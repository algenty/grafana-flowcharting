{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../node_modules/chartist/dist/chartist.js","webpack:///../node_modules/chroma-js/chroma.js","webpack:///../node_modules/pako/index.js","webpack:///../node_modules/pako/lib/deflate.js","webpack:///../node_modules/pako/lib/inflate.js","webpack:///../node_modules/pako/lib/utils/common.js","webpack:///../node_modules/pako/lib/utils/strings.js","webpack:///../node_modules/pako/lib/zlib/adler32.js","webpack:///../node_modules/pako/lib/zlib/constants.js","webpack:///../node_modules/pako/lib/zlib/crc32.js","webpack:///../node_modules/pako/lib/zlib/deflate.js","webpack:///../node_modules/pako/lib/zlib/gzheader.js","webpack:///../node_modules/pako/lib/zlib/inffast.js","webpack:///../node_modules/pako/lib/zlib/inflate.js","webpack:///../node_modules/pako/lib/zlib/inftrees.js","webpack:///../node_modules/pako/lib/zlib/messages.js","webpack:///../node_modules/pako/lib/zlib/trees.js","webpack:///../node_modules/pako/lib/zlib/zstream.js","webpack:///../node_modules/safe-eval/index.js","webpack:///../node_modules/tslib/tslib.es6.js","webpack:///../node_modules/vkbeautify/index.js","webpack:///../node_modules/vm-browserify/index.js","webpack:///../node_modules/webpack/buildin/global.js","webpack:///./drawio_custom.js","webpack:///./flowchartHandler.ts","webpack:///./flowchart_class.ts","webpack:///./flowchart_ctrl.ts","webpack:///./flowchart_options.ts","webpack:///./globals_class.ts","webpack:///./grafana_func.ts","webpack:///./graph_class.ts","webpack:///./inspect_options.ts","webpack:///./mapping_options.ts","webpack:///./metricHandler.ts","webpack:///./metric_class.ts","webpack:///./module.ts","webpack:///./mxgraph_custom.js","webpack:///./rule_class.ts","webpack:///./rulesHandler.ts","webpack:///./state_class.ts","webpack:///./statesHandler.ts","webpack:///./tooltipHandler.ts","webpack:///./utils_raw.js","webpack:///external \"@grafana/data\"","webpack:///external \"app/core/app_events\"","webpack:///external \"app/core/time_series2\"","webpack:///external \"app/core/utils/kbn\"","webpack:///external \"app/plugins/sdk\"","webpack:///external \"lodash\""],"names":["module","exports","executeLayout","graph","exec","animate","post","isEnabled","getModel","beginUpdate","e","endUpdate","executeLayoutList","layoutList","done","cells","getSelectionCells","i","length","layout","window","config","key","execute","getDefaultParent","csvToArray","text","re_valid","re_value","test","a","replace","m0","m1","m2","m3","undefined","push","importCsv","lines","split","allCells","dups","lookups","style","styles","stylename","labelname","labels","parentstyle","identity","parent","namespace","width","height","left","top","edgespacing","nodespacing","levelspacing","padding","view","bds","getGraphBounds","afterInsert","pt","getFreeInsertPoint","x0","x","y0","y","label","edges","link","ignore","index","charAt","substring","mxUtils","trim","idx","indexOf","value","sanitizeHtml","JSON","parse","parseFloat","Error","mxResources","get","keys","identityIndex","parentIndex","attribs","to","arrays","values","short","model","cell","id","getCell","exists","newCell","mxCell","mxGeometry","vertex","j","setAttributeForCell","tempLabel","getAttribute","labelChanged","tempStyle","replacePlaceholders","setGeometry","geometry","setStyle","setLinkForCell","fireEvent","mxEventObject","size","getPreferredSizeForCell","addCell","roots","slice","select","edge","insertEdge","bind","realCell","dataCell","tmp","from","refs","ref","fromlabel","tolabel","placeholders","invert","createCurrentEdgeStyle","remove","edgeLayout","mxParallelEdgeLayout","spacing","postProcess","geo","getCellGeometry","Math","round","snap","temp","validate","circleLayout","mxCircleLayout","resetEdges","circleLayoutIsVertexIgnored","isVertexIgnored","apply","arguments","treeLayout","mxCompactTreeLayout","levelDistance","edgeRouting","flowLayout","mxHierarchicalLayout","mxConstants","DIRECTION_WEST","DIRECTION_NORTH","intraCellSpacing","parallelEdgeSpacing","interRankCellSpacing","disableEdgeStyle","moveCells","organicLayout","mxFastOrganicLayout","forceConstant","organicLayoutIsVertexIgnored","console","log","anonymize","div","document","createElement","ignoredAnonymizedChars","anonymizeString","zeros","result","c","isNaN","parseInt","random","toLowerCase","String","fromCharCode","toUpperCase","join","replaceTextContent","elt","nodeValue","nodeType","NODETYPE_ELEMENT","firstChild","nextSibling","anonymizeHtml","html","innerHTML","queue","getLabel","isHtmlLabel","setValue","addExtFont","fontName","fontUrl","dontRemember","fontId","getElementById","Editor","GOOGLE_FONTS","mxClient","head","getElementsByTagName","appendChild","createTextNode","setAttribute","extFonts","notFound","name","url","customize","mxTooltipHandler","prototype","show","tip","destroyed","init","isNode","$div","place_tt","visibility","fit","$","mxEvent","addGestureListeners","evt","hideTooltip","delay","Graph","getTooltipForCell","hasTips","isReplacePlaceholders","ttDiv","className","ignored","builtInProperties","attrs","attributes","nodeName","sort","b","attrDiv","attrString","isCustomLink","htmlEntities","GF_tooltipHandler","tooltipHandler","gfDiv","getDiv","addMouseWheelListener","func","container","event","IS_FF","detail","wheelDelta","IS_NS","documentMode","addListener","IS_GC","IS_SF","evalCode","eval","atob","viewerCode","pako","require","vkbeautify","safeEval","stringToBytes","str","arr","Array","charCodeAt","bytesToString","encode","data","deflate","base64","encodeURIComponent","error","deflateRaw","btoa","removeLinebreaks","isencoded","node","parseXml","documentElement","diagrams","decode","getTextContent","inflateRaw","decodeURIComponent","xml","DOMParser","parser","parseFromString","createXmlDocument","async","loadXML","doc","implementation","createDocument","ActiveXObject","decodeFromUri","textContent","normalizeXml","sleep","ms","mess","Promise","resolve","setTimeout","uniqueID","chr4","toString","stringToJsRegex","RegExp","match","matchString","pattern","regex","minify","xmlmin","prettify","prettifyJSON","json","addScript","src","s","r","t","parentNode","insertBefore","loadJS","fname","code","loadFile","evalRaw","req","load","getStatus","getText","$loadFile","ajax","type","success","$evalFile","call","evalIt","getfileContent","request","fetch","response"],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA,MAAM,IAA0C;AAChD;AACA,IAAI,iCAAmB,EAAE,mCAAE;AAC3B;AACA,KAAK;AAAA,oGAAC;AACN,GAAG,MAAM,EAON;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,cAAc,EAAE;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,UAAU;AACvB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,eAAe;AACf,cAAc;AACd,cAAc;AACd,gBAAgB;AAChB,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,6BAA6B,WAAW;AACxC;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,sCAAsC,mBAAmB,GAAG,mBAAmB;AAC/E;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA,gCAAgC,qEAAqE;;AAErG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,uBAAuB,iBAAiB;AACxC;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,oBAAoB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA,wCAAwC;AACxC;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;;AAEzC;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;;AAEL,iBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC;;AAEhC;AACA;;AAEA,kBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;;AAEA,oBAAoB,4BAA4B;AAChD;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;;AAEhC;;AAEA;AACA;AACA;;AAEA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC;;AAEhC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sDAAsD,mBAAmB;AACzE;AACA,aAAa,uDAAuD;AACpE,aAAa,mDAAmD;AAChE,aAAa,uDAAuD;AACpE,aAAa;AACb;AACA;AACA;AACA,sBAAsB;AACtB,aAAa;AACb,sBAAsB;AACtB,aAAa;AACb,sBAAsB;AACtB,sBAAsB;AACtB;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC;;AAEhC;AACA;;AAEA;;AAEA,qBAAqB,4BAA4B;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;AACD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;AACD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kDAAkD;AAClD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA,CAAC;AACD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,CAAC;AACD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,cAAc,aAAa;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,QAAQ;AACrB,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,aAAa;AAC3B;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oCAAoC;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,qBAAqB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,GAAG;AACH,CAAC;AACD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK,kBAAkB,aAAa,KAAK;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,yBAAyB;AACvC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,EAAE;AACf,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,EAAE;AACf,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,EAAE;AACf,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,EAAE;AACf,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS,IAAI;AACb,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,KAAK;AACL,kCAAkC;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,yBAAyB;AACtC,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,cAAc;AACd;;AAEA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,CAAC;AACD,CAAC;AACD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA,CAAC;AACD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,CAAC;AACD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,CAAC;AACD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,CAAC;AACD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G;AAC5G;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gHAAgH;AAChH;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA,qHAAqH;AACrH;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH,CAAC;AACD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G;AAC5G;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS,GAAG,WAAW;AACvB,OAAO;;AAEP;;AAEA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mIAAmI;AACnI;AACA;AACA,SAAS;AACT,OAAO;AACP,0IAA0I;AAC1I;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA,mIAAmI;AACnI;AACA;AACA,SAAS;AACT,OAAO;AACP,0IAA0I;AAC1I;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH,CAAC;AACD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,CAAC;;AAED;;AAEA,CAAC;;;;;;;;;;;;;ACn6ID;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,KAA4D;AAChE,IAAI,SAC2B;AAC/B,CAAC,qBAAqB;;AAEtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA,iDAAiD,qBAAqB;AACtE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uHAAuH,iBAAiB;AACxI;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B,yCAAyC;AACxE;AACA;AACA;AACA;AACA,6BAA6B,iCAAiC,EAAE;AAChE,0BAA0B,mBAAmB,EAAE;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,aAAa;AAC3C;AACA,wCAAwC,8BAA8B;AACtE;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yEAAyE,kBAAkB,EAAE;AAC7F;AACA;AACA;AACA,oDAAoD,iBAAiB;AACrE;;AAEA;AACA,2BAA2B,OAAO;AAClC;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,mCAAmC,iBAAiB;AACpD;;AAEA;AACA,6CAA6C,mBAAmB;AAChE;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,4BAA4B,8BAA8B;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,uBAAuB,2BAA2B;AAClD,4BAA4B,+BAA+B;AAC3D,4BAA4B,+BAA+B;;AAE3D;AACA,oBAAoB,UAAU;AAC9B,mDAAmD,wBAAwB;AAC3E;AACA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,KAAK;AAC9B,gCAAgC,YAAY;AAC5C,gCAAgC,YAAY;AAC5C;AACA,qBAAqB,mCAAmC;AACxD;AACA,qBAAqB,WAAW;AAChC;AACA,qBAAqB,+CAA+C;AACpE;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,KAAK;AAC9B;AACA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4BAA4B,qBAAqB;AACjD,4BAA4B,uBAAuB;AACnD,4BAA4B,uBAAuB;AACnD;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4BAA4B,OAAO;AACnC,0BAA0B,UAAU;AACpC,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F,kGAAkG;AAClG,kGAAkG;AAClG,kGAAkG;AAClG,kGAAkG;AAClG,kGAAkG;AAClG;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;AAOA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kCAAkC,EAAE,aAAa,EAAE;AACnD,mCAAmC,EAAE,aAAa,EAAE;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,OAAO;AAC9B,uBAAuB,OAAO;AAC9B;AACA,sBAAsB,UAAU;AAChC,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;AAOA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;;;;;;AAOA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6BAA6B,qBAAqB;AAClD,6BAA6B,uBAAuB;AACpD,6BAA6B,uBAAuB;AACpD;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4BAA4B,OAAO;AACnC,0BAA0B,UAAU;AACpC,wBAAwB,UAAU;AAClC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,0FAA0F;AAC1F,kGAAkG;AAClG,kGAAkG;AAClG,kGAAkG;AAClG,kGAAkG;AAClG,kGAAkG;AAClG;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;AAOA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,kBAAkB;AACtD;AACA;;AAEA;AACA,kCAAkC,sBAAsB;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mEAAmE;AACnE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;AAOA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;;AAEA;;AAEA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;;AAEA;;AAEA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;AAOA,wCAAwC,6BAA6B;AACrE,wCAAwC,uCAAuC;;AAE/E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,wCAAwC;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK,EAAE,EAAE;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;AAMA;AACA;AACA,qDAAqD,iBAAiB;AACtE;;AAEA,sCAAsC,wBAAwB;AAC9D;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,kCAAkC;AAC/D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA,4BAA4B,6BAA6B;AACzD;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oCAAoC,aAAa;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0BAA0B;AAClE,wCAAwC,0BAA0B;AAClE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,mDAAmD;AACnD,+DAA+D;AAC/D,+DAA+D;AAC/D;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA,yDAAyD,YAAY;AACrE,SAAS;AACT;AACA,yDAAyD,YAAY;AACrE,SAAS;AACT;AACA;;AAEA,gCAAgC,gCAAgC;AAChE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,qDAAqD,UAAU,EAAE,EAAE;AAC1F;AACA,mDAAmD,cAAc,EAAE;AACnE,wCAAwC,iBAAiB,EAAE;AAC3D;AACA,0CAA0C,uBAAuB,EAAE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;;AAET,uBAAuB,gBAAgB;AACvC;AACA;AACA,iCAAiC,YAAY;AAC7C,oCAAoC,YAAY;AAChD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,UAAU;AACpD,uCAAuC,UAAU;;AAEjD;AACA;AACA;AACA;AACA;AACA,kGAAkG;AAClG,sGAAsG;AACtG;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,mBAAmB;AACvD,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC;AACrC;;AAEA,+BAA+B,sBAAsB;;AAErD;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;;AAEA,sCAAsC,yBAAyB;;AAE/D;;AAEA;;AAEA;AACA;AACA,kCAAkC,kBAAkB,EAAE,OAAO,UAAU;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,iBAAiB;AAC3E;;AAEA;AACA;AACA,aAAa;AACb,6BAA6B,KAAK;AAClC;AACA;AACA;AACA;AACA,0DAA0D,4BAA4B,EAAE;AACxF,2DAA2D,mCAAmC,EAAE;AAChG,0DAA0D,wBAAwB,EAAE;AACpF;AACA,mDAAmD,UAAU;AAC7D;AACA,uDAAuD,KAAK;AAC5D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,aAAa;AACb,8CAA8C,UAAU;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,aAAa;AACpD;;AAEA;AACA;;AAEA,aAAa;AACb;;AAEA,aAAa;AACb;AACA;AACA,0EAA0E,2CAA2C,EAAE;;AAEvH,aAAa,OAAO;AACpB;AACA;AACA;AACA,0EAA0E,yBAAyB;AACnG;AACA;AACA,iBAAiB;AACjB;AACA;AACA,mDAAmD,aAAa,EAAE;AAClE;;AAEA;AACA,kDAAkD,iBAAiB,EAAE;AACrE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;AAKA;AACA;;AAEA;AACA,0CAA0C,uBAAuB,EAAE;AACnE;AACA;AACA,+CAA+C,gBAAgB,EAAE;AACjE;AACA,uDAAuD,4CAA4C,EAAE;AACrG;AACA;AACA,SAAS;AACT;AACA,iDAAiD,gBAAgB,EAAE;AACnE;AACA,uDAAuD,gFAAgF,EAAE;AACzI;AACA;AACA,SAAS;AACT;AACA;AACA,iDAAiD,gBAAgB,EAAE;AACnE;AACA,uDAAuD,8HAA8H,EAAE;AACvL;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;;AAEA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA;AACA;AACA,UAAU;;AAEV,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV,+BAA+B,UAAU;AACzC,mCAAmC,oBAAoB;AACvD,mCAAmC,sBAAsB;AACzD,kCAAkC,sBAAsB;AACxD,iCAAiC,0CAA0C;AAC3E,kCAAkC,qFAAqF;AACvH,+BAA+B,4CAA4C;AAC3E;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;;AAEA;AACA,8BAA8B,kBAAkB;AAChD;AACA;AACA;;AAEA;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;;AAEA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,0BAA0B;;AAEzD;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB,KAAK;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C,kCAAkC,aAAa;AAC/C;AACA;AACA,SAAS;;AAET;;AAEA,yCAAyC,6BAA6B;;AAEtE;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sDAAsD,YAAY,EAAE;;AAEpE,wBAAwB,kBAAkB;;AAE1C;;AAEA,uCAAuC;AACvC;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;;AAEA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;;AAEA,4CAA4C;AAC5C;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;;AAEA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;;AAEA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA,kEAAkE,YAAY,EAAE;AAChF;AACA,2BAA2B,8BAA8B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;;;;AAKA;AACA,4BAA4B,kEAAkE;AAC9F,0BAA0B;AAC1B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD,qBAAqB;AAC7E;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;;;AAgBA;;;;;;;;;;;AAWA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;;;;;;;;;;;;ACxpGD;AACa;;AAEb,gBAAgB,mBAAO,CAAC,oEAAoB;;AAE5C,gBAAgB,mBAAO,CAAC,0DAAe;AACvC,gBAAgB,mBAAO,CAAC,0DAAe;AACvC,gBAAgB,mBAAO,CAAC,wEAAsB;;AAE9C;;AAEA;;AAEA;;;;;;;;;;;;;ACba;;;AAGb,mBAAmB,mBAAO,CAAC,gEAAgB;AAC3C,mBAAmB,mBAAO,CAAC,gEAAgB;AAC3C,mBAAmB,mBAAO,CAAC,kEAAiB;AAC5C,mBAAmB,mBAAO,CAAC,kEAAiB;AAC5C,mBAAmB,mBAAO,CAAC,gEAAgB;;AAE3C;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA,8BAA8B;AAC9B;AACA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,eAAe;;AAElB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB;AAClB,mBAAmB;AACnB,sBAAsB;AACtB,mBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,cAAc;;AAEjC;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qBAAqB,yCAAyC;;AAE9D;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;;;;;;;;;;;AC/Ya;;;AAGb,mBAAmB,mBAAO,CAAC,gEAAgB;AAC3C,mBAAmB,mBAAO,CAAC,gEAAgB;AAC3C,mBAAmB,mBAAO,CAAC,kEAAiB;AAC5C,mBAAmB,mBAAO,CAAC,oEAAkB;AAC7C,mBAAmB,mBAAO,CAAC,kEAAiB;AAC5C,mBAAmB,mBAAO,CAAC,gEAAgB;AAC3C,mBAAmB,mBAAO,CAAC,kEAAiB;;AAE5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA,8BAA8B;AAC9B;AACA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG,eAAe;;AAElB;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB,mBAAmB;AACnB,sBAAsB;AACtB,mBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sDAAsD;;AAEtD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,kEAAkE;;AAEvF;;AAEA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qBAAqB,yCAAyC;;AAE9D;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;;;;;;;;;;;ACtaa;;;AAGb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,UAAU;;AAE5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,4BAA4B,YAAY;AACxC,qBAAqB,8BAA8B;AACnD;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACxGA;AACa;;;AAGb,YAAY,mBAAO,CAAC,0DAAU;;;AAG9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK,wCAAwC,EAAE,aAAa,sBAAsB;AAClF,KAAK,oDAAoD,EAAE,aAAa,0BAA0B;;;AAGlG;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA,kCAAkC;;;AAGlC;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,SAAS;AAC/B;AACA;AACA,mBAAmB,qBAAqB,UAAU;;AAElD;AACA;AACA,oBAAoB,0BAA0B,gBAAgB,UAAU;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,0BAA0B,UAAU;;AAExD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,kBAAkB;;AAE3C;AACA;AACA,kDAAkD,OAAO;;AAEzD;AACA;AACA,gBAAgB,YAAY;;AAE5B;AACA;AACA,kBAAkB,YAAY;;AAE9B;AACA;;;;;;;;;;;;;AC1La;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;;AAGA;;;;;;;;;;;;;AClDa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACnEa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;;AAEA,sBAAsB;AACtB;;;AAGA;;;;;;;;;;;;;AC1Da;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,mBAAO,CAAC,iEAAiB;AACvC,cAAc,mBAAO,CAAC,uDAAS;AAC/B,cAAc,mBAAO,CAAC,2DAAW;AACjC,cAAc,mBAAO,CAAC,uDAAS;AAC/B,cAAc,mBAAO,CAAC,6DAAY;;AAElC;AACA;;;AAGA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;AAChC;;;AAGA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;;AAE1B,mBAAmB;;AAEnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,sBAAsB,qBAAqB,cAAc,EAAE;;;AAG/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B,kBAAkB,UAAU;;AAE5B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,wBAAwB;AACxB,YAAY;AACZ,UAAU;AACV,+BAA+B;AAC/B,gCAAgC;AAChC;AACA;;AAEA,sBAAsB;;AAEtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0BAA0B;;AAE3D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,aAAa;;AAEb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;;AAEnE;AACA,yDAAyD;AACzD;;AAEA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,0DAA0D;AAC1D;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,aAAa;;AAEb;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO,EAAE;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;;AAEA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,mBAAmB;;AAEnB;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO,EAAE;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oEAAoE;AACpE;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,0DAA0D;AAC1D;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,mBAAmB;AACnB,kBAAkB;AAClB,0BAA0B;AAC1B,4BAA4B;AAC5B,uBAAuB;AACvB,mBAAmB;AACnB,gBAAgB;AAChB,qBAAqB;AACrB,mBAAmB;AACnB,2BAA2B;AAC3B,uBAAuB;;AAEvB,kBAAkB;AAClB,kBAAkB;AAClB,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;;AAEnB,iBAAiB;AACjB,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB,sBAAsB;AACtB,2BAA2B;AAC3B,oBAAoB;AACpB,uBAAuB;AACvB,qBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB,oBAAoB;;AAEpB;AACA;;AAEA,sBAAsB;;AAEtB;;AAEA;;AAEA,2CAA2C;AAC3C,6CAA6C;AAC7C,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB,uBAAuB;AACvB,uBAAuB;;AAEvB;AACA;AACA;;AAEA,0BAA0B;AAC1B,+CAA+C;AAC/C;;AAEA,oBAAoB;AACpB,oBAAoB;AACpB;AACA;AACA;;AAEA,gDAAgD;AAChD;AACA;AACA;;AAEA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB,sBAAsB;AACtB,mBAAmB;AACnB,kBAAkB;;;AAGlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,6BAA6B,uBAAuB;AACpD,8BAA8B,uBAAuB;AACrD;AACA;AACA;;;AAGA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB;;AAErB,sCAAsC;;AAEtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;;AAEA;AACA;;AAEA,uBAAuB;AACvB,qBAAqB;AACrB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B,2BAA2B,aAAa;AACxC,oBAAoB,qBAAqB;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oDAAoD;AACpD;AACA;;AAEA,aAAa;;AAEb;AACA;AACA,qBAAqB;AACrB,yBAAyB;AACzB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACj1Da;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACzDa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,WAAW;AACX,WAAW;AACX,UAAU;AACV,UAAU;AACV;AACA,WAAW;AACX;AACA,YAAY;AACZ,YAAY;AACZ,YAAY;AACZ;AACA,eAAe;AACf,WAAW;AACX,WAAW;AACX,YAAY;AACZ,YAAY;AACZ,YAAY;AACZ,YAAY;AACZ,WAAW;AACX,SAAS;AACT;AACA,UAAU;AACV,WAAW;AACX,WAAW;AACX;;;AAGA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,gCAAgC;AAChC;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,mBAAmB;AACnB,qCAAqC;AACrC;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,mBAAmB;AACnB;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,qBAAqB;AACrB,uCAAuC;AACvC;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,mBAAmB;AACnB,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,kBAAkB;AAClB;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxVa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,mBAAO,CAAC,iEAAiB;AAC7C,oBAAoB,mBAAO,CAAC,2DAAW;AACvC,oBAAoB,mBAAO,CAAC,uDAAS;AACrC,oBAAoB,mBAAO,CAAC,2DAAW;AACvC,oBAAoB,mBAAO,CAAC,6DAAY;;AAExC;AACA;AACA;;AAEA;AACA;;;AAGA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;;AAGA,gBAAgB;AAChB,iBAAiB;AACjB,gBAAgB;AAChB,cAAc;AACd,iBAAiB;AACjB,iBAAiB;AACjB,gBAAgB;AAChB,mBAAmB;AACnB,gBAAgB;AAChB,mBAAmB;AACnB,iBAAiB;AACjB,qBAAqB;AACrB,uBAAuB;AACvB,uBAAuB;AACvB,sBAAsB;AACtB,qBAAqB;AACrB,sBAAsB;AACtB,wBAAwB;AACxB,yBAAyB;AACzB,yBAAyB;AACzB,wBAAwB;AACxB,2BAA2B;AAC3B,yBAAyB;AACzB,4BAA4B;AAC5B,0BAA0B;AAC1B,wBAAwB;AACxB,kBAAkB;AAClB,mBAAmB;AACnB,iBAAiB;AACjB,gBAAgB;AAChB,gBAAgB;AAChB,iBAAiB;;AAEjB;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,gBAAgB;AAChB,oBAAoB;AACpB,gBAAgB;AAChB,wBAAwB;AACxB,iBAAiB;AACjB,gBAAgB;AAChB,iBAAiB;AACjB,iBAAiB;AACjB;AACA,mBAAmB;;AAEnB;AACA,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,qBAAqB;;AAErB;AACA,gBAAgB;AAChB,gBAAgB;;AAEhB;AACA,kBAAkB;AAClB,kBAAkB;;AAElB;AACA,iBAAiB;;AAEjB;AACA,sBAAsB;AACtB,uBAAuB;AACvB,mBAAmB;AACnB,oBAAoB;;AAEpB;AACA,iBAAiB;AACjB,gBAAgB;AAChB,iBAAiB;AACjB,gBAAgB;AAChB,mBAAmB;;AAEnB,mCAAmC;AACnC,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA,yCAAyC;AACzC,qBAAqB;AACrB,sBAAsB;AACtB,gBAAgB;AAChB,gBAAgB;AAChB,eAAe;AACf;;AAEA;AACA;;AAEA,6BAA6B,uBAAuB;AACpD;AACA;AACA,gBAAgB;AAChB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,uBAAuB;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,uBAAuB;AACrC,sBAAsB;;AAEtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;;AAEpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uBAAuB,uBAAuB;AAC9C,uBAAuB,uBAAuB;AAC9C,uBAAuB,uBAAuB;AAC9C,uBAAuB,uBAAuB;;AAE9C,uEAAuE,UAAU;;AAEjF;AACA;AACA,sBAAsB,uBAAuB;;AAE7C,uEAAuE,UAAU;;AAEjF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD,sCAAsC,qBAAqB;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB,WAAW;AACX,UAAU;AACV,iBAAiB;AACjB,WAAW;AACX,WAAW;AACX,gBAAgB;AAChB,WAAW;AACX,WAAW;AACX;AACA,eAAe;AACf,mCAAmC;AACnC,aAAa;AACb,mCAAmC;AACnC,UAAU;AACV,UAAU;AACV,+BAA+B;AAC/B;;AAEA,QAAQ;;AAER;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,qBAAqB,EAAE;;;AAGnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,iBAAiB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,aAAa;AACzC,4BAA4B,aAAa;AACzC,2BAA2B,iBAAiB;AAC5C,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,oEAAoE;AACpE;AACA;AACA;;AAEA,sCAAsC,OAAO;AAC7C;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,OAAO;;AAExC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,kEAAkE;AAClE;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,OAAO;AACzD;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,oEAAoE;AACpE;AACA;AACA;;AAEA,oCAAoC,OAAO;AAC3C;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,OAAO;AACzD;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,qBAAqB;AAC3D,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA,aAAa;AACb,qCAAqC,kBAAkB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA;AACA,SAAS;AACT,iCAAiC,kBAAkB;AACnD;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,uBAAuB;AACpD;AACA,+BAA+B,uBAAuB;;AAEtD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6DAA6D,uBAAuB;AACpF;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnhDa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,iEAAiB;;AAErC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;;AAEzB,cAAc;AACd,cAAc;AACd,uBAAuB;AACvB,eAAe;AACf,eAAe;AACf,eAAe;AACf,eAAe;AACf,eAAe;AACf,eAAe;AACf,WAAW;AACX,WAAW;AACX,UAAU;AACV,WAAW;AACX,WAAW;AACX,kBAAkB;AAClB;AACA,iBAAiB;AACjB,UAAU;AACV,2CAA2C,eAAe;AAC1D,0CAA0C,eAAe;AACzD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA,qBAAqB,UAAU;AAC/B,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA,kBAAkB;AAClB,sCAAsC,2BAA2B;AACjE,uCAAuC;AACvC,wCAAwC;AACxC;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA,eAAe,WAAW;AAC1B,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;;AAEA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,GAAG,OAAO;AACV;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX,UAAU;AACV,YAAY;AACZ,qBAAqB;AACrB,cAAc;AACd,WAAW;AACX,WAAW;AACX,mBAAmB;AACnB,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtVa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/Ba;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,YAAY,mBAAO,CAAC,iEAAiB;;AAErC;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;;;AAGA,oBAAoB,sBAAsB,qBAAqB,cAAc,EAAE;;AAE/E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA,kCAAkC;AAClC,iCAAiC;AACjC,iCAAiC;AACjC,4BAA4B;AAC5B,iCAAiC;;AAEjC;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA,2BAA2B;AAC3B,oBAAoB;AACpB,6BAA6B;AAC7B;;;;AAIA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,WAAW;AACX,WAAW;AACX,YAAY;AACZ,QAAQ;AACR,mBAAmB;;AAEnB,gBAAgB,kBAAkB;AAClC;AACA;;AAEA;AACA;AACA;AACA,+CAA+C;;AAE/C,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,UAAU,EAAE;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;;AAE/B;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C,uBAAuB;AACvB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,mBAAmB;AACnB,qBAAqB;AACrB;AACA,0CAA0C;AAC1C,eAAe;AACf,WAAW;AACX,QAAQ;;AAER;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,gBAAgB;AAC7B;AACA,oBAAoB,UAAU;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ;AACR,WAAW;AACX,aAAa;AACb,WAAW;AACX,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA,eAAe,8BAA8B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA,eAAe,8BAA8B;AAC7C;AACA;AACA;AACA;AACA,aAAa;AACb,QAAQ,gBAAgB;AACxB;AACA,eAAe,oCAAoC;AACnD;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,kBAAkB;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA,aAAa,aAAa,QAAQ,iCAAiC;AACnE,aAAa,aAAa,QAAQ,iCAAiC;AACnE,aAAa,cAAc,OAAO,+BAA+B;;AAEjE;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,eAAe;AACf,kBAAkB;AAClB;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,YAAY;AACZ;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;;AAEtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA,WAAW;AACX,SAAS;AACT,aAAa;AACb,WAAW;AACX,YAAY;;AAEZ;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA,OAAO;AACP;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,kCAAkC;AAClC;AACA,eAAe;AACf;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA;AACA,oCAAoC;AACpC;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,oBAAoB;AACpB,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,WAAW;AACxB;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,QAAQ,OAAO,wBAAwB;;AAE9E;AACA;AACA;AACA,eAAe;AACf;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA,8BAA8B;;AAE9B,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,mBAAmB;AACnB;AACA,QAAQ;AACR,mBAAmB;AACnB,aAAa;;AAEb,wCAAwC;;AAExC,gBAAgB;AAChB,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA,gDAAgD;;AAEhD,aAAa,eAAe;AAC5B;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;;AAEA,KAAK;;AAEL,+BAA+B,kCAAkC;AACjE;;AAEA,KAAK;AACL;;AAEA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,mBAAmB;AACnB;AACA,QAAQ;AACR,mBAAmB;AACnB,aAAa;;AAEb,wCAAwC;;AAExC,gBAAgB;AAChB,oBAAoB;AACpB,oBAAoB;;AAEpB,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA,aAAa,eAAe;AAC5B;AACA;;AAEA;AACA;;AAEA,KAAK;AACL,UAAU,iCAAiC,EAAE;;AAE7C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,gCAAgC;AAChC,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;;AAEA,wCAAwC;AACxC;;AAEA,wCAAwC;AACxC;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,IAAI,MAAM,GAAG,MAAM,GAAG;AAChD;AACA;AACA;AACA,SAAS,IAAI,KAAK,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,IAAI,MAAM,IAAI;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iBAAiB;AACjB,WAAW;AACX;AACA,wDAAwD;AACxD,uCAAuC;AACvC;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iBAAiB;AACjB,WAAW;AACX;AACA,4BAA4B;AAC5B,sBAAsB;;AAEtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,wBAAwB;;AAE1D,GAAG;AACH;AACA,4CAA4C;AAC5C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,kBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrsCa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC9CA,SAAS,mBAAO,CAAC,kDAAI;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,+DAA+D;AAC/D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;;AAEO;AACP;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAE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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,aAAa;AACb;;AAEA;;AAEA,2BAA2B,GAAG;AAC9B,gBAAgB,KAAK;AACrB,gBAAgB,SAAS;AACzB,gBAAgB,KAAK;AACrB;AACA;AACA,qBAAqB,GAAG;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,OAAO;;AAElB,UAAU;AACV;AACA,IAAI;AACJ,UAAU;AACV;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,GAAG;AAC7B;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,wBAAwB,GAAG;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,GAAG;AAC1B;AACA;AACA;;AAEA;AACA,yBAAyB,GAAG;AAC5B,yBAAyB,GAAG;AAC5B,wBAAwB,GAAG;AAC3B,yBAAyB,GAAG;;AAE5B;AACA;AACA,uBAAuB,GAAG;AAC1B;;AAEA,mBAAmB,GAAG;AACtB,mBAAmB,GAAG;;AAEtB;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,GAAG;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,GAAG;AACpB,iBAAiB,GAAG;AACpB;;AAEA,mBAAmB,GAAG;AACtB;AACA;;AAEA;;AAEA,oCAAoC,GAAG;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,OAAO;AAClB;AACA;AA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","file":"module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./module.ts\");\n","(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module unless amdModuleId is set\n    define('Chartist', [], function () {\n      return (root['Chartist'] = factory());\n    });\n  } else if (typeof module === 'object' && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    root['Chartist'] = factory();\n  }\n}(this, function () {\n\n/* Chartist.js 0.11.4\n * Copyright  2019 Gion Kunz\n * Free to use under either the WTFPL license or the MIT license.\n * https://raw.githubusercontent.com/gionkunz/chartist-js/master/LICENSE-WTFPL\n * https://raw.githubusercontent.com/gionkunz/chartist-js/master/LICENSE-MIT\n */\n/**\n * The core module of Chartist that is mainly providing static functions and higher level functions for chart modules.\n *\n * @module Chartist.Core\n */\nvar Chartist = {\n  version: '0.11.4'\n};\n\n(function (globalRoot, Chartist) {\n  'use strict';\n\n  var window = globalRoot.window;\n  var document = globalRoot.document;\n\n  /**\n   * This object contains all namespaces used within Chartist.\n   *\n   * @memberof Chartist.Core\n   * @type {{svg: string, xmlns: string, xhtml: string, xlink: string, ct: string}}\n   */\n  Chartist.namespaces = {\n    svg: 'http://www.w3.org/2000/svg',\n    xmlns: 'http://www.w3.org/2000/xmlns/',\n    xhtml: 'http://www.w3.org/1999/xhtml',\n    xlink: 'http://www.w3.org/1999/xlink',\n    ct: 'http://gionkunz.github.com/chartist-js/ct'\n  };\n\n  /**\n   * Helps to simplify functional style code\n   *\n   * @memberof Chartist.Core\n   * @param {*} n This exact value will be returned by the noop function\n   * @return {*} The same value that was provided to the n parameter\n   */\n  Chartist.noop = function (n) {\n    return n;\n  };\n\n  /**\n   * Generates a-z from a number 0 to 26\n   *\n   * @memberof Chartist.Core\n   * @param {Number} n A number from 0 to 26 that will result in a letter a-z\n   * @return {String} A character from a-z based on the input number n\n   */\n  Chartist.alphaNumerate = function (n) {\n    // Limit to a-z\n    return String.fromCharCode(97 + n % 26);\n  };\n\n  /**\n   * Simple recursive object extend\n   *\n   * @memberof Chartist.Core\n   * @param {Object} target Target object where the source will be merged into\n   * @param {Object...} sources This object (objects) will be merged into target and then target is returned\n   * @return {Object} An object that has the same reference as target but is extended and merged with the properties of source\n   */\n  Chartist.extend = function (target) {\n    var i, source, sourceProp;\n    target = target || {};\n\n    for (i = 1; i < arguments.length; i++) {\n      source = arguments[i];\n      for (var prop in source) {\n        sourceProp = source[prop];\n        if (typeof sourceProp === 'object' && sourceProp !== null && !(sourceProp instanceof Array)) {\n          target[prop] = Chartist.extend(target[prop], sourceProp);\n        } else {\n          target[prop] = sourceProp;\n        }\n      }\n    }\n\n    return target;\n  };\n\n  /**\n   * Replaces all occurrences of subStr in str with newSubStr and returns a new string.\n   *\n   * @memberof Chartist.Core\n   * @param {String} str\n   * @param {String} subStr\n   * @param {String} newSubStr\n   * @return {String}\n   */\n  Chartist.replaceAll = function(str, subStr, newSubStr) {\n    return str.replace(new RegExp(subStr, 'g'), newSubStr);\n  };\n\n  /**\n   * Converts a number to a string with a unit. If a string is passed then this will be returned unmodified.\n   *\n   * @memberof Chartist.Core\n   * @param {Number} value\n   * @param {String} unit\n   * @return {String} Returns the passed number value with unit.\n   */\n  Chartist.ensureUnit = function(value, unit) {\n    if(typeof value === 'number') {\n      value = value + unit;\n    }\n\n    return value;\n  };\n\n  /**\n   * Converts a number or string to a quantity object.\n   *\n   * @memberof Chartist.Core\n   * @param {String|Number} input\n   * @return {Object} Returns an object containing the value as number and the unit as string.\n   */\n  Chartist.quantity = function(input) {\n    if (typeof input === 'string') {\n      var match = (/^(\\d+)\\s*(.*)$/g).exec(input);\n      return {\n        value : +match[1],\n        unit: match[2] || undefined\n      };\n    }\n    return { value: input };\n  };\n\n  /**\n   * This is a wrapper around document.querySelector that will return the query if it's already of type Node\n   *\n   * @memberof Chartist.Core\n   * @param {String|Node} query The query to use for selecting a Node or a DOM node that will be returned directly\n   * @return {Node}\n   */\n  Chartist.querySelector = function(query) {\n    return query instanceof Node ? query : document.querySelector(query);\n  };\n\n  /**\n   * Functional style helper to produce array with given length initialized with undefined values\n   *\n   * @memberof Chartist.Core\n   * @param length\n   * @return {Array}\n   */\n  Chartist.times = function(length) {\n    return Array.apply(null, new Array(length));\n  };\n\n  /**\n   * Sum helper to be used in reduce functions\n   *\n   * @memberof Chartist.Core\n   * @param previous\n   * @param current\n   * @return {*}\n   */\n  Chartist.sum = function(previous, current) {\n    return previous + (current ? current : 0);\n  };\n\n  /**\n   * Multiply helper to be used in `Array.map` for multiplying each value of an array with a factor.\n   *\n   * @memberof Chartist.Core\n   * @param {Number} factor\n   * @returns {Function} Function that can be used in `Array.map` to multiply each value in an array\n   */\n  Chartist.mapMultiply = function(factor) {\n    return function(num) {\n      return num * factor;\n    };\n  };\n\n  /**\n   * Add helper to be used in `Array.map` for adding a addend to each value of an array.\n   *\n   * @memberof Chartist.Core\n   * @param {Number} addend\n   * @returns {Function} Function that can be used in `Array.map` to add a addend to each value in an array\n   */\n  Chartist.mapAdd = function(addend) {\n    return function(num) {\n      return num + addend;\n    };\n  };\n\n  /**\n   * Map for multi dimensional arrays where their nested arrays will be mapped in serial. The output array will have the length of the largest nested array. The callback function is called with variable arguments where each argument is the nested array value (or undefined if there are no more values).\n   *\n   * @memberof Chartist.Core\n   * @param arr\n   * @param cb\n   * @return {Array}\n   */\n  Chartist.serialMap = function(arr, cb) {\n    var result = [],\n        length = Math.max.apply(null, arr.map(function(e) {\n          return e.length;\n        }));\n\n    Chartist.times(length).forEach(function(e, index) {\n      var args = arr.map(function(e) {\n        return e[index];\n      });\n\n      result[index] = cb.apply(null, args);\n    });\n\n    return result;\n  };\n\n  /**\n   * This helper function can be used to round values with certain precision level after decimal. This is used to prevent rounding errors near float point precision limit.\n   *\n   * @memberof Chartist.Core\n   * @param {Number} value The value that should be rounded with precision\n   * @param {Number} [digits] The number of digits after decimal used to do the rounding\n   * @returns {number} Rounded value\n   */\n  Chartist.roundWithPrecision = function(value, digits) {\n    var precision = Math.pow(10, digits || Chartist.precision);\n    return Math.round(value * precision) / precision;\n  };\n\n  /**\n   * Precision level used internally in Chartist for rounding. If you require more decimal places you can increase this number.\n   *\n   * @memberof Chartist.Core\n   * @type {number}\n   */\n  Chartist.precision = 8;\n\n  /**\n   * A map with characters to escape for strings to be safely used as attribute values.\n   *\n   * @memberof Chartist.Core\n   * @type {Object}\n   */\n  Chartist.escapingMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    '\\'': '&#039;'\n  };\n\n  /**\n   * This function serializes arbitrary data to a string. In case of data that can't be easily converted to a string, this function will create a wrapper object and serialize the data using JSON.stringify. The outcoming string will always be escaped using Chartist.escapingMap.\n   * If called with null or undefined the function will return immediately with null or undefined.\n   *\n   * @memberof Chartist.Core\n   * @param {Number|String|Object} data\n   * @return {String}\n   */\n  Chartist.serialize = function(data) {\n    if(data === null || data === undefined) {\n      return data;\n    } else if(typeof data === 'number') {\n      data = ''+data;\n    } else if(typeof data === 'object') {\n      data = JSON.stringify({data: data});\n    }\n\n    return Object.keys(Chartist.escapingMap).reduce(function(result, key) {\n      return Chartist.replaceAll(result, key, Chartist.escapingMap[key]);\n    }, data);\n  };\n\n  /**\n   * This function de-serializes a string previously serialized with Chartist.serialize. The string will always be unescaped using Chartist.escapingMap before it's returned. Based on the input value the return type can be Number, String or Object. JSON.parse is used with try / catch to see if the unescaped string can be parsed into an Object and this Object will be returned on success.\n   *\n   * @memberof Chartist.Core\n   * @param {String} data\n   * @return {String|Number|Object}\n   */\n  Chartist.deserialize = function(data) {\n    if(typeof data !== 'string') {\n      return data;\n    }\n\n    data = Object.keys(Chartist.escapingMap).reduce(function(result, key) {\n      return Chartist.replaceAll(result, Chartist.escapingMap[key], key);\n    }, data);\n\n    try {\n      data = JSON.parse(data);\n      data = data.data !== undefined ? data.data : data;\n    } catch(e) {}\n\n    return data;\n  };\n\n  /**\n   * Create or reinitialize the SVG element for the chart\n   *\n   * @memberof Chartist.Core\n   * @param {Node} container The containing DOM Node object that will be used to plant the SVG element\n   * @param {String} width Set the width of the SVG element. Default is 100%\n   * @param {String} height Set the height of the SVG element. Default is 100%\n   * @param {String} className Specify a class to be added to the SVG element\n   * @return {Object} The created/reinitialized SVG element\n   */\n  Chartist.createSvg = function (container, width, height, className) {\n    var svg;\n\n    width = width || '100%';\n    height = height || '100%';\n\n    // Check if there is a previous SVG element in the container that contains the Chartist XML namespace and remove it\n    // Since the DOM API does not support namespaces we need to manually search the returned list http://www.w3.org/TR/selectors-api/\n    Array.prototype.slice.call(container.querySelectorAll('svg')).filter(function filterChartistSvgObjects(svg) {\n      return svg.getAttributeNS(Chartist.namespaces.xmlns, 'ct');\n    }).forEach(function removePreviousElement(svg) {\n      container.removeChild(svg);\n    });\n\n    // Create svg object with width and height or use 100% as default\n    svg = new Chartist.Svg('svg').attr({\n      width: width,\n      height: height\n    }).addClass(className);\n\n    svg._node.style.width = width;\n    svg._node.style.height = height;\n\n    // Add the DOM node to our container\n    container.appendChild(svg._node);\n\n    return svg;\n  };\n\n  /**\n   * Ensures that the data object passed as second argument to the charts is present and correctly initialized.\n   *\n   * @param  {Object} data The data object that is passed as second argument to the charts\n   * @return {Object} The normalized data object\n   */\n  Chartist.normalizeData = function(data, reverse, multi) {\n    var labelCount;\n    var output = {\n      raw: data,\n      normalized: {}\n    };\n\n    // Check if we should generate some labels based on existing series data\n    output.normalized.series = Chartist.getDataArray({\n      series: data.series || []\n    }, reverse, multi);\n\n    // If all elements of the normalized data array are arrays we're dealing with\n    // multi series data and we need to find the largest series if they are un-even\n    if (output.normalized.series.every(function(value) {\n        return value instanceof Array;\n      })) {\n      // Getting the series with the the most elements\n      labelCount = Math.max.apply(null, output.normalized.series.map(function(series) {\n        return series.length;\n      }));\n    } else {\n      // We're dealing with Pie data so we just take the normalized array length\n      labelCount = output.normalized.series.length;\n    }\n\n    output.normalized.labels = (data.labels || []).slice();\n    // Padding the labels to labelCount with empty strings\n    Array.prototype.push.apply(\n      output.normalized.labels,\n      Chartist.times(Math.max(0, labelCount - output.normalized.labels.length)).map(function() {\n        return '';\n      })\n    );\n\n    if(reverse) {\n      Chartist.reverseData(output.normalized);\n    }\n\n    return output;\n  };\n\n  /**\n   * This function safely checks if an objects has an owned property.\n   *\n   * @param {Object} object The object where to check for a property\n   * @param {string} property The property name\n   * @returns {boolean} Returns true if the object owns the specified property\n   */\n  Chartist.safeHasProperty = function(object, property) {\n    return object !== null &&\n      typeof object === 'object' &&\n      object.hasOwnProperty(property);\n  };\n\n  /**\n   * Checks if a value is considered a hole in the data series.\n   *\n   * @param {*} value\n   * @returns {boolean} True if the value is considered a data hole\n   */\n  Chartist.isDataHoleValue = function(value) {\n    return value === null ||\n      value === undefined ||\n      (typeof value === 'number' && isNaN(value));\n  };\n\n  /**\n   * Reverses the series, labels and series data arrays.\n   *\n   * @memberof Chartist.Core\n   * @param data\n   */\n  Chartist.reverseData = function(data) {\n    data.labels.reverse();\n    data.series.reverse();\n    for (var i = 0; i < data.series.length; i++) {\n      if(typeof(data.series[i]) === 'object' && data.series[i].data !== undefined) {\n        data.series[i].data.reverse();\n      } else if(data.series[i] instanceof Array) {\n        data.series[i].reverse();\n      }\n    }\n  };\n\n  /**\n   * Convert data series into plain array\n   *\n   * @memberof Chartist.Core\n   * @param {Object} data The series object that contains the data to be visualized in the chart\n   * @param {Boolean} [reverse] If true the whole data is reversed by the getDataArray call. This will modify the data object passed as first parameter. The labels as well as the series order is reversed. The whole series data arrays are reversed too.\n   * @param {Boolean} [multi] Create a multi dimensional array from a series data array where a value object with `x` and `y` values will be created.\n   * @return {Array} A plain array that contains the data to be visualized in the chart\n   */\n  Chartist.getDataArray = function(data, reverse, multi) {\n    // Recursively walks through nested arrays and convert string values to numbers and objects with value properties\n    // to values. Check the tests in data core -> data normalization for a detailed specification of expected values\n    function recursiveConvert(value) {\n      if(Chartist.safeHasProperty(value, 'value')) {\n        // We are dealing with value object notation so we need to recurse on value property\n        return recursiveConvert(value.value);\n      } else if(Chartist.safeHasProperty(value, 'data')) {\n        // We are dealing with series object notation so we need to recurse on data property\n        return recursiveConvert(value.data);\n      } else if(value instanceof Array) {\n        // Data is of type array so we need to recurse on the series\n        return value.map(recursiveConvert);\n      } else if(Chartist.isDataHoleValue(value)) {\n        // We're dealing with a hole in the data and therefore need to return undefined\n        // We're also returning undefined for multi value output\n        return undefined;\n      } else {\n        // We need to prepare multi value output (x and y data)\n        if(multi) {\n          var multiValue = {};\n\n          // Single series value arrays are assumed to specify the Y-Axis value\n          // For example: [1, 2] => [{x: undefined, y: 1}, {x: undefined, y: 2}]\n          // If multi is a string then it's assumed that it specified which dimension should be filled as default\n          if(typeof multi === 'string') {\n            multiValue[multi] = Chartist.getNumberOrUndefined(value);\n          } else {\n            multiValue.y = Chartist.getNumberOrUndefined(value);\n          }\n\n          multiValue.x = value.hasOwnProperty('x') ? Chartist.getNumberOrUndefined(value.x) : multiValue.x;\n          multiValue.y = value.hasOwnProperty('y') ? Chartist.getNumberOrUndefined(value.y) : multiValue.y;\n\n          return multiValue;\n\n        } else {\n          // We can return simple data\n          return Chartist.getNumberOrUndefined(value);\n        }\n      }\n    }\n\n    return data.series.map(recursiveConvert);\n  };\n\n  /**\n   * Converts a number into a padding object.\n   *\n   * @memberof Chartist.Core\n   * @param {Object|Number} padding\n   * @param {Number} [fallback] This value is used to fill missing values if a incomplete padding object was passed\n   * @returns {Object} Returns a padding object containing top, right, bottom, left properties filled with the padding number passed in as argument. If the argument is something else than a number (presumably already a correct padding object) then this argument is directly returned.\n   */\n  Chartist.normalizePadding = function(padding, fallback) {\n    fallback = fallback || 0;\n\n    return typeof padding === 'number' ? {\n      top: padding,\n      right: padding,\n      bottom: padding,\n      left: padding\n    } : {\n      top: typeof padding.top === 'number' ? padding.top : fallback,\n      right: typeof padding.right === 'number' ? padding.right : fallback,\n      bottom: typeof padding.bottom === 'number' ? padding.bottom : fallback,\n      left: typeof padding.left === 'number' ? padding.left : fallback\n    };\n  };\n\n  Chartist.getMetaData = function(series, index) {\n    var value = series.data ? series.data[index] : series[index];\n    return value ? value.meta : undefined;\n  };\n\n  /**\n   * Calculate the order of magnitude for the chart scale\n   *\n   * @memberof Chartist.Core\n   * @param {Number} value The value Range of the chart\n   * @return {Number} The order of magnitude\n   */\n  Chartist.orderOfMagnitude = function (value) {\n    return Math.floor(Math.log(Math.abs(value)) / Math.LN10);\n  };\n\n  /**\n   * Project a data length into screen coordinates (pixels)\n   *\n   * @memberof Chartist.Core\n   * @param {Object} axisLength The svg element for the chart\n   * @param {Number} length Single data value from a series array\n   * @param {Object} bounds All the values to set the bounds of the chart\n   * @return {Number} The projected data length in pixels\n   */\n  Chartist.projectLength = function (axisLength, length, bounds) {\n    return length / bounds.range * axisLength;\n  };\n\n  /**\n   * Get the height of the area in the chart for the data series\n   *\n   * @memberof Chartist.Core\n   * @param {Object} svg The svg element for the chart\n   * @param {Object} options The Object that contains all the optional values for the chart\n   * @return {Number} The height of the area in the chart for the data series\n   */\n  Chartist.getAvailableHeight = function (svg, options) {\n    return Math.max((Chartist.quantity(options.height).value || svg.height()) - (options.chartPadding.top +  options.chartPadding.bottom) - options.axisX.offset, 0);\n  };\n\n  /**\n   * Get highest and lowest value of data array. This Array contains the data that will be visualized in the chart.\n   *\n   * @memberof Chartist.Core\n   * @param {Array} data The array that contains the data to be visualized in the chart\n   * @param {Object} options The Object that contains the chart options\n   * @param {String} dimension Axis dimension 'x' or 'y' used to access the correct value and high / low configuration\n   * @return {Object} An object that contains the highest and lowest value that will be visualized on the chart.\n   */\n  Chartist.getHighLow = function (data, options, dimension) {\n    // TODO: Remove workaround for deprecated global high / low config. Axis high / low configuration is preferred\n    options = Chartist.extend({}, options, dimension ? options['axis' + dimension.toUpperCase()] : {});\n\n    var highLow = {\n        high: options.high === undefined ? -Number.MAX_VALUE : +options.high,\n        low: options.low === undefined ? Number.MAX_VALUE : +options.low\n      };\n    var findHigh = options.high === undefined;\n    var findLow = options.low === undefined;\n\n    // Function to recursively walk through arrays and find highest and lowest number\n    function recursiveHighLow(data) {\n      if(data === undefined) {\n        return undefined;\n      } else if(data instanceof Array) {\n        for (var i = 0; i < data.length; i++) {\n          recursiveHighLow(data[i]);\n        }\n      } else {\n        var value = dimension ? +data[dimension] : +data;\n\n        if (findHigh && value > highLow.high) {\n          highLow.high = value;\n        }\n\n        if (findLow && value < highLow.low) {\n          highLow.low = value;\n        }\n      }\n    }\n\n    // Start to find highest and lowest number recursively\n    if(findHigh || findLow) {\n      recursiveHighLow(data);\n    }\n\n    // Overrides of high / low based on reference value, it will make sure that the invisible reference value is\n    // used to generate the chart. This is useful when the chart always needs to contain the position of the\n    // invisible reference value in the view i.e. for bipolar scales.\n    if (options.referenceValue || options.referenceValue === 0) {\n      highLow.high = Math.max(options.referenceValue, highLow.high);\n      highLow.low = Math.min(options.referenceValue, highLow.low);\n    }\n\n    // If high and low are the same because of misconfiguration or flat data (only the same value) we need\n    // to set the high or low to 0 depending on the polarity\n    if (highLow.high <= highLow.low) {\n      // If both values are 0 we set high to 1\n      if (highLow.low === 0) {\n        highLow.high = 1;\n      } else if (highLow.low < 0) {\n        // If we have the same negative value for the bounds we set bounds.high to 0\n        highLow.high = 0;\n      } else if (highLow.high > 0) {\n        // If we have the same positive value for the bounds we set bounds.low to 0\n        highLow.low = 0;\n      } else {\n        // If data array was empty, values are Number.MAX_VALUE and -Number.MAX_VALUE. Set bounds to prevent errors\n        highLow.high = 1;\n        highLow.low = 0;\n      }\n    }\n\n    return highLow;\n  };\n\n  /**\n   * Checks if a value can be safely coerced to a number. This includes all values except null which result in finite numbers when coerced. This excludes NaN, since it's not finite.\n   *\n   * @memberof Chartist.Core\n   * @param value\n   * @returns {Boolean}\n   */\n  Chartist.isNumeric = function(value) {\n    return value === null ? false : isFinite(value);\n  };\n\n  /**\n   * Returns true on all falsey values except the numeric value 0.\n   *\n   * @memberof Chartist.Core\n   * @param value\n   * @returns {boolean}\n   */\n  Chartist.isFalseyButZero = function(value) {\n    return !value && value !== 0;\n  };\n\n  /**\n   * Returns a number if the passed parameter is a valid number or the function will return undefined. On all other values than a valid number, this function will return undefined.\n   *\n   * @memberof Chartist.Core\n   * @param value\n   * @returns {*}\n   */\n  Chartist.getNumberOrUndefined = function(value) {\n    return Chartist.isNumeric(value) ? +value : undefined;\n  };\n\n  /**\n   * Checks if provided value object is multi value (contains x or y properties)\n   *\n   * @memberof Chartist.Core\n   * @param value\n   */\n  Chartist.isMultiValue = function(value) {\n    return typeof value === 'object' && ('x' in value || 'y' in value);\n  };\n\n  /**\n   * Gets a value from a dimension `value.x` or `value.y` while returning value directly if it's a valid numeric value. If the value is not numeric and it's falsey this function will return `defaultValue`.\n   *\n   * @memberof Chartist.Core\n   * @param value\n   * @param dimension\n   * @param defaultValue\n   * @returns {*}\n   */\n  Chartist.getMultiValue = function(value, dimension) {\n    if(Chartist.isMultiValue(value)) {\n      return Chartist.getNumberOrUndefined(value[dimension || 'y']);\n    } else {\n      return Chartist.getNumberOrUndefined(value);\n    }\n  };\n\n  /**\n   * Pollard Rho Algorithm to find smallest factor of an integer value. There are more efficient algorithms for factorization, but this one is quite efficient and not so complex.\n   *\n   * @memberof Chartist.Core\n   * @param {Number} num An integer number where the smallest factor should be searched for\n   * @returns {Number} The smallest integer factor of the parameter num.\n   */\n  Chartist.rho = function(num) {\n    if(num === 1) {\n      return num;\n    }\n\n    function gcd(p, q) {\n      if (p % q === 0) {\n        return q;\n      } else {\n        return gcd(q, p % q);\n      }\n    }\n\n    function f(x) {\n      return x * x + 1;\n    }\n\n    var x1 = 2, x2 = 2, divisor;\n    if (num % 2 === 0) {\n      return 2;\n    }\n\n    do {\n      x1 = f(x1) % num;\n      x2 = f(f(x2)) % num;\n      divisor = gcd(Math.abs(x1 - x2), num);\n    } while (divisor === 1);\n\n    return divisor;\n  };\n\n  /**\n   * Calculate and retrieve all the bounds for the chart and return them in one array\n   *\n   * @memberof Chartist.Core\n   * @param {Number} axisLength The length of the Axis used for\n   * @param {Object} highLow An object containing a high and low property indicating the value range of the chart.\n   * @param {Number} scaleMinSpace The minimum projected length a step should result in\n   * @param {Boolean} onlyInteger\n   * @return {Object} All the values to set the bounds of the chart\n   */\n  Chartist.getBounds = function (axisLength, highLow, scaleMinSpace, onlyInteger) {\n    var i,\n      optimizationCounter = 0,\n      newMin,\n      newMax,\n      bounds = {\n        high: highLow.high,\n        low: highLow.low\n      };\n\n    bounds.valueRange = bounds.high - bounds.low;\n    bounds.oom = Chartist.orderOfMagnitude(bounds.valueRange);\n    bounds.step = Math.pow(10, bounds.oom);\n    bounds.min = Math.floor(bounds.low / bounds.step) * bounds.step;\n    bounds.max = Math.ceil(bounds.high / bounds.step) * bounds.step;\n    bounds.range = bounds.max - bounds.min;\n    bounds.numberOfSteps = Math.round(bounds.range / bounds.step);\n\n    // Optimize scale step by checking if subdivision is possible based on horizontalGridMinSpace\n    // If we are already below the scaleMinSpace value we will scale up\n    var length = Chartist.projectLength(axisLength, bounds.step, bounds);\n    var scaleUp = length < scaleMinSpace;\n    var smallestFactor = onlyInteger ? Chartist.rho(bounds.range) : 0;\n\n    // First check if we should only use integer steps and if step 1 is still larger than scaleMinSpace so we can use 1\n    if(onlyInteger && Chartist.projectLength(axisLength, 1, bounds) >= scaleMinSpace) {\n      bounds.step = 1;\n    } else if(onlyInteger && smallestFactor < bounds.step && Chartist.projectLength(axisLength, smallestFactor, bounds) >= scaleMinSpace) {\n      // If step 1 was too small, we can try the smallest factor of range\n      // If the smallest factor is smaller than the current bounds.step and the projected length of smallest factor\n      // is larger than the scaleMinSpace we should go for it.\n      bounds.step = smallestFactor;\n    } else {\n      // Trying to divide or multiply by 2 and find the best step value\n      while (true) {\n        if (scaleUp && Chartist.projectLength(axisLength, bounds.step, bounds) <= scaleMinSpace) {\n          bounds.step *= 2;\n        } else if (!scaleUp && Chartist.projectLength(axisLength, bounds.step / 2, bounds) >= scaleMinSpace) {\n          bounds.step /= 2;\n          if(onlyInteger && bounds.step % 1 !== 0) {\n            bounds.step *= 2;\n            break;\n          }\n        } else {\n          break;\n        }\n\n        if(optimizationCounter++ > 1000) {\n          throw new Error('Exceeded maximum number of iterations while optimizing scale step!');\n        }\n      }\n    }\n\n    var EPSILON = 2.221E-16;\n    bounds.step = Math.max(bounds.step, EPSILON);\n    function safeIncrement(value, increment) {\n      // If increment is too small use *= (1+EPSILON) as a simple nextafter\n      if (value === (value += increment)) {\n      \tvalue *= (1 + (increment > 0 ? EPSILON : -EPSILON));\n      }\n      return value;\n    }\n\n    // Narrow min and max based on new step\n    newMin = bounds.min;\n    newMax = bounds.max;\n    while (newMin + bounds.step <= bounds.low) {\n    \tnewMin = safeIncrement(newMin, bounds.step);\n    }\n    while (newMax - bounds.step >= bounds.high) {\n    \tnewMax = safeIncrement(newMax, -bounds.step);\n    }\n    bounds.min = newMin;\n    bounds.max = newMax;\n    bounds.range = bounds.max - bounds.min;\n\n    var values = [];\n    for (i = bounds.min; i <= bounds.max; i = safeIncrement(i, bounds.step)) {\n      var value = Chartist.roundWithPrecision(i);\n      if (value !== values[values.length - 1]) {\n        values.push(value);\n      }\n    }\n    bounds.values = values;\n    return bounds;\n  };\n\n  /**\n   * Calculate cartesian coordinates of polar coordinates\n   *\n   * @memberof Chartist.Core\n   * @param {Number} centerX X-axis coordinates of center point of circle segment\n   * @param {Number} centerY X-axis coordinates of center point of circle segment\n   * @param {Number} radius Radius of circle segment\n   * @param {Number} angleInDegrees Angle of circle segment in degrees\n   * @return {{x:Number, y:Number}} Coordinates of point on circumference\n   */\n  Chartist.polarToCartesian = function (centerX, centerY, radius, angleInDegrees) {\n    var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;\n\n    return {\n      x: centerX + (radius * Math.cos(angleInRadians)),\n      y: centerY + (radius * Math.sin(angleInRadians))\n    };\n  };\n\n  /**\n   * Initialize chart drawing rectangle (area where chart is drawn) x1,y1 = bottom left / x2,y2 = top right\n   *\n   * @memberof Chartist.Core\n   * @param {Object} svg The svg element for the chart\n   * @param {Object} options The Object that contains all the optional values for the chart\n   * @param {Number} [fallbackPadding] The fallback padding if partial padding objects are used\n   * @return {Object} The chart rectangles coordinates inside the svg element plus the rectangles measurements\n   */\n  Chartist.createChartRect = function (svg, options, fallbackPadding) {\n    var hasAxis = !!(options.axisX || options.axisY);\n    var yAxisOffset = hasAxis ? options.axisY.offset : 0;\n    var xAxisOffset = hasAxis ? options.axisX.offset : 0;\n    // If width or height results in invalid value (including 0) we fallback to the unitless settings or even 0\n    var width = svg.width() || Chartist.quantity(options.width).value || 0;\n    var height = svg.height() || Chartist.quantity(options.height).value || 0;\n    var normalizedPadding = Chartist.normalizePadding(options.chartPadding, fallbackPadding);\n\n    // If settings were to small to cope with offset (legacy) and padding, we'll adjust\n    width = Math.max(width, yAxisOffset + normalizedPadding.left + normalizedPadding.right);\n    height = Math.max(height, xAxisOffset + normalizedPadding.top + normalizedPadding.bottom);\n\n    var chartRect = {\n      padding: normalizedPadding,\n      width: function () {\n        return this.x2 - this.x1;\n      },\n      height: function () {\n        return this.y1 - this.y2;\n      }\n    };\n\n    if(hasAxis) {\n      if (options.axisX.position === 'start') {\n        chartRect.y2 = normalizedPadding.top + xAxisOffset;\n        chartRect.y1 = Math.max(height - normalizedPadding.bottom, chartRect.y2 + 1);\n      } else {\n        chartRect.y2 = normalizedPadding.top;\n        chartRect.y1 = Math.max(height - normalizedPadding.bottom - xAxisOffset, chartRect.y2 + 1);\n      }\n\n      if (options.axisY.position === 'start') {\n        chartRect.x1 = normalizedPadding.left + yAxisOffset;\n        chartRect.x2 = Math.max(width - normalizedPadding.right, chartRect.x1 + 1);\n      } else {\n        chartRect.x1 = normalizedPadding.left;\n        chartRect.x2 = Math.max(width - normalizedPadding.right - yAxisOffset, chartRect.x1 + 1);\n      }\n    } else {\n      chartRect.x1 = normalizedPadding.left;\n      chartRect.x2 = Math.max(width - normalizedPadding.right, chartRect.x1 + 1);\n      chartRect.y2 = normalizedPadding.top;\n      chartRect.y1 = Math.max(height - normalizedPadding.bottom, chartRect.y2 + 1);\n    }\n\n    return chartRect;\n  };\n\n  /**\n   * Creates a grid line based on a projected value.\n   *\n   * @memberof Chartist.Core\n   * @param position\n   * @param index\n   * @param axis\n   * @param offset\n   * @param length\n   * @param group\n   * @param classes\n   * @param eventEmitter\n   */\n  Chartist.createGrid = function(position, index, axis, offset, length, group, classes, eventEmitter) {\n    var positionalData = {};\n    positionalData[axis.units.pos + '1'] = position;\n    positionalData[axis.units.pos + '2'] = position;\n    positionalData[axis.counterUnits.pos + '1'] = offset;\n    positionalData[axis.counterUnits.pos + '2'] = offset + length;\n\n    var gridElement = group.elem('line', positionalData, classes.join(' '));\n\n    // Event for grid draw\n    eventEmitter.emit('draw',\n      Chartist.extend({\n        type: 'grid',\n        axis: axis,\n        index: index,\n        group: group,\n        element: gridElement\n      }, positionalData)\n    );\n  };\n\n  /**\n   * Creates a grid background rect and emits the draw event.\n   *\n   * @memberof Chartist.Core\n   * @param gridGroup\n   * @param chartRect\n   * @param className\n   * @param eventEmitter\n   */\n  Chartist.createGridBackground = function (gridGroup, chartRect, className, eventEmitter) {\n    var gridBackground = gridGroup.elem('rect', {\n        x: chartRect.x1,\n        y: chartRect.y2,\n        width: chartRect.width(),\n        height: chartRect.height(),\n      }, className, true);\n\n      // Event for grid background draw\n      eventEmitter.emit('draw', {\n        type: 'gridBackground',\n        group: gridGroup,\n        element: gridBackground\n      });\n  };\n\n  /**\n   * Creates a label based on a projected value and an axis.\n   *\n   * @memberof Chartist.Core\n   * @param position\n   * @param length\n   * @param index\n   * @param labels\n   * @param axis\n   * @param axisOffset\n   * @param labelOffset\n   * @param group\n   * @param classes\n   * @param useForeignObject\n   * @param eventEmitter\n   */\n  Chartist.createLabel = function(position, length, index, labels, axis, axisOffset, labelOffset, group, classes, useForeignObject, eventEmitter) {\n    var labelElement;\n    var positionalData = {};\n\n    positionalData[axis.units.pos] = position + labelOffset[axis.units.pos];\n    positionalData[axis.counterUnits.pos] = labelOffset[axis.counterUnits.pos];\n    positionalData[axis.units.len] = length;\n    positionalData[axis.counterUnits.len] = Math.max(0, axisOffset - 10);\n\n    if(useForeignObject) {\n      // We need to set width and height explicitly to px as span will not expand with width and height being\n      // 100% in all browsers\n      var content = document.createElement('span');\n      content.className = classes.join(' ');\n      content.setAttribute('xmlns', Chartist.namespaces.xhtml);\n      content.innerText = labels[index];\n      content.style[axis.units.len] = Math.round(positionalData[axis.units.len]) + 'px';\n      content.style[axis.counterUnits.len] = Math.round(positionalData[axis.counterUnits.len]) + 'px';\n\n      labelElement = group.foreignObject(content, Chartist.extend({\n        style: 'overflow: visible;'\n      }, positionalData));\n    } else {\n      labelElement = group.elem('text', positionalData, classes.join(' ')).text(labels[index]);\n    }\n\n    eventEmitter.emit('draw', Chartist.extend({\n      type: 'label',\n      axis: axis,\n      index: index,\n      group: group,\n      element: labelElement,\n      text: labels[index]\n    }, positionalData));\n  };\n\n  /**\n   * Helper to read series specific options from options object. It automatically falls back to the global option if\n   * there is no option in the series options.\n   *\n   * @param {Object} series Series object\n   * @param {Object} options Chartist options object\n   * @param {string} key The options key that should be used to obtain the options\n   * @returns {*}\n   */\n  Chartist.getSeriesOption = function(series, options, key) {\n    if(series.name && options.series && options.series[series.name]) {\n      var seriesOptions = options.series[series.name];\n      return seriesOptions.hasOwnProperty(key) ? seriesOptions[key] : options[key];\n    } else {\n      return options[key];\n    }\n  };\n\n  /**\n   * Provides options handling functionality with callback for options changes triggered by responsive options and media query matches\n   *\n   * @memberof Chartist.Core\n   * @param {Object} options Options set by user\n   * @param {Array} responsiveOptions Optional functions to add responsive behavior to chart\n   * @param {Object} eventEmitter The event emitter that will be used to emit the options changed events\n   * @return {Object} The consolidated options object from the defaults, base and matching responsive options\n   */\n  Chartist.optionsProvider = function (options, responsiveOptions, eventEmitter) {\n    var baseOptions = Chartist.extend({}, options),\n      currentOptions,\n      mediaQueryListeners = [],\n      i;\n\n    function updateCurrentOptions(mediaEvent) {\n      var previousOptions = currentOptions;\n      currentOptions = Chartist.extend({}, baseOptions);\n\n      if (responsiveOptions) {\n        for (i = 0; i < responsiveOptions.length; i++) {\n          var mql = window.matchMedia(responsiveOptions[i][0]);\n          if (mql.matches) {\n            currentOptions = Chartist.extend(currentOptions, responsiveOptions[i][1]);\n          }\n        }\n      }\n\n      if(eventEmitter && mediaEvent) {\n        eventEmitter.emit('optionsChanged', {\n          previousOptions: previousOptions,\n          currentOptions: currentOptions\n        });\n      }\n    }\n\n    function removeMediaQueryListeners() {\n      mediaQueryListeners.forEach(function(mql) {\n        mql.removeListener(updateCurrentOptions);\n      });\n    }\n\n    if (!window.matchMedia) {\n      throw 'window.matchMedia not found! Make sure you\\'re using a polyfill.';\n    } else if (responsiveOptions) {\n\n      for (i = 0; i < responsiveOptions.length; i++) {\n        var mql = window.matchMedia(responsiveOptions[i][0]);\n        mql.addListener(updateCurrentOptions);\n        mediaQueryListeners.push(mql);\n      }\n    }\n    // Execute initially without an event argument so we get the correct options\n    updateCurrentOptions();\n\n    return {\n      removeMediaQueryListeners: removeMediaQueryListeners,\n      getCurrentOptions: function getCurrentOptions() {\n        return Chartist.extend({}, currentOptions);\n      }\n    };\n  };\n\n\n  /**\n   * Splits a list of coordinates and associated values into segments. Each returned segment contains a pathCoordinates\n   * valueData property describing the segment.\n   *\n   * With the default options, segments consist of contiguous sets of points that do not have an undefined value. Any\n   * points with undefined values are discarded.\n   *\n   * **Options**\n   * The following options are used to determine how segments are formed\n   * ```javascript\n   * var options = {\n   *   // If fillHoles is true, undefined values are simply discarded without creating a new segment. Assuming other options are default, this returns single segment.\n   *   fillHoles: false,\n   *   // If increasingX is true, the coordinates in all segments have strictly increasing x-values.\n   *   increasingX: false\n   * };\n   * ```\n   *\n   * @memberof Chartist.Core\n   * @param {Array} pathCoordinates List of point coordinates to be split in the form [x1, y1, x2, y2 ... xn, yn]\n   * @param {Array} values List of associated point values in the form [v1, v2 .. vn]\n   * @param {Object} options Options set by user\n   * @return {Array} List of segments, each containing a pathCoordinates and valueData property.\n   */\n  Chartist.splitIntoSegments = function(pathCoordinates, valueData, options) {\n    var defaultOptions = {\n      increasingX: false,\n      fillHoles: false\n    };\n\n    options = Chartist.extend({}, defaultOptions, options);\n\n    var segments = [];\n    var hole = true;\n\n    for(var i = 0; i < pathCoordinates.length; i += 2) {\n      // If this value is a \"hole\" we set the hole flag\n      if(Chartist.getMultiValue(valueData[i / 2].value) === undefined) {\n      // if(valueData[i / 2].value === undefined) {\n        if(!options.fillHoles) {\n          hole = true;\n        }\n      } else {\n        if(options.increasingX && i >= 2 && pathCoordinates[i] <= pathCoordinates[i-2]) {\n          // X is not increasing, so we need to make sure we start a new segment\n          hole = true;\n        }\n\n\n        // If it's a valid value we need to check if we're coming out of a hole and create a new empty segment\n        if(hole) {\n          segments.push({\n            pathCoordinates: [],\n            valueData: []\n          });\n          // As we have a valid value now, we are not in a \"hole\" anymore\n          hole = false;\n        }\n\n        // Add to the segment pathCoordinates and valueData\n        segments[segments.length - 1].pathCoordinates.push(pathCoordinates[i], pathCoordinates[i + 1]);\n        segments[segments.length - 1].valueData.push(valueData[i / 2]);\n      }\n    }\n\n    return segments;\n  };\n}(this || global, Chartist));\n;/**\n * Chartist path interpolation functions.\n *\n * @module Chartist.Interpolation\n */\n/* global Chartist */\n(function(globalRoot, Chartist) {\n  'use strict';\n\n  Chartist.Interpolation = {};\n\n  /**\n   * This interpolation function does not smooth the path and the result is only containing lines and no curves.\n   *\n   * @example\n   * var chart = new Chartist.Line('.ct-chart', {\n   *   labels: [1, 2, 3, 4, 5],\n   *   series: [[1, 2, 8, 1, 7]]\n   * }, {\n   *   lineSmooth: Chartist.Interpolation.none({\n   *     fillHoles: false\n   *   })\n   * });\n   *\n   *\n   * @memberof Chartist.Interpolation\n   * @return {Function}\n   */\n  Chartist.Interpolation.none = function(options) {\n    var defaultOptions = {\n      fillHoles: false\n    };\n    options = Chartist.extend({}, defaultOptions, options);\n    return function none(pathCoordinates, valueData) {\n      var path = new Chartist.Svg.Path();\n      var hole = true;\n\n      for(var i = 0; i < pathCoordinates.length; i += 2) {\n        var currX = pathCoordinates[i];\n        var currY = pathCoordinates[i + 1];\n        var currData = valueData[i / 2];\n\n        if(Chartist.getMultiValue(currData.value) !== undefined) {\n\n          if(hole) {\n            path.move(currX, currY, false, currData);\n          } else {\n            path.line(currX, currY, false, currData);\n          }\n\n          hole = false;\n        } else if(!options.fillHoles) {\n          hole = true;\n        }\n      }\n\n      return path;\n    };\n  };\n\n  /**\n   * Simple smoothing creates horizontal handles that are positioned with a fraction of the length between two data points. You can use the divisor option to specify the amount of smoothing.\n   *\n   * Simple smoothing can be used instead of `Chartist.Smoothing.cardinal` if you'd like to get rid of the artifacts it produces sometimes. Simple smoothing produces less flowing lines but is accurate by hitting the points and it also doesn't swing below or above the given data point.\n   *\n   * All smoothing functions within Chartist are factory functions that accept an options parameter. The simple interpolation function accepts one configuration parameter `divisor`, between 1 and , which controls the smoothing characteristics.\n   *\n   * @example\n   * var chart = new Chartist.Line('.ct-chart', {\n   *   labels: [1, 2, 3, 4, 5],\n   *   series: [[1, 2, 8, 1, 7]]\n   * }, {\n   *   lineSmooth: Chartist.Interpolation.simple({\n   *     divisor: 2,\n   *     fillHoles: false\n   *   })\n   * });\n   *\n   *\n   * @memberof Chartist.Interpolation\n   * @param {Object} options The options of the simple interpolation factory function.\n   * @return {Function}\n   */\n  Chartist.Interpolation.simple = function(options) {\n    var defaultOptions = {\n      divisor: 2,\n      fillHoles: false\n    };\n    options = Chartist.extend({}, defaultOptions, options);\n\n    var d = 1 / Math.max(1, options.divisor);\n\n    return function simple(pathCoordinates, valueData) {\n      var path = new Chartist.Svg.Path();\n      var prevX, prevY, prevData;\n\n      for(var i = 0; i < pathCoordinates.length; i += 2) {\n        var currX = pathCoordinates[i];\n        var currY = pathCoordinates[i + 1];\n        var length = (currX - prevX) * d;\n        var currData = valueData[i / 2];\n\n        if(currData.value !== undefined) {\n\n          if(prevData === undefined) {\n            path.move(currX, currY, false, currData);\n          } else {\n            path.curve(\n              prevX + length,\n              prevY,\n              currX - length,\n              currY,\n              currX,\n              currY,\n              false,\n              currData\n            );\n          }\n\n          prevX = currX;\n          prevY = currY;\n          prevData = currData;\n        } else if(!options.fillHoles) {\n          prevX = currX = prevData = undefined;\n        }\n      }\n\n      return path;\n    };\n  };\n\n  /**\n   * Cardinal / Catmull-Rome spline interpolation is the default smoothing function in Chartist. It produces nice results where the splines will always meet the points. It produces some artifacts though when data values are increased or decreased rapidly. The line may not follow a very accurate path and if the line should be accurate this smoothing function does not produce the best results.\n   *\n   * Cardinal splines can only be created if there are more than two data points. If this is not the case this smoothing will fallback to `Chartist.Smoothing.none`.\n   *\n   * All smoothing functions within Chartist are factory functions that accept an options parameter. The cardinal interpolation function accepts one configuration parameter `tension`, between 0 and 1, which controls the smoothing intensity.\n   *\n   * @example\n   * var chart = new Chartist.Line('.ct-chart', {\n   *   labels: [1, 2, 3, 4, 5],\n   *   series: [[1, 2, 8, 1, 7]]\n   * }, {\n   *   lineSmooth: Chartist.Interpolation.cardinal({\n   *     tension: 1,\n   *     fillHoles: false\n   *   })\n   * });\n   *\n   * @memberof Chartist.Interpolation\n   * @param {Object} options The options of the cardinal factory function.\n   * @return {Function}\n   */\n  Chartist.Interpolation.cardinal = function(options) {\n    var defaultOptions = {\n      tension: 1,\n      fillHoles: false\n    };\n\n    options = Chartist.extend({}, defaultOptions, options);\n\n    var t = Math.min(1, Math.max(0, options.tension)),\n      c = 1 - t;\n\n    return function cardinal(pathCoordinates, valueData) {\n      // First we try to split the coordinates into segments\n      // This is necessary to treat \"holes\" in line charts\n      var segments = Chartist.splitIntoSegments(pathCoordinates, valueData, {\n        fillHoles: options.fillHoles\n      });\n\n      if(!segments.length) {\n        // If there were no segments return 'Chartist.Interpolation.none'\n        return Chartist.Interpolation.none()([]);\n      } else if(segments.length > 1) {\n        // If the split resulted in more that one segment we need to interpolate each segment individually and join them\n        // afterwards together into a single path.\n          var paths = [];\n        // For each segment we will recurse the cardinal function\n        segments.forEach(function(segment) {\n          paths.push(cardinal(segment.pathCoordinates, segment.valueData));\n        });\n        // Join the segment path data into a single path and return\n        return Chartist.Svg.Path.join(paths);\n      } else {\n        // If there was only one segment we can proceed regularly by using pathCoordinates and valueData from the first\n        // segment\n        pathCoordinates = segments[0].pathCoordinates;\n        valueData = segments[0].valueData;\n\n        // If less than two points we need to fallback to no smoothing\n        if(pathCoordinates.length <= 4) {\n          return Chartist.Interpolation.none()(pathCoordinates, valueData);\n        }\n\n        var path = new Chartist.Svg.Path().move(pathCoordinates[0], pathCoordinates[1], false, valueData[0]),\n          z;\n\n        for (var i = 0, iLen = pathCoordinates.length; iLen - 2 * !z > i; i += 2) {\n          var p = [\n            {x: +pathCoordinates[i - 2], y: +pathCoordinates[i - 1]},\n            {x: +pathCoordinates[i], y: +pathCoordinates[i + 1]},\n            {x: +pathCoordinates[i + 2], y: +pathCoordinates[i + 3]},\n            {x: +pathCoordinates[i + 4], y: +pathCoordinates[i + 5]}\n          ];\n          if (z) {\n            if (!i) {\n              p[0] = {x: +pathCoordinates[iLen - 2], y: +pathCoordinates[iLen - 1]};\n            } else if (iLen - 4 === i) {\n              p[3] = {x: +pathCoordinates[0], y: +pathCoordinates[1]};\n            } else if (iLen - 2 === i) {\n              p[2] = {x: +pathCoordinates[0], y: +pathCoordinates[1]};\n              p[3] = {x: +pathCoordinates[2], y: +pathCoordinates[3]};\n            }\n          } else {\n            if (iLen - 4 === i) {\n              p[3] = p[2];\n            } else if (!i) {\n              p[0] = {x: +pathCoordinates[i], y: +pathCoordinates[i + 1]};\n            }\n          }\n\n          path.curve(\n            (t * (-p[0].x + 6 * p[1].x + p[2].x) / 6) + (c * p[2].x),\n            (t * (-p[0].y + 6 * p[1].y + p[2].y) / 6) + (c * p[2].y),\n            (t * (p[1].x + 6 * p[2].x - p[3].x) / 6) + (c * p[2].x),\n            (t * (p[1].y + 6 * p[2].y - p[3].y) / 6) + (c * p[2].y),\n            p[2].x,\n            p[2].y,\n            false,\n            valueData[(i + 2) / 2]\n          );\n        }\n\n        return path;\n      }\n    };\n  };\n\n  /**\n   * Monotone Cubic spline interpolation produces a smooth curve which preserves monotonicity. Unlike cardinal splines, the curve will not extend beyond the range of y-values of the original data points.\n   *\n   * Monotone Cubic splines can only be created if there are more than two data points. If this is not the case this smoothing will fallback to `Chartist.Smoothing.none`.\n   *\n   * The x-values of subsequent points must be increasing to fit a Monotone Cubic spline. If this condition is not met for a pair of adjacent points, then there will be a break in the curve between those data points.\n   *\n   * All smoothing functions within Chartist are factory functions that accept an options parameter.\n   *\n   * @example\n   * var chart = new Chartist.Line('.ct-chart', {\n   *   labels: [1, 2, 3, 4, 5],\n   *   series: [[1, 2, 8, 1, 7]]\n   * }, {\n   *   lineSmooth: Chartist.Interpolation.monotoneCubic({\n   *     fillHoles: false\n   *   })\n   * });\n   *\n   * @memberof Chartist.Interpolation\n   * @param {Object} options The options of the monotoneCubic factory function.\n   * @return {Function}\n   */\n  Chartist.Interpolation.monotoneCubic = function(options) {\n    var defaultOptions = {\n      fillHoles: false\n    };\n\n    options = Chartist.extend({}, defaultOptions, options);\n\n    return function monotoneCubic(pathCoordinates, valueData) {\n      // First we try to split the coordinates into segments\n      // This is necessary to treat \"holes\" in line charts\n      var segments = Chartist.splitIntoSegments(pathCoordinates, valueData, {\n        fillHoles: options.fillHoles,\n        increasingX: true\n      });\n\n      if(!segments.length) {\n        // If there were no segments return 'Chartist.Interpolation.none'\n        return Chartist.Interpolation.none()([]);\n      } else if(segments.length > 1) {\n        // If the split resulted in more that one segment we need to interpolate each segment individually and join them\n        // afterwards together into a single path.\n          var paths = [];\n        // For each segment we will recurse the monotoneCubic fn function\n        segments.forEach(function(segment) {\n          paths.push(monotoneCubic(segment.pathCoordinates, segment.valueData));\n        });\n        // Join the segment path data into a single path and return\n        return Chartist.Svg.Path.join(paths);\n      } else {\n        // If there was only one segment we can proceed regularly by using pathCoordinates and valueData from the first\n        // segment\n        pathCoordinates = segments[0].pathCoordinates;\n        valueData = segments[0].valueData;\n\n        // If less than three points we need to fallback to no smoothing\n        if(pathCoordinates.length <= 4) {\n          return Chartist.Interpolation.none()(pathCoordinates, valueData);\n        }\n\n        var xs = [],\n          ys = [],\n          i,\n          n = pathCoordinates.length / 2,\n          ms = [],\n          ds = [], dys = [], dxs = [],\n          path;\n\n        // Populate x and y coordinates into separate arrays, for readability\n\n        for(i = 0; i < n; i++) {\n          xs[i] = pathCoordinates[i * 2];\n          ys[i] = pathCoordinates[i * 2 + 1];\n        }\n\n        // Calculate deltas and derivative\n\n        for(i = 0; i < n - 1; i++) {\n          dys[i] = ys[i + 1] - ys[i];\n          dxs[i] = xs[i + 1] - xs[i];\n          ds[i] = dys[i] / dxs[i];\n        }\n\n        // Determine desired slope (m) at each point using Fritsch-Carlson method\n        // See: http://math.stackexchange.com/questions/45218/implementation-of-monotone-cubic-interpolation\n\n        ms[0] = ds[0];\n        ms[n - 1] = ds[n - 2];\n\n        for(i = 1; i < n - 1; i++) {\n          if(ds[i] === 0 || ds[i - 1] === 0 || (ds[i - 1] > 0) !== (ds[i] > 0)) {\n            ms[i] = 0;\n          } else {\n            ms[i] = 3 * (dxs[i - 1] + dxs[i]) / (\n              (2 * dxs[i] + dxs[i - 1]) / ds[i - 1] +\n              (dxs[i] + 2 * dxs[i - 1]) / ds[i]);\n\n            if(!isFinite(ms[i])) {\n              ms[i] = 0;\n            }\n          }\n        }\n\n        // Now build a path from the slopes\n\n        path = new Chartist.Svg.Path().move(xs[0], ys[0], false, valueData[0]);\n\n        for(i = 0; i < n - 1; i++) {\n          path.curve(\n            // First control point\n            xs[i] + dxs[i] / 3,\n            ys[i] + ms[i] * dxs[i] / 3,\n            // Second control point\n            xs[i + 1] - dxs[i] / 3,\n            ys[i + 1] - ms[i + 1] * dxs[i] / 3,\n            // End point\n            xs[i + 1],\n            ys[i + 1],\n\n            false,\n            valueData[i + 1]\n          );\n        }\n\n        return path;\n      }\n    };\n  };\n\n  /**\n   * Step interpolation will cause the line chart to move in steps rather than diagonal or smoothed lines. This interpolation will create additional points that will also be drawn when the `showPoint` option is enabled.\n   *\n   * All smoothing functions within Chartist are factory functions that accept an options parameter. The step interpolation function accepts one configuration parameter `postpone`, that can be `true` or `false`. The default value is `true` and will cause the step to occur where the value actually changes. If a different behaviour is needed where the step is shifted to the left and happens before the actual value, this option can be set to `false`.\n   *\n   * @example\n   * var chart = new Chartist.Line('.ct-chart', {\n   *   labels: [1, 2, 3, 4, 5],\n   *   series: [[1, 2, 8, 1, 7]]\n   * }, {\n   *   lineSmooth: Chartist.Interpolation.step({\n   *     postpone: true,\n   *     fillHoles: false\n   *   })\n   * });\n   *\n   * @memberof Chartist.Interpolation\n   * @param options\n   * @returns {Function}\n   */\n  Chartist.Interpolation.step = function(options) {\n    var defaultOptions = {\n      postpone: true,\n      fillHoles: false\n    };\n\n    options = Chartist.extend({}, defaultOptions, options);\n\n    return function step(pathCoordinates, valueData) {\n      var path = new Chartist.Svg.Path();\n\n      var prevX, prevY, prevData;\n\n      for (var i = 0; i < pathCoordinates.length; i += 2) {\n        var currX = pathCoordinates[i];\n        var currY = pathCoordinates[i + 1];\n        var currData = valueData[i / 2];\n\n        // If the current point is also not a hole we can draw the step lines\n        if(currData.value !== undefined) {\n          if(prevData === undefined) {\n            path.move(currX, currY, false, currData);\n          } else {\n            if(options.postpone) {\n              // If postponed we should draw the step line with the value of the previous value\n              path.line(currX, prevY, false, prevData);\n            } else {\n              // If not postponed we should draw the step line with the value of the current value\n              path.line(prevX, currY, false, currData);\n            }\n            // Line to the actual point (this should only be a Y-Axis movement\n            path.line(currX, currY, false, currData);\n          }\n\n          prevX = currX;\n          prevY = currY;\n          prevData = currData;\n        } else if(!options.fillHoles) {\n          prevX = prevY = prevData = undefined;\n        }\n      }\n\n      return path;\n    };\n  };\n\n}(this || global, Chartist));\n;/**\n * A very basic event module that helps to generate and catch events.\n *\n * @module Chartist.Event\n */\n/* global Chartist */\n(function (globalRoot, Chartist) {\n  'use strict';\n\n  Chartist.EventEmitter = function () {\n    var handlers = [];\n\n    /**\n     * Add an event handler for a specific event\n     *\n     * @memberof Chartist.Event\n     * @param {String} event The event name\n     * @param {Function} handler A event handler function\n     */\n    function addEventHandler(event, handler) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    }\n\n    /**\n     * Remove an event handler of a specific event name or remove all event handlers for a specific event.\n     *\n     * @memberof Chartist.Event\n     * @param {String} event The event name where a specific or all handlers should be removed\n     * @param {Function} [handler] An optional event handler function. If specified only this specific handler will be removed and otherwise all handlers are removed.\n     */\n    function removeEventHandler(event, handler) {\n      // Only do something if there are event handlers with this name existing\n      if(handlers[event]) {\n        // If handler is set we will look for a specific handler and only remove this\n        if(handler) {\n          handlers[event].splice(handlers[event].indexOf(handler), 1);\n          if(handlers[event].length === 0) {\n            delete handlers[event];\n          }\n        } else {\n          // If no handler is specified we remove all handlers for this event\n          delete handlers[event];\n        }\n      }\n    }\n\n    /**\n     * Use this function to emit an event. All handlers that are listening for this event will be triggered with the data parameter.\n     *\n     * @memberof Chartist.Event\n     * @param {String} event The event name that should be triggered\n     * @param {*} data Arbitrary data that will be passed to the event handler callback functions\n     */\n    function emit(event, data) {\n      // Only do something if there are event handlers with this name existing\n      if(handlers[event]) {\n        handlers[event].forEach(function(handler) {\n          handler(data);\n        });\n      }\n\n      // Emit event to star event handlers\n      if(handlers['*']) {\n        handlers['*'].forEach(function(starHandler) {\n          starHandler(event, data);\n        });\n      }\n    }\n\n    return {\n      addEventHandler: addEventHandler,\n      removeEventHandler: removeEventHandler,\n      emit: emit\n    };\n  };\n\n}(this || global, Chartist));\n;/**\n * This module provides some basic prototype inheritance utilities.\n *\n * @module Chartist.Class\n */\n/* global Chartist */\n(function(globalRoot, Chartist) {\n  'use strict';\n\n  function listToArray(list) {\n    var arr = [];\n    if (list.length) {\n      for (var i = 0; i < list.length; i++) {\n        arr.push(list[i]);\n      }\n    }\n    return arr;\n  }\n\n  /**\n   * Method to extend from current prototype.\n   *\n   * @memberof Chartist.Class\n   * @param {Object} properties The object that serves as definition for the prototype that gets created for the new class. This object should always contain a constructor property that is the desired constructor for the newly created class.\n   * @param {Object} [superProtoOverride] By default extens will use the current class prototype or Chartist.class. With this parameter you can specify any super prototype that will be used.\n   * @return {Function} Constructor function of the new class\n   *\n   * @example\n   * var Fruit = Class.extend({\n     * color: undefined,\n     *   sugar: undefined,\n     *\n     *   constructor: function(color, sugar) {\n     *     this.color = color;\n     *     this.sugar = sugar;\n     *   },\n     *\n     *   eat: function() {\n     *     this.sugar = 0;\n     *     return this;\n     *   }\n     * });\n   *\n   * var Banana = Fruit.extend({\n     *   length: undefined,\n     *\n     *   constructor: function(length, sugar) {\n     *     Banana.super.constructor.call(this, 'Yellow', sugar);\n     *     this.length = length;\n     *   }\n     * });\n   *\n   * var banana = new Banana(20, 40);\n   * console.log('banana instanceof Fruit', banana instanceof Fruit);\n   * console.log('Fruit is prototype of banana', Fruit.prototype.isPrototypeOf(banana));\n   * console.log('bananas prototype is Fruit', Object.getPrototypeOf(banana) === Fruit.prototype);\n   * console.log(banana.sugar);\n   * console.log(banana.eat().sugar);\n   * console.log(banana.color);\n   */\n  function extend(properties, superProtoOverride) {\n    var superProto = superProtoOverride || this.prototype || Chartist.Class;\n    var proto = Object.create(superProto);\n\n    Chartist.Class.cloneDefinitions(proto, properties);\n\n    var constr = function() {\n      var fn = proto.constructor || function () {},\n        instance;\n\n      // If this is linked to the Chartist namespace the constructor was not called with new\n      // To provide a fallback we will instantiate here and return the instance\n      instance = this === Chartist ? Object.create(proto) : this;\n      fn.apply(instance, Array.prototype.slice.call(arguments, 0));\n\n      // If this constructor was not called with new we need to return the instance\n      // This will not harm when the constructor has been called with new as the returned value is ignored\n      return instance;\n    };\n\n    constr.prototype = proto;\n    constr.super = superProto;\n    constr.extend = this.extend;\n\n    return constr;\n  }\n\n  // Variable argument list clones args > 0 into args[0] and retruns modified args[0]\n  function cloneDefinitions() {\n    var args = listToArray(arguments);\n    var target = args[0];\n\n    args.splice(1, args.length - 1).forEach(function (source) {\n      Object.getOwnPropertyNames(source).forEach(function (propName) {\n        // If this property already exist in target we delete it first\n        delete target[propName];\n        // Define the property with the descriptor from source\n        Object.defineProperty(target, propName,\n          Object.getOwnPropertyDescriptor(source, propName));\n      });\n    });\n\n    return target;\n  }\n\n  Chartist.Class = {\n    extend: extend,\n    cloneDefinitions: cloneDefinitions\n  };\n\n}(this || global, Chartist));\n;/**\n * Base for all chart types. The methods in Chartist.Base are inherited to all chart types.\n *\n * @module Chartist.Base\n */\n/* global Chartist */\n(function(globalRoot, Chartist) {\n  'use strict';\n\n  var window = globalRoot.window;\n\n  // TODO: Currently we need to re-draw the chart on window resize. This is usually very bad and will affect performance.\n  // This is done because we can't work with relative coordinates when drawing the chart because SVG Path does not\n  // work with relative positions yet. We need to check if we can do a viewBox hack to switch to percentage.\n  // See http://mozilla.6506.n7.nabble.com/Specyfing-paths-with-percentages-unit-td247474.html\n  // Update: can be done using the above method tested here: http://codepen.io/gionkunz/pen/KDvLj\n  // The problem is with the label offsets that can't be converted into percentage and affecting the chart container\n  /**\n   * Updates the chart which currently does a full reconstruction of the SVG DOM\n   *\n   * @param {Object} [data] Optional data you'd like to set for the chart before it will update. If not specified the update method will use the data that is already configured with the chart.\n   * @param {Object} [options] Optional options you'd like to add to the previous options for the chart before it will update. If not specified the update method will use the options that have been already configured with the chart.\n   * @param {Boolean} [override] If set to true, the passed options will be used to extend the options that have been configured already. Otherwise the chart default options will be used as the base\n   * @memberof Chartist.Base\n   */\n  function update(data, options, override) {\n    if(data) {\n      this.data = data || {};\n      this.data.labels = this.data.labels || [];\n      this.data.series = this.data.series || [];\n      // Event for data transformation that allows to manipulate the data before it gets rendered in the charts\n      this.eventEmitter.emit('data', {\n        type: 'update',\n        data: this.data\n      });\n    }\n\n    if(options) {\n      this.options = Chartist.extend({}, override ? this.options : this.defaultOptions, options);\n\n      // If chartist was not initialized yet, we just set the options and leave the rest to the initialization\n      // Otherwise we re-create the optionsProvider at this point\n      if(!this.initializeTimeoutId) {\n        this.optionsProvider.removeMediaQueryListeners();\n        this.optionsProvider = Chartist.optionsProvider(this.options, this.responsiveOptions, this.eventEmitter);\n      }\n    }\n\n    // Only re-created the chart if it has been initialized yet\n    if(!this.initializeTimeoutId) {\n      this.createChart(this.optionsProvider.getCurrentOptions());\n    }\n\n    // Return a reference to the chart object to chain up calls\n    return this;\n  }\n\n  /**\n   * This method can be called on the API object of each chart and will un-register all event listeners that were added to other components. This currently includes a window.resize listener as well as media query listeners if any responsive options have been provided. Use this function if you need to destroy and recreate Chartist charts dynamically.\n   *\n   * @memberof Chartist.Base\n   */\n  function detach() {\n    // Only detach if initialization already occurred on this chart. If this chart still hasn't initialized (therefore\n    // the initializationTimeoutId is still a valid timeout reference, we will clear the timeout\n    if(!this.initializeTimeoutId) {\n      window.removeEventListener('resize', this.resizeListener);\n      this.optionsProvider.removeMediaQueryListeners();\n    } else {\n      window.clearTimeout(this.initializeTimeoutId);\n    }\n\n    return this;\n  }\n\n  /**\n   * Use this function to register event handlers. The handler callbacks are synchronous and will run in the main thread rather than the event loop.\n   *\n   * @memberof Chartist.Base\n   * @param {String} event Name of the event. Check the examples for supported events.\n   * @param {Function} handler The handler function that will be called when an event with the given name was emitted. This function will receive a data argument which contains event data. See the example for more details.\n   */\n  function on(event, handler) {\n    this.eventEmitter.addEventHandler(event, handler);\n    return this;\n  }\n\n  /**\n   * Use this function to un-register event handlers. If the handler function parameter is omitted all handlers for the given event will be un-registered.\n   *\n   * @memberof Chartist.Base\n   * @param {String} event Name of the event for which a handler should be removed\n   * @param {Function} [handler] The handler function that that was previously used to register a new event handler. This handler will be removed from the event handler list. If this parameter is omitted then all event handlers for the given event are removed from the list.\n   */\n  function off(event, handler) {\n    this.eventEmitter.removeEventHandler(event, handler);\n    return this;\n  }\n\n  function initialize() {\n    // Add window resize listener that re-creates the chart\n    window.addEventListener('resize', this.resizeListener);\n\n    // Obtain current options based on matching media queries (if responsive options are given)\n    // This will also register a listener that is re-creating the chart based on media changes\n    this.optionsProvider = Chartist.optionsProvider(this.options, this.responsiveOptions, this.eventEmitter);\n    // Register options change listener that will trigger a chart update\n    this.eventEmitter.addEventHandler('optionsChanged', function() {\n      this.update();\n    }.bind(this));\n\n    // Before the first chart creation we need to register us with all plugins that are configured\n    // Initialize all relevant plugins with our chart object and the plugin options specified in the config\n    if(this.options.plugins) {\n      this.options.plugins.forEach(function(plugin) {\n        if(plugin instanceof Array) {\n          plugin[0](this, plugin[1]);\n        } else {\n          plugin(this);\n        }\n      }.bind(this));\n    }\n\n    // Event for data transformation that allows to manipulate the data before it gets rendered in the charts\n    this.eventEmitter.emit('data', {\n      type: 'initial',\n      data: this.data\n    });\n\n    // Create the first chart\n    this.createChart(this.optionsProvider.getCurrentOptions());\n\n    // As chart is initialized from the event loop now we can reset our timeout reference\n    // This is important if the chart gets initialized on the same element twice\n    this.initializeTimeoutId = undefined;\n  }\n\n  /**\n   * Constructor of chart base class.\n   *\n   * @param query\n   * @param data\n   * @param defaultOptions\n   * @param options\n   * @param responsiveOptions\n   * @constructor\n   */\n  function Base(query, data, defaultOptions, options, responsiveOptions) {\n    this.container = Chartist.querySelector(query);\n    this.data = data || {};\n    this.data.labels = this.data.labels || [];\n    this.data.series = this.data.series || [];\n    this.defaultOptions = defaultOptions;\n    this.options = options;\n    this.responsiveOptions = responsiveOptions;\n    this.eventEmitter = Chartist.EventEmitter();\n    this.supportsForeignObject = Chartist.Svg.isSupported('Extensibility');\n    this.supportsAnimations = Chartist.Svg.isSupported('AnimationEventsAttribute');\n    this.resizeListener = function resizeListener(){\n      this.update();\n    }.bind(this);\n\n    if(this.container) {\n      // If chartist was already initialized in this container we are detaching all event listeners first\n      if(this.container.__chartist__) {\n        this.container.__chartist__.detach();\n      }\n\n      this.container.__chartist__ = this;\n    }\n\n    // Using event loop for first draw to make it possible to register event listeners in the same call stack where\n    // the chart was created.\n    this.initializeTimeoutId = setTimeout(initialize.bind(this), 0);\n  }\n\n  // Creating the chart base class\n  Chartist.Base = Chartist.Class.extend({\n    constructor: Base,\n    optionsProvider: undefined,\n    container: undefined,\n    svg: undefined,\n    eventEmitter: undefined,\n    createChart: function() {\n      throw new Error('Base chart type can\\'t be instantiated!');\n    },\n    update: update,\n    detach: detach,\n    on: on,\n    off: off,\n    version: Chartist.version,\n    supportsForeignObject: false\n  });\n\n}(this || global, Chartist));\n;/**\n * Chartist SVG module for simple SVG DOM abstraction\n *\n * @module Chartist.Svg\n */\n/* global Chartist */\n(function(globalRoot, Chartist) {\n  'use strict';\n\n  var document = globalRoot.document;\n\n  /**\n   * Chartist.Svg creates a new SVG object wrapper with a starting element. You can use the wrapper to fluently create sub-elements and modify them.\n   *\n   * @memberof Chartist.Svg\n   * @constructor\n   * @param {String|Element} name The name of the SVG element to create or an SVG dom element which should be wrapped into Chartist.Svg\n   * @param {Object} attributes An object with properties that will be added as attributes to the SVG element that is created. Attributes with undefined values will not be added.\n   * @param {String} className This class or class list will be added to the SVG element\n   * @param {Object} parent The parent SVG wrapper object where this newly created wrapper and it's element will be attached to as child\n   * @param {Boolean} insertFirst If this param is set to true in conjunction with a parent element the newly created element will be added as first child element in the parent element\n   */\n  function Svg(name, attributes, className, parent, insertFirst) {\n    // If Svg is getting called with an SVG element we just return the wrapper\n    if(name instanceof Element) {\n      this._node = name;\n    } else {\n      this._node = document.createElementNS(Chartist.namespaces.svg, name);\n\n      // If this is an SVG element created then custom namespace\n      if(name === 'svg') {\n        this.attr({\n          'xmlns:ct': Chartist.namespaces.ct\n        });\n      }\n    }\n\n    if(attributes) {\n      this.attr(attributes);\n    }\n\n    if(className) {\n      this.addClass(className);\n    }\n\n    if(parent) {\n      if (insertFirst && parent._node.firstChild) {\n        parent._node.insertBefore(this._node, parent._node.firstChild);\n      } else {\n        parent._node.appendChild(this._node);\n      }\n    }\n  }\n\n  /**\n   * Set attributes on the current SVG element of the wrapper you're currently working on.\n   *\n   * @memberof Chartist.Svg\n   * @param {Object|String} attributes An object with properties that will be added as attributes to the SVG element that is created. Attributes with undefined values will not be added. If this parameter is a String then the function is used as a getter and will return the attribute value.\n   * @param {String} [ns] If specified, the attribute will be obtained using getAttributeNs. In order to write namepsaced attributes you can use the namespace:attribute notation within the attributes object.\n   * @return {Object|String} The current wrapper object will be returned so it can be used for chaining or the attribute value if used as getter function.\n   */\n  function attr(attributes, ns) {\n    if(typeof attributes === 'string') {\n      if(ns) {\n        return this._node.getAttributeNS(ns, attributes);\n      } else {\n        return this._node.getAttribute(attributes);\n      }\n    }\n\n    Object.keys(attributes).forEach(function(key) {\n      // If the attribute value is undefined we can skip this one\n      if(attributes[key] === undefined) {\n        return;\n      }\n\n      if (key.indexOf(':') !== -1) {\n        var namespacedAttribute = key.split(':');\n        this._node.setAttributeNS(Chartist.namespaces[namespacedAttribute[0]], key, attributes[key]);\n      } else {\n        this._node.setAttribute(key, attributes[key]);\n      }\n    }.bind(this));\n\n    return this;\n  }\n\n  /**\n   * Create a new SVG element whose wrapper object will be selected for further operations. This way you can also create nested groups easily.\n   *\n   * @memberof Chartist.Svg\n   * @param {String} name The name of the SVG element that should be created as child element of the currently selected element wrapper\n   * @param {Object} [attributes] An object with properties that will be added as attributes to the SVG element that is created. Attributes with undefined values will not be added.\n   * @param {String} [className] This class or class list will be added to the SVG element\n   * @param {Boolean} [insertFirst] If this param is set to true in conjunction with a parent element the newly created element will be added as first child element in the parent element\n   * @return {Chartist.Svg} Returns a Chartist.Svg wrapper object that can be used to modify the containing SVG data\n   */\n  function elem(name, attributes, className, insertFirst) {\n    return new Chartist.Svg(name, attributes, className, this, insertFirst);\n  }\n\n  /**\n   * Returns the parent Chartist.SVG wrapper object\n   *\n   * @memberof Chartist.Svg\n   * @return {Chartist.Svg} Returns a Chartist.Svg wrapper around the parent node of the current node. If the parent node is not existing or it's not an SVG node then this function will return null.\n   */\n  function parent() {\n    return this._node.parentNode instanceof SVGElement ? new Chartist.Svg(this._node.parentNode) : null;\n  }\n\n  /**\n   * This method returns a Chartist.Svg wrapper around the root SVG element of the current tree.\n   *\n   * @memberof Chartist.Svg\n   * @return {Chartist.Svg} The root SVG element wrapped in a Chartist.Svg element\n   */\n  function root() {\n    var node = this._node;\n    while(node.nodeName !== 'svg') {\n      node = node.parentNode;\n    }\n    return new Chartist.Svg(node);\n  }\n\n  /**\n   * Find the first child SVG element of the current element that matches a CSS selector. The returned object is a Chartist.Svg wrapper.\n   *\n   * @memberof Chartist.Svg\n   * @param {String} selector A CSS selector that is used to query for child SVG elements\n   * @return {Chartist.Svg} The SVG wrapper for the element found or null if no element was found\n   */\n  function querySelector(selector) {\n    var foundNode = this._node.querySelector(selector);\n    return foundNode ? new Chartist.Svg(foundNode) : null;\n  }\n\n  /**\n   * Find the all child SVG elements of the current element that match a CSS selector. The returned object is a Chartist.Svg.List wrapper.\n   *\n   * @memberof Chartist.Svg\n   * @param {String} selector A CSS selector that is used to query for child SVG elements\n   * @return {Chartist.Svg.List} The SVG wrapper list for the element found or null if no element was found\n   */\n  function querySelectorAll(selector) {\n    var foundNodes = this._node.querySelectorAll(selector);\n    return foundNodes.length ? new Chartist.Svg.List(foundNodes) : null;\n  }\n\n  /**\n   * Returns the underlying SVG node for the current element.\n   *\n   * @memberof Chartist.Svg\n   * @returns {Node}\n   */\n  function getNode() {\n    return this._node;\n  }\n\n  /**\n   * This method creates a foreignObject (see https://developer.mozilla.org/en-US/docs/Web/SVG/Element/foreignObject) that allows to embed HTML content into a SVG graphic. With the help of foreignObjects you can enable the usage of regular HTML elements inside of SVG where they are subject for SVG positioning and transformation but the Browser will use the HTML rendering capabilities for the containing DOM.\n   *\n   * @memberof Chartist.Svg\n   * @param {Node|String} content The DOM Node, or HTML string that will be converted to a DOM Node, that is then placed into and wrapped by the foreignObject\n   * @param {String} [attributes] An object with properties that will be added as attributes to the foreignObject element that is created. Attributes with undefined values will not be added.\n   * @param {String} [className] This class or class list will be added to the SVG element\n   * @param {Boolean} [insertFirst] Specifies if the foreignObject should be inserted as first child\n   * @return {Chartist.Svg} New wrapper object that wraps the foreignObject element\n   */\n  function foreignObject(content, attributes, className, insertFirst) {\n    // If content is string then we convert it to DOM\n    // TODO: Handle case where content is not a string nor a DOM Node\n    if(typeof content === 'string') {\n      var container = document.createElement('div');\n      container.innerHTML = content;\n      content = container.firstChild;\n    }\n\n    // Adding namespace to content element\n    content.setAttribute('xmlns', Chartist.namespaces.xmlns);\n\n    // Creating the foreignObject without required extension attribute (as described here\n    // http://www.w3.org/TR/SVG/extend.html#ForeignObjectElement)\n    var fnObj = this.elem('foreignObject', attributes, className, insertFirst);\n\n    // Add content to foreignObjectElement\n    fnObj._node.appendChild(content);\n\n    return fnObj;\n  }\n\n  /**\n   * This method adds a new text element to the current Chartist.Svg wrapper.\n   *\n   * @memberof Chartist.Svg\n   * @param {String} t The text that should be added to the text element that is created\n   * @return {Chartist.Svg} The same wrapper object that was used to add the newly created element\n   */\n  function text(t) {\n    this._node.appendChild(document.createTextNode(t));\n    return this;\n  }\n\n  /**\n   * This method will clear all child nodes of the current wrapper object.\n   *\n   * @memberof Chartist.Svg\n   * @return {Chartist.Svg} The same wrapper object that got emptied\n   */\n  function empty() {\n    while (this._node.firstChild) {\n      this._node.removeChild(this._node.firstChild);\n    }\n\n    return this;\n  }\n\n  /**\n   * This method will cause the current wrapper to remove itself from its parent wrapper. Use this method if you'd like to get rid of an element in a given DOM structure.\n   *\n   * @memberof Chartist.Svg\n   * @return {Chartist.Svg} The parent wrapper object of the element that got removed\n   */\n  function remove() {\n    this._node.parentNode.removeChild(this._node);\n    return this.parent();\n  }\n\n  /**\n   * This method will replace the element with a new element that can be created outside of the current DOM.\n   *\n   * @memberof Chartist.Svg\n   * @param {Chartist.Svg} newElement The new Chartist.Svg object that will be used to replace the current wrapper object\n   * @return {Chartist.Svg} The wrapper of the new element\n   */\n  function replace(newElement) {\n    this._node.parentNode.replaceChild(newElement._node, this._node);\n    return newElement;\n  }\n\n  /**\n   * This method will append an element to the current element as a child.\n   *\n   * @memberof Chartist.Svg\n   * @param {Chartist.Svg} element The Chartist.Svg element that should be added as a child\n   * @param {Boolean} [insertFirst] Specifies if the element should be inserted as first child\n   * @return {Chartist.Svg} The wrapper of the appended object\n   */\n  function append(element, insertFirst) {\n    if(insertFirst && this._node.firstChild) {\n      this._node.insertBefore(element._node, this._node.firstChild);\n    } else {\n      this._node.appendChild(element._node);\n    }\n\n    return this;\n  }\n\n  /**\n   * Returns an array of class names that are attached to the current wrapper element. This method can not be chained further.\n   *\n   * @memberof Chartist.Svg\n   * @return {Array} A list of classes or an empty array if there are no classes on the current element\n   */\n  function classes() {\n    return this._node.getAttribute('class') ? this._node.getAttribute('class').trim().split(/\\s+/) : [];\n  }\n\n  /**\n   * Adds one or a space separated list of classes to the current element and ensures the classes are only existing once.\n   *\n   * @memberof Chartist.Svg\n   * @param {String} names A white space separated list of class names\n   * @return {Chartist.Svg} The wrapper of the current element\n   */\n  function addClass(names) {\n    this._node.setAttribute('class',\n      this.classes(this._node)\n        .concat(names.trim().split(/\\s+/))\n        .filter(function(elem, pos, self) {\n          return self.indexOf(elem) === pos;\n        }).join(' ')\n    );\n\n    return this;\n  }\n\n  /**\n   * Removes one or a space separated list of classes from the current element.\n   *\n   * @memberof Chartist.Svg\n   * @param {String} names A white space separated list of class names\n   * @return {Chartist.Svg} The wrapper of the current element\n   */\n  function removeClass(names) {\n    var removedClasses = names.trim().split(/\\s+/);\n\n    this._node.setAttribute('class', this.classes(this._node).filter(function(name) {\n      return removedClasses.indexOf(name) === -1;\n    }).join(' '));\n\n    return this;\n  }\n\n  /**\n   * Removes all classes from the current element.\n   *\n   * @memberof Chartist.Svg\n   * @return {Chartist.Svg} The wrapper of the current element\n   */\n  function removeAllClasses() {\n    this._node.setAttribute('class', '');\n\n    return this;\n  }\n\n  /**\n   * Get element height using `getBoundingClientRect`\n   *\n   * @memberof Chartist.Svg\n   * @return {Number} The elements height in pixels\n   */\n  function height() {\n    return this._node.getBoundingClientRect().height;\n  }\n\n  /**\n   * Get element width using `getBoundingClientRect`\n   *\n   * @memberof Chartist.Core\n   * @return {Number} The elements width in pixels\n   */\n  function width() {\n    return this._node.getBoundingClientRect().width;\n  }\n\n  /**\n   * The animate function lets you animate the current element with SMIL animations. You can add animations for multiple attributes at the same time by using an animation definition object. This object should contain SMIL animation attributes. Please refer to http://www.w3.org/TR/SVG/animate.html for a detailed specification about the available animation attributes. Additionally an easing property can be passed in the animation definition object. This can be a string with a name of an easing function in `Chartist.Svg.Easing` or an array with four numbers specifying a cubic Bzier curve.\n   * **An animations object could look like this:**\n   * ```javascript\n   * element.animate({\n   *   opacity: {\n   *     dur: 1000,\n   *     from: 0,\n   *     to: 1\n   *   },\n   *   x1: {\n   *     dur: '1000ms',\n   *     from: 100,\n   *     to: 200,\n   *     easing: 'easeOutQuart'\n   *   },\n   *   y1: {\n   *     dur: '2s',\n   *     from: 0,\n   *     to: 100\n   *   }\n   * });\n   * ```\n   * **Automatic unit conversion**\n   * For the `dur` and the `begin` animate attribute you can also omit a unit by passing a number. The number will automatically be converted to milli seconds.\n   * **Guided mode**\n   * The default behavior of SMIL animations with offset using the `begin` attribute is that the attribute will keep it's original value until the animation starts. Mostly this behavior is not desired as you'd like to have your element attributes already initialized with the animation `from` value even before the animation starts. Also if you don't specify `fill=\"freeze\"` on an animate element or if you delete the animation after it's done (which is done in guided mode) the attribute will switch back to the initial value. This behavior is also not desired when performing simple one-time animations. For one-time animations you'd want to trigger animations immediately instead of relative to the document begin time. That's why in guided mode Chartist.Svg will also use the `begin` property to schedule a timeout and manually start the animation after the timeout. If you're using multiple SMIL definition objects for an attribute (in an array), guided mode will be disabled for this attribute, even if you explicitly enabled it.\n   * If guided mode is enabled the following behavior is added:\n   * - Before the animation starts (even when delayed with `begin`) the animated attribute will be set already to the `from` value of the animation\n   * - `begin` is explicitly set to `indefinite` so it can be started manually without relying on document begin time (creation)\n   * - The animate element will be forced to use `fill=\"freeze\"`\n   * - The animation will be triggered with `beginElement()` in a timeout where `begin` of the definition object is interpreted in milli seconds. If no `begin` was specified the timeout is triggered immediately.\n   * - After the animation the element attribute value will be set to the `to` value of the animation\n   * - The animate element is deleted from the DOM\n   *\n   * @memberof Chartist.Svg\n   * @param {Object} animations An animations object where the property keys are the attributes you'd like to animate. The properties should be objects again that contain the SMIL animation attributes (usually begin, dur, from, and to). The property begin and dur is auto converted (see Automatic unit conversion). You can also schedule multiple animations for the same attribute by passing an Array of SMIL definition objects. Attributes that contain an array of SMIL definition objects will not be executed in guided mode.\n   * @param {Boolean} guided Specify if guided mode should be activated for this animation (see Guided mode). If not otherwise specified, guided mode will be activated.\n   * @param {Object} eventEmitter If specified, this event emitter will be notified when an animation starts or ends.\n   * @return {Chartist.Svg} The current element where the animation was added\n   */\n  function animate(animations, guided, eventEmitter) {\n    if(guided === undefined) {\n      guided = true;\n    }\n\n    Object.keys(animations).forEach(function createAnimateForAttributes(attribute) {\n\n      function createAnimate(animationDefinition, guided) {\n        var attributeProperties = {},\n          animate,\n          timeout,\n          easing;\n\n        // Check if an easing is specified in the definition object and delete it from the object as it will not\n        // be part of the animate element attributes.\n        if(animationDefinition.easing) {\n          // If already an easing Bzier curve array we take it or we lookup a easing array in the Easing object\n          easing = animationDefinition.easing instanceof Array ?\n            animationDefinition.easing :\n            Chartist.Svg.Easing[animationDefinition.easing];\n          delete animationDefinition.easing;\n        }\n\n        // If numeric dur or begin was provided we assume milli seconds\n        animationDefinition.begin = Chartist.ensureUnit(animationDefinition.begin, 'ms');\n        animationDefinition.dur = Chartist.ensureUnit(animationDefinition.dur, 'ms');\n\n        if(easing) {\n          animationDefinition.calcMode = 'spline';\n          animationDefinition.keySplines = easing.join(' ');\n          animationDefinition.keyTimes = '0;1';\n        }\n\n        // Adding \"fill: freeze\" if we are in guided mode and set initial attribute values\n        if(guided) {\n          animationDefinition.fill = 'freeze';\n          // Animated property on our element should already be set to the animation from value in guided mode\n          attributeProperties[attribute] = animationDefinition.from;\n          this.attr(attributeProperties);\n\n          // In guided mode we also set begin to indefinite so we can trigger the start manually and put the begin\n          // which needs to be in ms aside\n          timeout = Chartist.quantity(animationDefinition.begin || 0).value;\n          animationDefinition.begin = 'indefinite';\n        }\n\n        animate = this.elem('animate', Chartist.extend({\n          attributeName: attribute\n        }, animationDefinition));\n\n        if(guided) {\n          // If guided we take the value that was put aside in timeout and trigger the animation manually with a timeout\n          setTimeout(function() {\n            // If beginElement fails we set the animated attribute to the end position and remove the animate element\n            // This happens if the SMIL ElementTimeControl interface is not supported or any other problems occured in\n            // the browser. (Currently FF 34 does not support animate elements in foreignObjects)\n            try {\n              animate._node.beginElement();\n            } catch(err) {\n              // Set animated attribute to current animated value\n              attributeProperties[attribute] = animationDefinition.to;\n              this.attr(attributeProperties);\n              // Remove the animate element as it's no longer required\n              animate.remove();\n            }\n          }.bind(this), timeout);\n        }\n\n        if(eventEmitter) {\n          animate._node.addEventListener('beginEvent', function handleBeginEvent() {\n            eventEmitter.emit('animationBegin', {\n              element: this,\n              animate: animate._node,\n              params: animationDefinition\n            });\n          }.bind(this));\n        }\n\n        animate._node.addEventListener('endEvent', function handleEndEvent() {\n          if(eventEmitter) {\n            eventEmitter.emit('animationEnd', {\n              element: this,\n              animate: animate._node,\n              params: animationDefinition\n            });\n          }\n\n          if(guided) {\n            // Set animated attribute to current animated value\n            attributeProperties[attribute] = animationDefinition.to;\n            this.attr(attributeProperties);\n            // Remove the animate element as it's no longer required\n            animate.remove();\n          }\n        }.bind(this));\n      }\n\n      // If current attribute is an array of definition objects we create an animate for each and disable guided mode\n      if(animations[attribute] instanceof Array) {\n        animations[attribute].forEach(function(animationDefinition) {\n          createAnimate.bind(this)(animationDefinition, false);\n        }.bind(this));\n      } else {\n        createAnimate.bind(this)(animations[attribute], guided);\n      }\n\n    }.bind(this));\n\n    return this;\n  }\n\n  Chartist.Svg = Chartist.Class.extend({\n    constructor: Svg,\n    attr: attr,\n    elem: elem,\n    parent: parent,\n    root: root,\n    querySelector: querySelector,\n    querySelectorAll: querySelectorAll,\n    getNode: getNode,\n    foreignObject: foreignObject,\n    text: text,\n    empty: empty,\n    remove: remove,\n    replace: replace,\n    append: append,\n    classes: classes,\n    addClass: addClass,\n    removeClass: removeClass,\n    removeAllClasses: removeAllClasses,\n    height: height,\n    width: width,\n    animate: animate\n  });\n\n  /**\n   * This method checks for support of a given SVG feature like Extensibility, SVG-animation or the like. Check http://www.w3.org/TR/SVG11/feature for a detailed list.\n   *\n   * @memberof Chartist.Svg\n   * @param {String} feature The SVG 1.1 feature that should be checked for support.\n   * @return {Boolean} True of false if the feature is supported or not\n   */\n  Chartist.Svg.isSupported = function(feature) {\n    return document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#' + feature, '1.1');\n  };\n\n  /**\n   * This Object contains some standard easing cubic bezier curves. Then can be used with their name in the `Chartist.Svg.animate`. You can also extend the list and use your own name in the `animate` function. Click the show code button to see the available bezier functions.\n   *\n   * @memberof Chartist.Svg\n   */\n  var easingCubicBeziers = {\n    easeInSine: [0.47, 0, 0.745, 0.715],\n    easeOutSine: [0.39, 0.575, 0.565, 1],\n    easeInOutSine: [0.445, 0.05, 0.55, 0.95],\n    easeInQuad: [0.55, 0.085, 0.68, 0.53],\n    easeOutQuad: [0.25, 0.46, 0.45, 0.94],\n    easeInOutQuad: [0.455, 0.03, 0.515, 0.955],\n    easeInCubic: [0.55, 0.055, 0.675, 0.19],\n    easeOutCubic: [0.215, 0.61, 0.355, 1],\n    easeInOutCubic: [0.645, 0.045, 0.355, 1],\n    easeInQuart: [0.895, 0.03, 0.685, 0.22],\n    easeOutQuart: [0.165, 0.84, 0.44, 1],\n    easeInOutQuart: [0.77, 0, 0.175, 1],\n    easeInQuint: [0.755, 0.05, 0.855, 0.06],\n    easeOutQuint: [0.23, 1, 0.32, 1],\n    easeInOutQuint: [0.86, 0, 0.07, 1],\n    easeInExpo: [0.95, 0.05, 0.795, 0.035],\n    easeOutExpo: [0.19, 1, 0.22, 1],\n    easeInOutExpo: [1, 0, 0, 1],\n    easeInCirc: [0.6, 0.04, 0.98, 0.335],\n    easeOutCirc: [0.075, 0.82, 0.165, 1],\n    easeInOutCirc: [0.785, 0.135, 0.15, 0.86],\n    easeInBack: [0.6, -0.28, 0.735, 0.045],\n    easeOutBack: [0.175, 0.885, 0.32, 1.275],\n    easeInOutBack: [0.68, -0.55, 0.265, 1.55]\n  };\n\n  Chartist.Svg.Easing = easingCubicBeziers;\n\n  /**\n   * This helper class is to wrap multiple `Chartist.Svg` elements into a list where you can call the `Chartist.Svg` functions on all elements in the list with one call. This is helpful when you'd like to perform calls with `Chartist.Svg` on multiple elements.\n   * An instance of this class is also returned by `Chartist.Svg.querySelectorAll`.\n   *\n   * @memberof Chartist.Svg\n   * @param {Array<Node>|NodeList} nodeList An Array of SVG DOM nodes or a SVG DOM NodeList (as returned by document.querySelectorAll)\n   * @constructor\n   */\n  function SvgList(nodeList) {\n    var list = this;\n\n    this.svgElements = [];\n    for(var i = 0; i < nodeList.length; i++) {\n      this.svgElements.push(new Chartist.Svg(nodeList[i]));\n    }\n\n    // Add delegation methods for Chartist.Svg\n    Object.keys(Chartist.Svg.prototype).filter(function(prototypeProperty) {\n      return ['constructor',\n          'parent',\n          'querySelector',\n          'querySelectorAll',\n          'replace',\n          'append',\n          'classes',\n          'height',\n          'width'].indexOf(prototypeProperty) === -1;\n    }).forEach(function(prototypeProperty) {\n      list[prototypeProperty] = function() {\n        var args = Array.prototype.slice.call(arguments, 0);\n        list.svgElements.forEach(function(element) {\n          Chartist.Svg.prototype[prototypeProperty].apply(element, args);\n        });\n        return list;\n      };\n    });\n  }\n\n  Chartist.Svg.List = Chartist.Class.extend({\n    constructor: SvgList\n  });\n}(this || global, Chartist));\n;/**\n * Chartist SVG path module for SVG path description creation and modification.\n *\n * @module Chartist.Svg.Path\n */\n/* global Chartist */\n(function(globalRoot, Chartist) {\n  'use strict';\n\n  /**\n   * Contains the descriptors of supported element types in a SVG path. Currently only move, line and curve are supported.\n   *\n   * @memberof Chartist.Svg.Path\n   * @type {Object}\n   */\n  var elementDescriptions = {\n    m: ['x', 'y'],\n    l: ['x', 'y'],\n    c: ['x1', 'y1', 'x2', 'y2', 'x', 'y'],\n    a: ['rx', 'ry', 'xAr', 'lAf', 'sf', 'x', 'y']\n  };\n\n  /**\n   * Default options for newly created SVG path objects.\n   *\n   * @memberof Chartist.Svg.Path\n   * @type {Object}\n   */\n  var defaultOptions = {\n    // The accuracy in digit count after the decimal point. This will be used to round numbers in the SVG path. If this option is set to false then no rounding will be performed.\n    accuracy: 3\n  };\n\n  function element(command, params, pathElements, pos, relative, data) {\n    var pathElement = Chartist.extend({\n      command: relative ? command.toLowerCase() : command.toUpperCase()\n    }, params, data ? { data: data } : {} );\n\n    pathElements.splice(pos, 0, pathElement);\n  }\n\n  function forEachParam(pathElements, cb) {\n    pathElements.forEach(function(pathElement, pathElementIndex) {\n      elementDescriptions[pathElement.command.toLowerCase()].forEach(function(paramName, paramIndex) {\n        cb(pathElement, paramName, pathElementIndex, paramIndex, pathElements);\n      });\n    });\n  }\n\n  /**\n   * Used to construct a new path object.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Boolean} close If set to true then this path will be closed when stringified (with a Z at the end)\n   * @param {Object} options Options object that overrides the default objects. See default options for more details.\n   * @constructor\n   */\n  function SvgPath(close, options) {\n    this.pathElements = [];\n    this.pos = 0;\n    this.close = close;\n    this.options = Chartist.extend({}, defaultOptions, options);\n  }\n\n  /**\n   * Gets or sets the current position (cursor) inside of the path. You can move around the cursor freely but limited to 0 or the count of existing elements. All modifications with element functions will insert new elements at the position of this cursor.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Number} [pos] If a number is passed then the cursor is set to this position in the path element array.\n   * @return {Chartist.Svg.Path|Number} If the position parameter was passed then the return value will be the path object for easy call chaining. If no position parameter was passed then the current position is returned.\n   */\n  function position(pos) {\n    if(pos !== undefined) {\n      this.pos = Math.max(0, Math.min(this.pathElements.length, pos));\n      return this;\n    } else {\n      return this.pos;\n    }\n  }\n\n  /**\n   * Removes elements from the path starting at the current position.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Number} count Number of path elements that should be removed from the current position.\n   * @return {Chartist.Svg.Path} The current path object for easy call chaining.\n   */\n  function remove(count) {\n    this.pathElements.splice(this.pos, count);\n    return this;\n  }\n\n  /**\n   * Use this function to add a new move SVG path element.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Number} x The x coordinate for the move element.\n   * @param {Number} y The y coordinate for the move element.\n   * @param {Boolean} [relative] If set to true the move element will be created with relative coordinates (lowercase letter)\n   * @param {*} [data] Any data that should be stored with the element object that will be accessible in pathElement\n   * @return {Chartist.Svg.Path} The current path object for easy call chaining.\n   */\n  function move(x, y, relative, data) {\n    element('M', {\n      x: +x,\n      y: +y\n    }, this.pathElements, this.pos++, relative, data);\n    return this;\n  }\n\n  /**\n   * Use this function to add a new line SVG path element.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Number} x The x coordinate for the line element.\n   * @param {Number} y The y coordinate for the line element.\n   * @param {Boolean} [relative] If set to true the line element will be created with relative coordinates (lowercase letter)\n   * @param {*} [data] Any data that should be stored with the element object that will be accessible in pathElement\n   * @return {Chartist.Svg.Path} The current path object for easy call chaining.\n   */\n  function line(x, y, relative, data) {\n    element('L', {\n      x: +x,\n      y: +y\n    }, this.pathElements, this.pos++, relative, data);\n    return this;\n  }\n\n  /**\n   * Use this function to add a new curve SVG path element.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Number} x1 The x coordinate for the first control point of the bezier curve.\n   * @param {Number} y1 The y coordinate for the first control point of the bezier curve.\n   * @param {Number} x2 The x coordinate for the second control point of the bezier curve.\n   * @param {Number} y2 The y coordinate for the second control point of the bezier curve.\n   * @param {Number} x The x coordinate for the target point of the curve element.\n   * @param {Number} y The y coordinate for the target point of the curve element.\n   * @param {Boolean} [relative] If set to true the curve element will be created with relative coordinates (lowercase letter)\n   * @param {*} [data] Any data that should be stored with the element object that will be accessible in pathElement\n   * @return {Chartist.Svg.Path} The current path object for easy call chaining.\n   */\n  function curve(x1, y1, x2, y2, x, y, relative, data) {\n    element('C', {\n      x1: +x1,\n      y1: +y1,\n      x2: +x2,\n      y2: +y2,\n      x: +x,\n      y: +y\n    }, this.pathElements, this.pos++, relative, data);\n    return this;\n  }\n\n  /**\n   * Use this function to add a new non-bezier curve SVG path element.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Number} rx The radius to be used for the x-axis of the arc.\n   * @param {Number} ry The radius to be used for the y-axis of the arc.\n   * @param {Number} xAr Defines the orientation of the arc\n   * @param {Number} lAf Large arc flag\n   * @param {Number} sf Sweep flag\n   * @param {Number} x The x coordinate for the target point of the curve element.\n   * @param {Number} y The y coordinate for the target point of the curve element.\n   * @param {Boolean} [relative] If set to true the curve element will be created with relative coordinates (lowercase letter)\n   * @param {*} [data] Any data that should be stored with the element object that will be accessible in pathElement\n   * @return {Chartist.Svg.Path} The current path object for easy call chaining.\n   */\n  function arc(rx, ry, xAr, lAf, sf, x, y, relative, data) {\n    element('A', {\n      rx: +rx,\n      ry: +ry,\n      xAr: +xAr,\n      lAf: +lAf,\n      sf: +sf,\n      x: +x,\n      y: +y\n    }, this.pathElements, this.pos++, relative, data);\n    return this;\n  }\n\n  /**\n   * Parses an SVG path seen in the d attribute of path elements, and inserts the parsed elements into the existing path object at the current cursor position. Any closing path indicators (Z at the end of the path) will be ignored by the parser as this is provided by the close option in the options of the path object.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {String} path Any SVG path that contains move (m), line (l) or curve (c) components.\n   * @return {Chartist.Svg.Path} The current path object for easy call chaining.\n   */\n  function parse(path) {\n    // Parsing the SVG path string into an array of arrays [['M', '10', '10'], ['L', '100', '100']]\n    var chunks = path.replace(/([A-Za-z])([0-9])/g, '$1 $2')\n      .replace(/([0-9])([A-Za-z])/g, '$1 $2')\n      .split(/[\\s,]+/)\n      .reduce(function(result, element) {\n        if(element.match(/[A-Za-z]/)) {\n          result.push([]);\n        }\n\n        result[result.length - 1].push(element);\n        return result;\n      }, []);\n\n    // If this is a closed path we remove the Z at the end because this is determined by the close option\n    if(chunks[chunks.length - 1][0].toUpperCase() === 'Z') {\n      chunks.pop();\n    }\n\n    // Using svgPathElementDescriptions to map raw path arrays into objects that contain the command and the parameters\n    // For example {command: 'M', x: '10', y: '10'}\n    var elements = chunks.map(function(chunk) {\n        var command = chunk.shift(),\n          description = elementDescriptions[command.toLowerCase()];\n\n        return Chartist.extend({\n          command: command\n        }, description.reduce(function(result, paramName, index) {\n          result[paramName] = +chunk[index];\n          return result;\n        }, {}));\n      });\n\n    // Preparing a splice call with the elements array as var arg params and insert the parsed elements at the current position\n    var spliceArgs = [this.pos, 0];\n    Array.prototype.push.apply(spliceArgs, elements);\n    Array.prototype.splice.apply(this.pathElements, spliceArgs);\n    // Increase the internal position by the element count\n    this.pos += elements.length;\n\n    return this;\n  }\n\n  /**\n   * This function renders to current SVG path object into a final SVG string that can be used in the d attribute of SVG path elements. It uses the accuracy option to round big decimals. If the close parameter was set in the constructor of this path object then a path closing Z will be appended to the output string.\n   *\n   * @memberof Chartist.Svg.Path\n   * @return {String}\n   */\n  function stringify() {\n    var accuracyMultiplier = Math.pow(10, this.options.accuracy);\n\n    return this.pathElements.reduce(function(path, pathElement) {\n        var params = elementDescriptions[pathElement.command.toLowerCase()].map(function(paramName) {\n          return this.options.accuracy ?\n            (Math.round(pathElement[paramName] * accuracyMultiplier) / accuracyMultiplier) :\n            pathElement[paramName];\n        }.bind(this));\n\n        return path + pathElement.command + params.join(',');\n      }.bind(this), '') + (this.close ? 'Z' : '');\n  }\n\n  /**\n   * Scales all elements in the current SVG path object. There is an individual parameter for each coordinate. Scaling will also be done for control points of curves, affecting the given coordinate.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Number} x The number which will be used to scale the x, x1 and x2 of all path elements.\n   * @param {Number} y The number which will be used to scale the y, y1 and y2 of all path elements.\n   * @return {Chartist.Svg.Path} The current path object for easy call chaining.\n   */\n  function scale(x, y) {\n    forEachParam(this.pathElements, function(pathElement, paramName) {\n      pathElement[paramName] *= paramName[0] === 'x' ? x : y;\n    });\n    return this;\n  }\n\n  /**\n   * Translates all elements in the current SVG path object. The translation is relative and there is an individual parameter for each coordinate. Translation will also be done for control points of curves, affecting the given coordinate.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Number} x The number which will be used to translate the x, x1 and x2 of all path elements.\n   * @param {Number} y The number which will be used to translate the y, y1 and y2 of all path elements.\n   * @return {Chartist.Svg.Path} The current path object for easy call chaining.\n   */\n  function translate(x, y) {\n    forEachParam(this.pathElements, function(pathElement, paramName) {\n      pathElement[paramName] += paramName[0] === 'x' ? x : y;\n    });\n    return this;\n  }\n\n  /**\n   * This function will run over all existing path elements and then loop over their attributes. The callback function will be called for every path element attribute that exists in the current path.\n   * The method signature of the callback function looks like this:\n   * ```javascript\n   * function(pathElement, paramName, pathElementIndex, paramIndex, pathElements)\n   * ```\n   * If something else than undefined is returned by the callback function, this value will be used to replace the old value. This allows you to build custom transformations of path objects that can't be achieved using the basic transformation functions scale and translate.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Function} transformFnc The callback function for the transformation. Check the signature in the function description.\n   * @return {Chartist.Svg.Path} The current path object for easy call chaining.\n   */\n  function transform(transformFnc) {\n    forEachParam(this.pathElements, function(pathElement, paramName, pathElementIndex, paramIndex, pathElements) {\n      var transformed = transformFnc(pathElement, paramName, pathElementIndex, paramIndex, pathElements);\n      if(transformed || transformed === 0) {\n        pathElement[paramName] = transformed;\n      }\n    });\n    return this;\n  }\n\n  /**\n   * This function clones a whole path object with all its properties. This is a deep clone and path element objects will also be cloned.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Boolean} [close] Optional option to set the new cloned path to closed. If not specified or false, the original path close option will be used.\n   * @return {Chartist.Svg.Path}\n   */\n  function clone(close) {\n    var c = new Chartist.Svg.Path(close || this.close);\n    c.pos = this.pos;\n    c.pathElements = this.pathElements.slice().map(function cloneElements(pathElement) {\n      return Chartist.extend({}, pathElement);\n    });\n    c.options = Chartist.extend({}, this.options);\n    return c;\n  }\n\n  /**\n   * Split a Svg.Path object by a specific command in the path chain. The path chain will be split and an array of newly created paths objects will be returned. This is useful if you'd like to split an SVG path by it's move commands, for example, in order to isolate chunks of drawings.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {String} command The command you'd like to use to split the path\n   * @return {Array<Chartist.Svg.Path>}\n   */\n  function splitByCommand(command) {\n    var split = [\n      new Chartist.Svg.Path()\n    ];\n\n    this.pathElements.forEach(function(pathElement) {\n      if(pathElement.command === command.toUpperCase() && split[split.length - 1].pathElements.length !== 0) {\n        split.push(new Chartist.Svg.Path());\n      }\n\n      split[split.length - 1].pathElements.push(pathElement);\n    });\n\n    return split;\n  }\n\n  /**\n   * This static function on `Chartist.Svg.Path` is joining multiple paths together into one paths.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Array<Chartist.Svg.Path>} paths A list of paths to be joined together. The order is important.\n   * @param {boolean} close If the newly created path should be a closed path\n   * @param {Object} options Path options for the newly created path.\n   * @return {Chartist.Svg.Path}\n   */\n\n  function join(paths, close, options) {\n    var joinedPath = new Chartist.Svg.Path(close, options);\n    for(var i = 0; i < paths.length; i++) {\n      var path = paths[i];\n      for(var j = 0; j < path.pathElements.length; j++) {\n        joinedPath.pathElements.push(path.pathElements[j]);\n      }\n    }\n    return joinedPath;\n  }\n\n  Chartist.Svg.Path = Chartist.Class.extend({\n    constructor: SvgPath,\n    position: position,\n    remove: remove,\n    move: move,\n    line: line,\n    curve: curve,\n    arc: arc,\n    scale: scale,\n    translate: translate,\n    transform: transform,\n    parse: parse,\n    stringify: stringify,\n    clone: clone,\n    splitByCommand: splitByCommand\n  });\n\n  Chartist.Svg.Path.elementDescriptions = elementDescriptions;\n  Chartist.Svg.Path.join = join;\n}(this || global, Chartist));\n;/* global Chartist */\n(function (globalRoot, Chartist) {\n  'use strict';\n\n  var window = globalRoot.window;\n  var document = globalRoot.document;\n\n  var axisUnits = {\n    x: {\n      pos: 'x',\n      len: 'width',\n      dir: 'horizontal',\n      rectStart: 'x1',\n      rectEnd: 'x2',\n      rectOffset: 'y2'\n    },\n    y: {\n      pos: 'y',\n      len: 'height',\n      dir: 'vertical',\n      rectStart: 'y2',\n      rectEnd: 'y1',\n      rectOffset: 'x1'\n    }\n  };\n\n  function Axis(units, chartRect, ticks, options) {\n    this.units = units;\n    this.counterUnits = units === axisUnits.x ? axisUnits.y : axisUnits.x;\n    this.chartRect = chartRect;\n    this.axisLength = chartRect[units.rectEnd] - chartRect[units.rectStart];\n    this.gridOffset = chartRect[units.rectOffset];\n    this.ticks = ticks;\n    this.options = options;\n  }\n\n  function createGridAndLabels(gridGroup, labelGroup, useForeignObject, chartOptions, eventEmitter) {\n    var axisOptions = chartOptions['axis' + this.units.pos.toUpperCase()];\n    var projectedValues = this.ticks.map(this.projectValue.bind(this));\n    var labelValues = this.ticks.map(axisOptions.labelInterpolationFnc);\n\n    projectedValues.forEach(function(projectedValue, index) {\n      var labelOffset = {\n        x: 0,\n        y: 0\n      };\n\n      // TODO: Find better solution for solving this problem\n      // Calculate how much space we have available for the label\n      var labelLength;\n      if(projectedValues[index + 1]) {\n        // If we still have one label ahead, we can calculate the distance to the next tick / label\n        labelLength = projectedValues[index + 1] - projectedValue;\n      } else {\n        // If we don't have a label ahead and we have only two labels in total, we just take the remaining distance to\n        // on the whole axis length. We limit that to a minimum of 30 pixel, so that labels close to the border will\n        // still be visible inside of the chart padding.\n        labelLength = Math.max(this.axisLength - projectedValue, 30);\n      }\n\n      // Skip grid lines and labels where interpolated label values are falsey (execpt for 0)\n      if(Chartist.isFalseyButZero(labelValues[index]) && labelValues[index] !== '') {\n        return;\n      }\n\n      // Transform to global coordinates using the chartRect\n      // We also need to set the label offset for the createLabel function\n      if(this.units.pos === 'x') {\n        projectedValue = this.chartRect.x1 + projectedValue;\n        labelOffset.x = chartOptions.axisX.labelOffset.x;\n\n        // If the labels should be positioned in start position (top side for vertical axis) we need to set a\n        // different offset as for positioned with end (bottom)\n        if(chartOptions.axisX.position === 'start') {\n          labelOffset.y = this.chartRect.padding.top + chartOptions.axisX.labelOffset.y + (useForeignObject ? 5 : 20);\n        } else {\n          labelOffset.y = this.chartRect.y1 + chartOptions.axisX.labelOffset.y + (useForeignObject ? 5 : 20);\n        }\n      } else {\n        projectedValue = this.chartRect.y1 - projectedValue;\n        labelOffset.y = chartOptions.axisY.labelOffset.y - (useForeignObject ? labelLength : 0);\n\n        // If the labels should be positioned in start position (left side for horizontal axis) we need to set a\n        // different offset as for positioned with end (right side)\n        if(chartOptions.axisY.position === 'start') {\n          labelOffset.x = useForeignObject ? this.chartRect.padding.left + chartOptions.axisY.labelOffset.x : this.chartRect.x1 - 10;\n        } else {\n          labelOffset.x = this.chartRect.x2 + chartOptions.axisY.labelOffset.x + 10;\n        }\n      }\n\n      if(axisOptions.showGrid) {\n        Chartist.createGrid(projectedValue, index, this, this.gridOffset, this.chartRect[this.counterUnits.len](), gridGroup, [\n          chartOptions.classNames.grid,\n          chartOptions.classNames[this.units.dir]\n        ], eventEmitter);\n      }\n\n      if(axisOptions.showLabel) {\n        Chartist.createLabel(projectedValue, labelLength, index, labelValues, this, axisOptions.offset, labelOffset, labelGroup, [\n          chartOptions.classNames.label,\n          chartOptions.classNames[this.units.dir],\n          (axisOptions.position === 'start' ? chartOptions.classNames[axisOptions.position] : chartOptions.classNames['end'])\n        ], useForeignObject, eventEmitter);\n      }\n    }.bind(this));\n  }\n\n  Chartist.Axis = Chartist.Class.extend({\n    constructor: Axis,\n    createGridAndLabels: createGridAndLabels,\n    projectValue: function(value, index, data) {\n      throw new Error('Base axis can\\'t be instantiated!');\n    }\n  });\n\n  Chartist.Axis.units = axisUnits;\n\n}(this || global, Chartist));\n;/**\n * The auto scale axis uses standard linear scale projection of values along an axis. It uses order of magnitude to find a scale automatically and evaluates the available space in order to find the perfect amount of ticks for your chart.\n * **Options**\n * The following options are used by this axis in addition to the default axis options outlined in the axis configuration of the chart default settings.\n * ```javascript\n * var options = {\n *   // If high is specified then the axis will display values explicitly up to this value and the computed maximum from the data is ignored\n *   high: 100,\n *   // If low is specified then the axis will display values explicitly down to this value and the computed minimum from the data is ignored\n *   low: 0,\n *   // This option will be used when finding the right scale division settings. The amount of ticks on the scale will be determined so that as many ticks as possible will be displayed, while not violating this minimum required space (in pixel).\n *   scaleMinSpace: 20,\n *   // Can be set to true or false. If set to true, the scale will be generated with whole numbers only.\n *   onlyInteger: true,\n *   // The reference value can be used to make sure that this value will always be on the chart. This is especially useful on bipolar charts where the bipolar center always needs to be part of the chart.\n *   referenceValue: 5\n * };\n * ```\n *\n * @module Chartist.AutoScaleAxis\n */\n/* global Chartist */\n(function (globalRoot, Chartist) {\n  'use strict';\n\n  var window = globalRoot.window;\n  var document = globalRoot.document;\n\n  function AutoScaleAxis(axisUnit, data, chartRect, options) {\n    // Usually we calculate highLow based on the data but this can be overriden by a highLow object in the options\n    var highLow = options.highLow || Chartist.getHighLow(data, options, axisUnit.pos);\n    this.bounds = Chartist.getBounds(chartRect[axisUnit.rectEnd] - chartRect[axisUnit.rectStart], highLow, options.scaleMinSpace || 20, options.onlyInteger);\n    this.range = {\n      min: this.bounds.min,\n      max: this.bounds.max\n    };\n\n    Chartist.AutoScaleAxis.super.constructor.call(this,\n      axisUnit,\n      chartRect,\n      this.bounds.values,\n      options);\n  }\n\n  function projectValue(value) {\n    return this.axisLength * (+Chartist.getMultiValue(value, this.units.pos) - this.bounds.min) / this.bounds.range;\n  }\n\n  Chartist.AutoScaleAxis = Chartist.Axis.extend({\n    constructor: AutoScaleAxis,\n    projectValue: projectValue\n  });\n\n}(this || global, Chartist));\n;/**\n * The fixed scale axis uses standard linear projection of values along an axis. It makes use of a divisor option to divide the range provided from the minimum and maximum value or the options high and low that will override the computed minimum and maximum.\n * **Options**\n * The following options are used by this axis in addition to the default axis options outlined in the axis configuration of the chart default settings.\n * ```javascript\n * var options = {\n *   // If high is specified then the axis will display values explicitly up to this value and the computed maximum from the data is ignored\n *   high: 100,\n *   // If low is specified then the axis will display values explicitly down to this value and the computed minimum from the data is ignored\n *   low: 0,\n *   // If specified then the value range determined from minimum to maximum (or low and high) will be divided by this number and ticks will be generated at those division points. The default divisor is 1.\n *   divisor: 4,\n *   // If ticks is explicitly set, then the axis will not compute the ticks with the divisor, but directly use the data in ticks to determine at what points on the axis a tick need to be generated.\n *   ticks: [1, 10, 20, 30]\n * };\n * ```\n *\n * @module Chartist.FixedScaleAxis\n */\n/* global Chartist */\n(function (globalRoot, Chartist) {\n  'use strict';\n\n  var window = globalRoot.window;\n  var document = globalRoot.document;\n\n  function FixedScaleAxis(axisUnit, data, chartRect, options) {\n    var highLow = options.highLow || Chartist.getHighLow(data, options, axisUnit.pos);\n    this.divisor = options.divisor || 1;\n    this.ticks = options.ticks || Chartist.times(this.divisor).map(function(value, index) {\n      return highLow.low + (highLow.high - highLow.low) / this.divisor * index;\n    }.bind(this));\n    this.ticks.sort(function(a, b) {\n      return a - b;\n    });\n    this.range = {\n      min: highLow.low,\n      max: highLow.high\n    };\n\n    Chartist.FixedScaleAxis.super.constructor.call(this,\n      axisUnit,\n      chartRect,\n      this.ticks,\n      options);\n\n    this.stepLength = this.axisLength / this.divisor;\n  }\n\n  function projectValue(value) {\n    return this.axisLength * (+Chartist.getMultiValue(value, this.units.pos) - this.range.min) / (this.range.max - this.range.min);\n  }\n\n  Chartist.FixedScaleAxis = Chartist.Axis.extend({\n    constructor: FixedScaleAxis,\n    projectValue: projectValue\n  });\n\n}(this || global, Chartist));\n;/**\n * The step axis for step based charts like bar chart or step based line charts. It uses a fixed amount of ticks that will be equally distributed across the whole axis length. The projection is done using the index of the data value rather than the value itself and therefore it's only useful for distribution purpose.\n * **Options**\n * The following options are used by this axis in addition to the default axis options outlined in the axis configuration of the chart default settings.\n * ```javascript\n * var options = {\n *   // Ticks to be used to distribute across the axis length. As this axis type relies on the index of the value rather than the value, arbitrary data that can be converted to a string can be used as ticks.\n *   ticks: ['One', 'Two', 'Three'],\n *   // If set to true the full width will be used to distribute the values where the last value will be at the maximum of the axis length. If false the spaces between the ticks will be evenly distributed instead.\n *   stretch: true\n * };\n * ```\n *\n * @module Chartist.StepAxis\n */\n/* global Chartist */\n(function (globalRoot, Chartist) {\n  'use strict';\n\n  var window = globalRoot.window;\n  var document = globalRoot.document;\n\n  function StepAxis(axisUnit, data, chartRect, options) {\n    Chartist.StepAxis.super.constructor.call(this,\n      axisUnit,\n      chartRect,\n      options.ticks,\n      options);\n\n    var calc = Math.max(1, options.ticks.length - (options.stretch ? 1 : 0));\n    this.stepLength = this.axisLength / calc;\n  }\n\n  function projectValue(value, index) {\n    return this.stepLength * index;\n  }\n\n  Chartist.StepAxis = Chartist.Axis.extend({\n    constructor: StepAxis,\n    projectValue: projectValue\n  });\n\n}(this || global, Chartist));\n;/**\n * The Chartist line chart can be used to draw Line or Scatter charts. If used in the browser you can access the global `Chartist` namespace where you find the `Line` function as a main entry point.\n *\n * For examples on how to use the line chart please check the examples of the `Chartist.Line` method.\n *\n * @module Chartist.Line\n */\n/* global Chartist */\n(function(globalRoot, Chartist){\n  'use strict';\n\n  var window = globalRoot.window;\n  var document = globalRoot.document;\n\n  /**\n   * Default options in line charts. Expand the code view to see a detailed list of options with comments.\n   *\n   * @memberof Chartist.Line\n   */\n  var defaultOptions = {\n    // Options for X-Axis\n    axisX: {\n      // The offset of the labels to the chart area\n      offset: 30,\n      // Position where labels are placed. Can be set to `start` or `end` where `start` is equivalent to left or top on vertical axis and `end` is equivalent to right or bottom on horizontal axis.\n      position: 'end',\n      // Allows you to correct label positioning on this axis by positive or negative x and y offset.\n      labelOffset: {\n        x: 0,\n        y: 0\n      },\n      // If labels should be shown or not\n      showLabel: true,\n      // If the axis grid should be drawn or not\n      showGrid: true,\n      // Interpolation function that allows you to intercept the value from the axis label\n      labelInterpolationFnc: Chartist.noop,\n      // Set the axis type to be used to project values on this axis. If not defined, Chartist.StepAxis will be used for the X-Axis, where the ticks option will be set to the labels in the data and the stretch option will be set to the global fullWidth option. This type can be changed to any axis constructor available (e.g. Chartist.FixedScaleAxis), where all axis options should be present here.\n      type: undefined\n    },\n    // Options for Y-Axis\n    axisY: {\n      // The offset of the labels to the chart area\n      offset: 40,\n      // Position where labels are placed. Can be set to `start` or `end` where `start` is equivalent to left or top on vertical axis and `end` is equivalent to right or bottom on horizontal axis.\n      position: 'start',\n      // Allows you to correct label positioning on this axis by positive or negative x and y offset.\n      labelOffset: {\n        x: 0,\n        y: 0\n      },\n      // If labels should be shown or not\n      showLabel: true,\n      // If the axis grid should be drawn or not\n      showGrid: true,\n      // Interpolation function that allows you to intercept the value from the axis label\n      labelInterpolationFnc: Chartist.noop,\n      // Set the axis type to be used to project values on this axis. If not defined, Chartist.AutoScaleAxis will be used for the Y-Axis, where the high and low options will be set to the global high and low options. This type can be changed to any axis constructor available (e.g. Chartist.FixedScaleAxis), where all axis options should be present here.\n      type: undefined,\n      // This value specifies the minimum height in pixel of the scale steps\n      scaleMinSpace: 20,\n      // Use only integer values (whole numbers) for the scale steps\n      onlyInteger: false\n    },\n    // Specify a fixed width for the chart as a string (i.e. '100px' or '50%')\n    width: undefined,\n    // Specify a fixed height for the chart as a string (i.e. '100px' or '50%')\n    height: undefined,\n    // If the line should be drawn or not\n    showLine: true,\n    // If dots should be drawn or not\n    showPoint: true,\n    // If the line chart should draw an area\n    showArea: false,\n    // The base for the area chart that will be used to close the area shape (is normally 0)\n    areaBase: 0,\n    // Specify if the lines should be smoothed. This value can be true or false where true will result in smoothing using the default smoothing interpolation function Chartist.Interpolation.cardinal and false results in Chartist.Interpolation.none. You can also choose other smoothing / interpolation functions available in the Chartist.Interpolation module, or write your own interpolation function. Check the examples for a brief description.\n    lineSmooth: true,\n    // If the line chart should add a background fill to the .ct-grids group.\n    showGridBackground: false,\n    // Overriding the natural low of the chart allows you to zoom in or limit the charts lowest displayed value\n    low: undefined,\n    // Overriding the natural high of the chart allows you to zoom in or limit the charts highest displayed value\n    high: undefined,\n    // Padding of the chart drawing area to the container element and labels as a number or padding object {top: 5, right: 5, bottom: 5, left: 5}\n    chartPadding: {\n      top: 15,\n      right: 15,\n      bottom: 5,\n      left: 10\n    },\n    // When set to true, the last grid line on the x-axis is not drawn and the chart elements will expand to the full available width of the chart. For the last label to be drawn correctly you might need to add chart padding or offset the last label with a draw event handler.\n    fullWidth: false,\n    // If true the whole data is reversed including labels, the series order as well as the whole series data arrays.\n    reverseData: false,\n    // Override the class names that get used to generate the SVG structure of the chart\n    classNames: {\n      chart: 'ct-chart-line',\n      label: 'ct-label',\n      labelGroup: 'ct-labels',\n      series: 'ct-series',\n      line: 'ct-line',\n      point: 'ct-point',\n      area: 'ct-area',\n      grid: 'ct-grid',\n      gridGroup: 'ct-grids',\n      gridBackground: 'ct-grid-background',\n      vertical: 'ct-vertical',\n      horizontal: 'ct-horizontal',\n      start: 'ct-start',\n      end: 'ct-end'\n    }\n  };\n\n  /**\n   * Creates a new chart\n   *\n   */\n  function createChart(options) {\n    var data = Chartist.normalizeData(this.data, options.reverseData, true);\n\n    // Create new svg object\n    this.svg = Chartist.createSvg(this.container, options.width, options.height, options.classNames.chart);\n    // Create groups for labels, grid and series\n    var gridGroup = this.svg.elem('g').addClass(options.classNames.gridGroup);\n    var seriesGroup = this.svg.elem('g');\n    var labelGroup = this.svg.elem('g').addClass(options.classNames.labelGroup);\n\n    var chartRect = Chartist.createChartRect(this.svg, options, defaultOptions.padding);\n    var axisX, axisY;\n\n    if(options.axisX.type === undefined) {\n      axisX = new Chartist.StepAxis(Chartist.Axis.units.x, data.normalized.series, chartRect, Chartist.extend({}, options.axisX, {\n        ticks: data.normalized.labels,\n        stretch: options.fullWidth\n      }));\n    } else {\n      axisX = options.axisX.type.call(Chartist, Chartist.Axis.units.x, data.normalized.series, chartRect, options.axisX);\n    }\n\n    if(options.axisY.type === undefined) {\n      axisY = new Chartist.AutoScaleAxis(Chartist.Axis.units.y, data.normalized.series, chartRect, Chartist.extend({}, options.axisY, {\n        high: Chartist.isNumeric(options.high) ? options.high : options.axisY.high,\n        low: Chartist.isNumeric(options.low) ? options.low : options.axisY.low\n      }));\n    } else {\n      axisY = options.axisY.type.call(Chartist, Chartist.Axis.units.y, data.normalized.series, chartRect, options.axisY);\n    }\n\n    axisX.createGridAndLabels(gridGroup, labelGroup, this.supportsForeignObject, options, this.eventEmitter);\n    axisY.createGridAndLabels(gridGroup, labelGroup, this.supportsForeignObject, options, this.eventEmitter);\n\n    if (options.showGridBackground) {\n      Chartist.createGridBackground(gridGroup, chartRect, options.classNames.gridBackground, this.eventEmitter);\n    }\n\n    // Draw the series\n    data.raw.series.forEach(function(series, seriesIndex) {\n      var seriesElement = seriesGroup.elem('g');\n\n      // Write attributes to series group element. If series name or meta is undefined the attributes will not be written\n      seriesElement.attr({\n        'ct:series-name': series.name,\n        'ct:meta': Chartist.serialize(series.meta)\n      });\n\n      // Use series class from series data or if not set generate one\n      seriesElement.addClass([\n        options.classNames.series,\n        (series.className || options.classNames.series + '-' + Chartist.alphaNumerate(seriesIndex))\n      ].join(' '));\n\n      var pathCoordinates = [],\n        pathData = [];\n\n      data.normalized.series[seriesIndex].forEach(function(value, valueIndex) {\n        var p = {\n          x: chartRect.x1 + axisX.projectValue(value, valueIndex, data.normalized.series[seriesIndex]),\n          y: chartRect.y1 - axisY.projectValue(value, valueIndex, data.normalized.series[seriesIndex])\n        };\n        pathCoordinates.push(p.x, p.y);\n        pathData.push({\n          value: value,\n          valueIndex: valueIndex,\n          meta: Chartist.getMetaData(series, valueIndex)\n        });\n      }.bind(this));\n\n      var seriesOptions = {\n        lineSmooth: Chartist.getSeriesOption(series, options, 'lineSmooth'),\n        showPoint: Chartist.getSeriesOption(series, options, 'showPoint'),\n        showLine: Chartist.getSeriesOption(series, options, 'showLine'),\n        showArea: Chartist.getSeriesOption(series, options, 'showArea'),\n        areaBase: Chartist.getSeriesOption(series, options, 'areaBase')\n      };\n\n      var smoothing = typeof seriesOptions.lineSmooth === 'function' ?\n        seriesOptions.lineSmooth : (seriesOptions.lineSmooth ? Chartist.Interpolation.monotoneCubic() : Chartist.Interpolation.none());\n      // Interpolating path where pathData will be used to annotate each path element so we can trace back the original\n      // index, value and meta data\n      var path = smoothing(pathCoordinates, pathData);\n\n      // If we should show points we need to create them now to avoid secondary loop\n      // Points are drawn from the pathElements returned by the interpolation function\n      // Small offset for Firefox to render squares correctly\n      if (seriesOptions.showPoint) {\n\n        path.pathElements.forEach(function(pathElement) {\n          var point = seriesElement.elem('line', {\n            x1: pathElement.x,\n            y1: pathElement.y,\n            x2: pathElement.x + 0.01,\n            y2: pathElement.y\n          }, options.classNames.point).attr({\n            'ct:value': [pathElement.data.value.x, pathElement.data.value.y].filter(Chartist.isNumeric).join(','),\n            'ct:meta': Chartist.serialize(pathElement.data.meta)\n          });\n\n          this.eventEmitter.emit('draw', {\n            type: 'point',\n            value: pathElement.data.value,\n            index: pathElement.data.valueIndex,\n            meta: pathElement.data.meta,\n            series: series,\n            seriesIndex: seriesIndex,\n            axisX: axisX,\n            axisY: axisY,\n            group: seriesElement,\n            element: point,\n            x: pathElement.x,\n            y: pathElement.y\n          });\n        }.bind(this));\n      }\n\n      if(seriesOptions.showLine) {\n        var line = seriesElement.elem('path', {\n          d: path.stringify()\n        }, options.classNames.line, true);\n\n        this.eventEmitter.emit('draw', {\n          type: 'line',\n          values: data.normalized.series[seriesIndex],\n          path: path.clone(),\n          chartRect: chartRect,\n          index: seriesIndex,\n          series: series,\n          seriesIndex: seriesIndex,\n          seriesMeta: series.meta,\n          axisX: axisX,\n          axisY: axisY,\n          group: seriesElement,\n          element: line\n        });\n      }\n\n      // Area currently only works with axes that support a range!\n      if(seriesOptions.showArea && axisY.range) {\n        // If areaBase is outside the chart area (< min or > max) we need to set it respectively so that\n        // the area is not drawn outside the chart area.\n        var areaBase = Math.max(Math.min(seriesOptions.areaBase, axisY.range.max), axisY.range.min);\n\n        // We project the areaBase value into screen coordinates\n        var areaBaseProjected = chartRect.y1 - axisY.projectValue(areaBase);\n\n        // In order to form the area we'll first split the path by move commands so we can chunk it up into segments\n        path.splitByCommand('M').filter(function onlySolidSegments(pathSegment) {\n          // We filter only \"solid\" segments that contain more than one point. Otherwise there's no need for an area\n          return pathSegment.pathElements.length > 1;\n        }).map(function convertToArea(solidPathSegments) {\n          // Receiving the filtered solid path segments we can now convert those segments into fill areas\n          var firstElement = solidPathSegments.pathElements[0];\n          var lastElement = solidPathSegments.pathElements[solidPathSegments.pathElements.length - 1];\n\n          // Cloning the solid path segment with closing option and removing the first move command from the clone\n          // We then insert a new move that should start at the area base and draw a straight line up or down\n          // at the end of the path we add an additional straight line to the projected area base value\n          // As the closing option is set our path will be automatically closed\n          return solidPathSegments.clone(true)\n            .position(0)\n            .remove(1)\n            .move(firstElement.x, areaBaseProjected)\n            .line(firstElement.x, firstElement.y)\n            .position(solidPathSegments.pathElements.length + 1)\n            .line(lastElement.x, areaBaseProjected);\n\n        }).forEach(function createArea(areaPath) {\n          // For each of our newly created area paths, we'll now create path elements by stringifying our path objects\n          // and adding the created DOM elements to the correct series group\n          var area = seriesElement.elem('path', {\n            d: areaPath.stringify()\n          }, options.classNames.area, true);\n\n          // Emit an event for each area that was drawn\n          this.eventEmitter.emit('draw', {\n            type: 'area',\n            values: data.normalized.series[seriesIndex],\n            path: areaPath.clone(),\n            series: series,\n            seriesIndex: seriesIndex,\n            axisX: axisX,\n            axisY: axisY,\n            chartRect: chartRect,\n            index: seriesIndex,\n            group: seriesElement,\n            element: area\n          });\n        }.bind(this));\n      }\n    }.bind(this));\n\n    this.eventEmitter.emit('created', {\n      bounds: axisY.bounds,\n      chartRect: chartRect,\n      axisX: axisX,\n      axisY: axisY,\n      svg: this.svg,\n      options: options\n    });\n  }\n\n  /**\n   * This method creates a new line chart.\n   *\n   * @memberof Chartist.Line\n   * @param {String|Node} query A selector query string or directly a DOM element\n   * @param {Object} data The data object that needs to consist of a labels and a series array\n   * @param {Object} [options] The options object with options that override the default options. Check the examples for a detailed list.\n   * @param {Array} [responsiveOptions] Specify an array of responsive option arrays which are a media query and options object pair => [[mediaQueryString, optionsObject],[more...]]\n   * @return {Object} An object which exposes the API for the created chart\n   *\n   * @example\n   * // Create a simple line chart\n   * var data = {\n   *   // A labels array that can contain any sort of values\n   *   labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'],\n   *   // Our series array that contains series objects or in this case series data arrays\n   *   series: [\n   *     [5, 2, 4, 2, 0]\n   *   ]\n   * };\n   *\n   * // As options we currently only set a static size of 300x200 px\n   * var options = {\n   *   width: '300px',\n   *   height: '200px'\n   * };\n   *\n   * // In the global name space Chartist we call the Line function to initialize a line chart. As a first parameter we pass in a selector where we would like to get our chart created. Second parameter is the actual data object and as a third parameter we pass in our options\n   * new Chartist.Line('.ct-chart', data, options);\n   *\n   * @example\n   * // Use specific interpolation function with configuration from the Chartist.Interpolation module\n   *\n   * var chart = new Chartist.Line('.ct-chart', {\n   *   labels: [1, 2, 3, 4, 5],\n   *   series: [\n   *     [1, 1, 8, 1, 7]\n   *   ]\n   * }, {\n   *   lineSmooth: Chartist.Interpolation.cardinal({\n   *     tension: 0.2\n   *   })\n   * });\n   *\n   * @example\n   * // Create a line chart with responsive options\n   *\n   * var data = {\n   *   // A labels array that can contain any sort of values\n   *   labels: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'],\n   *   // Our series array that contains series objects or in this case series data arrays\n   *   series: [\n   *     [5, 2, 4, 2, 0]\n   *   ]\n   * };\n   *\n   * // In addition to the regular options we specify responsive option overrides that will override the default configutation based on the matching media queries.\n   * var responsiveOptions = [\n   *   ['screen and (min-width: 641px) and (max-width: 1024px)', {\n   *     showPoint: false,\n   *     axisX: {\n   *       labelInterpolationFnc: function(value) {\n   *         // Will return Mon, Tue, Wed etc. on medium screens\n   *         return value.slice(0, 3);\n   *       }\n   *     }\n   *   }],\n   *   ['screen and (max-width: 640px)', {\n   *     showLine: false,\n   *     axisX: {\n   *       labelInterpolationFnc: function(value) {\n   *         // Will return M, T, W etc. on small screens\n   *         return value[0];\n   *       }\n   *     }\n   *   }]\n   * ];\n   *\n   * new Chartist.Line('.ct-chart', data, null, responsiveOptions);\n   *\n   */\n  function Line(query, data, options, responsiveOptions) {\n    Chartist.Line.super.constructor.call(this,\n      query,\n      data,\n      defaultOptions,\n      Chartist.extend({}, defaultOptions, options),\n      responsiveOptions);\n  }\n\n  // Creating line chart type in Chartist namespace\n  Chartist.Line = Chartist.Base.extend({\n    constructor: Line,\n    createChart: createChart\n  });\n\n}(this || global, Chartist));\n;/**\n * The bar chart module of Chartist that can be used to draw unipolar or bipolar bar and grouped bar charts.\n *\n * @module Chartist.Bar\n */\n/* global Chartist */\n(function(globalRoot, Chartist){\n  'use strict';\n\n  var window = globalRoot.window;\n  var document = globalRoot.document;\n\n  /**\n   * Default options in bar charts. Expand the code view to see a detailed list of options with comments.\n   *\n   * @memberof Chartist.Bar\n   */\n  var defaultOptions = {\n    // Options for X-Axis\n    axisX: {\n      // The offset of the chart drawing area to the border of the container\n      offset: 30,\n      // Position where labels are placed. Can be set to `start` or `end` where `start` is equivalent to left or top on vertical axis and `end` is equivalent to right or bottom on horizontal axis.\n      position: 'end',\n      // Allows you to correct label positioning on this axis by positive or negative x and y offset.\n      labelOffset: {\n        x: 0,\n        y: 0\n      },\n      // If labels should be shown or not\n      showLabel: true,\n      // If the axis grid should be drawn or not\n      showGrid: true,\n      // Interpolation function that allows you to intercept the value from the axis label\n      labelInterpolationFnc: Chartist.noop,\n      // This value specifies the minimum width in pixel of the scale steps\n      scaleMinSpace: 30,\n      // Use only integer values (whole numbers) for the scale steps\n      onlyInteger: false\n    },\n    // Options for Y-Axis\n    axisY: {\n      // The offset of the chart drawing area to the border of the container\n      offset: 40,\n      // Position where labels are placed. Can be set to `start` or `end` where `start` is equivalent to left or top on vertical axis and `end` is equivalent to right or bottom on horizontal axis.\n      position: 'start',\n      // Allows you to correct label positioning on this axis by positive or negative x and y offset.\n      labelOffset: {\n        x: 0,\n        y: 0\n      },\n      // If labels should be shown or not\n      showLabel: true,\n      // If the axis grid should be drawn or not\n      showGrid: true,\n      // Interpolation function that allows you to intercept the value from the axis label\n      labelInterpolationFnc: Chartist.noop,\n      // This value specifies the minimum height in pixel of the scale steps\n      scaleMinSpace: 20,\n      // Use only integer values (whole numbers) for the scale steps\n      onlyInteger: false\n    },\n    // Specify a fixed width for the chart as a string (i.e. '100px' or '50%')\n    width: undefined,\n    // Specify a fixed height for the chart as a string (i.e. '100px' or '50%')\n    height: undefined,\n    // Overriding the natural high of the chart allows you to zoom in or limit the charts highest displayed value\n    high: undefined,\n    // Overriding the natural low of the chart allows you to zoom in or limit the charts lowest displayed value\n    low: undefined,\n    // Unless low/high are explicitly set, bar chart will be centered at zero by default. Set referenceValue to null to auto scale.\n    referenceValue: 0,\n    // Padding of the chart drawing area to the container element and labels as a number or padding object {top: 5, right: 5, bottom: 5, left: 5}\n    chartPadding: {\n      top: 15,\n      right: 15,\n      bottom: 5,\n      left: 10\n    },\n    // Specify the distance in pixel of bars in a group\n    seriesBarDistance: 15,\n    // If set to true this property will cause the series bars to be stacked. Check the `stackMode` option for further stacking options.\n    stackBars: false,\n    // If set to 'overlap' this property will force the stacked bars to draw from the zero line.\n    // If set to 'accumulate' this property will form a total for each series point. This will also influence the y-axis and the overall bounds of the chart. In stacked mode the seriesBarDistance property will have no effect.\n    stackMode: 'accumulate',\n    // Inverts the axes of the bar chart in order to draw a horizontal bar chart. Be aware that you also need to invert your axis settings as the Y Axis will now display the labels and the X Axis the values.\n    horizontalBars: false,\n    // If set to true then each bar will represent a series and the data array is expected to be a one dimensional array of data values rather than a series array of series. This is useful if the bar chart should represent a profile rather than some data over time.\n    distributeSeries: false,\n    // If true the whole data is reversed including labels, the series order as well as the whole series data arrays.\n    reverseData: false,\n    // If the bar chart should add a background fill to the .ct-grids group.\n    showGridBackground: false,\n    // Override the class names that get used to generate the SVG structure of the chart\n    classNames: {\n      chart: 'ct-chart-bar',\n      horizontalBars: 'ct-horizontal-bars',\n      label: 'ct-label',\n      labelGroup: 'ct-labels',\n      series: 'ct-series',\n      bar: 'ct-bar',\n      grid: 'ct-grid',\n      gridGroup: 'ct-grids',\n      gridBackground: 'ct-grid-background',\n      vertical: 'ct-vertical',\n      horizontal: 'ct-horizontal',\n      start: 'ct-start',\n      end: 'ct-end'\n    }\n  };\n\n  /**\n   * Creates a new chart\n   *\n   */\n  function createChart(options) {\n    var data;\n    var highLow;\n\n    if(options.distributeSeries) {\n      data = Chartist.normalizeData(this.data, options.reverseData, options.horizontalBars ? 'x' : 'y');\n      data.normalized.series = data.normalized.series.map(function(value) {\n        return [value];\n      });\n    } else {\n      data = Chartist.normalizeData(this.data, options.reverseData, options.horizontalBars ? 'x' : 'y');\n    }\n\n    // Create new svg element\n    this.svg = Chartist.createSvg(\n      this.container,\n      options.width,\n      options.height,\n      options.classNames.chart + (options.horizontalBars ? ' ' + options.classNames.horizontalBars : '')\n    );\n\n    // Drawing groups in correct order\n    var gridGroup = this.svg.elem('g').addClass(options.classNames.gridGroup);\n    var seriesGroup = this.svg.elem('g');\n    var labelGroup = this.svg.elem('g').addClass(options.classNames.labelGroup);\n\n    if(options.stackBars && data.normalized.series.length !== 0) {\n\n      // If stacked bars we need to calculate the high low from stacked values from each series\n      var serialSums = Chartist.serialMap(data.normalized.series, function serialSums() {\n        return Array.prototype.slice.call(arguments).map(function(value) {\n          return value;\n        }).reduce(function(prev, curr) {\n          return {\n            x: prev.x + (curr && curr.x) || 0,\n            y: prev.y + (curr && curr.y) || 0\n          };\n        }, {x: 0, y: 0});\n      });\n\n      highLow = Chartist.getHighLow([serialSums], options, options.horizontalBars ? 'x' : 'y');\n\n    } else {\n\n      highLow = Chartist.getHighLow(data.normalized.series, options, options.horizontalBars ? 'x' : 'y');\n    }\n\n    // Overrides of high / low from settings\n    highLow.high = +options.high || (options.high === 0 ? 0 : highLow.high);\n    highLow.low = +options.low || (options.low === 0 ? 0 : highLow.low);\n\n    var chartRect = Chartist.createChartRect(this.svg, options, defaultOptions.padding);\n\n    var valueAxis,\n      labelAxisTicks,\n      labelAxis,\n      axisX,\n      axisY;\n\n    // We need to set step count based on some options combinations\n    if(options.distributeSeries && options.stackBars) {\n      // If distributed series are enabled and bars need to be stacked, we'll only have one bar and therefore should\n      // use only the first label for the step axis\n      labelAxisTicks = data.normalized.labels.slice(0, 1);\n    } else {\n      // If distributed series are enabled but stacked bars aren't, we should use the series labels\n      // If we are drawing a regular bar chart with two dimensional series data, we just use the labels array\n      // as the bars are normalized\n      labelAxisTicks = data.normalized.labels;\n    }\n\n    // Set labelAxis and valueAxis based on the horizontalBars setting. This setting will flip the axes if necessary.\n    if(options.horizontalBars) {\n      if(options.axisX.type === undefined) {\n        valueAxis = axisX = new Chartist.AutoScaleAxis(Chartist.Axis.units.x, data.normalized.series, chartRect, Chartist.extend({}, options.axisX, {\n          highLow: highLow,\n          referenceValue: 0\n        }));\n      } else {\n        valueAxis = axisX = options.axisX.type.call(Chartist, Chartist.Axis.units.x, data.normalized.series, chartRect, Chartist.extend({}, options.axisX, {\n          highLow: highLow,\n          referenceValue: 0\n        }));\n      }\n\n      if(options.axisY.type === undefined) {\n        labelAxis = axisY = new Chartist.StepAxis(Chartist.Axis.units.y, data.normalized.series, chartRect, {\n          ticks: labelAxisTicks\n        });\n      } else {\n        labelAxis = axisY = options.axisY.type.call(Chartist, Chartist.Axis.units.y, data.normalized.series, chartRect, options.axisY);\n      }\n    } else {\n      if(options.axisX.type === undefined) {\n        labelAxis = axisX = new Chartist.StepAxis(Chartist.Axis.units.x, data.normalized.series, chartRect, {\n          ticks: labelAxisTicks\n        });\n      } else {\n        labelAxis = axisX = options.axisX.type.call(Chartist, Chartist.Axis.units.x, data.normalized.series, chartRect, options.axisX);\n      }\n\n      if(options.axisY.type === undefined) {\n        valueAxis = axisY = new Chartist.AutoScaleAxis(Chartist.Axis.units.y, data.normalized.series, chartRect, Chartist.extend({}, options.axisY, {\n          highLow: highLow,\n          referenceValue: 0\n        }));\n      } else {\n        valueAxis = axisY = options.axisY.type.call(Chartist, Chartist.Axis.units.y, data.normalized.series, chartRect, Chartist.extend({}, options.axisY, {\n          highLow: highLow,\n          referenceValue: 0\n        }));\n      }\n    }\n\n    // Projected 0 point\n    var zeroPoint = options.horizontalBars ? (chartRect.x1 + valueAxis.projectValue(0)) : (chartRect.y1 - valueAxis.projectValue(0));\n    // Used to track the screen coordinates of stacked bars\n    var stackedBarValues = [];\n\n    labelAxis.createGridAndLabels(gridGroup, labelGroup, this.supportsForeignObject, options, this.eventEmitter);\n    valueAxis.createGridAndLabels(gridGroup, labelGroup, this.supportsForeignObject, options, this.eventEmitter);\n\n    if (options.showGridBackground) {\n      Chartist.createGridBackground(gridGroup, chartRect, options.classNames.gridBackground, this.eventEmitter);\n    }\n\n    // Draw the series\n    data.raw.series.forEach(function(series, seriesIndex) {\n      // Calculating bi-polar value of index for seriesOffset. For i = 0..4 biPol will be -1.5, -0.5, 0.5, 1.5 etc.\n      var biPol = seriesIndex - (data.raw.series.length - 1) / 2;\n      // Half of the period width between vertical grid lines used to position bars\n      var periodHalfLength;\n      // Current series SVG element\n      var seriesElement;\n\n      // We need to set periodHalfLength based on some options combinations\n      if(options.distributeSeries && !options.stackBars) {\n        // If distributed series are enabled but stacked bars aren't, we need to use the length of the normaizedData array\n        // which is the series count and divide by 2\n        periodHalfLength = labelAxis.axisLength / data.normalized.series.length / 2;\n      } else if(options.distributeSeries && options.stackBars) {\n        // If distributed series and stacked bars are enabled we'll only get one bar so we should just divide the axis\n        // length by 2\n        periodHalfLength = labelAxis.axisLength / 2;\n      } else {\n        // On regular bar charts we should just use the series length\n        periodHalfLength = labelAxis.axisLength / data.normalized.series[seriesIndex].length / 2;\n      }\n\n      // Adding the series group to the series element\n      seriesElement = seriesGroup.elem('g');\n\n      // Write attributes to series group element. If series name or meta is undefined the attributes will not be written\n      seriesElement.attr({\n        'ct:series-name': series.name,\n        'ct:meta': Chartist.serialize(series.meta)\n      });\n\n      // Use series class from series data or if not set generate one\n      seriesElement.addClass([\n        options.classNames.series,\n        (series.className || options.classNames.series + '-' + Chartist.alphaNumerate(seriesIndex))\n      ].join(' '));\n\n      data.normalized.series[seriesIndex].forEach(function(value, valueIndex) {\n        var projected,\n          bar,\n          previousStack,\n          labelAxisValueIndex;\n\n        // We need to set labelAxisValueIndex based on some options combinations\n        if(options.distributeSeries && !options.stackBars) {\n          // If distributed series are enabled but stacked bars aren't, we can use the seriesIndex for later projection\n          // on the step axis for label positioning\n          labelAxisValueIndex = seriesIndex;\n        } else if(options.distributeSeries && options.stackBars) {\n          // If distributed series and stacked bars are enabled, we will only get one bar and therefore always use\n          // 0 for projection on the label step axis\n          labelAxisValueIndex = 0;\n        } else {\n          // On regular bar charts we just use the value index to project on the label step axis\n          labelAxisValueIndex = valueIndex;\n        }\n\n        // We need to transform coordinates differently based on the chart layout\n        if(options.horizontalBars) {\n          projected = {\n            x: chartRect.x1 + valueAxis.projectValue(value && value.x ? value.x : 0, valueIndex, data.normalized.series[seriesIndex]),\n            y: chartRect.y1 - labelAxis.projectValue(value && value.y ? value.y : 0, labelAxisValueIndex, data.normalized.series[seriesIndex])\n          };\n        } else {\n          projected = {\n            x: chartRect.x1 + labelAxis.projectValue(value && value.x ? value.x : 0, labelAxisValueIndex, data.normalized.series[seriesIndex]),\n            y: chartRect.y1 - valueAxis.projectValue(value && value.y ? value.y : 0, valueIndex, data.normalized.series[seriesIndex])\n          }\n        }\n\n        // If the label axis is a step based axis we will offset the bar into the middle of between two steps using\n        // the periodHalfLength value. Also we do arrange the different series so that they align up to each other using\n        // the seriesBarDistance. If we don't have a step axis, the bar positions can be chosen freely so we should not\n        // add any automated positioning.\n        if(labelAxis instanceof Chartist.StepAxis) {\n          // Offset to center bar between grid lines, but only if the step axis is not stretched\n          if(!labelAxis.options.stretch) {\n            projected[labelAxis.units.pos] += periodHalfLength * (options.horizontalBars ? -1 : 1);\n          }\n          // Using bi-polar offset for multiple series if no stacked bars or series distribution is used\n          projected[labelAxis.units.pos] += (options.stackBars || options.distributeSeries) ? 0 : biPol * options.seriesBarDistance * (options.horizontalBars ? -1 : 1);\n        }\n\n        // Enter value in stacked bar values used to remember previous screen value for stacking up bars\n        previousStack = stackedBarValues[valueIndex] || zeroPoint;\n        stackedBarValues[valueIndex] = previousStack - (zeroPoint - projected[labelAxis.counterUnits.pos]);\n\n        // Skip if value is undefined\n        if(value === undefined) {\n          return;\n        }\n\n        var positions = {};\n        positions[labelAxis.units.pos + '1'] = projected[labelAxis.units.pos];\n        positions[labelAxis.units.pos + '2'] = projected[labelAxis.units.pos];\n\n        if(options.stackBars && (options.stackMode === 'accumulate' || !options.stackMode)) {\n          // Stack mode: accumulate (default)\n          // If bars are stacked we use the stackedBarValues reference and otherwise base all bars off the zero line\n          // We want backwards compatibility, so the expected fallback without the 'stackMode' option\n          // to be the original behaviour (accumulate)\n          positions[labelAxis.counterUnits.pos + '1'] = previousStack;\n          positions[labelAxis.counterUnits.pos + '2'] = stackedBarValues[valueIndex];\n        } else {\n          // Draw from the zero line normally\n          // This is also the same code for Stack mode: overlap\n          positions[labelAxis.counterUnits.pos + '1'] = zeroPoint;\n          positions[labelAxis.counterUnits.pos + '2'] = projected[labelAxis.counterUnits.pos];\n        }\n\n        // Limit x and y so that they are within the chart rect\n        positions.x1 = Math.min(Math.max(positions.x1, chartRect.x1), chartRect.x2);\n        positions.x2 = Math.min(Math.max(positions.x2, chartRect.x1), chartRect.x2);\n        positions.y1 = Math.min(Math.max(positions.y1, chartRect.y2), chartRect.y1);\n        positions.y2 = Math.min(Math.max(positions.y2, chartRect.y2), chartRect.y1);\n\n        var metaData = Chartist.getMetaData(series, valueIndex);\n\n        // Create bar element\n        bar = seriesElement.elem('line', positions, options.classNames.bar).attr({\n          'ct:value': [value.x, value.y].filter(Chartist.isNumeric).join(','),\n          'ct:meta': Chartist.serialize(metaData)\n        });\n\n        this.eventEmitter.emit('draw', Chartist.extend({\n          type: 'bar',\n          value: value,\n          index: valueIndex,\n          meta: metaData,\n          series: series,\n          seriesIndex: seriesIndex,\n          axisX: axisX,\n          axisY: axisY,\n          chartRect: chartRect,\n          group: seriesElement,\n          element: bar\n        }, positions));\n      }.bind(this));\n    }.bind(this));\n\n    this.eventEmitter.emit('created', {\n      bounds: valueAxis.bounds,\n      chartRect: chartRect,\n      axisX: axisX,\n      axisY: axisY,\n      svg: this.svg,\n      options: options\n    });\n  }\n\n  /**\n   * This method creates a new bar chart and returns API object that you can use for later changes.\n   *\n   * @memberof Chartist.Bar\n   * @param {String|Node} query A selector query string or directly a DOM element\n   * @param {Object} data The data object that needs to consist of a labels and a series array\n   * @param {Object} [options] The options object with options that override the default options. Check the examples for a detailed list.\n   * @param {Array} [responsiveOptions] Specify an array of responsive option arrays which are a media query and options object pair => [[mediaQueryString, optionsObject],[more...]]\n   * @return {Object} An object which exposes the API for the created chart\n   *\n   * @example\n   * // Create a simple bar chart\n   * var data = {\n   *   labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'],\n   *   series: [\n   *     [5, 2, 4, 2, 0]\n   *   ]\n   * };\n   *\n   * // In the global name space Chartist we call the Bar function to initialize a bar chart. As a first parameter we pass in a selector where we would like to get our chart created and as a second parameter we pass our data object.\n   * new Chartist.Bar('.ct-chart', data);\n   *\n   * @example\n   * // This example creates a bipolar grouped bar chart where the boundaries are limitted to -10 and 10\n   * new Chartist.Bar('.ct-chart', {\n   *   labels: [1, 2, 3, 4, 5, 6, 7],\n   *   series: [\n   *     [1, 3, 2, -5, -3, 1, -6],\n   *     [-5, -2, -4, -1, 2, -3, 1]\n   *   ]\n   * }, {\n   *   seriesBarDistance: 12,\n   *   low: -10,\n   *   high: 10\n   * });\n   *\n   */\n  function Bar(query, data, options, responsiveOptions) {\n    Chartist.Bar.super.constructor.call(this,\n      query,\n      data,\n      defaultOptions,\n      Chartist.extend({}, defaultOptions, options),\n      responsiveOptions);\n  }\n\n  // Creating bar chart type in Chartist namespace\n  Chartist.Bar = Chartist.Base.extend({\n    constructor: Bar,\n    createChart: createChart\n  });\n\n}(this || global, Chartist));\n;/**\n * The pie chart module of Chartist that can be used to draw pie, donut or gauge charts\n *\n * @module Chartist.Pie\n */\n/* global Chartist */\n(function(globalRoot, Chartist) {\n  'use strict';\n\n  var window = globalRoot.window;\n  var document = globalRoot.document;\n\n  /**\n   * Default options in line charts. Expand the code view to see a detailed list of options with comments.\n   *\n   * @memberof Chartist.Pie\n   */\n  var defaultOptions = {\n    // Specify a fixed width for the chart as a string (i.e. '100px' or '50%')\n    width: undefined,\n    // Specify a fixed height for the chart as a string (i.e. '100px' or '50%')\n    height: undefined,\n    // Padding of the chart drawing area to the container element and labels as a number or padding object {top: 5, right: 5, bottom: 5, left: 5}\n    chartPadding: 5,\n    // Override the class names that are used to generate the SVG structure of the chart\n    classNames: {\n      chartPie: 'ct-chart-pie',\n      chartDonut: 'ct-chart-donut',\n      series: 'ct-series',\n      slicePie: 'ct-slice-pie',\n      sliceDonut: 'ct-slice-donut',\n      sliceDonutSolid: 'ct-slice-donut-solid',\n      label: 'ct-label'\n    },\n    // The start angle of the pie chart in degrees where 0 points north. A higher value offsets the start angle clockwise.\n    startAngle: 0,\n    // An optional total you can specify. By specifying a total value, the sum of the values in the series must be this total in order to draw a full pie. You can use this parameter to draw only parts of a pie or gauge charts.\n    total: undefined,\n    // If specified the donut CSS classes will be used and strokes will be drawn instead of pie slices.\n    donut: false,\n    // If specified the donut segments will be drawn as shapes instead of strokes.\n    donutSolid: false,\n    // Specify the donut stroke width, currently done in javascript for convenience. May move to CSS styles in the future.\n    // This option can be set as number or string to specify a relative width (i.e. 100 or '30%').\n    donutWidth: 60,\n    // If a label should be shown or not\n    showLabel: true,\n    // Label position offset from the standard position which is half distance of the radius. This value can be either positive or negative. Positive values will position the label away from the center.\n    labelOffset: 0,\n    // This option can be set to 'inside', 'outside' or 'center'. Positioned with 'inside' the labels will be placed on half the distance of the radius to the border of the Pie by respecting the 'labelOffset'. The 'outside' option will place the labels at the border of the pie and 'center' will place the labels in the absolute center point of the chart. The 'center' option only makes sense in conjunction with the 'labelOffset' option.\n    labelPosition: 'inside',\n    // An interpolation function for the label value\n    labelInterpolationFnc: Chartist.noop,\n    // Label direction can be 'neutral', 'explode' or 'implode'. The labels anchor will be positioned based on those settings as well as the fact if the labels are on the right or left side of the center of the chart. Usually explode is useful when labels are positioned far away from the center.\n    labelDirection: 'neutral',\n    // If true the whole data is reversed including labels, the series order as well as the whole series data arrays.\n    reverseData: false,\n    // If true empty values will be ignored to avoid drawing unncessary slices and labels\n    ignoreEmptyValues: false\n  };\n\n  /**\n   * Determines SVG anchor position based on direction and center parameter\n   *\n   * @param center\n   * @param label\n   * @param direction\n   * @return {string}\n   */\n  function determineAnchorPosition(center, label, direction) {\n    var toTheRight = label.x > center.x;\n\n    if(toTheRight && direction === 'explode' ||\n      !toTheRight && direction === 'implode') {\n      return 'start';\n    } else if(toTheRight && direction === 'implode' ||\n      !toTheRight && direction === 'explode') {\n      return 'end';\n    } else {\n      return 'middle';\n    }\n  }\n\n  /**\n   * Creates the pie chart\n   *\n   * @param options\n   */\n  function createChart(options) {\n    var data = Chartist.normalizeData(this.data);\n    var seriesGroups = [],\n      labelsGroup,\n      chartRect,\n      radius,\n      labelRadius,\n      totalDataSum,\n      startAngle = options.startAngle;\n\n    // Create SVG.js draw\n    this.svg = Chartist.createSvg(this.container, options.width, options.height,options.donut ? options.classNames.chartDonut : options.classNames.chartPie);\n    // Calculate charting rect\n    chartRect = Chartist.createChartRect(this.svg, options, defaultOptions.padding);\n    // Get biggest circle radius possible within chartRect\n    radius = Math.min(chartRect.width() / 2, chartRect.height() / 2);\n    // Calculate total of all series to get reference value or use total reference from optional options\n    totalDataSum = options.total || data.normalized.series.reduce(function(previousValue, currentValue) {\n      return previousValue + currentValue;\n    }, 0);\n\n    var donutWidth = Chartist.quantity(options.donutWidth);\n    if (donutWidth.unit === '%') {\n      donutWidth.value *= radius / 100;\n    }\n\n    // If this is a donut chart we need to adjust our radius to enable strokes to be drawn inside\n    // Unfortunately this is not possible with the current SVG Spec\n    // See this proposal for more details: http://lists.w3.org/Archives/Public/www-svg/2003Oct/0000.html\n    radius -= options.donut && !options.donutSolid ? donutWidth.value / 2  : 0;\n\n    // If labelPosition is set to `outside` or a donut chart is drawn then the label position is at the radius,\n    // if regular pie chart it's half of the radius\n    if(options.labelPosition === 'outside' || options.donut && !options.donutSolid) {\n      labelRadius = radius;\n    } else if(options.labelPosition === 'center') {\n      // If labelPosition is center we start with 0 and will later wait for the labelOffset\n      labelRadius = 0;\n    } else if(options.donutSolid) {\n      labelRadius = radius - donutWidth.value / 2;\n    } else {\n      // Default option is 'inside' where we use half the radius so the label will be placed in the center of the pie\n      // slice\n      labelRadius = radius / 2;\n    }\n    // Add the offset to the labelRadius where a negative offset means closed to the center of the chart\n    labelRadius += options.labelOffset;\n\n    // Calculate end angle based on total sum and current data value and offset with padding\n    var center = {\n      x: chartRect.x1 + chartRect.width() / 2,\n      y: chartRect.y2 + chartRect.height() / 2\n    };\n\n    // Check if there is only one non-zero value in the series array.\n    var hasSingleValInSeries = data.raw.series.filter(function(val) {\n      return val.hasOwnProperty('value') ? val.value !== 0 : val !== 0;\n    }).length === 1;\n\n    // Creating the series groups\n    data.raw.series.forEach(function(series, index) {\n      seriesGroups[index] = this.svg.elem('g', null, null);\n    }.bind(this));\n    //if we need to show labels we create the label group now\n    if(options.showLabel) {\n      labelsGroup = this.svg.elem('g', null, null);\n    }\n\n    // Draw the series\n    // initialize series groups\n    data.raw.series.forEach(function(series, index) {\n      // If current value is zero and we are ignoring empty values then skip to next value\n      if (data.normalized.series[index] === 0 && options.ignoreEmptyValues) return;\n\n      // If the series is an object and contains a name or meta data we add a custom attribute\n      seriesGroups[index].attr({\n        'ct:series-name': series.name\n      });\n\n      // Use series class from series data or if not set generate one\n      seriesGroups[index].addClass([\n        options.classNames.series,\n        (series.className || options.classNames.series + '-' + Chartist.alphaNumerate(index))\n      ].join(' '));\n\n      // If the whole dataset is 0 endAngle should be zero. Can't divide by 0.\n      var endAngle = (totalDataSum > 0 ? startAngle + data.normalized.series[index] / totalDataSum * 360 : 0);\n\n      // Use slight offset so there are no transparent hairline issues\n      var overlappigStartAngle = Math.max(0, startAngle - (index === 0 || hasSingleValInSeries ? 0 : 0.2));\n\n      // If we need to draw the arc for all 360 degrees we need to add a hack where we close the circle\n      // with Z and use 359.99 degrees\n      if(endAngle - overlappigStartAngle >= 359.99) {\n        endAngle = overlappigStartAngle + 359.99;\n      }\n\n      var start = Chartist.polarToCartesian(center.x, center.y, radius, overlappigStartAngle),\n        end = Chartist.polarToCartesian(center.x, center.y, radius, endAngle);\n\n      var innerStart,\n        innerEnd,\n        donutSolidRadius;\n\n      // Create a new path element for the pie chart. If this isn't a donut chart we should close the path for a correct stroke\n      var path = new Chartist.Svg.Path(!options.donut || options.donutSolid)\n        .move(end.x, end.y)\n        .arc(radius, radius, 0, endAngle - startAngle > 180, 0, start.x, start.y);\n\n      // If regular pie chart (no donut) we add a line to the center of the circle for completing the pie\n      if(!options.donut) {\n        path.line(center.x, center.y);\n      } else if (options.donutSolid) {\n        donutSolidRadius = radius - donutWidth.value;\n        innerStart = Chartist.polarToCartesian(center.x, center.y, donutSolidRadius, startAngle - (index === 0 || hasSingleValInSeries ? 0 : 0.2));\n        innerEnd = Chartist.polarToCartesian(center.x, center.y, donutSolidRadius, endAngle);\n        path.line(innerStart.x, innerStart.y);\n        path.arc(donutSolidRadius, donutSolidRadius, 0, endAngle - startAngle  > 180, 1, innerEnd.x, innerEnd.y);\n      }\n\n      // Create the SVG path\n      // If this is a donut chart we add the donut class, otherwise just a regular slice\n      var pathClassName = options.classNames.slicePie;\n      if (options.donut) {\n        pathClassName = options.classNames.sliceDonut;\n        if (options.donutSolid) {\n          pathClassName = options.classNames.sliceDonutSolid;\n        }\n      }\n      var pathElement = seriesGroups[index].elem('path', {\n        d: path.stringify()\n      }, pathClassName);\n\n      // Adding the pie series value to the path\n      pathElement.attr({\n        'ct:value': data.normalized.series[index],\n        'ct:meta': Chartist.serialize(series.meta)\n      });\n\n      // If this is a donut, we add the stroke-width as style attribute\n      if(options.donut && !options.donutSolid) {\n        pathElement._node.style.strokeWidth = donutWidth.value + 'px';\n      }\n\n      // Fire off draw event\n      this.eventEmitter.emit('draw', {\n        type: 'slice',\n        value: data.normalized.series[index],\n        totalDataSum: totalDataSum,\n        index: index,\n        meta: series.meta,\n        series: series,\n        group: seriesGroups[index],\n        element: pathElement,\n        path: path.clone(),\n        center: center,\n        radius: radius,\n        startAngle: startAngle,\n        endAngle: endAngle\n      });\n\n      // If we need to show labels we need to add the label for this slice now\n      if(options.showLabel) {\n        var labelPosition;\n        if(data.raw.series.length === 1) {\n          // If we have only 1 series, we can position the label in the center of the pie\n          labelPosition = {\n            x: center.x,\n            y: center.y\n          };\n        } else {\n          // Position at the labelRadius distance from center and between start and end angle\n          labelPosition = Chartist.polarToCartesian(\n            center.x,\n            center.y,\n            labelRadius,\n            startAngle + (endAngle - startAngle) / 2\n          );\n        }\n\n        var rawValue;\n        if(data.normalized.labels && !Chartist.isFalseyButZero(data.normalized.labels[index])) {\n          rawValue = data.normalized.labels[index];\n        } else {\n          rawValue = data.normalized.series[index];\n        }\n\n        var interpolatedValue = options.labelInterpolationFnc(rawValue, index);\n\n        if(interpolatedValue || interpolatedValue === 0) {\n          var labelElement = labelsGroup.elem('text', {\n            dx: labelPosition.x,\n            dy: labelPosition.y,\n            'text-anchor': determineAnchorPosition(center, labelPosition, options.labelDirection)\n          }, options.classNames.label).text('' + interpolatedValue);\n\n          // Fire off draw event\n          this.eventEmitter.emit('draw', {\n            type: 'label',\n            index: index,\n            group: labelsGroup,\n            element: labelElement,\n            text: '' + interpolatedValue,\n            x: labelPosition.x,\n            y: labelPosition.y\n          });\n        }\n      }\n\n      // Set next startAngle to current endAngle.\n      // (except for last slice)\n      startAngle = endAngle;\n    }.bind(this));\n\n    this.eventEmitter.emit('created', {\n      chartRect: chartRect,\n      svg: this.svg,\n      options: options\n    });\n  }\n\n  /**\n   * This method creates a new pie chart and returns an object that can be used to redraw the chart.\n   *\n   * @memberof Chartist.Pie\n   * @param {String|Node} query A selector query string or directly a DOM element\n   * @param {Object} data The data object in the pie chart needs to have a series property with a one dimensional data array. The values will be normalized against each other and don't necessarily need to be in percentage. The series property can also be an array of value objects that contain a value property and a className property to override the CSS class name for the series group.\n   * @param {Object} [options] The options object with options that override the default options. Check the examples for a detailed list.\n   * @param {Array} [responsiveOptions] Specify an array of responsive option arrays which are a media query and options object pair => [[mediaQueryString, optionsObject],[more...]]\n   * @return {Object} An object with a version and an update method to manually redraw the chart\n   *\n   * @example\n   * // Simple pie chart example with four series\n   * new Chartist.Pie('.ct-chart', {\n   *   series: [10, 2, 4, 3]\n   * });\n   *\n   * @example\n   * // Drawing a donut chart\n   * new Chartist.Pie('.ct-chart', {\n   *   series: [10, 2, 4, 3]\n   * }, {\n   *   donut: true\n   * });\n   *\n   * @example\n   * // Using donut, startAngle and total to draw a gauge chart\n   * new Chartist.Pie('.ct-chart', {\n   *   series: [20, 10, 30, 40]\n   * }, {\n   *   donut: true,\n   *   donutWidth: 20,\n   *   startAngle: 270,\n   *   total: 200\n   * });\n   *\n   * @example\n   * // Drawing a pie chart with padding and labels that are outside the pie\n   * new Chartist.Pie('.ct-chart', {\n   *   series: [20, 10, 30, 40]\n   * }, {\n   *   chartPadding: 30,\n   *   labelOffset: 50,\n   *   labelDirection: 'explode'\n   * });\n   *\n   * @example\n   * // Overriding the class names for individual series as well as a name and meta data.\n   * // The name will be written as ct:series-name attribute and the meta data will be serialized and written\n   * // to a ct:meta attribute.\n   * new Chartist.Pie('.ct-chart', {\n   *   series: [{\n   *     value: 20,\n   *     name: 'Series 1',\n   *     className: 'my-custom-class-one',\n   *     meta: 'Meta One'\n   *   }, {\n   *     value: 10,\n   *     name: 'Series 2',\n   *     className: 'my-custom-class-two',\n   *     meta: 'Meta Two'\n   *   }, {\n   *     value: 70,\n   *     name: 'Series 3',\n   *     className: 'my-custom-class-three',\n   *     meta: 'Meta Three'\n   *   }]\n   * });\n   */\n  function Pie(query, data, options, responsiveOptions) {\n    Chartist.Pie.super.constructor.call(this,\n      query,\n      data,\n      defaultOptions,\n      Chartist.extend({}, defaultOptions, options),\n      responsiveOptions);\n  }\n\n  // Creating pie chart type in Chartist namespace\n  Chartist.Pie = Chartist.Base.extend({\n    constructor: Pie,\n    createChart: createChart,\n    determineAnchorPosition: determineAnchorPosition\n  });\n\n}(this || global, Chartist));\n\nreturn Chartist;\n\n}));\n","/**\n * chroma.js - JavaScript library for color conversions\n *\n * Copyright (c) 2011-2019, Gregor Aisch\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name Gregor Aisch may not be used to endorse or promote products\n * derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * -------------------------------------------------------\n *\n * chroma.js includes colors from colorbrewer2.org, which are released under\n * the following license:\n *\n * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,\n * and The Pennsylvania State University.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific\n * language governing permissions and limitations under the License.\n *\n * ------------------------------------------------------\n *\n * Named colors are taken from X11 Color Names.\n * http://www.w3.org/TR/css3-color/#svg-color\n *\n * @preserve\n */\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global.chroma = factory());\n}(this, (function () { 'use strict';\n\n    var limit = function (x, min, max) {\n        if ( min === void 0 ) min=0;\n        if ( max === void 0 ) max=1;\n\n        return x < min ? min : x > max ? max : x;\n    };\n\n    var clip_rgb = function (rgb) {\n        rgb._clipped = false;\n        rgb._unclipped = rgb.slice(0);\n        for (var i=0; i<=3; i++) {\n            if (i < 3) {\n                if (rgb[i] < 0 || rgb[i] > 255) { rgb._clipped = true; }\n                rgb[i] = limit(rgb[i], 0, 255);\n            } else if (i === 3) {\n                rgb[i] = limit(rgb[i], 0, 1);\n            }\n        }\n        return rgb;\n    };\n\n    // ported from jQuery's $.type\n    var classToType = {};\n    for (var i = 0, list = ['Boolean', 'Number', 'String', 'Function', 'Array', 'Date', 'RegExp', 'Undefined', 'Null']; i < list.length; i += 1) {\n        var name = list[i];\n\n        classToType[(\"[object \" + name + \"]\")] = name.toLowerCase();\n    }\n    var type = function(obj) {\n        return classToType[Object.prototype.toString.call(obj)] || \"object\";\n    };\n\n    var unpack = function (args, keyOrder) {\n        if ( keyOrder === void 0 ) keyOrder=null;\n\n    \t// if called with more than 3 arguments, we return the arguments\n        if (args.length >= 3) { return Array.prototype.slice.call(args); }\n        // with less than 3 args we check if first arg is object\n        // and use the keyOrder string to extract and sort properties\n    \tif (type(args[0]) == 'object' && keyOrder) {\n    \t\treturn keyOrder.split('')\n    \t\t\t.filter(function (k) { return args[0][k] !== undefined; })\n    \t\t\t.map(function (k) { return args[0][k]; });\n    \t}\n    \t// otherwise we just return the first argument\n    \t// (which we suppose is an array of args)\n        return args[0];\n    };\n\n    var last = function (args) {\n        if (args.length < 2) { return null; }\n        var l = args.length-1;\n        if (type(args[l]) == 'string') { return args[l].toLowerCase(); }\n        return null;\n    };\n\n    var PI = Math.PI;\n\n    var utils = {\n    \tclip_rgb: clip_rgb,\n    \tlimit: limit,\n    \ttype: type,\n    \tunpack: unpack,\n    \tlast: last,\n    \tPI: PI,\n    \tTWOPI: PI*2,\n    \tPITHIRD: PI/3,\n    \tDEG2RAD: PI / 180,\n    \tRAD2DEG: 180 / PI\n    };\n\n    var input = {\n    \tformat: {},\n    \tautodetect: []\n    };\n\n    var last$1 = utils.last;\n    var clip_rgb$1 = utils.clip_rgb;\n    var type$1 = utils.type;\n\n\n    var Color = function Color() {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var me = this;\n        if (type$1(args[0]) === 'object' &&\n            args[0].constructor &&\n            args[0].constructor === this.constructor) {\n            // the argument is already a Color instance\n            return args[0];\n        }\n\n        // last argument could be the mode\n        var mode = last$1(args);\n        var autodetect = false;\n\n        if (!mode) {\n            autodetect = true;\n            if (!input.sorted) {\n                input.autodetect = input.autodetect.sort(function (a,b) { return b.p - a.p; });\n                input.sorted = true;\n            }\n            // auto-detect format\n            for (var i = 0, list = input.autodetect; i < list.length; i += 1) {\n                var chk = list[i];\n\n                mode = chk.test.apply(chk, args);\n                if (mode) { break; }\n            }\n        }\n\n        if (input.format[mode]) {\n            var rgb = input.format[mode].apply(null, autodetect ? args : args.slice(0,-1));\n            me._rgb = clip_rgb$1(rgb);\n        } else {\n            throw new Error('unknown format: '+args);\n        }\n\n        // add alpha channel\n        if (me._rgb.length === 3) { me._rgb.push(1); }\n    };\n\n    Color.prototype.toString = function toString () {\n        if (type$1(this.hex) == 'function') { return this.hex(); }\n        return (\"[\" + (this._rgb.join(',')) + \"]\");\n    };\n\n    var Color_1 = Color;\n\n    var chroma = function () {\n    \tvar args = [], len = arguments.length;\n    \twhile ( len-- ) args[ len ] = arguments[ len ];\n\n    \treturn new (Function.prototype.bind.apply( chroma.Color, [ null ].concat( args) ));\n    };\n\n    chroma.Color = Color_1;\n    chroma.version = '2.1.0';\n\n    var chroma_1 = chroma;\n\n    var unpack$1 = utils.unpack;\n    var max = Math.max;\n\n    var rgb2cmyk = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$1(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        r = r / 255;\n        g = g / 255;\n        b = b / 255;\n        var k = 1 - max(r,max(g,b));\n        var f = k < 1 ? 1 / (1-k) : 0;\n        var c = (1-r-k) * f;\n        var m = (1-g-k) * f;\n        var y = (1-b-k) * f;\n        return [c,m,y,k];\n    };\n\n    var rgb2cmyk_1 = rgb2cmyk;\n\n    var unpack$2 = utils.unpack;\n\n    var cmyk2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack$2(args, 'cmyk');\n        var c = args[0];\n        var m = args[1];\n        var y = args[2];\n        var k = args[3];\n        var alpha = args.length > 4 ? args[4] : 1;\n        if (k === 1) { return [0,0,0,alpha]; }\n        return [\n            c >= 1 ? 0 : 255 * (1-c) * (1-k), // r\n            m >= 1 ? 0 : 255 * (1-m) * (1-k), // g\n            y >= 1 ? 0 : 255 * (1-y) * (1-k), // b\n            alpha\n        ];\n    };\n\n    var cmyk2rgb_1 = cmyk2rgb;\n\n    var unpack$3 = utils.unpack;\n    var type$2 = utils.type;\n\n\n\n    Color_1.prototype.cmyk = function() {\n        return rgb2cmyk_1(this._rgb);\n    };\n\n    chroma_1.cmyk = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['cmyk']) ));\n    };\n\n    input.format.cmyk = cmyk2rgb_1;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$3(args, 'cmyk');\n            if (type$2(args) === 'array' && args.length === 4) {\n                return 'cmyk';\n            }\n        }\n    });\n\n    var unpack$4 = utils.unpack;\n    var last$2 = utils.last;\n    var rnd = function (a) { return Math.round(a*100)/100; };\n\n    /*\n     * supported arguments:\n     * - hsl2css(h,s,l)\n     * - hsl2css(h,s,l,a)\n     * - hsl2css([h,s,l], mode)\n     * - hsl2css([h,s,l,a], mode)\n     * - hsl2css({h,s,l,a}, mode)\n     */\n    var hsl2css = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var hsla = unpack$4(args, 'hsla');\n        var mode = last$2(args) || 'lsa';\n        hsla[0] = rnd(hsla[0] || 0);\n        hsla[1] = rnd(hsla[1]*100) + '%';\n        hsla[2] = rnd(hsla[2]*100) + '%';\n        if (mode === 'hsla' || (hsla.length > 3 && hsla[3]<1)) {\n            hsla[3] = hsla.length > 3 ? hsla[3] : 1;\n            mode = 'hsla';\n        } else {\n            hsla.length = 3;\n        }\n        return (mode + \"(\" + (hsla.join(',')) + \")\");\n    };\n\n    var hsl2css_1 = hsl2css;\n\n    var unpack$5 = utils.unpack;\n\n    /*\n     * supported arguments:\n     * - rgb2hsl(r,g,b)\n     * - rgb2hsl(r,g,b,a)\n     * - rgb2hsl([r,g,b])\n     * - rgb2hsl([r,g,b,a])\n     * - rgb2hsl({r,g,b,a})\n     */\n    var rgb2hsl = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack$5(args, 'rgba');\n        var r = args[0];\n        var g = args[1];\n        var b = args[2];\n\n        r /= 255;\n        g /= 255;\n        b /= 255;\n\n        var min = Math.min(r, g, b);\n        var max = Math.max(r, g, b);\n\n        var l = (max + min) / 2;\n        var s, h;\n\n        if (max === min){\n            s = 0;\n            h = Number.NaN;\n        } else {\n            s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);\n        }\n\n        if (r == max) { h = (g - b) / (max - min); }\n        else if (g == max) { h = 2 + (b - r) / (max - min); }\n        else if (b == max) { h = 4 + (r - g) / (max - min); }\n\n        h *= 60;\n        if (h < 0) { h += 360; }\n        if (args.length>3 && args[3]!==undefined) { return [h,s,l,args[3]]; }\n        return [h,s,l];\n    };\n\n    var rgb2hsl_1 = rgb2hsl;\n\n    var unpack$6 = utils.unpack;\n    var last$3 = utils.last;\n\n\n    var round = Math.round;\n\n    /*\n     * supported arguments:\n     * - rgb2css(r,g,b)\n     * - rgb2css(r,g,b,a)\n     * - rgb2css([r,g,b], mode)\n     * - rgb2css([r,g,b,a], mode)\n     * - rgb2css({r,g,b,a}, mode)\n     */\n    var rgb2css = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var rgba = unpack$6(args, 'rgba');\n        var mode = last$3(args) || 'rgb';\n        if (mode.substr(0,3) == 'hsl') {\n            return hsl2css_1(rgb2hsl_1(rgba), mode);\n        }\n        rgba[0] = round(rgba[0]);\n        rgba[1] = round(rgba[1]);\n        rgba[2] = round(rgba[2]);\n        if (mode === 'rgba' || (rgba.length > 3 && rgba[3]<1)) {\n            rgba[3] = rgba.length > 3 ? rgba[3] : 1;\n            mode = 'rgba';\n        }\n        return (mode + \"(\" + (rgba.slice(0,mode==='rgb'?3:4).join(',')) + \")\");\n    };\n\n    var rgb2css_1 = rgb2css;\n\n    var unpack$7 = utils.unpack;\n    var round$1 = Math.round;\n\n    var hsl2rgb = function () {\n        var assign;\n\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n        args = unpack$7(args, 'hsl');\n        var h = args[0];\n        var s = args[1];\n        var l = args[2];\n        var r,g,b;\n        if (s === 0) {\n            r = g = b = l*255;\n        } else {\n            var t3 = [0,0,0];\n            var c = [0,0,0];\n            var t2 = l < 0.5 ? l * (1+s) : l+s-l*s;\n            var t1 = 2 * l - t2;\n            var h_ = h / 360;\n            t3[0] = h_ + 1/3;\n            t3[1] = h_;\n            t3[2] = h_ - 1/3;\n            for (var i=0; i<3; i++) {\n                if (t3[i] < 0) { t3[i] += 1; }\n                if (t3[i] > 1) { t3[i] -= 1; }\n                if (6 * t3[i] < 1)\n                    { c[i] = t1 + (t2 - t1) * 6 * t3[i]; }\n                else if (2 * t3[i] < 1)\n                    { c[i] = t2; }\n                else if (3 * t3[i] < 2)\n                    { c[i] = t1 + (t2 - t1) * ((2 / 3) - t3[i]) * 6; }\n                else\n                    { c[i] = t1; }\n            }\n            (assign = [round$1(c[0]*255),round$1(c[1]*255),round$1(c[2]*255)], r = assign[0], g = assign[1], b = assign[2]);\n        }\n        if (args.length > 3) {\n            // keep alpha channel\n            return [r,g,b,args[3]];\n        }\n        return [r,g,b,1];\n    };\n\n    var hsl2rgb_1 = hsl2rgb;\n\n    var RE_RGB = /^rgb\\(\\s*(-?\\d+),\\s*(-?\\d+)\\s*,\\s*(-?\\d+)\\s*\\)$/;\n    var RE_RGBA = /^rgba\\(\\s*(-?\\d+),\\s*(-?\\d+)\\s*,\\s*(-?\\d+)\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n    var RE_RGB_PCT = /^rgb\\(\\s*(-?\\d+(?:\\.\\d+)?)%,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n    var RE_RGBA_PCT = /^rgba\\(\\s*(-?\\d+(?:\\.\\d+)?)%,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n    var RE_HSL = /^hsl\\(\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n    var RE_HSLA = /^hsla\\(\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n\n    var round$2 = Math.round;\n\n    var css2rgb = function (css) {\n        css = css.toLowerCase().trim();\n        var m;\n\n        if (input.format.named) {\n            try {\n                return input.format.named(css);\n            } catch (e) {\n                // eslint-disable-next-line\n            }\n        }\n\n        // rgb(250,20,0)\n        if ((m = css.match(RE_RGB))) {\n            var rgb = m.slice(1,4);\n            for (var i=0; i<3; i++) {\n                rgb[i] = +rgb[i];\n            }\n            rgb[3] = 1;  // default alpha\n            return rgb;\n        }\n\n        // rgba(250,20,0,0.4)\n        if ((m = css.match(RE_RGBA))) {\n            var rgb$1 = m.slice(1,5);\n            for (var i$1=0; i$1<4; i$1++) {\n                rgb$1[i$1] = +rgb$1[i$1];\n            }\n            return rgb$1;\n        }\n\n        // rgb(100%,0%,0%)\n        if ((m = css.match(RE_RGB_PCT))) {\n            var rgb$2 = m.slice(1,4);\n            for (var i$2=0; i$2<3; i$2++) {\n                rgb$2[i$2] = round$2(rgb$2[i$2] * 2.55);\n            }\n            rgb$2[3] = 1;  // default alpha\n            return rgb$2;\n        }\n\n        // rgba(100%,0%,0%,0.4)\n        if ((m = css.match(RE_RGBA_PCT))) {\n            var rgb$3 = m.slice(1,5);\n            for (var i$3=0; i$3<3; i$3++) {\n                rgb$3[i$3] = round$2(rgb$3[i$3] * 2.55);\n            }\n            rgb$3[3] = +rgb$3[3];\n            return rgb$3;\n        }\n\n        // hsl(0,100%,50%)\n        if ((m = css.match(RE_HSL))) {\n            var hsl = m.slice(1,4);\n            hsl[1] *= 0.01;\n            hsl[2] *= 0.01;\n            var rgb$4 = hsl2rgb_1(hsl);\n            rgb$4[3] = 1;\n            return rgb$4;\n        }\n\n        // hsla(0,100%,50%,0.5)\n        if ((m = css.match(RE_HSLA))) {\n            var hsl$1 = m.slice(1,4);\n            hsl$1[1] *= 0.01;\n            hsl$1[2] *= 0.01;\n            var rgb$5 = hsl2rgb_1(hsl$1);\n            rgb$5[3] = +m[4];  // default alpha = 1\n            return rgb$5;\n        }\n    };\n\n    css2rgb.test = function (s) {\n        return RE_RGB.test(s) ||\n            RE_RGBA.test(s) ||\n            RE_RGB_PCT.test(s) ||\n            RE_RGBA_PCT.test(s) ||\n            RE_HSL.test(s) ||\n            RE_HSLA.test(s);\n    };\n\n    var css2rgb_1 = css2rgb;\n\n    var type$3 = utils.type;\n\n\n\n\n    Color_1.prototype.css = function(mode) {\n        return rgb2css_1(this._rgb, mode);\n    };\n\n    chroma_1.css = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['css']) ));\n    };\n\n    input.format.css = css2rgb_1;\n\n    input.autodetect.push({\n        p: 5,\n        test: function (h) {\n            var rest = [], len = arguments.length - 1;\n            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];\n\n            if (!rest.length && type$3(h) === 'string' && css2rgb_1.test(h)) {\n                return 'css';\n            }\n        }\n    });\n\n    var unpack$8 = utils.unpack;\n\n    input.format.gl = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var rgb = unpack$8(args, 'rgba');\n        rgb[0] *= 255;\n        rgb[1] *= 255;\n        rgb[2] *= 255;\n        return rgb;\n    };\n\n    chroma_1.gl = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['gl']) ));\n    };\n\n    Color_1.prototype.gl = function() {\n        var rgb = this._rgb;\n        return [rgb[0]/255, rgb[1]/255, rgb[2]/255, rgb[3]];\n    };\n\n    var unpack$9 = utils.unpack;\n\n    var rgb2hcg = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$9(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        var min = Math.min(r, g, b);\n        var max = Math.max(r, g, b);\n        var delta = max - min;\n        var c = delta * 100 / 255;\n        var _g = min / (255 - delta) * 100;\n        var h;\n        if (delta === 0) {\n            h = Number.NaN;\n        } else {\n            if (r === max) { h = (g - b) / delta; }\n            if (g === max) { h = 2+(b - r) / delta; }\n            if (b === max) { h = 4+(r - g) / delta; }\n            h *= 60;\n            if (h < 0) { h += 360; }\n        }\n        return [h, c, _g];\n    };\n\n    var rgb2hcg_1 = rgb2hcg;\n\n    var unpack$a = utils.unpack;\n    var floor = Math.floor;\n\n    /*\n     * this is basically just HSV with some minor tweaks\n     *\n     * hue.. [0..360]\n     * chroma .. [0..1]\n     * grayness .. [0..1]\n     */\n\n    var hcg2rgb = function () {\n        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;\n\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n        args = unpack$a(args, 'hcg');\n        var h = args[0];\n        var c = args[1];\n        var _g = args[2];\n        var r,g,b;\n        _g = _g * 255;\n        var _c = c * 255;\n        if (c === 0) {\n            r = g = b = _g;\n        } else {\n            if (h === 360) { h = 0; }\n            if (h > 360) { h -= 360; }\n            if (h < 0) { h += 360; }\n            h /= 60;\n            var i = floor(h);\n            var f = h - i;\n            var p = _g * (1 - c);\n            var q = p + _c * (1 - f);\n            var t = p + _c * f;\n            var v = p + _c;\n            switch (i) {\n                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break\n                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break\n                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break\n                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break\n                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break\n                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break\n            }\n        }\n        return [r, g, b, args.length > 3 ? args[3] : 1];\n    };\n\n    var hcg2rgb_1 = hcg2rgb;\n\n    var unpack$b = utils.unpack;\n    var type$4 = utils.type;\n\n\n\n\n\n\n    Color_1.prototype.hcg = function() {\n        return rgb2hcg_1(this._rgb);\n    };\n\n    chroma_1.hcg = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hcg']) ));\n    };\n\n    input.format.hcg = hcg2rgb_1;\n\n    input.autodetect.push({\n        p: 1,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$b(args, 'hcg');\n            if (type$4(args) === 'array' && args.length === 3) {\n                return 'hcg';\n            }\n        }\n    });\n\n    var unpack$c = utils.unpack;\n    var last$4 = utils.last;\n    var round$3 = Math.round;\n\n    var rgb2hex = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$c(args, 'rgba');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        var a = ref[3];\n        var mode = last$4(args) || 'auto';\n        if (a === undefined) { a = 1; }\n        if (mode === 'auto') {\n            mode = a < 1 ? 'rgba' : 'rgb';\n        }\n        r = round$3(r);\n        g = round$3(g);\n        b = round$3(b);\n        var u = r << 16 | g << 8 | b;\n        var str = \"000000\" + u.toString(16); //#.toUpperCase();\n        str = str.substr(str.length - 6);\n        var hxa = '0' + round$3(a * 255).toString(16);\n        hxa = hxa.substr(hxa.length - 2);\n        switch (mode.toLowerCase()) {\n            case 'rgba': return (\"#\" + str + hxa);\n            case 'argb': return (\"#\" + hxa + str);\n            default: return (\"#\" + str);\n        }\n    };\n\n    var rgb2hex_1 = rgb2hex;\n\n    var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;\n    var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;\n\n    var hex2rgb = function (hex) {\n        if (hex.match(RE_HEX)) {\n            // remove optional leading #\n            if (hex.length === 4 || hex.length === 7) {\n                hex = hex.substr(1);\n            }\n            // expand short-notation to full six-digit\n            if (hex.length === 3) {\n                hex = hex.split('');\n                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];\n            }\n            var u = parseInt(hex, 16);\n            var r = u >> 16;\n            var g = u >> 8 & 0xFF;\n            var b = u & 0xFF;\n            return [r,g,b,1];\n        }\n\n        // match rgba hex format, eg #FF000077\n        if (hex.match(RE_HEXA)) {\n            if (hex.length === 5 || hex.length === 9) {\n                // remove optional leading #\n                hex = hex.substr(1);\n            }\n            // expand short-notation to full eight-digit\n            if (hex.length === 4) {\n                hex = hex.split('');\n                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]+hex[3]+hex[3];\n            }\n            var u$1 = parseInt(hex, 16);\n            var r$1 = u$1 >> 24 & 0xFF;\n            var g$1 = u$1 >> 16 & 0xFF;\n            var b$1 = u$1 >> 8 & 0xFF;\n            var a = Math.round((u$1 & 0xFF) / 0xFF * 100) / 100;\n            return [r$1,g$1,b$1,a];\n        }\n\n        // we used to check for css colors here\n        // if _input.css? and rgb = _input.css hex\n        //     return rgb\n\n        throw new Error((\"unknown hex color: \" + hex));\n    };\n\n    var hex2rgb_1 = hex2rgb;\n\n    var type$5 = utils.type;\n\n\n\n\n    Color_1.prototype.hex = function(mode) {\n        return rgb2hex_1(this._rgb, mode);\n    };\n\n    chroma_1.hex = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hex']) ));\n    };\n\n    input.format.hex = hex2rgb_1;\n    input.autodetect.push({\n        p: 4,\n        test: function (h) {\n            var rest = [], len = arguments.length - 1;\n            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];\n\n            if (!rest.length && type$5(h) === 'string' && [3,4,5,6,7,8,9].indexOf(h.length) >= 0) {\n                return 'hex';\n            }\n        }\n    });\n\n    var unpack$d = utils.unpack;\n    var TWOPI = utils.TWOPI;\n    var min = Math.min;\n    var sqrt = Math.sqrt;\n    var acos = Math.acos;\n\n    var rgb2hsi = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        /*\n        borrowed from here:\n        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp\n        */\n        var ref = unpack$d(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        r /= 255;\n        g /= 255;\n        b /= 255;\n        var h;\n        var min_ = min(r,g,b);\n        var i = (r+g+b) / 3;\n        var s = i > 0 ? 1 - min_/i : 0;\n        if (s === 0) {\n            h = NaN;\n        } else {\n            h = ((r-g)+(r-b)) / 2;\n            h /= sqrt((r-g)*(r-g) + (r-b)*(g-b));\n            h = acos(h);\n            if (b > g) {\n                h = TWOPI - h;\n            }\n            h /= TWOPI;\n        }\n        return [h*360,s,i];\n    };\n\n    var rgb2hsi_1 = rgb2hsi;\n\n    var unpack$e = utils.unpack;\n    var limit$1 = utils.limit;\n    var TWOPI$1 = utils.TWOPI;\n    var PITHIRD = utils.PITHIRD;\n    var cos = Math.cos;\n\n    /*\n     * hue [0..360]\n     * saturation [0..1]\n     * intensity [0..1]\n     */\n    var hsi2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        /*\n        borrowed from here:\n        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp\n        */\n        args = unpack$e(args, 'hsi');\n        var h = args[0];\n        var s = args[1];\n        var i = args[2];\n        var r,g,b;\n\n        if (isNaN(h)) { h = 0; }\n        if (isNaN(s)) { s = 0; }\n        // normalize hue\n        if (h > 360) { h -= 360; }\n        if (h < 0) { h += 360; }\n        h /= 360;\n        if (h < 1/3) {\n            b = (1-s)/3;\n            r = (1+s*cos(TWOPI$1*h)/cos(PITHIRD-TWOPI$1*h))/3;\n            g = 1 - (b+r);\n        } else if (h < 2/3) {\n            h -= 1/3;\n            r = (1-s)/3;\n            g = (1+s*cos(TWOPI$1*h)/cos(PITHIRD-TWOPI$1*h))/3;\n            b = 1 - (r+g);\n        } else {\n            h -= 2/3;\n            g = (1-s)/3;\n            b = (1+s*cos(TWOPI$1*h)/cos(PITHIRD-TWOPI$1*h))/3;\n            r = 1 - (g+b);\n        }\n        r = limit$1(i*r*3);\n        g = limit$1(i*g*3);\n        b = limit$1(i*b*3);\n        return [r*255, g*255, b*255, args.length > 3 ? args[3] : 1];\n    };\n\n    var hsi2rgb_1 = hsi2rgb;\n\n    var unpack$f = utils.unpack;\n    var type$6 = utils.type;\n\n\n\n\n\n\n    Color_1.prototype.hsi = function() {\n        return rgb2hsi_1(this._rgb);\n    };\n\n    chroma_1.hsi = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hsi']) ));\n    };\n\n    input.format.hsi = hsi2rgb_1;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$f(args, 'hsi');\n            if (type$6(args) === 'array' && args.length === 3) {\n                return 'hsi';\n            }\n        }\n    });\n\n    var unpack$g = utils.unpack;\n    var type$7 = utils.type;\n\n\n\n\n\n\n    Color_1.prototype.hsl = function() {\n        return rgb2hsl_1(this._rgb);\n    };\n\n    chroma_1.hsl = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hsl']) ));\n    };\n\n    input.format.hsl = hsl2rgb_1;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$g(args, 'hsl');\n            if (type$7(args) === 'array' && args.length === 3) {\n                return 'hsl';\n            }\n        }\n    });\n\n    var unpack$h = utils.unpack;\n    var min$1 = Math.min;\n    var max$1 = Math.max;\n\n    /*\n     * supported arguments:\n     * - rgb2hsv(r,g,b)\n     * - rgb2hsv([r,g,b])\n     * - rgb2hsv({r,g,b})\n     */\n    var rgb2hsl$1 = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack$h(args, 'rgb');\n        var r = args[0];\n        var g = args[1];\n        var b = args[2];\n        var min_ = min$1(r, g, b);\n        var max_ = max$1(r, g, b);\n        var delta = max_ - min_;\n        var h,s,v;\n        v = max_ / 255.0;\n        if (max_ === 0) {\n            h = Number.NaN;\n            s = 0;\n        } else {\n            s = delta / max_;\n            if (r === max_) { h = (g - b) / delta; }\n            if (g === max_) { h = 2+(b - r) / delta; }\n            if (b === max_) { h = 4+(r - g) / delta; }\n            h *= 60;\n            if (h < 0) { h += 360; }\n        }\n        return [h, s, v]\n    };\n\n    var rgb2hsv = rgb2hsl$1;\n\n    var unpack$i = utils.unpack;\n    var floor$1 = Math.floor;\n\n    var hsv2rgb = function () {\n        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;\n\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n        args = unpack$i(args, 'hsv');\n        var h = args[0];\n        var s = args[1];\n        var v = args[2];\n        var r,g,b;\n        v *= 255;\n        if (s === 0) {\n            r = g = b = v;\n        } else {\n            if (h === 360) { h = 0; }\n            if (h > 360) { h -= 360; }\n            if (h < 0) { h += 360; }\n            h /= 60;\n\n            var i = floor$1(h);\n            var f = h - i;\n            var p = v * (1 - s);\n            var q = v * (1 - s * f);\n            var t = v * (1 - s * (1 - f));\n\n            switch (i) {\n                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break\n                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break\n                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break\n                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break\n                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break\n                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break\n            }\n        }\n        return [r,g,b,args.length > 3?args[3]:1];\n    };\n\n    var hsv2rgb_1 = hsv2rgb;\n\n    var unpack$j = utils.unpack;\n    var type$8 = utils.type;\n\n\n\n\n\n\n    Color_1.prototype.hsv = function() {\n        return rgb2hsv(this._rgb);\n    };\n\n    chroma_1.hsv = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hsv']) ));\n    };\n\n    input.format.hsv = hsv2rgb_1;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$j(args, 'hsv');\n            if (type$8(args) === 'array' && args.length === 3) {\n                return 'hsv';\n            }\n        }\n    });\n\n    var labConstants = {\n        // Corresponds roughly to RGB brighter/darker\n        Kn: 18,\n\n        // D65 standard referent\n        Xn: 0.950470,\n        Yn: 1,\n        Zn: 1.088830,\n\n        t0: 0.137931034,  // 4 / 29\n        t1: 0.206896552,  // 6 / 29\n        t2: 0.12841855,   // 3 * t1 * t1\n        t3: 0.008856452,  // t1 * t1 * t1\n    };\n\n    var unpack$k = utils.unpack;\n    var pow = Math.pow;\n\n    var rgb2lab = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$k(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        var ref$1 = rgb2xyz(r,g,b);\n        var x = ref$1[0];\n        var y = ref$1[1];\n        var z = ref$1[2];\n        var l = 116 * y - 16;\n        return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z)];\n    };\n\n    var rgb_xyz = function (r) {\n        if ((r /= 255) <= 0.04045) { return r / 12.92; }\n        return pow((r + 0.055) / 1.055, 2.4);\n    };\n\n    var xyz_lab = function (t) {\n        if (t > labConstants.t3) { return pow(t, 1 / 3); }\n        return t / labConstants.t2 + labConstants.t0;\n    };\n\n    var rgb2xyz = function (r,g,b) {\n        r = rgb_xyz(r);\n        g = rgb_xyz(g);\n        b = rgb_xyz(b);\n        var x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / labConstants.Xn);\n        var y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / labConstants.Yn);\n        var z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / labConstants.Zn);\n        return [x,y,z];\n    };\n\n    var rgb2lab_1 = rgb2lab;\n\n    var unpack$l = utils.unpack;\n    var pow$1 = Math.pow;\n\n    /*\n     * L* [0..100]\n     * a [-100..100]\n     * b [-100..100]\n     */\n    var lab2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack$l(args, 'lab');\n        var l = args[0];\n        var a = args[1];\n        var b = args[2];\n        var x,y,z, r,g,b_;\n\n        y = (l + 16) / 116;\n        x = isNaN(a) ? y : y + a / 500;\n        z = isNaN(b) ? y : y - b / 200;\n\n        y = labConstants.Yn * lab_xyz(y);\n        x = labConstants.Xn * lab_xyz(x);\n        z = labConstants.Zn * lab_xyz(z);\n\n        r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);  // D65 -> sRGB\n        g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);\n        b_ = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);\n\n        return [r,g,b_,args.length > 3 ? args[3] : 1];\n    };\n\n    var xyz_rgb = function (r) {\n        return 255 * (r <= 0.00304 ? 12.92 * r : 1.055 * pow$1(r, 1 / 2.4) - 0.055)\n    };\n\n    var lab_xyz = function (t) {\n        return t > labConstants.t1 ? t * t * t : labConstants.t2 * (t - labConstants.t0)\n    };\n\n    var lab2rgb_1 = lab2rgb;\n\n    var unpack$m = utils.unpack;\n    var type$9 = utils.type;\n\n\n\n\n\n\n    Color_1.prototype.lab = function() {\n        return rgb2lab_1(this._rgb);\n    };\n\n    chroma_1.lab = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['lab']) ));\n    };\n\n    input.format.lab = lab2rgb_1;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$m(args, 'lab');\n            if (type$9(args) === 'array' && args.length === 3) {\n                return 'lab';\n            }\n        }\n    });\n\n    var unpack$n = utils.unpack;\n    var RAD2DEG = utils.RAD2DEG;\n    var sqrt$1 = Math.sqrt;\n    var atan2 = Math.atan2;\n    var round$4 = Math.round;\n\n    var lab2lch = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$n(args, 'lab');\n        var l = ref[0];\n        var a = ref[1];\n        var b = ref[2];\n        var c = sqrt$1(a * a + b * b);\n        var h = (atan2(b, a) * RAD2DEG + 360) % 360;\n        if (round$4(c*10000) === 0) { h = Number.NaN; }\n        return [l, c, h];\n    };\n\n    var lab2lch_1 = lab2lch;\n\n    var unpack$o = utils.unpack;\n\n\n\n    var rgb2lch = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$o(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        var ref$1 = rgb2lab_1(r,g,b);\n        var l = ref$1[0];\n        var a = ref$1[1];\n        var b_ = ref$1[2];\n        return lab2lch_1(l,a,b_);\n    };\n\n    var rgb2lch_1 = rgb2lch;\n\n    var unpack$p = utils.unpack;\n    var DEG2RAD = utils.DEG2RAD;\n    var sin = Math.sin;\n    var cos$1 = Math.cos;\n\n    var lch2lab = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        /*\n        Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.\n        These formulas were invented by David Dalrymple to obtain maximum contrast without going\n        out of gamut if the parameters are in the range 0-1.\n\n        A saturation multiplier was added by Gregor Aisch\n        */\n        var ref = unpack$p(args, 'lch');\n        var l = ref[0];\n        var c = ref[1];\n        var h = ref[2];\n        if (isNaN(h)) { h = 0; }\n        h = h * DEG2RAD;\n        return [l, cos$1(h) * c, sin(h) * c]\n    };\n\n    var lch2lab_1 = lch2lab;\n\n    var unpack$q = utils.unpack;\n\n\n\n    var lch2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack$q(args, 'lch');\n        var l = args[0];\n        var c = args[1];\n        var h = args[2];\n        var ref = lch2lab_1 (l,c,h);\n        var L = ref[0];\n        var a = ref[1];\n        var b_ = ref[2];\n        var ref$1 = lab2rgb_1 (L,a,b_);\n        var r = ref$1[0];\n        var g = ref$1[1];\n        var b = ref$1[2];\n        return [r, g, b, args.length > 3 ? args[3] : 1];\n    };\n\n    var lch2rgb_1 = lch2rgb;\n\n    var unpack$r = utils.unpack;\n\n\n    var hcl2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var hcl = unpack$r(args, 'hcl').reverse();\n        return lch2rgb_1.apply(void 0, hcl);\n    };\n\n    var hcl2rgb_1 = hcl2rgb;\n\n    var unpack$s = utils.unpack;\n    var type$a = utils.type;\n\n\n\n\n\n\n    Color_1.prototype.lch = function() { return rgb2lch_1(this._rgb); };\n    Color_1.prototype.hcl = function() { return rgb2lch_1(this._rgb).reverse(); };\n\n    chroma_1.lch = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['lch']) ));\n    };\n    chroma_1.hcl = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hcl']) ));\n    };\n\n    input.format.lch = lch2rgb_1;\n    input.format.hcl = hcl2rgb_1;\n\n    ['lch','hcl'].forEach(function (m) { return input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$s(args, m);\n            if (type$a(args) === 'array' && args.length === 3) {\n                return m;\n            }\n        }\n    }); });\n\n    /**\n    \tX11 color names\n\n    \thttp://www.w3.org/TR/css3-color/#svg-color\n    */\n\n    var w3cx11 = {\n        aliceblue: '#f0f8ff',\n        antiquewhite: '#faebd7',\n        aqua: '#00ffff',\n        aquamarine: '#7fffd4',\n        azure: '#f0ffff',\n        beige: '#f5f5dc',\n        bisque: '#ffe4c4',\n        black: '#000000',\n        blanchedalmond: '#ffebcd',\n        blue: '#0000ff',\n        blueviolet: '#8a2be2',\n        brown: '#a52a2a',\n        burlywood: '#deb887',\n        cadetblue: '#5f9ea0',\n        chartreuse: '#7fff00',\n        chocolate: '#d2691e',\n        coral: '#ff7f50',\n        cornflower: '#6495ed',\n        cornflowerblue: '#6495ed',\n        cornsilk: '#fff8dc',\n        crimson: '#dc143c',\n        cyan: '#00ffff',\n        darkblue: '#00008b',\n        darkcyan: '#008b8b',\n        darkgoldenrod: '#b8860b',\n        darkgray: '#a9a9a9',\n        darkgreen: '#006400',\n        darkgrey: '#a9a9a9',\n        darkkhaki: '#bdb76b',\n        darkmagenta: '#8b008b',\n        darkolivegreen: '#556b2f',\n        darkorange: '#ff8c00',\n        darkorchid: '#9932cc',\n        darkred: '#8b0000',\n        darksalmon: '#e9967a',\n        darkseagreen: '#8fbc8f',\n        darkslateblue: '#483d8b',\n        darkslategray: '#2f4f4f',\n        darkslategrey: '#2f4f4f',\n        darkturquoise: '#00ced1',\n        darkviolet: '#9400d3',\n        deeppink: '#ff1493',\n        deepskyblue: '#00bfff',\n        dimgray: '#696969',\n        dimgrey: '#696969',\n        dodgerblue: '#1e90ff',\n        firebrick: '#b22222',\n        floralwhite: '#fffaf0',\n        forestgreen: '#228b22',\n        fuchsia: '#ff00ff',\n        gainsboro: '#dcdcdc',\n        ghostwhite: '#f8f8ff',\n        gold: '#ffd700',\n        goldenrod: '#daa520',\n        gray: '#808080',\n        green: '#008000',\n        greenyellow: '#adff2f',\n        grey: '#808080',\n        honeydew: '#f0fff0',\n        hotpink: '#ff69b4',\n        indianred: '#cd5c5c',\n        indigo: '#4b0082',\n        ivory: '#fffff0',\n        khaki: '#f0e68c',\n        laserlemon: '#ffff54',\n        lavender: '#e6e6fa',\n        lavenderblush: '#fff0f5',\n        lawngreen: '#7cfc00',\n        lemonchiffon: '#fffacd',\n        lightblue: '#add8e6',\n        lightcoral: '#f08080',\n        lightcyan: '#e0ffff',\n        lightgoldenrod: '#fafad2',\n        lightgoldenrodyellow: '#fafad2',\n        lightgray: '#d3d3d3',\n        lightgreen: '#90ee90',\n        lightgrey: '#d3d3d3',\n        lightpink: '#ffb6c1',\n        lightsalmon: '#ffa07a',\n        lightseagreen: '#20b2aa',\n        lightskyblue: '#87cefa',\n        lightslategray: '#778899',\n        lightslategrey: '#778899',\n        lightsteelblue: '#b0c4de',\n        lightyellow: '#ffffe0',\n        lime: '#00ff00',\n        limegreen: '#32cd32',\n        linen: '#faf0e6',\n        magenta: '#ff00ff',\n        maroon: '#800000',\n        maroon2: '#7f0000',\n        maroon3: '#b03060',\n        mediumaquamarine: '#66cdaa',\n        mediumblue: '#0000cd',\n        mediumorchid: '#ba55d3',\n        mediumpurple: '#9370db',\n        mediumseagreen: '#3cb371',\n        mediumslateblue: '#7b68ee',\n        mediumspringgreen: '#00fa9a',\n        mediumturquoise: '#48d1cc',\n        mediumvioletred: '#c71585',\n        midnightblue: '#191970',\n        mintcream: '#f5fffa',\n        mistyrose: '#ffe4e1',\n        moccasin: '#ffe4b5',\n        navajowhite: '#ffdead',\n        navy: '#000080',\n        oldlace: '#fdf5e6',\n        olive: '#808000',\n        olivedrab: '#6b8e23',\n        orange: '#ffa500',\n        orangered: '#ff4500',\n        orchid: '#da70d6',\n        palegoldenrod: '#eee8aa',\n        palegreen: '#98fb98',\n        paleturquoise: '#afeeee',\n        palevioletred: '#db7093',\n        papayawhip: '#ffefd5',\n        peachpuff: '#ffdab9',\n        peru: '#cd853f',\n        pink: '#ffc0cb',\n        plum: '#dda0dd',\n        powderblue: '#b0e0e6',\n        purple: '#800080',\n        purple2: '#7f007f',\n        purple3: '#a020f0',\n        rebeccapurple: '#663399',\n        red: '#ff0000',\n        rosybrown: '#bc8f8f',\n        royalblue: '#4169e1',\n        saddlebrown: '#8b4513',\n        salmon: '#fa8072',\n        sandybrown: '#f4a460',\n        seagreen: '#2e8b57',\n        seashell: '#fff5ee',\n        sienna: '#a0522d',\n        silver: '#c0c0c0',\n        skyblue: '#87ceeb',\n        slateblue: '#6a5acd',\n        slategray: '#708090',\n        slategrey: '#708090',\n        snow: '#fffafa',\n        springgreen: '#00ff7f',\n        steelblue: '#4682b4',\n        tan: '#d2b48c',\n        teal: '#008080',\n        thistle: '#d8bfd8',\n        tomato: '#ff6347',\n        turquoise: '#40e0d0',\n        violet: '#ee82ee',\n        wheat: '#f5deb3',\n        white: '#ffffff',\n        whitesmoke: '#f5f5f5',\n        yellow: '#ffff00',\n        yellowgreen: '#9acd32'\n    };\n\n    var w3cx11_1 = w3cx11;\n\n    var type$b = utils.type;\n\n\n\n\n\n    Color_1.prototype.name = function() {\n        var hex = rgb2hex_1(this._rgb, 'rgb');\n        for (var i = 0, list = Object.keys(w3cx11_1); i < list.length; i += 1) {\n            var n = list[i];\n\n            if (w3cx11_1[n] === hex) { return n.toLowerCase(); }\n        }\n        return hex;\n    };\n\n    input.format.named = function (name) {\n        name = name.toLowerCase();\n        if (w3cx11_1[name]) { return hex2rgb_1(w3cx11_1[name]); }\n        throw new Error('unknown color name: '+name);\n    };\n\n    input.autodetect.push({\n        p: 5,\n        test: function (h) {\n            var rest = [], len = arguments.length - 1;\n            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];\n\n            if (!rest.length && type$b(h) === 'string' && w3cx11_1[h.toLowerCase()]) {\n                return 'named';\n            }\n        }\n    });\n\n    var unpack$t = utils.unpack;\n\n    var rgb2num = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$t(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        return (r << 16) + (g << 8) + b;\n    };\n\n    var rgb2num_1 = rgb2num;\n\n    var type$c = utils.type;\n\n    var num2rgb = function (num) {\n        if (type$c(num) == \"number\" && num >= 0 && num <= 0xFFFFFF) {\n            var r = num >> 16;\n            var g = (num >> 8) & 0xFF;\n            var b = num & 0xFF;\n            return [r,g,b,1];\n        }\n        throw new Error(\"unknown num color: \"+num);\n    };\n\n    var num2rgb_1 = num2rgb;\n\n    var type$d = utils.type;\n\n\n\n    Color_1.prototype.num = function() {\n        return rgb2num_1(this._rgb);\n    };\n\n    chroma_1.num = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['num']) ));\n    };\n\n    input.format.num = num2rgb_1;\n\n    input.autodetect.push({\n        p: 5,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            if (args.length === 1 && type$d(args[0]) === 'number' && args[0] >= 0 && args[0] <= 0xFFFFFF) {\n                return 'num';\n            }\n        }\n    });\n\n    var unpack$u = utils.unpack;\n    var type$e = utils.type;\n    var round$5 = Math.round;\n\n    Color_1.prototype.rgb = function(rnd) {\n        if ( rnd === void 0 ) rnd=true;\n\n        if (rnd === false) { return this._rgb.slice(0,3); }\n        return this._rgb.slice(0,3).map(round$5);\n    };\n\n    Color_1.prototype.rgba = function(rnd) {\n        if ( rnd === void 0 ) rnd=true;\n\n        return this._rgb.slice(0,4).map(function (v,i) {\n            return i<3 ? (rnd === false ? v : round$5(v)) : v;\n        });\n    };\n\n    chroma_1.rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['rgb']) ));\n    };\n\n    input.format.rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var rgba = unpack$u(args, 'rgba');\n        if (rgba[3] === undefined) { rgba[3] = 1; }\n        return rgba;\n    };\n\n    input.autodetect.push({\n        p: 3,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$u(args, 'rgba');\n            if (type$e(args) === 'array' && (args.length === 3 ||\n                args.length === 4 && type$e(args[3]) == 'number' && args[3] >= 0 && args[3] <= 1)) {\n                return 'rgb';\n            }\n        }\n    });\n\n    /*\n     * Based on implementation by Neil Bartlett\n     * https://github.com/neilbartlett/color-temperature\n     */\n\n    var log = Math.log;\n\n    var temperature2rgb = function (kelvin) {\n        var temp = kelvin / 100;\n        var r,g,b;\n        if (temp < 66) {\n            r = 255;\n            g = -155.25485562709179 - 0.44596950469579133 * (g = temp-2) + 104.49216199393888 * log(g);\n            b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp-10) + 115.67994401066147 * log(b);\n        } else {\n            r = 351.97690566805693 + 0.114206453784165 * (r = temp-55) - 40.25366309332127 * log(r);\n            g = 325.4494125711974 + 0.07943456536662342 * (g = temp-50) - 28.0852963507957 * log(g);\n            b = 255;\n        }\n        return [r,g,b,1];\n    };\n\n    var temperature2rgb_1 = temperature2rgb;\n\n    /*\n     * Based on implementation by Neil Bartlett\n     * https://github.com/neilbartlett/color-temperature\n     **/\n\n\n    var unpack$v = utils.unpack;\n    var round$6 = Math.round;\n\n    var rgb2temperature = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var rgb = unpack$v(args, 'rgb');\n        var r = rgb[0], b = rgb[2];\n        var minTemp = 1000;\n        var maxTemp = 40000;\n        var eps = 0.4;\n        var temp;\n        while (maxTemp - minTemp > eps) {\n            temp = (maxTemp + minTemp) * 0.5;\n            var rgb$1 = temperature2rgb_1(temp);\n            if ((rgb$1[2] / rgb$1[0]) >= (b / r)) {\n                maxTemp = temp;\n            } else {\n                minTemp = temp;\n            }\n        }\n        return round$6(temp);\n    };\n\n    var rgb2temperature_1 = rgb2temperature;\n\n    Color_1.prototype.temp =\n    Color_1.prototype.kelvin =\n    Color_1.prototype.temperature = function() {\n        return rgb2temperature_1(this._rgb);\n    };\n\n    chroma_1.temp =\n    chroma_1.kelvin =\n    chroma_1.temperature = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['temp']) ));\n    };\n\n    input.format.temp =\n    input.format.kelvin =\n    input.format.temperature = temperature2rgb_1;\n\n    var type$f = utils.type;\n\n    Color_1.prototype.alpha = function(a, mutate) {\n        if ( mutate === void 0 ) mutate=false;\n\n        if (a !== undefined && type$f(a) === 'number') {\n            if (mutate) {\n                this._rgb[3] = a;\n                return this;\n            }\n            return new Color_1([this._rgb[0], this._rgb[1], this._rgb[2], a], 'rgb');\n        }\n        return this._rgb[3];\n    };\n\n    Color_1.prototype.clipped = function() {\n        return this._rgb._clipped || false;\n    };\n\n    Color_1.prototype.darken = function(amount) {\n    \tif ( amount === void 0 ) amount=1;\n\n    \tvar me = this;\n    \tvar lab = me.lab();\n    \tlab[0] -= labConstants.Kn * amount;\n    \treturn new Color_1(lab, 'lab').alpha(me.alpha(), true);\n    };\n\n    Color_1.prototype.brighten = function(amount) {\n    \tif ( amount === void 0 ) amount=1;\n\n    \treturn this.darken(-amount);\n    };\n\n    Color_1.prototype.darker = Color_1.prototype.darken;\n    Color_1.prototype.brighter = Color_1.prototype.brighten;\n\n    Color_1.prototype.get = function(mc) {\n        var ref = mc.split('.');\n        var mode = ref[0];\n        var channel = ref[1];\n        var src = this[mode]();\n        if (channel) {\n            var i = mode.indexOf(channel);\n            if (i > -1) { return src[i]; }\n            throw new Error((\"unknown channel \" + channel + \" in mode \" + mode));\n        } else {\n            return src;\n        }\n    };\n\n    var type$g = utils.type;\n    var pow$2 = Math.pow;\n\n    var EPS = 1e-7;\n    var MAX_ITER = 20;\n\n    Color_1.prototype.luminance = function(lum) {\n        if (lum !== undefined && type$g(lum) === 'number') {\n            if (lum === 0) {\n                // return pure black\n                return new Color_1([0,0,0,this._rgb[3]], 'rgb');\n            }\n            if (lum === 1) {\n                // return pure white\n                return new Color_1([255,255,255,this._rgb[3]], 'rgb');\n            }\n            // compute new color using...\n            var cur_lum = this.luminance();\n            var mode = 'rgb';\n            var max_iter = MAX_ITER;\n\n            var test = function (low, high) {\n                var mid = low.interpolate(high, 0.5, mode);\n                var lm = mid.luminance();\n                if (Math.abs(lum - lm) < EPS || !max_iter--) {\n                    // close enough\n                    return mid;\n                }\n                return lm > lum ? test(low, mid) : test(mid, high);\n            };\n\n            var rgb = (cur_lum > lum ? test(new Color_1([0,0,0]), this) : test(this, new Color_1([255,255,255]))).rgb();\n            return new Color_1(rgb.concat( [this._rgb[3]]));\n        }\n        return rgb2luminance.apply(void 0, (this._rgb).slice(0,3));\n    };\n\n\n    var rgb2luminance = function (r,g,b) {\n        // relative luminance\n        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n        r = luminance_x(r);\n        g = luminance_x(g);\n        b = luminance_x(b);\n        return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n    };\n\n    var luminance_x = function (x) {\n        x /= 255;\n        return x <= 0.03928 ? x/12.92 : pow$2((x+0.055)/1.055, 2.4);\n    };\n\n    var interpolator = {};\n\n    var type$h = utils.type;\n\n\n    var mix = function (col1, col2, f) {\n        if ( f === void 0 ) f=0.5;\n        var rest = [], len = arguments.length - 3;\n        while ( len-- > 0 ) rest[ len ] = arguments[ len + 3 ];\n\n        var mode = rest[0] || 'lrgb';\n        if (!interpolator[mode] && !rest.length) {\n            // fall back to the first supported mode\n            mode = Object.keys(interpolator)[0];\n        }\n        if (!interpolator[mode]) {\n            throw new Error((\"interpolation mode \" + mode + \" is not defined\"));\n        }\n        if (type$h(col1) !== 'object') { col1 = new Color_1(col1); }\n        if (type$h(col2) !== 'object') { col2 = new Color_1(col2); }\n        return interpolator[mode](col1, col2, f)\n            .alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));\n    };\n\n    Color_1.prototype.mix =\n    Color_1.prototype.interpolate = function(col2, f) {\n    \tif ( f === void 0 ) f=0.5;\n    \tvar rest = [], len = arguments.length - 2;\n    \twhile ( len-- > 0 ) rest[ len ] = arguments[ len + 2 ];\n\n    \treturn mix.apply(void 0, [ this, col2, f ].concat( rest ));\n    };\n\n    Color_1.prototype.premultiply = function(mutate) {\n    \tif ( mutate === void 0 ) mutate=false;\n\n    \tvar rgb = this._rgb;\n    \tvar a = rgb[3];\n    \tif (mutate) {\n    \t\tthis._rgb = [rgb[0]*a, rgb[1]*a, rgb[2]*a, a];\n    \t\treturn this;\n    \t} else {\n    \t\treturn new Color_1([rgb[0]*a, rgb[1]*a, rgb[2]*a, a], 'rgb');\n    \t}\n    };\n\n    Color_1.prototype.saturate = function(amount) {\n    \tif ( amount === void 0 ) amount=1;\n\n    \tvar me = this;\n    \tvar lch = me.lch();\n    \tlch[1] += labConstants.Kn * amount;\n    \tif (lch[1] < 0) { lch[1] = 0; }\n    \treturn new Color_1(lch, 'lch').alpha(me.alpha(), true);\n    };\n\n    Color_1.prototype.desaturate = function(amount) {\n    \tif ( amount === void 0 ) amount=1;\n\n    \treturn this.saturate(-amount);\n    };\n\n    var type$i = utils.type;\n\n    Color_1.prototype.set = function(mc, value, mutate) {\n        if ( mutate === void 0 ) mutate=false;\n\n        var ref = mc.split('.');\n        var mode = ref[0];\n        var channel = ref[1];\n        var src = this[mode]();\n        if (channel) {\n            var i = mode.indexOf(channel);\n            if (i > -1) {\n                if (type$i(value) == 'string') {\n                    switch(value.charAt(0)) {\n                        case '+': src[i] += +value; break;\n                        case '-': src[i] += +value; break;\n                        case '*': src[i] *= +(value.substr(1)); break;\n                        case '/': src[i] /= +(value.substr(1)); break;\n                        default: src[i] = +value;\n                    }\n                } else if (type$i(value) === 'number') {\n                    src[i] = value;\n                } else {\n                    throw new Error(\"unsupported value for Color.set\");\n                }\n                var out = new Color_1(src, mode);\n                if (mutate) {\n                    this._rgb = out._rgb;\n                    return this;\n                }\n                return out;\n            }\n            throw new Error((\"unknown channel \" + channel + \" in mode \" + mode));\n        } else {\n            return src;\n        }\n    };\n\n    var rgb$1 = function (col1, col2, f) {\n        var xyz0 = col1._rgb;\n        var xyz1 = col2._rgb;\n        return new Color_1(\n            xyz0[0] + f * (xyz1[0]-xyz0[0]),\n            xyz0[1] + f * (xyz1[1]-xyz0[1]),\n            xyz0[2] + f * (xyz1[2]-xyz0[2]),\n            'rgb'\n        )\n    };\n\n    // register interpolator\n    interpolator.rgb = rgb$1;\n\n    var sqrt$2 = Math.sqrt;\n    var pow$3 = Math.pow;\n\n    var lrgb = function (col1, col2, f) {\n        var ref = col1._rgb;\n        var x1 = ref[0];\n        var y1 = ref[1];\n        var z1 = ref[2];\n        var ref$1 = col2._rgb;\n        var x2 = ref$1[0];\n        var y2 = ref$1[1];\n        var z2 = ref$1[2];\n        return new Color_1(\n            sqrt$2(pow$3(x1,2) * (1-f) + pow$3(x2,2) * f),\n            sqrt$2(pow$3(y1,2) * (1-f) + pow$3(y2,2) * f),\n            sqrt$2(pow$3(z1,2) * (1-f) + pow$3(z2,2) * f),\n            'rgb'\n        )\n    };\n\n    // register interpolator\n    interpolator.lrgb = lrgb;\n\n    var lab$1 = function (col1, col2, f) {\n        var xyz0 = col1.lab();\n        var xyz1 = col2.lab();\n        return new Color_1(\n            xyz0[0] + f * (xyz1[0]-xyz0[0]),\n            xyz0[1] + f * (xyz1[1]-xyz0[1]),\n            xyz0[2] + f * (xyz1[2]-xyz0[2]),\n            'lab'\n        )\n    };\n\n    // register interpolator\n    interpolator.lab = lab$1;\n\n    var _hsx = function (col1, col2, f, m) {\n        var assign, assign$1;\n\n        var xyz0, xyz1;\n        if (m === 'hsl') {\n            xyz0 = col1.hsl();\n            xyz1 = col2.hsl();\n        } else if (m === 'hsv') {\n            xyz0 = col1.hsv();\n            xyz1 = col2.hsv();\n        } else if (m === 'hcg') {\n            xyz0 = col1.hcg();\n            xyz1 = col2.hcg();\n        } else if (m === 'hsi') {\n            xyz0 = col1.hsi();\n            xyz1 = col2.hsi();\n        } else if (m === 'lch' || m === 'hcl') {\n            m = 'hcl';\n            xyz0 = col1.hcl();\n            xyz1 = col2.hcl();\n        }\n\n        var hue0, hue1, sat0, sat1, lbv0, lbv1;\n        if (m.substr(0, 1) === 'h') {\n            (assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2]);\n            (assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2]);\n        }\n\n        var sat, hue, lbv, dh;\n\n        if (!isNaN(hue0) && !isNaN(hue1)) {\n            // both colors have hue\n            if (hue1 > hue0 && hue1 - hue0 > 180) {\n                dh = hue1-(hue0+360);\n            } else if (hue1 < hue0 && hue0 - hue1 > 180) {\n                dh = hue1+360-hue0;\n            } else{\n                dh = hue1 - hue0;\n            }\n            hue = hue0 + f * dh;\n        } else if (!isNaN(hue0)) {\n            hue = hue0;\n            if ((lbv1 == 1 || lbv1 == 0) && m != 'hsv') { sat = sat0; }\n        } else if (!isNaN(hue1)) {\n            hue = hue1;\n            if ((lbv0 == 1 || lbv0 == 0) && m != 'hsv') { sat = sat1; }\n        } else {\n            hue = Number.NaN;\n        }\n\n        if (sat === undefined) { sat = sat0 + f * (sat1 - sat0); }\n        lbv = lbv0 + f * (lbv1-lbv0);\n        return new Color_1([hue, sat, lbv], m);\n    };\n\n    var lch$1 = function (col1, col2, f) {\n    \treturn _hsx(col1, col2, f, 'lch');\n    };\n\n    // register interpolator\n    interpolator.lch = lch$1;\n    interpolator.hcl = lch$1;\n\n    var num$1 = function (col1, col2, f) {\n        var c1 = col1.num();\n        var c2 = col2.num();\n        return new Color_1(c1 + f * (c2-c1), 'num')\n    };\n\n    // register interpolator\n    interpolator.num = num$1;\n\n    var hcg$1 = function (col1, col2, f) {\n    \treturn _hsx(col1, col2, f, 'hcg');\n    };\n\n    // register interpolator\n    interpolator.hcg = hcg$1;\n\n    var hsi$1 = function (col1, col2, f) {\n    \treturn _hsx(col1, col2, f, 'hsi');\n    };\n\n    // register interpolator\n    interpolator.hsi = hsi$1;\n\n    var hsl$1 = function (col1, col2, f) {\n    \treturn _hsx(col1, col2, f, 'hsl');\n    };\n\n    // register interpolator\n    interpolator.hsl = hsl$1;\n\n    var hsv$1 = function (col1, col2, f) {\n    \treturn _hsx(col1, col2, f, 'hsv');\n    };\n\n    // register interpolator\n    interpolator.hsv = hsv$1;\n\n    var clip_rgb$2 = utils.clip_rgb;\n    var pow$4 = Math.pow;\n    var sqrt$3 = Math.sqrt;\n    var PI$1 = Math.PI;\n    var cos$2 = Math.cos;\n    var sin$1 = Math.sin;\n    var atan2$1 = Math.atan2;\n\n    var average = function (colors, mode, weights) {\n        if ( mode === void 0 ) mode='lrgb';\n        if ( weights === void 0 ) weights=null;\n\n        var l = colors.length;\n        if (!weights) { weights = Array.from(new Array(l)).map(function () { return 1; }); }\n        // normalize weights\n        var k = l / weights.reduce(function(a, b) { return a + b; });\n        weights.forEach(function (w,i) { weights[i] *= k; });\n        // convert colors to Color objects\n        colors = colors.map(function (c) { return new Color_1(c); });\n        if (mode === 'lrgb') {\n            return _average_lrgb(colors, weights)\n        }\n        var first = colors.shift();\n        var xyz = first.get(mode);\n        var cnt = [];\n        var dx = 0;\n        var dy = 0;\n        // initial color\n        for (var i=0; i<xyz.length; i++) {\n            xyz[i] = (xyz[i] || 0) * weights[0];\n            cnt.push(isNaN(xyz[i]) ? 0 : weights[0]);\n            if (mode.charAt(i) === 'h' && !isNaN(xyz[i])) {\n                var A = xyz[i] / 180 * PI$1;\n                dx += cos$2(A) * weights[0];\n                dy += sin$1(A) * weights[0];\n            }\n        }\n\n        var alpha = first.alpha() * weights[0];\n        colors.forEach(function (c,ci) {\n            var xyz2 = c.get(mode);\n            alpha += c.alpha() * weights[ci+1];\n            for (var i=0; i<xyz.length; i++) {\n                if (!isNaN(xyz2[i])) {\n                    cnt[i] += weights[ci+1];\n                    if (mode.charAt(i) === 'h') {\n                        var A = xyz2[i] / 180 * PI$1;\n                        dx += cos$2(A) * weights[ci+1];\n                        dy += sin$1(A) * weights[ci+1];\n                    } else {\n                        xyz[i] += xyz2[i] * weights[ci+1];\n                    }\n                }\n            }\n        });\n\n        for (var i$1=0; i$1<xyz.length; i$1++) {\n            if (mode.charAt(i$1) === 'h') {\n                var A$1 = atan2$1(dy / cnt[i$1], dx / cnt[i$1]) / PI$1 * 180;\n                while (A$1 < 0) { A$1 += 360; }\n                while (A$1 >= 360) { A$1 -= 360; }\n                xyz[i$1] = A$1;\n            } else {\n                xyz[i$1] = xyz[i$1]/cnt[i$1];\n            }\n        }\n        alpha /= l;\n        return (new Color_1(xyz, mode)).alpha(alpha > 0.99999 ? 1 : alpha, true);\n    };\n\n\n    var _average_lrgb = function (colors, weights) {\n        var l = colors.length;\n        var xyz = [0,0,0,0];\n        for (var i=0; i < colors.length; i++) {\n            var col = colors[i];\n            var f = weights[i] / l;\n            var rgb = col._rgb;\n            xyz[0] += pow$4(rgb[0],2) * f;\n            xyz[1] += pow$4(rgb[1],2) * f;\n            xyz[2] += pow$4(rgb[2],2) * f;\n            xyz[3] += rgb[3] * f;\n        }\n        xyz[0] = sqrt$3(xyz[0]);\n        xyz[1] = sqrt$3(xyz[1]);\n        xyz[2] = sqrt$3(xyz[2]);\n        if (xyz[3] > 0.9999999) { xyz[3] = 1; }\n        return new Color_1(clip_rgb$2(xyz));\n    };\n\n    // minimal multi-purpose interface\n\n    // @requires utils color analyze\n\n\n    var type$j = utils.type;\n\n    var pow$5 = Math.pow;\n\n    var scale = function(colors) {\n\n        // constructor\n        var _mode = 'rgb';\n        var _nacol = chroma_1('#ccc');\n        var _spread = 0;\n        // const _fixed = false;\n        var _domain = [0, 1];\n        var _pos = [];\n        var _padding = [0,0];\n        var _classes = false;\n        var _colors = [];\n        var _out = false;\n        var _min = 0;\n        var _max = 1;\n        var _correctLightness = false;\n        var _colorCache = {};\n        var _useCache = true;\n        var _gamma = 1;\n\n        // private methods\n\n        var setColors = function(colors) {\n            colors = colors || ['#fff', '#000'];\n            if (colors && type$j(colors) === 'string' && chroma_1.brewer &&\n                chroma_1.brewer[colors.toLowerCase()]) {\n                colors = chroma_1.brewer[colors.toLowerCase()];\n            }\n            if (type$j(colors) === 'array') {\n                // handle single color\n                if (colors.length === 1) {\n                    colors = [colors[0], colors[0]];\n                }\n                // make a copy of the colors\n                colors = colors.slice(0);\n                // convert to chroma classes\n                for (var c=0; c<colors.length; c++) {\n                    colors[c] = chroma_1(colors[c]);\n                }\n                // auto-fill color position\n                _pos.length = 0;\n                for (var c$1=0; c$1<colors.length; c$1++) {\n                    _pos.push(c$1/(colors.length-1));\n                }\n            }\n            resetCache();\n            return _colors = colors;\n        };\n\n        var getClass = function(value) {\n            if (_classes != null) {\n                var n = _classes.length-1;\n                var i = 0;\n                while (i < n && value >= _classes[i]) {\n                    i++;\n                }\n                return i-1;\n            }\n            return 0;\n        };\n\n        var tMapLightness = function (t) { return t; };\n        var tMapDomain = function (t) { return t; };\n\n        // const classifyValue = function(value) {\n        //     let val = value;\n        //     if (_classes.length > 2) {\n        //         const n = _classes.length-1;\n        //         const i = getClass(value);\n        //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class\n        //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class\n        //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));\n        //     }\n        //     return val;\n        // };\n\n        var getColor = function(val, bypassMap) {\n            var col, t;\n            if (bypassMap == null) { bypassMap = false; }\n            if (isNaN(val) || (val === null)) { return _nacol; }\n            if (!bypassMap) {\n                if (_classes && (_classes.length > 2)) {\n                    // find the class\n                    var c = getClass(val);\n                    t = c / (_classes.length-2);\n                } else if (_max !== _min) {\n                    // just interpolate between min/max\n                    t = (val - _min) / (_max - _min);\n                } else {\n                    t = 1;\n                }\n            } else {\n                t = val;\n            }\n\n            // domain map\n            t = tMapDomain(t);\n\n            if (!bypassMap) {\n                t = tMapLightness(t);  // lightness correction\n            }\n\n            if (_gamma !== 1) { t = pow$5(t, _gamma); }\n\n            t = _padding[0] + (t * (1 - _padding[0] - _padding[1]));\n\n            t = Math.min(1, Math.max(0, t));\n\n            var k = Math.floor(t * 10000);\n\n            if (_useCache && _colorCache[k]) {\n                col = _colorCache[k];\n            } else {\n                if (type$j(_colors) === 'array') {\n                    //for i in [0.._pos.length-1]\n                    for (var i=0; i<_pos.length; i++) {\n                        var p = _pos[i];\n                        if (t <= p) {\n                            col = _colors[i];\n                            break;\n                        }\n                        if ((t >= p) && (i === (_pos.length-1))) {\n                            col = _colors[i];\n                            break;\n                        }\n                        if (t > p && t < _pos[i+1]) {\n                            t = (t-p)/(_pos[i+1]-p);\n                            col = chroma_1.interpolate(_colors[i], _colors[i+1], t, _mode);\n                            break;\n                        }\n                    }\n                } else if (type$j(_colors) === 'function') {\n                    col = _colors(t);\n                }\n                if (_useCache) { _colorCache[k] = col; }\n            }\n            return col;\n        };\n\n        var resetCache = function () { return _colorCache = {}; };\n\n        setColors(colors);\n\n        // public interface\n\n        var f = function(v) {\n            var c = chroma_1(getColor(v));\n            if (_out && c[_out]) { return c[_out](); } else { return c; }\n        };\n\n        f.classes = function(classes) {\n            if (classes != null) {\n                if (type$j(classes) === 'array') {\n                    _classes = classes;\n                    _domain = [classes[0], classes[classes.length-1]];\n                } else {\n                    var d = chroma_1.analyze(_domain);\n                    if (classes === 0) {\n                        _classes = [d.min, d.max];\n                    } else {\n                        _classes = chroma_1.limits(d, 'e', classes);\n                    }\n                }\n                return f;\n            }\n            return _classes;\n        };\n\n\n        f.domain = function(domain) {\n            if (!arguments.length) {\n                return _domain;\n            }\n            _min = domain[0];\n            _max = domain[domain.length-1];\n            _pos = [];\n            var k = _colors.length;\n            if ((domain.length === k) && (_min !== _max)) {\n                // update positions\n                for (var i = 0, list = Array.from(domain); i < list.length; i += 1) {\n                    var d = list[i];\n\n                  _pos.push((d-_min) / (_max-_min));\n                }\n            } else {\n                for (var c=0; c<k; c++) {\n                    _pos.push(c/(k-1));\n                }\n                if (domain.length > 2) {\n                    // set domain map\n                    var tOut = domain.map(function (d,i) { return i/(domain.length-1); });\n                    var tBreaks = domain.map(function (d) { return (d - _min) / (_max - _min); });\n                    if (!tBreaks.every(function (val, i) { return tOut[i] === val; })) {\n                        tMapDomain = function (t) {\n                            if (t <= 0 || t >= 1) { return t; }\n                            var i = 0;\n                            while (t >= tBreaks[i+1]) { i++; }\n                            var f = (t - tBreaks[i]) / (tBreaks[i+1] - tBreaks[i]);\n                            var out = tOut[i] + f * (tOut[i+1] - tOut[i]);\n                            return out;\n                        };\n                    }\n\n                }\n            }\n            _domain = [_min, _max];\n            return f;\n        };\n\n        f.mode = function(_m) {\n            if (!arguments.length) {\n                return _mode;\n            }\n            _mode = _m;\n            resetCache();\n            return f;\n        };\n\n        f.range = function(colors, _pos) {\n            setColors(colors, _pos);\n            return f;\n        };\n\n        f.out = function(_o) {\n            _out = _o;\n            return f;\n        };\n\n        f.spread = function(val) {\n            if (!arguments.length) {\n                return _spread;\n            }\n            _spread = val;\n            return f;\n        };\n\n        f.correctLightness = function(v) {\n            if (v == null) { v = true; }\n            _correctLightness = v;\n            resetCache();\n            if (_correctLightness) {\n                tMapLightness = function(t) {\n                    var L0 = getColor(0, true).lab()[0];\n                    var L1 = getColor(1, true).lab()[0];\n                    var pol = L0 > L1;\n                    var L_actual = getColor(t, true).lab()[0];\n                    var L_ideal = L0 + ((L1 - L0) * t);\n                    var L_diff = L_actual - L_ideal;\n                    var t0 = 0;\n                    var t1 = 1;\n                    var max_iter = 20;\n                    while ((Math.abs(L_diff) > 1e-2) && (max_iter-- > 0)) {\n                        (function() {\n                            if (pol) { L_diff *= -1; }\n                            if (L_diff < 0) {\n                                t0 = t;\n                                t += (t1 - t) * 0.5;\n                            } else {\n                                t1 = t;\n                                t += (t0 - t) * 0.5;\n                            }\n                            L_actual = getColor(t, true).lab()[0];\n                            return L_diff = L_actual - L_ideal;\n                        })();\n                    }\n                    return t;\n                };\n            } else {\n                tMapLightness = function (t) { return t; };\n            }\n            return f;\n        };\n\n        f.padding = function(p) {\n            if (p != null) {\n                if (type$j(p) === 'number') {\n                    p = [p,p];\n                }\n                _padding = p;\n                return f;\n            } else {\n                return _padding;\n            }\n        };\n\n        f.colors = function(numColors, out) {\n            // If no arguments are given, return the original colors that were provided\n            if (arguments.length < 2) { out = 'hex'; }\n            var result = [];\n\n            if (arguments.length === 0) {\n                result = _colors.slice(0);\n\n            } else if (numColors === 1) {\n                result = [f(0.5)];\n\n            } else if (numColors > 1) {\n                var dm = _domain[0];\n                var dd = _domain[1] - dm;\n                result = __range__(0, numColors, false).map(function (i) { return f( dm + ((i/(numColors-1)) * dd) ); });\n\n            } else { // returns all colors based on the defined classes\n                colors = [];\n                var samples = [];\n                if (_classes && (_classes.length > 2)) {\n                    for (var i = 1, end = _classes.length, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n                        samples.push((_classes[i-1]+_classes[i])*0.5);\n                    }\n                } else {\n                    samples = _domain;\n                }\n                result = samples.map(function (v) { return f(v); });\n            }\n\n            if (chroma_1[out]) {\n                result = result.map(function (c) { return c[out](); });\n            }\n            return result;\n        };\n\n        f.cache = function(c) {\n            if (c != null) {\n                _useCache = c;\n                return f;\n            } else {\n                return _useCache;\n            }\n        };\n\n        f.gamma = function(g) {\n            if (g != null) {\n                _gamma = g;\n                return f;\n            } else {\n                return _gamma;\n            }\n        };\n\n        f.nodata = function(d) {\n            if (d != null) {\n                _nacol = chroma_1(d);\n                return f;\n            } else {\n                return _nacol;\n            }\n        };\n\n        return f;\n    };\n\n    function __range__(left, right, inclusive) {\n      var range = [];\n      var ascending = left < right;\n      var end = !inclusive ? right : ascending ? right + 1 : right - 1;\n      for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n        range.push(i);\n      }\n      return range;\n    }\n\n    //\n    // interpolates between a set of colors uzing a bezier spline\n    //\n\n    // @requires utils lab\n\n\n\n\n    var bezier = function(colors) {\n        var assign, assign$1, assign$2;\n\n        var I, lab0, lab1, lab2;\n        colors = colors.map(function (c) { return new Color_1(c); });\n        if (colors.length === 2) {\n            // linear interpolation\n            (assign = colors.map(function (c) { return c.lab(); }), lab0 = assign[0], lab1 = assign[1]);\n            I = function(t) {\n                var lab = ([0, 1, 2].map(function (i) { return lab0[i] + (t * (lab1[i] - lab0[i])); }));\n                return new Color_1(lab, 'lab');\n            };\n        } else if (colors.length === 3) {\n            // quadratic bezier interpolation\n            (assign$1 = colors.map(function (c) { return c.lab(); }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2]);\n            I = function(t) {\n                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t) * lab0[i]) + (2 * (1-t) * t * lab1[i]) + (t * t * lab2[i]); }));\n                return new Color_1(lab, 'lab');\n            };\n        } else if (colors.length === 4) {\n            // cubic bezier interpolation\n            var lab3;\n            (assign$2 = colors.map(function (c) { return c.lab(); }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3]);\n            I = function(t) {\n                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t)*(1-t) * lab0[i]) + (3 * (1-t) * (1-t) * t * lab1[i]) + (3 * (1-t) * t * t * lab2[i]) + (t*t*t * lab3[i]); }));\n                return new Color_1(lab, 'lab');\n            };\n        } else if (colors.length === 5) {\n            var I0 = bezier(colors.slice(0, 3));\n            var I1 = bezier(colors.slice(2, 5));\n            I = function(t) {\n                if (t < 0.5) {\n                    return I0(t*2);\n                } else {\n                    return I1((t-0.5)*2);\n                }\n            };\n        }\n        return I;\n    };\n\n    var bezier_1 = function (colors) {\n        var f = bezier(colors);\n        f.scale = function () { return scale(f); };\n        return f;\n    };\n\n    /*\n     * interpolates between a set of colors uzing a bezier spline\n     * blend mode formulas taken from http://www.venture-ware.com/kevin/coding/lets-learn-math-photoshop-blend-modes/\n     */\n\n\n\n\n    var blend = function (bottom, top, mode) {\n        if (!blend[mode]) {\n            throw new Error('unknown blend mode ' + mode);\n        }\n        return blend[mode](bottom, top);\n    };\n\n    var blend_f = function (f) { return function (bottom,top) {\n            var c0 = chroma_1(top).rgb();\n            var c1 = chroma_1(bottom).rgb();\n            return chroma_1.rgb(f(c0, c1));\n        }; };\n\n    var each = function (f) { return function (c0, c1) {\n            var out = [];\n            out[0] = f(c0[0], c1[0]);\n            out[1] = f(c0[1], c1[1]);\n            out[2] = f(c0[2], c1[2]);\n            return out;\n        }; };\n\n    var normal = function (a) { return a; };\n    var multiply = function (a,b) { return a * b / 255; };\n    var darken$1 = function (a,b) { return a > b ? b : a; };\n    var lighten = function (a,b) { return a > b ? a : b; };\n    var screen = function (a,b) { return 255 * (1 - (1-a/255) * (1-b/255)); };\n    var overlay = function (a,b) { return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255 ) * ( 1 - b / 255 )); };\n    var burn = function (a,b) { return 255 * (1 - (1 - b / 255) / (a/255)); };\n    var dodge = function (a,b) {\n        if (a === 255) { return 255; }\n        a = 255 * (b / 255) / (1 - a / 255);\n        return a > 255 ? 255 : a\n    };\n\n    // # add = (a,b) ->\n    // #     if (a + b > 255) then 255 else a + b\n\n    blend.normal = blend_f(each(normal));\n    blend.multiply = blend_f(each(multiply));\n    blend.screen = blend_f(each(screen));\n    blend.overlay = blend_f(each(overlay));\n    blend.darken = blend_f(each(darken$1));\n    blend.lighten = blend_f(each(lighten));\n    blend.dodge = blend_f(each(dodge));\n    blend.burn = blend_f(each(burn));\n    // blend.add = blend_f(each(add));\n\n    var blend_1 = blend;\n\n    // cubehelix interpolation\n    // based on D.A. Green \"A colour scheme for the display of astronomical intensity images\"\n    // http://astron-soc.in/bulletin/11June/289392011.pdf\n\n    var type$k = utils.type;\n    var clip_rgb$3 = utils.clip_rgb;\n    var TWOPI$2 = utils.TWOPI;\n    var pow$6 = Math.pow;\n    var sin$2 = Math.sin;\n    var cos$3 = Math.cos;\n\n\n    var cubehelix = function(start, rotations, hue, gamma, lightness) {\n        if ( start === void 0 ) start=300;\n        if ( rotations === void 0 ) rotations=-1.5;\n        if ( hue === void 0 ) hue=1;\n        if ( gamma === void 0 ) gamma=1;\n        if ( lightness === void 0 ) lightness=[0,1];\n\n        var dh = 0, dl;\n        if (type$k(lightness) === 'array') {\n            dl = lightness[1] - lightness[0];\n        } else {\n            dl = 0;\n            lightness = [lightness, lightness];\n        }\n\n        var f = function(fract) {\n            var a = TWOPI$2 * (((start+120)/360) + (rotations * fract));\n            var l = pow$6(lightness[0] + (dl * fract), gamma);\n            var h = dh !== 0 ? hue[0] + (fract * dh) : hue;\n            var amp = (h * l * (1-l)) / 2;\n            var cos_a = cos$3(a);\n            var sin_a = sin$2(a);\n            var r = l + (amp * ((-0.14861 * cos_a) + (1.78277* sin_a)));\n            var g = l + (amp * ((-0.29227 * cos_a) - (0.90649* sin_a)));\n            var b = l + (amp * (+1.97294 * cos_a));\n            return chroma_1(clip_rgb$3([r*255,g*255,b*255,1]));\n        };\n\n        f.start = function(s) {\n            if ((s == null)) { return start; }\n            start = s;\n            return f;\n        };\n\n        f.rotations = function(r) {\n            if ((r == null)) { return rotations; }\n            rotations = r;\n            return f;\n        };\n\n        f.gamma = function(g) {\n            if ((g == null)) { return gamma; }\n            gamma = g;\n            return f;\n        };\n\n        f.hue = function(h) {\n            if ((h == null)) { return hue; }\n            hue = h;\n            if (type$k(hue) === 'array') {\n                dh = hue[1] - hue[0];\n                if (dh === 0) { hue = hue[1]; }\n            } else {\n                dh = 0;\n            }\n            return f;\n        };\n\n        f.lightness = function(h) {\n            if ((h == null)) { return lightness; }\n            if (type$k(h) === 'array') {\n                lightness = h;\n                dl = h[1] - h[0];\n            } else {\n                lightness = [h,h];\n                dl = 0;\n            }\n            return f;\n        };\n\n        f.scale = function () { return chroma_1.scale(f); };\n\n        f.hue(hue);\n\n        return f;\n    };\n\n    var digits = '0123456789abcdef';\n\n    var floor$2 = Math.floor;\n    var random = Math.random;\n\n    var random_1 = function () {\n        var code = '#';\n        for (var i=0; i<6; i++) {\n            code += digits.charAt(floor$2(random() * 16));\n        }\n        return new Color_1(code, 'hex');\n    };\n\n    var log$1 = Math.log;\n    var pow$7 = Math.pow;\n    var floor$3 = Math.floor;\n    var abs = Math.abs;\n\n\n    var analyze = function (data, key) {\n        if ( key === void 0 ) key=null;\n\n        var r = {\n            min: Number.MAX_VALUE,\n            max: Number.MAX_VALUE*-1,\n            sum: 0,\n            values: [],\n            count: 0\n        };\n        if (type(data) === 'object') {\n            data = Object.values(data);\n        }\n        data.forEach(function (val) {\n            if (key && type(val) === 'object') { val = val[key]; }\n            if (val !== undefined && val !== null && !isNaN(val)) {\n                r.values.push(val);\n                r.sum += val;\n                if (val < r.min) { r.min = val; }\n                if (val > r.max) { r.max = val; }\n                r.count += 1;\n            }\n        });\n\n        r.domain = [r.min, r.max];\n\n        r.limits = function (mode, num) { return limits(r, mode, num); };\n\n        return r;\n    };\n\n\n    var limits = function (data, mode, num) {\n        if ( mode === void 0 ) mode='equal';\n        if ( num === void 0 ) num=7;\n\n        if (type(data) == 'array') {\n            data = analyze(data);\n        }\n        var min = data.min;\n        var max = data.max;\n        var values = data.values.sort(function (a,b) { return a-b; });\n\n        if (num === 1) { return [min,max]; }\n\n        var limits = [];\n\n        if (mode.substr(0,1) === 'c') { // continuous\n            limits.push(min);\n            limits.push(max);\n        }\n\n        if (mode.substr(0,1) === 'e') { // equal interval\n            limits.push(min);\n            for (var i=1; i<num; i++) {\n                limits.push(min+((i/num)*(max-min)));\n            }\n            limits.push(max);\n        }\n\n        else if (mode.substr(0,1) === 'l') { // log scale\n            if (min <= 0) {\n                throw new Error('Logarithmic scales are only possible for values > 0');\n            }\n            var min_log = Math.LOG10E * log$1(min);\n            var max_log = Math.LOG10E * log$1(max);\n            limits.push(min);\n            for (var i$1=1; i$1<num; i$1++) {\n                limits.push(pow$7(10, min_log + ((i$1/num) * (max_log - min_log))));\n            }\n            limits.push(max);\n        }\n\n        else if (mode.substr(0,1) === 'q') { // quantile scale\n            limits.push(min);\n            for (var i$2=1; i$2<num; i$2++) {\n                var p = ((values.length-1) * i$2)/num;\n                var pb = floor$3(p);\n                if (pb === p) {\n                    limits.push(values[pb]);\n                } else { // p > pb\n                    var pr = p - pb;\n                    limits.push((values[pb]*(1-pr)) + (values[pb+1]*pr));\n                }\n            }\n            limits.push(max);\n\n        }\n\n        else if (mode.substr(0,1) === 'k') { // k-means clustering\n            /*\n            implementation based on\n            http://code.google.com/p/figue/source/browse/trunk/figue.js#336\n            simplified for 1-d input values\n            */\n            var cluster;\n            var n = values.length;\n            var assignments = new Array(n);\n            var clusterSizes = new Array(num);\n            var repeat = true;\n            var nb_iters = 0;\n            var centroids = null;\n\n            // get seed values\n            centroids = [];\n            centroids.push(min);\n            for (var i$3=1; i$3<num; i$3++) {\n                centroids.push(min + ((i$3/num) * (max-min)));\n            }\n            centroids.push(max);\n\n            while (repeat) {\n                // assignment step\n                for (var j=0; j<num; j++) {\n                    clusterSizes[j] = 0;\n                }\n                for (var i$4=0; i$4<n; i$4++) {\n                    var value = values[i$4];\n                    var mindist = Number.MAX_VALUE;\n                    var best = (void 0);\n                    for (var j$1=0; j$1<num; j$1++) {\n                        var dist = abs(centroids[j$1]-value);\n                        if (dist < mindist) {\n                            mindist = dist;\n                            best = j$1;\n                        }\n                        clusterSizes[best]++;\n                        assignments[i$4] = best;\n                    }\n                }\n\n                // update centroids step\n                var newCentroids = new Array(num);\n                for (var j$2=0; j$2<num; j$2++) {\n                    newCentroids[j$2] = null;\n                }\n                for (var i$5=0; i$5<n; i$5++) {\n                    cluster = assignments[i$5];\n                    if (newCentroids[cluster] === null) {\n                        newCentroids[cluster] = values[i$5];\n                    } else {\n                        newCentroids[cluster] += values[i$5];\n                    }\n                }\n                for (var j$3=0; j$3<num; j$3++) {\n                    newCentroids[j$3] *= 1/clusterSizes[j$3];\n                }\n\n                // check convergence\n                repeat = false;\n                for (var j$4=0; j$4<num; j$4++) {\n                    if (newCentroids[j$4] !== centroids[j$4]) {\n                        repeat = true;\n                        break;\n                    }\n                }\n\n                centroids = newCentroids;\n                nb_iters++;\n\n                if (nb_iters > 200) {\n                    repeat = false;\n                }\n            }\n\n            // finished k-means clustering\n            // the next part is borrowed from gabrielflor.it\n            var kClusters = {};\n            for (var j$5=0; j$5<num; j$5++) {\n                kClusters[j$5] = [];\n            }\n            for (var i$6=0; i$6<n; i$6++) {\n                cluster = assignments[i$6];\n                kClusters[cluster].push(values[i$6]);\n            }\n            var tmpKMeansBreaks = [];\n            for (var j$6=0; j$6<num; j$6++) {\n                tmpKMeansBreaks.push(kClusters[j$6][0]);\n                tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length-1]);\n            }\n            tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a,b){ return a-b; });\n            limits.push(tmpKMeansBreaks[0]);\n            for (var i$7=1; i$7 < tmpKMeansBreaks.length; i$7+= 2) {\n                var v = tmpKMeansBreaks[i$7];\n                if (!isNaN(v) && (limits.indexOf(v) === -1)) {\n                    limits.push(v);\n                }\n            }\n        }\n        return limits;\n    };\n\n    var analyze_1 = {analyze: analyze, limits: limits};\n\n    var contrast = function (a, b) {\n        // WCAG contrast ratio\n        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\n        a = new Color_1(a);\n        b = new Color_1(b);\n        var l1 = a.luminance();\n        var l2 = b.luminance();\n        return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);\n    };\n\n    var sqrt$4 = Math.sqrt;\n    var atan2$2 = Math.atan2;\n    var abs$1 = Math.abs;\n    var cos$4 = Math.cos;\n    var PI$2 = Math.PI;\n\n    var deltaE = function(a, b, L, C) {\n        if ( L === void 0 ) L=1;\n        if ( C === void 0 ) C=1;\n\n        // Delta E (CMC)\n        // see http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CMC.html\n        a = new Color_1(a);\n        b = new Color_1(b);\n        var ref = Array.from(a.lab());\n        var L1 = ref[0];\n        var a1 = ref[1];\n        var b1 = ref[2];\n        var ref$1 = Array.from(b.lab());\n        var L2 = ref$1[0];\n        var a2 = ref$1[1];\n        var b2 = ref$1[2];\n        var c1 = sqrt$4((a1 * a1) + (b1 * b1));\n        var c2 = sqrt$4((a2 * a2) + (b2 * b2));\n        var sl = L1 < 16.0 ? 0.511 : (0.040975 * L1) / (1.0 + (0.01765 * L1));\n        var sc = ((0.0638 * c1) / (1.0 + (0.0131 * c1))) + 0.638;\n        var h1 = c1 < 0.000001 ? 0.0 : (atan2$2(b1, a1) * 180.0) / PI$2;\n        while (h1 < 0) { h1 += 360; }\n        while (h1 >= 360) { h1 -= 360; }\n        var t = (h1 >= 164.0) && (h1 <= 345.0) ? (0.56 + abs$1(0.2 * cos$4((PI$2 * (h1 + 168.0)) / 180.0))) : (0.36 + abs$1(0.4 * cos$4((PI$2 * (h1 + 35.0)) / 180.0)));\n        var c4 = c1 * c1 * c1 * c1;\n        var f = sqrt$4(c4 / (c4 + 1900.0));\n        var sh = sc * (((f * t) + 1.0) - f);\n        var delL = L1 - L2;\n        var delC = c1 - c2;\n        var delA = a1 - a2;\n        var delB = b1 - b2;\n        var dH2 = ((delA * delA) + (delB * delB)) - (delC * delC);\n        var v1 = delL / (L * sl);\n        var v2 = delC / (C * sc);\n        var v3 = sh;\n        return sqrt$4((v1 * v1) + (v2 * v2) + (dH2 / (v3 * v3)));\n    };\n\n    // simple Euclidean distance\n    var distance = function(a, b, mode) {\n        if ( mode === void 0 ) mode='lab';\n\n        // Delta E (CIE 1976)\n        // see http://www.brucelindbloom.com/index.html?Equations.html\n        a = new Color_1(a);\n        b = new Color_1(b);\n        var l1 = a.get(mode);\n        var l2 = b.get(mode);\n        var sum_sq = 0;\n        for (var i in l1) {\n            var d = (l1[i] || 0) - (l2[i] || 0);\n            sum_sq += d*d;\n        }\n        return Math.sqrt(sum_sq);\n    };\n\n    var valid = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        try {\n            new (Function.prototype.bind.apply( Color_1, [ null ].concat( args) ));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // some pre-defined color scales:\n\n\n\n\n    var scales = {\n    \tcool: function cool() { return scale([chroma_1.hsl(180,1,.9), chroma_1.hsl(250,.7,.4)]) },\n    \thot: function hot() { return scale(['#000','#f00','#ff0','#fff'], [0,.25,.75,1]).mode('rgb') }\n    };\n\n    /**\n        ColorBrewer colors for chroma.js\n\n        Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The\n        Pennsylvania State University.\n\n        Licensed under the Apache License, Version 2.0 (the \"License\");\n        you may not use this file except in compliance with the License.\n        You may obtain a copy of the License at\n        http://www.apache.org/licenses/LICENSE-2.0\n\n        Unless required by applicable law or agreed to in writing, software distributed\n        under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n        CONDITIONS OF ANY KIND, either express or implied. See the License for the\n        specific language governing permissions and limitations under the License.\n    */\n\n    var colorbrewer = {\n        // sequential\n        OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],\n        PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],\n        BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],\n        Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],\n        BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],\n        YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],\n        YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],\n        Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],\n        RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],\n        Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],\n        YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],\n        Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],\n        GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],\n        Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],\n        YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],\n        PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],\n        Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],\n        PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],\n        Viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],\n\n        // diverging\n\n        Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],\n        RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],\n        RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],\n        PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],\n        PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],\n        RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],\n        BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],\n        RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],\n        PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],\n\n        // qualitative\n\n        Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],\n        Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],\n        Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],\n        Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],\n        Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],\n        Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],\n        Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],\n        Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2'],\n    };\n\n    // add lowercase aliases for case-insensitive matches\n    for (var i$1 = 0, list$1 = Object.keys(colorbrewer); i$1 < list$1.length; i$1 += 1) {\n        var key = list$1[i$1];\n\n        colorbrewer[key.toLowerCase()] = colorbrewer[key];\n    }\n\n    var colorbrewer_1 = colorbrewer;\n\n    // feel free to comment out anything to rollup\n    // a smaller chroma.js built\n\n    // io --> convert colors\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    // operators --> modify existing Colors\n\n\n\n\n\n\n\n\n\n\n    // interpolators\n\n\n\n\n\n\n\n\n\n\n    // generators -- > create new colors\n    chroma_1.average = average;\n    chroma_1.bezier = bezier_1;\n    chroma_1.blend = blend_1;\n    chroma_1.cubehelix = cubehelix;\n    chroma_1.mix = chroma_1.interpolate = mix;\n    chroma_1.random = random_1;\n    chroma_1.scale = scale;\n\n    // other utility methods\n    chroma_1.analyze = analyze_1.analyze;\n    chroma_1.contrast = contrast;\n    chroma_1.deltaE = deltaE;\n    chroma_1.distance = distance;\n    chroma_1.limits = analyze_1.limits;\n    chroma_1.valid = valid;\n\n    // scale\n    chroma_1.scales = scales;\n\n    // colors\n    chroma_1.colors = w3cx11_1;\n    chroma_1.brewer = colorbrewer_1;\n\n    var chroma_js = chroma_1;\n\n    return chroma_js;\n\n})));\n","// Top level file is just a mixin of submodules & constants\n'use strict';\n\nvar assign    = require('./lib/utils/common').assign;\n\nvar deflate   = require('./lib/deflate');\nvar inflate   = require('./lib/inflate');\nvar constants = require('./lib/zlib/constants');\n\nvar pako = {};\n\nassign(pako, deflate, inflate, constants);\n\nmodule.exports = pako;\n","'use strict';\n\n\nvar zlib_deflate = require('./zlib/deflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n","'use strict';\n\n\nvar zlib_inflate = require('./zlib/inflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar c            = require('./zlib/constants');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\nvar GZheader     = require('./zlib/gzheader');\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== c.Z_OK) {\n        throw new Error(msg[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === 'string') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 aligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n","'use strict';\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\nfunction _has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n","// String encode/decode helpers\n'use strict';\n\n\nvar utils = require('./common');\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n","'use strict';\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n","'use strict';\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = require('../utils/common');\nvar trees   = require('./trees');\nvar adler32 = require('./adler32');\nvar crc32   = require('./crc32');\nvar msg     = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils         = require('../utils/common');\nvar adler32       = require('./adler32');\nvar crc32         = require('./crc32');\nvar inflate_fast  = require('./inffast');\nvar inflate_table = require('./inftrees');\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction zswap32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        state.flags = 0;           /* expect zlib header */\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        else if (len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n        state.dmax = 1 << len;\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if (state.flags & 0x0200) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Array(state.head.extra_len);\n              }\n              utils.arraySet(\n                state.head.extra,\n                input,\n                next,\n                // extra field is limited to 65536 bytes\n                // - no need for additional size check\n                copy,\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if (state.flags & 0x0200) {\n              state.check = crc32(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          utils.arraySet(output, input, next, copy, put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inflate_fast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if (_out) {\n            strm.adler = state.check =\n                /*UPDATE(state.check, put - _out, _out);*/\n                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var state;\n  var dictid;\n  var ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = require('../utils/common');\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code's length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\nvar utils = require('../utils/common');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n","var vm = require('vm')\n\nmodule.exports = function safeEval (code, context, opts) {\n  var sandbox = {}\n  var resultKey = 'SAFE_EVAL_' + Math.floor(Math.random() * 1000000)\n  sandbox[resultKey] = {}\n  var clearContext = `\n    (function(){\n      Function = undefined;\n      const keys = Object.getOwnPropertyNames(this).concat(['constructor']);\n      keys.forEach((key) => {\n        const item = this[key];\n        if(!item || typeof item.constructor !== 'function') return;\n        this[key].constructor = undefined;\n      });\n    })();\n  `\n  code = clearContext + resultKey + '=' + code\n  if (context) {\n    Object.keys(context).forEach(function (key) {\n      sandbox[key] = context[key]\n    })\n  }\n  vm.runInNewContext(code, sandbox, opts)\n  return sandbox[resultKey]\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\r\n* vkBeautify - javascript plugin to pretty-print or minify text in XML, JSON, CSS and SQL formats.\r\n*\r\n* Copyright (c) 2012 Vadim Kiryukhin\r\n* vkiryukhin @ gmail.com\r\n* http://www.eslinstructor.net/vkbeautify/\r\n*\r\n* Dual licensed under the MIT and GPL licenses:\r\n*   http://www.opensource.org/licenses/mit-license.php\r\n*   http://www.gnu.org/licenses/gpl.html\r\n*\r\n*   Pretty print\r\n*\r\n*        vkbeautify.xml(text [,indent_pattern]);\r\n*        vkbeautify.json(text [,indent_pattern]);\r\n*        vkbeautify.css(text [,indent_pattern]);\r\n*        vkbeautify.sql(text [,indent_pattern]);\r\n*\r\n*        @text - String; text to beatufy;\r\n*        @indent_pattern - Integer | String;\r\n*                Integer:  number of white spaces;\r\n*                String:   character string to visualize indentation ( can also be a set of white spaces )\r\n*   Minify\r\n*\r\n*        vkbeautify.xmlmin(text [,preserve_comments]);\r\n*        vkbeautify.jsonmin(text);\r\n*        vkbeautify.cssmin(text [,preserve_comments]);\r\n*        vkbeautify.sqlmin(text);\r\n*\r\n*        @text - String; text to minify;\r\n*        @preserve_comments - Bool; [optional];\r\n*                Set this flag to true to prevent removing comments from @text ( minxml and mincss functions only. )\r\n*\r\n*   Examples:\r\n*        vkbeautify.xml(text); // pretty print XML\r\n*        vkbeautify.json(text, 4 ); // pretty print JSON\r\n*        vkbeautify.css(text, '. . . .'); // pretty print CSS\r\n*        vkbeautify.sql(text, '----'); // pretty print SQL\r\n*\r\n*        vkbeautify.xmlmin(text, true);// minify XML, preserve comments\r\n*        vkbeautify.jsonmin(text);// minify JSON\r\n*        vkbeautify.cssmin(text);// minify CSS, remove comments ( default )\r\n*        vkbeautify.sqlmin(text);// minify SQL\r\n*\r\n*/\r\nfunction createShiftArr(step) {\r\n\r\n\tvar space = '    ';\r\n\r\n\tif ( isNaN(parseInt(step)) ) {  // argument is string\r\n\t\tspace = step;\r\n\t} else { // argument is integer\r\n\t\tswitch(step) {\r\n\t\t\tcase 1: space = ' '; break;\r\n\t\t\tcase 2: space = '  '; break;\r\n\t\t\tcase 3: space = '   '; break;\r\n\t\t\tcase 4: space = '    '; break;\r\n\t\t\tcase 5: space = '     '; break;\r\n\t\t\tcase 6: space = '      '; break;\r\n\t\t\tcase 7: space = '       '; break;\r\n\t\t\tcase 8: space = '        '; break;\r\n\t\t\tcase 9: space = '         '; break;\r\n\t\t\tcase 10: space = '          '; break;\r\n\t\t\tcase 11: space = '           '; break;\r\n\t\t\tcase 12: space = '            '; break;\r\n\t\t}\r\n\t}\r\n\r\n\tvar shift = ['\\n']; // array of shifts\r\n\tfor(var ix=0;ix<100;ix++) {\r\n\t\tshift.push(shift[ix]+space);\r\n\t}\r\n\treturn shift;\r\n}\r\n\r\nfunction vkbeautify(){\r\n\tthis.step = '    '; // 4 spaces\r\n\tthis.shift = createShiftArr(this.step);\r\n};\r\n\r\nvkbeautify.prototype.xml = function(text,step) {\r\n\r\n\tvar ar = text.replace(/>\\s{0,}</g,\"><\")\r\n\t\t\t\t .replace(/</g,\"~::~<\")\r\n\t\t\t\t .replace(/\\s*xmlns\\:/g,\"~::~xmlns:\")\r\n\t\t\t\t .replace(/\\s*xmlns\\=/g,\"~::~xmlns=\")\r\n\t\t\t\t .split('~::~'),\r\n\t\tlen = ar.length,\r\n\t\tinComment = false,\r\n\t\tdeep = 0,\r\n\t\tstr = '',\r\n\t\tix = 0,\r\n\t\tshift = step ? createShiftArr(step) : this.shift;\r\n\r\n\t\tfor(ix=0;ix<len;ix++) {\r\n\t\t\t// start comment or <![CDATA[...]]> or <!DOCTYPE //\r\n\t\t\tif(ar[ix].search(/<!/) > -1) {\r\n\t\t\t\tstr += shift[deep]+ar[ix];\r\n\t\t\t\tinComment = true;\r\n\t\t\t\t// end comment  or <![CDATA[...]]> //\r\n\t\t\t\tif(ar[ix].search(/-->/) > -1 || ar[ix].search(/\\]>/) > -1 || ar[ix].search(/!DOCTYPE/) > -1 ) {\r\n\t\t\t\t\tinComment = false;\r\n\t\t\t\t}\r\n\t\t\t} else\r\n\t\t\t// end comment  or <![CDATA[...]]> //\r\n\t\t\tif(ar[ix].search(/-->/) > -1 || ar[ix].search(/\\]>/) > -1) {\r\n\t\t\t\tstr += ar[ix];\r\n\t\t\t\tinComment = false;\r\n\t\t\t} else\r\n\t\t\t// <elm></elm> //\r\n\t\t\tif( /^<\\w/.exec(ar[ix-1]) && /^<\\/\\w/.exec(ar[ix]) &&\r\n\t\t\t\t/^<[\\w:\\-\\.\\,]+/.exec(ar[ix-1]) == /^<\\/[\\w:\\-\\.\\,]+/.exec(ar[ix])[0].replace('/','')) {\r\n\t\t\t\tstr += ar[ix];\r\n\t\t\t\tif(!inComment) deep--;\r\n\t\t\t} else\r\n\t\t\t // <elm> //\r\n\t\t\tif(ar[ix].search(/<\\w/) > -1 && ar[ix].search(/<\\//) == -1 && ar[ix].search(/\\/>/) == -1 ) {\r\n\t\t\t\tstr = !inComment ? str += shift[deep++]+ar[ix] : str += ar[ix];\r\n\t\t\t} else\r\n\t\t\t // <elm>...</elm> //\r\n\t\t\tif(ar[ix].search(/<\\w/) > -1 && ar[ix].search(/<\\//) > -1) {\r\n\t\t\t\tstr = !inComment ? str += shift[deep]+ar[ix] : str += ar[ix];\r\n\t\t\t} else\r\n\t\t\t// </elm> //\r\n\t\t\tif(ar[ix].search(/<\\//) > -1) {\r\n\t\t\t\tstr = !inComment ? str += shift[--deep]+ar[ix] : str += ar[ix];\r\n\t\t\t} else\r\n\t\t\t// <elm/> //\r\n\t\t\tif(ar[ix].search(/\\/>/) > -1 ) {\r\n\t\t\t\tstr = !inComment ? str += shift[deep]+ar[ix] : str += ar[ix];\r\n\t\t\t} else\r\n\t\t\t// <? xml ... ?> //\r\n\t\t\tif(ar[ix].search(/<\\?/) > -1) {\r\n\t\t\t\tstr += shift[deep]+ar[ix];\r\n\t\t\t} else\r\n\t\t\t// xmlns //\r\n\t\t\tif( ar[ix].search(/xmlns\\:/) > -1  || ar[ix].search(/xmlns\\=/) > -1) {\r\n\t\t\t\tstr += shift[deep]+ar[ix];\r\n\t\t\t}\r\n\r\n\t\t\telse {\r\n\t\t\t\tstr += ar[ix];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\treturn  (str[0] == '\\n') ? str.slice(1) : str;\r\n}\r\n\r\nvkbeautify.prototype.json = function(text,step) {\r\n\r\n\tvar step = step ? step : this.step;\r\n\r\n\tif (typeof JSON === 'undefined' ) return text;\r\n\r\n\tif ( typeof text === \"string\" ) return JSON.stringify(JSON.parse(text), null, step);\r\n\tif ( typeof text === \"object\" ) return JSON.stringify(text, null, step);\r\n\r\n\treturn text; // text is not string nor object\r\n}\r\n\r\nvkbeautify.prototype.css = function(text, step) {\r\n\r\n\tvar ar = text.replace(/\\s{1,}/g,' ')\r\n\t\t\t\t.replace(/\\{/g,\"{~::~\")\r\n\t\t\t\t.replace(/\\}/g,\"~::~}~::~\")\r\n\t\t\t\t.replace(/\\;/g,\";~::~\")\r\n\t\t\t\t.replace(/\\/\\*/g,\"~::~/*\")\r\n\t\t\t\t.replace(/\\*\\//g,\"*/~::~\")\r\n\t\t\t\t.replace(/~::~\\s{0,}~::~/g,\"~::~\")\r\n\t\t\t\t.split('~::~'),\r\n\t\tlen = ar.length,\r\n\t\tdeep = 0,\r\n\t\tstr = '',\r\n\t\tix = 0,\r\n\t\tshift = step ? createShiftArr(step) : this.shift;\r\n\r\n\t\tfor(ix=0;ix<len;ix++) {\r\n\r\n\t\t\tif( /\\{/.exec(ar[ix]))  {\r\n\t\t\t\tstr += shift[deep++]+ar[ix];\r\n\t\t\t} else\r\n\t\t\tif( /\\}/.exec(ar[ix]))  {\r\n\t\t\t\tstr += shift[--deep]+ar[ix];\r\n\t\t\t} else\r\n\t\t\tif( /\\*\\\\/.exec(ar[ix]))  {\r\n\t\t\t\tstr += shift[deep]+ar[ix];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tstr += shift[deep]+ar[ix];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn str.replace(/^\\n{1,}/,'');\r\n}\r\n\r\n//----------------------------------------------------------------------------\r\n\r\nfunction isSubquery(str, parenthesisLevel) {\r\n\treturn  parenthesisLevel - (str.replace(/\\(/g,'').length - str.replace(/\\)/g,'').length )\r\n}\r\n\r\nfunction split_sql(str, tab) {\r\n\r\n\treturn str.replace(/\\s{1,}/g,\" \")\r\n\r\n\t\t\t\t.replace(/ AND /ig,\"~::~\"+tab+tab+\"AND \")\r\n\t\t\t\t.replace(/ BETWEEN /ig,\"~::~\"+tab+\"BETWEEN \")\r\n\t\t\t\t.replace(/ CASE /ig,\"~::~\"+tab+\"CASE \")\r\n\t\t\t\t.replace(/ ELSE /ig,\"~::~\"+tab+\"ELSE \")\r\n\t\t\t\t.replace(/ END /ig,\"~::~\"+tab+\"END \")\r\n\t\t\t\t.replace(/ FROM /ig,\"~::~FROM \")\r\n\t\t\t\t.replace(/ GROUP\\s{1,}BY/ig,\"~::~GROUP BY \")\r\n\t\t\t\t.replace(/ HAVING /ig,\"~::~HAVING \")\r\n\t\t\t\t//.replace(/ SET /ig,\" SET~::~\")\r\n\t\t\t\t.replace(/ IN /ig,\" IN \")\r\n\r\n\t\t\t\t.replace(/ JOIN /ig,\"~::~JOIN \")\r\n\t\t\t\t.replace(/ CROSS~::~{1,}JOIN /ig,\"~::~CROSS JOIN \")\r\n\t\t\t\t.replace(/ INNER~::~{1,}JOIN /ig,\"~::~INNER JOIN \")\r\n\t\t\t\t.replace(/ LEFT~::~{1,}JOIN /ig,\"~::~LEFT JOIN \")\r\n\t\t\t\t.replace(/ RIGHT~::~{1,}JOIN /ig,\"~::~RIGHT JOIN \")\r\n\r\n\t\t\t\t.replace(/ ON /ig,\"~::~\"+tab+\"ON \")\r\n\t\t\t\t.replace(/ OR /ig,\"~::~\"+tab+tab+\"OR \")\r\n\t\t\t\t.replace(/ ORDER\\s{1,}BY/ig,\"~::~ORDER BY \")\r\n\t\t\t\t.replace(/ OVER /ig,\"~::~\"+tab+\"OVER \")\r\n\r\n\t\t\t\t.replace(/\\(\\s{0,}SELECT /ig,\"~::~(SELECT \")\r\n\t\t\t\t.replace(/\\)\\s{0,}SELECT /ig,\")~::~SELECT \")\r\n\r\n\t\t\t\t.replace(/ THEN /ig,\" THEN~::~\"+tab+\"\")\r\n\t\t\t\t.replace(/ UNION /ig,\"~::~UNION~::~\")\r\n\t\t\t\t.replace(/ USING /ig,\"~::~USING \")\r\n\t\t\t\t.replace(/ WHEN /ig,\"~::~\"+tab+\"WHEN \")\r\n\t\t\t\t.replace(/ WHERE /ig,\"~::~WHERE \")\r\n\t\t\t\t.replace(/ WITH /ig,\"~::~WITH \")\r\n\r\n\t\t\t\t//.replace(/\\,\\s{0,}\\(/ig,\",~::~( \")\r\n\t\t\t\t//.replace(/\\,/ig,\",~::~\"+tab+tab+\"\")\r\n\r\n\t\t\t\t.replace(/ ALL /ig,\" ALL \")\r\n\t\t\t\t.replace(/ AS /ig,\" AS \")\r\n\t\t\t\t.replace(/ ASC /ig,\" ASC \")\r\n\t\t\t\t.replace(/ DESC /ig,\" DESC \")\r\n\t\t\t\t.replace(/ DISTINCT /ig,\" DISTINCT \")\r\n\t\t\t\t.replace(/ EXISTS /ig,\" EXISTS \")\r\n\t\t\t\t.replace(/ NOT /ig,\" NOT \")\r\n\t\t\t\t.replace(/ NULL /ig,\" NULL \")\r\n\t\t\t\t.replace(/ LIKE /ig,\" LIKE \")\r\n\t\t\t\t.replace(/\\s{0,}SELECT /ig,\"SELECT \")\r\n\t\t\t\t.replace(/\\s{0,}UPDATE /ig,\"UPDATE \")\r\n\t\t\t\t.replace(/ SET /ig,\" SET \")\r\n\r\n\t\t\t\t.replace(/~::~{1,}/g,\"~::~\")\r\n\t\t\t\t.split('~::~');\r\n}\r\n\r\nvkbeautify.prototype.sql = function(text,step) {\r\n\r\n\tvar ar_by_quote = text.replace(/\\s{1,}/g,\" \")\r\n\t\t\t\t\t\t\t.replace(/\\'/ig,\"~::~\\'\")\r\n\t\t\t\t\t\t\t.split('~::~'),\r\n\t\tlen = ar_by_quote.length,\r\n\t\tar = [],\r\n\t\tdeep = 0,\r\n\t\ttab = this.step,//+this.step,\r\n\t\tinComment = true,\r\n\t\tinQuote = false,\r\n\t\tparenthesisLevel = 0,\r\n\t\tstr = '',\r\n\t\tix = 0,\r\n\t\tshift = step ? createShiftArr(step) : this.shift;;\r\n\r\n\t\tfor(ix=0;ix<len;ix++) {\r\n\t\t\tif(ix%2) {\r\n\t\t\t\tar = ar.concat(ar_by_quote[ix]);\r\n\t\t\t} else {\r\n\t\t\t\tar = ar.concat(split_sql(ar_by_quote[ix], tab) );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlen = ar.length;\r\n\t\tfor(ix=0;ix<len;ix++) {\r\n\r\n\t\t\tparenthesisLevel = isSubquery(ar[ix], parenthesisLevel);\r\n\r\n\t\t\tif( /\\s{0,}\\s{0,}SELECT\\s{0,}/.exec(ar[ix]))  {\r\n\t\t\t\tar[ix] = ar[ix].replace(/\\,/g,\",\\n\"+tab+tab+\"\")\r\n\t\t\t}\r\n\r\n\t\t\tif( /\\s{0,}\\s{0,}SET\\s{0,}/.exec(ar[ix]))  {\r\n\t\t\t\tar[ix] = ar[ix].replace(/\\,/g,\",\\n\"+tab+tab+\"\")\r\n\t\t\t}\r\n\r\n\t\t\tif( /\\s{0,}\\(\\s{0,}SELECT\\s{0,}/.exec(ar[ix]))  {\r\n\t\t\t\tdeep++;\r\n\t\t\t\tstr += shift[deep]+ar[ix];\r\n\t\t\t} else\r\n\t\t\tif( /\\'/.exec(ar[ix]) )  {\r\n\t\t\t\tif(parenthesisLevel<1 && deep) {\r\n\t\t\t\t\tdeep--;\r\n\t\t\t\t}\r\n\t\t\t\tstr += ar[ix];\r\n\t\t\t}\r\n\t\t\telse  {\r\n\t\t\t\tstr += shift[deep]+ar[ix];\r\n\t\t\t\tif(parenthesisLevel<1 && deep) {\r\n\t\t\t\t\tdeep--;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar junk = 0;\r\n\t\t}\r\n\r\n\t\tstr = str.replace(/^\\n{1,}/,'').replace(/\\n{1,}/g,\"\\n\");\r\n\t\treturn str;\r\n}\r\n\r\n\r\nvkbeautify.prototype.xmlmin = function(text, preserveComments) {\r\n\r\n\tvar str = preserveComments ? text\r\n\t\t\t\t\t\t\t   : text.replace(/\\<![ \\r\\n\\t]*(--([^\\-]|[\\r\\n]|-[^\\-])*--[ \\r\\n\\t]*)\\>/g,\"\")\r\n\t\t\t\t\t\t\t\t\t .replace(/[ \\r\\n\\t]{1,}xmlns/g, ' xmlns');\r\n\treturn  str.replace(/>\\s{0,}</g,\"><\");\r\n}\r\n\r\nvkbeautify.prototype.jsonmin = function(text) {\r\n\r\n\tif (typeof JSON === 'undefined' ) return text;\r\n\r\n\treturn JSON.stringify(JSON.parse(text), null, 0);\r\n\r\n}\r\n\r\nvkbeautify.prototype.cssmin = function(text, preserveComments) {\r\n\r\n\tvar str = preserveComments ? text\r\n\t\t\t\t\t\t\t   : text.replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+\\//g,\"\") ;\r\n\r\n\treturn str.replace(/\\s{1,}/g,' ')\r\n\t\t\t  .replace(/\\{\\s{1,}/g,\"{\")\r\n\t\t\t  .replace(/\\}\\s{1,}/g,\"}\")\r\n\t\t\t  .replace(/\\;\\s{1,}/g,\";\")\r\n\t\t\t  .replace(/\\/\\*\\s{1,}/g,\"/*\")\r\n\t\t\t  .replace(/\\*\\/\\s{1,}/g,\"*/\");\r\n}\r\n\r\nvkbeautify.prototype.sqlmin = function(text) {\r\n\treturn text.replace(/\\s{1,}/g,\" \").replace(/\\s{1,}\\(/,\"(\").replace(/\\s{1,}\\)/,\")\");\r\n}\r\n\r\nmodule.exports = new vkbeautify();\r\n","var indexOf = function (xs, item) {\n    if (xs.indexOf) return xs.indexOf(item);\n    else for (var i = 0; i < xs.length; i++) {\n        if (xs[i] === item) return i;\n    }\n    return -1;\n};\nvar Object_keys = function (obj) {\n    if (Object.keys) return Object.keys(obj)\n    else {\n        var res = [];\n        for (var key in obj) res.push(key)\n        return res;\n    }\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nvar defineProp = (function() {\n    try {\n        Object.defineProperty({}, '_', {});\n        return function(obj, name, value) {\n            Object.defineProperty(obj, name, {\n                writable: true,\n                enumerable: false,\n                configurable: true,\n                value: value\n            })\n        };\n    } catch(e) {\n        return function(obj, name, value) {\n            obj[name] = value;\n        };\n    }\n}());\n\nvar globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',\n'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',\n'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',\n'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',\n'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];\n\nfunction Context() {}\nContext.prototype = {};\n\nvar Script = exports.Script = function NodeScript (code) {\n    if (!(this instanceof Script)) return new Script(code);\n    this.code = code;\n};\n\nScript.prototype.runInContext = function (context) {\n    if (!(context instanceof Context)) {\n        throw new TypeError(\"needs a 'context' argument.\");\n    }\n    \n    var iframe = document.createElement('iframe');\n    if (!iframe.style) iframe.style = {};\n    iframe.style.display = 'none';\n    \n    document.body.appendChild(iframe);\n    \n    var win = iframe.contentWindow;\n    var wEval = win.eval, wExecScript = win.execScript;\n\n    if (!wEval && wExecScript) {\n        // win.eval() magically appears when this is called in IE:\n        wExecScript.call(win, 'null');\n        wEval = win.eval;\n    }\n    \n    forEach(Object_keys(context), function (key) {\n        win[key] = context[key];\n    });\n    forEach(globals, function (key) {\n        if (context[key]) {\n            win[key] = context[key];\n        }\n    });\n    \n    var winKeys = Object_keys(win);\n\n    var res = wEval.call(win, this.code);\n    \n    forEach(Object_keys(win), function (key) {\n        // Avoid copying circular objects like `top` and `window` by only\n        // updating existing context properties or new properties in the `win`\n        // that was only introduced after the eval.\n        if (key in context || indexOf(winKeys, key) === -1) {\n            context[key] = win[key];\n        }\n    });\n\n    forEach(globals, function (key) {\n        if (!(key in context)) {\n            defineProp(context, key, win[key]);\n        }\n    });\n    \n    document.body.removeChild(iframe);\n    \n    return res;\n};\n\nScript.prototype.runInThisContext = function () {\n    return eval(this.code); // maybe...\n};\n\nScript.prototype.runInNewContext = function (context) {\n    var ctx = Script.createContext(context);\n    var res = this.runInContext(ctx);\n\n    if (context) {\n        forEach(Object_keys(ctx), function (key) {\n            context[key] = ctx[key];\n        });\n    }\n\n    return res;\n};\n\nforEach(Object_keys(Script.prototype), function (name) {\n    exports[name] = Script[name] = function (code) {\n        var s = Script(code);\n        return s[name].apply(s, [].slice.call(arguments, 1));\n    };\n});\n\nexports.isContext = function (context) {\n    return context instanceof Context;\n};\n\nexports.createScript = function (code) {\n    return exports.Script(code);\n};\n\nexports.createContext = Script.createContext = function (context) {\n    var copy = new Context();\n    if(typeof context === 'object') {\n        forEach(Object_keys(context), function (key) {\n            copy[key] = context[key];\n        });\n    }\n    return copy;\n};\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","module.exports = {\n  executeLayout(graph, exec, animate, post) {\n    if (graph.isEnabled()) {\n      graph.getModel().beginUpdate();\n      try {\n        exec();\n      } catch (e) {\n        throw e;\n      } finally {\n        graph.getModel().endUpdate();\n        if (post != null) {\n          post();\n        }\n      }\n    }\n  },\n  executeLayoutList(graph, layoutList, done) {\n    var cells = graph.getSelectionCells();\n\n    for (var i = 0; i < layoutList.length; i++) {\n      var layout = new window[layoutList[i].layout](graph);\n\n      if (layoutList[i].config != null) {\n        for (var key in layoutList[i].config) {\n          layout[key] = layoutList[i].config[key];\n        }\n      }\n\n      this.executeLayout(\n        graph,\n        function() {\n          layout.execute(graph.getDefaultParent(), cells.length === 0 ? null : cells);\n        },\n        i === layoutList.length - 1,\n        done\n      );\n    }\n  },\n  csvToArray(text) {\n    var re_valid = /^\\s*(?:'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|[^,'\"\\s\\\\]*(?:\\s+[^,'\"\\s\\\\]+)*)\\s*(?:,\\s*(?:'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|[^,'\"\\s\\\\]*(?:\\s+[^,'\"\\s\\\\]+)*)\\s*)*$/;\n    var re_value = /(?!\\s*$)\\s*(?:'([^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*)'|\"([^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*)\"|([^,'\"\\s\\\\]*(?:\\s+[^,'\"\\s\\\\]+)*))\\s*(?:,|$)/g;\n    // Return NULL if input string is not well formed CSV string.\n    if (!re_valid.test(text)) {\n      return null;\n    }\n    var a = []; // Initialize array to receive values.\n    text.replace(\n      re_value, // \"Walk\" the string using replace with callback.\n      function(m0, m1, m2, m3) {\n        // Remove backslash from \\' in single quoted values.\n        if (m1 !== undefined) {\n          a.push(m1.replace(/\\\\'/g, \"'\"));\n        }\n        // Remove backslash from \\\" in double quoted values.\n        else if (m2 !== undefined) {\n          a.push(m2.replace(/\\\\\"/g, '\"'));\n        } else if (m3 !== undefined) {\n          a.push(m3);\n        }\n        return ''; // Return empty string.\n      }\n    );\n    // Handle special case of empty last value.\n    if (/,\\s*$/.test(text)) {\n      a.push('');\n    }\n    return a;\n  },\n  importCsv(graph, text) {\n    try {\n      var lines = text.split('\\n');\n      var allCells = [];\n      var cells = [];\n      var dups = {};\n\n      if (lines.length > 0) {\n        // Internal lookup table\n        var lookups = {};\n\n        // Default values\n        var style = null;\n        var styles = null;\n        var stylename = null;\n        var labelname = null;\n        var labels = null;\n        var parentstyle = null;\n        var identity = null;\n        var parent = null;\n        var namespace = '';\n        var width = 'auto';\n        var height = 'auto';\n        var left = null;\n        var top = null;\n        var edgespacing = 40;\n        var nodespacing = 40;\n        var levelspacing = 100;\n        var padding = 0;\n        var view = graph.view;\n        var bds = graph.getGraphBounds();\n\n        // Delayed after optional layout\n        var afterInsert = function() {\n          // graph.setSelectionCells(select);\n          // graph.scrollCellToVisible(graph.getSelectionCell());\n        };\n\n        // Computes unscaled, untranslated graph bounds\n        var pt = graph.getFreeInsertPoint();\n        var x0 = pt.x;\n        var y0 = pt.y;\n        var y = y0;\n\n        // Default label value depends on column names\n        var label = null;\n\n        // Default layout to run.\n        var layout = 'auto';\n\n        // Name of the attribute that contains the parent reference\n        parent = null;\n\n        // Name of the attribute that contains the references for creating edges\n        var edges = [];\n\n        // Name of the column for hyperlinks\n        var link = null;\n\n        // String array of names to remove from metadata\n        var ignore = null;\n\n        // Read processing instructions first\n        var index = 0;\n\n        while (index < lines.length && lines[index].charAt(0) === '#') {\n          text = lines[index];\n          index++;\n\n          while (index < lines.length && text.charAt(text.length - 1) === '\\\\' && lines[index].charAt(0) === '#') {\n            text = text.substring(0, text.length - 1) + mxUtils.trim(lines[index].substring(1));\n            index++;\n          }\n\n          if (text.charAt(1) !== '#') {\n            // Processing instruction\n            var idx = text.indexOf(':');\n\n            if (idx > 0) {\n              var key = mxUtils.trim(text.substring(1, idx));\n              var value = mxUtils.trim(text.substring(idx + 1));\n\n              if (key === 'label') {\n                label = graph.sanitizeHtml(value);\n              } else if (key === 'labelname' && value.length > 0 && value !== '-') {\n                labelname = value;\n              } else if (key === 'labels' && value.length > 0 && value !== '-') {\n                labels = JSON.parse(value);\n              } else if (key === 'style') {\n                style = value;\n              } else if (key === 'parentstyle') {\n                parentstyle = value;\n              } else if (key === 'stylename' && value.length > 0 && value !== '-') {\n                stylename = value;\n              } else if (key === 'styles' && value.length > 0 && value !== '-') {\n                styles = JSON.parse(value);\n              } else if (key === 'identity' && value.length > 0 && value !== '-') {\n                identity = value;\n              } else if (key === 'parent' && value.length > 0 && value !== '-') {\n                parent = value;\n              } else if (key === 'namespace' && value.length > 0 && value !== '-') {\n                namespace = value;\n              } else if (key === 'width') {\n                width = value;\n              } else if (key === 'height') {\n                height = value;\n              } else if (key === 'left' && value.length > 0) {\n                left = value;\n              } else if (key === 'top' && value.length > 0) {\n                top = value;\n              } else if (key === 'ignore') {\n                ignore = value.split(',');\n              } else if (key === 'connect') {\n                edges.push(JSON.parse(value));\n              } else if (key === 'link') {\n                link = value;\n              } else if (key === 'padding') {\n                padding = parseFloat(value);\n              } else if (key === 'edgespacing') {\n                edgespacing = parseFloat(value);\n              } else if (key === 'nodespacing') {\n                nodespacing = parseFloat(value);\n              } else if (key === 'levelspacing') {\n                levelspacing = parseFloat(value);\n              } else if (key === 'layout') {\n                layout = value;\n              }\n            }\n          }\n        }\n\n        if (lines[index] == null) {\n          throw new Error(mxResources.get('invalidOrMissingFile'));\n        }\n\n        // Converts identity and parent to index and validates XML attribute names\n        var keys = this.csvToArray(lines[index]);\n        var identityIndex = null;\n        var parentIndex = null;\n        var attribs = [];\n\n        for (var i = 0; i < keys.length; i++) {\n          if (identity === keys[i]) {\n            identityIndex = i;\n          }\n\n          if (parent === keys[i]) {\n            parentIndex = i;\n          }\n\n          attribs.push(\n            mxUtils\n              .trim(keys[i])\n              .replace(/[^a-z0-9]+/gi, '_')\n              .replace(/^\\d+/, '')\n              .replace(/_+$/, '')\n          );\n        }\n\n        if (label == null) {\n          label = '%' + attribs[0] + '%';\n        }\n\n        if (edges != null) {\n          for (var e = 0; e < edges.length; e++) {\n            if (lookups[edges[e].to] == null) {\n              lookups[edges[e].to] = {};\n            }\n          }\n        }\n\n        // Parse and validate input\n        var arrays = [];\n\n        for (let i = index + 1; i < lines.length; i++) {\n          let values = this.csvToArray(lines[i]);\n\n          if (values == null) {\n            var short = lines[i].length > 40 ? lines[i].substring(0, 40) + '...' : lines[i];\n\n            throw new Error(short + ' (' + i + '):\\n' + mxResources.get('containsValidationErrors'));\n          } else if (values.length > 0) {\n            arrays.push(values);\n          }\n        }\n\n        graph.model.beginUpdate();\n        try {\n          for (let i = 0; i < arrays.length; i++) {\n            let values = arrays[i];\n            var cell = null;\n            var id = identityIndex != null ? namespace + values[identityIndex] : null;\n\n            if (id != null) {\n              cell = graph.model.getCell(id);\n            }\n\n            var exists = cell != null;\n            var newCell = new mxCell(label, new mxGeometry(x0, y, 0, 0), style || 'whiteSpace=wrap;html=1;');\n            newCell.vertex = true;\n            newCell.id = id;\n\n            for (var j = 0; j < values.length; j++) {\n              graph.setAttributeForCell(newCell, attribs[j], values[j]);\n            }\n\n            if (labelname != null && labels != null) {\n              var tempLabel = labels[newCell.getAttribute(labelname)];\n\n              if (tempLabel != null) {\n                graph.labelChanged(newCell, tempLabel);\n              }\n            }\n\n            if (stylename != null && styles != null) {\n              var tempStyle = styles[newCell.getAttribute(stylename)];\n\n              if (tempStyle != null) {\n                newCell.style = tempStyle;\n              }\n            }\n\n            graph.setAttributeForCell(newCell, 'placeholders', '1');\n            newCell.style = graph.replacePlaceholders(newCell, newCell.style);\n\n            if (exists) {\n              graph.model.setGeometry(cell, newCell.geometry);\n              graph.model.setStyle(cell, newCell.style);\n\n              if (mxUtils.indexOf(cells, cell) < 0) {\n                cells.push(cell);\n              }\n            }\n\n            cell = newCell;\n\n            if (!exists) {\n              for (let e = 0; e < edges.length; e++) {\n                lookups[edges[e].to][cell.getAttribute(edges[e].to)] = cell;\n              }\n            }\n\n            if (link != null && link !== 'link') {\n              graph.setLinkForCell(cell, cell.getAttribute(link));\n\n              // Removes attribute\n              graph.setAttributeForCell(cell, link, null);\n            }\n\n            // Sets the size\n            graph.fireEvent(new mxEventObject('cellsInserted', 'cells', [cell]));\n            var size = graph.getPreferredSizeForCell(cell);\n\n            if (cell.vertex) {\n              if (left != null && cell.getAttribute(left) != null) {\n                cell.geometry.x = x0 + parseFloat(cell.getAttribute(left));\n              }\n\n              if (top != null && cell.getAttribute(top) != null) {\n                cell.geometry.y = y0 + parseFloat(cell.getAttribute(top));\n              }\n\n              if (width.charAt(0) === '@' && cell.getAttribute(width.substring(1)) != null) {\n                cell.geometry.width = parseFloat(cell.getAttribute(width.substring(1)));\n              } else {\n                cell.geometry.width = width === 'auto' ? size.width + padding : parseFloat(width);\n              }\n\n              if (height.charAt(0) === '@' && cell.getAttribute(height.substring(1)) != null) {\n                cell.geometry.height = parseFloat(cell.getAttribute(height.substring(1)));\n              } else {\n                cell.geometry.height = height === 'auto' ? size.height + padding : parseFloat(height);\n              }\n\n              y += cell.geometry.height + nodespacing;\n            }\n\n            if (!exists) {\n              parent = parentIndex != null ? graph.model.getCell(namespace + values[parentIndex]) : null;\n              allCells.push(cell);\n\n              if (parent != null) {\n                parent.style = graph.replacePlaceholders(parent, parentstyle);\n                graph.addCell(cell, parent);\n              } else {\n                cells.push(graph.addCell(cell));\n              }\n            } else {\n              if (dups[id] == null) {\n                dups[id] = [];\n              }\n\n              dups[id].push(cell);\n            }\n          }\n\n          var roots = cells.slice();\n          var select = cells.slice();\n\n          for (let e = 0; e < edges.length; e++) {\n            var edge = edges[e];\n\n            for (let i = 0; i < allCells.length; i++) {\n              cell = allCells[i];\n\n              var insertEdge = mxUtils.bind(this, function(realCell, dataCell, edge) {\n                var tmp = dataCell.getAttribute(edge.from);\n\n                if (tmp != null) {\n                  // Removes attribute\n                  graph.setAttributeForCell(dataCell, edge.from, null);\n\n                  if (tmp !== '') {\n                    var refs = tmp.split(',');\n\n                    for (var j = 0; j < refs.length; j++) {\n                      var ref = lookups[edge.to][refs[j]];\n\n                      if (ref != null) {\n                        var label = edge.label;\n\n                        if (edge.fromlabel != null) {\n                          label = (dataCell.getAttribute(edge.fromlabel) || '') + (label || '');\n                        }\n\n                        if (edge.tolabel != null) {\n                          label = (label || '') + (ref.getAttribute(edge.tolabel) || '');\n                        }\n\n                        var placeholders = (edge.placeholders === 'target') === !edge.invert ? ref : realCell;\n                        var style =\n                          edge.style != null\n                            ? graph.replacePlaceholders(placeholders, edge.style)\n                            : graph.createCurrentEdgeStyle();\n\n                        select.push(\n                          graph.insertEdge(\n                            null,\n                            null,\n                            label || '',\n                            edge.invert ? ref : realCell,\n                            edge.invert ? realCell : ref,\n                            style\n                          )\n                        );\n                        mxUtils.remove(edge.invert ? realCell : ref, roots);\n                      }\n                    }\n                  }\n                }\n              });\n\n              insertEdge(cell, cell, edge);\n\n              // Checks more entries\n              if (dups[cell.id] != null) {\n                for (let j = 0; j < dups[cell.id].length; j++) {\n                  insertEdge(cell, dups[cell.id][j], edge);\n                }\n              }\n            }\n          }\n          // Removes ignored attributes after processing above\n          if (ignore != null) {\n            for (let i = 0; i < allCells.length; i++) {\n              cell = allCells[i];\n\n              for (let j = 0; j < ignore.length; j++) {\n                graph.setAttributeForCell(cell, mxUtils.trim(ignore[j]), null);\n              }\n            }\n          }\n\n          if (cells.length > 0) {\n            var edgeLayout = new mxParallelEdgeLayout(graph);\n            edgeLayout.spacing = edgespacing;\n\n            var postProcess = function() {\n              if (edgeLayout.spacing > 0) {\n                edgeLayout.execute(graph.getDefaultParent());\n              }\n\n              // Aligns cells to grid and/or rounds positions\n              for (var i = 0; i < cells.length; i++) {\n                var geo = graph.getCellGeometry(cells[i]);\n                geo.x = Math.round(graph.snap(geo.x));\n                geo.y = Math.round(graph.snap(geo.y));\n\n                if (width === 'auto') {\n                  geo.width = Math.round(graph.snap(geo.width));\n                }\n\n                if (height === 'auto') {\n                  geo.height = Math.round(graph.snap(geo.height));\n                }\n              }\n            };\n            if (layout.charAt(0) === '[') {\n              // Required for layouts to work with new cells\n              var temp = afterInsert;\n              graph.view.validate();\n              this.executeLayoutList(graph, JSON.parse(layout), function() {\n                postProcess();\n                temp();\n              });\n              afterInsert = null;\n            } else if (layout === 'circle') {\n              var circleLayout = new mxCircleLayout(graph);\n              circleLayout.resetEdges = false;\n\n              var circleLayoutIsVertexIgnored = circleLayout.isVertexIgnored;\n\n              // Ignore other cells\n              circleLayout.isVertexIgnored = function(vertex) {\n                return circleLayoutIsVertexIgnored.apply(this, arguments) || mxUtils.indexOf(cells, vertex) < 0;\n              };\n\n              this.executeLayout(\n                graph,\n                function() {\n                  circleLayout.execute(graph.getDefaultParent());\n                  postProcess();\n                },\n                true,\n                afterInsert\n              );\n\n              afterInsert = null;\n            } else if (\n              layout === 'horizontaltree' ||\n              layout === 'verticaltree' ||\n              (layout === 'auto' && select.length === 2 * cells.length - 1 && roots.length === 1)\n            ) {\n              // Required for layouts to work with new cells\n              graph.view.validate();\n\n              var treeLayout = new mxCompactTreeLayout(graph, layout === 'horizontaltree');\n              treeLayout.levelDistance = nodespacing;\n              treeLayout.edgeRouting = false;\n              treeLayout.resetEdges = false;\n\n              this.executeLayout(\n                graph,\n                function() {\n                  treeLayout.execute(graph.getDefaultParent(), roots.length > 0 ? roots[0] : null);\n                },\n                true,\n                afterInsert\n              );\n\n              afterInsert = null;\n            } else if (\n              layout === 'horizontalflow' ||\n              layout === 'verticalflow' ||\n              (layout === 'auto' && roots.length === 1)\n            ) {\n              // Required for layouts to work with new cells\n              graph.view.validate();\n\n              var flowLayout = new mxHierarchicalLayout(\n                graph,\n                layout === 'horizontalflow' ? mxConstants.DIRECTION_WEST : mxConstants.DIRECTION_NORTH\n              );\n              flowLayout.intraCellSpacing = nodespacing;\n              flowLayout.parallelEdgeSpacing = edgespacing;\n              flowLayout.interRankCellSpacing = levelspacing;\n              flowLayout.disableEdgeStyle = false;\n\n              this.executeLayout(\n                graph,\n                function() {\n                  flowLayout.execute(graph.getDefaultParent(), select);\n\n                  // Workaround for flow layout moving cells to origin\n                  graph.moveCells(select, x0, y0);\n                },\n                true,\n                afterInsert\n              );\n\n              afterInsert = null;\n            } else if (layout === 'organic' || (layout === 'auto' && select.length > cells.length)) {\n              // Required for layouts to work with new cells\n              graph.view.validate();\n\n              var organicLayout = new mxFastOrganicLayout(graph);\n              organicLayout.forceConstant = nodespacing * 3;\n              organicLayout.resetEdges = false;\n\n              var organicLayoutIsVertexIgnored = organicLayout.isVertexIgnored;\n\n              // Ignore other cells\n              organicLayout.isVertexIgnored = function(vertex) {\n                return organicLayoutIsVertexIgnored.apply(this, arguments) || mxUtils.indexOf(cells, vertex) < 0;\n              };\n\n              edgeLayout = new mxParallelEdgeLayout(graph);\n              edgeLayout.spacing = edgespacing;\n\n              this.executeLayout(\n                graph,\n                function() {\n                  organicLayout.execute(graph.getDefaultParent());\n                  postProcess();\n                },\n                true,\n                afterInsert\n              );\n\n              afterInsert = null;\n            }\n          }\n        } finally {\n          graph.model.endUpdate();\n        }\n        if (afterInsert != null) {\n          afterInsert();\n        }\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  },\n  anonymize(graph) {\n    const div = document.createElement('div');\n    const model = graph.model;\n    const ignoredAnonymizedChars = '\\n\\t`~!@#$%^&*()_+{}|:\"<>?-=[];\\'./,\\n\\t';\n    const anonymizeString = (text, zeros) => {\n      var result = [];\n\n      for (let i = 0; i < text.length; i++) {\n        const c = text.charAt(i);\n        if (ignoredAnonymizedChars.indexOf(c) >= 0) {\n          result.push(c);\n        } else if (!isNaN(parseInt(c))) {\n          result.push(zeros ? '0' : Math.round(Math.random() * 9));\n        } else if (c.toLowerCase() !== c) {\n          result.push(String.fromCharCode(65 + Math.round(Math.random() * 25)));\n        } else if (c.toUpperCase() !== c) {\n          result.push(String.fromCharCode(97 + Math.round(Math.random() * 25)));\n        } else if (/\\s/.test(c)) {\n          result.push(' ');\n        } else {\n          result.push('?');\n        }\n      }\n      return result.join('');\n    };\n    const replaceTextContent = elt => {\n      if (elt.nodeValue != null) {\n        elt.nodeValue = anonymizeString(elt.nodeValue);\n      }\n\n      if (elt.nodeType === mxConstants.NODETYPE_ELEMENT) {\n        let tmp = elt.firstChild;\n\n        while (tmp != null) {\n          replaceTextContent(tmp);\n          tmp = tmp.nextSibling;\n        }\n      }\n    };\n    const anonymizeHtml = html => {\n      div.innerHTML = html;\n\n      replaceTextContent(div);\n\n      return div.innerHTML;\n    };\n\n    model.beginUpdate();\n    try {\n      // Queue used to fix ancestor placeholders\n      const queue = [];\n\n      for (var id in model.cells) {\n        var cell = model.cells[id];\n        var label = graph.getLabel(cell);\n\n        if (graph.isHtmlLabel(cell)) {\n          label = anonymizeHtml(label);\n        } else {\n          label = anonymizeString(label);\n        }\n\n        queue.push({ cell: cell, label: label });\n      }\n\n      for (var i = 0; i < queue.length; i++) {\n        model.setValue(queue[i].cell, queue[i].label);\n      }\n    } finally {\n      model.endUpdate();\n    }\n  },\n  addExtFont(fontName, fontUrl, dontRemember) {\n    // KNOWN: Font not added when pasting cells with custom fonts\n    if (fontName && fontUrl) {\n      var fontId = 'extFont_' + fontName;\n\n      if (document.getElementById(fontId) === null) {\n        if (fontUrl.indexOf(Editor.GOOGLE_FONTS) === 0) {\n          mxClient.link('stylesheet', fontUrl, null, fontId);\n        } else {\n          var head = document.getElementsByTagName('head')[0];\n\n          // KNOWN: Should load fonts synchronously\n          var style = document.createElement('style');\n\n          style.appendChild(\n            document.createTextNode(\n              '@font-face {\\n' + '\\tfont-family: \"' + fontName + '\";\\n' + '\\tsrc: url(\"' + fontUrl + '\");\\n' + '}'\n            )\n          );\n\n          style.setAttribute('id', fontId);\n          head = document.getElementsByTagName('head')[0];\n          head.appendChild(style);\n        }\n      }\n\n      if (!dontRemember) {\n        if (this.extFonts == null) {\n          this.extFonts = [];\n        }\n\n        var extFonts = this.extFonts,\n          notFound = true;\n\n        for (var i = 0; i < extFonts.length; i++) {\n          if (extFonts[i].name === fontName) {\n            notFound = false;\n            break;\n          }\n        }\n\n        if (notFound) {\n          this.extFonts.push({ name: fontName, url: fontUrl });\n        }\n      }\n    }\n  },\n};\n","import { Flowchart } from 'flowchart_class';\nimport { Rule, GFMap } from 'rule_class';\nimport _ from 'lodash';\n// const clonedeep = require('lodash.clonedeep')\nimport { Metric } from './metric_class';\nimport { $GF } from 'globals_class';\n\n/**\n * Class FlowchartHandler\n */\nexport class FlowchartHandler {\n  $scope: ng.IScope;\n  $elem: any; //TODO: elem ?\n  parentDiv: HTMLDivElement;\n  ctrl: any; //TODO: ctrl ?\n  flowcharts: Flowchart[] = [];\n  currentFlowchartName = 'Main'; // name of current Flowchart\n  currentFlowchart: Flowchart | undefined;\n  data: gf.TFlowchartHandlerData;\n  firstLoad = true; // First load\n  flags = {\n    sources: new Set<string>(),\n    options: new Set<string>(),\n    rules: new Set<string>(),\n    datas: new Set<string>(),\n    graphHover: new Set<string>(),\n    applyOptions: new Set<string>(),\n    hiddenChange: new Set<string>(),\n  };\n  newMode = false; // Mode if new flowchart\n  sequenceNumber = 0; // Sequence Number for a name\n  static defaultXml: string;\n  static defaultCsv: string;\n  onMapping: gf.TIOnMappingObj = {\n    active: false,\n    object: null,\n    value: null,\n    prop: 'id',\n    $scope: null,\n  };\n  mousedownTimeout = 0;\n  mousedown = 0;\n  onEdit = false; // editor open or not\n  postedId: string | undefined = undefined; // Current ID on edit mode\n  editorWindow: Window | null = null; // Window draw.io editor\n\n  /**\n   * Creates an instance of FlowchartHandler to handle flowchart\n   * @param {ng.IScope} $scope - angular scope\n   * @param {any} elem - angular elem\n   * @param {TODO:FlowchartCtrl} ctrl - ctrlPanel\n   * @param {*} data - Empty data to store\n   * @memberof FlowchartHandler\n   */\n  constructor($scope: ng.IScope, elem: any, ctrl: any, data: gf.TFlowchartHandlerData) {\n    FlowchartHandler.getDefaultDioGraph();\n    this.$scope = $scope;\n    this.$elem = elem.find('.flowchart-panel__chart');\n    this.parentDiv = this.$elem[0];\n    this.ctrl = ctrl;\n    this.data = data;\n    this.currentFlowchartName = 'Main';\n\n    // Events Render\n    ctrl.events.on('render', () => {\n      this.render();\n    });\n\n    document.body.onmousedown = () => {\n      this.mousedown = 0;\n      window.clearInterval(this.mousedownTimeout);\n      this.mousedownTimeout = window.setInterval(() => {\n        this.mousedown += 1;\n      }, 200);\n    };\n\n    document.body.onmouseup = () => {\n      this.mousedown = 0;\n      window.clearInterval(this.mousedownTimeout);\n    };\n  }\n\n  static getDefaultData(): gf.TFlowchartHandlerData {\n    return {\n      editorUrl: 'https://diagrams.new/',\n      editorTheme: 'kennedy',\n      flowcharts: [],\n      allowDrawio: true,\n    };\n  }\n\n  /**\n   * import data into\n   *\n   * @returns {this}\n   * @param {Object} obj\n   * @memberof FlowchartHandler\n   */\n  import(obj: any): this {\n    this.flowcharts = [];\n    if (obj !== undefined && obj !== null) {\n      // For version 0.5.0 and under\n      let tmpFc: any[];\n      if (Array.isArray(obj)) {\n        tmpFc = obj;\n      } else {\n        tmpFc = obj.flowcharts;\n      }\n\n      // For 0.9.0 and under\n      if (tmpFc.length === 1) {\n        this.currentFlowchartName = tmpFc[0].name;\n        if (!!tmpFc[0].editorTheme && tmpFc[0].editorTheme.length > 1) {\n          this.data.editorTheme = tmpFc[0].editorTheme;\n        }\n        if (!!tmpFc[0].editorUrl && tmpFc[0].editorUrl.length > 1) {\n          this.data.editorUrl = tmpFc[0].editorUrl;\n        }\n        if (!!tmpFc[0].allowDrawio || tmpFc[0].allowDrawio === false) {\n          this.data.allowDrawio = obj.allowDrawio;\n        }\n      }\n      this.data.editorTheme = !!obj.editorTheme ? obj.editorTheme : this.data.editorTheme;\n      this.data.editorUrl = !!obj.editorUrl ? obj.editorUrl : this.data.editorUrl;\n\n      // import data\n      tmpFc.forEach((fcData: gf.TFlowchartData) => {\n        this.addFlowchart(fcData.name)\n          .toBack()\n          .import(fcData);\n      });\n      this.currentFlowchart = this.getFlowchart('Main');\n    }\n    return this;\n  }\n\n  /**\n   * Return default xml source graph\n   *\n   * @static\n   * @returns {string}\n   * @memberof FlowchartHandler\n   */\n  static getDefaultDioGraph(): string {\n    let result = FlowchartHandler.defaultXml;\n    if (!result) {\n      const url = `${$GF.plugin.getRootPath()}${$GF.CONSTANTS.CONF_FILE_DEFAULTDIO}`;\n      result = $GF.utils.$loadFile(url);\n    }\n    return result;\n  }\n\n  /**\n   * Return default xml source graph\n   *\n   * @static\n   * @returns {string}\n   * @memberof FlowchartHandler\n   */\n  static getDefaultCsvGraph(): string {\n    let result = FlowchartHandler.defaultCsv;\n    if (!result) {\n      const url = `${$GF.plugin.getRootPath()}${$GF.CONSTANTS.CONF_FILE_DEFAULTCSV}`;\n      result = $GF.utils.$loadFile(url);\n    }\n    return result;\n  }\n\n  /**\n   * Get flowchart with name\n   *\n   * @param {string} name\n   * @returns {Flowchart}\n   * @memberof FlowchartHandler\n   */\n  getFlowchart(name?: string): Flowchart {\n    if (name) {\n      const lg = this.flowcharts.length;\n      for (let i = 0; i < lg; i++) {\n        const fc = this.flowcharts[i];\n        if (fc.getName() === name) {\n          return fc;\n        }\n      }\n    }\n    const current = this.getCurrentFlowchart();\n    return current !== undefined ? current : this.flowcharts[0];\n  }\n\n  getFlowchartById(id: string): Flowchart | undefined {\n    const fcs = this.getFlowcharts();\n    for (let index = 0; index < fcs.length; index++) {\n      const fc = fcs[index];\n      if (fc.id === id) {\n        return fc;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Return array of flowchart\n   *\n   * @returns {Flowchart[]} Array of flowchart\n   * @memberof FlowchartHandler\n   */\n  getFlowcharts(): Flowchart[] {\n    return this.flowcharts;\n  }\n\n  /**\n   * Return number of flowchart\n   *\n   * @returns {number} Nulber of flowchart\n   * @memberof FlowchartHandler\n   */\n  countFlowcharts(): number {\n    if (this.flowcharts !== undefined && Array.isArray(this.flowcharts)) {\n      return this.flowcharts.length;\n    }\n    return 0;\n  }\n\n  /**\n   * get a temp name\n   *\n   * @returns {string}\n   * @memberof FlowchartHandler\n   */\n  getFlowchartTmpName(): string {\n    if (this.sequenceNumber === 0) {\n      this.sequenceNumber = this.countFlowcharts();\n    }\n    return `Flowchart-${this.sequenceNumber++}`;\n  }\n\n  isMultiFlowcharts(): boolean {\n    return this.flowcharts.length > 1;\n  }\n\n  isCurrentfirst(): boolean {\n    const index = this.getCurrentIndex();\n    return index === 0;\n  }\n\n  isCurrentLast(): boolean {\n    const index = this.getCurrentIndex();\n    return index === this.flowcharts.length - 1;\n  }\n\n  getCurrentIndex(): number {\n    if (this.currentFlowchart) {\n      return this.flowcharts.indexOf(this.currentFlowchart);\n    }\n    return 0;\n  }\n\n  /**\n   * Define current flowchart to display\n   *\n   * @param {string} name, Main if empty\n   * @returns {(Flowchart|undefined)}\n   * @memberof FlowchartHandler\n   */\n  setCurrentFlowchart(name?: string): Flowchart | undefined {\n    $GF.log.debug('setCurrentFlowchart', name);\n    if (name === undefined) {\n      this.currentFlowchart = this.getFlowchart('Main');\n      this.currentFlowchartName = this.currentFlowchart.getName();\n      this.currentFlowchart.toFront();\n      return this.currentFlowchart;\n    }\n    if (this.currentFlowchart === undefined) {\n      this.currentFlowchart = this.getFlowchart(name);\n      this.currentFlowchartName = this.currentFlowchart.getName();\n      // this.currentFlowchart.toFront();\n      return this.currentFlowchart;\n    }\n    if (this.currentFlowchart.getName() !== name) {\n      this.currentFlowchart.toBack();\n    }\n    this.currentFlowchart = this.getFlowchart(name);\n    this.currentFlowchartName = name;\n    this.currentFlowchart.toFront();\n    return this.currentFlowchart;\n  }\n\n  setNextFlowchart() {\n    const index = this.getCurrentIndex();\n    if (index < this.flowcharts.length - 1) {\n      const name = this.flowcharts[index + 1].getName();\n      this.setCurrentFlowchart(name);\n    }\n  }\n\n  setPreviousFlowchart() {\n    const index = this.getCurrentIndex();\n    if (index !== 0) {\n      const name = this.flowcharts[index - 1].getName();\n      this.setCurrentFlowchart(name);\n    }\n  }\n\n  /**\n   * get Current Flowchart\n   *\n   * @returns {(Flowchart|undefined)}\n   * @memberof FlowchartHandler\n   */\n  getCurrentFlowchart(): Flowchart | undefined {\n    return this.currentFlowchart;\n  }\n\n  /**\n   * Give the name of current flowchart\n   *\n   * @returns {string}\n   * @memberof FlowchartHandler\n   */\n  getCurrentFlowchartName(): string {\n    const cf = this.getCurrentFlowchart();\n    return cf !== undefined ? cf.getName() : 'Main';\n  }\n\n  /**\n   * Create a div container for graph\n   *\n   * @returns {HTMLDivElement}\n   * @memberof FlowchartHandler\n   */\n  createContainer(): HTMLDivElement {\n    const div = document.createElement('div');\n    div.style.margin = 'auto';\n    // div.style.position = 'relative';\n    div.style.position = 'absolute';\n    div.style.width = '100%';\n    div.style.height = '100%';\n    div.style.touchAction = 'none';\n    div.style.border = 'none';\n    div.style.cursor = 'default';\n    div.style.right = '0px';\n    div.style.left = '0px';\n    div.style.bottom = '0px';\n    div.style.top = '0px';\n    // div.style.overflow = 'none';\n    this.parentDiv.appendChild(div);\n    return div;\n  }\n\n  /**\n   * Add a flowchart\n   *\n   * @param {string} name\n   * @returns {Flowchart}\n   * @memberof FlowchartHandler\n   */\n  addFlowchart(name: string): Flowchart {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'addFlowchart()');\n    const data = Flowchart.getDefaultData();\n    const container = this.createContainer();\n    const flowchart = new Flowchart(name, container, this.ctrl, data);\n    // flowchart.init();\n    this.flowcharts.push(flowchart);\n    this.data.flowcharts.push(data);\n    // this.flagChange($GF.CONSTANTS.FLOWCHART_CHG_SOURCES, name);\n    trc.after();\n    return flowchart;\n  }\n\n  /**\n   * Remove a flowchart\n   *\n   * @param {string} name\n   * @memberof FlowchartHandler\n   */\n  removeFlowchart(name: string) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'removeFlowchart()');\n    const fc = this.getFlowchart(name);\n    const index = this.flowcharts.indexOf(fc);\n    this.flowcharts.splice(index, 1);\n    this.data.flowcharts.splice(index, 1);\n    fc.destroy();\n    trc.after();\n  }\n\n  /**\n   * Render for draw\n   *\n   * @memberof FlowchartHandler\n   */\n  async render(name?: string) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'render()');\n    // console.log('RENDER Flags BEGIN', clonedeep(this.flags));\n    // not repeat render if mouse down\n    if (!this.mousedown) {\n      this.flagChange($GF.CONSTANTS.FLOWCHART_APL_OPTIONS);\n      const self = this;\n      // SOURCE\n      if (self.isFlagedChange($GF.CONSTANTS.FLOWCHART_CHG_SOURCES)) {\n        this.getFlagNames($GF.CONSTANTS.FLOWCHART_CHG_SOURCES).forEach(name => {\n          self.load(name).setOptions(name);\n        });\n      }\n      // console.log('RENDER Flags AFTER SOURCE', clonedeep(this.flags));\n\n      // OPTIONS\n      if (self.isFlagedChange($GF.CONSTANTS.FLOWCHART_CHG_OPTIONS)) {\n        this.getFlagNames($GF.CONSTANTS.FLOWCHART_CHG_OPTIONS).forEach(name => {\n          self.setOptions(name);\n        });\n      }\n      // console.log('RENDER Flags AFTER OPTIONS', clonedeep(this.flags));\n\n      // RULES or DATAS\n      if (\n        self.isFlagedChange($GF.CONSTANTS.FLOWCHART_CHG_RULES) ||\n        self.isFlagedChange($GF.CONSTANTS.FLOWCHART_CHG_DATAS) ||\n        self.isFlagedChange($GF.CONSTANTS.FLOWCHART_CHG_GRAPHHOVER)\n      ) {\n        const rules = self.ctrl.rulesHandler.getRules();\n        const metrics = self.ctrl.metricHandler.getMetrics();\n\n        // Change to async to optimize\n        self.async_refreshStates(rules, metrics);\n        this.aknowledgeFlagChange($GF.CONSTANTS.FLOWCHART_APL_OPTIONS);\n        this.aknowledgeFlagChange($GF.CONSTANTS.FLOWCHART_CHG_DATAS);\n        this.aknowledgeFlagChange($GF.CONSTANTS.FLOWCHART_CHG_GRAPHHOVER);\n      }\n      // console.log('RENDER Flags AFTER DATAS', clonedeep(this.flags));\n\n      // Current visible\n      if (self.currentFlowchart !== undefined && !self.currentFlowchart.isVisible()) {\n        // console.log(\"!self.currentFlowchart.isVisible()\",!self.currentFlowchart.isVisible());\n        this.setCurrentFlowchart(self.currentFlowchart.getName());\n        this.aknowledgeFlagChange($GF.CONSTANTS.FLOWCHART_APL_OPTIONS);\n      }\n      // console.log('RENDER Flags AFTER VISIBLES', clonedeep(this.flags));\n\n      // OTHER : Resize, OnLoad\n      if (self.isFlagedChange($GF.CONSTANTS.FLOWCHART_APL_OPTIONS) || self.firstLoad) {\n        // console.log(\"Apply Options\")\n        if (self.firstLoad) {\n          self.applyOptions();\n          self.firstLoad = false;\n        } else {\n          // console.log(\"Apply options on\",this.getFlagNames($GF.CONSTANTS.FLOWCHART_APL_OPTIONS));\n          this.getFlagNames($GF.CONSTANTS.FLOWCHART_APL_OPTIONS).forEach(name => {\n            self.applyOptions(name);\n          });\n        }\n      }\n      // this.refresh();\n    }\n    this.ctrl.renderingCompleted();\n    trc.after();\n  }\n\n  /**\n   * Flag source change\n   *\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  onSourceChange(name?: string): this {\n    this.flagChange($GF.CONSTANTS.FLOWCHART_CHG_SOURCES, name);\n    return this;\n  }\n\n  /**\n   * Flag options change\n   *\n   * @param {string} [name]\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  onOptionsChange(name?: string): this {\n    this.flagChange($GF.CONSTANTS.FLOWCHART_CHG_OPTIONS, name);\n    return this;\n  }\n\n  /**\n   * Flag datas change\n   *\n   * @param {string} [name]\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  onDatasChange(name?: string): this {\n    this.flagChange($GF.CONSTANTS.FLOWCHART_CHG_DATAS, name);\n    return this;\n  }\n\n  /**\n   * Flag rule change\n   *\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  onRulesChange(name?: string): this {\n    this.flagChange($GF.CONSTANTS.FLOWCHART_CHG_RULES, name);\n    return this;\n  }\n\n  /**\n   * Flag data Graph-Hover change\n   *\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  onGraphHoverChange(): this {\n    this.flagChange($GF.CONSTANTS.FLOWCHART_CHG_GRAPHHOVER, name);\n    return this;\n  }\n\n  /**\n   * Apply options on graphs\n   *\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  applyOptions(name?: string): this {\n    $GF.log.debug(`${this.constructor.name}.applyOptions()`, name);\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'applyOptions()');\n    if (name === undefined) {\n      this.flowcharts.forEach(flowchart => {\n        const name = flowchart.getName();\n        this.applyOptions(name);\n      });\n    } else {\n      const flowchart = this.getFlowchart(name);\n      flowchart.applyOptions();\n      this.aknowledgeFlagChange($GF.CONSTANTS.FLOWCHART_APL_OPTIONS, name);\n      if (!flowchart.isVisible()) {\n        this.flagChange($GF.CONSTANTS.FLOWCHART_CHG_HIDDENCHANGE, name);\n      }\n    }\n    trc.after();\n    return this;\n  }\n\n  flagChange(type: gf.TFlowchartFlagKeys, name?: string): this {\n    $GF.log.debug('flagChange', type, name);\n    if (name !== undefined) {\n      this.flags[type].add(name);\n    } else {\n      this.flowcharts.forEach(flowchart => {\n        const name = flowchart.getName();\n        this.flags[type].add(name);\n      });\n    }\n    return this;\n  }\n\n  isFlagedChange(type: gf.TFlowchartFlagKeys, name?: string): boolean {\n    if (name === undefined) {\n      return this.flags[type].size > 0;\n    }\n    return this.flags[type].has(name);\n  }\n\n  aknowledgeFlagChange(type: gf.TFlowchartFlagKeys, name?: string): void {\n    $GF.log.debug('aknowledgeFlagChange', type, name);\n    if (name === undefined) {\n      this.flags[type].clear();\n    } else {\n      this.flags[type].delete(name);\n    }\n  }\n\n  getFlagNames(type: gf.TFlowchartFlagKeys): string[] {\n    let result: string[] = [];\n    this.flags[type].forEach(value => result.push(value));\n    return result;\n  }\n\n  /**\n   * Call refreshStates asynchronously\n   *\n   * @param {Rule[]} rules\n   * @param {Metric[]} metrics\n   * @memberof FlowchartHandler\n   */\n  async_refreshStates(rules: Rule[], metrics: Metric[]) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'async_refreshStates()');\n    this.refreshStates(rules, metrics);\n    trc.after();\n  }\n\n  /**\n   * Refresh rules according new rules or data\n   *\n   * @param {Rule[]} rules\n   * @param {Metric[]} metrics\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  refreshStates(rules: Rule[], metrics: Metric[]): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'refreshStates()');\n    if (this.isFlagedChange($GF.CONSTANTS.FLOWCHART_CHG_RULES)) {\n      this.updateStates(rules);\n      this.aknowledgeFlagChange($GF.CONSTANTS.FLOWCHART_CHG_RULES);\n    }\n    this.setStates(rules, metrics);\n    this.applyStates();\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Refresh all flowchart\n   *\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  refresh(): this {\n    this.flowcharts.forEach(flowchart => {\n      flowchart.refresh();\n    });\n    return this;\n  }\n\n  /**\n   * Change states of cell according to rules and metrics\n   *\n   * @param {Rule[]} rules\n   * @param {any[]} metrics\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  setStates(rules: Rule[], metrics: any[]): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'setStates()');\n    this.flowcharts.forEach(flowchart => {\n      flowchart.setStates(rules, metrics);\n    });\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Update states with rule\n   *\n   * @param {Rule[]} rules\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  updateStates(rules: Rule[]): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'updateStates()');\n    this.flowcharts.forEach(flowchart => {\n      flowchart.updateStates(rules);\n    });\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Apply state of cell after setStates\n   *\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  applyStates(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'applyStates()');\n    new Promise(() => {\n      this.flowcharts.forEach(flowchart => {\n        flowchart.applyStates();\n      });\n    }).then(() => {\n      this.refresh();\n    });\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Set and apply options\n   *\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  setOptions(name?: string): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'setOptions()');\n    if (name === undefined) {\n      this.flowcharts.forEach(flowchart => {\n        const name = flowchart.getName();\n        this.setOptions(name);\n      });\n    } else {\n      const flowchart = this.getFlowchart(name);\n      flowchart.setOptions();\n      this.aknowledgeFlagChange($GF.CONSTANTS.FLOWCHART_CHG_OPTIONS, name);\n      // this.flagChange($GF.CONSTANTS.FLOWCHART_CHG_DATAS, name);\n      this.flagChange($GF.CONSTANTS.FLOWCHART_APL_OPTIONS, name);\n      if (!flowchart.isVisible()) {\n        this.flagChange($GF.CONSTANTS.FLOWCHART_CHG_HIDDENCHANGE, name);\n      }\n    }\n    trc.after();\n    return this;\n  }\n\n  setCurrentOptions(): this {\n    const name = this.getCurrentFlowchartName();\n    this.setOptions(name);\n    return this;\n  }\n\n  /**\n   * (re)draw graph\n   *\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  draw(name?: string): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'draw()');\n    if (name === undefined) {\n      this.flowcharts.forEach(flowchart => {\n        const name = flowchart.getName();\n        this.draw(name);\n      });\n    } else {\n      const flowchart = this.getFlowchart(name);\n      flowchart.redraw();\n    }\n    trc.after();\n    return this;\n  }\n\n  drawCurrent(): this {\n    const name = this.getCurrentFlowchartName();\n    this.draw(name);\n    return this;\n  }\n\n  /**\n   * (re)load graph,\n   *\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  load(name?: string): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'draw()');\n    if (name === undefined) {\n      this.flowcharts.forEach(flowchart => {\n        this.load(name);\n      });\n    } else {\n      const flowchart = this.getFlowchart(name);\n      if (!flowchart.isVisible()) {\n        this.flagChange($GF.CONSTANTS.FLOWCHART_CHG_HIDDENCHANGE, name);\n      }\n      flowchart.reload();\n      this.aknowledgeFlagChange($GF.CONSTANTS.FLOWCHART_CHG_SOURCES, name);\n    }\n    trc.after();\n    return this;\n  }\n\n  /**\n   * load current flowchart\n   *\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  loadCurrent(): this {\n    const name = this.getCurrentFlowchartName();\n    this.load(name);\n    return this;\n  }\n\n  /**\n   * Active option link/map\n   *\n   * @param {Object} objToMap\n   * @memberof FlowchartHandler\n   */\n  setMap(objToMap: GFMap, prop: gf.TPropertieKey = 'id'): this {\n    const flowchart = this.getFlowchart(this.currentFlowchartName);\n    this.onMapping.active = true;\n    this.onMapping.object = objToMap;\n    this.onMapping.value = objToMap.getId();\n    this.onMapping.$scope = this.$scope;\n    this.onMapping.prop = prop;\n    flowchart.setMap(this.onMapping);\n    return this;\n  }\n\n  /**\n   * Desactivate option\n   *\n   * @memberof FlowchartHandler\n   */\n  unsetMap(): this {\n    const flowchart = this.getFlowchart(this.currentFlowchartName);\n    this.onMapping.active = false;\n    this.onMapping.object = undefined;\n    this.onMapping.value = '';\n    flowchart.unsetMap();\n    return this;\n  }\n\n  /**\n   * Return true if mapping object is active\n   *\n   * @param {properties} objToMap\n   * @returns true - true if mapping mode\n   * @memberof FlowchartHandler\n   */\n  isMapping(objToMap: GFMap): boolean {\n    if (objToMap === undefined || objToMap == null) {\n      return this.onMapping.active;\n    }\n    if (this.onMapping.active === true && objToMap === this.onMapping.object) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Wait for draw.io answer\n   *\n   * @private\n   * @param {MessageEvent} event\n   * @memberof FlowchartHandler\n   */\n  listenMessage(event: any) {\n    if (event.data !== undefined && event.data.length > 0 && event.data.substring(0, 3) === 'fc-') {\n      const id = event.data.substring(3);\n      const fc = this.getFlowchartById(id);\n      this.currentFlowchart = fc;\n      // send xml\n      // if (event.source) {\n      //   if (!(event.source instanceof MessagePort) && !(event.source instanceof ServiceWorker)) {\n      if (fc !== undefined) {\n        $GF.message.setMessage('Sending current data to draw.io editor', 'info');\n        event.source.postMessage(fc.data.xml, event.origin);\n        this.postedId = fc.id;\n      }\n      //   }\n      // }\n    } else {\n      if (\n        this.onEdit &&\n        event.data !== undefined &&\n        event.data.length > 0 &&\n        event.data.substring(0, 3) !== 'fc-' &&\n        this.currentFlowchart !== undefined\n      ) {\n        if (this.postedId !== undefined) {\n          const fc = this.getFlowchartById(this.postedId);\n          if (fc !== undefined) {\n            $GF.message.setMessage('Received data from draw.io editor, refresh in progress', 'info');\n            fc.redraw(event.data);\n            this.onSourceChange(fc.getName());\n            this.$scope.$apply();\n            this.render();\n          }\n        }\n      }\n      if ((this.onEdit && event.data !== undefined) || event.data.length === 0) {\n        if (this.editorWindow) {\n          this.editorWindow.close();\n        }\n        this.onEdit = false;\n        this.postedId = undefined;\n        window.removeEventListener('message', this.listenMessage.bind(this), false);\n        $GF.message.setMessage('Draw.io editor closed', 'info');\n      }\n    }\n  }\n\n  /**\n   * Open graph in draw.io\n   *\n   * @memberof FlowchartHandler\n   */\n  openDrawEditor(name?: string) {\n    const fc = this.getFlowchart(name);\n    const urlEditor = this.data.editorUrl;\n    const theme = this.data.editorTheme;\n    const urlParams = `${urlEditor}?embed=1&spin=1&libraries=1&ui=${theme}&ready=fc-${fc.id}&src=grafana`;\n    this.editorWindow = window.open(urlParams, 'MxGraph Editor', 'width=1280, height=720');\n    this.onEdit = true;\n    $GF.message.setMessage(`Opening current flowchart on draw.io editor`, 'info');\n    window.addEventListener('message', this.listenMessage.bind(this), false);\n  }\n\n  /**\n   * Get flowchart names\n   *\n   * @returns {string[]}\n   * @memberof FlowchartHandler\n   */\n  getFlowchartNames(): string[] {\n    return this.flowcharts.map(f => f.data.name);\n  }\n}\n","import XGraph from 'graph_class';\nimport { StateHandler } from 'statesHandler';\nimport { State } from 'state_class';\nimport { Rule } from 'rule_class';\n\nimport { FlowchartHandler } from 'flowchartHandler';\nimport { Metric } from 'metric_class';\nimport { $GF } from 'globals_class';\n\n/**\n * Flowchart handler\n *\n * @export\n * @class Flowchart\n */\nexport class Flowchart {\n  data: gf.TFlowchartData;\n  container: HTMLDivElement;\n  xgraph: XGraph | undefined = undefined;\n  stateHandler: StateHandler | undefined;\n  // ctrl: any;\n  templateSrv: any;\n  states: Map<string, State> | undefined;\n  id: string;\n  visible = false;\n\n  constructor(name: string, container: HTMLDivElement, ctrl: any, data: gf.TFlowchartData) {\n    this.data = data;\n    this.data.name = name;\n    this.container = container;\n    this.templateSrv = ctrl.templateSrv;\n    this.id = $GF.utils.uniqueID();\n  }\n\n  /**\n   * Import data object in current flowchart\n   *\n   * @param {Object} obj\n   * @memberof Flowchart\n   */\n  import(obj: any): this {\n    $GF.log.info(`flowchart[${this.data.name}].import()`);\n    if (!!obj.download || this.data.download === false) {\n      this.data.download = obj.download;\n    }\n    // 0.3.0\n    if (!!obj.source) {\n      this.data.type = obj.source.type;\n      this.data.xml = obj.source.xml.value;\n      this.data.url = obj.source.url.value;\n    }\n    // 0.3.0\n    if (!!obj.options) {\n      this.data.zoom = obj.options.zoom;\n      this.data.center = obj.options.center;\n      this.data.scale = obj.options.scale;\n      this.data.lock = obj.options.lock;\n      this.data.tooltip = obj.options.tooltip;\n      this.data.grid = obj.options.grid;\n      this.data.bgColor = obj.options.bgColor;\n    }\n    if (!!obj.type) {\n      this.data.type = obj.type;\n    }\n    if (!!obj.xml) {\n      this.data.xml = obj.xml;\n    }\n\n    // 0.9.0\n    if (!!obj.csv) {\n      this.data.csv = obj.csv;\n    }\n    if (!!obj.url) {\n      this.data.url = obj.url;\n    }\n    if (!!obj.zoom) {\n      this.data.zoom = obj.zoom;\n    }\n    if (!!obj.center || obj.center === false) {\n      this.data.center = obj.center;\n    }\n    if (!!obj.scale || obj.scale === false) {\n      this.data.scale = obj.scale;\n    }\n\n    if (!!obj.lock || obj.lock === false) {\n      this.data.lock = obj.lock;\n    }\n\n    if (!!obj.enableAnim || obj.enableAnim === false) {\n      this.data.enableAnim = obj.enableAnim;\n    }\n    if (!!obj.tooltip) {\n      this.data.tooltip = obj.tooltip;\n    }\n    if (!!obj.grid || obj.grid === false) {\n      this.data.grid = obj.grid;\n    }\n    if (!!obj.bgColor) {\n      this.data.bgColor = obj.bgColor;\n    }\n    this.init();\n    return this;\n  }\n\n  /**\n   * Return the default XML when new\n   *\n   * @static\n   * @returns {gf.TFlowchartData}\n   * @memberof Flowchart\n   */\n  static getDefaultData(): gf.TFlowchartData {\n    return {\n      name: 'name',\n      xml: FlowchartHandler.getDefaultDioGraph(),\n      csv: FlowchartHandler.getDefaultCsvGraph(),\n      download: false,\n      type: 'xml',\n      url: 'http://<YourUrl>/<Your XML/drawio file/api>',\n      zoom: '100%',\n      center: true,\n      scale: true,\n      lock: true,\n      enableAnim: true,\n      tooltip: true,\n      grid: false,\n      bgColor: null,\n    };\n  }\n\n  /**\n   * Return data without functions to save json in grafana\n   *\n   * @returns {Object} Data object\n   * @memberof Flowchart\n   */\n  getData(): gf.TFlowchartData {\n    return this.data;\n  }\n\n  /**\n   * Update states of flowchart/graph\n   *\n   * @param {*} rules\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  updateStates(rules: Rule[]): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'updateStates()');\n    rules.forEach(rule => {\n      if (this.stateHandler !== undefined) {\n        rule.states = this.stateHandler.getStatesForRule(rule);\n        if (rule.states) {\n          rule.states.forEach((state: any) => {\n            state.unsetState();\n          });\n        } else {\n          $GF.log.warn('States not defined for this rule');\n        }\n      } else {\n        $GF.log.error('updateStates => this.stateHandler undefined');\n      }\n    });\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Initialisation of flowchart class\n   *\n   * @return {this}\n   * @memberof Flowchart\n   */\n  init(): this {\n    try {\n      const content = this.getContent();\n      if (this.xgraph === undefined) {\n        this.xgraph = new XGraph(this.container, this.data.type, content);\n      }\n      if (content !== undefined && content !== null) {\n        if (this.data.enableAnim) {\n          this.xgraph.enableAnim(true);\n        } else {\n          this.xgraph.enableAnim(false);\n        }\n        this.setOptions();\n        this.xgraph.drawGraph();\n        if (this.data.tooltip) {\n          this.xgraph.tooltipGraph(true);\n        }\n        if (this.data.scale) {\n          this.xgraph.scaleGraph(true);\n        } else {\n          this.xgraph.zoomGraph(this.data.zoom);\n        }\n        if (this.data.center) {\n          this.xgraph.centerGraph(true);\n        }\n        if (this.data.lock) {\n          this.xgraph.lockGraph(true);\n        }\n        this.stateHandler = new StateHandler(this.xgraph);\n        $GF.message.clearMessage();\n      } else {\n        $GF.message.setMessage('Source content empty Graph not defined', 'error');\n        $GF.log.error('Source content empty Graph not defined');\n      }\n    } catch (error) {\n      $GF.message.setMessage('Unable to initialize graph', 'error');\n      $GF.log.error('Unable to initialize graph', error);\n    }\n    return this;\n  }\n\n  /**\n   * Get states handler\n   *\n   * @returns\n   * @memberof Flowchart\n   */\n  getStateHandler() {\n    return this.stateHandler;\n  }\n\n  /**\n   * Get XGraph\n   *\n   * @returns\n   * @memberof Flowchart\n   */\n  getXGraph() {\n    return this.xgraph;\n  }\n\n  allowDrawio(flag: boolean): this {\n    if (this.xgraph !== undefined) {\n      this.xgraph.allowDrawio(flag);\n    }\n    return this;\n  }\n\n  /**\n   * Init states with rules and metrics\n   *\n   * @param {Rule[]} rules\n   * @param {Metric[]} metrics\n   * @memberof Flowchart\n   */\n  setStates(rules: Rule[], metrics: Metric[]): this {\n    // $GF.log.info(`flowchart[${this.data.name}].setStates()`);\n    if (rules === undefined) {\n      $GF.log.warn(\"Rules shoudn't be null\");\n    }\n    if (metrics === undefined) {\n      $GF.log.warn(\"Metrics shoudn't be null\");\n    }\n    if (this.stateHandler) {\n      this.stateHandler.setStates(rules, metrics);\n    }\n    return this;\n  }\n\n  /**\n   * Init options of graph\n   *\n   * @memberof Flowchart\n   */\n  setOptions(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'setOptions()');\n    this.setScale(this.data.scale);\n    this.setCenter(this.data.center);\n    this.setGrid(this.data.grid);\n    this.setTooltip(this.data.tooltip);\n    this.setLock(this.data.lock);\n    this.setZoom(this.data.zoom);\n    this.setBgColor(this.data.bgColor);\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Apply new states (colors,text ...)\n   *\n   * @memberof Flowchart\n   */\n  applyStates(): this {\n    // $GF.log.info(`flowchart[${this.data.name}].applyStates()`);\n    if (this.stateHandler) {\n      this.stateHandler.applyStates();\n    }\n    return this;\n  }\n\n  /**\n   * Apply options\n   *\n   * @memberof Flowchart\n   */\n  applyOptions() {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'applyOptions()');\n    if (this.xgraph) {\n      this.xgraph.applyGraph();\n    }\n    trc.after();\n  }\n\n  /**\n   * Refresh graph\n   *\n   * @memberof Flowchart\n   */\n  refresh() {\n    if (this.xgraph) {\n      this.xgraph.refresh();\n    }\n  }\n\n  /**\n   * Reset and redraw graph when source changed\n   *\n   * @param {*} xmlGraph\n   * @memberof Flowchart\n   */\n  redraw(content?: string) {\n    if (content !== undefined) {\n      this.setContent(content);\n    }\n    if (this.xgraph !== undefined) {\n      this.xgraph.setContent(this.getContent());\n    }\n    // this.applyOptions();\n  }\n\n  /**\n   * Reload source of graph\n   *\n   * @memberof Flowchart\n   */\n  reload() {\n    if (this.xgraph !== undefined && this.xgraph !== null) {\n      this.xgraph.destroyGraph();\n      this.xgraph = undefined;\n      this.init();\n    } else {\n      this.init();\n    }\n  }\n\n  /**\n   * Destroy this flowchart correctly\n   *\n   * @memberof Flowchart\n   */\n  destroy() {\n    this.toBack();\n    if (this.xgraph !== undefined && this.xgraph !== null) {\n      this.xgraph.destroyGraph();\n      this.xgraph = undefined;\n    }\n    this.container.remove();\n  }\n\n  /**\n   * Set the name\n   *\n   * @param {string} name\n   * @memberof Flowchart\n   */\n  setName(name: string) {\n    this.data.name = name;\n  }\n\n  getName(): string {\n    return this.data.name;\n  }\n\n  /**\n   * Set paramater lock\n   *\n   * @param {boolean} bool\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  setLock(bool: boolean): this {\n    this.data.lock = bool;\n    if (this.xgraph) {\n      this.xgraph.lock = bool;\n    }\n    return this;\n  }\n\n  /**\n   * Lock graph\n   *\n   * @param {boolean} bool\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  applyLock(bool: boolean): this {\n    if (bool !== undefined) {\n      this.data.lock = bool;\n    }\n    if (this.xgraph) {\n      this.xgraph.lockGraph(this.data.lock);\n    }\n    return this;\n  }\n\n  /**\n   * Set enable tooltip\n   *\n   * @param {boolean} bool\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  setTooltip(bool: boolean): this {\n    this.data.tooltip = bool;\n    if (this.xgraph) {\n      this.xgraph.tooltip = bool;\n    }\n    return this;\n  }\n\n  /**\n   * Enable tooltip\n   *\n   * @param {boolean} bool\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  applyTooltip(bool: boolean): this {\n    if (bool !== undefined) {\n      this.data.tooltip = bool;\n    }\n    if (this.xgraph) {\n      this.xgraph.tooltipGraph(this.data.tooltip);\n    }\n    return this;\n  }\n\n  /**\n   * Set scale parameter\n   *\n   * @param {boolean} bool\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  setScale(bool: boolean): this {\n    this.data.scale = bool;\n    if (this.xgraph) {\n      this.xgraph.scale = bool;\n    }\n    return this;\n  }\n\n  /**\n   * Set BgColor\n   *\n   * @param {(string | null)} bgColor\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  setBgColor(bgColor: string | null): this {\n    this.data.bgColor = bgColor;\n    if (this.xgraph) {\n      this.xgraph.bgColor = bgColor;\n    }\n    return this;\n  }\n\n  /**\n   * Apply Background color\n   *\n   * @param {string} bgColor\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  ApplyBgColor(bgColor: string): this {\n    this.data.bgColor = bgColor;\n    if (bgColor) {\n      if (this.xgraph) {\n        this.xgraph.bgGraph(bgColor);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Apply scale parameter\n   *\n   * @param {boolean} bool\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  applyScale(bool: boolean): this {\n    if (bool !== undefined) {\n      this.data.scale = bool;\n    }\n    if (this.xgraph) {\n      this.xgraph.scaleGraph(this.data.scale);\n    }\n    return this;\n  }\n\n  /**\n   * set center parameter\n   *\n   * @param {boolean} bool\n   * @returns\n   * @memberof Flowchart\n   */\n  setCenter(bool: boolean) {\n    this.data.center = bool;\n    if (this.xgraph) {\n      this.xgraph.center = bool;\n    }\n    return this;\n  }\n\n  /**\n   * Get names array of names according id or value\n   *\n   * @param {gf.TPropertieKey} prop\n   * @returns {string[]}\n   * @memberof Flowchart\n   */\n  getNamesByProp(prop: gf.TPropertieKey): string[] {\n    if (this.xgraph) {\n      return this.xgraph.getOrignalCells(prop);\n    }\n    return [];\n  }\n\n  /**\n   * get XML def with var replaced\n   *\n   * @param {boolean} replaceVarBool\n   * @returns {string}\n   * @memberof Flowchart\n   */\n  getXml(replaceVarBool: boolean = true): string {\n    if (!replaceVarBool) {\n      return this.data.xml;\n    }\n    return this.templateSrv.replaceWithText(this.data.xml);\n  }\n\n  /**\n   * get CSV def with var replaced\n   *\n   * @param {boolean} replaceVarBool\n   * @returns {string}\n   * @memberof Flowchart\n   */\n  getCsv(replaceVarBool: boolean = true): string {\n    if (!replaceVarBool) {\n      return this.data.csv;\n    }\n    return this.templateSrv.replaceWithText(this.data.csv);\n  }\n\n  /**\n   * Get data source according type\n   *\n   * @param {boolean} [replaceVarBool=true]\n   * @returns\n   * @memberof Flowchart\n   */\n  getSource(replaceVarBool: boolean = true) {\n    if (this.data.type === 'xml') {\n      return this.getXml(replaceVarBool);\n    }\n    if (this.data.type === 'csv') {\n      return this.getCsv(replaceVarBool);\n    }\n    return '';\n  }\n\n  /**\n   * Get Source of graph (csv|xml) or get content from url\n   *\n   * @param {boolean} replaceVarBool\n   * @returns\n   * @memberof Flowchart\n   */\n  getContent(replaceVarBool: boolean = true): string {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'getContent()');\n    let content: string | null = '';\n    if (this.data.download) {\n      const url = this.templateSrv.replaceWithText(this.data.url);\n      $GF.message.setMessage(`Loading content definition for ${this.data.name}`, 'info');\n      content = this.loadContent(url);\n      $GF.message.clearMessage();\n      if (content !== null) {\n        if (replaceVarBool) {\n          content = this.templateSrv.replaceWithText(content);\n        }\n      }\n    } else {\n      content = this.getSource(replaceVarBool);\n    }\n    trc.after();\n    return content === null ? '' : content;\n  }\n\n  /**\n   * Set the data source\n   *\n   * @param {string} content\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  setContent(content: string): this {\n    if (this.data.type === 'xml') {\n      this.data.xml = content;\n    }\n    if (this.data.type === 'csv') {\n      this.data.csv = content;\n    }\n    return this;\n  }\n\n  /**\n   * Load source from url\n   *\n   * @param {*} url\n   * @returns\n   * @memberof Flowchart\n   */\n  loadContent(url: string): string | null {\n    return $GF.utils.$loadFile(url);\n  }\n\n  renameId(oldId: string, newId: string): this {\n    if (this.xgraph) {\n      this.xgraph.renameId(oldId, newId);\n    }\n    return this;\n  }\n\n  /**\n   * Apply xml to graph\n   *\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  applyModel(): this {\n    if (this.xgraph) {\n      this.data.xml = this.xgraph.getXmlModel();\n    }\n    this.redraw();\n    return this;\n  }\n\n  center(bool: boolean): this {\n    if (bool !== undefined) {\n      this.data.center = bool;\n    }\n    if (this.xgraph) {\n      this.xgraph.centerGraph(this.data.center);\n    }\n    return this;\n  }\n\n  setZoom(percent: string): this {\n    this.data.zoom = percent;\n    if (this.xgraph) {\n      this.xgraph.zoomPercent = percent;\n    }\n    return this;\n  }\n\n  zoom(percent: string): this {\n    if (percent !== undefined) {\n      this.data.zoom = percent;\n    }\n    if (this.xgraph) {\n      this.xgraph.zoomGraph(this.data.zoom);\n    }\n    return this;\n  }\n\n  setGrid(bool: boolean): this {\n    this.data.grid = bool;\n    if (this.xgraph) {\n      this.xgraph.grid = bool;\n    }\n    return this;\n  }\n\n  grid(bool: boolean): this {\n    if (bool !== undefined) {\n      this.data.grid = bool;\n    }\n    if (this.xgraph) {\n      this.xgraph.gridGraph(this.data.grid);\n    }\n    return this;\n  }\n\n  setXml(xml: string): this {\n    this.data.xml = xml;\n    return this;\n  }\n\n  setCsv(csv: string): this {\n    this.data.csv = csv;\n    return this;\n  }\n\n  minify() {\n    this.data.xml = $GF.utils.minify(this.data.xml);\n  }\n\n  prettify() {\n    this.data.xml = $GF.utils.prettify(this.data.xml);\n  }\n\n  decode() {\n    if ($GF.utils.isencoded(this.data.xml)) {\n      this.data.xml = $GF.utils.decode(this.data.xml, true, true, true);\n      // this.data.xml = XGraph.decompress(this.data.xml);\n    }\n  }\n\n  encode() {\n    if (!$GF.utils.isencoded(this.data.xml)) {\n      this.data.xml = $GF.utils.encode(this.data.xml, true, true, true);\n      // this.data.xml = XGraph.compress(this.data.xml);\n    }\n  }\n\n  getContainer(): HTMLDivElement {\n    return this.container;\n  }\n\n  setMap(onMappingObj: gf.TIOnMappingObj) {\n    const container = this.getContainer();\n    if (this.xgraph) {\n      this.xgraph.setMap(onMappingObj);\n    }\n    container.scrollIntoView();\n    container.focus();\n  }\n\n  unsetMap() {\n    if (this.xgraph) {\n      this.xgraph.unsetMap();\n    }\n  }\n\n  toFront(forceRefresh: boolean = false): this {\n    $GF.log.debug('toFront', this.data.name);\n    this.visible = true;\n    this.container.className = 'GF_flowchartShow';\n    if (forceRefresh) {\n      this.applyOptions();\n    }\n    return this;\n  }\n\n  toBack(): this {\n    $GF.log.debug('toBack', this.data.name);\n    this.visible = false;\n    this.container.className = 'GF_flowchartHide';\n    return this;\n  }\n\n  isVisible(): boolean {\n    return this.visible;\n  }\n}\n","import { MetricsPanelCtrl } from 'grafana/app/plugins/sdk';\n// import { appEvents } from 'grafana/app/core/core';\nimport { mappingOptionsTab } from 'mapping_options';\nimport { flowchartOptionsTab } from 'flowchart_options';\nimport { inspectOptionsTab } from 'inspect_options';\nimport { RulesHandler } from 'rulesHandler';\nimport { FlowchartHandler } from 'flowchartHandler';\nimport { MetricHandler } from 'metricHandler';\n// import { PanelEvents } from '@grafana/data';\nimport { $GF } from 'globals_class';\nimport XGraph from 'graph_class';\nimport grafana from 'grafana_func';\nimport _ from 'lodash';\n\nclass FlowchartCtrl extends MetricsPanelCtrl {\n  $rootScope: any;\n  $scope: any;\n  templateSrv: any;\n  version: any;\n  changedSource: boolean;\n  changedData: boolean;\n  changedOptions: boolean;\n  rulesHandler: RulesHandler | undefined;\n  flowchartHandler: FlowchartHandler | undefined;\n  metricHandler: MetricHandler | undefined;\n  GHApplied = false;\n  panelDefaults: {\n    newFlag: boolean;\n    format: string;\n    valueName: string;\n    rulesData: gf.TIRulesHandlerData;\n    flowchartsData: gf.TFlowchartHandlerData;\n  };\n  containerDivId: string;\n  static templateUrl: string;\n  /**@ngInject*/\n  constructor($scope, $injector, $rootScope, templateSrv) {\n    super($scope, $injector);\n    $GF.init($scope, templateSrv, this.dashboard);\n    this.$rootScope = $rootScope;\n    this.$scope = $scope;\n    $scope.editor = this;\n    this.version = $GF.plugin.getVersion();\n    this.templateSrv = templateSrv;\n    this.changedSource = true;\n    this.changedData = true;\n    this.changedOptions = true;\n    this.rulesHandler = undefined;\n    this.flowchartHandler = undefined;\n    this.metricHandler = undefined;\n    this.panelDefaults = {\n      newFlag: true,\n      format: 'short',\n      valueName: 'current',\n      rulesData: RulesHandler.getDefaultData(),\n      flowchartsData: FlowchartHandler.getDefaultData(),\n    };\n\n    _.defaults(this.panel, this.panelDefaults);\n    this.panel.graphId = `flowchart_${this.panel.id}`;\n    this.containerDivId = `container_${this.panel.graphId}`;\n\n    // events\n    this.events.on(grafana.PanelEvents.render, this.onRender.bind(this));\n    this.events.on(grafana.PanelEvents.refresh, this.onRefresh.bind(this));\n    this.events.on(grafana.PanelEvents.dataReceived, this.onDataReceived.bind(this));\n    this.events.on(grafana.PanelEvents.dataError, this.onDataError.bind(this));\n    this.events.on(grafana.PanelEvents.dataSnapshotLoad, this.onDataReceived.bind(this));\n    this.events.on(grafana.PanelEvents.editModeInitialized, this.onInitEditMode.bind(this));\n    // this.events.on('init-panel-actions', this.onInitPanelActions.bind(this));\n    // this.events.on('template-variable-value-updated', this.onVarChanged.bind(this));\n    // grafana.PanelEvents.on('graph-hover', this.onGraphHover.bind(this), this.$scope);\n    // grafana.PanelEvents.on('graph-hover-clear', this.clearCrosshair.bind(this), this.$scope);\n    grafana.appEvents.on('graph-hover', this.onGraphHover.bind(this), this.$scope);\n    grafana.appEvents.on('graph-hover-clear', this.clearCrosshair.bind(this), this.$scope);\n    this.dashboard.events.on('template-variable-value-updated', this.onVarChanged.bind(this), $scope);\n    // if ($scope.$root.onAppEvent) {\n    //   $scope.$root.onAppEvent('template-variable-value-updated', this.onVarChanged.bind(this), $scope);\n    //   // $scope.$root.onAppEvent('graph-hover', this.onVarChanged.bind(this), $scope);\n    // }\n  }\n\n  //\n  // EVENTS FCT\n  //\n  onInitEditMode() {\n    this.addEditorTab('Flowchart', flowchartOptionsTab, 2);\n    this.addEditorTab('Mapping', mappingOptionsTab, 3);\n    this.addEditorTab('Inspect', inspectOptionsTab, 4);\n  }\n\n  onGraphHover(event: any) {\n    const self = this;\n    const flowchartHandler = this.flowchartHandler;\n    if (this.dashboard.sharedTooltipModeEnabled() && flowchartHandler !== undefined) {\n      const timestamp = event.pos.x;\n      const id = 'graph-hover';\n      $GF.clearUniqTimeOut(id);\n      const setGraphHover = () => {\n        $GF.setGraphHover(timestamp);\n        flowchartHandler.onGraphHoverChange();\n        self.render();\n        self.GHApplied = true;\n        $GF.clearUniqTimeOut(id);\n      };\n      $GF.setUniqTimeOut(setGraphHover, $GF.CONSTANTS.CONF_GRAPHHOVER_DELAY, id);\n    } else if (self.GHApplied) {\n      $GF.unsetGraphHover();\n    }\n  }\n\n  clearCrosshair(event: any) {\n    if (this.flowchartHandler !== undefined && this.GHApplied) {\n      const id = 'graph-hover';\n      this.GHApplied = false;\n      $GF.clearUniqTimeOut(id);\n      $GF.unsetGraphHover();\n      this.flowchartHandler.onGraphHoverChange();\n      this.render();\n    }\n  }\n\n  onRefresh() {\n    this.onRender();\n  }\n\n  onVarChanged() {\n    if (this.flowchartHandler !== undefined) {\n      this.flowchartHandler.onSourceChange();\n      this.flowchartHandler.render();\n    }\n  }\n\n  onRender() {}\n\n  onDataReceived(dataList) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'onDataReceived()');\n    if (!!this.metricHandler) {\n      this.metricHandler.initData(dataList);\n      if (!!this.flowchartHandler) {\n        this.flowchartHandler.onDatasChange();\n      }\n    }\n    this.render();\n    trc.after();\n    $GF.trace.resume();\n  }\n\n  onDataError() {\n    this.render();\n  }\n\n  // onInitPanelActions(actions) {\n  //   actions.push({\n  //     text: 'Export SVG',\n  //     click: 'ctrl.exportSVG()',\n  //   });\n  // }\n\n  //\n  // FUNCTIONS\n  //\n  link(scope, elem, attrs, ctrl) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'link()');\n\n    // MxGraph Init\n    XGraph.initMxGraph();\n\n    // $GF Containers\n    const $section = elem.find('#flowcharting-section');\n    const parent = $section[0];\n    $GF.setMessageDiv(parent);\n\n    // DATA\n    this.metricHandler = new MetricHandler();\n\n    // RULES\n    const newRulesData = RulesHandler.getDefaultData();\n    this.rulesHandler = new RulesHandler(newRulesData);\n    // for version < 0.4.0\n    if (this.panel.version === undefined && this.panel.styles !== undefined) {\n      this.rulesHandler.import(this.panel.styles);\n      delete this.panel.styles;\n    } else {\n      this.rulesHandler.import(this.panel.rulesData);\n    }\n    if (this.panel.newFlag && this.rulesHandler.countRules() === 0) {\n      this.rulesHandler.addRule('.*');\n    }\n    this.panel.rulesData = newRulesData;\n\n    // FLOWCHART\n    const newFlowchartsData = FlowchartHandler.getDefaultData();\n    this.flowchartHandler = new FlowchartHandler(scope, elem, ctrl, newFlowchartsData);\n    // for version < 0.4.0\n    if (this.panel.version === undefined && this.panel.flowchart !== undefined) {\n      this.flowchartHandler.import([this.panel.flowchart]);\n      delete this.panel.flowchart;\n    } else {\n      this.flowchartHandler.import(this.panel.flowchartsData);\n    }\n    if (this.panel.newFlag && this.flowchartHandler.countFlowcharts() === 0) {\n      this.flowchartHandler.addFlowchart('Main').init();\n    }\n    this.panel.flowchartsData = newFlowchartsData;\n\n    // Position to main flowchart\n    // this.flowchartHandler.setCurrentFlowchart('Main');\n\n    // Versions\n    this.panel.newFlag = false;\n    this.panel.version = this.version;\n    trc.after();\n  }\n\n  displayMultiCursor(): boolean {\n    if (this.flowchartHandler) {\n      return this.flowchartHandler.isMultiFlowcharts();\n    }\n    return false;\n  }\n\n  displayFirstCursor(): boolean {\n    if (this.flowchartHandler) {\n      return !this.flowchartHandler?.isCurrentfirst();\n    }\n    return false;\n  }\n\n  displayLastCursor(): boolean {\n    if (this.flowchartHandler) {\n      return !this.flowchartHandler?.isCurrentLast();\n    }\n    return false;\n  }\n\n  displayNextFlowchart() {\n    if (this.flowchartHandler) {\n      this.flowchartHandler.setNextFlowchart();\n    }\n  }\n\n  displayPreviousFlowchart() {\n    if (this.flowchartHandler) {\n      this.flowchartHandler.setPreviousFlowchart();\n    }\n  }\n\n  // exportSVG() {\n  //   const scope = this.$scope.$new(true);\n  //   scope.panel = 'table';\n  //   this.publishAppEvent('show-modal', {\n  //     templateHtml: '<export-data-modal panel=\"panel\" data=\"tableData\"></export-data-modal>',\n  //     scope,\n  //     modalClass: 'modal--narrow',\n  //   });\n  // }\n\n  // setUnitFormat(subItem) {\n  //   this.panel.format = subItem.value;\n  //   this.refresh();\n  // }\n\n  // getVariables() {\n  //   if (this.templateSrv !== undefined && this.templateSrv !== null) {\n  //     return _.map(this.templateSrv.variables, variable => `\\${${variable.name}}`);\n  //   }\n  //   return null;\n  // }\n\n  $onDestroy() {\n    $GF.destroy();\n  }\n}\n\nexport { FlowchartCtrl, FlowchartCtrl as MetricsPanelCtrl };\n\nFlowchartCtrl.templateUrl = './partials/module.html';\n","import { FlowchartHandler } from 'flowchartHandler';\n\nimport XGraph from 'graph_class';\nimport { Flowchart } from 'flowchart_class';\nimport { $GF } from 'globals_class';\n\nexport class FlowchartOptionsCtrl {\n  $scope: gf.TIFlowchartOptionsScope;\n  ctrl: any; //TODO: redefine any\n  flowchartHandler: FlowchartHandler;\n  panel: any;\n  sourceTypes = $GF.CONSTANTS.SOURCE_TYPES;\n  themes = $GF.CONSTANTS.DIOTHEME_TYPES;\n  errorSourceFlag = false;\n  errorSourceMsg = '';\n  errorDownloadFlag = false;\n  errorDownloadMsg = '';\n  editMode = false;\n  currentFlowchart: Flowchart | undefined;\n  newName = '';\n  currentFlowchartName = 'Main';\n  /** @ngInject */\n  constructor($scope: gf.TIFlowchartOptionsScope) {\n    $scope.editor = this;\n    $scope.$GF = $GF.me();\n    this.$scope = $scope;\n    this.ctrl = $scope.ctrl;\n    this.panel = this.ctrl.panel;\n    this.flowchartHandler = this.ctrl.flowchartHandler;\n    this.currentFlowchart = this.flowchartHandler.getFlowchart();\n  }\n\n  /**\n   * Render\n   *\n   * @memberof FlowchartOptionsCtrl\n   */\n  render() {\n    this.flowchartHandler.render();\n  }\n\n  /**\n   * onSourceChange event when source changes\n   *\n   * @memberof FlowchartOptionsCtrl\n   */\n  onSourceChange() {\n    const name = this.flowchartHandler.getCurrentFlowchartName();\n    this.flowchartHandler.onSourceChange(name);\n    this.render();\n  }\n\n  /**\n   * onOptionChange event when options change\n   *\n   * @memberof FlowchartOptionsCtrl\n   */\n  onOptionChange() {\n    const name = this.flowchartHandler.getCurrentFlowchartName();\n    this.flowchartHandler.onOptionsChange(name);\n    this.render();\n  }\n\n  // onColorChange() {\n  //   this.onOptionChange();\n  // }\n\n  checkSource_onSourceChange(source: string): boolean {\n    const bool = XGraph.isValidXml(source);\n    this.errorSourceFlag = !bool;\n    if (!bool) {\n      $GF.message.setMessage('Invalid Xml definition', 'error');\n    } else {\n      $GF.message.clearMessage();\n      this.onSourceChange();\n      this.$scope.$applyAsync();\n    }\n    return bool;\n  }\n\n  addFlowchart() {\n    this.editMode = true;\n    this.currentFlowchart = this.flowchartHandler.addFlowchart(this.flowchartHandler.getFlowchartTmpName());\n    this.currentFlowchart.init();\n    this.flowchartHandler.setCurrentFlowchart(this.currentFlowchart.getName());\n    $GF.message.setMessage(this.currentFlowchart.getName());\n    this.newName = this.currentFlowchart.getName();\n  }\n\n  removeFlowchart() {\n    const current = this.flowchartHandler.getCurrentFlowchart();\n    if (current !== undefined && current.getName() !== 'Main') {\n      this.currentFlowchart = this.flowchartHandler.setCurrentFlowchart();\n      this.currentFlowchartName = this.flowchartHandler.getCurrentFlowchartName();\n      $GF.message.setMessage(this.currentFlowchartName);\n      this.flowchartHandler.removeFlowchart(current.getName());\n    }\n  }\n\n  selectFlowchart() {\n    this.flowchartHandler.setCurrentFlowchart(this.flowchartHandler.currentFlowchartName);\n    this.currentFlowchart = this.flowchartHandler.getCurrentFlowchart();\n    if (this.currentFlowchart) {\n      this.currentFlowchartName = this.flowchartHandler.getCurrentFlowchartName();\n      $GF.message.setMessage(this.currentFlowchartName);\n    }\n  }\n\n  cancelFlowchart() {\n    this.editMode = false;\n    const canceled = this.currentFlowchart;\n    this.currentFlowchart = this.flowchartHandler.setCurrentFlowchart('Main');\n    if (canceled) {\n      this.flowchartHandler.removeFlowchart(canceled.getName());\n      if (this.currentFlowchart) {\n        this.currentFlowchartName = this.currentFlowchart.getName();\n      }\n    }\n    $GF.message.setMessage(this.currentFlowchartName);\n  }\n\n  isValideFlowchart(): boolean {\n    const fcs = this.flowchartHandler.getFlowchartNames();\n    if (this.newName === undefined) {\n      return false;\n    }\n    if (this.newName.length === 0) {\n      return false;\n    }\n    if (fcs.includes(this.newName) && this.currentFlowchart && this.newName !== this.currentFlowchart.getName()) {\n      $GF.message.setMessage(`Flowchart with name \"${this.newName}\" already exist`, 'error');\n      return false;\n    }\n    return true;\n  }\n\n  validateFlowchart() {\n    this.editMode = false;\n    if (this.currentFlowchart) {\n      this.currentFlowchart.setName(this.newName);\n    }\n    this.currentFlowchartName = this.newName;\n    this.currentFlowchart = this.flowchartHandler.setCurrentFlowchart(this.newName);\n  }\n\n  checkUrl_onSourceChange(url: string): boolean {\n    this.errorDownloadFlag = false;\n    // this.errorDownloadMsg = '';\n    const init: RequestInit = { method: 'GET', mode: 'cors', cache: 'default' };\n    try {\n      url = this.ctrl.templateSrv.replaceWithText(url);\n      fetch(url, init)\n        .then(response => {\n          if (!(response.status >= 200 && response.status <= 299)) {\n            this.errorSourceFlag = true;\n            // this.errorDownloadMsg = `Error ${response.status} : ${response.statusText}`;\n            $GF.message.setMessage(`Error ${response.status} : ${response.statusText}`, 'error');\n            this.$scope.$applyAsync();\n          } else {\n            response.text().then(text => {\n              const fc = this.flowchartHandler.getCurrentFlowchart();\n              if (fc && fc.data.type === 'xml') {\n                const bool = XGraph.isValidXml(text);\n                this.errorSourceFlag = !bool;\n                if (this.errorSourceFlag) {\n                  $GF.message.setMessage('Response is an invalid Xml definition', 'error');\n                  $GF.log.error('Response is an invalid Xml definition');\n                  // this.errorSourceMsg = 'Response is an invalid Xml definition';\n                } else {\n                  $GF.message.clearMessage();\n                  // this.errorDownloadMsg = '';\n                  this.onSourceChange();\n                }\n              } else {\n                // this.errorDownloadMsg = '';\n                this.onSourceChange();\n              }\n              this.$scope.$applyAsync();\n            });\n          }\n        })\n        .catch(error => {\n          this.errorSourceFlag = true;\n          // this.errorDownloadMsg = `Error : ${error}`;\n          $GF.message.setMessage(`Error : ${error}`, 'error');\n          this.$scope.$applyAsync();\n        });\n    } catch (error) {\n      this.errorDownloadFlag = true;\n      $GF.message.setMessage('Error when call url', 'error');\n      // this.errorDownloadMsg = 'Error when call url';\n    }\n    return true;\n  }\n\n  /**\n   * Open graph in index in draw.io\n   *\n   * @param {Number} name - index of graph\n   * @memberof FlowchartOptionsCtrl\n   * @see flowchartHandler:openDrawEditor\n   */\n  edit(name: string) {\n    this.flowchartHandler.openDrawEditor(name);\n  }\n\n  getFlowcharts() {\n    return this.flowchartHandler.getFlowcharts();\n  }\n\n  getNames(): string[] {\n    return this.flowchartHandler.getFlowchartNames();\n  }\n\n  getCurrentFlowchart(): Flowchart[] {\n    const current = this.flowchartHandler.getCurrentFlowchart();\n    if (current) {\n      return [current];\n    }\n    return [this.flowchartHandler.flowcharts[0]];\n  }\n}\n\n/** @ngInject */\nexport function flowchartOptionsTab($q, $sce, uiSegmentSrv) {\n  return {\n    restrict: 'E',\n    scope: true,\n    templateUrl: `${$GF.plugin.getPartialPath()}/flowchart/index.html`,\n    controller: FlowchartOptionsCtrl,\n  };\n}\n","import _ from 'lodash';\nclass GFCONSTANT {\n  // CONFIG\n  CONF_PATH_LIBS = 'libs/';\n  CONF_PATH_DRAWIO = 'libs/drawio/';\n  CONF_PATH_STATIC = 'static/';\n  CONF_PATH_PARTIALS = 'partials/';\n  CONF_PATH_STYLES = 'styles/';\n  CONF_FILE_PLUGINJSON = './plugin.json';\n  CONF_FILE_DEFAULTDIO = 'static/defaultGraph.drawio';\n  CONF_FILE_DEFAULTCSV = 'static/defaultGraph.csv';\n  CONF_FILE_SHAPESTXT = 'static/shapes.txt';\n  CONF_FILE_APPJS = 'libs/drawio/js/app.min.js';\n  CONF_FILE_SHAPESJS = 'libs/drawio/js/shapes.min.js';\n  CONF_FILE_VIEWERJS = 'libs/drawio/js/viewer.min.js';\n  CONF_FILE_PRECONFIGJS = 'libs/drawio/js/PreConfig.js';\n  CONF_FILE_POSTCONFIGJS = 'libs/drawio/js/PostConfig.js';\n  CONF_TOOLTIPS_DELAY = 200;\n  CONF_GRAPHHOVER_DELAY = 50;\n  CONF_COLORS_STEPS = 5;\n  CONF_COLORS_MS = 50;\n  CONF_ANIMS_STEP = 5;\n  CONF_ANIMS_MS = 50;\n  CONF_GFMESSAGE_MS = 5000;\n  CONF_BLINK_COLOR = '#f5f242';\n\n  // GLOBAL VARIABLE\n  VAR_STG_SHAPES = 'shapestext';\n  VAR_TBL_SHAPES = 'shapesarray';\n  VAR_STR_VIEWERJS = 'viewer.min.js';\n  VAR_STR_SHAPESJS = 'shapes.min.js';\n  VAR_STG_CTXROOT = 'contextroot';\n  VAR_NUM_GHTIMESTAMP = 'graph-hover-timestamp';\n  VAR_OBJ_TEMPLATESRV = 'templatesrv';\n  VAR_OBJ_CTRL = 'ctrl';\n  VAR_OBJ_DASHBOARD = 'dashboard';\n  VAR_MAP_INTERVAL = 'interval';\n  VAR_MAP_TIMEOUT = 'timeout';\n  VAR_STR_RULENAME: gf.TVariableKeys = '_rule';\n  VAR_NUM_LEVEL: gf.TVariableKeys = '_level';\n  VAR_NUM_VALUE: gf.TVariableKeys = '_value';\n  VAR_STR_FORMATED: gf.TVariableKeys = '_formated';\n  VAR_STR_COLOR: gf.TVariableKeys = '_color';\n\n  // FLOWCHART CHANGE KEY FLAG\n  FLOWCHART_CHG_SOURCES: gf.TFlowchartFlagKeys = 'sources';\n  FLOWCHART_CHG_OPTIONS: gf.TFlowchartFlagKeys = 'options';\n  FLOWCHART_APL_OPTIONS: gf.TFlowchartFlagKeys = 'applyOptions';\n  FLOWCHART_CHG_DATAS: gf.TFlowchartFlagKeys = 'datas';\n  FLOWCHART_CHG_RULES: gf.TFlowchartFlagKeys = 'rules';\n  FLOWCHART_CHG_GRAPHHOVER: gf.TFlowchartFlagKeys = 'graphHover';\n  FLOWCHART_CHG_HIDDENCHANGE: gf.TFlowchartFlagKeys = 'hiddenChange';\n\n  // CONDITIONS\n  TOOLTIP_APPLYON: gf.TTooltipOnList = [\n    { text: 'Warning / Critical', value: 'wc' },\n    { text: 'Always', value: 'a' },\n  ];\n  COLOR_APPLYON: gf.TColorOnList = [\n    { text: 'Never', value: 'n' },\n    { text: 'Warning / Critical', value: 'wc' },\n    { text: 'Always', value: 'a' },\n  ];\n  TEXT_APPLYON: gf.TTextOnList = [\n    { text: 'Never', value: 'n' },\n    { text: 'When Metric Displayed', value: 'wmd' },\n    { text: 'Warning / Critical', value: 'wc' },\n    { text: 'Critical Only', value: 'co' },\n  ];\n  LINK_APPLYON: gf.TLinkOnList = [\n    { text: 'Warning / Critical', value: 'wc' },\n    { text: 'Always', value: 'a' },\n  ];\n\n  // TYPES\n  VALUE_TYPES: gf.TValueTypeList = [\n    { text: 'Number', value: 'number' },\n    { text: 'String', value: 'string' },\n    { text: 'Date', value: 'date' },\n  ];\n  METRIC_TYPES: gf.TMetricTypeList = [\n    { text: 'Series', value: 'serie' },\n    { text: 'Table', value: 'table' },\n  ];\n  SOURCE_TYPES: gf.TSourceTypeList = [\n    { text: 'XML', value: 'xml' },\n    { text: 'CSV', value: 'csv' },\n  ];\n  DIOTHEME_TYPES: gf.TDioThemeList = [\n    { text: 'Dark', value: 'dark' },\n    { text: 'Light', value: 'kennedy' },\n    { text: 'Mobile', value: 'minimal' },\n    { text: 'atlas', value: 'atlas' },\n  ];\n  IDENT_TYPES: { text: string; value: gf.TPropertieKey }[] = [\n    { text: 'Id', value: 'id' },\n    { text: 'Label', value: 'value' },\n  ];\n  AGGREGATION_TYPES: gf.TAggregationList = [\n    { text: 'First', value: 'first' },\n    { text: 'First (not null)', value: 'first_notnull' },\n    { text: 'Last', value: 'current' },\n    { text: 'Last (not null)', value: 'current_notnull' },\n    { text: 'Min', value: 'min' },\n    { text: 'Max', value: 'max' },\n    { text: 'Sum', value: 'total' },\n    { text: 'Avg', value: 'avg' },\n    { text: 'Count', value: 'count' },\n    { text: 'Delta', value: 'delta' },\n    { text: 'Range', value: 'range' },\n    { text: 'Diff', value: 'diff' },\n    { text: 'Time of last point', value: 'last_time' },\n  ];\n  TOOLTIP_GRAPH_TYPES: gf.TGraphTypeList = [\n    { text: 'Line', value: 'line' },\n    { text: 'Histogram', value: 'bar' },\n  ];\n  TOOLTIP_GRAPH_SCALE_TYPES: gf.TGraphScaleList = [\n    { text: 'Linear', value: 'linear' },\n    { text: 'Logarithmic', value: 'log' },\n  ];\n  TOOLTIP_GRAPH_SIZE_TYPES: gf.TGraphSizeList = [\n    { text: 'Adjustable', value: '100%' },\n    { text: 'Small', value: '100px' },\n    { text: 'Medium', value: '200px' },\n    { text: 'Large', value: '400px' },\n  ];\n  TOOLTIP_DIRECTION_TYPES: gf.TDirectionList = [\n    { text: 'Vertical', value: 'v' },\n    { text: 'Horizontal ', value: 'h' },\n  ];\n  VALUE_DATEFORMAT_TYPES: gf.TDateFormatList = [\n    { text: 'YYYY-MM-DD HH:mm:ss', value: 'YYYY-MM-DD HH:mm:ss' },\n    { text: 'YYYY-MM-DD HH:mm:ss.SSS', value: 'YYYY-MM-DD HH:mm:ss.SSS' },\n    { text: 'MM/DD/YY h:mm:ss a', value: 'MM/DD/YY h:mm:ss a' },\n    { text: 'MMMM D, YYYY LT', value: 'MMMM D, YYYY LT' },\n    { text: 'YYYY-MM-DD', value: 'YYYY-MM-DD' },\n  ];\n\n  VALUEMAPPINGTYPES: gf.TValueMappingList = [\n    { text: 'Value to text', value: 1 },\n    { text: 'Range to text', value: 2 },\n  ];\n\n  // METHODS\n  TEXTMETHODS: gf.TTextMethodList = [\n    { text: 'All content', value: 'content' },\n    { text: 'Substring', value: 'pattern', placeholder: '/RegEx/' },\n    { text: 'Append (Space) ', value: 'as' },\n    { text: 'Append (New line) ', value: 'anl' },\n  ];\n  COLORMETHODS: gf.TStyleColorList = [\n    { text: 'Shape Stroke/Border', value: 'strokeColor' },\n    { text: 'Shape Fill', value: 'fillColor' },\n    { text: 'Shape Gradient', value: 'gradientColor' },\n    { text: 'Label font color', value: 'fontColor' },\n    { text: 'Label background color', value: 'labelBackgroundColor' },\n    { text: 'Label border color', value: 'labelBorderColor' },\n    { text: 'Image background', value: 'imageBackground' },\n    { text: 'Image border', value: 'imageBorder' },\n  ];\n  EVENTMETHODS: gf.TStyleEventList = [\n    { text: 'Shape : Change form (text)', value: 'shape', type: 'text', placeholder: 'Shape name' },\n    { text: 'Shape : Rotate Shape (0-360)', value: 'rotation', type: 'number', placeholder: '0-360', default: 0 },\n    { text: 'Shape : Blink (frequence ms)', value: 'blink', type: 'number', placeholder: 'Number in ms', default: 500 },\n    { text: 'Shape : Hide/Show (0|1)', value: 'visibility', type: 'number', placeholder: '0 or 1', typeahead: '0|1' },\n    { text: 'Shape : Height (number)', value: 'height', type: 'number', placeholder: 'Number of px' },\n    { text: 'Shape : Width (number)', value: 'width', type: 'number', placeholder: 'Number of px' },\n    { text: 'Shape : Resize (percent)', value: 'size', type: 'number', placeholder: 'percent' },\n    { text: 'Shape : Opacity (0-100)', value: 'opacity', type: 'number', placeholder: '0-100', default: 100 },\n    {\n      text: 'Shape : Gradient direction',\n      value: 'gradientDirection',\n      type: 'text',\n      placeholder: 'Direction name',\n      default: 'south',\n      typeahead: 'south|east|north|west',\n    },\n    {\n      text: 'Shape : Collapse/Expande (0|1)',\n      value: 'fold',\n      type: 'number',\n      placeholder: '0 or 1',\n      typeahead: '0|1',\n      default: '1',\n    },\n    { text: 'Shape : Change position in Bar (0-100)', value: 'barPos', type: 'number', placeholder: '0-100' },\n    {\n      text: 'Shape : Flip horizontally (0|1)',\n      value: 'flipH',\n      type: 'number',\n      placeholder: '0 or 1',\n      typeahead: '0|1',\n    },\n    { text: 'Shape : Flip vertically (0|1)', value: 'flipV', type: 'number', placeholder: '0 or 1', typeahead: '0|1' },\n    {\n      text: 'Arrow : change start marker (text)',\n      value: 'startArrow',\n      type: 'text',\n      placeholder: 'Marker',\n      typeahead:\n        'none|classic|classicThin|block|blockThin|open|openThin|oval|diamond|diamondThin|openAsync|async|box|halfCircle|dash|cross|circlePlus|circle|ERone|ERmandOne|ERoneToMany|ERzeroToOne',\n    },\n    {\n      text: 'Arrow : change end marker (text)',\n      value: 'endArrow',\n      type: 'text',\n      placeholder: 'Marker',\n      typeahead:\n        'none|classic|classicThin|block|blockThin|open|openThin|oval|diamond|diamondThin|openAsync|async|box|halfCircle|dash|cross|circlePlus|circle|ERone|ERmandOne|ERoneToMany|ERzeroToOne',\n    },\n    {\n      text: 'Arrow : Anime flow (frequence ms)',\n      value: 'class_mxEdgeFlow',\n      type: 'number',\n      placeholder: 'Number in ms',\n    },\n    { text: 'Label : Replace text (text)', value: 'text', type: 'text', placeholder: 'Text' },\n    { text: 'Label : Font Size (numeric)', value: 'fontSize', type: 'number', placeholder: 'Number' },\n    { text: 'Label : Opacity (numeric)', value: 'textOpacity', type: 'number', placeholder: '0-100', default: 100 },\n    { text: 'Image : Change URL (text)', value: 'image', type: 'text', placeholder: 'Url' },\n  ];\n\n  LOCALVARIABLENAMES: gf.TVariableList = [\n    { text: 'Name of the rule', value: this.VAR_STR_RULENAME },\n    { text: 'Current color according to the thresholds', value: this.VAR_STR_COLOR },\n    { text: 'Current raw value according to the aggregation', value: this.VAR_NUM_VALUE },\n    { text: 'Current level according to the thresholds', value: this.VAR_NUM_LEVEL },\n    { text: 'Current formated value accordingto the type', value: this.VAR_STR_FORMATED },\n  ];\n}\n\nexport class GFVariables {\n  _variables: Map<string, any>;\n  constructor() {\n    this._variables = new Map();\n  }\n\n  /**\n   * Get the full available vars names\n   *\n   * @static\n   * @returns {string[]}\n   * @memberof GFVariables\n   */\n  static getAvailableLocalVarNames(): string[] {\n    return $GF.CONSTANTS.LOCALVARIABLENAMES.map(x => '${' + x.value + '}');\n  }\n\n  /**\n   * set or redefine varaible\n   *\n   * @param {string} key\n   * @param {*} value\n   * @returns {this}\n   * @memberof GFVariables\n   */\n  set(key: gf.TVariableKeys, value: any): this {\n    this._variables.set(key, value);\n    return this;\n  }\n\n  unset(key: gf.TVariableKeys): this {\n    this._variables.delete(key);\n    return this;\n  }\n\n  /**\n   * Get variable value\n   *\n   * @param {string} key\n   * @returns {*}\n   * @memberof GFVariables\n   */\n  get(key: gf.TVariableKeys): any {\n    return this._variables.get(key);\n  }\n\n  /**\n   * Return the name of variables without ${}\n   *\n   * @returns {string[]}\n   * @memberof GFVariables\n   */\n  keys(): string[] {\n    return Array.from(this._variables.keys());\n  }\n\n  /**\n   * Return all local declared variables and grafana variables\n   *\n   * @returns {string[]}\n   * @memberof GFVariables\n   */\n  getFullVarsNames(): string[] {\n    return $GF.getGrafanaVars().concat(this.getVarsNames());\n  }\n\n  /**\n   * Get the full names of declared local vars\n   *\n   * @returns {string[]}\n   * @memberof GFVariables\n   */\n  getVarsNames(): string[] {\n    return this.keys().map(x => '${' + x + '}');\n  }\n\n  /**\n   * Clear all variables\n   *\n   * @returns {this}\n   * @memberof GFVariables\n   */\n  clear(): this {\n    this._variables.clear();\n    return this;\n  }\n\n  /**\n   * Replace text with variables\n   *\n   * @param {string} text\n   * @returns {string}\n   * @memberof GFVariables\n   */\n  replaceText(text: string): string {\n    try {\n      let templateSrv = $GF.getVar($GF.CONSTANTS.VAR_OBJ_TEMPLATESRV);\n      text = templateSrv !== undefined ? templateSrv.replaceWithText(text) : text;\n      for (let [key, value] of this._variables) {\n        text = text.replace('${' + key + '}', value);\n      }\n    } catch (error) {\n      return text;\n    }\n    return text;\n  }\n\n  /**\n   * Replace and eval text with variables\n   *\n   * @param {string} text\n   * @returns {string}\n   * @memberof GFVariables\n   */\n  eval(text: string): string {\n    let t = this.replaceText(text);\n    return $GF.utils.evalIt(t);\n  }\n}\n\nclass GFLog {\n  static DEBUG = 0;\n  static INFO = 1;\n  static WARN = 2;\n  static ERROR = 3;\n  static logLevel = GFLog.WARN;\n  static logDisplay = true;\n  constructor() {}\n\n  static init(): GFLog {\n    return new GFLog();\n  }\n\n  /**\n   * If message must be displayed\n   *\n   * @param {number} level (DEBUG : 0, INFO : 1, WARN:2, ERROR:3)\n   * @returns {boolean}\n   * @memberof Log\n   */\n  static toDisplay(level: number): boolean {\n    if (GFLog.logDisplay !== undefined && GFLog.logDisplay === true) {\n      if (GFLog.logLevel !== undefined && level >= GFLog.logLevel) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Display debug message in console\n   *\n   * @param {string} title\n   * @param {((any | undefined))} obj\n   * @memberof Log\n   */\n  async debug(...args) {\n    if (GFLog.toDisplay(GFLog.DEBUG)) {\n      const title = args.shift();\n      console.debug(`GF DEBUG : ${title}`, ...args);\n    }\n  }\n\n  /**\n   * Display warn message in console\n   *\n   * @param {string} title\n   * @param {((any | undefined))} obj\n   * @memberof Log\n   */\n  async warn(...args) {\n    if (GFLog.toDisplay(GFLog.WARN)) {\n      const title = args.shift();\n      console.warn(`GF WARN : ${title}`, ...args);\n    }\n  }\n\n  /**\n   * Display info message in console\n   *\n   * @param {string} title\n   * @param {((any | undefined))} obj\n   * @memberof Log\n   */\n  async info(...args) {\n    if (GFLog.toDisplay(GFLog.INFO)) {\n      const title = args.shift();\n      console.info(`GF INFO : ${title}`, ...args);\n    }\n  }\n\n  /**\n   * Display error message in console\n   *\n   * @param {string} title\n   * @param {((any | undefined))} obj\n   * @memberof Log\n   */\n  async error(...args) {\n    if (GFLog.toDisplay(GFLog.ERROR)) {\n      const title = args.shift();\n      console.error(`GF ERROR : ${title}`, ...args);\n    }\n  }\n}\n\nclass GFPlugin {\n  static data: any = require('./plugin.json');\n  static defaultContextRoot = '/public/plugins/agenty-flowcharting-panel/';\n  static contextRoot: string;\n  constructor() {}\n\n  /**\n   * init GFPlugin\n   *\n   * @static\n   * @param {*} $scope\n   * @param {*} templateSrv\n   * @returns {GFPlugin}\n   * @memberof GFPlugin\n   */\n  static init($scope: any, templateSrv: any, dashboard: any): GFPlugin {\n    let plug = new GFPlugin();\n    this.contextRoot = GFPlugin.defaultContextRoot;\n    if ($scope === undefined) {\n      this.contextRoot = __dirname;\n      if (this.contextRoot.length > 0) {\n        $GF.setVar($GF.CONSTANTS.VAR_STG_CTXROOT, this.contextRoot);\n      }\n    } else {\n      this.contextRoot = $scope.$root.appSubUrl + this.defaultContextRoot;\n    }\n    $GF.setVar($GF.CONSTANTS.VAR_OBJ_TEMPLATESRV, templateSrv);\n    $GF.setVar($GF.CONSTANTS.VAR_STG_CTXROOT, this.contextRoot);\n    $GF.setVar($GF.CONSTANTS.VAR_OBJ_DASHBOARD, dashboard);\n    return plug;\n  }\n\n  getRepo(): string {\n    let url = '';\n    GFPlugin.data.info.links.forEach((link: { name: string; url: string }) => {\n      if (link.name === 'Documentation') {\n        url = link.url;\n      }\n    });\n    return url;\n  }\n\n  /**\n   * Get version of plugin\n   *\n   * @returns {string}\n   * @memberof GFPlugin\n   */\n  getVersion(): string {\n    return GFPlugin.data.info.version;\n  }\n\n  /**\n   * Get root path\n   *\n   * @returns {string}\n   * @memberof GFPlugin\n   */\n  getRootPath(): string {\n    return $GF.getVar($GF.CONSTANTS.VAR_STG_CTXROOT);\n  }\n\n  /**\n   * Get libs path\n   *\n   * @returns {string}\n   * @memberof GFPlugin\n   */\n  getLibsPath(): string {\n    return `${$GF.getVar($GF.CONSTANTS.VAR_STG_CTXROOT)}libs/`;\n  }\n\n  /**\n   * Get Draw.io libs path\n   *\n   * @returns {string}\n   * @memberof GFPlugin\n   */\n  getDrawioPath(): string {\n    return `${this.getLibsPath()}drawio/`;\n  }\n\n  /**\n   * Get statics path\n   *\n   * @returns {string}\n   * @memberof GFPlugin\n   */\n  getStaticPath(): string {\n    return `${this.getRootPath()}static/`;\n  }\n\n  /**\n   * Get mxBasePath\n   * mxBasePath: Specifies the path in mxClient.basePath.\n   *\n   * @returns {string}\n   * @memberof GFPlugin\n   */\n  getMxBasePath(): string {\n    return `${this.getDrawioPath()}mxgraph/`;\n  }\n\n  /**\n   * Return Style path\n   *\n   * @returns {string}\n   * @memberof GFPlugin\n   */\n  getMxStylePath(): string {\n    return `${this.getDrawioPath()}styles/`;\n  }\n\n  /**\n   * Return shapes xml path for draw.io\n   *\n   * @returns {string}\n   * @memberof GFPlugin\n   */\n  getShapesPath(): string {\n    return `${this.getDrawioPath()}/shapes/`;\n  }\n\n  /**\n   * Return partial path\n   *\n   * @returns {string}\n   * @memberof GFPlugin\n   */\n  getPartialPath(): string {\n    return `${this.getRootPath()}partials/`;\n  }\n\n  /**\n   * Return stencils js path for draw.io\n   *\n   * @returns {string}\n   * @memberof GFPlugin\n   */\n  getStencilsPath(): string {\n    return `${this.getDrawioPath()}/stencils/`;\n  }\n\n  getMxCssPath(): string {\n    return `${this.getDrawioPath()}styles/`;\n  }\n\n  getMxResourcePath(): string {\n    return `${this.getMxBasePath()}css/`;\n  }\n\n  getMxImagePath(): string {\n    return `${this.getMxBasePath()}images/`;\n  }\n}\n\nclass GFMessage {\n  static container: HTMLDivElement;\n  static message: HTMLSpanElement;\n  static ERROR_MESSAGE = 'error';\n  static ERROR_COLOR = 'red';\n  static INFO_MESSAGE = 'info';\n  static INFO_COLOR = 'white';\n  static WARNING_MESSAGE = 'warning';\n  static WARNING_COLOR = 'yellow';\n\n  constructor(parent: HTMLElement) {\n    const container = parent.querySelector<HTMLDivElement>('div#flowcharting-message');\n    if (container !== null) {\n      GFMessage.container = container;\n      const span = container.querySelector<HTMLSpanElement>('#message-text');\n      if (span === null) {\n        GFMessage.message = document.createElement('span');\n        GFMessage.container.appendChild(GFMessage.message);\n      } else {\n        GFMessage.message = span;\n      }\n    }\n  }\n\n  static init(parentDiv: HTMLElement): GFMessage {\n    return new GFMessage(parentDiv);\n  }\n\n  async setMessage(message: string, type: string = GFMessage.INFO_MESSAGE) {\n    if (GFMessage.container && GFMessage.message) {\n      GFMessage.message.innerHTML = message;\n      switch (type) {\n        case GFMessage.INFO_MESSAGE:\n          GFMessage.message.style.color = GFMessage.INFO_COLOR;\n          break;\n        case GFMessage.ERROR_MESSAGE:\n          GFMessage.message.style.color = GFMessage.ERROR_COLOR;\n          break;\n        case GFMessage.WARNING_MESSAGE:\n          GFMessage.message.style.color = GFMessage.WARNING_COLOR;\n          break;\n\n        default:\n          GFMessage.message.style.color = GFMessage.INFO_COLOR;\n          break;\n      }\n      GFMessage.container.style.display = '';\n      $GF.setUniqTimeOut(this.clearMessage, $GF.CONSTANTS.CONF_GFMESSAGE_MS, 'flowcharting-message');\n    }\n  }\n\n  clearMessage() {\n    if (GFMessage.container && GFMessage.message) {\n      GFMessage.container.style.display = 'none';\n      GFMessage.message.innerHTML = '';\n    }\n    $GF.clearUniqTimeOut('flowcharting-message');\n  }\n}\n\n/**\n * Trace Perf class\n *\n * @class GFTrace\n */\nclass GFTrace {\n  static enable = false;\n  static trc = new Map();\n  static fn = new Map();\n  static indent = 0;\n  trace:\n    | {\n        Name: string;\n        Id: string;\n        Args: any;\n        Return: any;\n        Before: number;\n        End: number | undefined;\n        ExecTime: number | undefined;\n        Indent: number;\n      }\n    | undefined;\n\n  constructor(fn?: string) {\n    if (GFTrace.enable && fn !== undefined) {\n      this.trace = {\n        Name: fn,\n        Id: $GF.utils.uniqueID(),\n        Args: undefined,\n        Return: undefined,\n        Before: Date.now(),\n        End: undefined,\n        ExecTime: undefined,\n        Indent: GFTrace.indent,\n      };\n      GFTrace.trc.set(this.trace.Id, this.trace);\n    }\n  }\n\n  static init(): GFTrace {\n    return new GFTrace();\n  }\n\n  before(\n    fn: string | undefined\n  ):\n    | GFTrace\n    | {\n        after: () => void;\n      } {\n    if (GFTrace.enable && fn !== undefined) {\n      const t = new GFTrace(fn);\n      GFTrace.indent++;\n      GFTrace._inc(fn);\n      return t;\n    }\n    return { after: () => {} };\n  }\n\n  static _inc(fn) {\n    let f = GFTrace.fn.get(fn);\n    if (f === undefined) {\n      f = {\n        Calls: 0,\n        Function: fn,\n        TotalTimes: 0,\n      };\n    }\n    f.Calls++;\n    GFTrace.fn.set(fn, f);\n  }\n\n  async after() {\n    if (GFTrace.enable && this.trace !== undefined) {\n      if (this.trace) {\n        this.trace.End = Date.now();\n        GFTrace.indent--;\n      }\n    }\n  }\n\n  async clear() {\n    if (GFTrace.enable) {\n      GFTrace.trc.clear();\n      GFTrace.fn.clear();\n    }\n  }\n\n  enable() {\n    GFTrace.enable = true;\n  }\n\n  disable() {\n    GFTrace.enable = false;\n  }\n\n  isEnabled() {\n    return GFTrace.enable;\n  }\n\n  async resume() {\n    if (GFTrace.enable) {\n      let tb: any[] = [];\n      let fn: any[] = [];\n      GFTrace.trc.forEach(trace => {\n        trace.ExecTime = trace.End - trace.Before;\n        const f = GFTrace.fn.get(trace.Name);\n        f.TotalTimes += trace.ExecTime;\n        tb.push(trace);\n      });\n      console.table(tb, ['Indent', 'Name', 'ExecTime']);\n      GFTrace.fn.forEach(f => {\n        fn.push(f);\n      });\n      console.table(fn, ['Function', 'Calls', 'TotalTimes']);\n      this.clear();\n    }\n  }\n}\n\nexport class $GF {\n  static _globalvars: GFVariables = new GFVariables();\n  static CONSTANTS: GFCONSTANT = new GFCONSTANT();\n  static log: GFLog = GFLog.init();\n  static trace: GFTrace = GFTrace.init();\n  static message: GFMessage;\n  static plugin: GFPlugin;\n  static graphHover = false;\n  static GHTimeStamp = 0;\n  static DEBUG = false;\n  static utils: {\n    decode: (data: string, encode: boolean, deflate: boolean, base64: boolean) => string;\n    encode: (data: string, encode: boolean, deflate: boolean, base64: boolean) => string;\n    loadJS: (fname: string) => void;\n    sleep: (ms: number, mess?: string) => void;\n    uniqueID: () => string;\n    // getRatioColor: (ratio: number, colorStart: string, colorEnd: string) => string;\n    matchString: (str: string, pattern: string | undefined, regex?: boolean) => boolean;\n    stringToJsRegex: (str: string) => RegExp;\n    isencoded: (data: string) => boolean;\n    minify: (text: string) => string;\n    prettify: (text: string) => string;\n    getMarky: () => any;\n    // getStepColors: (colorStart: string, colorEnd: string, colorCount: number) => string[];\n    evalIt: (code: string) => string;\n    loadFile: (fname: string) => string;\n    $loadFile: (fname: string) => string;\n    $evalFile: (fname: string) => void;\n    evalRaw: (code: string) => void;\n    addScript: (src: string) => void;\n  } = require('./utils_raw');\n\n  static init($scope: any, templateSrv: any, dashboard: any): $GF {\n    this.plugin = GFPlugin.init($scope, templateSrv, dashboard);\n    if (this.DEBUG) {\n      console.log('DEBUG Scope', $scope);\n      console.log('DEBUG TemplateSrv', templateSrv);\n      console.log('DEBUG Theme', dashboard.style);\n      console.log('DEBUG dashboard', dashboard);\n    }\n    return this;\n  }\n\n  static me(): $GF {\n    return this;\n  }\n\n  /**\n   * Recover Meassage div in module.html\n   *\n   * @static\n   * @param {HTMLElement} html\n   * @memberof $GF\n   */\n  static setMessageDiv(html: HTMLElement) {\n    this.message = GFMessage.init(html);\n  }\n\n  /**\n   * Return the theme\n   *\n   * @static\n   * @returns {string}\n   * @memberof $GF\n   */\n  static getTheme(): string {\n    let templateSrv = $GF.getVar($GF.CONSTANTS.VAR_OBJ_TEMPLATESRV);\n    let theme = templateSrv !== undefined ? templateSrv.style : 'dark';\n    return theme;\n  }\n\n  /**\n   * Create and get local variables container\n   *\n   * @static\n   * @returns {GFVariables}\n   * @memberof GFGlobal\n   */\n  static createLocalVars(): GFVariables {\n    let _v = new GFVariables();\n    return _v;\n  }\n\n  /**\n   * Get global variables container\n   *\n   * @static\n   * @returns {GFVariables}\n   * @memberof GFGlobal\n   */\n  static getGlobalVars(): GFVariables {\n    if ($GF._globalvars === undefined) {\n      $GF._globalvars = new GFVariables();\n    }\n    return $GF._globalvars;\n  }\n\n  static getGrafanaVars(): string[] {\n    const templateSrv = $GF.getVar($GF.CONSTANTS.VAR_OBJ_TEMPLATESRV);\n    if (templateSrv !== undefined && templateSrv !== null) {\n      return _.map(templateSrv.variables, variable => `\\${${variable.name}}`);\n    }\n    return [];\n  }\n\n  /**\n   * Get global variable value\n   *\n   * @static\n   * @param {*} key\n   * @returns {*}\n   * @memberof GFGlobal\n   */\n  static getVar(key: any): any {\n    return $GF.getGlobalVars().get(key);\n  }\n\n  /**\n   * set global variable with value\n   *\n   * @static\n   * @param {*} key\n   * @param {*} value\n   * @memberof GFGlobal\n   */\n  static setVar(key: any, value: any) {\n    $GF.getGlobalVars().set(key, value);\n  }\n\n  static unsetVar(key: any) {\n    $GF.getGlobalVars().unset(key);\n  }\n\n  /**\n   * Get all available variables name\n   *\n   * @static\n   * @returns {string[]}\n   * @memberof GFGlobal\n   */\n  static getFullAvailableVarNames(): string[] {\n    return GFVariables.getAvailableLocalVarNames().concat($GF.getGrafanaVars());\n  }\n\n  static getIntervalCounter(begin: number, end: number, count: number, method: gf.TCounterKeys = 'linear'): number[] {\n    let result: number[] = [];\n    const distance = end - begin;\n    const step = Math.round(distance / count);\n    let current = begin;\n    let index = 0;\n    for (index = 0; index < count; index++) {\n      current += step;\n      result.push(current);\n    }\n    result[index] = end;\n    return result;\n  }\n\n  static setUniqTimeOut(fc: CallableFunction, timer: number, id?: string): string {\n    let timeout: Map<string, number> = $GF.getVar($GF.CONSTANTS.VAR_MAP_TIMEOUT);\n    if (timeout === undefined) {\n      timeout = new Map();\n      $GF.setVar($GF.CONSTANTS.VAR_MAP_TIMEOUT, timeout);\n    }\n    if (id !== undefined) {\n      this.clearUniqTimeOut(id);\n    }\n    const thread = window.setTimeout(fc, timer);\n    id = id === undefined ? thread.toString() : id;\n    timeout.set(id, thread);\n    return id;\n  }\n\n  static clearUniqTimeOut(id: string) {\n    const timeout: Map<string, number> = $GF.getVar($GF.CONSTANTS.VAR_MAP_TIMEOUT);\n    if (timeout !== undefined) {\n      try {\n        const tm = timeout.get(id);\n        if (tm !== undefined) {\n          timeout.delete(id);\n          window.clearTimeout(tm);\n        }\n      } catch (error) {\n        $GF.log.warn('Failed to clear timeout thread', id, error);\n      }\n    }\n  }\n\n  /**\n   * Add a new Intervall (window.setInterval)\n   *\n   * @static\n   * @param {CallableFunction} fc\n   * @param {number} timer\n   * @returns {number}\n   * @memberof GFGlobal\n   */\n  static setUniqInterval(fc: CallableFunction, timer: number, id?: string): string {\n    let interval: Map<string, number> = $GF.getVar($GF.CONSTANTS.VAR_MAP_INTERVAL);\n    if (interval === undefined) {\n      interval = new Map();\n      $GF.setVar($GF.CONSTANTS.VAR_MAP_INTERVAL, interval);\n    }\n    if (id !== undefined) {\n      this.clearUniqInterval(id);\n    }\n    const thread = window.setInterval(fc, timer);\n    id = id === undefined ? thread.toString() : id;\n    interval.set(id, thread);\n    return id;\n  }\n\n  /**\n   * Add/clear a  Intervall (window.clearInterval)\n   *\n   * @static\n   * @param {string} id\n   * @memberof GFGlobal\n   */\n  static clearUniqInterval(id: string) {\n    let interval: Map<string, number> = $GF.getVar($GF.CONSTANTS.VAR_MAP_INTERVAL);\n    if (interval !== undefined) {\n      try {\n        const int = interval.get(id);\n        interval.delete(id);\n        window.clearInterval(int);\n      } catch (error) {\n        $GF.log.warn('Failed to clear interval thread', id, error);\n      }\n    }\n  }\n\n  /**\n   * Load a file into variables\n   *\n   * @static\n   * @param {string} varName\n   * @param {string} fileName\n   * @memberof GFGlobal\n   */\n  static async loadLocalFile(varName: string, fileName: string) {\n    let v = $GF.getVar(varName);\n    if (v === undefined) {\n      const contextroot = $GF.getVar($GF.CONSTANTS.VAR_STG_CTXROOT);\n      if (contextroot !== undefined) {\n        const filePath = `${contextroot}/${fileName}`;\n        if (!!window.fetch) {\n          // excuter ma requte fetch ici\n          fetch(filePath)\n            .then(response => {\n              if (response.ok) {\n                response\n                  .text()\n                  .then(text => {\n                    $GF.log.info('loadLocalFile called succesfully', filePath);\n                    $GF.setVar(varName, text);\n                    return text;\n                  })\n                  .catch(error => $GF.log.error('Error when download text file', filePath, error));\n              }\n            })\n            .catch(error => $GF.log.error('Error when download file', filePath, error));\n        } else {\n          // Faire quelque chose avec XMLHttpRequest?\n          const txt = $GF.utils.loadFile(fileName);\n          if (txt) {\n            $GF.setVar(varName, $GF.utils.loadFile(fileName));\n            return txt;\n          }\n        }\n      } else {\n        $GF.log.warn('loadLocalFile Contexroot : ', contextroot);\n      }\n    }\n    return false;\n  }\n\n  static setGraphHover(timestamp: number) {\n    if (this.isGraphHoverEnabled()) {\n      this.graphHover = true;\n      this.GHTimeStamp = timestamp;\n    }\n  }\n\n  static unsetGraphHover() {\n    this.graphHover = false;\n    this.GHTimeStamp = 0;\n  }\n\n  static hasGraphHover(): boolean {\n    return this.graphHover && this.isGraphHoverEnabled();\n  }\n\n  static isGraphHoverEnabled(): boolean {\n    const dashboard = this.getVar($GF.CONSTANTS.VAR_OBJ_DASHBOARD);\n    return dashboard !== undefined && dashboard.sharedTooltipModeEnabled();\n  }\n\n  static getGraphHover(): number | undefined {\n    if (this.hasGraphHover()) {\n      // return this.getVar($GF.CONSTANTS.VAR_NUM_GHTIMESTAMP);\n      return this.GHTimeStamp;\n    }\n    return undefined;\n  }\n\n  /**\n   * Return Html for popup with links to documentation\n   *\n   * @param {string} text\n   * @param {string} tagBook\n   * @param {string} [tagImage]\n   * @returns {string}\n   * @memberof $GF\n   */\n  static popover(text: string, tagBook: string, tagImage?: string): string {\n    const url = $GF.plugin.getRepo();\n    const images = `${this.plugin.getRepo()}images/`;\n    const textEncoded = String(text)\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;');\n    const desc = `${textEncoded}`;\n    let book = '';\n    let image = '';\n    if (tagBook) {\n      book = `<a href=\"${url}${tagBook}\" target=\"_blank\"><i class=\"fa fa-book fa-fw\"></i>Help</a>`;\n    }\n    if (tagImage) {\n      image = `<a href=\"${images}${tagImage}.png\" target=\"_blank\"><i class=\"fa fa-image fa-fw\"></i>Example</a>`;\n    }\n    return `\n    <div id=\"popover\" style=\"display:flex;flex-wrap:wrap;width: 100%;\">\n      <div style=\"flex:1;height:100px;margin-bottom: 20px;\">${desc}</div>\n      <div style=\"flex:1;height:100px;margin-bottom: 20px;\">${book}</div>\n      <div style=\"flex-basis: 100%;height:100px;margin-bottom:20px;\">${image}</div>\n    </div>`;\n  }\n\n  static destroy() {\n    let interval: Set<any> = $GF.getVar($GF.CONSTANTS.VAR_MAP_INTERVAL);\n    if (interval !== undefined) {\n      interval.forEach(x => $GF.clearUniqInterval(x));\n      interval.clear();\n    }\n    let timeout: Set<any> = $GF.getVar($GF.CONSTANTS.VAR_MAP_TIMEOUT);\n    if (timeout !== undefined) {\n      timeout.forEach(x => $GF.clearUniqTimeOut(x));\n      timeout.clear();\n    }\n  }\n}\n","// import { getValueFormat } from '@grafana/data';\nimport kbn from 'grafana/app/core/utils/kbn';\nimport TimeSeries from 'grafana/app/core/time_series2';\nimport _ from 'lodash';\nimport { loadPluginCss, MetricsPanelCtrl } from 'grafana/app/plugins/sdk';\nimport { dateTime, PanelEvents } from '@grafana/data';\nimport appEvents from 'grafana/app/core/app_events';\n\nvar grafana = {\n  // formatValue(value, unit, decimals) {\n  //   const fmt = getValueFormat(unit);\n  //   const result = fmt(value, decimals).toString();\n  //   return result.toString();\n  // }\n  formatValue(value, unit, decimals) {\n    return kbn.valueFormats[unit](value, decimals, null).toString();\n  },\n\n  getUnitFormats() {\n    return kbn.getUnitFormats();\n  },\n\n  loadCss() {\n    loadPluginCss({\n      dark: 'plugins/agenty-flowcharting-panel/static/css/flowchart.dark.css',\n      light: 'plugins/agenty-flowcharting-panel/static/css/flowchart.light.css',\n    });\n  },\n\n  getTimeSeries(seriesData) {\n    return new TimeSeries({\n      datapoints: seriesData.datapoints || [],\n      alias: seriesData.target,\n      unit: seriesData.unit,\n    });\n  },\n\n  getFormatedDate(value, format) {\n    return dateTime(value).format(format);\n  },\n  appEvents: appEvents,\n  MetricsPanelCtrl: MetricsPanelCtrl,\n  PanelEvents: PanelEvents,\n};\n\nexport default grafana;\n","import _ from 'lodash';\nimport { $GF } from 'globals_class';\nimport * as Drawio from 'drawio_custom';\nimport chroma from 'chroma-js';\nimport { customize, evalCode } from 'mxgraph_custom';\n\ndeclare var mxEvent: any;\ndeclare var mxClient: any;\ndeclare var mxCodec: any;\ndeclare var mxUrlConverter: any;\ndeclare var mxCellOverlay: any;\ndeclare var mxConstants: any;\ndeclare var mxCellHighlight: any;\ndeclare var mxRectangle: any;\ndeclare var mxUtils: any;\ndeclare var Graph: any;\ndeclare var mxTooltipHandler: any;\n\n/**\n * mxGraph interface class\n *\n * @export\n * @class XGraph\n */\nexport default class XGraph {\n  static initialized = false;\n  container: HTMLDivElement;\n  xmlGraph = '';\n  csvGraph = '';\n  type: gf.TSourceTypeKeys = 'xml';\n  graph: any = undefined;\n  scale = true;\n  tooltip = true;\n  lock = true;\n  center = true;\n  animation = true;\n  zoom = false;\n  zoomFactor = 1.2;\n  cumulativeZoomFactor = 1;\n  grid = false;\n  bgColor: string | null = null;\n  zoomPercent = '1';\n  cells: { id: string[]; value: string[] } = {\n    id: [],\n    value: [],\n  };\n  clickBackup: any;\n  dbclickBackup: any;\n  onMapping: gf.TIOnMappingObj;\n  /**\n   * Creates an instance of XGraph.\n   * @param {DOM} container\n   * @param {string} definition\n   * @memberof XGraph\n   */\n  constructor(container: HTMLDivElement, type: gf.TSourceTypeKeys, definition: string) {\n    this.container = container;\n    this.type = type;\n    this.onMapping = {\n      active: false,\n      $scope: null,\n      value: null,\n      prop: 'id',\n      object: null,\n    };\n\n    // END ZOOM MouseWheele\n    XGraph.initMxGraph();\n    if (type === 'xml') {\n      if ($GF.utils.isencoded(definition)) {\n        this.xmlGraph = $GF.utils.decode(definition, true, true, true);\n      } else {\n        this.xmlGraph = definition;\n      }\n    }\n    if (type === 'csv') {\n      this.csvGraph = definition;\n    }\n    this.initGraph();\n    const self = this;\n    if ($GF.DEBUG) {\n      console.log('DEBUG ON');\n      this.graph.addListener(mxEvent.CLICK, (_sender, _evt) => {\n        console.log('DEBUG CLICK');\n        this.eventDebug(_evt);\n        if (_evt.properties.cell) {\n          const id = _evt.properties.cell.id;\n          const state = $GF.getVar(`STATE_${id}`);\n          console.log('DEBUG GF STATE', state);\n          const view = self.graph.view;\n          console.log('DEBUG CELL STATE', view.getState(_evt.properties.cell));\n        }\n      });\n    }\n  }\n\n  /**\n   * Valided XML definition\n   *\n   * @static\n   * @param {string} source\n   * @returns\n   * @memberof XGraph\n   */\n  static isValidXml(source: string) {\n    try {\n      const div = document.createElement('div');\n      const g = new Graph(div);\n      if ($GF.utils.isencoded(source)) {\n        source = $GF.utils.decode(source, true, true, true);\n      }\n      const xmlDoc = mxUtils.parseXml(source);\n      const codec = new mxCodec(xmlDoc);\n      g.getModel().beginUpdate();\n      codec.decode(xmlDoc.documentElement, g.getModel());\n      g.getModel().endUpdate();\n      g.destroy();\n      return true;\n    } catch (error) {\n      $GF.log.error('isValidXml', error);\n      return false;\n    }\n  }\n\n  /**\n   * Anonymize Graph\n   *\n   * @memberof XGraph\n   */\n  async anonymize() {\n    Drawio.anonymize(this.graph);\n  }\n\n  /**\n   * Init Global vars an libs for mxgraph\n   *\n   * @static\n   * @returns\n   * @memberof XGraph\n   */\n  static async initMxGraph() {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'initMxGgraph()');\n    let myWindow: any = window;\n    if (!XGraph.initialized) {\n      if (myWindow.mxGraph === undefined || myWindow.mxGraph === undefined) {\n        XGraph.preInitGlobalVars();\n        // let code = $GF.utils.$loadFile(`${$GF.plugin.getDrawioPath()}js/viewer.min.js`);\n        // $GF.utils.evalRaw(code);\n        // $GF.utils.$evalFile(`${$GF.plugin.getDrawioPath()}js/viewer.min.js`);\n        evalCode();\n        customize();\n        XGraph.postInitGlobalVars();\n        // let code = $GF.utils.$loadFile(`${$GF.plugin.getLibsPath()}/Graph_custom.js`);\n        // $GF.utils.evalRaw(code);\n        mxTooltipHandler.prototype.delay = $GF.CONSTANTS.CONF_TOOLTIPS_DELAY;\n      }\n      XGraph.initialized = true;\n    }\n    trc.after();\n  }\n\n  /**\n   * Init Vars for mxGraph\n   *\n   * @static\n   * @memberof XGraph\n   */\n  static preInitGlobalVars() {\n    const myWindow: any = window;\n    myWindow.BASE_PATH = $GF.plugin.getMxBasePath();\n    myWindow.RESOURCES_PATH = $GF.plugin.getMxResourcePath();\n    myWindow.RESOURCE_BASE = $GF.plugin.getMxResourcePath();\n    myWindow.STENCIL_PATH = $GF.plugin.getStencilsPath();\n    myWindow.SHAPES_PATH = $GF.plugin.getShapesPath();\n    myWindow.IMAGE_PATH = $GF.plugin.getMxImagePath();\n    myWindow.STYLE_PATH = $GF.plugin.getMxStylePath();\n    myWindow.CSS_PATH = $GF.plugin.getMxCssPath();\n    myWindow.mxLanguages = ['en'];\n    myWindow.DRAWIO_BASE_URL = $GF.plugin.getDrawioPath(); // Replace with path to base of deployment, e.g. https://www.example.com/folder\n    myWindow.DRAW_MATH_URL = $GF.plugin.getDrawioPath(); // Replace with path to base of deployment, e.g. https://www.example.com/folder\n    myWindow.DRAWIO_VIEWER_URL = $GF.plugin.getDrawioPath() + 'viewer.min.js'; // Replace your path to the viewer js, e.g. https://www.example.com/js/viewer.min.js\n    myWindow.DRAW_MATH_URL = $GF.plugin.getDrawioPath() + 'math/';\n    myWindow.DRAWIO_CONFIG = null; // Replace with your custom draw.io configurations. For more details, https://desk.draw.io/support/solutions/articles/16000058316\n    const urlParams = new Object();\n    myWindow.urlParams = urlParams;\n    urlParams['sync'] = 'none'; // Disabled realtime\n    urlParams['lightbox'] = '1'; // Uses lightbox in chromeless mode (larger zoom, no page visible, chromeless)\n    urlParams['nav'] = '1'; // Enables folding in chromeless mode\n    urlParams['local'] = '1'; // Uses device mode only\n    urlParams['embed'] = '1'; // Runs in embed mode\n    // const theme = $GF.getTheme();\n    // switch (theme) {\n    //   case 'dark':\n    //     urlParams['ui'] = 'dark';\n    //     break;\n\n    //   case 'light':\n    //     urlParams['ui'] = 'kennedy';\n    //     break;\n\n    //   default:\n    //     urlParams['ui'] = 'dark';\n    //     break;\n    // }\n    urlParams['ui'] = 'min';\n    myWindow.mxImageBasePath = $GF.plugin.getMxImagePath();\n    myWindow.mxBasePath = $GF.plugin.getMxBasePath();\n    myWindow.mxLoadStylesheets = true;\n    myWindow.mxLanguage = 'en';\n    myWindow.mxLoadResources = true;\n  }\n\n  static postInitGlobalVars() {\n    const myWindow: any = window;\n    myWindow.mxClient.mxBasePath = $GF.plugin.getMxBasePath();\n    myWindow.mxClient.mxImageBasePath = $GF.plugin.getMxImagePath();\n    myWindow.mxClient.mxLoadResources = true;\n    myWindow.mxClient.mxLanguage = 'en';\n    myWindow.mxClient.mxLoadStylesheets = true;\n    myWindow.VSD_CONVERT_URL = null;\n    myWindow.EMF_CONVERT_URL = null;\n    myWindow.ICONSEARCH_PATH = null;\n  }\n\n  /**\n   * Graph initilisation and reset\n   *\n   * @memberof XGraph\n   */\n  initGraph(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'initGraph()');\n    this.graph = new Graph(this.container);\n\n    // /!\\ What is setPannig\n    this.graph.setPanning(true);\n\n    // Backup funtions of clicks\n    this.clickBackup = this.graph.click;\n    this.dbclickBackup = this.graph.dblClick;\n\n    // EVENTS\n\n    // CTRL+MOUSEWHEEL\n    mxEvent.addMouseWheelListener(mxUtils.bind(this, this.eventMouseWheel), this.container);\n    if (mxClient.IS_IE || mxClient.IS_EDGE) {\n      mxEvent.addListener(this.container, 'wheel', mxUtils.bind(this, this.eventMouseWheel));\n    }\n\n    // KEYS\n    mxEvent.addListener(document, 'keydown', mxUtils.bind(this, this.eventKey));\n\n    // CONTEXT MENU\n    this.container.addEventListener('contextmenu', e => e.preventDefault());\n\n    // DB CLICK\n    this.graph.dblClick = this.eventDbClick.bind(this);\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Draw graph\n   *\n   * @returns {this}\n   * @memberof XGraph\n   */\n  drawGraph(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'drawGraph()');\n    this.graph.getModel().beginUpdate();\n    this.graph.getModel().clear();\n    try {\n      if (this.type === 'xml') {\n        const xmlDoc = mxUtils.parseXml(this.xmlGraph);\n        const codec = new mxCodec(xmlDoc);\n        this.graph.model.clear();\n        this.graph.view.scale = 1;\n        codec.decode(xmlDoc.documentElement, this.graph.getModel());\n        this.loadExtFont();\n        this.graph.updateCssTransform();\n        this.graph.selectUnlockedLayer();\n      }\n      if (this.type === 'csv') {\n        try {\n          Drawio.importCsv(this.graph, this.csvGraph);\n          this.refresh();\n        } catch (error) {\n          $GF.log.error('Bad CSV format', error);\n          $GF.message.setMessage('Bad CSV format');\n        }\n      }\n    } catch (error) {\n      $GF.log.error('Error in draw', error);\n    } finally {\n      this.cells['id'] = this.getCurrentCells('id');\n      this.cells['value'] = this.getCurrentCells('value');\n      this.graph.getModel().endUpdate();\n    }\n    trc.after();\n    return this;\n  }\n\n  async loadExtFont() {\n    const model = this.graph.getModel();\n    let extFonts = model.extFonts;\n    if (extFonts) {\n      try {\n        extFonts = extFonts.split('|').map(function(ef) {\n          var parts = ef.split('^');\n          return { name: parts[0], url: parts[1] };\n        });\n\n        for (var i = 0; i < extFonts.length; i++) {\n          // Drawio.addExtFont(extFonts[i].name, extFonts[i].url);\n          this.graph.addExtFont(extFonts[i].name, extFonts[i].url);\n        }\n      } catch (e) {\n        $GF.log.error('ExtFonts format error:', e.message);\n      }\n    }\n  }\n\n  /**\n   * Apply options on graph\n   *\n   * @return this\n   * @memberof XGraph\n   */\n  applyGraph(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'applyGraph()');\n    if (!this.scale) {\n      this.zoomGraph(this.zoomPercent);\n    } else {\n      this.unzoomGraph();\n    }\n    this.tooltipGraph(this.tooltip);\n    this.lockGraph(this.lock);\n    if (this.scale && this.center) {\n      this.fitGraph();\n    } else {\n      this.scaleGraph(this.scale);\n      this.centerGraph(this.center);\n    }\n    this.gridGraph(this.grid);\n    this.bgGraph(this.bgColor);\n    this.graph.foldingEnabled = true;\n    this.graph.cellRenderer.forceControlClickHandler = true;\n    this.refresh();\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Refresh graph\n   *\n   * @returns {this}\n   * @memberof XGraph\n   */\n  refresh(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'refresh()');\n    this.graph.refresh();\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Destroy Graph object and DOM\n   *\n   * @returns {this}\n   * @memberof XGraph\n   */\n  destroyGraph(): this {\n    this.graph.destroy();\n    this.graph = undefined;\n    return this;\n  }\n\n  /**\n   * lock cells\n   *\n   * @returns {this}\n   * @param {Boolean} bool\n   * @memberof XGraph\n   */\n  lockGraph(bool: boolean): this {\n    if (bool) {\n      this.graph.setEnabled(false);\n    } else {\n      this.graph.setEnabled(true);\n    }\n    this.lock = bool;\n    return this;\n  }\n\n  /**\n   * Enable tooltip\n   *\n   * @returns {this}\n   * @param {Boolean} bool\n   * @memberof XGraph\n   */\n  tooltipGraph(bool: boolean): this {\n    if (bool) {\n      this.graph.setTooltips(true);\n    } else {\n      this.graph.setTooltips(false);\n    }\n    this.tooltip = bool;\n    return this;\n  }\n\n  /**\n   * Allow downloads images from site draw.io\n   *\n   * @param {boolean} bool\n   * @returns {this}\n   * @memberof XGraph\n   */\n  allowDrawio(bool: boolean): this {\n    if (bool) {\n      mxUrlConverter.prototype.baseUrl = 'http://draw.io/';\n      mxUrlConverter.prototype.baseDomain = '';\n    } else {\n      mxUrlConverter.prototype.baseUrl = null;\n      mxUrlConverter.prototype.baseDomain = null;\n    }\n    return this;\n  }\n\n  enableAnim(bool: boolean): this {\n    this.animation = bool;\n    return this;\n  }\n\n  /**\n   * Center graph in panel\n   *\n   * @returns {this}\n   * @param {Boolean} bool\n   * @memberof XGraph\n   */\n  centerGraph(bool: boolean): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'centerGraph()');\n    this.graph.centerZoom = false;\n    if (bool) {\n      this.graph.center(true, true);\n    } else {\n      this.graph.center(false, false);\n    }\n    this.center = bool;\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Scale graph in panel\n   *\n   * @returns {this}\n   * @param {boolean} bool\n   * @memberof XGraph\n   */\n  scaleGraph(bool: boolean): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'scaleGraph()');\n    if (bool) {\n      this.unzoomGraph();\n      this.graph.fit();\n      this.graph.view.rendering = true;\n    }\n    this.scale = bool;\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Scale graph into container\n   *\n   * @returns {this}\n   * @memberof XGraph\n   */\n  fitGraph(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'fitGraph()');\n    const margin = 2;\n    const max = 3;\n\n    const bounds = this.graph.getGraphBounds();\n    const cw = this.graph.container.clientWidth - margin;\n    const ch = this.graph.container.clientHeight - margin;\n    const w = bounds.width / this.graph.view.scale;\n    const h = bounds.height / this.graph.view.scale;\n    const s = Math.min(max, Math.min(cw / w, ch / h));\n\n    this.graph.view.scaleAndTranslate(\n      s,\n      (margin + cw - w * s) / (2 * s) - bounds.x / this.graph.view.scale,\n      (margin + ch - h * s) / (2 * s) - bounds.y / this.graph.view.scale\n    );\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Display grid in panel\n   *\n   * @param {boolean} bool\n   * @returns {this}\n   * @memberof XGraph\n   */\n  gridGraph(bool: boolean): this {\n    if (bool) {\n      this.container.style.backgroundImage =\n        \"url('data:image/gif;base64,R0lGODlhCgAKAJEAAAAAAP///8zMzP///yH5BAEAAAMALAAAAAAKAAoAAAIJ1I6py+0Po2wFADs=')\";\n    } else {\n      this.container.style.backgroundImage = '';\n    }\n    this.grid = bool;\n    return this;\n  }\n\n  /**\n   * Zoom/unzoom\n   *\n   * @param {string} percent\n   * @returns {this}\n   * @memberof XGraph\n   */\n  zoomGraph(percent: string): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'zoomGraph()');\n    if (!this.scale && percent && percent.length > 0 && percent !== '100%' && percent !== '0%') {\n      const ratio: number = Number(percent.replace('%', '')) / 100;\n      this.graph.zoomTo(ratio, true);\n      this.zoomPercent = percent;\n    } else {\n      this.unzoomGraph();\n    }\n    this.zoom = true;\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Restore initial size\n   *\n   * @returns {this}\n   * @memberof XGraph\n   */\n  unzoomGraph(): this {\n    this.zoom = false;\n    this.graph.zoomActual();\n    return this;\n  }\n\n  /**\n   * Define background color\n   *\n   * @param {this} bgColor\n   * @memberof XGraph\n   */\n  bgGraph(bgColor): this {\n    const $div = $(this.container);\n    if (bgColor) {\n      this.bgColor = bgColor;\n      $div.css('background-color', bgColor);\n    } else {\n      $div.css('background-color', '');\n    }\n    return this;\n  }\n\n  /**\n   * Return mxgraph object\n   *\n   * @returns\n   * @memberof XGraph\n   */\n  getMxGraph() {\n    return this.graph;\n  }\n\n  /**\n   * Return xml definition\n   *\n   * @returns {string}\n   * @memberof XGraph\n   */\n  getxmlGraph(): string {\n    return this.xmlGraph;\n  }\n\n  /**\n   * Assign source definition and redraw graph\n   *\n   * @param {string} xmlGraph\n   * @returns {this}\n   * @memberof XGraph\n   */\n  setContent(content: string): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'setContent()');\n    if (this.type === 'xml') {\n      if ($GF.utils.isencoded(content)) {\n        this.xmlGraph = $GF.utils.decode(content, true, true, true);\n      } else {\n        this.xmlGraph = content;\n      }\n    }\n    if (this.type === 'csv') {\n      this.csvGraph = content;\n    }\n    this.drawGraph();\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Get list of values or id\n   *\n   * @param { gf.TPropertieKey} prop\n   * @returns {string[]}\n   * @memberof XGraph\n   */\n  getCurrentCells(prop: gf.TPropertieKey): string[] {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'getCurrentCells()');\n    const cellIds: string[] = [];\n    const model = this.graph.getModel();\n    const cells = model.cells;\n    if (prop === 'id') {\n      _.each(cells, (mxcell: mxCell) => {\n        cellIds.push(this.getId(mxcell));\n      });\n    } else if (prop === 'value') {\n      _.each(cells, (mxcell: mxCell) => {\n        cellIds.push(this.getLabelCell(mxcell));\n      });\n    }\n    trc.after();\n    return cellIds;\n  }\n\n  /**\n   * Get list of mxCell\n   *\n   * @param {string} prop - id|value\n   * @param {string} pattern - regex like or string\n   * @returns {mxCell[]}\n   * @memberof XGraph\n   */\n  findMxCells(prop: gf.TPropertieKey, pattern: string): mxCell[] {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'findMxCells()');\n    const mxcells = this.getMxCells();\n    const result: any[] = [];\n    if (prop === 'id') {\n      _.each(mxcells, (mxcell: mxCell) => {\n        if ($GF.utils.matchString(mxcell.id, pattern)) {\n          result.push(mxcell);\n        }\n      });\n    } else if (prop === 'value') {\n      _.each(mxcells, (mxcell: mxCell) => {\n        if ($GF.utils.matchString(this.getLabelCell(mxcell), pattern)) {\n          result.push(mxcell);\n        }\n      });\n    }\n    trc.after();\n    return result;\n  }\n\n  /**\n   * Select cells in graph with pattern for id or value\n   *\n   * @param {string} prop - \"id\"|\"value\"\n   * @param {string} pattern - regex like\n   * @memberof XGraph\n   */\n  async selectMxCells(prop: gf.TPropertieKey, pattern: string) {\n    const mxcells = this.findMxCells(prop, pattern);\n    if (mxcells) {\n      this.highlightCells(mxcells);\n    }\n  }\n\n  /**\n   * Unselect cells\n   *\n   * @returns {this}\n   * @memberof XGraph\n   */\n  async unselectMxCells(prop: gf.TPropertieKey, pattern: string) {\n    const mxcells = this.findMxCells(prop, pattern);\n    if (mxcells) {\n      this.unhighlightCells(mxcells);\n    }\n  }\n\n  /**\n   * Create tooltip on image\n   *\n   * @param {*} image\n   * @param {*} tooltip\n   * @returns {mxCellOverlay}\n   * @memberof XGraph\n   */\n  createOverlay(image, tooltip): any {\n    const overlay = new mxCellOverlay(image, tooltip);\n    overlay.addListener(mxEvent.CLICK, (_sender, _evt) => {\n      mxUtils.alert(`${tooltip}\\nLast update: ${new Date()}`);\n    });\n    return overlay;\n  }\n\n  /**\n   * Add Warning icon\n   *\n   * @param {string} state (OK|WARN|ERROR)\n   * @param {mxCell} mxcell\n   * @returns {this}\n   * @memberof XGraph\n   */\n  addOverlay(state: string, mxcell: mxCell) {\n    this.graph.addCellOverlay(mxcell, this.createOverlay(this.graph.warningImage, `State: ${state}`));\n    return this;\n  }\n\n  /**\n   * Remove Warning icon\n   *\n   * @param {mxCell} mxcell\n   * @returns {this}\n   * @memberof XGraph\n   */\n  removeOverlay(mxcell: mxCell): this {\n    this.graph.removeCellOverlays(mxcell);\n    return this;\n  }\n\n  /**\n   * Add link to cell\n   *\n   * @param {mxCell} mxcell\n   * @param {string} link - Url\n   * @returns {this}\n   * @memberof XGraph\n   */\n  addLink(mxcell: mxCell, link): this {\n    this.graph.setLinkForCell(mxcell, link);\n    return this;\n  }\n\n  /**\n   * Get link from cell\n   *\n   * @param {mxCell} mxcell\n   * @memberof XGraph\n   */\n  getLink(mxcell: mxCell): string | null {\n    return this.graph.getLinkForCell(mxcell);\n  }\n\n  /**\n   * Remove link of cell\n   *\n   * @param {mxCell} mxcell\n   * @returns {this}\n   * @memberof XGraph\n   */\n  removeLink(mxcell: mxCell): this {\n    this.graph.setLinkForCell(mxcell, null);\n    return this;\n  }\n\n  /**\n   * Get value or id from cell source\n   *\n   * @param { gf.TPropertieKey} prop\n   * @returns {string[]} value of labels or id frome source\n   * @memberof XGraph\n   */\n  getOrignalCells(prop: gf.TPropertieKey): string[] {\n    if (prop === 'id' || prop === 'value') {\n      return this.cells[prop];\n    }\n    // TODO: attributs\n    return [];\n  }\n\n  /**\n   * Rename Id of cell\n   * Must be uniq\n   * @param {string} oldId\n   * @param {string} newId\n   * @returns {this} XGraph\n   * @memberof XGraph\n   */\n  renameId(oldId: string, newId: string): this {\n    const cells = this.findMxCells('id', oldId);\n    if (cells !== undefined && cells.length > 0) {\n      cells.forEach(cell => {\n        cell.id = newId;\n      });\n    } else {\n      $GF.log.warn(`Cell ${oldId} not found`);\n    }\n    return this;\n  }\n\n  /**\n   * Get xml definition from current graph\n   *\n   * @returns\n   * @memberof XGraph\n   */\n  getXmlModel() {\n    const encoder = new mxCodec();\n    const node = encoder.encode(this.graph.getModel());\n    return mxUtils.getXml(node);\n  }\n\n  /**\n   * Return all cells\n   *\n   * @returns {Map<mxCell>} mxCells\n   * @memberof XGraph\n   */\n  getMxCells(): any {\n    return this.graph.getModel().cells;\n  }\n\n  /**\n   * Return value of id or value of mxcell\n   *\n   * @param {string} prop - \"id\"|\"value\"\n   * @param {mxCell} mxcell\n   * @memberof XGraph\n   */\n  getValuePropOfMxCell(prop: gf.TPropertieKey, mxcell: mxCell): string | null {\n    if (prop === 'id') {\n      return this.getId(mxcell);\n    }\n    if (prop === 'value') {\n      return this.getLabelCell(mxcell);\n    }\n    return null;\n  }\n\n  getStyleCell(mxcell: mxCell, style: any): string | null {\n    const state = this.graph.view.getState(mxcell);\n    if (state) {\n      return state.style[style];\n    }\n    return null;\n  }\n\n  isAnimated() {\n    return this.animation;\n  }\n\n  /**\n   * Apply color style on Cell\n   *\n   * @param {mxCell} mxcell\n   * @param {gf.TStyleColor.Keys} style\n   * @param {(string | null)} color\n   * @param {boolean} [animate=false]\n   * @returns {this}\n   * @memberof XGraph\n   */\n  // setColorAnimCell(mxcell: mxCell, style: gf.TStyleColorKeys, color: string | null): this {\n  //   const trc = $GF.trace.before(this.constructor.name + '.' + 'setColorAnimCell()');\n  //   if (this.isAnimated() && color) {\n  //     try {\n  //       const startColor = this.getStyleCell(mxcell, style);\n  //       if (startColor) {\n  //         const endColor = color;\n  //         const steps = chroma\n  //           .scale([startColor, endColor])\n  //           .mode('lrgb')\n  //           .colors($GF.CONSTANTS.CONF_COLORS_STEPS + 1);\n  //         const count = 1;\n  //         const self = this;\n  //         const lg = steps.length;\n  //         function graduate(count, steps) {\n  //           if (count < lg) {\n  //             self.setStyleCell(mxcell, style, steps[count]);\n  //             window.setTimeout(() => {\n  //               graduate(count + 1, steps);\n  //             }, $GF.CONSTANTS.CONF_COLORS_MS);\n  //           }\n  //         }\n  //         graduate(count, steps);\n  //       } else {\n  //         // let hex = Color(color).hex();\n  //         let hex = chroma(color).hex();\n  //         this.setStyleCell(mxcell, style, hex);\n  //       }\n  //     } catch (error) {\n  //       $GF.log.error('Error on graduate color', error);\n  //       this.setStyleCell(mxcell, style, color);\n  //     }\n  //   } else {\n  //     if (color !== null) {\n  //       try {\n  //         color = chroma(color).hex();\n  //       } catch (error) {\n  //         $GF.log.error('Invalid Color', color);\n  //       }\n  //     }\n  //     this.setStyleCell(mxcell, style, color);\n  //   }\n  //   trc.after();\n  //   return this;\n  // }\n  setColorAnimCell(mxcell: mxCell, style: gf.TStyleColorKeys, color: string | null): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'setColorAnimCell()');\n    const id = `${style}_${mxcell.id}`;\n    // Cancel Previous anim\n    $GF.clearUniqTimeOut(id);\n    if (this.isAnimated() && color) {\n      try {\n        const startColor = this.getStyleCell(mxcell, style);\n        if (startColor) {\n          const endColor = color;\n          const steps = chroma\n            .scale([startColor, endColor])\n            .mode('lrgb')\n            .colors($GF.CONSTANTS.CONF_COLORS_STEPS + 1);\n          let count = 1;\n          const self = this;\n          const lg = steps.length;\n          function graduate() {\n            if (count < lg) {\n              self.setStyleCell(mxcell, style, steps[count]);\n              count += 1;\n              $GF.setUniqTimeOut(graduate, $GF.CONSTANTS.CONF_COLORS_MS, id);\n            } else {\n              $GF.clearUniqTimeOut(id);\n            }\n          }\n          graduate();\n        } else {\n          // let hex = Color(color).hex();\n          let hex = chroma(color).hex();\n          this.setStyleCell(mxcell, style, hex);\n        }\n      } catch (error) {\n        $GF.log.error('Error on graduate color', error);\n        this.setStyleCell(mxcell, style, color);\n      }\n    } else {\n      if (color !== null) {\n        try {\n          color = chroma(color).hex();\n        } catch (error) {\n          $GF.log.error('Invalid Color', color);\n        }\n      }\n      this.setStyleCell(mxcell, style, color);\n    }\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Change or apply style\n   *\n   * @param {mxCell} mxcell\n   * @param {gf.TStyleColor.Keys} style\n   * @param {(string | null)} value\n   * @returns {this}\n   * @memberof XGraph\n   */\n  setStyleCell(mxcell: mxCell, style: any, value: string | null): this {\n    this.graph.setCellStyles(style, value, [mxcell]);\n    return this;\n  }\n\n  /**\n   * Change style with steps to anime\n   *\n   * @param {mxCell} mxcell\n   * @param {*} style\n   * @param {(string | null)} endValue\n   * @param {string} [beginValue]\n   * @memberof XGraph\n   */\n  async setStyleAnimCell(mxcell: mxCell, style: any, endValue: string | null, beginValue?: string) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'setStyleAnimCell()');\n    if (this.isAnimated() && endValue !== null) {\n      try {\n        const end = Number(endValue);\n        const begin = beginValue !== undefined ? Number(beginValue) : Number(this.getStyleCell(mxcell, style));\n        if (end !== begin) {\n          const id = `${style}_${mxcell.id}`;\n          // Cancel Previous anim\n          $GF.clearUniqTimeOut(id);\n          const steps = $GF.getIntervalCounter(begin, end, $GF.CONSTANTS.CONF_ANIMS_STEP);\n          const lg = steps.length;\n          let count = 0;\n          const self = this;\n          function graduate() {\n            if (count < lg) {\n              self.setStyleCell(mxcell, style, steps[count].toString());\n              count += 1;\n              $GF.setUniqTimeOut(graduate, $GF.CONSTANTS.CONF_ANIMS_MS, id);\n            } else {\n              $GF.clearUniqTimeOut(id);\n            }\n          }\n          graduate();\n        }\n      } catch (error) {\n        this.graph.setCellStyles(style, endValue, [mxcell]);\n      }\n    } else {\n      this.graph.setCellStyles(style, endValue, [mxcell]);\n    }\n    trc.after();\n  }\n\n  /**\n   * Apply the styles to mxcell\n   *\n   * @param {mxCell} mxcell\n   * @param {string} styles\n   * @memberof XGraph\n   */\n  setStyles(mxcell: mxCell, styles: string): this {\n    this.graph.getModel().setStyle(mxcell, styles);\n    return this;\n  }\n\n  setClassCell(mxcell: mxCell, className: string): this {\n    var state = this.graph.view.getState(mxcell);\n    if (state && state.shape !== null) {\n      const paths = state.shape.node.getElementsByTagName('path');\n      if (paths.length > 1) {\n        let currentClass: string = paths[1].getAttribute('class');\n        let classes: string[] = [];\n        if (currentClass !== null && currentClass !== undefined) {\n          classes = currentClass.split(' ');\n        }\n        if (!classes.includes(className)) {\n          classes.push(className);\n          currentClass = classes.join(' ');\n          paths[1].setAttribute('class', currentClass);\n          if (mxUtils.getValue(state.style, mxConstants.STYLE_DASHED, '0') !== '1') {\n            paths[1].setAttribute('stroke-dasharray', '8');\n          }\n        }\n      }\n    }\n    return this;\n  }\n\n  unsetClassCell(mxcell: mxCell, className: string): this {\n    var state = this.graph.view.getState(mxcell);\n    if (state && state.shape !== null) {\n      const paths = state.shape.node.getElementsByTagName('path');\n      if (paths.length > 1) {\n        let currentClass: string = paths[1].getAttribute('class');\n        let classes: string[] = [];\n        if (currentClass !== null && currentClass !== undefined) {\n          classes = currentClass.split(' ');\n        }\n        if (classes.includes(className)) {\n          classes = classes.filter(c => c !== className);\n          if (classes.length > 1) {\n            currentClass = classes.join(' ');\n            paths[1].setAttribute('class', currentClass);\n          } else {\n            paths[1].removeAttribute('class');\n          }\n          if (mxUtils.getValue(state.style, mxConstants.STYLE_DASHED, '0') !== '1') {\n            paths[1].removeAttribute('stroke-dasharray');\n          }\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Return Label/value of mxcell\n   *\n   * @param {mxCell} mxcell\n   * @returns {string} Label of current cell\n   * @memberof XGraph\n   */\n  getLabelCell(mxcell: mxCell): string {\n    if (mxUtils.isNode(mxcell.value)) {\n      return mxcell.value.getAttribute('label');\n    }\n    return mxcell.getValue(mxcell);\n  }\n\n  /**\n   * Assign new label for mxcell\n   *\n   * @param {mxCell} mxcell\n   * @param {string} text - New label\n   * @returns {this}\n   * @memberof XGraph\n   */\n  setLabelCell(mxcell: mxCell, text: string): this {\n    this.graph.cellLabelChanged(mxcell, text, false);\n    return this;\n  }\n\n  /**\n   * Return Id of mxCell\n   *\n   * @param {mxCell} mxcell\n   * @returns {string} Id of mxCell\n   * @memberof XGraph\n   */\n  getId(mxcell): string {\n    return mxcell.getId();\n  }\n\n  /**\n   * Active mapping option when user click on mapping\n   *\n   * @param {Object} onMappingObj\n   * @memberof XGraph\n   */\n  setMap(onMappingObj: gf.TIOnMappingObj) {\n    $GF.log.info('XGraph.setMapping()');\n    this.onMapping = onMappingObj;\n    if (this.onMapping.active === true) {\n      this.container.style.cursor = 'crosshair';\n      this.graph.click = this.eventClick.bind(this);\n    }\n  }\n\n  /**\n   * Disable mapping when user click on mapping\n   *\n   * @memberof XGraph\n   */\n  unsetMap() {\n    $GF.log.info('XGraph.unsetMapping()');\n    this.onMapping.active = false;\n    this.container.style.cursor = 'auto';\n    this.graph.click = this.clickBackup;\n    if (this.onMapping.$scope) {\n      this.onMapping.$scope.$applyAsync();\n    }\n  }\n\n  //\n  // GRAPH HANDLER\n  //\n\n  /**\n   * Event for click on graph\n   *\n   * @param {MouseEvent} me\n   * @memberof XGraph\n   */\n  eventClick(me: mxMouseEvent) {\n    if (this.onMapping.active) {\n      const state = me.getState();\n      if (state) {\n        const prop = this.onMapping.prop !== null ? this.onMapping.prop : 'id';\n        const value = this.getValuePropOfMxCell(prop, state.cell);\n        if (this.onMapping.object) {\n          this.onMapping.object.data.pattern = value;\n        }\n        if (this.onMapping.value) {\n          const elt = document.getElementById(this.onMapping.value);\n          if (elt) {\n            setTimeout(() => {\n              elt.focus();\n            }, 100);\n          }\n        }\n        this.unsetMap();\n      }\n    }\n  }\n\n  eventDebug(me: mxMouseEvent) {\n    console.log('DEBUG mxMouseEvent', me);\n    // const state = me.getState();\n    // if (state) {\n    //   console.log(\"DEBUG state\",state);\n    // }\n  }\n\n  /**\n   * Event for double click on graph\n   *\n   * @param {MouseEvent} evt\n   * @param {mxCell} mxcell\n   * @memberof XGraph\n   */\n  eventDbClick(evt: MouseEvent, mxcell: mxCell) {\n    if (mxcell !== undefined) {\n      this.lazyZoomCell(mxcell);\n    }\n  }\n\n  /**\n   * Event for mouse wheel on graph\n   *\n   * @param {Event} evt\n   * @param {boolean} up\n   * @memberof XGraph\n   */\n  eventMouseWheel(evt: WheelEvent, up: boolean) {\n    if (this.graph.isZoomWheelEvent(evt)) {\n      if (up === null || up === undefined) {\n        if (evt.deltaY < 0) {\n          up = true;\n        } else {\n          up = false;\n        }\n      }\n      const rect = this.container.getBoundingClientRect();\n      const x = evt.clientX - rect.left;\n      const y = evt.clientY - rect.top;\n\n      if (up) {\n        this.cumulativeZoomFactor = this.cumulativeZoomFactor * 1.2;\n      } else {\n        this.cumulativeZoomFactor = this.cumulativeZoomFactor * 0.8;\n      }\n      this.lazyZoomPointer(this.cumulativeZoomFactor, x, y);\n      mxEvent.consume(evt);\n    }\n  }\n\n  /**\n   * Event for key on graph\n   *\n   * @param {KeyboardEvent} evt\n   * @memberof XGraph\n   */\n  eventKey(evt: KeyboardEvent) {\n    if (!mxEvent.isConsumed(evt) && evt.keyCode === 27 /* Escape */) {\n      this.cumulativeZoomFactor = 1;\n      if (this.graph) {\n        this.graph.zoomActual();\n        this.applyGraph();\n      }\n    }\n  }\n\n  /**\n   * Zoom/Unzoom on graph on center\n   *\n   * @param {number} factor - 1 = 100%\n   * @memberof XGraph\n   */\n  async lazyZoomCenter(factor: number) {\n    this.graph.zoomTo(factor, true);\n  }\n\n  /**\n   * Zoom/Unzoom on graph on mouse pointer\n   *\n   * @param {number} factor\n   * @param {number} offsetX\n   * @param {number} offsetY\n   * @memberof XGraph\n   */\n  async lazyZoomPointer(factor: number, offsetX: number, offsetY: number) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'lazyZoomPointer()');\n    let dx = offsetX * 2;\n    let dy = offsetY * 2;\n\n    factor = Math.max(0.01, Math.min(this.graph.view.scale * factor, 160)) / this.graph.view.scale;\n    factor = this.cumulativeZoomFactor / this.graph.view.scale;\n    const scale = Math.round(this.graph.view.scale * factor * 100) / 100;\n    factor = scale / this.graph.view.scale;\n\n    if (factor > 1) {\n      const f = (factor - 1) / (scale * 2);\n      dx *= -f;\n      dy *= -f;\n    } else {\n      const f = (1 / factor - 1) / (this.graph.view.scale * 2);\n      dx *= f;\n      dy *= f;\n    }\n    this.graph.view.scaleAndTranslate(scale, this.graph.view.translate.x + dx, this.graph.view.translate.y + dy);\n    trc.after();\n  }\n\n  /**\n   * Highlights the given cell.\n   *\n   * @param {mxCell[]} cells\n   * @memberof XGraph\n   */\n  async highlightCells(cells: mxCell[] = this.getMxCells()) {\n    for (let i = 0; i < cells.length; i++) {\n      this.highlightCell(cells[i]);\n    }\n  }\n\n  /**\n   * UnHighlights the given array of cells.\n   *\n   * @param {mxCell[]} cells\n   * @memberof XGraph\n   */\n  async unhighlightCells(mxcells: mxCell[] = this.getMxCells()) {\n    _.each(mxcells, (mxcell: mxCell) => {\n      this.unhighlightCell(mxcell);\n    });\n  }\n\n  /**\n   * Highlights the given cell.\n   *\n   * @param {*} cell\n   * @returns\n   * @memberof XGraph\n   */\n  async highlightCell(cell: mxCell) {\n    if (!cell.highlight) {\n      const color = '#99ff33';\n      const opacity = 100;\n      const state = this.graph.view.getState(cell);\n\n      if (state != null) {\n        const sw = Math.max(5, mxUtils.getValue(state.style, mxConstants.STYLE_STROKEWIDTH, 1) + 4);\n        const hl = new mxCellHighlight(this.graph, color, sw, false);\n\n        if (opacity != null) {\n          hl.opacity = opacity;\n        }\n\n        hl.highlight(state);\n        cell.highlight = hl;\n      }\n    }\n  }\n\n  /**\n   * UnHighlights the given cell.\n   *\n   * @param {mxCell} mxcell\n   * @memberof XGraph\n   */\n  async unhighlightCell(mxcell: mxCell) {\n    if (mxcell && mxcell.highlight) {\n      const hl = mxcell.highlight;\n      // Fades out the highlight after a duration\n      if (hl.shape != null) {\n        mxUtils.setPrefixedStyle(hl.shape.node.style, 'transition', 'all 500ms ease-in-out');\n        hl.shape.node.style.opacity = 0;\n      }\n      // Destroys the highlight after the fade\n      window.setTimeout(() => {\n        hl.destroy();\n      }, 500);\n      mxcell.highlight = null;\n    }\n  }\n\n  // BLINK\n  async blinkCell(mxcell: mxCell, ms: number) {\n    if (!mxcell.blink) {\n      mxcell.blink = true;\n      const self = this;\n      const id = `blink_${mxcell.id}`;\n      // Cancel Previous anim\n      $GF.clearUniqTimeOut(id);\n      const bl_on = function() {\n        const color = '#f5f242';\n        const opacity = 100;\n        const state = self.graph.view.getState(mxcell);\n\n        if (state != null) {\n          const sw = Math.max(5, mxUtils.getValue(state.style, mxConstants.STYLE_STROKEWIDTH, 1) + 4);\n          const hl = new mxCellHighlight(self.graph, color, sw, false);\n\n          if (opacity != null) {\n            hl.opacity = opacity;\n          }\n\n          hl.highlight(state);\n          mxcell.blink_on = hl;\n          mxcell.blink_ms = ms;\n          $GF.setUniqTimeOut(bl_off, ms, id);\n        }\n      };\n      const bl_off = function() {\n        if (mxcell && mxcell.blink) {\n          // console.log('bl_off');\n          const hl = mxcell.blink_on;\n          // Fades out the highlight after a duration\n          if (hl.shape != null) {\n            mxUtils.setPrefixedStyle(hl.shape.node.style, `transition`, `all ${ms}ms ease-in-out`);\n            hl.shape.node.style.opacity = 0;\n          }\n          // Destroys the highlight after the fade\n          // window.setTimeout(() => {\n          //   hl.destroy();\n          //   cell.blink_on = null;\n          // }, ms);\n          hl.destroy();\n          mxcell.blink_on = null;\n          $GF.setUniqTimeOut(bl_on, ms, id);\n        }\n      };\n      bl_on();\n    }\n  }\n\n  async unblinkCell(mxcell: mxCell) {\n    const id = `blink_${mxcell.id}`;\n    if (mxcell.blink) {\n      if (mxcell.blink_on) {\n        const hl = mxcell.blink_on;\n        if (hl.shape != null) {\n          hl.shape.node.style.opacity = 0;\n          hl.destroy();\n          mxcell.blink_on = null;\n          mxcell.blink_ms = 0;\n        }\n      }\n      mxcell.blink = null;\n    }\n    // Cancel Previous anim\n    $GF.clearUniqTimeOut(id);\n  }\n\n  isBlinkCell(mxcell: mxCell): boolean {\n    return !!mxcell.blink;\n  }\n\n  geBlinkMxCell(mxcell: mxCell): number {\n    return !!mxcell.blink ? mxcell.blink_ms : 0;\n  }\n\n  // COLLAPSE\n  isCollapsedCell(mxcell: mxCell): boolean {\n    return this.graph.isCellCollapsed(mxcell);\n  }\n\n  collapseCell(mxcell: mxCell) {\n    if (!this.isCollapsedCell(mxcell)) {\n      this.graph.foldCells(true, false, [mxcell], null, null);\n    }\n  }\n\n  expandCell(mxcell: mxCell) {\n    if (this.isCollapsedCell(mxcell)) {\n      this.graph.foldCells(false, false, [mxcell], null, null);\n    }\n  }\n\n  toggleFoldCell(mxcell: mxCell) {\n    const collapse: boolean = !this.isCollapsedCell(mxcell);\n    this.graph.foldCells(collapse, false, [mxcell], null, null);\n  }\n\n  // VISIBLE\n\n  /**\n   * Hide cell/shape\n   *\n   * @param {mxCell} mxcell\n   * @memberof XGraph\n   */\n  async hideCell(mxcell: mxCell) {\n    if (this.isVisibleCell(mxcell)) {\n      this.graph.model.setVisible(mxcell, false);\n    }\n  }\n\n  /**\n   * Show/unhide cell/shape\n   *\n   * @param {mxCell} mxcell\n   * @memberof XGraph\n   */\n  async showCell(mxcell: mxCell) {\n    if (!this.isVisibleCell(mxcell)) {\n      this.graph.model.setVisible(mxcell, true);\n    }\n  }\n\n  /**\n   * Cell is visible ?\n   *\n   * @param {mxCell} mxcell\n   * @returns {boolean}\n   * @memberof XGraph\n   */\n  isVisibleCell(mxcell: mxCell): boolean {\n    return this.graph.model.isVisible(mxcell);\n  }\n\n  // async resizeCell(mxcell: mxCell, percent: number, origine?: mxGeometry) {\n  //   const trc = $GF.trace.before(this.constructor.name + '.' + 'resizeCell()');\n  //   const geo = this.graph.model.getGeometry(mxcell);\n  //   if (geo !== null) {\n  //     let _x = origine !== undefined ? origine.x : geo.x;\n  //     let _ow = origine !== undefined ? origine.width : geo.x;\n  //     let _y = origine !== undefined ? origine.y : geo.y;\n  //     let _oh = origine !== undefined ? origine.height : geo.y;\n  //     let _w = _ow * (percent / 100);\n  //     let _h = _oh * (percent / 100);\n  //     _x = _x - (_w - _ow) / 2;\n  //     _y = _y - (_h - _oh) / 2;\n  //     if (this.isAnimated()) {\n  //       const steps_x = $GF.getIntervalCounter(geo.x, _x, $GF.CONSTANTS.CONF_ANIMS_STEP);\n  //       const steps_y = $GF.getIntervalCounter(geo.y, _y, $GF.CONSTANTS.CONF_ANIMS_STEP);\n  //       const steps_w = $GF.getIntervalCounter(geo.width, _w, $GF.CONSTANTS.CONF_ANIMS_STEP);\n  //       const steps_h = $GF.getIntervalCounter(geo.height, _h, $GF.CONSTANTS.CONF_ANIMS_STEP);\n  //       const l = steps_x.length;\n  //       let count = 0;\n  //       const self = this;\n  //       function graduate(count, steps_x, steps_y, steps_w, steps_h) {\n  //         if (count < l) {\n  //           window.setTimeout(() => {\n  //             const _rec = new mxRectangle(steps_x[count], steps_y[count], steps_w[count], steps_h[count]);\n  //             self.graph.resizeCell(mxcell, _rec, true);\n  //             graduate(count + 1, steps_x, steps_y, steps_w, steps_h);\n  //           }, $GF.CONSTANTS.CONF_ANIMS_MS);\n  //         }\n  //       }\n  //       graduate(count, steps_x, steps_y, steps_w, steps_h);\n  //     } else {\n  //       const _rec = new mxRectangle(_x, _y, _w, _h);\n  //       this.graph.resizeCell(mxcell, _rec, true);\n  //     }\n  //   }\n  //   trc.after();\n  // }\n  async resizeCell(mxcell: mxCell, percent: number, origine?: mxGeometry) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'resizeCell()');\n    const geo = this.graph.model.getGeometry(mxcell);\n    if (geo !== null) {\n      const id = `resize_${mxcell.id}`;\n      // Cancel Previous anim\n      $GF.clearUniqTimeOut(id);\n      let _x = origine !== undefined ? origine.x : geo.x;\n      let _ow = origine !== undefined ? origine.width : geo.x;\n      let _y = origine !== undefined ? origine.y : geo.y;\n      let _oh = origine !== undefined ? origine.height : geo.y;\n      let _w = _ow * (percent / 100);\n      let _h = _oh * (percent / 100);\n      _x = _x - (_w - _ow) / 2;\n      _y = _y - (_h - _oh) / 2;\n      if (this.isAnimated()) {\n        const steps_x = $GF.getIntervalCounter(geo.x, _x, $GF.CONSTANTS.CONF_ANIMS_STEP);\n        const steps_y = $GF.getIntervalCounter(geo.y, _y, $GF.CONSTANTS.CONF_ANIMS_STEP);\n        const steps_w = $GF.getIntervalCounter(geo.width, _w, $GF.CONSTANTS.CONF_ANIMS_STEP);\n        const steps_h = $GF.getIntervalCounter(geo.height, _h, $GF.CONSTANTS.CONF_ANIMS_STEP);\n        const lg = steps_x.length;\n        let count = 0;\n        const self = this;\n        function graduate() {\n          if (count < lg) {\n            const _rec = new mxRectangle(steps_x[count], steps_y[count], steps_w[count], steps_h[count]);\n            self.graph.resizeCell(mxcell, _rec, true);\n            count += 1;\n            $GF.setUniqTimeOut(graduate, $GF.CONSTANTS.CONF_ANIMS_MS, id);\n          } else {\n            $GF.clearUniqTimeOut(id);\n          }\n        }\n        graduate();\n      } else {\n        const _rec = new mxRectangle(_x, _y, _w, _h);\n        this.graph.resizeCell(mxcell, _rec, true);\n      }\n    }\n    trc.after();\n  }\n  // WIDTH AND HEIGHT\n  // async changeSizeCell(mxcell: mxCell, width: number | undefined, height: number | undefined, origine?: mxGeometry) {\n  //   const trc = $GF.trace.before(this.constructor.name + '.' + 'resizeCell()');\n  //   const geo = this.graph.model.getGeometry(mxcell);\n  //   if (geo !== null) {\n  //     let _x = origine !== undefined ? origine.x : geo.x;\n  //     let _ow = origine !== undefined ? origine.width : geo.x;\n  //     let _y = origine !== undefined ? origine.y : geo.y;\n  //     let _oh = origine !== undefined ? origine.height : geo.y;\n  //     _x = width !== undefined && width < 0 ? _x + width + _ow : _x;\n  //     _y = height !== undefined && height < 0 ? _y + height + _oh : _y;\n  //     let _h = height !== undefined ? Math.abs(height) : origine !== undefined ? origine.height : geo.height;\n  //     let _w = width !== undefined ? Math.abs(width) : origine !== undefined ? origine.width : geo.width;\n  //     if (this.isAnimated()) {\n  //       const steps_x = $GF.getIntervalCounter(geo.x, _x, $GF.CONSTANTS.CONF_ANIMS_STEP);\n  //       const steps_y = $GF.getIntervalCounter(geo.y, _y, $GF.CONSTANTS.CONF_ANIMS_STEP);\n  //       const steps_w = $GF.getIntervalCounter(geo.width, _w, $GF.CONSTANTS.CONF_ANIMS_STEP);\n  //       const steps_h = $GF.getIntervalCounter(geo.height, _h, $GF.CONSTANTS.CONF_ANIMS_STEP);\n  //       const l = steps_x.length;\n  //       let count = 0;\n  //       const self = this;\n  //       function graduate(count, steps_x, steps_y, steps_w, steps_h) {\n  //         if (count < l) {\n  //           window.setTimeout(() => {\n  //             const _rec = new mxRectangle(steps_x[count], steps_y[count], steps_w[count], steps_h[count]);\n  //             self.graph.resizeCell(mxcell, _rec, true);\n  //             graduate(count + 1, steps_x, steps_y, steps_w, steps_h);\n  //           }, $GF.CONSTANTS.CONF_ANIMS_MS);\n  //         }\n  //       }\n  //       graduate(count, steps_x, steps_y, steps_w, steps_h);\n  //     } else {\n  //       const _rec = new mxRectangle(_x, _y, _w, _h);\n  //       this.graph.resizeCell(mxcell, _rec, true);\n  //     }\n  //   }\n  //   trc.after();\n  // }\n  async changeSizeCell(mxcell: mxCell, width: number | undefined, height: number | undefined, origine?: mxGeometry) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'resizeCell()');\n    const geo = this.graph.model.getGeometry(mxcell);\n    if (geo !== null) {\n      const id = `resize_${mxcell.id}`;\n      // Cancel Previous anim\n      $GF.clearUniqTimeOut(id);\n      let _x = origine !== undefined ? origine.x : geo.x;\n      let _ow = origine !== undefined ? origine.width : geo.x;\n      let _y = origine !== undefined ? origine.y : geo.y;\n      let _oh = origine !== undefined ? origine.height : geo.y;\n      _x = width !== undefined && width < 0 ? _x + width + _ow : _x;\n      _y = height !== undefined && height < 0 ? _y + height + _oh : _y;\n      let _h = height !== undefined ? Math.abs(height) : origine !== undefined ? origine.height : geo.height;\n      let _w = width !== undefined ? Math.abs(width) : origine !== undefined ? origine.width : geo.width;\n      if (this.isAnimated()) {\n        const steps_x = $GF.getIntervalCounter(geo.x, _x, $GF.CONSTANTS.CONF_ANIMS_STEP);\n        const steps_y = $GF.getIntervalCounter(geo.y, _y, $GF.CONSTANTS.CONF_ANIMS_STEP);\n        const steps_w = $GF.getIntervalCounter(geo.width, _w, $GF.CONSTANTS.CONF_ANIMS_STEP);\n        const steps_h = $GF.getIntervalCounter(geo.height, _h, $GF.CONSTANTS.CONF_ANIMS_STEP);\n        const lg = steps_x.length;\n        let count = 0;\n        const self = this;\n        function graduate() {\n          if (count < lg) {\n            const _rec = new mxRectangle(steps_x[count], steps_y[count], steps_w[count], steps_h[count]);\n            self.graph.resizeCell(mxcell, _rec, true);\n            count += 1;\n            $GF.setUniqTimeOut(graduate, $GF.CONSTANTS.CONF_ANIMS_MS, id);\n          } else {\n            $GF.clearUniqTimeOut(id);\n          }\n        }\n        graduate();\n      } else {\n        const _rec = new mxRectangle(_x, _y, _w, _h);\n        this.graph.resizeCell(mxcell, _rec, true);\n      }\n    }\n    trc.after();\n  }\n\n  getSizeCell(mxcell: mxCell): mxGeometry {\n    return this.graph.model.getGeometry(mxcell);\n  }\n\n  async resetSizeCell(mxcell: mxCell, mxgeo: mxGeometry) {\n    const rec = new mxRectangle(mxgeo.x, mxgeo.y, mxgeo.width, mxgeo.height);\n    this.graph.resizeCell(mxcell, rec, true);\n  }\n\n  /**\n   * Zoom cell on full panel\n   *\n   * @param {mxCell} mxcell\n   * @memberof XGraph\n   */\n  async lazyZoomCell(mxcell: mxCell) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'lazyZoomCell()');\n    if (mxcell !== undefined && mxcell !== null && mxcell.isVertex()) {\n      const state = this.graph.view.getState(mxcell);\n      if (state !== null) {\n        let rect: any;\n        if (state.width !== undefined && state.width > 0 && state.height !== undefined && state.height > 0) {\n          // const x = state.x;\n          // const y = state.y;\n          // const width = state.width;\n          // const height = state.height;\n          // rect = new mxRectangle(x, y, width, height);\n          rect = state.shape.bounds;\n        } else {\n          rect = state.text.boundingBox;\n        }\n        this.graph.zoomToRect(rect);\n        this.cumulativeZoomFactor = this.graph.view.scale;\n      }\n    }\n    trc.after();\n  }\n\n  static loadXml(url: string): string | null {\n    try {\n      const req: any = mxUtils.load(url);\n      if (req.getStatus() >= 200 && req.getStatus() <= 299) {\n        return req.getText();\n      } else {\n        $GF.log.error('Cannot load ' + url, req.getStatus());\n      }\n    } catch (error) {\n      $GF.log.error('Cannot load ' + url, error);\n    }\n    return null;\n  }\n\n  static compress(source: string): string {\n    return Graph.compress(source, true);\n  }\n\n  static decompress(source: string): string {\n    return Graph.decompress(source, true);\n  }\n}\n","import { FlowchartHandler } from './flowchartHandler';\nimport { State } from 'state_class';\nimport { $GF } from 'globals_class';\nimport { StateHandler } from 'statesHandler';\nimport _ from 'lodash';\n// import { MetricHandler } from './metricHandler';\n\ndeclare interface TColumn {\n  id: string;\n  desc: string;\n  sort: 'asc' | 'desc';\n  select: boolean;\n}\n\ndeclare interface TTable {\n  data: State[];\n  columns: TColumn[];\n}\n\nexport class InspectOptionsCtrl {\n  enable = false; // enable inspector or not\n  ctrl: any; //TODO: define type\n  flowchartHandler: FlowchartHandler;\n  stateHandler: StateHandler | undefined;\n  state: TTable;\n  panel: any;\n  traceEnable: boolean = $GF.trace.isEnabled();\n\n  /** @ngInject */\n  constructor($scope: gf.TInspectOptionsScope) {\n    $scope.editor = this;\n    $scope.$GF = $GF.me();\n\n    this.state = {\n      data: this.getStates(),\n      columns: [\n        {\n          id: 'cellId',\n          desc: 'Shape ID',\n          sort: 'asc',\n          select: false,\n        },\n        {\n          id: 'label',\n          desc: 'Label',\n          sort: 'asc',\n          select: false,\n        },\n        {\n          id: 'cellId',\n          desc: 'Shape ID',\n          sort: 'asc',\n          select: false,\n        },\n        {\n          id: 'font',\n          desc: 'Font color',\n          sort: 'asc',\n          select: false,\n        },\n        {\n          id: 'fill',\n          desc: 'Fill color',\n          sort: 'asc',\n          select: false,\n        },\n        {\n          id: 'stroke',\n          desc: 'Stroke color',\n          sort: 'asc',\n          select: false,\n        },\n        {\n          id: 'tags',\n          desc: 'Tags Mapping',\n          sort: 'asc',\n          select: false,\n        },\n      ],\n    };\n    this.ctrl = $scope.ctrl;\n    this.panel = this.ctrl.panel;\n    this.flowchartHandler = this.ctrl.flowchartHandler;\n    this.stateHandler = this.flowchartHandler.getFlowchart().getStateHandler();\n  }\n\n  render() {\n    this.panel.render();\n  }\n\n  // onDebug() {\n  //   GFP.log.logLevel = this.logLevel;\n  //   GFP.log.logDisplay = this.logDisplay;\n  // }\n\n  onChangeId(state: State) {\n    if (state.newcellId !== undefined && state.cellId !== state.newcellId) {\n      state.edited = true;\n      const sh = this.flowchartHandler.getFlowchart().getStateHandler();\n      if (sh !== undefined) {\n        sh.edited = true;\n      }\n      if (state.previousId === undefined) {\n        state.previousId = state.cellId;\n      }\n      state.cellId = state.newcellId;\n      state.edited = true;\n    }\n    state.edit = false;\n  }\n\n  onEdit(state: State) {\n    state.edit = true;\n    state.newcellId = state.cellId;\n    // let stateHandler = this.flowchartHandler.getFlowchart().getStateHandler();\n    // stateHandler.edited = true;\n    const elt = document.getElementById(state.cellId);\n    setTimeout(() => {\n      if (elt) {\n        elt.focus();\n      }\n    }, 100);\n  }\n\n  reset() {\n    this.flowchartHandler.draw();\n    this.flowchartHandler.refresh();\n    // this.$scope.$apply();\n  }\n\n  apply() {\n    const flowchart = this.flowchartHandler.getFlowchart();\n    const sh = flowchart.getStateHandler();\n    if (sh !== undefined) {\n      const states = sh.getStates();\n      states.forEach(state => {\n        if (state.edited && state.previousId) {\n          flowchart.renameId(state.previousId, state.cellId);\n          state.edited = false;\n        }\n      });\n      sh.edited = false;\n    }\n    flowchart.applyModel();\n  }\n\n  selectCell(state: State) {\n    state.highlightCell();\n  }\n\n  unselectCell(state: State) {\n    state.unhighlightCell();\n  }\n\n  getStates(): State[] {\n    if (this.stateHandler) {\n      const states = this.stateHandler.getStatesForInspect();\n      return _.orderBy(states, ['cellId', 'globalLevel'], ['asc']);\n    }\n    return [];\n  }\n\n  getStateValue(state: State, col: string): string | null {\n    switch (col) {\n      case 'cellId':\n        return state.cellId;\n        break;\n      case 'level':\n        return state.getTextLevel();\n        break;\n      case 'label':\n        return state.getCellProp('value');\n        break;\n\n      default:\n        return null;\n        break;\n    }\n  }\n\n  tracePerf() {\n    if (this.traceEnable) {\n      $GF.trace.enable();\n    } else {\n      $GF.trace.disable();\n    }\n  }\n\n  anonymize() {\n    const fc = this.flowchartHandler.getFlowchart();\n    const xg = fc.getXGraph();\n    if (xg) {\n      xg.anonymize();\n    }\n  }\n}\n\n/** @ngInject */\nexport function inspectOptionsTab($q, uiSegmentSrv) {\n  'use strict';\n  return {\n    restrict: 'E',\n    scope: true,\n    templateUrl: `${$GF.plugin.getPartialPath()}inspect/index.html`,\n    controller: InspectOptionsCtrl,\n  };\n}\n","import { FlowchartHandler } from './flowchartHandler';\nimport { RulesHandler } from 'rulesHandler';\nimport { Rule, EventMap } from 'rule_class';\nimport { $GF } from 'globals_class';\nimport grafana from 'grafana_func';\nimport _ from 'lodash';\nimport { MetricHandler } from './metricHandler';\n\nexport class MappingOptionsCtrl {\n  $scope: gf.TMappingOptionsScope;\n  ctrl: any;\n  panel: any;\n  flowchartHandler: FlowchartHandler;\n  rulesHandler: RulesHandler;\n  metricHandler: MetricHandler;\n  unitFormats: any;\n  style = $GF.CONSTANTS.COLORMETHODS;\n  metricType: gf.TSelectString[] = $GF.CONSTANTS.METRIC_TYPES;\n  colorOn = $GF.CONSTANTS.COLOR_APPLYON;\n  linkOn = $GF.CONSTANTS.LINK_APPLYON;\n  tooltipOn = $GF.CONSTANTS.TOOLTIP_APPLYON;\n  textOn = $GF.CONSTANTS.TEXT_APPLYON;\n  textReplace = $GF.CONSTANTS.TEXTMETHODS;\n  EventType = EventMap.getDefaultMethods();\n  tpDirection: gf.TSelectString[] = $GF.CONSTANTS.TOOLTIP_DIRECTION_TYPES;\n  propTypes: gf.TSelectString[] = $GF.CONSTANTS.IDENT_TYPES;\n  textPattern = '/.*/';\n  metricTypes = $GF.CONSTANTS.VALUE_TYPES;\n  dateFormats: gf.TSelectString[] = $GF.CONSTANTS.VALUE_DATEFORMAT_TYPES;\n  aggregationTypes = $GF.CONSTANTS.AGGREGATION_TYPES;\n  mappingTypes = $GF.CONSTANTS.VALUEMAPPINGTYPES;\n  tpGraphType = $GF.CONSTANTS.TOOLTIP_GRAPH_TYPES;\n  tpGraphScale = $GF.CONSTANTS.TOOLTIP_GRAPH_SCALE_TYPES;\n  tpGraphSize = $GF.CONSTANTS.TOOLTIP_GRAPH_SIZE_TYPES;\n  getMetricNames: () => any[];\n  getCellNames: (prop: gf.TPropertieKey) => any[];\n  getCellNamesById: () => any[];\n  getCellNamesByValue: () => any[];\n  getVariables: () => any;\n  // getEventValues: () => any;\n  getEventValues: string[];\n\n  /** @ngInject */\n  constructor($scope: gf.TMappingOptionsScope) {\n    $scope.editor = this;\n    $scope.$GF = $GF.me();\n    this.$scope = $scope;\n    this.ctrl = $scope.ctrl;\n    this.panel = this.ctrl.panel;\n    this.rulesHandler = this.ctrl.rulesHandler;\n    this.flowchartHandler = this.ctrl.flowchartHandler;\n    this.rulesHandler = this.ctrl.rulesHandler;\n    this.metricHandler = this.ctrl.metricHandler;\n    this.unitFormats = grafana.getUnitFormats();\n    this.tpGraphSize = $GF.CONSTANTS.TOOLTIP_GRAPH_SIZE_TYPES;\n\n    this.getMetricNames = (): string[] => {\n      return this.metricHandler.getNames('serie');\n    };\n\n    this.getCellNames = (prop: gf.TPropertieKey = 'id'): string[] => {\n      const flowchart = this.flowchartHandler.getFlowchart();\n      const cells = flowchart.getNamesByProp(prop);\n      const uniq = new Set(cells);\n      let filter = [...uniq];\n      filter = filter.filter(e => e !== undefined && e.length > 0);\n      return filter;\n    };\n\n    this.getCellNamesById = (): string[] => {\n      return this.getCellNames('id');\n    };\n\n    this.getCellNamesByValue = (): string[] => {\n      return this.getCellNames('value');\n    };\n\n    this.getVariables = () => {\n      return $GF.getFullAvailableVarNames();\n    };\n\n    this.getEventValues = [];\n  }\n\n  isFirstRule(index: number): boolean {\n    if (index === 0) {\n      return true;\n    }\n    return false;\n  }\n\n  isOnlySeries(): boolean {\n    const bool = this.metricHandler.isTypeOf('serie') && !this.metricHandler.isTypeOf('table');\n    return bool;\n  }\n\n  isOnlyTables(): boolean {\n    const bool = !this.metricHandler.isTypeOf('serie') && this.metricHandler.isTypeOf('table');\n    return bool;\n  }\n\n  isMultipleType(): boolean {\n    const bool = this.metricHandler.isTypeOf('serie') && this.metricHandler.isTypeOf('table');\n    return bool;\n  }\n\n  initType(rule: Rule) {\n    if (this.isOnlyTables()) {\n      rule.data.metricType = 'table';\n    } else if (this.isOnlySeries()) {\n      rule.data.metricType = 'serie';\n    }\n  }\n\n  getTablesName(): string[] {\n    return this.metricHandler.getNames('table');\n  }\n\n  getColumnsForTable(tableName: string): string[] {\n    return this.metricHandler.getColumnsName(tableName, 'table');\n  }\n\n  isLastRule(index: number): boolean {\n    const count = this.rulesHandler.countRules();\n    if (index === count - 1) {\n      return true;\n    }\n    return false;\n  }\n\n  render() {\n    this.ctrl.render();\n  }\n\n  setUnitFormat(rule: Rule, subItem: any) {\n    rule.data.unit = subItem.value;\n    this.onRulesChange();\n  }\n\n  onRulesChange() {\n    $GF.log.info('MappingOptionsCtrl.onRulesChange()');\n    this.flowchartHandler.onRulesChange();\n    this.render();\n    return true;\n  }\n\n  getLevels(rule: Rule): gf.TSelectNumber[] {\n    let lvl: gf.TSelectNumber[] = [];\n    let count = rule.data.colors.length;\n    for (let index = 0; index < count; index++) {\n      lvl.push({ text: `${index}`, value: index });\n    }\n    return lvl;\n  }\n\n  removeShapeMap(rule: Rule, index: number) {\n    const shape = rule.getShapeMap(index);\n    this.unselectCell(rule.data.shapeProp, shape.data.pattern);\n    rule.removeShapeMap(index);\n  }\n\n  removeTextMap(rule: Rule, index: number) {\n    const txt = rule.getTextMap(index);\n    this.unselectCell(rule.data.textProp, txt.data.pattern);\n    rule.removeTextMap(index);\n  }\n\n  removeLinkMap(rule: Rule, index: number) {\n    const lnk = rule.getLinkMap(index);\n    this.unselectCell(rule.data.linkProp, lnk.data.pattern);\n    rule.removeLinkMap(index);\n  }\n\n  removeEventMap(rule: Rule, index: number) {\n    const evt = rule.getEventMap(index);\n    this.unselectCell(rule.data.eventProp, evt.data.pattern);\n    rule.removeEventMap(index);\n  }\n\n  /**\n   * Add Color\n   *\n   * @param {Number} ruleIndex\n   * @param {Number} colorIndex\n   * @memberof MappingOptionsCtrl\n   */\n  onColorChange(ruleIndex: number, colorIndex: number) {\n    return (newColor: any) => {\n      const rule = this.rulesHandler.getRule(ruleIndex);\n      rule.data.colors[colorIndex] = newColor;\n      this.onRulesChange();\n    };\n  }\n\n  /**\n   * Display cell selection in graph\n   * @param  {} prop\n   * @param  {} value\n   */\n  async selectCell(prop: gf.TPropertieKey, value: string) {\n    const flowchart = this.flowchartHandler.getFlowchart();\n    const xgraph = flowchart.getXGraph();\n    if (xgraph) {\n      xgraph.selectMxCells(prop, value);\n    }\n  }\n\n  /**\n   * Undisplay cell selection\n   *\n   * @memberof MappingOptionsCtrl\n   */\n  async unselectCell(prop: gf.TPropertieKey, value: string) {\n    const flowchart = this.flowchartHandler.getFlowchart();\n    const xgraph = flowchart.getXGraph();\n    if (xgraph) {\n      xgraph.unselectMxCells(prop, value);\n    }\n  }\n\n  /**\n   * Disable/Enable rule\n   *\n   * @param {Rule} rule\n   * @param {boolean} bool\n   * @memberof MappingOptionsCtrl\n   */\n  toggleShow(rule: Rule, bool: boolean) {\n    rule.data.hidden = bool;\n    this.onRulesChange();\n  }\n\n  /**\n   * Turn Highlight on of cells in rule\n   *\n   * @param {*} rule\n   * @memberof MappingOptionsCtrl\n   */\n  async highlightCells(rule: Rule) {\n    rule.highlightCells();\n  }\n\n  /**\n   * Turn Highlight off of cells in rule\n   *\n   * @param {*} rule\n   * @memberof MappingOptionsCtrl\n   */\n  async unhighlightCells(rule: Rule) {\n    rule.unhighlightCells();\n  }\n\n  /**\n   * Turn Highlight off all cells\n   *\n   * @param {*} rule\n   * @memberof MappingOptionsCtrl\n   */\n  async unhighlightAllCells() {\n    const flowchart = this.flowchartHandler.getFlowchart();\n    const xgraph = flowchart.getXGraph();\n    if (xgraph) {\n      xgraph.unhighlightCells();\n    }\n  }\n\n  //\n  // RULE\n  //\n\n  /**\n   * Remove a rule\n   *\n   * @param {Rule} rule\n   * @param {boolean} [force]\n   * @memberof MappingOptionsCtrl\n   */\n  removeRule(rule: Rule, force?: boolean) {\n    if (rule.removeClick === 1 || force) {\n      this.rulesHandler.removeRule(rule);\n      this.onRulesChange();\n    }\n    rule.removeClick = 1;\n    window.setInterval(() => {\n      if (rule) {\n        rule.removeClick = 2;\n      }\n    }, 2000);\n  }\n\n  /**\n   * Clone a rule\n   *\n   * @param {Rule} rule\n   * @memberof MappingOptionsCtrl\n   */\n  cloneRule(rule: Rule) {\n    this.rulesHandler.cloneRule(rule);\n    this.onRulesChange();\n  }\n\n  /**\n   * Move rule up or down\n   *\n   * @param {Rule} rule\n   * @param {boolean} up\n   * @memberof MappingOptionsCtrl\n   */\n  moveRule(rule: Rule, up: boolean) {\n    if (up) {\n      this.rulesHandler.moveRuleToUp(rule);\n    } else {\n      this.rulesHandler.moveRuleToDown(rule);\n    }\n    this.onRulesChange();\n  }\n\n  //\n  // Events\n  //\n  onEventValue(event: EventMap) {\n    this.getEventValues = event.getTypeahead();\n  }\n}\n\n/** @ngInject */\nexport function mappingOptionsTab($q, uiSegmentSrv) {\n  'use strict';\n  return {\n    restrict: 'E',\n    scope: true,\n    templateUrl: `${$GF.plugin.getPartialPath()}/mapping/index.html`,\n    controller: MappingOptionsCtrl,\n  };\n}\n","import _ from 'lodash';\nimport { Metric, Serie, Table } from './metric_class';\nimport { $GF } from 'globals_class';\n\n/**\n * Data Series/Tables handler\n *\n * @export\n * @class MetricHandler\n */\nexport class MetricHandler {\n  panel: any;\n  // $scope: ng.IScope;\n  tables: Table[] = [];\n  series: Serie[] = [];\n  metrics: Array<Serie | Table> = [];\n  // constructor($scope: ng.IScope) {\n  //   this.$scope = $scope;\n  // }\n  constructor() {}\n\n  /**\n   * Init data with dataList\n   *\n   * @param {any} dataList\n   * @memberof MetricHandler\n   */\n  initData(dataList: any) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'initData()');\n    this.tables = [];\n    this.series = [];\n    this.metrics = [];\n\n    dataList.forEach(dl => {\n      this.addMetric(dl);\n    });\n    trc.after();\n  }\n\n  /**\n   * Add/convert dataList to Metric\n   *\n   * @param {*} data\n   * @memberof MetricHandler\n   */\n  addMetric(data: any) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'addMetric()');\n    if (data.type === 'table') {\n      this.addTable(data);\n    } else {\n      this.addSerie(data);\n    }\n    trc.after();\n  }\n\n  /**\n   * Convert and add dataList to a Metric Table\n   *\n   * @param {any} data\n   * @returns {Table}\n   * @memberof MetricHandler\n   */\n  addTable(data: any): Table {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'addTable()');\n    const table = new Table(data);\n    this.tables.push(table);\n    this.metrics.push(table);\n    trc.after();\n    return table;\n  }\n\n  /**\n   * Convert and add dataList to a Metric Serie\n   *\n   * @param {any} data\n   * @returns {Serie}\n   * @memberof MetricHandler\n   */\n  addSerie(data: any): Serie {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'addSerie()');\n    const serie = new Serie(data);\n    this.series.push(serie);\n    this.metrics.push(serie);\n    trc.after();\n    return serie;\n  }\n\n  /**\n   * get Names of metrics (serie or table or both if type is undefined)\n   *\n   * @param {gf.TMetricTypeKeys} [type]\n   * @returns {string[]}\n   * @memberof MetricHandler\n   */\n  getNames(type?: gf.TMetricTypeKeys): string[] {\n    let names: string[] = [];\n    if (type === 'serie') {\n      names = this.series.map(m => m.getName());\n    } else if (type === 'table') {\n      names = this.tables.map(m => m.getName());\n    } else {\n      names = this.metrics.map(m => m.getName());\n    }\n    // GFGlobal.log.debug('getNames', names);\n    return names;\n  }\n\n  /**\n   * get Metrics, series or tables or both if type is undefined\n   *\n   * @param {gf.TMetricTypeKeys} [type]\n   * @returns {Metric[]}\n   * @memberof MetricHandler\n   */\n  getMetrics(type?: gf.TMetricTypeKeys): Metric[] {\n    if (type === 'serie') {\n      return this.series;\n    }\n    if (type === 'table') {\n      return this.tables;\n    }\n    return this.metrics;\n  }\n\n  /**\n   * Define if have tables or serie\n   *\n   * @param {gf.TMetricTypeKeys} [type]\n   * @returns {boolean}\n   * @memberof MetricHandler\n   */\n  isTypeOf(type?: gf.TMetricTypeKeys): boolean {\n    if (type === 'serie') {\n      return this.series.length > 0;\n    }\n    if (type === 'table') {\n      return this.tables.length > 0;\n    }\n    return false;\n  }\n\n  /**\n   * Get metrics with this name Serie or table or both\n   *\n   * @param {string} name\n   * @param {gf.TMetricTypeKeys} [type]\n   * @returns {Metric[]}\n   * @memberof MetricHandler\n   */\n  findMetrics(name: string, type?: gf.TMetricTypeKeys): Metric[] {\n    let metrics: Metric[] = [];\n    if (type) {\n      if (type === 'table') {\n        metrics = this.tables.filter(m => m.getName() === name);\n      }\n      if (type === 'serie') {\n        metrics = this.series.filter(m => m.getName() === name);\n      }\n    } else {\n      metrics = this.metrics.filter(m => m.getName() === name);\n    }\n    return metrics;\n  }\n\n  /**\n   * Get column name for a metric\n   *\n   * @param {string} metricName\n   * @param {gf.TMetricTypeKeys} [type]\n   * @returns {string[]}\n   * @memberof MetricHandler\n   */\n  getColumnsName(metricName: string, type?: gf.TMetricTypeKeys): string[] {\n    const metrics = this.findMetrics(metricName, type);\n    let columns: string[] = [];\n    metrics.forEach(m => {\n      columns = columns.concat(m.getColumnsName());\n    });\n    return columns;\n  }\n}\n","import grafana from './grafana_func';\nimport _ from 'lodash';\nimport { $GF } from 'globals_class';\n\n/**\n * Metric parent\n *\n * @export\n * @class Metric\n */\nexport class Metric {\n  type = 'unknow';\n  scopedVars: any;\n  metrics: any = {};\n  name = '';\n  nullPointMode = 'connected';\n  constructor(dataList: any) {}\n\n  /**\n   * Get name of metric\n   *\n   * @returns {string}\n   * @memberof Metric\n   */\n  getName(): string {\n    if (this.name === undefined || this.name === null) {\n      $GF.log.error('Metric => getName : Name is null');\n    }\n    return this.name;\n  }\n\n  /**\n   * Get value of metric for an aggregation\n   *\n   * @param {gf.TAggregationKeys} aggregator\n   * @param {string} [column]\n   * @returns {(string | number | null)}\n   * @memberof Metric\n   */\n  getValue(aggregator: gf.TAggregationKeys, column?: string): string | number | null {\n    return null;\n  }\n\n  findValue(timestamp: number, column?: string): string | number | null {\n    return null;\n  }\n\n  /**\n   * Return coordinates for graph {x:time,y:value}\n   *\n   * @param {string} [column]\n   * @returns {gf.TGraphCoordinate[]}\n   * @memberof Metric\n   */\n  getData(column?: string, log: boolean = false): number[] | Array<{ x: number | Date; y: number }> {\n    return [];\n  }\n\n  /**\n   * Return columns for this metric\n   *\n   * @returns {string[]}\n   * @memberof Metric\n   */\n  getColumnsName(): string[] {\n    return [];\n  }\n}\n\n/**\n * Serie data\n *\n * @export\n * @class Serie\n * @extends {Metric}\n */\n/**\n * Serie type for a metric\n *\n * @export\n * @class Serie\n * @extends {Metric}\n */\nexport class Serie extends Metric {\n  constructor(dataList: any) {\n    super(dataList);\n    this.type = 'serie';\n    this.metrics = this.seriesHandler(dataList);\n    this.addCustomStats();\n    this.name = this.metrics.alias;\n  }\n\n  seriesHandler(seriesData) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'seriesHandler()');\n    const series = grafana.getTimeSeries(seriesData);\n    series.flotpairs = series.getFlotPairs(this.nullPointMode);\n    trc.after();\n    return series;\n  }\n\n  addCustomStats() {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'addCustomStats()');\n    try {\n      let lg = this.metrics.flotpairs.length;\n      // LAST TIME\n      this.metrics.stats['last_time'] = this.metrics.flotpairs[lg - 1][0];\n      // LAST\n      this.metrics.stats['current'] = this.metrics.flotpairs[lg - 1][1];\n      // LAST NOT NULL\n      this.metrics.stats['current_notnull'] = null;\n      let idx = lg - 1;\n      while ((this.metrics.flotpairs[idx][1] === null || this.metrics.flotpairs[idx][1] === undefined) && idx >= 0) {\n        idx -= 1;\n      }\n      if (idx >= 0) {\n        this.metrics.stats['current_notnull'] = this.metrics.flotpairs[idx][1];\n      }\n      // FIRST\n      this.metrics.stats['first'] = this.metrics.flotpairs[0][1];\n      // FIRST NOT NULL\n      this.metrics.stats['first_notnull'] = null;\n      idx = 0;\n      while ((this.metrics.flotpairs[idx][1] === null || this.metrics.flotpairs[idx][1] === undefined) && idx < lg) {\n        idx += 1;\n      }\n      if (idx < lg) {\n        this.metrics.stats['first_notnull'] = this.metrics.flotpairs[idx][1];\n      }\n    } catch (error) {\n      $GF.log.error('Unable to add custom stats', error);\n    }\n    trc.after();\n  }\n\n  /**\n   * Get value of serie for an aggregation\n   *\n   * @param {gf.TAggregationKeys} aggregator\n   * @param {string} [column]\n   * @returns {(string | number | null)}\n   * @memberof Metric\n   */\n  getValue(aggregator: gf.TAggregationKeys): string | number | null {\n    try {\n      let value: string | number | null = null;\n      if ($GF.hasGraphHover()) {\n        const timestamp = $GF.getGraphHover();\n        value = timestamp !== undefined ? this.findValue(timestamp) : null;\n      } else {\n        value = this.metrics.stats[aggregator];\n      }\n      return value;\n    } catch (error) {\n      $GF.log.error('datapoint for serie is null', error);\n      return null;\n    }\n  }\n\n  /**\n   * find a value by a timestamp\n   *\n   * @param {number} timestamp\n   * @returns {(string | number | null)}\n   * @memberof Serie\n   */\n  findValue(timestamp: number): string | number | null {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'findValue()');\n    let low = 0;\n    let high = this.metrics.flotpairs.length - 1;\n    let found = !(high > 0);\n    timestamp = Math.round(timestamp);\n    let value = null;\n    while (!found) {\n      let middle = low + Math.round((high - low) / 2);\n      if (this.metrics.flotpairs[middle][0] === timestamp) {\n        value = this.metrics.flotpairs[middle][1];\n        found = true;\n      }\n      if (!found && low < middle && middle < high) {\n        if (timestamp > this.metrics.flotpairs[middle][0]) {\n          low = middle;\n        }\n        if (timestamp < this.metrics.flotpairs[middle][0]) {\n          high = middle;\n        }\n      } else {\n        if (this.metrics.flotpairs[middle][0] > timestamp && middle >= 1) {\n          value = this.metrics.flotpairs[middle - 1][1];\n        } else {\n          value = this.metrics.flotpairs[middle][1];\n        }\n        found = true;\n      }\n    }\n    trc.after();\n    return value;\n  }\n\n  getData(column: string = '', log: boolean = false): number[] | Array<{ x: number | Date; y: number }> {\n    return this.metrics.flotpairs.map(d => {\n      if (!!log) {\n        return { x: d[0], y: Math.log10(d[1]) };\n      }\n      return { x: d[0], y: d[1] };\n    });\n  }\n\n  getColumnsName(): string[] {\n    //TODO: If multi column\n    return ['time', 'value'];\n  }\n}\n\n/**\n * Table data\n *\n * @export\n * @class Table\n * @extends {Metric}\n */\nexport class Table extends Metric {\n  tableColumnOptions: any = {};\n  tableColumn = '';\n  allIsNull = true;\n  allIsZero = true;\n  constructor(dataList: any) {\n    super(dataList);\n    this.type = 'table';\n    this.name = dataList.refId;\n    this.metrics = this.tableHandler(dataList);\n  }\n\n  tableHandler(tableData: any) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'tableHandler()');\n    const table: any = {\n      datapoints: [],\n      columnNames: {},\n      stats: {},\n    };\n\n    tableData.columns.forEach((column, columnIndex) => {\n      table.columnNames[columnIndex] = column.text;\n      if (column.text.toString().toLowerCase() === 'time') {\n        table.timeIndex = columnIndex;\n        table.timeColumn = column.text;\n      }\n    });\n\n    this.tableColumnOptions = table.columnNames;\n    if (!_.find(tableData.columns, ['text', this.tableColumn])) {\n      this.setTableColumnToSensibleDefault(tableData);\n    }\n\n    tableData.rows.forEach(row => {\n      const datapoint = {};\n      row.forEach((value, columnIndex) => {\n        const key = table.columnNames[columnIndex];\n        datapoint[key] = value;\n      });\n      table.datapoints.push(datapoint);\n    });\n    this.metrics.flotpairs = this.getFlotPairs(this.nullPointMode, table);\n    trc.after();\n    return table;\n  }\n\n  setTableColumnToSensibleDefault(tableData: any) {\n    if (tableData.columns.length === 1) {\n      this.tableColumn = tableData.columns[0].text;\n    } else {\n      this.tableColumn = _.find(tableData.columns, col => {\n        return col.type !== 'time';\n      }).text;\n    }\n  }\n\n  getFlotPairs(fillStyle: string, table: any) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'getFlotPairs()');\n    const result: any[] = [];\n    const ignoreNulls = fillStyle === 'connected';\n    const nullAsZero = fillStyle === 'null as zero';\n    table.allIsNull = true;\n    table.allIsZero = true;\n\n    for (const idx in table.columnNames) {\n      // let index = Number(idx);\n      // if (table.timeIndex !== undefined && table.timeIndex !== null && index === table.timeIndex) continue;\n      const currName = table.columnNames[idx];\n      table.stats[currName] = {};\n      table.stats[currName].name = currName;\n      table.stats[currName].total = 0;\n      table.stats[currName].max = -Number.MAX_VALUE;\n      table.stats[currName].min = Number.MAX_VALUE;\n      table.stats[currName].logmin = Number.MAX_VALUE;\n      table.stats[currName].avg = null;\n      table.stats[currName].current = null;\n      table.stats[currName].current_notnull = null;\n      table.stats[currName].first = null;\n      table.stats[currName].first_notnull = null;\n      table.stats[currName].delta = 0;\n      table.stats[currName].diff = null;\n      table.stats[currName].range = null;\n      table.stats[currName].timeStep = Number.MAX_VALUE;\n\n      let currentTime: any;\n      let currentValue: any;\n      let nonNulls = 0;\n      let previousTime;\n      let previousValue = 0;\n      let previousDeltaUp = true;\n\n      try {\n        for (let i = 0; i < table.datapoints.length; i++) {\n          if (table.timeColumn) {\n            currentTime = table.datapoints[i][table.timeColumn];\n          }\n          currentValue = table.datapoints[i][currName];\n\n          if (previousTime !== undefined) {\n            const timeStep = currentTime - previousTime;\n            if (timeStep < table.stats[currName].timeStep) {\n              table.stats[currName].timeStep = timeStep;\n            }\n          }\n          previousTime = currentTime;\n\n          if (currentValue === null) {\n            if (ignoreNulls) {\n              continue;\n            }\n            if (nullAsZero) {\n              currentValue = 0;\n            }\n          }\n\n          if (currentValue !== null) {\n            if (_.isNumber(currentValue)) {\n              table.stats[currName].total += currentValue;\n              this.allIsNull = false;\n              nonNulls++;\n            }\n\n            if (currentValue > table.stats[currName].max) {\n              table.stats[currName].max = currentValue;\n            }\n\n            if (currentValue < table.stats[currName].min) {\n              table.stats[currName].min = currentValue;\n            }\n\n            if (table.stats[currName].first === null) {\n              table.stats[currName].first = currentValue;\n            } else {\n              if (previousValue > currentValue) {\n                // counter reset\n                previousDeltaUp = false;\n                if (i === table.datapoints.length - 1) {\n                  // reset on last\n                  table.stats[currName].delta += currentValue;\n                }\n              } else {\n                if (previousDeltaUp) {\n                  table.stats[currName].delta += currentValue - previousValue; // normal increment\n                } else {\n                  table.stats[currName].delta += currentValue; // account for counter reset\n                }\n                previousDeltaUp = true;\n              }\n            }\n            previousValue = currentValue;\n\n            if (currentValue < table.stats[currName].logmin && currentValue > 0) {\n              table.stats[currName].logmin = currentValue;\n            }\n\n            if (currentValue !== 0) {\n              this.allIsZero = false;\n            }\n          }\n          result.push([currentTime, currentValue]);\n        }\n      } catch (error) {\n        $GF.log.error('Unable to aggregate data', error);\n      }\n\n      if (currentTime) {\n        table.stats[currName].last_time = currentTime;\n      }\n\n      if (table.stats[currName].max === -Number.MAX_VALUE) {\n        table.stats[currName].max = null;\n      }\n      if (table.stats[currName].min === Number.MAX_VALUE) {\n        table.stats[currName].min = null;\n      }\n\n      if (result.length && !this.allIsNull) {\n        table.stats[currName].avg = table.stats[currName].total / nonNulls;\n        table.stats[currName].current = result[result.length - 1][1];\n        if (table.stats[currName].current === null && result.length > 1) {\n          table.stats[currName].current = result[result.length - 2][1];\n        }\n      }\n      if (table.stats[currName].max !== null && table.stats[currName].min !== null) {\n        table.stats[currName].range = table.stats[currName].max - table.stats[currName].min;\n      }\n      if (table.stats[currName].current !== null && table.stats[currName].first !== null) {\n        table.stats[currName].diff = table.stats[currName].current - table.stats[currName].first;\n      }\n\n      table.stats[currName].count = result.length;\n    }\n    trc.after();\n    return result;\n  }\n\n  /**\n   * Get value of table for an aggregation\n   *\n   * @param {gf.TAggregationKeys} aggregator\n   * @param {string} [column]\n   * @returns {(string | number | null)}\n   * @memberof Metric\n   */\n  getValue(aggregator: gf.TAggregationKeys, column: string): string | number | null {\n    try {\n      let value: string | number | null = null;\n      if ($GF.hasGraphHover()) {\n        const timestamp = $GF.getGraphHover();\n        value = timestamp !== undefined ? this.findValue(timestamp, column) : null;\n      } else {\n        value = this.metrics.stats[column][aggregator];\n      }\n      return value;\n    } catch (error) {\n      $GF.log.error('datapoint for table is null', error);\n      return null;\n    }\n  }\n\n  /**\n   * find a value by a timestamp\n   *\n   * @param {number} timestamp\n   * @returns {(string | number | null)}\n   * @memberof Serie\n   */\n  findValue(timestamp: number, column: string): string | number | null {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'findValue()');\n    let low = 0;\n    let high = this.metrics.datapoints.length - 1;\n    let found = !(high > 0 && this.metrics.datapoints[low][this.metrics.timeColumn] < timestamp);\n    timestamp = Math.round(timestamp);\n    let value = null;\n    while (!found) {\n      let middle = low + Math.round((high - low) / 2);\n      if (this.metrics.datapoints[middle][this.metrics.timeColumn] === timestamp) {\n        value = this.metrics.datapoints[middle][column];\n        found = true;\n      }\n      if (!found && low < middle && middle < high) {\n        if (timestamp > this.metrics.datapoints[middle][this.metrics.timeColumn]) {\n          low = middle;\n        }\n        if (timestamp < this.metrics.datapoints[middle][this.metrics.timeColumn]) {\n          high = middle;\n        }\n      } else {\n        if (this.metrics.datapoints[middle][this.metrics.timeColumn] > timestamp && middle >= 1) {\n          value = this.metrics.datapoints[middle - 1][column];\n        } else {\n          value = this.metrics.datapoints[middle][column];\n        }\n        found = true;\n      }\n    }\n    trc.after();\n    return value;\n  }\n\n  /**\n   * Return the index of a column\n   *\n   * @param {string} column\n   * @returns {(number | null)}\n   * @memberof Table\n   */\n  getColumnIndex(column: string): number | null {\n    for (const idx in this.tableColumnOptions) {\n      if (column === this.tableColumnOptions[idx]) {\n        return Number(idx);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Return name of columns\n   *\n   * @returns {string[]}\n   * @memberof Table\n   */\n  getColumnsName(): string[] {\n    const result: string[] = [];\n    for (const idx in this.tableColumnOptions) {\n      result.push(this.tableColumnOptions[idx]);\n    }\n    return result;\n  }\n\n  /**\n   * Return formated data for tooltips graph\n   *\n   * @param {string} column\n   * @returns {(number[] | Array<{ x: number | Date; y: number }>)}\n   * @memberof Table\n   */\n  getData(column: string): number[] | Array<{ x: number | Date; y: number }> {\n    if (this.metrics.timeColumn) {\n      return this.metrics.datapoints.map(d => {\n        return { x: d[this.metrics.timeColumn], y: d[column] };\n      });\n    }\n    return this.metrics.datapoints.map(d => d[column]);\n  }\n}\n","import { FlowchartCtrl } from './flowchart_ctrl';\nimport grafana from './grafana_func';\n\ngrafana.loadCss();\n\nexport { FlowchartCtrl as PanelCtrl };\n","const customize = () => {\n  mxTooltipHandler.prototype.show = function (tip, x, y) {\n    // TYPE STRING\n    if (this.destroyed) {\n      return;\n    }\n    if (tip === null) {\n      return;\n    }\n    if (tip.length === 0) {\n      return;\n    }\n    // Initializes the DOM nodes if required\n    if (this.div == null) {\n      this.init();\n    }\n    if (!mxUtils.isNode(tip)) {\n      this.div.innerHTML = tip.replace(/\\n/g, '<br>');\n    } else {\n      this.div.innerHTML = '';\n      this.div.appendChild(tip);\n    }\n    this.$div.place_tt(x + 20, y);\n    this.div.style.visibility = '';\n    mxUtils.fit(this.div);\n  };\n\n  mxTooltipHandler.prototype.init = function () {\n    if (this.div === null || this.div === undefined) {\n      this.$div = $('<div class=\"graph-tooltip\">');\n      this.div = this.$div[0];\n      mxEvent.addGestureListeners(\n        this.div,\n        mxUtils.bind(this, function (evt) {\n          this.hideTooltip();\n        })\n      );\n    }\n  };\n\n  mxTooltipHandler.prototype.hideTooltip = function () {\n    if (this.div != null) {\n      this.div.style.visibility = 'hidden';\n      this.div.innerHTML = '';\n    }\n  };\n\n  mxTooltipHandler.prototype.delay = 200;\n\n  Graph.prototype.getTooltipForCell = function (cell) {\n    let hasTips = false;\n    let div = document.createElement('div');\n    if (mxUtils.isNode(cell.value)) {\n      let tmp = cell.value.getAttribute('tooltip');\n      // Tooltip\n      if (tmp != null) {\n        hasTips = true;\n        if (tmp !== null && this.isReplacePlaceholders(cell)) {\n          tmp = this.replacePlaceholders(cell, tmp);\n        }\n        let ttDiv = document.createElement('div');\n        ttDiv.className = 'tooltip-text';\n        ttDiv.innerHTML = this.sanitizeHtml(tmp);\n        div.appendChild(ttDiv);\n      }\n\n      let ignored = this.builtInProperties;\n      let attrs = cell.value.attributes;\n      let temp = [];\n\n      // Hides links in edit mode\n      // if (this.isEnabled()) {\n      ignored.push('link');\n      // }\n\n      // Attributes\n      for (var i = 0; i < attrs.length; i++) {\n        if (mxUtils.indexOf(ignored, attrs[i].nodeName) < 0 && attrs[i].nodeValue.length > 0) {\n          temp.push({ name: attrs[i].nodeName, value: attrs[i].nodeValue });\n        }\n      }\n\n      // Sorts by name\n      temp.sort(function (a, b) {\n        if (a.name < b.name) {\n          return -1;\n        } else if (a.name > b.name) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n      if (temp.length > 0) {\n        hasTips = true;\n        var attrDiv = document.createElement('div');\n        var attrString = '';\n        for (let i = 0; i < temp.length; i++) {\n          if (temp[i].name !== 'link' || !this.isCustomLink(temp[i].value)) {\n            attrString +=\n              (temp[i].name !== 'link' ? '<b>' + temp[i].name + ':</b> ' : '') +\n              mxUtils.htmlEntities(temp[i].value) +\n              '\\n';\n          }\n        }\n        attrDiv.innerHTML = attrString;\n        div.appendChild(attrDiv);\n      }\n    }\n\n    // GF Tooltips\n    if (cell.GF_tooltipHandler != null) {\n      let tooltipHandler = cell.GF_tooltipHandler;\n      let gfDiv = tooltipHandler.getDiv(div);\n      if (gfDiv !== null) {\n        hasTips = true;\n      }\n    }\n    if (hasTips) {\n      return div;\n    }\n    return '';\n  };\n\n  mxEvent.addMouseWheelListener = function (func, container) {\n    if (null != func) {\n      var c = function (container) {\n        null == container && (container = window.event);\n        var c;\n        c = mxClient.IS_FF ? -container.detail / 2 : container.wheelDelta / 120;\n        0 !== c && func(container, 0 < c);\n      };\n      mxClient.IS_NS && null == document.documentMode\n        ? mxEvent.addListener(\n          mxClient.IS_GC && null != container ? container : window,\n          mxClient.IS_SF || mxClient.IS_GC ? 'mousewheel' : 'DOMMouseScroll',\n          c\n        )\n        : mxEvent.addListener(document, 'mousewheel', c);\n    }\n  };\n};\n\n\nfunction evalCode() {\n  window.eval(window.atob(viewerCode));\n}\n\n\nexport { customize, evalCode };\n\nconst viewerCode = 'd2luZG93LlNURU5DSUxfUEFUSD13aW5kb3cuU1RFTkNJTF9QQVRIfHwiaHR0cHM6Ly93d3cuZHJhdy5pby9zdGVuY2lscyI7d2luZG93LlNIQVBFU19QQVRIPXdpbmRvdy5TSEFQRVNfUEFUSHx8Imh0dHBzOi8vd3d3LmRyYXcuaW8vc2hhcGVzIjt3aW5kb3cubXhCYXNlUGF0aD13aW5kb3cubXhCYXNlUGF0aHx8Imh0dHBzOi8vd3d3LmRyYXcuaW8vbXhncmFwaC8iO3dpbmRvdy5teExvYWRTdHlsZXNoZWV0cz13aW5kb3cubXhMb2FkU3R5bGVzaGVldHN8fCExOwovL2ZnbmFzcy5naXRodWIuY29tL3NwaW4uanMjdjIuMC4wCiFmdW5jdGlvbihhLGIpeyJvYmplY3QiPT10eXBlb2YgZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1iKCk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoYik6YS5TcGlubmVyPWIoKX0odGhpcyxmdW5jdGlvbigpeyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiBhKGEsYil7dmFyIGMsZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KGF8fCJkaXYiKTtmb3IoYyBpbiBiKWRbY109YltjXTtyZXR1cm4gZH1mdW5jdGlvbiBiKGEpe2Zvcih2YXIgYj0xLGM9YXJndW1lbnRzLmxlbmd0aDtjPmI7YisrKWEuYXBwZW5kQ2hpbGQoYXJndW1lbnRzW2JdKTtyZXR1cm4gYX1mdW5jdGlvbiBjKGEsYixjLGQpe3ZhciBlPVsib3BhY2l0eSIsYix+figxMDAqYSksYyxkXS5qb2luKCItIiksZj0uMDErYy9kKjEwMCxnPU1hdGgubWF4KDEtKDEtYSkvYiooMTAwLWYpLGEpLGg9ai5zdWJzdHJpbmcoMCxqLmluZGV4T2YoIkFuaW1hdGlvbiIpKS50b0xvd2VyQ2FzZSgpLGk9aCYmIi0iK2grIi0ifHwiIjtyZXR1cm4gbFtlXXx8KG0uaW5zZXJ0UnVsZSgiQCIraSsia2V5ZnJhbWVzICIrZSsiezAle29wYWNpdHk6IitnKyJ9IitmKyIle29wYWNpdHk6IithKyJ9IisoZisuMDEpKyIle29wYWNpdHk6MX0iKyhmK2IpJTEwMCsiJXtvcGFjaXR5OiIrYSsifTEwMCV7b3BhY2l0eToiK2crIn19IixtLmNzc1J1bGVzLmxlbmd0aCksbFtlXT0xKSxlfWZ1bmN0aW9uIGQoYSxiKXt2YXIgYyxkLGU9YS5zdHlsZTtmb3IoYj1iLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Iuc2xpY2UoMSksZD0wO2Q8ay5sZW5ndGg7ZCsrKWlmKGM9a1tkXStiLHZvaWQgMCE9PWVbY10pcmV0dXJuIGM7cmV0dXJuIHZvaWQgMCE9PWVbYl0/Yjp2b2lkIDB9ZnVuY3Rpb24gZShhLGIpe2Zvcih2YXIgYyBpbiBiKWEuc3R5bGVbZChhLGMpfHxjXT1iW2NdO3JldHVybiBhfWZ1bmN0aW9uIGYoYSl7Zm9yKHZhciBiPTE7Yjxhcmd1bWVudHMubGVuZ3RoO2IrKyl7dmFyIGM9YXJndW1lbnRzW2JdO2Zvcih2YXIgZCBpbiBjKXZvaWQgMD09PWFbZF0mJihhW2RdPWNbZF0pfXJldHVybiBhfWZ1bmN0aW9uIGcoYSxiKXtyZXR1cm4ic3RyaW5nIj09dHlwZW9mIGE/YTphW2IlYS5sZW5ndGhdfWZ1bmN0aW9uIGgoYSl7dGhpcy5vcHRzPWYoYXx8e30saC5kZWZhdWx0cyxuKX1mdW5jdGlvbiBpKCl7ZnVuY3Rpb24gYyhiLGMpe3JldHVybiBhKCI8IitiKycgeG1sbnM9InVybjpzY2hlbWFzLW1pY3Jvc29mdC5jb206dm1sIiBjbGFzcz0ic3Bpbi12bWwiPicsYyl9bS5hZGRSdWxlKCIuc3Bpbi12bWwiLCJiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKSIpLGgucHJvdG90eXBlLmxpbmVzPWZ1bmN0aW9uKGEsZCl7ZnVuY3Rpb24gZigpe3JldHVybiBlKGMoImdyb3VwIix7Y29vcmRzaXplOmsrIiAiK2ssY29vcmRvcmlnaW46LWorIiAiKy1qfSkse3dpZHRoOmssaGVpZ2h0Omt9KX1mdW5jdGlvbiBoKGEsaCxpKXtiKG0sYihlKGYoKSx7cm90YXRpb246MzYwL2QubGluZXMqYSsiZGVnIixsZWZ0On5+aH0pLGIoZShjKCJyb3VuZHJlY3QiLHthcmNzaXplOmQuY29ybmVyc30pLHt3aWR0aDpqLGhlaWdodDpkLndpZHRoLGxlZnQ6ZC5yYWRpdXMsdG9wOi1kLndpZHRoPj4xLGZpbHRlcjppfSksYygiZmlsbCIse2NvbG9yOmcoZC5jb2xvcixhKSxvcGFjaXR5OmQub3BhY2l0eX0pLGMoInN0cm9rZSIse29wYWNpdHk6MH0pKSkpfXZhciBpLGo9ZC5sZW5ndGgrZC53aWR0aCxrPTIqaixsPTIqLShkLndpZHRoK2QubGVuZ3RoKSsicHgiLG09ZShmKCkse3Bvc2l0aW9uOiJhYnNvbHV0ZSIsdG9wOmwsbGVmdDpsfSk7aWYoZC5zaGFkb3cpZm9yKGk9MTtpPD1kLmxpbmVzO2krKyloKGksLTIsInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5CbHVyKHBpeGVscmFkaXVzPTIsbWFrZXNoYWRvdz0xLHNoYWRvd29wYWNpdHk9LjMpIik7Zm9yKGk9MTtpPD1kLmxpbmVzO2krKyloKGkpO3JldHVybiBiKGEsbSl9LGgucHJvdG90eXBlLm9wYWNpdHk9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9YS5maXJzdENoaWxkO2Q9ZC5zaGFkb3cmJmQubGluZXN8fDAsZSYmYitkPGUuY2hpbGROb2Rlcy5sZW5ndGgmJihlPWUuY2hpbGROb2Rlc1tiK2RdLGU9ZSYmZS5maXJzdENoaWxkLGU9ZSYmZS5maXJzdENoaWxkLGUmJihlLm9wYWNpdHk9YykpfX12YXIgaixrPVsid2Via2l0IiwiTW96IiwibXMiLCJPIl0sbD17fSxtPWZ1bmN0aW9uKCl7dmFyIGM9YSgic3R5bGUiLHt0eXBlOiJ0ZXh0L2NzcyJ9KTtyZXR1cm4gYihkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgiaGVhZCIpWzBdLGMpLGMuc2hlZXR8fGMuc3R5bGVTaGVldH0oKSxuPXtsaW5lczoxMixsZW5ndGg6Nyx3aWR0aDo1LHJhZGl1czoxMCxyb3RhdGU6MCxjb3JuZXJzOjEsY29sb3I6IiMwMDAiLGRpcmVjdGlvbjoxLHNwZWVkOjEsdHJhaWw6MTAwLG9wYWNpdHk6LjI1LGZwczoyMCx6SW5kZXg6MmU5LGNsYXNzTmFtZToic3Bpbm5lciIsdG9wOiI1MCUiLGxlZnQ6IjUwJSIscG9zaXRpb246ImFic29sdXRlIn07aC5kZWZhdWx0cz17fSxmKGgucHJvdG90eXBlLHtzcGluOmZ1bmN0aW9uKGIpe3RoaXMuc3RvcCgpO3t2YXIgYz10aGlzLGQ9Yy5vcHRzLGY9Yy5lbD1lKGEoMCx7Y2xhc3NOYW1lOmQuY2xhc3NOYW1lfSkse3Bvc2l0aW9uOmQucG9zaXRpb24sd2lkdGg6MCx6SW5kZXg6ZC56SW5kZXh9KTtkLnJhZGl1cytkLmxlbmd0aCtkLndpZHRofWlmKGImJihiLmluc2VydEJlZm9yZShmLGIuZmlyc3RDaGlsZHx8bnVsbCksZShmLHtsZWZ0OmQubGVmdCx0b3A6ZC50b3B9KSksZi5zZXRBdHRyaWJ1dGUoInJvbGUiLCJwcm9ncmVzc2JhciIpLGMubGluZXMoZixjLm9wdHMpLCFqKXt2YXIgZyxoPTAsaT0oZC5saW5lcy0xKSooMS1kLmRpcmVjdGlvbikvMixrPWQuZnBzLGw9ay9kLnNwZWVkLG09KDEtZC5vcGFjaXR5KS8obCpkLnRyYWlsLzEwMCksbj1sL2QubGluZXM7IWZ1bmN0aW9uIG8oKXtoKys7Zm9yKHZhciBhPTA7YTxkLmxpbmVzO2ErKylnPU1hdGgubWF4KDEtKGgrKGQubGluZXMtYSkqbiklbCptLGQub3BhY2l0eSksYy5vcGFjaXR5KGYsYSpkLmRpcmVjdGlvbitpLGcsZCk7Yy50aW1lb3V0PWMuZWwmJnNldFRpbWVvdXQobyx+figxZTMvaykpfSgpfXJldHVybiBjfSxzdG9wOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lbDtyZXR1cm4gYSYmKGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpLGEucGFyZW50Tm9kZSYmYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpLHRoaXMuZWw9dm9pZCAwKSx0aGlzfSxsaW5lczpmdW5jdGlvbihkLGYpe2Z1bmN0aW9uIGgoYixjKXtyZXR1cm4gZShhKCkse3Bvc2l0aW9uOiJhYnNvbHV0ZSIsd2lkdGg6Zi5sZW5ndGgrZi53aWR0aCsicHgiLGhlaWdodDpmLndpZHRoKyJweCIsYmFja2dyb3VuZDpiLGJveFNoYWRvdzpjLHRyYW5zZm9ybU9yaWdpbjoibGVmdCIsdHJhbnNmb3JtOiJyb3RhdGUoIit+figzNjAvZi5saW5lcyprK2Yucm90YXRlKSsiZGVnKSB0cmFuc2xhdGUoIitmLnJhZGl1cysicHgsMCkiLGJvcmRlclJhZGl1czooZi5jb3JuZXJzKmYud2lkdGg+PjEpKyJweCJ9KX1mb3IodmFyIGksaz0wLGw9KGYubGluZXMtMSkqKDEtZi5kaXJlY3Rpb24pLzI7azxmLmxpbmVzO2srKylpPWUoYSgpLHtwb3NpdGlvbjoiYWJzb2x1dGUiLHRvcDoxK34oZi53aWR0aC8yKSsicHgiLHRyYW5zZm9ybTpmLmh3YWNjZWw/InRyYW5zbGF0ZTNkKDAsMCwwKSI6IiIsb3BhY2l0eTpmLm9wYWNpdHksYW5pbWF0aW9uOmomJmMoZi5vcGFjaXR5LGYudHJhaWwsbCtrKmYuZGlyZWN0aW9uLGYubGluZXMpKyIgIisxL2Yuc3BlZWQrInMgbGluZWFyIGluZmluaXRlIn0pLGYuc2hhZG93JiZiKGksZShoKCIjMDAwIiwiMCAwIDRweCAjMDAwIikse3RvcDoiMnB4In0pKSxiKGQsYihpLGgoZyhmLmNvbG9yLGspLCIwIDAgMXB4IHJnYmEoMCwwLDAsLjEpIikpKTtyZXR1cm4gZH0sb3BhY2l0eTpmdW5jdGlvbihhLGIsYyl7YjxhLmNoaWxkTm9kZXMubGVuZ3RoJiYoYS5jaGlsZE5vZGVzW2JdLnN0eWxlLm9wYWNpdHk9Yyl9fSk7dmFyIG89ZShhKCJncm91cCIpLHtiZWhhdmlvcjoidXJsKCNkZWZhdWx0I1ZNTCkifSk7cmV0dXJuIWQobywidHJhbnNmb3JtIikmJm8uYWRqP2koKTpqPWQobywiYW5pbWF0aW9uIiksaH0pOwovLyBOT1RFOiBNb2RpZmllZCB0byBzdXBwb3J0IGRhdGEgVVJJcyBmb3IgaW1hZ2VzLCBpZS4gZGF0YTppbWFnZS8qCi8vIE1vZGlmaWVkIHRvIGFsbG93ICJ3b3JkLWJyZWFrOiBicmVhay13b3JkIiBpbiBzdHlsZXMuIEl0IGlzIGRvbmUgYnkgYWRkaW5nICJicmVhay13b3JkIiB3aGljaCBpcyBhdCBpbmRleCA1NSBvZiBKIGFycmF5IEpbNTVdIHRvICJjc3NMaXRHcm91cCIgb2YgIndvcmQtYnJlYWsiCihmdW5jdGlvbigpe3ZhciBjPXZvaWQgMCxuPSEwLHM9bnVsbCxDPSExLEo9WyJhbGljZWJsdWUsYW50aXF1ZXdoaXRlLGFxdWEsYXF1YW1hcmluZSxhenVyZSxiZWlnZSxiaXNxdWUsYmxhY2ssYmxhbmNoZWRhbG1vbmQsYmx1ZSxibHVldmlvbGV0LGJyb3duLGJ1cmx5d29vZCxjYWRldGJsdWUsY2hhcnRyZXVzZSxjaG9jb2xhdGUsY29yYWwsY29ybmZsb3dlcmJsdWUsY29ybnNpbGssY3JpbXNvbixjeWFuLGRhcmtibHVlLGRhcmtjeWFuLGRhcmtnb2xkZW5yb2QsZGFya2dyYXksZGFya2dyZWVuLGRhcmtraGFraSxkYXJrbWFnZW50YSxkYXJrb2xpdmVncmVlbixkYXJrb3JhbmdlLGRhcmtvcmNoaWQsZGFya3JlZCxkYXJrc2FsbW9uLGRhcmtzZWFncmVlbixkYXJrc2xhdGVibHVlLGRhcmtzbGF0ZWdyYXksZGFya3R1cnF1b2lzZSxkYXJrdmlvbGV0LGRlZXBwaW5rLGRlZXBza3libHVlLGRpbWdyYXksZG9kZ2VyYmx1ZSxmaXJlYnJpY2ssZmxvcmFsd2hpdGUsZm9yZXN0Z3JlZW4sZnVjaHNpYSxnYWluc2Jvcm8sZ2hvc3R3aGl0ZSxnb2xkLGdvbGRlbnJvZCxncmF5LGdyZWVuLGdyZWVueWVsbG93LGhvbmV5ZGV3LGhvdHBpbmssaW5kaWFucmVkLGluZGlnbyxpdm9yeSxraGFraSxsYXZlbmRlcixsYXZlbmRlcmJsdXNoLGxhd25ncmVlbixsZW1vbmNoaWZmb24sbGlnaHRibHVlLGxpZ2h0Y29yYWwsbGlnaHRjeWFuLGxpZ2h0Z29sZGVucm9keWVsbG93LGxpZ2h0Z3JlZW4sbGlnaHRncmV5LGxpZ2h0cGluayxsaWdodHNhbG1vbixsaWdodHNlYWdyZWVuLGxpZ2h0c2t5Ymx1ZSxsaWdodHNsYXRlZ3JheSxsaWdodHN0ZWVsYmx1ZSxsaWdodHllbGxvdyxsaW1lLGxpbWVncmVlbixsaW5lbixtYWdlbnRhLG1hcm9vbixtZWRpdW1hcXVhbWFyaW5lLG1lZGl1bWJsdWUsbWVkaXVtb3JjaGlkLG1lZGl1bXB1cnBsZSxtZWRpdW1zZWFncmVlbixtZWRpdW1zbGF0ZWJsdWUsbWVkaXVtc3ByaW5nZ3JlZW4sbWVkaXVtdHVycXVvaXNlLG1lZGl1bXZpb2xldHJlZCxtaWRuaWdodGJsdWUsbWludGNyZWFtLG1pc3R5cm9zZSxtb2NjYXNpbixuYXZham93aGl0ZSxuYXZ5LG9sZGxhY2Usb2xpdmUsb2xpdmVkcmFiLG9yYW5nZSxvcmFuZ2VyZWQsb3JjaGlkLHBhbGVnb2xkZW5yb2QscGFsZWdyZWVuLHBhbGV0dXJxdW9pc2UscGFsZXZpb2xldHJlZCxwYXBheWF3aGlwLHBlYWNocHVmZixwZXJ1LHBpbmsscGx1bSxwb3dkZXJibHVlLHB1cnBsZSxyZWQscm9zeWJyb3duLHJveWFsYmx1ZSxzYWRkbGVicm93bixzYWxtb24sc2FuZHlicm93bixzZWFncmVlbixzZWFzaGVsbCxzaWVubmEsc2lsdmVyLHNreWJsdWUsc2xhdGVibHVlLHNsYXRlZ3JheSxzbm93LHNwcmluZ2dyZWVuLHN0ZWVsYmx1ZSx0YW4sdGVhbCx0aGlzdGxlLHRvbWF0byx0cmFuc3BhcmVudCx0dXJxdW9pc2UsdmlvbGV0LHdoZWF0LHdoaXRlLHdoaXRlc21va2UseWVsbG93LHllbGxvd2dyZWVuIi5zcGxpdCgiLCIpLAoiYWxsLXNjcm9sbCxjb2wtcmVzaXplLGNyb3NzaGFpcixkZWZhdWx0LGUtcmVzaXplLGhhbmQsaGVscCxtb3ZlLG4tcmVzaXplLG5lLXJlc2l6ZSxuby1kcm9wLG5vdC1hbGxvd2VkLG53LXJlc2l6ZSxwb2ludGVyLHByb2dyZXNzLHJvdy1yZXNpemUscy1yZXNpemUsc2UtcmVzaXplLHN3LXJlc2l6ZSx0ZXh0LHZlcnRpY2FsLXRleHQsdy1yZXNpemUsd2FpdCIuc3BsaXQoIiwiKSwiYXJtZW5pYW4sZGVjaW1hbCxkZWNpbWFsLWxlYWRpbmctemVybyxkaXNjLGdlb3JnaWFuLGxvd2VyLWFscGhhLGxvd2VyLWdyZWVrLGxvd2VyLWxhdGluLGxvd2VyLXJvbWFuLHNxdWFyZSx1cHBlci1hbHBoYSx1cHBlci1sYXRpbix1cHBlci1yb21hbiIuc3BsaXQoIiwiKSwiMTAwLDIwMCwzMDAsNDAwLDUwMCw2MDAsNzAwLDgwMCw5MDAsYm9sZCxib2xkZXIsbGlnaHRlciIuc3BsaXQoIiwiKSwiYmxvY2stbGV2ZWwsaW5saW5lLWxldmVsLHRhYmxlLWNhcHRpb24sdGFibGUtY2VsbCx0YWJsZS1jb2x1bW4sdGFibGUtY29sdW1uLWdyb3VwLHRhYmxlLWZvb3Rlci1ncm91cCx0YWJsZS1oZWFkZXItZ3JvdXAsdGFibGUtcm93LHRhYmxlLXJvdy1ncm91cCIuc3BsaXQoIiwiKSwKImNvbmRlbnNlZCxleHBhbmRlZCxleHRyYS1jb25kZW5zZWQsZXh0cmEtZXhwYW5kZWQsbmFycm93ZXIsc2VtaS1jb25kZW5zZWQsc2VtaS1leHBhbmRlZCx1bHRyYS1jb25kZW5zZWQsdWx0cmEtZXhwYW5kZWQsd2lkZXIiLnNwbGl0KCIsIiksImluaGVyaXQsaW5saW5lLGlubGluZS1ibG9jayxpbmxpbmUtYm94LGlubGluZS1mbGV4LGlubGluZS1ncmlkLGlubGluZS1saXN0LWl0ZW0saW5saW5lLXN0YWNrLGlubGluZS10YWJsZSxydW4taW4iLnNwbGl0KCIsIiksImJlaGluZCxjZW50ZXItbGVmdCxjZW50ZXItcmlnaHQsZmFyLWxlZnQsZmFyLXJpZ2h0LGxlZnQtc2lkZSxsZWZ0d2FyZHMscmlnaHQtc2lkZSxyaWdodHdhcmRzIi5zcGxpdCgiLCIpLCJsYXJnZSxsYXJnZXIsc21hbGwsc21hbGxlcix4LWxhcmdlLHgtc21hbGwseHgtbGFyZ2UseHgtc21hbGwiLnNwbGl0KCIsIiksImRhc2hlZCxkb3R0ZWQsZG91YmxlLGdyb292ZSxvdXRzZXQscmlkZ2Usc29saWQiLnNwbGl0KCIsIiksCiJlYXNlLGVhc2UtaW4sZWFzZS1pbi1vdXQsZWFzZS1vdXQsbGluZWFyLHN0ZXAtZW5kLHN0ZXAtc3RhcnQiLnNwbGl0KCIsIiksImF0LGNsb3Nlc3QtY29ybmVyLGNsb3Nlc3Qtc2lkZSxlbGxpcHNlLGZhcnRoZXN0LWNvcm5lcixmYXJ0aGVzdC1zaWRlIi5zcGxpdCgiLCIpLCJiYXNlbGluZSxtaWRkbGUsc3ViLHN1cGVyLHRleHQtYm90dG9tLHRleHQtdG9wIi5zcGxpdCgiLCIpLCJjYXB0aW9uLGljb24sbWVudSxtZXNzYWdlLWJveCxzbWFsbC1jYXB0aW9uLHN0YXR1cy1iYXIiLnNwbGl0KCIsIiksImZhc3QsZmFzdGVyLHNsb3csc2xvd2VyLHgtZmFzdCx4LXNsb3ciLnNwbGl0KCIsIiksWyJhYm92ZSIsImJlbG93IiwiaGlnaGVyIiwibGV2ZWwiLCJsb3dlciJdLFsiY3Vyc2l2ZSIsImZhbnRhc3kiLCJtb25vc3BhY2UiLCJzYW5zLXNlcmlmIiwic2VyaWYiXSxbImxvdWQiLCJzaWxlbnQiLCJzb2Z0IiwieC1sb3VkIiwieC1zb2Z0Il0sWyJuby1yZXBlYXQiLCJyZXBlYXQteCIsInJlcGVhdC15IiwKInJvdW5kIiwic3BhY2UiXSxbImJsaW5rIiwibGluZS10aHJvdWdoIiwib3ZlcmxpbmUiLCJ1bmRlcmxpbmUiXSxbImJsb2NrIiwiZmxleCIsImdyaWQiLCJ0YWJsZSJdLFsiaGlnaCIsImxvdyIsIngtaGlnaCIsIngtbG93Il0sWyJub3dyYXAiLCJwcmUiLCJwcmUtbGluZSIsInByZS13cmFwIl0sWyJhYnNvbHV0ZSIsInJlbGF0aXZlIiwic3RhdGljIl0sWyJhbHRlcm5hdGUiLCJhbHRlcm5hdGUtcmV2ZXJzZSIsInJldmVyc2UiXSxbImJvcmRlci1ib3giLCJjb250ZW50LWJveCIsInBhZGRpbmctYm94Il0sWyJjYXBpdGFsaXplIiwibG93ZXJjYXNlIiwidXBwZXJjYXNlIl0sWyJjaGlsZCIsImZlbWFsZSIsIm1hbGUiXSxbIj0iLCJvcGFjaXR5Il0sWyJiYWNrd2FyZHMiLCJmb3J3YXJkcyJdLFsiYmlkaS1vdmVycmlkZSIsImVtYmVkIl0sWyJib3R0b20iLCJ0b3AiXSxbImJyZWFrLWFsbCIsImtlZXAtYWxsIl0sWyJjbGlwIiwiZWxsaXBzaXMiXSxbImNvbnRhaW4iLCJjb3ZlciJdLApbImNvbnRpbnVvdXMiLCJkaWdpdHMiXSxbImVuZCIsInN0YXJ0Il0sWyJmbGF0IiwicHJlc2VydmUtM2QiXSxbImhpZGUiLCJzaG93Il0sWyJob3Jpem9udGFsIiwidmVydGljYWwiXSxbImluc2lkZSIsIm91dHNpZGUiXSxbIml0YWxpYyIsIm9ibGlxdWUiXSxbImxlZnQiLCJyaWdodCJdLFsibHRyIiwicnRsIl0sWyJuby1jb250ZW50Iiwibm8tZGlzcGxheSJdLFsicGF1c2VkIiwicnVubmluZyJdLFsic3VwcHJlc3MiLCJ1bnJlc3RyaWN0ZWQiXSxbInRoaWNrIiwidGhpbiJdLFsiLCJdLFsiLyJdLFsiYWxsIl0sWyJhbHdheXMiXSxbImF1dG8iXSxbImF2b2lkIl0sWyJib3RoIl0sWyJicmVhay13b3JkIl0sWyJjZW50ZXIiXSxbImNpcmNsZSJdLFsiY29kZSJdLFsiY29sbGFwc2UiXSxbImNvbnRlbnRzIl0sWyJmaXhlZCJdLFsiaGlkZGVuIl0sWyJpbmZpbml0ZSJdLFsiaW5zZXQiXSxbImludmVydCJdLFsianVzdGlmeSJdLFsibGlzdC1pdGVtIl0sWyJsb2NhbCJdLFsibWVkaXVtIl0sClsibWl4Il0sWyJub25lIl0sWyJub3JtYWwiXSxbIm9uY2UiXSxbInJlcGVhdCJdLFsic2Nyb2xsIl0sWyJzZXBhcmF0ZSJdLFsic21hbGwtY2FwcyJdLFsic3BlbGwtb3V0Il0sWyJ0byJdLFsidmlzaWJsZSJdXSxMPXthbmltYXRpb246e2Nzc1Byb3BCaXRzOjUxNyxjc3NMaXRHcm91cDpbSlsxMF0sSlsyNF0sSlsyOV0sSls0NV0sSls0OF0sSls1NF0sSls2M10sSls3MV0sSls3Ml1dLGNzc0ZuczpbImN1YmljLWJlemllcigpIiwic3RlcHMoKSJdfSwiYW5pbWF0aW9uLWRlbGF5Ijp7Y3NzUHJvcEJpdHM6NSxjc3NMaXRHcm91cDpbSls0OF1dLGNzc0ZuczpbXX0sImFuaW1hdGlvbi1kaXJlY3Rpb24iOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltKWzI0XSxKWzQ4XSxKWzcyXV0sY3NzRm5zOltdfSwiYW5pbWF0aW9uLWR1cmF0aW9uIjoiYW5pbWF0aW9uLWRlbGF5IiwiYW5pbWF0aW9uLWZpbGwtbW9kZSI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbMjldLEpbNDhdLApKWzU0XSxKWzcxXV0sY3NzRm5zOltdfSwiYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCI6e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0pbNDhdLEpbNjNdXSxjc3NGbnM6W119LCJhbmltYXRpb24tbmFtZSI6e2Nzc1Byb3BCaXRzOjUxMixjc3NMaXRHcm91cDpbSls0OF0sSls3MV1dLGNzc0ZuczpbXX0sImFuaW1hdGlvbi1wbGF5LXN0YXRlIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls0NV0sSls0OF1dLGNzc0ZuczpbXX0sImFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb24iOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltKWzEwXSxKWzQ4XV0sY3NzRm5zOlsiY3ViaWMtYmV6aWVyKCkiLCJzdGVwcygpIl19LGFwcGVhcmFuY2U6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbNzFdXSxjc3NGbnM6W119LGF6aW11dGg6e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0pbN10sSls0Ml0sSls1Nl1dLGNzc0ZuczpbXX0sImJhY2tmYWNlLXZpc2liaWxpdHkiOntjc3NQcm9wQml0czowLApjc3NMaXRHcm91cDpbSls1OV0sSls2Ml0sSls4MF1dLGNzc0ZuczpbXX0sYmFja2dyb3VuZDp7Y3NzUHJvcEJpdHM6MjMsY3NzTGl0R3JvdXA6W0pbMF0sSlsxOF0sSlsyNV0sSlszMV0sSlszNF0sSls0Ml0sSls0OF0sSls0OV0sSls1Ml0sSls1Nl0sSls2MV0sSls2OF0sSls3MV0sSls3NF0sSls3NV1dLGNzc0ZuczoiaW1hZ2UoKSxsaW5lYXItZ3JhZGllbnQoKSxyYWRpYWwtZ3JhZGllbnQoKSxyZXBlYXRpbmctbGluZWFyLWdyYWRpZW50KCkscmVwZWF0aW5nLXJhZGlhbC1ncmFkaWVudCgpLHJnYigpLHJnYmEoKSIuc3BsaXQoIiwiKX0sImJhY2tncm91bmQtYXR0YWNobWVudCI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbNDhdLEpbNjFdLEpbNjhdLEpbNzVdXSxjc3NGbnM6W119LCJiYWNrZ3JvdW5kLWNvbG9yIjp7Y3NzUHJvcEJpdHM6Mixjc3NMaXRHcm91cDpbSlswXV0sY3NzRm5zOlsicmdiKCkiLCJyZ2JhKCkiXX0sImJhY2tncm91bmQtaW1hZ2UiOntjc3NQcm9wQml0czoxNiwKY3NzTGl0R3JvdXA6W0pbNDhdLEpbNzFdXSxjc3NGbnM6WyJpbWFnZSgpIiwibGluZWFyLWdyYWRpZW50KCkiLCJyYWRpYWwtZ3JhZGllbnQoKSIsInJlcGVhdGluZy1saW5lYXItZ3JhZGllbnQoKSIsInJlcGVhdGluZy1yYWRpYWwtZ3JhZGllbnQoKSJdfSwiYmFja2dyb3VuZC1wb3NpdGlvbiI6e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0pbMzFdLEpbNDJdLEpbNDhdLEpbNTZdXSxjc3NGbnM6W119LCJiYWNrZ3JvdW5kLXJlcGVhdCI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbMThdLEpbNDhdLEpbNzRdXSxjc3NGbnM6W119LCJiYWNrZ3JvdW5kLXNpemUiOntjc3NQcm9wQml0czo1LGNzc0xpdEdyb3VwOltKWzM0XSxKWzQ4XSxKWzUyXV0sY3NzRm5zOltdfSxib3JkZXI6e2Nzc1Byb3BCaXRzOjcsY3NzTGl0R3JvdXA6W0pbMF0sSls5XSxKWzQ3XSxKWzYyXSxKWzY0XSxKWzY5XSxKWzcxXV0sY3NzRm5zOlsicmdiKCkiLCJyZ2JhKCkiXX0sImJvcmRlci1ib3R0b20iOiJib3JkZXIiLAoiYm9yZGVyLWJvdHRvbS1jb2xvciI6ImJhY2tncm91bmQtY29sb3IiLCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIjp7Y3NzUHJvcEJpdHM6NSxjc3NGbnM6W119LCJib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1cyI6ImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMiLCJib3JkZXItYm90dG9tLXN0eWxlIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls5XSxKWzYyXSxKWzY0XSxKWzcxXV0sY3NzRm5zOltdfSwiYm9yZGVyLWJvdHRvbS13aWR0aCI6e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0pbNDddLEpbNjldXSxjc3NGbnM6W119LCJib3JkZXItY29sbGFwc2UiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltKWzU5XSxKWzc2XV0sY3NzRm5zOltdfSwiYm9yZGVyLWNvbG9yIjoiYmFja2dyb3VuZC1jb2xvciIsImJvcmRlci1sZWZ0IjoiYm9yZGVyIiwiYm9yZGVyLWxlZnQtY29sb3IiOiJiYWNrZ3JvdW5kLWNvbG9yIiwiYm9yZGVyLWxlZnQtc3R5bGUiOiJib3JkZXItYm90dG9tLXN0eWxlIiwKImJvcmRlci1sZWZ0LXdpZHRoIjoiYm9yZGVyLWJvdHRvbS13aWR0aCIsImJvcmRlci1yYWRpdXMiOntjc3NQcm9wQml0czo1LGNzc0xpdEdyb3VwOltKWzQ5XV0sY3NzRm5zOltdfSwiYm9yZGVyLXJpZ2h0IjoiYm9yZGVyIiwiYm9yZGVyLXJpZ2h0LWNvbG9yIjoiYmFja2dyb3VuZC1jb2xvciIsImJvcmRlci1yaWdodC1zdHlsZSI6ImJvcmRlci1ib3R0b20tc3R5bGUiLCJib3JkZXItcmlnaHQtd2lkdGgiOiJib3JkZXItYm90dG9tLXdpZHRoIiwiYm9yZGVyLXNwYWNpbmciOiJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIiwiYm9yZGVyLXN0eWxlIjoiYm9yZGVyLWJvdHRvbS1zdHlsZSIsImJvcmRlci10b3AiOiJib3JkZXIiLCJib3JkZXItdG9wLWNvbG9yIjoiYmFja2dyb3VuZC1jb2xvciIsImJvcmRlci10b3AtbGVmdC1yYWRpdXMiOiJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIiwiYm9yZGVyLXRvcC1yaWdodC1yYWRpdXMiOiJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIiwKImJvcmRlci10b3Atc3R5bGUiOiJib3JkZXItYm90dG9tLXN0eWxlIiwiYm9yZGVyLXRvcC13aWR0aCI6ImJvcmRlci1ib3R0b20td2lkdGgiLCJib3JkZXItd2lkdGgiOiJib3JkZXItYm90dG9tLXdpZHRoIixib3R0b206e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0pbNTJdXSxjc3NGbnM6W119LGJveDp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls2MF0sSls3MV0sSls3Ml1dLGNzc0ZuczpbXX0sImJveC1zaGFkb3ciOntjc3NQcm9wQml0czo3LGNzc0xpdEdyb3VwOltKWzBdLEpbNDhdLEpbNjRdLEpbNzFdXSxjc3NGbnM6WyJyZ2IoKSIsInJnYmEoKSJdfSwiYm94LXNpemluZyI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbMjVdXSxjc3NGbnM6W119LCJjYXB0aW9uLXNpZGUiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltKWzMxXV0sY3NzRm5zOltdfSxjbGVhcjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls0Ml0sSls1NF0sSls3MV1dLGNzc0ZuczpbXX0sCmNsaXA6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbNTJdXSxjc3NGbnM6WyJyZWN0KCkiXX0sY29sb3I6ImJhY2tncm91bmQtY29sb3IiLGNvbnRlbnQ6e2Nzc1Byb3BCaXRzOjgsY3NzTGl0R3JvdXA6W0pbNzFdLEpbNzJdXSxjc3NGbnM6W119LGN1ZTp7Y3NzUHJvcEJpdHM6MTYsY3NzTGl0R3JvdXA6W0pbNzFdXSxjc3NGbnM6W119LCJjdWUtYWZ0ZXIiOiJjdWUiLCJjdWUtYmVmb3JlIjoiY3VlIixjdXJzb3I6e2Nzc1Byb3BCaXRzOjE2LGNzc0xpdEdyb3VwOltKWzFdLEpbNDhdLEpbNTJdXSxjc3NGbnM6W119LGRpcmVjdGlvbjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls0M11dLGNzc0ZuczpbXX0sZGlzcGxheTp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls0XSxKWzZdLEpbMjBdLEpbNTJdLEpbNjddLEpbNzFdXSxjc3NGbnM6W119LCJkaXNwbGF5LWV4dHJhcyI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbNjddLEpbNzFdXSxjc3NGbnM6W119LAoiZGlzcGxheS1pbnNpZGUiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltKWzIwXSxKWzUyXV0sY3NzRm5zOltdfSwiZGlzcGxheS1vdXRzaWRlIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls0XSxKWzcxXV0sY3NzRm5zOltdfSxlbGV2YXRpb246e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0pbMTVdXSxjc3NGbnM6W119LCJlbXB0eS1jZWxscyI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbMzhdXSxjc3NGbnM6W119LGZpbHRlcjp7Y3NzUHJvcEJpdHM6MCxjc3NGbnM6WyJhbHBoYSgpIl19LCJmbG9hdCI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbNDJdLEpbNzFdXSxjc3NGbnM6W119LGZvbnQ6e2Nzc1Byb3BCaXRzOjczLGNzc0xpdEdyb3VwOltKWzNdLEpbOF0sSlsxM10sSlsxNl0sSls0MV0sSls0OF0sSls0OV0sSls2OV0sSls3Ml0sSls3N11dLGNzc0ZuczpbXX0sImZvbnQtZmFtaWx5Ijp7Y3NzUHJvcEJpdHM6NzIsY3NzTGl0R3JvdXA6W0pbMTZdLApKWzQ4XV0sY3NzRm5zOltdfSwiZm9udC1zaXplIjp7Y3NzUHJvcEJpdHM6MSxjc3NMaXRHcm91cDpbSls4XSxKWzY5XV0sY3NzRm5zOltdfSwiZm9udC1zdHJldGNoIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls1XSxKWzcyXV0sY3NzRm5zOltdfSwiZm9udC1zdHlsZSI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbNDFdLEpbNzJdXSxjc3NGbnM6W119LCJmb250LXZhcmlhbnQiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltKWzcyXSxKWzc3XV0sY3NzRm5zOltdfSwiZm9udC13ZWlnaHQiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltKWzNdLEpbNzJdXSxjc3NGbnM6W119LGhlaWdodDoiYm90dG9tIixsZWZ0OiJib3R0b20iLCJsZXR0ZXItc3BhY2luZyI6e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0pbNzJdXSxjc3NGbnM6W119LCJsaW5lLWhlaWdodCI6e2Nzc1Byb3BCaXRzOjEsY3NzTGl0R3JvdXA6W0pbNzJdXSxjc3NGbnM6W119LCJsaXN0LXN0eWxlIjp7Y3NzUHJvcEJpdHM6MTYsCmNzc0xpdEdyb3VwOltKWzJdLEpbNDBdLEpbNTddLEpbNzFdXSxjc3NGbnM6WyJpbWFnZSgpIiwibGluZWFyLWdyYWRpZW50KCkiLCJyYWRpYWwtZ3JhZGllbnQoKSIsInJlcGVhdGluZy1saW5lYXItZ3JhZGllbnQoKSIsInJlcGVhdGluZy1yYWRpYWwtZ3JhZGllbnQoKSJdfSwibGlzdC1zdHlsZS1pbWFnZSI6e2Nzc1Byb3BCaXRzOjE2LGNzc0xpdEdyb3VwOltKWzcxXV0sY3NzRm5zOlsiaW1hZ2UoKSIsImxpbmVhci1ncmFkaWVudCgpIiwicmFkaWFsLWdyYWRpZW50KCkiLCJyZXBlYXRpbmctbGluZWFyLWdyYWRpZW50KCkiLCJyZXBlYXRpbmctcmFkaWFsLWdyYWRpZW50KCkiXX0sImxpc3Qtc3R5bGUtcG9zaXRpb24iOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltKWzQwXV0sY3NzRm5zOltdfSwibGlzdC1zdHlsZS10eXBlIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSlsyXSxKWzU3XSxKWzcxXV0sY3NzRm5zOltdfSxtYXJnaW46ImJvdHRvbSIsIm1hcmdpbi1ib3R0b20iOiJib3R0b20iLAoibWFyZ2luLWxlZnQiOiJib3R0b20iLCJtYXJnaW4tcmlnaHQiOiJib3R0b20iLCJtYXJnaW4tdG9wIjoiYm90dG9tIiwibWF4LWhlaWdodCI6e2Nzc1Byb3BCaXRzOjEsY3NzTGl0R3JvdXA6W0pbNTJdLEpbNzFdXSxjc3NGbnM6W119LCJtYXgtd2lkdGgiOiJtYXgtaGVpZ2h0IiwibWluLWhlaWdodCI6e2Nzc1Byb3BCaXRzOjEsY3NzTGl0R3JvdXA6W0pbNTJdXSxjc3NGbnM6W119LCJtaW4td2lkdGgiOiJtaW4taGVpZ2h0IixvcGFjaXR5Ontjc3NQcm9wQml0czoxLGNzc0ZuczpbXX0sb3V0bGluZTp7Y3NzUHJvcEJpdHM6Nyxjc3NMaXRHcm91cDpbSlswXSxKWzldLEpbNDddLEpbNjJdLEpbNjRdLEpbNjVdLEpbNjldLEpbNzFdXSxjc3NGbnM6WyJyZ2IoKSIsInJnYmEoKSJdfSwib3V0bGluZS1jb2xvciI6e2Nzc1Byb3BCaXRzOjIsY3NzTGl0R3JvdXA6W0pbMF0sSls2NV1dLGNzc0ZuczpbInJnYigpIiwicmdiYSgpIl19LCJvdXRsaW5lLXN0eWxlIjoiYm9yZGVyLWJvdHRvbS1zdHlsZSIsCiJvdXRsaW5lLXdpZHRoIjoiYm9yZGVyLWJvdHRvbS13aWR0aCIsb3ZlcmZsb3c6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbNTJdLEpbNjJdLEpbNzVdLEpbODBdXSxjc3NGbnM6W119LCJvdmVyZmxvdy13cmFwIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls1NV0sSls3Ml1dLGNzc0ZuczpbXX0sIm92ZXJmbG93LXgiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltKWzQ0XSxKWzUyXSxKWzYyXSxKWzc1XSxKWzgwXV0sY3NzRm5zOltdfSwib3ZlcmZsb3cteSI6Im92ZXJmbG93LXgiLHBhZGRpbmc6Im9wYWNpdHkiLCJwYWRkaW5nLWJvdHRvbSI6Im9wYWNpdHkiLCJwYWRkaW5nLWxlZnQiOiJvcGFjaXR5IiwicGFkZGluZy1yaWdodCI6Im9wYWNpdHkiLCJwYWRkaW5nLXRvcCI6Im9wYWNpdHkiLCJwYWdlLWJyZWFrLWFmdGVyIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls0Ml0sSls1MV0sSls1Ml0sSls1M11dLGNzc0ZuczpbXX0sInBhZ2UtYnJlYWstYmVmb3JlIjoicGFnZS1icmVhay1hZnRlciIsCiJwYWdlLWJyZWFrLWluc2lkZSI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbNTJdLEpbNTNdXSxjc3NGbnM6W119LHBhdXNlOiJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIiwicGF1c2UtYWZ0ZXIiOiJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIiwicGF1c2UtYmVmb3JlIjoiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyIscGVyc3BlY3RpdmU6e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0pbNzFdXSxjc3NGbnM6W119LCJwZXJzcGVjdGl2ZS1vcmlnaW4iOntjc3NQcm9wQml0czo1LGNzc0xpdEdyb3VwOltKWzMxXSxKWzQyXSxKWzU2XV0sY3NzRm5zOltdfSxwaXRjaDp7Y3NzUHJvcEJpdHM6NSxjc3NMaXRHcm91cDpbSlsyMV0sSls2OV1dLGNzc0ZuczpbXX0sInBpdGNoLXJhbmdlIjoiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyIsInBsYXktZHVyaW5nIjp7Y3NzUHJvcEJpdHM6MTYsY3NzTGl0R3JvdXA6W0pbNTJdLEpbNzBdLEpbNzFdLEpbNzRdXSxjc3NGbnM6W119LApwb3NpdGlvbjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSlsyM11dLGNzc0ZuczpbXX0scXVvdGVzOntjc3NQcm9wQml0czo4LGNzc0xpdEdyb3VwOltKWzcxXV0sY3NzRm5zOltdfSxyZXNpemU6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbMzldLEpbNTRdLEpbNzFdXSxjc3NGbnM6W119LHJpY2huZXNzOiJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIixyaWdodDoiYm90dG9tIixzcGVhazp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls3MV0sSls3Ml0sSls3OF1dLGNzc0ZuczpbXX0sInNwZWFrLWhlYWRlciI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbNTFdLEpbNzNdXSxjc3NGbnM6W119LCJzcGVhay1udW1lcmFsIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSlszNV1dLGNzc0ZuczpbXX0sInNwZWFrLXB1bmN0dWF0aW9uIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls1OF0sSls3MV1dLGNzc0ZuczpbXX0sInNwZWVjaC1yYXRlIjp7Y3NzUHJvcEJpdHM6NSwKY3NzTGl0R3JvdXA6W0pbMTRdLEpbNjldXSxjc3NGbnM6W119LHN0cmVzczoiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyIsInRhYmxlLWxheW91dCI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbNTJdLEpbNjFdXSxjc3NGbnM6W119LCJ0ZXh0LWFsaWduIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls0Ml0sSls1Nl0sSls2Nl1dLGNzc0ZuczpbXX0sInRleHQtZGVjb3JhdGlvbiI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbMTldLEpbNzFdXSxjc3NGbnM6W119LCJ0ZXh0LWluZGVudCI6ImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMiLCJ0ZXh0LW92ZXJmbG93Ijp7Y3NzUHJvcEJpdHM6OCxjc3NMaXRHcm91cDpbSlszM11dLGNzc0ZuczpbXX0sInRleHQtc2hhZG93IjoiYm94LXNoYWRvdyIsInRleHQtdHJhbnNmb3JtIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSlsyNl0sSls3MV1dLGNzc0ZuczpbXX0sInRleHQtd3JhcCI6e2Nzc1Byb3BCaXRzOjAsCmNzc0xpdEdyb3VwOltKWzQ2XSxKWzcxXSxKWzcyXV0sY3NzRm5zOltdfSx0b3A6ImJvdHRvbSIsdHJhbnNmb3JtOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltKWzcxXV0sY3NzRm5zOiJtYXRyaXgoKSxwZXJzcGVjdGl2ZSgpLHJvdGF0ZSgpLHJvdGF0ZTNkKCkscm90YXRleCgpLHJvdGF0ZXkoKSxyb3RhdGV6KCksc2NhbGUoKSxzY2FsZTNkKCksc2NhbGV4KCksc2NhbGV5KCksc2NhbGV6KCksc2tldygpLHNrZXd4KCksc2tld3koKSx0cmFuc2xhdGUoKSx0cmFuc2xhdGUzZCgpLHRyYW5zbGF0ZXgoKSx0cmFuc2xhdGV5KCksdHJhbnNsYXRleigpIi5zcGxpdCgiLCIpfSwidHJhbnNmb3JtLW9yaWdpbiI6InBlcnNwZWN0aXZlLW9yaWdpbiIsInRyYW5zZm9ybS1zdHlsZSI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbMzddXSxjc3NGbnM6W119LHRyYW5zaXRpb246e2Nzc1Byb3BCaXRzOjEwMjksY3NzTGl0R3JvdXA6W0pbMTBdLEpbNDhdLEpbNTBdLEpbNzFdXSxjc3NGbnM6WyJjdWJpYy1iZXppZXIoKSIsCiJzdGVwcygpIl19LCJ0cmFuc2l0aW9uLWRlbGF5IjoiYW5pbWF0aW9uLWRlbGF5IiwidHJhbnNpdGlvbi1kdXJhdGlvbiI6ImFuaW1hdGlvbi1kZWxheSIsInRyYW5zaXRpb24tcHJvcGVydHkiOntjc3NQcm9wQml0czoxMDI0LGNzc0xpdEdyb3VwOltKWzQ4XSxKWzUwXV0sY3NzRm5zOltdfSwidHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24iOiJhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uIiwidW5pY29kZS1iaWRpIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSlszMF0sSls3Ml1dLGNzc0ZuczpbXX0sInZlcnRpY2FsLWFsaWduIjp7Y3NzUHJvcEJpdHM6NSxjc3NMaXRHcm91cDpbSlsxMl0sSlszMV1dLGNzc0ZuczpbXX0sdmlzaWJpbGl0eToiYmFja2ZhY2UtdmlzaWJpbGl0eSIsInZvaWNlLWZhbWlseSI6e2Nzc1Byb3BCaXRzOjgsY3NzTGl0R3JvdXA6W0pbMjddLEpbNDhdXSxjc3NGbnM6W119LHZvbHVtZTp7Y3NzUHJvcEJpdHM6MSxjc3NMaXRHcm91cDpbSlsxN10sSls2OV1dLApjc3NGbnM6W119LCJ3aGl0ZS1zcGFjZSI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbMjJdLEpbNzJdXSxjc3NGbnM6W119LHdpZHRoOiJtaW4taGVpZ2h0Iiwid29yZC1icmVhayI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbMzJdLEpbNzJdLEpbNTVdXSxjc3NGbnM6W119LCJ3b3JkLXNwYWNpbmciOiJsZXR0ZXItc3BhY2luZyIsIndvcmQtd3JhcCI6Im92ZXJmbG93LXdyYXAiLCJ6LWluZGV4IjoiYm90dG9tIix6b29tOiJsaW5lLWhlaWdodCIsImN1YmljLWJlemllcigpIjoiYW5pbWF0aW9uLWRlbGF5Iiwic3RlcHMoKSI6e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0pbMzZdLEpbNDhdXSxjc3NGbnM6W119LCJpbWFnZSgpIjp7Y3NzUHJvcEJpdHM6MTgsY3NzTGl0R3JvdXA6W0pbMF0sSls0OF1dLGNzc0ZuczpbInJnYigpIiwicmdiYSgpIl19LCJsaW5lYXItZ3JhZGllbnQoKSI6e2Nzc1Byb3BCaXRzOjcsY3NzTGl0R3JvdXA6W0pbMF0sSlszMV0sSls0Ml0sSls0OF0sCkpbNzldXSxjc3NGbnM6WyJyZ2IoKSIsInJnYmEoKSJdfSwicmFkaWFsLWdyYWRpZW50KCkiOntjc3NQcm9wQml0czo3LGNzc0xpdEdyb3VwOltKWzBdLEpbMTFdLEpbMzFdLEpbNDJdLEpbNDhdLEpbNTZdLEpbNTddXSxjc3NGbnM6WyJyZ2IoKSIsInJnYmEoKSJdfSwicmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudCgpIjoibGluZWFyLWdyYWRpZW50KCkiLCJyZXBlYXRpbmctcmFkaWFsLWdyYWRpZW50KCkiOiJyYWRpYWwtZ3JhZGllbnQoKSIsInJnYigpIjp7Y3NzUHJvcEJpdHM6MSxjc3NMaXRHcm91cDpbSls0OF1dLGNzc0ZuczpbXX0sInJnYmEoKSI6InJnYigpIiwicmVjdCgpIjp7Y3NzUHJvcEJpdHM6NSxjc3NMaXRHcm91cDpbSls0OF0sSls1Ml1dLGNzc0ZuczpbXX0sImFscGhhKCkiOntjc3NQcm9wQml0czoxLGNzc0xpdEdyb3VwOltKWzI4XV0sY3NzRm5zOltdfSwibWF0cml4KCkiOiJhbmltYXRpb24tZGVsYXkiLCJwZXJzcGVjdGl2ZSgpIjoiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyIsCiJyb3RhdGUoKSI6ImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMiLCJyb3RhdGUzZCgpIjoiYW5pbWF0aW9uLWRlbGF5Iiwicm90YXRleCgpIjoiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyIsInJvdGF0ZXkoKSI6ImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMiLCJyb3RhdGV6KCkiOiJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIiwic2NhbGUoKSI6ImFuaW1hdGlvbi1kZWxheSIsInNjYWxlM2QoKSI6ImFuaW1hdGlvbi1kZWxheSIsInNjYWxleCgpIjoiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyIsInNjYWxleSgpIjoiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyIsInNjYWxleigpIjoiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyIsInNrZXcoKSI6ImFuaW1hdGlvbi1kZWxheSIsInNrZXd4KCkiOiJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIiwic2tld3koKSI6ImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMiLCJ0cmFuc2xhdGUoKSI6ImFuaW1hdGlvbi1kZWxheSIsInRyYW5zbGF0ZTNkKCkiOiJhbmltYXRpb24tZGVsYXkiLAoidHJhbnNsYXRleCgpIjoiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyIsInRyYW5zbGF0ZXkoKSI6ImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMiLCJ0cmFuc2xhdGV6KCkiOiJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIn0sTztmb3IoTyBpbiBMKSJzdHJpbmciPT09dHlwZW9mIExbT10mJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKEwsTykmJihMW09dPUxbTFtPXV0pOyJ1bmRlZmluZWQiIT09dHlwZW9mIHdpbmRvdyYmKHdpbmRvdy5jc3NTY2hlbWE9TCk7dmFyIFUsWDsKKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZyhhKXt2YXIgZj1wYXJzZUludChhLnN1YnN0cmluZygxKSwxNik7cmV0dXJuIDY1NTM1PGY/KGYtPTY1NTM2LFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYrKGY+PjEwKSw1NjMyMCsoZiYxMDIzKSkpOmY9PWY/U3RyaW5nLmZyb21DaGFyQ29kZShmKToiICI+YVsxXT8iIjphWzFdfWZ1bmN0aW9uIHcoYSxmKXtyZXR1cm4nIicrYS5yZXBsYWNlKC9bXHUwMDAwLVx1MDAxZlxcXCI8Pl0vZyxmKSsnIid9ZnVuY3Rpb24gTShhKXtyZXR1cm4gRVthXXx8KEVbYV09IlxcIithLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKyIgIil9ZnVuY3Rpb24geChhKXtyZXR1cm4gZVthXXx8KGVbYV09KCJcdTAwMTAiPmE/IiUwIjoiJSIpK2EuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpfXZhciBFPXsiXFwiOiJcXFxcIn0sZT17IlxcIjoiJTVjIn0sdj1SZWdFeHAoIlxcdUZFRkZ8VVsrXVswLTlBLUY/XXsxLDZ9KD86LVswLTlBLUZdezEsNn0pP3x1cmxbKF1bXFx0XFxuXFxmIF0qKD86XCIoPzonfFteJ1wiXFxuXFxmXFxcXF18XFxcXFtcXHNcXFNdKSpcInwnKD86XCJ8W14nXCJcXG5cXGZcXFxcXXxcXFxcW1xcc1xcU10pKid8KD86W1xcdFxceDIxXFx4MjMtXFx4MjZcXHgyOC1cXHg1YlxceDVkLVxceDdlXXxbXFx1MDA4MC1cXHVkN2ZmXFx1ZTAwMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYmZmXVtcXHVkYzAwLVxcdWRmZmZdfFxcXFwoPzpbMC05YS1mQS1GXXsxLDZ9W1xcdFxcblxcZiBdP3xbXFx1MDAyMC1cXHUwMDdlXFx1MDA4MC1cXHVkN2ZmXFx1ZTAwMFxcdWZmZmRdfFtcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl0pKSopW1xcdFxcblxcZiBdKlspXXwoPyF1cmxbKF0pLT8oPzpbYS16QS1aX118W1xcdTAwODAtXFx1ZDdmZlxcdWUwMDAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXXxcXFxcKD86WzAtOWEtZkEtRl17MSw2fVtcXHRcXG5cXGYgXT98W1xcdTAwMjAtXFx1MDA3ZVxcdTAwODAtXFx1ZDdmZlxcdWUwMDBcXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYmZmXVtcXHVkYzAwLVxcdWRmZmZdKSkoPzpbYS16QS1aMC05Xy1dfFtcXHUwMDgwLVxcdWQ3ZmZcXHVlMDAwLVxcdWZmZmRdfFtcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl18XFxcXCg/OlswLTlhLWZBLUZdezEsNn1bXFx0XFxuXFxmIF0/fFtcXHUwMDIwLVxcdTAwN2VcXHUwMDgwLVxcdWQ3ZmZcXHVlMDAwXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXSkpKlsoXXwoPzpAPy0/KD86W2EtekEtWl9dfFtcXHUwMDgwLVxcdWQ3ZmZcXHVlMDAwLVxcdWZmZmRdfFtcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl18XFxcXCg/OlswLTlhLWZBLUZdezEsNn1bXFx0XFxuXFxmIF0/fFtcXHUwMDIwLVxcdTAwN2VcXHUwMDgwLVxcdWQ3ZmZcXHVlMDAwXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXSkpfCMpKD86W2EtekEtWjAtOV8tXXxbXFx1MDA4MC1cXHVkN2ZmXFx1ZTAwMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYmZmXVtcXHVkYzAwLVxcdWRmZmZdfFxcXFwoPzpbMC05YS1mQS1GXXsxLDZ9W1xcdFxcblxcZiBdP3xbXFx1MDAyMC1cXHUwMDdlXFx1MDA4MC1cXHVkN2ZmXFx1ZTAwMFxcdWZmZmRdfFtcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl0pKSp8XCIoPzonfFteJ1wiXFxuXFxmXFxcXF18XFxcXFtcXHNcXFNdKSpcInwnKD86XCJ8W14nXCJcXG5cXGZcXFxcXXxcXFxcW1xcc1xcU10pKid8Wy0rXT8oPzpbMC05XSsoPzpbLl1bMC05XSspP3xbLl1bMC05XSspKD86JXwtPyg/OlthLXpBLVpfXXxbXFx1MDA4MC1cXHVkN2ZmXFx1ZTAwMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYmZmXVtcXHVkYzAwLVxcdWRmZmZdfFxcXFwoPzpbMC05YS1mQS1GXXsxLDZ9W1xcdFxcblxcZiBdP3xbXFx1MDAyMC1cXHUwMDdlXFx1MDA4MC1cXHVkN2ZmXFx1ZTAwMFxcdWZmZmRdfFtcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl0pKSg/OlthLXpBLVowLTlfLV18W1xcdTAwODAtXFx1ZDdmZlxcdWUwMDAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXXxcXFxcKD86WzAtOWEtZkEtRl17MSw2fVtcXHRcXG5cXGYgXT98W1xcdTAwMjAtXFx1MDA3ZVxcdTAwODAtXFx1ZDdmZlxcdWUwMDBcXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYmZmXVtcXHVkYzAwLVxcdWRmZmZdKSkqKT98PFwhLS18LS1cPnxbXFx0XFxuXFxmIF0rfC8oPzpbKl1bXipdKlsqXSsoPzpbXi9dW14qXSpbKl0rKSovfC9bXlxcblxcZl0qKXxbfnxeJCpdPXxbXlwiJ1xcXFwvXXwvKD8hWy8qXSkiLCJnaSIpLApiPVJlZ0V4cCgiXFxcXCg/Oig/OlswLTlhLWZBLUZdezEsNn1bXFx0XFxuXFxmIF0/fFtcXHUwMDIwLVxcdTAwN2VcXHUwMDgwLVxcdWQ3ZmZcXHVlMDAwXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXSl8W1xcblxcZl0pIiwiZyIpLGE9UmVnRXhwKCJedXJsXFwoW1xcdFxcblxcZiBdKltcIiddP3xbXCInXT9bXFx0XFxuXFxmIF0qXFwpJCIsImdpIik7WD1mdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKGIsZyl9O1U9ZnVuY3Rpb24oYil7Zm9yKHZhciBiPSgiIitiKS5yZXBsYWNlKC9cclxuPy9nLCJcbiIpLm1hdGNoKHYpfHxbXSxmPTAsaD0iICIsZD0wLHk9Yi5sZW5ndGg7ZDx5OysrZCl7dmFyIGw9WChiW2RdKSxWPWwubGVuZ3RoLGc9bC5jaGFyQ29kZUF0KDApLGw9MzQ9PWd8fDM5PT1nP3cobC5zdWJzdHJpbmcoMSxWLTEpLE0pOjQ3PT1nJiYxPFZ8fCJcXCI9PWx8fCItLVw+Ij09bHx8IjxcIS0tIj09bHx8Ilx1ZmVmZiI9PWx8fDMyPj1nPyIgIjoKL3VybFwoL2kudGVzdChsKT8idXJsKCIrdyhsLnJlcGxhY2UoYSwiIikseCkrIikiOmw7aWYoaCE9bHx8IiAiIT1sKWJbZisrXT1oPWx9Yi5sZW5ndGg9ZjtyZXR1cm4gYn19KSgpOyJ1bmRlZmluZWQiIT09dHlwZW9mIHdpbmRvdyYmKHdpbmRvdy5sZXhDc3M9VSx3aW5kb3cuZGVjb2RlQ3NzPVgpO3ZhciBZPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZyhkKXtkPSgiIitkKS5tYXRjaChrKTtyZXR1cm4hZD9zOm5ldyBlKHYoZFsxXSksdihkWzJdKSx2KGRbM10pLHYoZFs0XSksdihkWzVdKSx2KGRbNl0pLHYoZFs3XSkpfWZ1bmN0aW9uIHcoZCxhKXtyZXR1cm4ic3RyaW5nIj09dHlwZW9mIGQ/ZW5jb2RlVVJJKGQpLnJlcGxhY2UoYSxNKTpzfWZ1bmN0aW9uIE0oZCl7ZD1kLmNoYXJDb2RlQXQoMCk7cmV0dXJuIiUiKyIwMTIzNDU2Nzg5QUJDREVGIi5jaGFyQXQoZD4+NCYxNSkrIjAxMjM0NTY3ODlBQkNERUYiLmNoYXJBdChkJjE1KX1mdW5jdGlvbiB4KGQpe2lmKGQ9PT1zKXJldHVybiBzO2Zvcih2YXIgZD1kLnJlcGxhY2UoLyhefFwvKVwuKD86XC98JCkvZywiJDEiKS5yZXBsYWNlKC9cL3syLH0vZywiLyIpLGE9YixoOyhoPWQucmVwbGFjZShhLCIkMSIpKSE9ZDtkPWgpO3JldHVybiBkfWZ1bmN0aW9uIEUoZCxoKXt2YXIgYj1kLlQoKSxmPWguSygpO2Y/Yi5nYShoLmopOmY9aC5YKCk7CmY/Yi5kYShoLm4pOmY9aC5ZKCk7Zj9iLmVhKGguayk6Zj1oLiQoKTt2YXIgZz1oLmcsaz14KGcpO2lmKGYpYi5jYShoLlYoKSksaz1rJiZrLnJlcGxhY2UoYSwiIik7ZWxzZSBpZihmPSEhZyl7aWYoNDchPT1rLmNoYXJDb2RlQXQoMCkpdmFyIGs9eChiLmd8fCIiKS5yZXBsYWNlKGEsIiIpLGU9ay5sYXN0SW5kZXhPZigiLyIpKzEsaz14KChlP2suc3Vic3RyaW5nKDAsZSk6IiIpK3goZykpLnJlcGxhY2UoYSwiIil9ZWxzZSBrPWsmJmsucmVwbGFjZShhLCIiKSxrIT09ZyYmYi5HKGspO2Y/Yi5HKGspOmY9aC5hYSgpO2Y/Yi5PKGgubCk6Zj1oLlooKTtmJiZiLmZhKGgubyk7cmV0dXJuIGJ9ZnVuY3Rpb24gZShkLGEsaCxmLGIsZyxrKXt0aGlzLmo9ZDt0aGlzLm49YTt0aGlzLms9aDt0aGlzLmg9Zjt0aGlzLmc9Yjt0aGlzLmw9Zzt0aGlzLm89a31mdW5jdGlvbiB2KGQpe3JldHVybiJzdHJpbmciPT10eXBlb2YgZCYmMDxkLmxlbmd0aD9kOnN9dmFyIGI9UmVnRXhwKC8oXC98XikoPzpbXi4vXVteL10qfFwuezIsfSg/OlteLi9dW14vXSopfFwuezMsfVteL10qKVwvXC5cLig/OlwvfCQpLyksCmE9L14oPzpcLlwuXC8pKig/OlwuXC4kKT8vO2UucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGQ9W107cyE9PXRoaXMuaiYmZC5wdXNoKHRoaXMuaiwiOiIpO3MhPT10aGlzLmsmJihkLnB1c2goIi8vIikscyE9PXRoaXMubiYmZC5wdXNoKHRoaXMubiwiQCIpLGQucHVzaCh0aGlzLmspLHMhPT10aGlzLmgmJmQucHVzaCgiOiIsdGhpcy5oLnRvU3RyaW5nKCkpKTtzIT09dGhpcy5nJiZkLnB1c2godGhpcy5nKTtzIT09dGhpcy5sJiZkLnB1c2goIj8iLHRoaXMubCk7cyE9PXRoaXMubyYmZC5wdXNoKCIjIix0aGlzLm8pO3JldHVybiBkLmpvaW4oIiIpfTtlLnByb3RvdHlwZS5UPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBlKHRoaXMuaix0aGlzLm4sdGhpcy5rLHRoaXMuaCx0aGlzLmcsdGhpcy5sLHRoaXMubyl9O2UucHJvdG90eXBlLlc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5qJiZkZWNvZGVVUklDb21wb25lbnQodGhpcy5qKS50b0xvd2VyQ2FzZSgpfTtlLnByb3RvdHlwZS5nYT0KZnVuY3Rpb24oZCl7dGhpcy5qPWQ/ZDpzfTtlLnByb3RvdHlwZS5LPWZ1bmN0aW9uKCl7cmV0dXJuIHMhPT10aGlzLmp9O2UucHJvdG90eXBlLmRhPWZ1bmN0aW9uKGQpe3RoaXMubj1kP2Q6c307ZS5wcm90b3R5cGUuWD1mdW5jdGlvbigpe3JldHVybiBzIT09dGhpcy5ufTtlLnByb3RvdHlwZS5lYT1mdW5jdGlvbihkKXt0aGlzLms9ZD9kOnM7dGhpcy5HKHRoaXMuZyl9O2UucHJvdG90eXBlLlk9ZnVuY3Rpb24oKXtyZXR1cm4gcyE9PXRoaXMua307ZS5wcm90b3R5cGUuVj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmgmJmRlY29kZVVSSUNvbXBvbmVudCh0aGlzLmgpfTtlLnByb3RvdHlwZS5jYT1mdW5jdGlvbihkKXtpZihkKXtkPU51bWJlcihkKTtpZihkIT09KGQmNjU1MzUpKXRocm93IEVycm9yKCJCYWQgcG9ydCBudW1iZXIgIitkKTt0aGlzLmg9IiIrZH1lbHNlIHRoaXMuaD1zfTtlLnByb3RvdHlwZS4kPWZ1bmN0aW9uKCl7cmV0dXJuIHMhPT10aGlzLmh9O2UucHJvdG90eXBlLlU9CmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZyYmZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMuZyl9O2UucHJvdG90eXBlLkc9ZnVuY3Rpb24oZCl7ZD8oZD0iIitkLHRoaXMuZz0hdGhpcy5rfHwvXlwvLy50ZXN0KGQpP2Q6Ii8iK2QpOnRoaXMuZz1zfTtlLnByb3RvdHlwZS5PPWZ1bmN0aW9uKGQpe3RoaXMubD1kP2Q6c307ZS5wcm90b3R5cGUuYWE9ZnVuY3Rpb24oKXtyZXR1cm4gcyE9PXRoaXMubH07ZS5wcm90b3R5cGUuYmE9ZnVuY3Rpb24oZCl7aWYoIm9iamVjdCI9PT10eXBlb2YgZCYmIShkIGluc3RhbmNlb2YgQXJyYXkpJiYoZCBpbnN0YW5jZW9mIE9iamVjdHx8IltvYmplY3QgQXJyYXldIiE9PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkKSkpe3ZhciBhPVtdLGg9LTEsZjtmb3IoZiBpbiBkKXt2YXIgYj1kW2ZdOyJzdHJpbmciPT09dHlwZW9mIGImJihhWysraF09ZixhWysraF09Yil9ZD1hfWZvcih2YXIgYT1bXSxoPSIiLGc9MDtnPGQubGVuZ3RoOylmPWRbZysrXSwKYj1kW2crK10sYS5wdXNoKGgsZW5jb2RlVVJJQ29tcG9uZW50KGYudG9TdHJpbmcoKSkpLGg9IiYiLGImJmEucHVzaCgiPSIsZW5jb2RlVVJJQ29tcG9uZW50KGIudG9TdHJpbmcoKSkpO3RoaXMubD1hLmpvaW4oIiIpfTtlLnByb3RvdHlwZS5mYT1mdW5jdGlvbihkKXt0aGlzLm89ZD9kOnN9O2UucHJvdG90eXBlLlo9ZnVuY3Rpb24oKXtyZXR1cm4gcyE9PXRoaXMub307dmFyIGs9L14oPzooW146Lz8jXSspOik/KD86XC9cLyg/OihbXi8/I10qKUApPyhbXi8/IzpAXSopKD86OihbMC05XSspKT8pPyhbXj8jXSspPyg/Olw/KFteI10qKSk/KD86IyguKikpPyQvLGY9L1sjXC9cP0BdL2csaD0vW1wjXD9dL2c7ZS5wYXJzZT1nO2UuY3JlYXRlPWZ1bmN0aW9uKGQsYSxiLGcsayxRLE4pe2Q9bmV3IGUodyhkLGYpLHcoYSxmKSwic3RyaW5nIj09dHlwZW9mIGI/ZW5jb2RlVVJJQ29tcG9uZW50KGIpOnMsMDxnP2cudG9TdHJpbmcoKTpzLHcoayxoKSxzLCJzdHJpbmciPT10eXBlb2YgTj9lbmNvZGVVUklDb21wb25lbnQoTik6CnMpO1EmJigic3RyaW5nIj09PXR5cGVvZiBRP2QuTyhRLnJlcGxhY2UoL1tePyY9MC05QS1aYS16X1wtfi4lXS9nLE0pKTpkLmJhKFEpKTtyZXR1cm4gZH07ZS5OPUU7ZS5tYT14O2UuaGE9e3VhOmZ1bmN0aW9uKGQpe3JldHVybi9cLmh0bWwkLy50ZXN0KGcoZCkuVSgpKT8idGV4dC9odG1sIjoiYXBwbGljYXRpb24vamF2YXNjcmlwdCJ9LE46ZnVuY3Rpb24oZCxhKXtyZXR1cm4gZD9FKGcoZCksZyhhKSkudG9TdHJpbmcoKToiIithfX07cmV0dXJuIGV9KCk7InVuZGVmaW5lZCIhPT10eXBlb2Ygd2luZG93JiYod2luZG93LlVSST1ZKTt2YXIgYWE9YyxiYT1jLGRhPWMsWj1jOwooZnVuY3Rpb24oKXtmdW5jdGlvbiBnKGEpe3JldHVybiJzdHJpbmciPT09dHlwZW9mIGE/J3VybCgiJythLnJlcGxhY2UoZSx3KSsnIiknOid1cmwoImFib3V0OmJsYW5rIiknfWZ1bmN0aW9uIHcoYSl7cmV0dXJuIHZbYV19ZnVuY3Rpb24gTShhLGQpe3JldHVybiBhP1kuaGEuTihhLGQpOmR9ZnVuY3Rpb24geChoLGQsZil7aWYoIWYpcmV0dXJuIHM7dmFyIGc9KCIiK2gpLm1hdGNoKGIpO3JldHVybiBnJiYoIWdbMV18fGEudGVzdChnWzFdKSk/ZihoLGQpOnN9ZnVuY3Rpb24gRShhKXtyZXR1cm4gYS5yZXBsYWNlKC9eLSg/OmFwcGxlfGNzc3xlcHVifGtodG1sfG1venxtc28/fG98cmltfHdhcHx3ZWJraXR8eHYpLSg/PVthLXpdKS8sIiIpfXZhciBlPS9bXG5cZlxyXCJcJygpKjw+XS9nLHY9eyJcbiI6IiUwYSIsIlx1MDAwYyI6IiUwYyIsIlxyIjoiJTBkIiwnIic6IiUyMiIsIiciOiIlMjciLCIoIjoiJTI4IiwiKSI6IiUyOSIsIioiOiIlMmEiLCI8IjoiJTNjIiwiPiI6IiUzZSJ9LApiPS9eKD86KFteOi8/IyBdKyk6KT8vLGE9L14oPzpodHRwcz98bWFpbHRvfGRhdGEpJC9pO2FhPWZ1bmN0aW9uKCl7dmFyIGE9e307cmV0dXJuIGZ1bmN0aW9uIHkoZixiLGssZSxOKXt2YXIgZj1FKGYpLHU9TFtmXTtpZighdXx8Im9iamVjdCIhPT10eXBlb2YgdSliLmxlbmd0aD0wO2Vsc2V7Zm9yKHZhciBpPXUuY3NzUHJvcEJpdHMscT1pJjgwLEI9aSYxNTM2LEY9TmFOLHI9MCxvPTA7cjxiLmxlbmd0aDsrK3Ipe3ZhciBqPWJbcl0udG9Mb3dlckNhc2UoKSxJPWouY2hhckNvZGVBdCgwKSxSLHYsUCxTLEQsdztpZigzMj09PUkpaj0iIjtlbHNlIGlmKDM0PT09SSlqPTE2PT09cT9rP2coeChNKGUsWChiW3JdLnN1YnN0cmluZygxLGoubGVuZ3RoLTEpKSksZixrKSk6IiI6aSY4JiYhKHEmcS0xKT9qOiIiO2Vsc2UgaWYoImluaGVyaXQiIT09ail7aWYoRD11LmNzc0xpdEdyb3VwKXt2YXIgRztpZighKEc9dS5jc3NMaXRNYXApKXtHPXt9O2Zvcih2YXIgSz1ELmxlbmd0aDswPD0tLUs7KWZvcih2YXIgQT0KRFtLXSxUPUEubGVuZ3RoOzA8PS0tVDspR1tBW1RdXT1hO0c9dS5jc3NMaXRNYXA9R31EPUd9ZWxzZSBEPWE7aWYoISh3PUQsd1tFKGopXT09PWEpKWlmKDM1PT09SSYmL14jKD86WzAtOWEtZl17M30pezEsMn0kLy50ZXN0KGopKWo9aSYyP2o6IiI7ZWxzZSBpZig0ODw9SSYmNTc+PUkpaj1pJjE/ajoiIjtlbHNlIGlmKFI9ai5jaGFyQ29kZUF0KDEpLHY9ai5jaGFyQ29kZUF0KDIpLFA9NDg8PVImJjU3Pj1SLFM9NDg8PXYmJjU3Pj12LDQzPT09SSYmKFB8fDQ2PT09UiYmUykpaj1pJjE/KFA/IiI6IjAiKStqLnN1YnN0cmluZygxKToiIjtlbHNlIGlmKDQ1PT09SSYmKFB8fDQ2PT09UiYmUykpaj1pJjQ/KFA/Ii0iOiItMCIpK2ouc3Vic3RyaW5nKDEpOmkmMT8iMCI6IiI7ZWxzZSBpZig0Nj09PUkmJlApaj1pJjE/IjAiK2o6IiI7ZWxzZSBpZigndXJsKCInPT09ai5zdWJzdHJpbmcoMCw1KSlqPWsmJmkmMTY/Zyh4KE0oZSxiW3JdLnN1YnN0cmluZyg1LGoubGVuZ3RoLTIpKSxmLGspKToKIiI7ZWxzZSBpZigiKCI9PT1qLmNoYXJBdChqLmxlbmd0aC0xKSlhOntEPWI7Rz1yO2o9MTtLPUcrMTtmb3IoST1ELmxlbmd0aDtLPEkmJmo7KUE9RFtLKytdLGorPSIpIj09PUE/LTE6L15bXiInXSpcKCQvLnRlc3QoQSk7aWYoIWope2o9RFtHXS50b0xvd2VyQ2FzZSgpO0k9RShqKTtEPUQuc3BsaWNlKEcsSy1HLCIiKTtHPXUuY3NzRm5zO0s9MDtmb3IoQT1HLmxlbmd0aDtLPEE7KytLKWlmKEdbS10uc3Vic3RyaW5nKDAsSS5sZW5ndGgpPT1JKXtEWzBdPURbRC5sZW5ndGgtMV09IiI7eShHW0tdLEQsayxlKTtqPWorRC5qb2luKCIgIikrIikiO2JyZWFrIGF9fWo9IiJ9ZWxzZSBqPUImJi9eLT9bYS16X11bXHdcLV0qJC8udGVzdChqKSYmIS9fXyQvLnRlc3Qoaik/TiYmNTEyPT09Qj9iW3JdK046MTAyND09PUImJkxbal0mJiJudW1iZXIiPT09dHlwZW9mIExbal0ub2E/ajoiIjovXlx3KyQvLnRlc3QoaikmJjY0PT09cSYmaSY4P0YrMT09PW8/KGJbRl09YltGXS5zdWJzdHJpbmcoMCwKYltGXS5sZW5ndGgtMSkrIiAiK2orJyInLCIiKTooRj1vLCciJytqKyciJyk6IiJ9aiYmKGJbbysrXT1qKX0xPT09byYmJ3VybCgiYWJvdXQ6YmxhbmsiKSc9PT1iWzBdJiYobz0wKTtiLmxlbmd0aD1vfX19KCk7dmFyIGs9UmVnRXhwKCJeKGFjdGl2ZXxhZnRlcnxiZWZvcmV8Ymxhbmt8Y2hlY2tlZHxkZWZhdWx0fGRpc2FibGVkfGRyb3B8ZW1wdHl8ZW5hYmxlZHxmaXJzdHxmaXJzdC1jaGlsZHxmaXJzdC1sZXR0ZXJ8Zmlyc3QtbGluZXxmaXJzdC1vZi10eXBlfGZ1bGxzY3JlZW58Zm9jdXN8aG92ZXJ8aW4tcmFuZ2V8aW5kZXRlcm1pbmF0ZXxpbnZhbGlkfGxhc3QtY2hpbGR8bGFzdC1vZi10eXBlfGxlZnR8bGlua3xvbmx5LWNoaWxkfG9ubHktb2YtdHlwZXxvcHRpb25hbHxvdXQtb2YtcmFuZ2V8cGxhY2Vob2xkZXItc2hvd258cmVhZC1vbmx5fHJlYWQtd3JpdGV8cmVxdWlyZWR8cmlnaHR8cm9vdHxzY29wZXx1c2VyLWVycm9yfHZhbGlkfHZpc2l0ZWQpJCIpLGY9e307ZlsiPiJdPQpmWyIrIl09ZlsifiJdPWY7YmE9ZnVuY3Rpb24oYSxkLGIpe2Z1bmN0aW9uIGcoaSxyKXtmdW5jdGlvbiBvKGIsZixnKXt2YXIgeSxlLGksbCxvLG09bjt5PSIiO2lmKGI8ZilpZihvPWFbYl0sIioiPT09bykrK2IseT1vO2Vsc2UgaWYoL15bYS16QS1aXS8udGVzdChvKSYmKGU9eChvLnRvTG93ZXJDYXNlKCksW10pKSkidGFnTmFtZSJpbiBlJiYobz1lLnRhZ05hbWUpLCsrYix5PW87Zm9yKGw9aT1lPSIiO20mJmI8ZjsrK2IpaWYobz1hW2JdLCIjIj09PW8uY2hhckF0KDApKS9eI198X18kfFteXHcjOlwtXS8udGVzdChvKT9tPUM6ZSs9byt2O2Vsc2UgaWYoIi4iPT09bykrK2I8ZiYmL15bMC05QS1aYS16Ol9cLV0rJC8udGVzdChvPWFbYl0pJiYhL15ffF9fJC8udGVzdChvKT9lKz0iLiIrbzptPUM7ZWxzZSBpZihiKzE8ZiYmIlsiPT09YVtiXSl7KytiO3ZhciBIPWFbYisrXS50b0xvd2VyQ2FzZSgpO289JC5tW3krIjo6IitIXTtvIT09K28mJihvPSQubVsiKjo6IitIXSk7dmFyIFc7CmQuaWE/KFc9ZC5pYSh5LEgpLCJzdHJpbmciIT09dHlwZW9mIFcmJihtPUMsVz1IKSxtJiZvIT09K28mJihvPSQuZC5OT05FKSk6KFc9SCxvIT09K28mJihtPUMpKTt2YXIgcD1IPSIiLGNhPUM7L15bfl4kKnxdPz0kLy50ZXN0KGFbYl0pJiYoSD1hW2IrK10scD1hW2IrK10sL15bMC05QS1aYS16Ol9cLV0rJC8udGVzdChwKT9wPSciJytwKyciJzoiXSI9PT1wJiYocD0nIiInLC0tYiksL14iKFteXCJcXF18XFwuKSoiJC8udGVzdChwKXx8KG09QyksKGNhPSJpIj09PWFbYl0pJiYrK2IpOyJdIiE9PWFbYl0mJigrK2IsbT1DKTtzd2l0Y2gobyl7Y2FzZSAkLmQuQ0xBU1NFUzpjYXNlICQuZC5MT0NBTF9OQU1FOmNhc2UgJC5kLk5PTkU6YnJlYWs7Y2FzZSAkLmQuR0xPQkFMX05BTUU6Y2FzZSAkLmQuSUQ6Y2FzZSAkLmQuSURSRUY6KCI9Ij09PUh8fCJ+PSI9PT1IfHwiJD0iPT09SCkmJiciIichPXAmJiFjYT9wPSciJytwLnN1YnN0cmluZygxLHAubGVuZ3RoLTEpK3YrJyInOiJ8PSI9PT0KSHx8IiI9PT1IfHwobT1DKTticmVhaztjYXNlICQuZC5VUkk6Y2FzZSAkLmQuVVJJX0ZSQUdNRU5UOiIiIT09SCYmKG09Qyk7YnJlYWs7ZGVmYXVsdDptPUN9bSYmKGkrPSJbIitXLnJlcGxhY2UoL1teXHctXS9nLCJcXCQmIikrSCtwKyhjYT8iIGldIjoiXSIpKX1lbHNlIGlmKGI8ZiYmIjoiPT09YVtiXSlpZihvPWFbKytiXSxrLnRlc3QobykpbCs9IjoiK287ZWxzZSBicmVhaztlbHNlIGJyZWFrO2IhPT1mJiYobT1DKTttJiYoYj0oeStlKS5yZXBsYWNlKC9bXiAuKiNcdy1dL2csIlxcJCYiKStpK2wrZykmJmoucHVzaChiKTtyZXR1cm4gbX0iICI9PT1hW2ldJiYrK2k7ci0xIT09aSYmIiAiPT09YVtyXSYmLS1yO2Zvcih2YXIgaj1bXSxsPWkscT1uLHU9aTtxJiZ1PHI7Kyt1KXt2YXIgQj1hW3VdO2lmKGZbQl09PT1mfHwiICI9PT1CKW8obCx1LEIpP2w9dSsxOnE9Q31vKGwsciwiIil8fChxPUMpO3JldHVybiBxPyhqLmxlbmd0aCYmKGw9ai5qb2luKCIiKSxlIT09cyYmKGw9Ii4iKwplKyIgIitsKSxOLnB1c2gobCkpLG4pOiFifHxiKGEuc2xpY2UoaSxyKSl9dmFyIGU9ZC5uYSx2PWQuTCx4PWQuQWEsTj1bXSx1PTAsaSxxPTAsQjtmb3IoaT0wO2k8YS5sZW5ndGg7KytpKWlmKEI9YVtpXSwiKCI9PUJ8fCJbIj09Qj8oKytxLG4pOiIpIj09Qnx8Il0iPT1CPyhxJiYtLXEsbik6ISgiICI9PWFbaV0mJihxfHxmW2FbaS0xXV09PT1mfHxmW2FbaSsxXV09PT1mKSkpYVt1KytdPWFbaV07YS5sZW5ndGg9dTt1PWEubGVuZ3RoO2ZvcihpPXE9MDtpPHU7KytpKWlmKCIsIj09PWFbaV0pe2lmKCFnKHEsaSkpcmV0dXJuIHM7cT1pKzF9cmV0dXJuIWcocSx1KT9zOk59OyhmdW5jdGlvbigpe3ZhciBhPS9eXHcvLGQ9UmVnRXhwKCJeKD86KD86KD86KD86b25seXxub3QpICk/KD86YWxsfGF1cmFsfGJyYWlsbGV8ZW1ib3NzZWR8aGFuZGhlbGR8cHJpbnR8cHJvamVjdGlvbnxzY3JlZW58c3BlZWNofHR0eXx0dil8XFwoICg/Oig/Om1pbi18bWF4LSk/KD86KD86ZGV2aWNlLSk/KD86YXNwZWN0LXJhdGlvfGhlaWdodHx3aWR0aCl8Y29sb3IoPzotaW5kZXgpP3xtb25vY2hyb21lfG9yaWVudGF0aW9ufHJlc29sdXRpb24pfGdyaWR8aG92ZXJ8bHVtaW5vc2l0eXxwb2ludGVyfHNjYW58c2NyaXB0KSAoPzo6IC0/KD86W2Etel1cXHcrKD86LVxcdyspKnxcXGQrKD86IC8gXFxkK3woPzpcXC5cXGQrKT8oPzpwW2N4dF18W2NlbV1tfGlufGRwaXxkcHB4fGRwY218JSk/KSkgKT9cXCkpKD86IGFuZCA/XFwoICg/Oig/Om1pbi18bWF4LSk/KD86KD86ZGV2aWNlLSk/KD86YXNwZWN0LXJhdGlvfGhlaWdodHx3aWR0aCl8Y29sb3IoPzotaW5kZXgpP3xtb25vY2hyb21lfG9yaWVudGF0aW9ufHJlc29sdXRpb24pfGdyaWR8aG92ZXJ8bHVtaW5vc2l0eXxwb2ludGVyfHNjYW58c2NyaXB0KSAoPzo6IC0/KD86W2Etel1cXHcrKD86LVxcdyspKnxcXGQrKD86IC8gXFxkK3woPzpcXC5cXGQrKT8oPzpwW2N4dF18W2NlbV1tfGlufGRwaXxkcHB4fGRwY218JSk/KSkgKT9cXCkpKikoPzogLCAoPzooPzooPzooPzpvbmx5fG5vdCkgKT8oPzphbGx8YXVyYWx8YnJhaWxsZXxlbWJvc3NlZHxoYW5kaGVsZHxwcmludHxwcm9qZWN0aW9ufHNjcmVlbnxzcGVlY2h8dHR5fHR2KXxcXCggKD86KD86bWluLXxtYXgtKT8oPzooPzpkZXZpY2UtKT8oPzphc3BlY3QtcmF0aW98aGVpZ2h0fHdpZHRoKXxjb2xvcig/Oi1pbmRleCk/fG1vbm9jaHJvbWV8b3JpZW50YXRpb258cmVzb2x1dGlvbil8Z3JpZHxob3ZlcnxsdW1pbm9zaXR5fHBvaW50ZXJ8c2NhbnxzY3JpcHQpICg/OjogLT8oPzpbYS16XVxcdysoPzotXFx3KykqfFxcZCsoPzogLyBcXGQrfCg/OlxcLlxcZCspPyg/OnBbY3h0XXxbY2VtXW18aW58ZHBpfGRwcHh8ZHBjbXwlKT8pKSApP1xcKSkoPzogYW5kID9cXCggKD86KD86bWluLXxtYXgtKT8oPzooPzpkZXZpY2UtKT8oPzphc3BlY3QtcmF0aW98aGVpZ2h0fHdpZHRoKXxjb2xvcig/Oi1pbmRleCk/fG1vbm9jaHJvbWV8b3JpZW50YXRpb258cmVzb2x1dGlvbil8Z3JpZHxob3ZlcnxsdW1pbm9zaXR5fHBvaW50ZXJ8c2NhbnxzY3JpcHQpICg/OjogLT8oPzpbYS16XVxcdysoPzotXFx3KykqfFxcZCsoPzogLyBcXGQrfCg/OlxcLlxcZCspPyg/OnBbY3h0XXxbY2VtXW18aW58ZHBpfGRwcHh8ZHBjbXwlKT8pKSApP1xcKSkqKSkqJCIsCiJpIik7Wj1mdW5jdGlvbihiKXtmb3IodmFyIGI9Yi5zbGljZSgpLGY9Yi5sZW5ndGgsZz0wLGs9MDtrPGY7KytrKXt2YXIgZT1iW2tdOyIgIiE9ZSYmKGJbZysrXT1lKX1iLmxlbmd0aD1nO2I9Yi5qb2luKCIgIik7cmV0dXJuIGI9IWIubGVuZ3RoPyIiOiFkLnRlc3QoYik/Im5vdCBhbGwiOmEudGVzdChiKT9iOiJub3QgYWxsICwgIitifX0pKCk7KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShiKXt2YXIgZD0vXlxzKlsnXShbXiddKilbJ11ccyokLyxmPS9eXHMqdXJsXHMqWyhdWyJdKFteIl0qKVsiXVspXVxzKiQvLGc9L15ccyp1cmxccypbKF1bJ10oW14nXSopWyddWyldXHMqJC8saD0vXlxzKnVybFxzKlsoXShbXildKilbKV1ccyokLyxrO3JldHVybihrPS9eXHMqWyJdKFteIl0qKVsiXVxzKiQvLmV4ZWMoYikpfHwoaz1kLmV4ZWMoYikpfHwoaz1mLmV4ZWMoYikpfHwoaz1nLmV4ZWMoYikpfHwoaz1oLmV4ZWMoYikpP2tbMV06c31mdW5jdGlvbiBiKGYsZyxrLGUsdix3LHUpe2Z1bmN0aW9uIGkoKXtyPQpGLmxlbmd0aCYmRltGLmxlbmd0aC0xXT09PXN9dmFyIHE9YyxCPXV8fFswXSxGPVtdLHI9QztmYShnLHtzdGFydFN0eWxlc2hlZXQ6ZnVuY3Rpb24oKXtxPVtdfSxlbmRTdHlsZXNoZWV0OmZ1bmN0aW9uKCl7fSxzdGFydEF0cnVsZTpmdW5jdGlvbihnLGope2lmKHIpZz1zO2Vsc2UgaWYoIkBtZWRpYSI9PT1nKXEucHVzaCgiQG1lZGlhIiwiICIsWihqKSk7ZWxzZSBpZigiQGtleWZyYW1lcyI9PT1nfHwiQC13ZWJraXQta2V5ZnJhbWVzIj09PWcpe3ZhciBpPWpbMF07MT09PWoubGVuZ3RoJiYhL19fJHxbXlx3XC1dLy50ZXN0KGkpPyhxLnB1c2goZywiICIsaStrLkwpLGc9IkBrZXlmcmFtZXMiKTpnPXN9ZWxzZSBpZigiQGltcG9ydCI9PT1nJiYwPGoubGVuZ3RoKWlmKGc9cywiZnVuY3Rpb24iPT09dHlwZW9mIHcpe3ZhciBsPVooai5zbGljZSgxKSk7aWYoIm5vdCBhbGwiIT09bCl7KytCWzBdO3ZhciB1PVtdO3EucHVzaCh1KTt2YXIgRT14KE0oZixhKGpbMF0pKSxmdW5jdGlvbihhKXt2YXIgZj0KYihFLGEucWEsayxlLHYsdyxCKTstLUJbMF07YT1sP3t0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiJAbWVkaWEgIitsKyIgeyIrZi5yZXN1bHQrIn0ifX06Zi5yZXN1bHQ7dVswXT1hO3coYSwhIUJbMF0pfSx2KX19ZWxzZSB3aW5kb3cuY29uc29sZSYmd2luZG93LmNvbnNvbGUubG9nKCJAaW1wb3J0ICIrai5qb2luKCIgIikrIiBlbGlkZWQiKTtyPSFnO0YucHVzaChnKX0sZW5kQXRydWxlOmZ1bmN0aW9uKCl7Ri5wb3AoKTtyfHxxLnB1c2goIjsiKTtpKCl9LHN0YXJ0QmxvY2s6ZnVuY3Rpb24oKXtyfHxxLnB1c2goInsiKX0sZW5kQmxvY2s6ZnVuY3Rpb24oKXtyfHwocS5wdXNoKCJ9Iikscj1uKX0sc3RhcnRSdWxlc2V0OmZ1bmN0aW9uKGEpe2lmKCFyKXt2YXIgYj1jOyJAa2V5ZnJhbWVzIj09PUZbRi5sZW5ndGgtMV0/KGI9YS5qb2luKCIgIikubWF0Y2goL14gKig/OmZyb218dG98XGQrKD86XC5cZCspPyUpICooPzosICooPzpmcm9tfHRvfFxkKyg/OlwuXGQrKT8lKSAqKSokL2kpLApyPSFiLGImJihiPWJbMF0ucmVwbGFjZSgvICsvZywiIikpKTooYT1iYShhLGspLCFhfHwhYS5sZW5ndGg/cj1uOmI9YS5qb2luKCIsICIpKTtyfHxxLnB1c2goYiwieyIpfUYucHVzaChzKX0sZW5kUnVsZXNldDpmdW5jdGlvbigpe0YucG9wKCk7cnx8cS5wdXNoKCJ9Iik7aSgpfSxkZWNsYXJhdGlvbjpmdW5jdGlvbihhLGIpe2lmKCFyKXt2YXIgZD1DLGc9Yi5sZW5ndGg7Mjw9ZyYmIiEiPT09YltnLTJdJiYiaW1wb3J0YW50Ij09PWJbZy0xXS50b0xvd2VyQ2FzZSgpJiYoZD1uLGIubGVuZ3RoLT0yKTthYShhLGIsZSxmLGsuTCk7Yi5sZW5ndGgmJnEucHVzaChhLCI6IixiLmpvaW4oIiAiKSxkPyIgIWltcG9ydGFudDsiOiI7Iil9fX0pO3JldHVybntyZXN1bHQ6e3RvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHEuam9pbigiIil9fSx2YTohIUJbMF19fWRhPWZ1bmN0aW9uKGEsZixnLGspe3JldHVybiBiKGEsZixnLGssYyxjKS5yZXN1bHQudG9TdHJpbmcoKX19KSgpfSkoKTsKInVuZGVmaW5lZCIhPT10eXBlb2Ygd2luZG93JiYod2luZG93LnNhbml0aXplQ3NzUHJvcGVydHk9YWEsd2luZG93LnNhbml0aXplQ3NzU2VsZWN0b3JMaXN0PWJhLHdpbmRvdy5zYW5pdGl6ZVN0eWxlc2hlZXQ9ZGEsd2luZG93LnNhbml0aXplTWVkaWFRdWVyeT1aKTt2YXIgZmEsZ2E7CihmdW5jdGlvbigpe2Z1bmN0aW9uIGcoYixhLGcsZixoKXtmb3IodmFyIGQ9YSsrO2E8ZyYmInsiIT09YlthXSYmIjsiIT09YlthXTspKythO2lmKGE8ZyYmKGh8fCI7Ij09PWJbYV0pKXt2YXIgaD1kKzEsZT1hO2g8ZyYmIiAiPT09YltoXSYmKytoO2U+aCYmIiAiPT09YltlLTFdJiYtLWU7Zi5zdGFydEF0cnVsZSYmZi5zdGFydEF0cnVsZShiW2RdLnRvTG93ZXJDYXNlKCksYi5zbGljZShoLGUpKTthPSJ7Ij09PWJbYV0/dyhiLGEsZyxmKTphKzE7Zi5lbmRBdHJ1bGUmJmYuZW5kQXRydWxlKCl9cmV0dXJuIGF9ZnVuY3Rpb24gdyhiLGEsayxmKXsrK2E7Zm9yKGYuc3RhcnRCbG9jayYmZi5zdGFydEJsb2NrKCk7YTxrOyl7dmFyIGg9YlthXS5jaGFyQXQoMCk7aWYoIn0iPT1oKXsrK2E7YnJlYWt9YT0iICI9PT1ofHwiOyI9PT1oP2ErMToiQCI9PT1oP2coYixhLGssZixDKToieyI9PT1oP3coYixhLGssZik6TShiLGEsayxmKX1mLmVuZEJsb2NrJiZmLmVuZEJsb2NrKCk7cmV0dXJuIGF9CmZ1bmN0aW9uIE0oYixhLGcsZil7dmFyIGg9YSxkPXgoYixhLGcsbik7aWYoMD5kKXJldHVybiBkPX5kLGQ9PT1oP2QrMTpkO3ZhciB5PWJbZF07aWYoInsiIT09eSlyZXR1cm4gZD09PWg/ZCsxOmQ7YT1kKzE7ZD5oJiYiICI9PT1iW2QtMV0mJi0tZDtmb3IoZi5zdGFydFJ1bGVzZXQmJmYuc3RhcnRSdWxlc2V0KGIuc2xpY2UoaCxkKSk7YTxnOyl7eT1iW2FdO2lmKCJ9Ij09PXkpeysrYTticmVha31hPSIgIj09PXk/YSsxOmUoYixhLGcsZil9Zi5lbmRSdWxlc2V0JiZmLmVuZFJ1bGVzZXQoKTtyZXR1cm4gYX1mdW5jdGlvbiB4KGIsYSxnLGYpe2Zvcih2YXIgaCxkPVtdLGU9LTE7YTxnOysrYSlpZihoPWJbYV0uY2hhckF0KDApLCJbIj09PWh8fCIoIj09PWgpZFsrK2VdPWg7ZWxzZSBpZigiXSI9PT1oJiYiWyI9PT1kW2VdfHwiKSI9PT1oJiYiKCI9PT1kW2VdKS0tZTtlbHNlIGlmKCJ7Ij09PWh8fCJ9Ij09PWh8fCI7Ij09PWh8fCJAIj09PWh8fCI6Ij09PWgmJiFmKWJyZWFrOzA8PQplJiYoYT1+KGErMSkpO3JldHVybiBhfWZ1bmN0aW9uIEUoYixhLGcpe2Zvcig7YTxnJiYiOyIhPT1iW2FdJiYifSIhPT1iW2FdOykrK2E7cmV0dXJuIGE8ZyYmIjsiPT09YlthXT9hKzE6YX1mdW5jdGlvbiBlKGIsYSxnLGYpe3ZhciBoPWJbYSsrXTtpZighdi50ZXN0KGgpKXJldHVybiBFKGIsYSxnKTthPGcmJiIgIj09PWJbYV0mJisrYTtpZihhPT1nfHwiOiIhPT1iW2FdKXJldHVybiBFKGIsYSxnKTsrK2E7YTxnJiYiICI9PT1iW2FdJiYrK2E7dmFyIGQ9eChiLGEsZyxDKTtpZigwPmQpZD1+ZDtlbHNle2Zvcih2YXIgZT1bXSxsPTAsdz1hO3c8ZDsrK3cpYT1iW3ddLCIgIiE9PWEmJihlW2wrK109YSk7aWYoZDxnKXtkb3thPWJbZF07aWYoIjsiPT09YXx8In0iPT09YSlicmVhaztsPTB9d2hpbGUoKytkPGcpOyI7Ij09PWEmJisrZH1sJiZmLmRlY2xhcmF0aW9uJiZmLmRlY2xhcmF0aW9uKGgudG9Mb3dlckNhc2UoKSxlKX1yZXR1cm4gZH1mYT1mdW5jdGlvbihiLGEpe3ZhciBlPVUoYik7CmEuc3RhcnRTdHlsZXNoZWV0JiZhLnN0YXJ0U3R5bGVzaGVldCgpO2Zvcih2YXIgZj0wLGg9ZS5sZW5ndGg7ZjxoOylmPSIgIj09PWVbZl0/ZisxOmY8aD8iQCI9PT1lW2ZdLmNoYXJBdCgwKT9nKGUsZixoLGEsbik6TShlLGYsaCxhKTpmO2EuZW5kU3R5bGVzaGVldCYmYS5lbmRTdHlsZXNoZWV0KCl9O3ZhciB2PS9eLT9bYS16XS9pO2dhPWZ1bmN0aW9uKGIsYSl7Zm9yKHZhciBnPVUoYiksZj0wLGg9Zy5sZW5ndGg7ZjxoOylmPSIgIiE9PWdbZl0/ZShnLGYsaCxhKTpmKzF9fSkoKTsidW5kZWZpbmVkIiE9PXR5cGVvZiB3aW5kb3cmJih3aW5kb3cucGFyc2VDc3NTdHlsZXNoZWV0PWZhLHdpbmRvdy5wYXJzZUNzc0RlY2xhcmF0aW9ucz1nYSk7dmFyICQ9e2Q6e05PTkU6MCxVUkk6MSxVUklfRlJBR01FTlQ6MTEsU0NSSVBUOjIsU1RZTEU6MyxIVE1MOjEyLElEOjQsSURSRUY6NSxJRFJFRlM6NixHTE9CQUxfTkFNRTo3LExPQ0FMX05BTUU6OCxDTEFTU0VTOjksRlJBTUVfVEFSR0VUOjEwLE1FRElBX1FVRVJZOjEzfX07JC5hdHlwZT0kLmQ7CiQubT17Iio6OmNsYXNzIjo5LCIqOjpkaXIiOjAsIio6OmRyYWdnYWJsZSI6MCwiKjo6aGlkZGVuIjowLCIqOjppZCI6NCwiKjo6aW5lcnQiOjAsIio6Oml0ZW1wcm9wIjowLCIqOjppdGVtcmVmIjo2LCIqOjppdGVtc2NvcGUiOjAsIio6OmxhbmciOjAsIio6Om9uYmx1ciI6MiwiKjo6b25jaGFuZ2UiOjIsIio6Om9uY2xpY2siOjIsIio6Om9uZGJsY2xpY2siOjIsIio6Om9uZXJyb3IiOjIsIio6Om9uZm9jdXMiOjIsIio6Om9ua2V5ZG93biI6MiwiKjo6b25rZXlwcmVzcyI6MiwiKjo6b25rZXl1cCI6MiwiKjo6b25sb2FkIjoyLCIqOjpvbm1vdXNlZG93biI6MiwiKjo6b25tb3VzZW1vdmUiOjIsIio6Om9ubW91c2VvdXQiOjIsIio6Om9ubW91c2VvdmVyIjoyLCIqOjpvbm1vdXNldXAiOjIsIio6Om9ucmVzZXQiOjIsIio6Om9uc2Nyb2xsIjoyLCIqOjpvbnNlbGVjdCI6MiwiKjo6b25zdWJtaXQiOjIsIio6Om9udG91Y2hjYW5jZWwiOjIsIio6Om9udG91Y2hlbmQiOjIsIio6Om9udG91Y2hlbnRlciI6MiwKIio6Om9udG91Y2hsZWF2ZSI6MiwiKjo6b250b3VjaG1vdmUiOjIsIio6Om9udG91Y2hzdGFydCI6MiwiKjo6b251bmxvYWQiOjIsIio6OnNwZWxsY2hlY2siOjAsIio6OnN0eWxlIjozLCIqOjp0YWJpbmRleCI6MCwiKjo6dGl0bGUiOjAsIio6OnRyYW5zbGF0ZSI6MCwiYTo6YWNjZXNza2V5IjowLCJhOjpjb29yZHMiOjAsImE6OmhyZWYiOjEsImE6OmhyZWZsYW5nIjowLCJhOjpuYW1lIjo3LCJhOjpvbmJsdXIiOjIsImE6Om9uZm9jdXMiOjIsImE6OnNoYXBlIjowLCJhOjp0YXJnZXQiOjEwLCJhOjp0eXBlIjowLCJhcmVhOjphY2Nlc3NrZXkiOjAsImFyZWE6OmFsdCI6MCwiYXJlYTo6Y29vcmRzIjowLCJhcmVhOjpocmVmIjoxLCJhcmVhOjpub2hyZWYiOjAsImFyZWE6Om9uYmx1ciI6MiwiYXJlYTo6b25mb2N1cyI6MiwiYXJlYTo6c2hhcGUiOjAsImFyZWE6OnRhcmdldCI6MTAsImF1ZGlvOjpjb250cm9scyI6MCwiYXVkaW86Omxvb3AiOjAsImF1ZGlvOjptZWRpYWdyb3VwIjo1LAoiYXVkaW86Om11dGVkIjowLCJhdWRpbzo6cHJlbG9hZCI6MCwiYXVkaW86OnNyYyI6MSwiYmRvOjpkaXIiOjAsImJsb2NrcXVvdGU6OmNpdGUiOjEsImJyOjpjbGVhciI6MCwiYnV0dG9uOjphY2Nlc3NrZXkiOjAsImJ1dHRvbjo6ZGlzYWJsZWQiOjAsImJ1dHRvbjo6bmFtZSI6OCwiYnV0dG9uOjpvbmJsdXIiOjIsImJ1dHRvbjo6b25mb2N1cyI6MiwiYnV0dG9uOjp0eXBlIjowLCJidXR0b246OnZhbHVlIjowLCJjYW52YXM6OmhlaWdodCI6MCwiY2FudmFzOjp3aWR0aCI6MCwiY2FwdGlvbjo6YWxpZ24iOjAsImNvbDo6YWxpZ24iOjAsImNvbDo6Y2hhciI6MCwiY29sOjpjaGFyb2ZmIjowLCJjb2w6OnNwYW4iOjAsImNvbDo6dmFsaWduIjowLCJjb2w6OndpZHRoIjowLCJjb2xncm91cDo6YWxpZ24iOjAsImNvbGdyb3VwOjpjaGFyIjowLCJjb2xncm91cDo6Y2hhcm9mZiI6MCwiY29sZ3JvdXA6OnNwYW4iOjAsImNvbGdyb3VwOjp2YWxpZ24iOjAsImNvbGdyb3VwOjp3aWR0aCI6MCwKImNvbW1hbmQ6OmNoZWNrZWQiOjAsImNvbW1hbmQ6OmNvbW1hbmQiOjUsImNvbW1hbmQ6OmRpc2FibGVkIjowLCJjb21tYW5kOjppY29uIjoxLCJjb21tYW5kOjpsYWJlbCI6MCwiY29tbWFuZDo6cmFkaW9ncm91cCI6MCwiY29tbWFuZDo6dHlwZSI6MCwiZGF0YTo6dmFsdWUiOjAsImRlbDo6Y2l0ZSI6MSwiZGVsOjpkYXRldGltZSI6MCwiZGV0YWlsczo6b3BlbiI6MCwiZGlyOjpjb21wYWN0IjowLCJkaXY6OmFsaWduIjowLCJkbDo6Y29tcGFjdCI6MCwiZmllbGRzZXQ6OmRpc2FibGVkIjowLCJmb250Ojpjb2xvciI6MCwiZm9udDo6ZmFjZSI6MCwiZm9udDo6c2l6ZSI6MCwiZm9ybTo6YWNjZXB0IjowLCJmb3JtOjphY3Rpb24iOjEsImZvcm06OmF1dG9jb21wbGV0ZSI6MCwiZm9ybTo6ZW5jdHlwZSI6MCwiZm9ybTo6bWV0aG9kIjowLCJmb3JtOjpuYW1lIjo3LCJmb3JtOjpub3ZhbGlkYXRlIjowLCJmb3JtOjpvbnJlc2V0IjoyLCJmb3JtOjpvbnN1Ym1pdCI6MiwiZm9ybTo6dGFyZ2V0IjoxMCwKImgxOjphbGlnbiI6MCwiaDI6OmFsaWduIjowLCJoMzo6YWxpZ24iOjAsImg0OjphbGlnbiI6MCwiaDU6OmFsaWduIjowLCJoNjo6YWxpZ24iOjAsImhyOjphbGlnbiI6MCwiaHI6Om5vc2hhZGUiOjAsImhyOjpzaXplIjowLCJocjo6d2lkdGgiOjAsImlmcmFtZTo6YWxpZ24iOjAsImlmcmFtZTo6ZnJhbWVib3JkZXIiOjAsImlmcmFtZTo6aGVpZ2h0IjowLCJpZnJhbWU6Om1hcmdpbmhlaWdodCI6MCwiaWZyYW1lOjptYXJnaW53aWR0aCI6MCwiaWZyYW1lOjp3aWR0aCI6MCwiaW1nOjphbGlnbiI6MCwiaW1nOjphbHQiOjAsImltZzo6Ym9yZGVyIjowLCJpbWc6OmhlaWdodCI6MCwiaW1nOjpoc3BhY2UiOjAsImltZzo6aXNtYXAiOjAsImltZzo6bmFtZSI6NywiaW1nOjpzcmMiOjEsImltZzo6dXNlbWFwIjoxMSwiaW1nOjp2c3BhY2UiOjAsImltZzo6d2lkdGgiOjAsImlucHV0OjphY2NlcHQiOjAsImlucHV0OjphY2Nlc3NrZXkiOjAsImlucHV0OjphbGlnbiI6MCwiaW5wdXQ6OmFsdCI6MCwKImlucHV0OjphdXRvY29tcGxldGUiOjAsImlucHV0OjpjaGVja2VkIjowLCJpbnB1dDo6ZGlzYWJsZWQiOjAsImlucHV0OjppbnB1dG1vZGUiOjAsImlucHV0Ojppc21hcCI6MCwiaW5wdXQ6Omxpc3QiOjUsImlucHV0OjptYXgiOjAsImlucHV0OjptYXhsZW5ndGgiOjAsImlucHV0OjptaW4iOjAsImlucHV0OjptdWx0aXBsZSI6MCwiaW5wdXQ6Om5hbWUiOjgsImlucHV0OjpvbmJsdXIiOjIsImlucHV0OjpvbmNoYW5nZSI6MiwiaW5wdXQ6Om9uZm9jdXMiOjIsImlucHV0OjpvbnNlbGVjdCI6MiwiaW5wdXQ6OnBhdHRlcm4iOjAsImlucHV0OjpwbGFjZWhvbGRlciI6MCwiaW5wdXQ6OnJlYWRvbmx5IjowLCJpbnB1dDo6cmVxdWlyZWQiOjAsImlucHV0OjpzaXplIjowLCJpbnB1dDo6c3JjIjoxLCJpbnB1dDo6c3RlcCI6MCwiaW5wdXQ6OnR5cGUiOjAsImlucHV0Ojp1c2VtYXAiOjExLCJpbnB1dDo6dmFsdWUiOjAsImluczo6Y2l0ZSI6MSwiaW5zOjpkYXRldGltZSI6MCwibGFiZWw6OmFjY2Vzc2tleSI6MCwKImxhYmVsOjpmb3IiOjUsImxhYmVsOjpvbmJsdXIiOjIsImxhYmVsOjpvbmZvY3VzIjoyLCJsZWdlbmQ6OmFjY2Vzc2tleSI6MCwibGVnZW5kOjphbGlnbiI6MCwibGk6OnR5cGUiOjAsImxpOjp2YWx1ZSI6MCwibWFwOjpuYW1lIjo3LCJtZW51Ojpjb21wYWN0IjowLCJtZW51OjpsYWJlbCI6MCwibWVudTo6dHlwZSI6MCwibWV0ZXI6OmhpZ2giOjAsIm1ldGVyOjpsb3ciOjAsIm1ldGVyOjptYXgiOjAsIm1ldGVyOjptaW4iOjAsIm1ldGVyOjp2YWx1ZSI6MCwib2w6OmNvbXBhY3QiOjAsIm9sOjpyZXZlcnNlZCI6MCwib2w6OnN0YXJ0IjowLCJvbDo6dHlwZSI6MCwib3B0Z3JvdXA6OmRpc2FibGVkIjowLCJvcHRncm91cDo6bGFiZWwiOjAsIm9wdGlvbjo6ZGlzYWJsZWQiOjAsIm9wdGlvbjo6bGFiZWwiOjAsIm9wdGlvbjo6c2VsZWN0ZWQiOjAsIm9wdGlvbjo6dmFsdWUiOjAsIm91dHB1dDo6Zm9yIjo2LCJvdXRwdXQ6Om5hbWUiOjgsInA6OmFsaWduIjowLCJwcmU6OndpZHRoIjowLAoicHJvZ3Jlc3M6Om1heCI6MCwicHJvZ3Jlc3M6Om1pbiI6MCwicHJvZ3Jlc3M6OnZhbHVlIjowLCJxOjpjaXRlIjoxLCJzZWxlY3Q6OmF1dG9jb21wbGV0ZSI6MCwic2VsZWN0OjpkaXNhYmxlZCI6MCwic2VsZWN0OjptdWx0aXBsZSI6MCwic2VsZWN0OjpuYW1lIjo4LCJzZWxlY3Q6Om9uYmx1ciI6Miwic2VsZWN0OjpvbmNoYW5nZSI6Miwic2VsZWN0OjpvbmZvY3VzIjoyLCJzZWxlY3Q6OnJlcXVpcmVkIjowLCJzZWxlY3Q6OnNpemUiOjAsInNvdXJjZTo6dHlwZSI6MCwidGFibGU6OmFsaWduIjowLCJ0YWJsZTo6Ymdjb2xvciI6MCwidGFibGU6OmJvcmRlciI6MCwidGFibGU6OmNlbGxwYWRkaW5nIjowLCJ0YWJsZTo6Y2VsbHNwYWNpbmciOjAsInRhYmxlOjpmcmFtZSI6MCwidGFibGU6OnJ1bGVzIjowLCJ0YWJsZTo6c3VtbWFyeSI6MCwidGFibGU6OndpZHRoIjowLCJ0Ym9keTo6YWxpZ24iOjAsInRib2R5OjpjaGFyIjowLCJ0Ym9keTo6Y2hhcm9mZiI6MCwidGJvZHk6OnZhbGlnbiI6MCwKInRkOjphYmJyIjowLCJ0ZDo6YWxpZ24iOjAsInRkOjpheGlzIjowLCJ0ZDo6Ymdjb2xvciI6MCwidGQ6OmNoYXIiOjAsInRkOjpjaGFyb2ZmIjowLCJ0ZDo6Y29sc3BhbiI6MCwidGQ6OmhlYWRlcnMiOjYsInRkOjpoZWlnaHQiOjAsInRkOjpub3dyYXAiOjAsInRkOjpyb3dzcGFuIjowLCJ0ZDo6c2NvcGUiOjAsInRkOjp2YWxpZ24iOjAsInRkOjp3aWR0aCI6MCwidGV4dGFyZWE6OmFjY2Vzc2tleSI6MCwidGV4dGFyZWE6OmF1dG9jb21wbGV0ZSI6MCwidGV4dGFyZWE6OmNvbHMiOjAsInRleHRhcmVhOjpkaXNhYmxlZCI6MCwidGV4dGFyZWE6OmlucHV0bW9kZSI6MCwidGV4dGFyZWE6Om5hbWUiOjgsInRleHRhcmVhOjpvbmJsdXIiOjIsInRleHRhcmVhOjpvbmNoYW5nZSI6MiwidGV4dGFyZWE6Om9uZm9jdXMiOjIsInRleHRhcmVhOjpvbnNlbGVjdCI6MiwidGV4dGFyZWE6OnBsYWNlaG9sZGVyIjowLCJ0ZXh0YXJlYTo6cmVhZG9ubHkiOjAsInRleHRhcmVhOjpyZXF1aXJlZCI6MCwKInRleHRhcmVhOjpyb3dzIjowLCJ0ZXh0YXJlYTo6d3JhcCI6MCwidGZvb3Q6OmFsaWduIjowLCJ0Zm9vdDo6Y2hhciI6MCwidGZvb3Q6OmNoYXJvZmYiOjAsInRmb290Ojp2YWxpZ24iOjAsInRoOjphYmJyIjowLCJ0aDo6YWxpZ24iOjAsInRoOjpheGlzIjowLCJ0aDo6Ymdjb2xvciI6MCwidGg6OmNoYXIiOjAsInRoOjpjaGFyb2ZmIjowLCJ0aDo6Y29sc3BhbiI6MCwidGg6OmhlYWRlcnMiOjYsInRoOjpoZWlnaHQiOjAsInRoOjpub3dyYXAiOjAsInRoOjpyb3dzcGFuIjowLCJ0aDo6c2NvcGUiOjAsInRoOjp2YWxpZ24iOjAsInRoOjp3aWR0aCI6MCwidGhlYWQ6OmFsaWduIjowLCJ0aGVhZDo6Y2hhciI6MCwidGhlYWQ6OmNoYXJvZmYiOjAsInRoZWFkOjp2YWxpZ24iOjAsInRyOjphbGlnbiI6MCwidHI6OmJnY29sb3IiOjAsInRyOjpjaGFyIjowLCJ0cjo6Y2hhcm9mZiI6MCwidHI6OnZhbGlnbiI6MCwidHJhY2s6OmRlZmF1bHQiOjAsInRyYWNrOjpraW5kIjowLCJ0cmFjazo6bGFiZWwiOjAsCiJ0cmFjazo6c3JjbGFuZyI6MCwidWw6OmNvbXBhY3QiOjAsInVsOjp0eXBlIjowLCJ2aWRlbzo6Y29udHJvbHMiOjAsInZpZGVvOjpoZWlnaHQiOjAsInZpZGVvOjpsb29wIjowLCJ2aWRlbzo6bWVkaWFncm91cCI6NSwidmlkZW86Om11dGVkIjowLCJ2aWRlbzo6cG9zdGVyIjoxLCJ2aWRlbzo6cHJlbG9hZCI6MCwidmlkZW86OnNyYyI6MSwidmlkZW86OndpZHRoIjowfTskLkFUVFJJQlM9JC5tOyQuYz17T1BUSU9OQUxfRU5EVEFHOjEsRU1QVFk6MixDREFUQTo0LFJDREFUQTo4LFVOU0FGRToxNixGT0xEQUJMRTozMixTQ1JJUFQ6NjQsU1RZTEU6MTI4LFZJUlRVQUxJWkVEOjI1Nn07JC5lZmxhZ3M9JC5jOwokLmY9e2E6MCxhYmJyOjAsYWNyb255bTowLGFkZHJlc3M6MCxhcHBsZXQ6MjcyLGFyZWE6MixhcnRpY2xlOjAsYXNpZGU6MCxhdWRpbzowLGI6MCxiYXNlOjI3NCxiYXNlZm9udDoyNzQsYmRpOjAsYmRvOjAsYmlnOjAsYmxvY2txdW90ZTowLGJvZHk6MzA1LGJyOjIsYnV0dG9uOjAsY2FudmFzOjAsY2FwdGlvbjowLGNlbnRlcjowLGNpdGU6MCxjb2RlOjAsY29sOjIsY29sZ3JvdXA6MSxjb21tYW5kOjIsZGF0YTowLGRhdGFsaXN0OjAsZGQ6MSxkZWw6MCxkZXRhaWxzOjAsZGZuOjAsZGlhbG9nOjI3MixkaXI6MCxkaXY6MCxkbDowLGR0OjEsZW06MCxmaWVsZHNldDowLGZpZ2NhcHRpb246MCxmaWd1cmU6MCxmb250OjAsZm9vdGVyOjAsZm9ybTowLGZyYW1lOjI3NCxmcmFtZXNldDoyNzIsaDE6MCxoMjowLGgzOjAsaDQ6MCxoNTowLGg2OjAsaGVhZDozMDUsaGVhZGVyOjAsaGdyb3VwOjAsaHI6MixodG1sOjMwNSxpOjAsaWZyYW1lOjQsaW1nOjIsaW5wdXQ6MixpbnM6MCxpc2luZGV4OjI3NCwKa2JkOjAsa2V5Z2VuOjI3NCxsYWJlbDowLGxlZ2VuZDowLGxpOjEsbGluazoyNzQsbWFwOjAsbWFyazowLG1lbnU6MCxtZXRhOjI3NCxtZXRlcjowLG5hdjowLG5vYnI6MCxub2VtYmVkOjI3Nixub2ZyYW1lczoyNzYsbm9zY3JpcHQ6Mjc2LG9iamVjdDoyNzIsb2w6MCxvcHRncm91cDowLG9wdGlvbjoxLG91dHB1dDowLHA6MSxwYXJhbToyNzQscHJlOjAscHJvZ3Jlc3M6MCxxOjAsczowLHNhbXA6MCxzY3JpcHQ6ODQsc2VjdGlvbjowLHNlbGVjdDowLHNtYWxsOjAsc291cmNlOjIsc3BhbjowLHN0cmlrZTowLHN0cm9uZzowLHN0eWxlOjE0OCxzdWI6MCxzdW1tYXJ5OjAsc3VwOjAsdGFibGU6MCx0Ym9keToxLHRkOjEsdGV4dGFyZWE6OCx0Zm9vdDoxLHRoOjEsdGhlYWQ6MSx0aW1lOjAsdGl0bGU6MjgwLHRyOjEsdHJhY2s6Mix0dDowLHU6MCx1bDowLCJ2YXIiOjAsdmlkZW86MCx3YnI6Mn07JC5FTEVNRU5UUz0kLmY7CiQuUT17YToiSFRNTEFuY2hvckVsZW1lbnQiLGFiYnI6IkhUTUxFbGVtZW50IixhY3JvbnltOiJIVE1MRWxlbWVudCIsYWRkcmVzczoiSFRNTEVsZW1lbnQiLGFwcGxldDoiSFRNTEFwcGxldEVsZW1lbnQiLGFyZWE6IkhUTUxBcmVhRWxlbWVudCIsYXJ0aWNsZToiSFRNTEVsZW1lbnQiLGFzaWRlOiJIVE1MRWxlbWVudCIsYXVkaW86IkhUTUxBdWRpb0VsZW1lbnQiLGI6IkhUTUxFbGVtZW50IixiYXNlOiJIVE1MQmFzZUVsZW1lbnQiLGJhc2Vmb250OiJIVE1MQmFzZUZvbnRFbGVtZW50IixiZGk6IkhUTUxFbGVtZW50IixiZG86IkhUTUxFbGVtZW50IixiaWc6IkhUTUxFbGVtZW50IixibG9ja3F1b3RlOiJIVE1MUXVvdGVFbGVtZW50Iixib2R5OiJIVE1MQm9keUVsZW1lbnQiLGJyOiJIVE1MQlJFbGVtZW50IixidXR0b246IkhUTUxCdXR0b25FbGVtZW50IixjYW52YXM6IkhUTUxDYW52YXNFbGVtZW50IixjYXB0aW9uOiJIVE1MVGFibGVDYXB0aW9uRWxlbWVudCIsY2VudGVyOiJIVE1MRWxlbWVudCIsCmNpdGU6IkhUTUxFbGVtZW50Iixjb2RlOiJIVE1MRWxlbWVudCIsY29sOiJIVE1MVGFibGVDb2xFbGVtZW50Iixjb2xncm91cDoiSFRNTFRhYmxlQ29sRWxlbWVudCIsY29tbWFuZDoiSFRNTENvbW1hbmRFbGVtZW50IixkYXRhOiJIVE1MRWxlbWVudCIsZGF0YWxpc3Q6IkhUTUxEYXRhTGlzdEVsZW1lbnQiLGRkOiJIVE1MRWxlbWVudCIsZGVsOiJIVE1MTW9kRWxlbWVudCIsZGV0YWlsczoiSFRNTERldGFpbHNFbGVtZW50IixkZm46IkhUTUxFbGVtZW50IixkaWFsb2c6IkhUTUxEaWFsb2dFbGVtZW50IixkaXI6IkhUTUxEaXJlY3RvcnlFbGVtZW50IixkaXY6IkhUTUxEaXZFbGVtZW50IixkbDoiSFRNTERMaXN0RWxlbWVudCIsZHQ6IkhUTUxFbGVtZW50IixlbToiSFRNTEVsZW1lbnQiLGZpZWxkc2V0OiJIVE1MRmllbGRTZXRFbGVtZW50IixmaWdjYXB0aW9uOiJIVE1MRWxlbWVudCIsZmlndXJlOiJIVE1MRWxlbWVudCIsZm9udDoiSFRNTEZvbnRFbGVtZW50Iixmb290ZXI6IkhUTUxFbGVtZW50IiwKZm9ybToiSFRNTEZvcm1FbGVtZW50IixmcmFtZToiSFRNTEZyYW1lRWxlbWVudCIsZnJhbWVzZXQ6IkhUTUxGcmFtZVNldEVsZW1lbnQiLGgxOiJIVE1MSGVhZGluZ0VsZW1lbnQiLGgyOiJIVE1MSGVhZGluZ0VsZW1lbnQiLGgzOiJIVE1MSGVhZGluZ0VsZW1lbnQiLGg0OiJIVE1MSGVhZGluZ0VsZW1lbnQiLGg1OiJIVE1MSGVhZGluZ0VsZW1lbnQiLGg2OiJIVE1MSGVhZGluZ0VsZW1lbnQiLGhlYWQ6IkhUTUxIZWFkRWxlbWVudCIsaGVhZGVyOiJIVE1MRWxlbWVudCIsaGdyb3VwOiJIVE1MRWxlbWVudCIsaHI6IkhUTUxIUkVsZW1lbnQiLGh0bWw6IkhUTUxIdG1sRWxlbWVudCIsaToiSFRNTEVsZW1lbnQiLGlmcmFtZToiSFRNTElGcmFtZUVsZW1lbnQiLGltZzoiSFRNTEltYWdlRWxlbWVudCIsaW5wdXQ6IkhUTUxJbnB1dEVsZW1lbnQiLGluczoiSFRNTE1vZEVsZW1lbnQiLGlzaW5kZXg6IkhUTUxVbmtub3duRWxlbWVudCIsa2JkOiJIVE1MRWxlbWVudCIsa2V5Z2VuOiJIVE1MS2V5Z2VuRWxlbWVudCIsCmxhYmVsOiJIVE1MTGFiZWxFbGVtZW50IixsZWdlbmQ6IkhUTUxMZWdlbmRFbGVtZW50IixsaToiSFRNTExJRWxlbWVudCIsbGluazoiSFRNTExpbmtFbGVtZW50IixtYXA6IkhUTUxNYXBFbGVtZW50IixtYXJrOiJIVE1MRWxlbWVudCIsbWVudToiSFRNTE1lbnVFbGVtZW50IixtZXRhOiJIVE1MTWV0YUVsZW1lbnQiLG1ldGVyOiJIVE1MTWV0ZXJFbGVtZW50IixuYXY6IkhUTUxFbGVtZW50Iixub2JyOiJIVE1MRWxlbWVudCIsbm9lbWJlZDoiSFRNTEVsZW1lbnQiLG5vZnJhbWVzOiJIVE1MRWxlbWVudCIsbm9zY3JpcHQ6IkhUTUxFbGVtZW50IixvYmplY3Q6IkhUTUxPYmplY3RFbGVtZW50IixvbDoiSFRNTE9MaXN0RWxlbWVudCIsb3B0Z3JvdXA6IkhUTUxPcHRHcm91cEVsZW1lbnQiLG9wdGlvbjoiSFRNTE9wdGlvbkVsZW1lbnQiLG91dHB1dDoiSFRNTE91dHB1dEVsZW1lbnQiLHA6IkhUTUxQYXJhZ3JhcGhFbGVtZW50IixwYXJhbToiSFRNTFBhcmFtRWxlbWVudCIscHJlOiJIVE1MUHJlRWxlbWVudCIsCnByb2dyZXNzOiJIVE1MUHJvZ3Jlc3NFbGVtZW50IixxOiJIVE1MUXVvdGVFbGVtZW50IixzOiJIVE1MRWxlbWVudCIsc2FtcDoiSFRNTEVsZW1lbnQiLHNjcmlwdDoiSFRNTFNjcmlwdEVsZW1lbnQiLHNlY3Rpb246IkhUTUxFbGVtZW50IixzZWxlY3Q6IkhUTUxTZWxlY3RFbGVtZW50IixzbWFsbDoiSFRNTEVsZW1lbnQiLHNvdXJjZToiSFRNTFNvdXJjZUVsZW1lbnQiLHNwYW46IkhUTUxTcGFuRWxlbWVudCIsc3RyaWtlOiJIVE1MRWxlbWVudCIsc3Ryb25nOiJIVE1MRWxlbWVudCIsc3R5bGU6IkhUTUxTdHlsZUVsZW1lbnQiLHN1YjoiSFRNTEVsZW1lbnQiLHN1bW1hcnk6IkhUTUxFbGVtZW50IixzdXA6IkhUTUxFbGVtZW50Iix0YWJsZToiSFRNTFRhYmxlRWxlbWVudCIsdGJvZHk6IkhUTUxUYWJsZVNlY3Rpb25FbGVtZW50Iix0ZDoiSFRNTFRhYmxlRGF0YUNlbGxFbGVtZW50Iix0ZXh0YXJlYToiSFRNTFRleHRBcmVhRWxlbWVudCIsdGZvb3Q6IkhUTUxUYWJsZVNlY3Rpb25FbGVtZW50IiwKdGg6IkhUTUxUYWJsZUhlYWRlckNlbGxFbGVtZW50Iix0aGVhZDoiSFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQiLHRpbWU6IkhUTUxUaW1lRWxlbWVudCIsdGl0bGU6IkhUTUxUaXRsZUVsZW1lbnQiLHRyOiJIVE1MVGFibGVSb3dFbGVtZW50Iix0cmFjazoiSFRNTFRyYWNrRWxlbWVudCIsdHQ6IkhUTUxFbGVtZW50Iix1OiJIVE1MRWxlbWVudCIsdWw6IkhUTUxVTGlzdEVsZW1lbnQiLCJ2YXIiOiJIVE1MRWxlbWVudCIsdmlkZW86IkhUTUxWaWRlb0VsZW1lbnQiLHdicjoiSFRNTEVsZW1lbnQifTskLkVMRU1FTlRfRE9NX0lOVEVSRkFDRVM9JC5ROyQuUD17Tk9UX0xPQURFRDowLFNBTUVfRE9DVU1FTlQ6MSxORVdfRE9DVU1FTlQ6Mn07JC51ZWZmZWN0cz0kLlA7CiQuSj17ImE6OmhyZWYiOjIsImFyZWE6OmhyZWYiOjIsImF1ZGlvOjpzcmMiOjEsImJsb2NrcXVvdGU6OmNpdGUiOjAsImNvbW1hbmQ6Omljb24iOjEsImRlbDo6Y2l0ZSI6MCwiZm9ybTo6YWN0aW9uIjoyLCJpbWc6OnNyYyI6MSwiaW5wdXQ6OnNyYyI6MSwiaW5zOjpjaXRlIjowLCJxOjpjaXRlIjowLCJ2aWRlbzo6cG9zdGVyIjoxLCJ2aWRlbzo6c3JjIjoxfTskLlVSSUVGRkVDVFM9JC5KOyQuTT17VU5TQU5EQk9YRUQ6MixTQU5EQk9YRUQ6MSxEQVRBOjB9OyQubHR5cGVzPSQuTTskLkk9eyJhOjpocmVmIjoyLCJhcmVhOjpocmVmIjoyLCJhdWRpbzo6c3JjIjoyLCJibG9ja3F1b3RlOjpjaXRlIjoyLCJjb21tYW5kOjppY29uIjoxLCJkZWw6OmNpdGUiOjIsImZvcm06OmFjdGlvbiI6MiwiaW1nOjpzcmMiOjEsImlucHV0OjpzcmMiOjEsImluczo6Y2l0ZSI6MiwicTo6Y2l0ZSI6MiwidmlkZW86OnBvc3RlciI6MSwidmlkZW86OnNyYyI6Mn07JC5MT0FERVJUWVBFUz0kLkk7CiJ1bmRlZmluZWQiIT09dHlwZW9mIHdpbmRvdyYmKHdpbmRvdy5odG1sND0kKTt2YXIgaGE9ZnVuY3Rpb24oZyl7ZnVuY3Rpb24gdyhhKXtpZihpLmhhc093blByb3BlcnR5KGEpKXJldHVybiBpW2FdO3ZhciBiPWEubWF0Y2gocSk7cmV0dXJuIGI/U3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChiWzFdLDEwKSk6KGI9YS5tYXRjaChCKSk/U3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChiWzFdLDE2KSk6ciYmRi50ZXN0KGEpPyhyLmlubmVySFRNTD0iJiIrYSsiOyIsYj1yLnRleHRDb250ZW50LGlbYV09Yik6IiYiK2ErIjsifWZ1bmN0aW9uIE0oYSxiKXtyZXR1cm4gdyhiKX1mdW5jdGlvbiB4KGEpe3JldHVybiBhLnJlcGxhY2UoaixNKX1mdW5jdGlvbiBFKGEpe3JldHVybigiIithKS5yZXBsYWNlKFIsIiZhbXA7IikucmVwbGFjZShQLCImbHQ7IikucmVwbGFjZShTLCImZ3Q7IikucmVwbGFjZShELCImIzM0OyIpfWZ1bmN0aW9uIGUoYSl7cmV0dXJuIGEucmVwbGFjZShpYSwiJmFtcDskMSIpLnJlcGxhY2UoUCwiJmx0OyIpLnJlcGxhY2UoUywiJmd0OyIpfQpmdW5jdGlvbiB2KGIpe3ZhciBkPXt6OmIuenx8Yi5jZGF0YSxBOmIuQXx8Yi5jb21tZW50LEI6Yi5CfHxiLmVuZERvYyx0OmIudHx8Yi5lbmRUYWcsZTpiLmV8fGIucGNkYXRhLEY6Yi5GfHxiLnJjZGF0YSxIOmIuSHx8Yi5zdGFydERvYyx3OmIud3x8Yi5zdGFydFRhZ307cmV0dXJuIGZ1bmN0aW9uKGIsZyl7dmFyIGY7dmFyIEg9Lyg8XC98PFwhLS18PFshP118WyY8Pl0pL2c7Zj1iKyIiO2lmKEcpZj1mLnNwbGl0KEgpO2Vsc2V7Zm9yKHZhciBlPVtdLGg9MCxqOyhqPUguZXhlYyhmKSkhPT1zOyllLnB1c2goZi5zdWJzdHJpbmcoaCxqLmluZGV4KSksZS5wdXNoKGpbMF0pLGg9ai5pbmRleCtqWzBdLmxlbmd0aDtlLnB1c2goZi5zdWJzdHJpbmcoaCkpO2Y9ZX1hKGQsZiwwLHtyOkMsQzpDfSxnKX19ZnVuY3Rpb24gYihiLGQsZyxmLHQpe3JldHVybiBmdW5jdGlvbigpe2EoYixkLGcsZix0KX19ZnVuY3Rpb24gYShhLGQscCxlLHQpe3RyeXthLkgmJjA9PXAmJmEuSCh0KTtmb3IodmFyIGgsCnosaixpPWQubGVuZ3RoO3A8aTspe3ZhciBvPWRbcCsrXSxsPWRbcF07c3dpdGNoKG8pe2Nhc2UgIiYiOkkudGVzdChsKT8oYS5lJiZhLmUoIiYiK2wsdCxBLGIoYSxkLHAsZSx0KSkscCsrKTphLmUmJmEuZSgiJmFtcDsiLHQsQSxiKGEsZCxwLGUsdCkpO2JyZWFrO2Nhc2UgIjwvIjppZihoPS9eKFstXHc6XSspW15cJ1wiXSovLmV4ZWMobCkpaWYoaFswXS5sZW5ndGg9PT1sLmxlbmd0aCYmIj4iPT09ZFtwKzFdKXArPTIsaj1oWzFdLnRvTG93ZXJDYXNlKCksYS50JiZhLnQoaix0LEEsYihhLGQscCxlLHQpKTtlbHNle3ZhciBtPWQscT1wLHI9YSx1PXQsdj1BLHk9ZSx3PWYobSxxKTt3PyhyLnQmJnIudCh3Lm5hbWUsdSx2LGIocixtLHEseSx1KSkscD13Lm5leHQpOnA9bS5sZW5ndGh9ZWxzZSBhLmUmJmEuZSgiJmx0Oy8iLHQsQSxiKGEsZCxwLGUsdCkpO2JyZWFrO2Nhc2UgIjwiOmlmKGg9L14oWy1cdzpdKylccypcLz8vLmV4ZWMobCkpaWYoaFswXS5sZW5ndGg9PT1sLmxlbmd0aCYmCiI+Ij09PWRbcCsxXSl7cCs9MjtqPWhbMV0udG9Mb3dlckNhc2UoKTthLncmJmEudyhqLFtdLHQsQSxiKGEsZCxwLGUsdCkpO3ZhciBCPWcuZltqXTtCJksmJihwPWsoZCx7bmFtZTpqLG5leHQ6cCxjOkJ9LGEsdCxBLGUpKX1lbHNle3ZhciBtPWQscT1hLHI9dCx1PUEsdj1lLHg9ZihtLHApO3g/KHEudyYmcS53KHgubmFtZSx4LlIscix1LGIocSxtLHgubmV4dCx2LHIpKSxwPXguYyZLP2sobSx4LHEscix1LHYpOngubmV4dCk6cD1tLmxlbmd0aH1lbHNlIGEuZSYmYS5lKCImbHQ7Iix0LEEsYihhLGQscCxlLHQpKTticmVhaztjYXNlICI8XCEtLSI6aWYoIWUuQyl7Zm9yKHo9cCsxO3o8aSYmISgiPiI9PT1kW3pdJiYvLS0kLy50ZXN0KGRbei0xXSkpO3orKyk7aWYoejxpKXtpZihhLkEpe3ZhciBEPWQuc2xpY2UocCx6KS5qb2luKCIiKTthLkEoRC5zdWJzdHIoMCxELmxlbmd0aC0yKSx0LEEsYihhLGQseisxLGUsdCkpfXA9eisxfWVsc2UgZS5DPW59ZS5DJiZhLmUmJmEuZSgiJmx0OyEtLSIsCnQsQSxiKGEsZCxwLGUsdCkpO2JyZWFrO2Nhc2UgIjwhIjppZigvXlx3Ly50ZXN0KGwpKXtpZighZS5yKXtmb3Ioej1wKzE7ejxpJiYiPiIhPT1kW3pdO3orKyk7ejxpP3A9eisxOmUucj1ufWUuciYmYS5lJiZhLmUoIiZsdDshIix0LEEsYihhLGQscCxlLHQpKX1lbHNlIGEuZSYmYS5lKCImbHQ7ISIsdCxBLGIoYSxkLHAsZSx0KSk7YnJlYWs7Y2FzZSAiPD8iOmlmKCFlLnIpe2Zvcih6PXArMTt6PGkmJiI+IiE9PWRbel07eisrKTt6PGk/cD16KzE6ZS5yPW59ZS5yJiZhLmUmJmEuZSgiJmx0Oz8iLHQsQSxiKGEsZCxwLGUsdCkpO2JyZWFrO2Nhc2UgIj4iOmEuZSYmYS5lKCImZ3Q7Iix0LEEsYihhLGQscCxlLHQpKTticmVhaztjYXNlICIiOmJyZWFrO2RlZmF1bHQ6YS5lJiZhLmUobyx0LEEsYihhLGQscCxlLHQpKX19YS5CJiZhLkIodCl9Y2F0Y2goRSl7aWYoRSE9PUEpdGhyb3cgRTt9fWZ1bmN0aW9uIGsoYSxkLGYsaCx0LGope3ZhciB6PWEubGVuZ3RoO1QuaGFzT3duUHJvcGVydHkoZC5uYW1lKXx8CihUW2QubmFtZV09UmVnRXhwKCJeIitkLm5hbWUrIig/OltcXHNcXC9dfCQpIiwiaSIpKTtmb3IodmFyIGk9VFtkLm5hbWVdLGs9ZC5uZXh0LGw9ZC5uZXh0KzE7bDx6JiYhKCI8LyI9PT1hW2wtMV0mJmkudGVzdChhW2xdKSk7bCsrKTtsPHomJihsLT0xKTt6PWEuc2xpY2UoayxsKS5qb2luKCIiKTtpZihkLmMmZy5jLkNEQVRBKWYueiYmZi56KHosaCx0LGIoZixhLGwsaixoKSk7ZWxzZSBpZihkLmMmZy5jLlJDREFUQSlmLkYmJmYuRihlKHopLGgsdCxiKGYsYSxsLGosaCkpO2Vsc2UgdGhyb3cgRXJyb3IoImJ1ZyIpO3JldHVybiBsfWZ1bmN0aW9uIGYoYSxiKXt2YXIgZD0vXihbLVx3Ol0rKS8uZXhlYyhhW2JdKSxmPXt9O2YubmFtZT1kWzFdLnRvTG93ZXJDYXNlKCk7Zi5jPWcuZltmLm5hbWVdO2Zvcih2YXIgZT1hW2JdLnN1YnN0cihkWzBdLmxlbmd0aCksaD1iKzEsaj1hLmxlbmd0aDtoPGomJiI+IiE9PWFbaF07aCsrKWUrPWFbaF07aWYoIShqPD1oKSl7Zm9yKHZhciBsPVtdOyIiIT09CmU7KWlmKGQ9amEuZXhlYyhlKSlpZihkWzRdJiYhZFs1XXx8ZFs2XSYmIWRbN10pe2Zvcih2YXIgZD1kWzRdfHxkWzZdLGk9QyxlPVtlLGFbaCsrXV07aDxqO2grKyl7aWYoaSl7aWYoIj4iPT09YVtoXSlicmVha31lbHNlIDA8PWFbaF0uaW5kZXhPZihkKSYmKGk9bik7ZS5wdXNoKGFbaF0pfWlmKGo8PWgpYnJlYWs7ZT1lLmpvaW4oIiIpfWVsc2V7dmFyIGk9ZFsxXS50b0xvd2VyQ2FzZSgpLGs7aWYoZFsyXSl7az1kWzNdO3ZhciBtPWsuY2hhckNvZGVBdCgwKTtpZigzND09PW18fDM5PT09bSlrPWsuc3Vic3RyKDEsay5sZW5ndGgtMik7az14KGsucmVwbGFjZShvLCIiKSl9ZWxzZSBrPSIiO2wucHVzaChpLGspO2U9ZS5zdWJzdHIoZFswXS5sZW5ndGgpfWVsc2UgZT1lLnJlcGxhY2UoL15bXHNcU11bXmEtelxzXSovLCIiKTtmLlI9bDtmLm5leHQ9aCsxO3JldHVybiBmfX1mdW5jdGlvbiBoKGEpe2Z1bmN0aW9uIGIoYSxkKXtmfHxkLnB1c2goYSl9dmFyIGQsZjtyZXR1cm4gdih7c3RhcnREb2M6ZnVuY3Rpb24oKXtkPQpbXTtmPUN9LHN0YXJ0VGFnOmZ1bmN0aW9uKGIsZSxoKXtpZighZiYmZy5mLmhhc093blByb3BlcnR5KGIpKXt2YXIgaj1nLmZbYl07aWYoIShqJmcuYy5GT0xEQUJMRSkpe3ZhciBrPWEoYixlKTtpZihrKXtpZigib2JqZWN0IiE9PXR5cGVvZiBrKXRocm93IEVycm9yKCJ0YWdQb2xpY3kgZGlkIG5vdCByZXR1cm4gb2JqZWN0IChvbGQgQVBJPykiKTtpZigiYXR0cmlicyJpbiBrKWU9ay5hdHRyaWJzO2Vsc2UgdGhyb3cgRXJyb3IoInRhZ1BvbGljeSBnYXZlIG5vIGF0dHJpYnMiKTt2YXIgaTsidGFnTmFtZSJpbiBrPyhpPWsudGFnTmFtZSxrPWcuZltpXSk6KGk9YixrPWopO2lmKGomZy5jLk9QVElPTkFMX0VORFRBRyl7dmFyIGw9ZFtkLmxlbmd0aC0xXTtsJiZsLkQ9PT1iJiYobC52IT09aXx8YiE9PWkpJiZoLnB1c2goIjwvIixsLnYsIj4iKX1qJmcuYy5FTVBUWXx8ZC5wdXNoKHtEOmIsdjppfSk7aC5wdXNoKCI8IixpKTtiPTA7Zm9yKGw9ZS5sZW5ndGg7YjxsO2IrPTIpe3ZhciBtPQplW2JdLG89ZVtiKzFdO28hPT1zJiZvIT09YyYmaC5wdXNoKCIgIixtLCc9IicsRShvKSwnIicpfWgucHVzaCgiPiIpO2omZy5jLkVNUFRZJiYhKGsmZy5jLkVNUFRZKSYmaC5wdXNoKCI8LyIsaSwiPiIpfWVsc2UgZj0hKGomZy5jLkVNUFRZKX19fSxlbmRUYWc6ZnVuY3Rpb24oYSxiKXtpZihmKWY9QztlbHNlIGlmKGcuZi5oYXNPd25Qcm9wZXJ0eShhKSl7dmFyIGU9Zy5mW2FdO2lmKCEoZSYoZy5jLkVNUFRZfGcuYy5GT0xEQUJMRSkpKXtpZihlJmcuYy5PUFRJT05BTF9FTkRUQUcpZm9yKGU9ZC5sZW5ndGg7MDw9LS1lOyl7dmFyIGg9ZFtlXS5EO2lmKGg9PT1hKWJyZWFrO2lmKCEoZy5mW2hdJmcuYy5PUFRJT05BTF9FTkRUQUcpKXJldHVybn1lbHNlIGZvcihlPWQubGVuZ3RoOzA8PS0tZSYmZFtlXS5EIT09YTspO2lmKCEoMD5lKSl7Zm9yKGg9ZC5sZW5ndGg7LS1oPmU7KXt2YXIgaj1kW2hdLnY7Zy5mW2pdJmcuYy5PUFRJT05BTF9FTkRUQUd8fGIucHVzaCgiPC8iLGosIj4iKX1lPApkLmxlbmd0aCYmKGE9ZFtlXS52KTtkLmxlbmd0aD1lO2IucHVzaCgiPC8iLGEsIj4iKX19fX0scGNkYXRhOmIscmNkYXRhOmIsY2RhdGE6YixlbmREb2M6ZnVuY3Rpb24oYSl7Zm9yKDtkLmxlbmd0aDtkLmxlbmd0aC0tKWEucHVzaCgiPC8iLGRbZC5sZW5ndGgtMV0udiwiPiIpfX0pfWZ1bmN0aW9uIGQoYSxiLGQsZixlKXtpZighZSlyZXR1cm4gczt0cnl7dmFyIGc9WS5wYXJzZSgiIithKTtpZihnJiYoIWcuSygpfHxrYS50ZXN0KGcuVygpKSkpe3ZhciBoPWUoZyxiLGQsZik7cmV0dXJuIGg/aC50b1N0cmluZygpOnN9fWNhdGNoKGope31yZXR1cm4gc31mdW5jdGlvbiB5KGEsYixkLGYsZSl7ZHx8YShiKyIgcmVtb3ZlZCIse1M6InJlbW92ZWQiLHRhZ05hbWU6Yn0pO2lmKGYhPT1lKXt2YXIgZz0iY2hhbmdlZCI7ZiYmIWU/Zz0icmVtb3ZlZCI6IWYmJmUmJihnPSJhZGRlZCIpO2EoYisiLiIrZCsiICIrZyx7UzpnLHRhZ05hbWU6YixsYTpkLG9sZFZhbHVlOmYsbmV3VmFsdWU6ZX0pfX0KZnVuY3Rpb24gbChhLGIsZCl7Yj1iKyI6OiIrZDtpZihhLmhhc093blByb3BlcnR5KGIpKXJldHVybiBhW2JdO2I9Iio6OiIrZDtpZihhLmhhc093blByb3BlcnR5KGIpKXJldHVybiBhW2JdfWZ1bmN0aW9uIFYoYSxiLGYsZSxoKXtmb3IodmFyIGo9MDtqPGIubGVuZ3RoO2orPTIpe3ZhciBrPWJbal0saT1iW2orMV0sbT1pLG89cyxxO2lmKChxPWErIjo6IitrLGcubS5oYXNPd25Qcm9wZXJ0eShxKSl8fChxPSIqOjoiK2ssZy5tLmhhc093blByb3BlcnR5KHEpKSlvPWcubVtxXTtpZihvIT09cylzd2l0Y2gobyl7Y2FzZSBnLmQuTk9ORTpicmVhaztjYXNlIGcuZC5TQ1JJUFQ6aT1zO2gmJnkoaCxhLGssbSxpKTticmVhaztjYXNlIGcuZC5TVFlMRTppZigidW5kZWZpbmVkIj09PXR5cGVvZiBOKXtpPXM7aCYmeShoLGEsayxtLGkpO2JyZWFrfXZhciByPVtdO04oaSx7ZGVjbGFyYXRpb246ZnVuY3Rpb24oYSxiKXt2YXIgZT1hLnRvTG93ZXJDYXNlKCk7dShlLGIsZj9mdW5jdGlvbihhKXtyZXR1cm4gZChhLApnLlAuamEsZy5NLmthLHtUWVBFOiJDU1MiLENTU19QUk9QOmV9LGYpfTpzKTtiLmxlbmd0aCYmci5wdXNoKGUrIjogIitiLmpvaW4oIiAiKSl9fSk7aT0wPHIubGVuZ3RoP3Iuam9pbigiIDsgIik6cztoJiZ5KGgsYSxrLG0saSk7YnJlYWs7Y2FzZSBnLmQuSUQ6Y2FzZSBnLmQuSURSRUY6Y2FzZSBnLmQuSURSRUZTOmNhc2UgZy5kLkdMT0JBTF9OQU1FOmNhc2UgZy5kLkxPQ0FMX05BTUU6Y2FzZSBnLmQuQ0xBU1NFUzppPWU/ZShpKTppO2gmJnkoaCxhLGssbSxpKTticmVhaztjYXNlIGcuZC5VUkk6aT1kKGksbChnLkosYSxrKSxsKGcuSSxhLGspLHtUWVBFOiJNQVJLVVAiLFhNTF9BVFRSOmssWE1MX1RBRzphfSxmKTtoJiZ5KGgsYSxrLG0saSk7YnJlYWs7Y2FzZSBnLmQuVVJJX0ZSQUdNRU5UOmkmJiIjIj09PWkuY2hhckF0KDApPyhpPWkuc3Vic3RyaW5nKDEpLGk9ZT9lKGkpOmksaSE9PXMmJmkhPT1jJiYoaT0iIyIraSkpOmk9cztoJiZ5KGgsYSxrLG0saSk7YnJlYWs7ZGVmYXVsdDppPQpzLGgmJnkoaCxhLGssbSxpKX1lbHNlIGk9cyxoJiZ5KGgsYSxrLG0saSk7YltqKzFdPWl9cmV0dXJuIGJ9ZnVuY3Rpb24gZWEoYSxiLGQpe3JldHVybiBmdW5jdGlvbihlLGYpe2lmKGcuZltlXSZnLmMuVU5TQUZFKWQmJnkoZCxlLGMsYyxjKTtlbHNlIHJldHVybnthdHRyaWJzOlYoZSxmLGEsYixkKX19fWZ1bmN0aW9uIFEoYSxiKXt2YXIgZD1bXTtoKGIpKGEsZCk7cmV0dXJuIGQuam9pbigiIil9dmFyIE4sdTsidW5kZWZpbmVkIiE9PXR5cGVvZiB3aW5kb3cmJihOPXdpbmRvdy5wYXJzZUNzc0RlY2xhcmF0aW9ucyx1PXdpbmRvdy5zYW5pdGl6ZUNzc1Byb3BlcnR5KTt2YXIgaT17bHQ6IjwiLExUOiI8IixndDoiPiIsR1Q6Ij4iLGFtcDoiJiIsQU1QOiImIixxdW90OiciJyxhcG9zOiInIixuYnNwOiJcdTAwYTAifSxxPS9eIyhcZCspJC8sQj0vXiN4KFswLTlBLUZhLWZdKykkLyxGPS9eW0EtWmEtel1bQS16YS16MC05XSskLyxyPSJ1bmRlZmluZWQiIT09dHlwZW9mIHdpbmRvdyYmCndpbmRvdy5kb2N1bWVudD93aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGV4dGFyZWEiKTpzLG89L1wwL2csaj0vJigjWzAtOV0rfCNbeFhdWzAtOUEtRmEtZl0rfFx3Kyk7L2csST0vXigjWzAtOV0rfCNbeFhdWzAtOUEtRmEtZl0rfFx3Kyk7LyxSPS8mL2csaWE9LyYoW15hLXojXXwjKD86W14wLTl4XXx4KD86W14wLTlhLWZdfCQpfCQpfCQpL2dpLFA9L1s8XS9nLFM9Lz4vZyxEPS9cIi9nLGphPS9eXHMqKFstLjpcd10rKSg/OlxzKig9KVxzKigoIilbXiJdKigifCQpfCgnKVteJ10qKCd8JCl8KD89W2Etel1bLVx3XSpccyo9KXxbXiInXHNdKikpPy9pLEc9Mz09PSJhLGIiLnNwbGl0KC8oLCkvKS5sZW5ndGgsSz1nLmMuQ0RBVEF8Zy5jLlJDREFUQSxBPXt9LFQ9e30sa2E9L14oPzpodHRwcz98bWFpbHRvfGRhdGEpJC9pLG09e307bS5wYT1tLmVzY2FwZUF0dHJpYj1FO20ucmE9bS5tYWtlSHRtbFNhbml0aXplcj1oO20uc2E9bS5tYWtlU2F4UGFyc2VyPXY7bS50YT1tLm1ha2VUYWdQb2xpY3k9CmVhO20ud2E9bS5ub3JtYWxpemVSQ0RhdGE9ZTttLnhhPW0uc2FuaXRpemU9ZnVuY3Rpb24oYSxiLGQsZSl7cmV0dXJuIFEoYSxlYShiLGQsZSkpfTttLnlhPW0uc2FuaXRpemVBdHRyaWJzPVY7bS56YT1tLnNhbml0aXplV2l0aFBvbGljeT1RO20uQmE9bS51bmVzY2FwZUVudGl0aWVzPXg7cmV0dXJuIG19KCQpLGxhPWhhLnNhbml0aXplOyJ1bmRlZmluZWQiIT09dHlwZW9mIHdpbmRvdyYmKHdpbmRvdy5odG1sPWhhLHdpbmRvdy5odG1sX3Nhbml0aXplPWxhKTt9KSgpOwohZnVuY3Rpb24odCl7aWYoIm9iamVjdCI9PXR5cGVvZiBleHBvcnRzJiYidW5kZWZpbmVkIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz10KCk7ZWxzZSBpZigiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSx0KTtlbHNleygidW5kZWZpbmVkIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6InVuZGVmaW5lZCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOiJ1bmRlZmluZWQiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMpLnBha289dCgpfX0oZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24gcihzLG8sbCl7ZnVuY3Rpb24gaChlLHQpe2lmKCFvW2VdKXtpZighc1tlXSl7dmFyIGE9ImZ1bmN0aW9uIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIXQmJmEpcmV0dXJuIGEoZSwhMCk7aWYoZClyZXR1cm4gZChlLCEwKTt2YXIgaT1uZXcgRXJyb3IoIkNhbm5vdCBmaW5kIG1vZHVsZSAnIitlKyInIik7dGhyb3cgaS5jb2RlPSJNT0RVTEVfTk9UX0ZPVU5EIixpfXZhciBuPW9bZV09e2V4cG9ydHM6e319O3NbZV1bMF0uY2FsbChuLmV4cG9ydHMsZnVuY3Rpb24odCl7cmV0dXJuIGgoc1tlXVsxXVt0XXx8dCl9LG4sbi5leHBvcnRzLHIscyxvLGwpfXJldHVybiBvW2VdLmV4cG9ydHN9Zm9yKHZhciBkPSJmdW5jdGlvbiI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLHQ9MDt0PGwubGVuZ3RoO3QrKyloKGxbdF0pO3JldHVybiBofSh7MTpbZnVuY3Rpb24odCxlLGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcz10KCIuL3psaWIvZGVmbGF0ZSIpLG89dCgiLi91dGlscy9jb21tb24iKSxsPXQoIi4vdXRpbHMvc3RyaW5ncyIpLG49dCgiLi96bGliL21lc3NhZ2VzIikscj10KCIuL3psaWIvenN0cmVhbSIpLGg9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxkPTAsZj0tMSxfPTAsdT04O2Z1bmN0aW9uIGModCl7aWYoISh0aGlzIGluc3RhbmNlb2YgYykpcmV0dXJuIG5ldyBjKHQpO3RoaXMub3B0aW9ucz1vLmFzc2lnbih7bGV2ZWw6ZixtZXRob2Q6dSxjaHVua1NpemU6MTYzODQsd2luZG93Qml0czoxNSxtZW1MZXZlbDo4LHN0cmF0ZWd5Ol8sdG86IiJ9LHR8fHt9KTt2YXIgZT10aGlzLm9wdGlvbnM7ZS5yYXcmJjA8ZS53aW5kb3dCaXRzP2Uud2luZG93Qml0cz0tZS53aW5kb3dCaXRzOmUuZ3ppcCYmMDxlLndpbmRvd0JpdHMmJmUud2luZG93Qml0czwxNiYmKGUud2luZG93Qml0cys9MTYpLHRoaXMuZXJyPTAsdGhpcy5tc2c9IiIsdGhpcy5lbmRlZD0hMSx0aGlzLmNodW5rcz1bXSx0aGlzLnN0cm09bmV3IHIsdGhpcy5zdHJtLmF2YWlsX291dD0wO3ZhciBhPXMuZGVmbGF0ZUluaXQyKHRoaXMuc3RybSxlLmxldmVsLGUubWV0aG9kLGUud2luZG93Qml0cyxlLm1lbUxldmVsLGUuc3RyYXRlZ3kpO2lmKGEhPT1kKXRocm93IG5ldyBFcnJvcihuW2FdKTtpZihlLmhlYWRlciYmcy5kZWZsYXRlU2V0SGVhZGVyKHRoaXMuc3RybSxlLmhlYWRlciksZS5kaWN0aW9uYXJ5KXt2YXIgaTtpZihpPSJzdHJpbmciPT10eXBlb2YgZS5kaWN0aW9uYXJ5P2wuc3RyaW5nMmJ1ZihlLmRpY3Rpb25hcnkpOiJbb2JqZWN0IEFycmF5QnVmZmVyXSI9PT1oLmNhbGwoZS5kaWN0aW9uYXJ5KT9uZXcgVWludDhBcnJheShlLmRpY3Rpb25hcnkpOmUuZGljdGlvbmFyeSwoYT1zLmRlZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSxpKSkhPT1kKXRocm93IG5ldyBFcnJvcihuW2FdKTt0aGlzLl9kaWN0X3NldD0hMH19ZnVuY3Rpb24gaSh0LGUpe3ZhciBhPW5ldyBjKGUpO2lmKGEucHVzaCh0LCEwKSxhLmVycil0aHJvdyBhLm1zZ3x8blthLmVycl07cmV0dXJuIGEucmVzdWx0fWMucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24odCxlKXt2YXIgYSxpLG49dGhpcy5zdHJtLHI9dGhpcy5vcHRpb25zLmNodW5rU2l6ZTtpZih0aGlzLmVuZGVkKXJldHVybiExO2k9ZT09PX5+ZT9lOiEwPT09ZT80OjAsInN0cmluZyI9PXR5cGVvZiB0P24uaW5wdXQ9bC5zdHJpbmcyYnVmKHQpOiJbb2JqZWN0IEFycmF5QnVmZmVyXSI9PT1oLmNhbGwodCk/bi5pbnB1dD1uZXcgVWludDhBcnJheSh0KTpuLmlucHV0PXQsbi5uZXh0X2luPTAsbi5hdmFpbF9pbj1uLmlucHV0Lmxlbmd0aDtkb3tpZigwPT09bi5hdmFpbF9vdXQmJihuLm91dHB1dD1uZXcgby5CdWY4KHIpLG4ubmV4dF9vdXQ9MCxuLmF2YWlsX291dD1yKSwxIT09KGE9cy5kZWZsYXRlKG4saSkpJiZhIT09ZClyZXR1cm4gdGhpcy5vbkVuZChhKSwhKHRoaXMuZW5kZWQ9ITApOzAhPT1uLmF2YWlsX291dCYmKDAhPT1uLmF2YWlsX2lufHw0IT09aSYmMiE9PWkpfHwoInN0cmluZyI9PT10aGlzLm9wdGlvbnMudG8/dGhpcy5vbkRhdGEobC5idWYyYmluc3RyaW5nKG8uc2hyaW5rQnVmKG4ub3V0cHV0LG4ubmV4dF9vdXQpKSk6dGhpcy5vbkRhdGEoby5zaHJpbmtCdWYobi5vdXRwdXQsbi5uZXh0X291dCkpKX13aGlsZSgoMDxuLmF2YWlsX2lufHwwPT09bi5hdmFpbF9vdXQpJiYxIT09YSk7cmV0dXJuIDQ9PT1pPyhhPXMuZGVmbGF0ZUVuZCh0aGlzLnN0cm0pLHRoaXMub25FbmQoYSksdGhpcy5lbmRlZD0hMCxhPT09ZCk6MiE9PWl8fCh0aGlzLm9uRW5kKGQpLCEobi5hdmFpbF9vdXQ9MCkpfSxjLnByb3RvdHlwZS5vbkRhdGE9ZnVuY3Rpb24odCl7dGhpcy5jaHVua3MucHVzaCh0KX0sYy5wcm90b3R5cGUub25FbmQ9ZnVuY3Rpb24odCl7dD09PWQmJigic3RyaW5nIj09PXRoaXMub3B0aW9ucy50bz90aGlzLnJlc3VsdD10aGlzLmNodW5rcy5qb2luKCIiKTp0aGlzLnJlc3VsdD1vLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpKSx0aGlzLmNodW5rcz1bXSx0aGlzLmVycj10LHRoaXMubXNnPXRoaXMuc3RybS5tc2d9LGEuRGVmbGF0ZT1jLGEuZGVmbGF0ZT1pLGEuZGVmbGF0ZVJhdz1mdW5jdGlvbih0LGUpe3JldHVybihlPWV8fHt9KS5yYXc9ITAsaSh0LGUpfSxhLmd6aXA9ZnVuY3Rpb24odCxlKXtyZXR1cm4oZT1lfHx7fSkuZ3ppcD0hMCxpKHQsZSl9fSx7Ii4vdXRpbHMvY29tbW9uIjozLCIuL3V0aWxzL3N0cmluZ3MiOjQsIi4vemxpYi9kZWZsYXRlIjo4LCIuL3psaWIvbWVzc2FnZXMiOjEzLCIuL3psaWIvenN0cmVhbSI6MTV9XSwyOltmdW5jdGlvbih0LGUsYSl7InVzZSBzdHJpY3QiO3ZhciBmPXQoIi4vemxpYi9pbmZsYXRlIiksXz10KCIuL3V0aWxzL2NvbW1vbiIpLHU9dCgiLi91dGlscy9zdHJpbmdzIiksYz10KCIuL3psaWIvY29uc3RhbnRzIiksaT10KCIuL3psaWIvbWVzc2FnZXMiKSxuPXQoIi4vemxpYi96c3RyZWFtIikscj10KCIuL3psaWIvZ3poZWFkZXIiKSxiPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7ZnVuY3Rpb24gcyh0KXtpZighKHRoaXMgaW5zdGFuY2VvZiBzKSlyZXR1cm4gbmV3IHModCk7dGhpcy5vcHRpb25zPV8uYXNzaWduKHtjaHVua1NpemU6MTYzODQsd2luZG93Qml0czowLHRvOiIifSx0fHx7fSk7dmFyIGU9dGhpcy5vcHRpb25zO2UucmF3JiYwPD1lLndpbmRvd0JpdHMmJmUud2luZG93Qml0czwxNiYmKGUud2luZG93Qml0cz0tZS53aW5kb3dCaXRzLDA9PT1lLndpbmRvd0JpdHMmJihlLndpbmRvd0JpdHM9LTE1KSksISgwPD1lLndpbmRvd0JpdHMmJmUud2luZG93Qml0czwxNil8fHQmJnQud2luZG93Qml0c3x8KGUud2luZG93Qml0cys9MzIpLDE1PGUud2luZG93Qml0cyYmZS53aW5kb3dCaXRzPDQ4JiYwPT0oMTUmZS53aW5kb3dCaXRzKSYmKGUud2luZG93Qml0c3w9MTUpLHRoaXMuZXJyPTAsdGhpcy5tc2c9IiIsdGhpcy5lbmRlZD0hMSx0aGlzLmNodW5rcz1bXSx0aGlzLnN0cm09bmV3IG4sdGhpcy5zdHJtLmF2YWlsX291dD0wO3ZhciBhPWYuaW5mbGF0ZUluaXQyKHRoaXMuc3RybSxlLndpbmRvd0JpdHMpO2lmKGEhPT1jLlpfT0spdGhyb3cgbmV3IEVycm9yKGlbYV0pO2lmKHRoaXMuaGVhZGVyPW5ldyByLGYuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sdGhpcy5oZWFkZXIpLGUuZGljdGlvbmFyeSYmKCJzdHJpbmciPT10eXBlb2YgZS5kaWN0aW9uYXJ5P2UuZGljdGlvbmFyeT11LnN0cmluZzJidWYoZS5kaWN0aW9uYXJ5KToiW29iamVjdCBBcnJheUJ1ZmZlcl0iPT09Yi5jYWxsKGUuZGljdGlvbmFyeSkmJihlLmRpY3Rpb25hcnk9bmV3IFVpbnQ4QXJyYXkoZS5kaWN0aW9uYXJ5KSksZS5yYXcmJihhPWYuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLGUuZGljdGlvbmFyeSkpIT09Yy5aX09LKSl0aHJvdyBuZXcgRXJyb3IoaVthXSl9ZnVuY3Rpb24gbyh0LGUpe3ZhciBhPW5ldyBzKGUpO2lmKGEucHVzaCh0LCEwKSxhLmVycil0aHJvdyBhLm1zZ3x8aVthLmVycl07cmV0dXJuIGEucmVzdWx0fXMucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24odCxlKXt2YXIgYSxpLG4scixzLG89dGhpcy5zdHJtLGw9dGhpcy5vcHRpb25zLmNodW5rU2l6ZSxoPXRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5LGQ9ITE7aWYodGhpcy5lbmRlZClyZXR1cm4hMTtpPWU9PT1+fmU/ZTohMD09PWU/Yy5aX0ZJTklTSDpjLlpfTk9fRkxVU0gsInN0cmluZyI9PXR5cGVvZiB0P28uaW5wdXQ9dS5iaW5zdHJpbmcyYnVmKHQpOiJbb2JqZWN0IEFycmF5QnVmZmVyXSI9PT1iLmNhbGwodCk/by5pbnB1dD1uZXcgVWludDhBcnJheSh0KTpvLmlucHV0PXQsby5uZXh0X2luPTAsby5hdmFpbF9pbj1vLmlucHV0Lmxlbmd0aDtkb3tpZigwPT09by5hdmFpbF9vdXQmJihvLm91dHB1dD1uZXcgXy5CdWY4KGwpLG8ubmV4dF9vdXQ9MCxvLmF2YWlsX291dD1sKSwoYT1mLmluZmxhdGUobyxjLlpfTk9fRkxVU0gpKT09PWMuWl9ORUVEX0RJQ1QmJmgmJihhPWYuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLGgpKSxhPT09Yy5aX0JVRl9FUlJPUiYmITA9PT1kJiYoYT1jLlpfT0ssZD0hMSksYSE9PWMuWl9TVFJFQU1fRU5EJiZhIT09Yy5aX09LKXJldHVybiB0aGlzLm9uRW5kKGEpLCEodGhpcy5lbmRlZD0hMCk7by5uZXh0X291dCYmKDAhPT1vLmF2YWlsX291dCYmYSE9PWMuWl9TVFJFQU1fRU5EJiYoMCE9PW8uYXZhaWxfaW58fGkhPT1jLlpfRklOSVNIJiZpIT09Yy5aX1NZTkNfRkxVU0gpfHwoInN0cmluZyI9PT10aGlzLm9wdGlvbnMudG8/KG49dS51dGY4Ym9yZGVyKG8ub3V0cHV0LG8ubmV4dF9vdXQpLHI9by5uZXh0X291dC1uLHM9dS5idWYyc3RyaW5nKG8ub3V0cHV0LG4pLG8ubmV4dF9vdXQ9cixvLmF2YWlsX291dD1sLXIsciYmXy5hcnJheVNldChvLm91dHB1dCxvLm91dHB1dCxuLHIsMCksdGhpcy5vbkRhdGEocykpOnRoaXMub25EYXRhKF8uc2hyaW5rQnVmKG8ub3V0cHV0LG8ubmV4dF9vdXQpKSkpLDA9PT1vLmF2YWlsX2luJiYwPT09by5hdmFpbF9vdXQmJihkPSEwKX13aGlsZSgoMDxvLmF2YWlsX2lufHwwPT09by5hdmFpbF9vdXQpJiZhIT09Yy5aX1NUUkVBTV9FTkQpO3JldHVybiBhPT09Yy5aX1NUUkVBTV9FTkQmJihpPWMuWl9GSU5JU0gpLGk9PT1jLlpfRklOSVNIPyhhPWYuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pLHRoaXMub25FbmQoYSksdGhpcy5lbmRlZD0hMCxhPT09Yy5aX09LKTppIT09Yy5aX1NZTkNfRkxVU0h8fCh0aGlzLm9uRW5kKGMuWl9PSyksIShvLmF2YWlsX291dD0wKSl9LHMucHJvdG90eXBlLm9uRGF0YT1mdW5jdGlvbih0KXt0aGlzLmNodW5rcy5wdXNoKHQpfSxzLnByb3RvdHlwZS5vbkVuZD1mdW5jdGlvbih0KXt0PT09Yy5aX09LJiYoInN0cmluZyI9PT10aGlzLm9wdGlvbnMudG8/dGhpcy5yZXN1bHQ9dGhpcy5jaHVua3Muam9pbigiIik6dGhpcy5yZXN1bHQ9Xy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKSksdGhpcy5jaHVua3M9W10sdGhpcy5lcnI9dCx0aGlzLm1zZz10aGlzLnN0cm0ubXNnfSxhLkluZmxhdGU9cyxhLmluZmxhdGU9byxhLmluZmxhdGVSYXc9ZnVuY3Rpb24odCxlKXtyZXR1cm4oZT1lfHx7fSkucmF3PSEwLG8odCxlKX0sYS51bmd6aXA9b30seyIuL3V0aWxzL2NvbW1vbiI6MywiLi91dGlscy9zdHJpbmdzIjo0LCIuL3psaWIvY29uc3RhbnRzIjo2LCIuL3psaWIvZ3poZWFkZXIiOjksIi4vemxpYi9pbmZsYXRlIjoxMSwiLi96bGliL21lc3NhZ2VzIjoxMywiLi96bGliL3pzdHJlYW0iOjE1fV0sMzpbZnVuY3Rpb24odCxlLGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgaT0idW5kZWZpbmVkIiE9dHlwZW9mIFVpbnQ4QXJyYXkmJiJ1bmRlZmluZWQiIT10eXBlb2YgVWludDE2QXJyYXkmJiJ1bmRlZmluZWQiIT10eXBlb2YgSW50MzJBcnJheTthLmFzc2lnbj1mdW5jdGlvbih0KXtmb3IodmFyIGUsYSxpPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtpLmxlbmd0aDspe3ZhciBuPWkuc2hpZnQoKTtpZihuKXtpZigib2JqZWN0IiE9dHlwZW9mIG4pdGhyb3cgbmV3IFR5cGVFcnJvcihuKyJtdXN0IGJlIG5vbi1vYmplY3QiKTtmb3IodmFyIHIgaW4gbillPW4sYT1yLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLGEpJiYodFtyXT1uW3JdKX19cmV0dXJuIHR9LGEuc2hyaW5rQnVmPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQubGVuZ3RoPT09ZT90OnQuc3ViYXJyYXk/dC5zdWJhcnJheSgwLGUpOih0Lmxlbmd0aD1lLHQpfTt2YXIgbj17YXJyYXlTZXQ6ZnVuY3Rpb24odCxlLGEsaSxuKXtpZihlLnN1YmFycmF5JiZ0LnN1YmFycmF5KXQuc2V0KGUuc3ViYXJyYXkoYSxhK2kpLG4pO2Vsc2UgZm9yKHZhciByPTA7cjxpO3IrKyl0W24rcl09ZVthK3JdfSxmbGF0dGVuQ2h1bmtzOmZ1bmN0aW9uKHQpe3ZhciBlLGEsaSxuLHIscztmb3IoZT1pPTAsYT10Lmxlbmd0aDtlPGE7ZSsrKWkrPXRbZV0ubGVuZ3RoO2ZvcihzPW5ldyBVaW50OEFycmF5KGkpLGU9bj0wLGE9dC5sZW5ndGg7ZTxhO2UrKylyPXRbZV0scy5zZXQocixuKSxuKz1yLmxlbmd0aDtyZXR1cm4gc319LHI9e2FycmF5U2V0OmZ1bmN0aW9uKHQsZSxhLGksbil7Zm9yKHZhciByPTA7cjxpO3IrKyl0W24rcl09ZVthK3JdfSxmbGF0dGVuQ2h1bmtzOmZ1bmN0aW9uKHQpe3JldHVybltdLmNvbmNhdC5hcHBseShbXSx0KX19O2Euc2V0VHlwZWQ9ZnVuY3Rpb24odCl7dD8oYS5CdWY4PVVpbnQ4QXJyYXksYS5CdWYxNj1VaW50MTZBcnJheSxhLkJ1ZjMyPUludDMyQXJyYXksYS5hc3NpZ24oYSxuKSk6KGEuQnVmOD1BcnJheSxhLkJ1ZjE2PUFycmF5LGEuQnVmMzI9QXJyYXksYS5hc3NpZ24oYSxyKSl9LGEuc2V0VHlwZWQoaSl9LHt9XSw0OltmdW5jdGlvbih0LGUsYSl7InVzZSBzdHJpY3QiO3ZhciBsPXQoIi4vY29tbW9uIiksbj0hMCxyPSEwO3RyeXtTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsWzBdKX1jYXRjaCh0KXtuPSExfXRyeXtTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsbmV3IFVpbnQ4QXJyYXkoMSkpfWNhdGNoKHQpe3I9ITF9Zm9yKHZhciBoPW5ldyBsLkJ1ZjgoMjU2KSxpPTA7aTwyNTY7aSsrKWhbaV09MjUyPD1pPzY6MjQ4PD1pPzU6MjQwPD1pPzQ6MjI0PD1pPzM6MTkyPD1pPzI6MTtmdW5jdGlvbiBkKHQsZSl7aWYoZTw2NTUzNCYmKHQuc3ViYXJyYXkmJnJ8fCF0LnN1YmFycmF5JiZuKSlyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLGwuc2hyaW5rQnVmKHQsZSkpO2Zvcih2YXIgYT0iIixpPTA7aTxlO2krKylhKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHRbaV0pO3JldHVybiBhfWhbMjU0XT1oWzI1NF09MSxhLnN0cmluZzJidWY9ZnVuY3Rpb24odCl7dmFyIGUsYSxpLG4scixzPXQubGVuZ3RoLG89MDtmb3Iobj0wO248cztuKyspNTUyOTY9PSg2NDUxMiYoYT10LmNoYXJDb2RlQXQobikpKSYmbisxPHMmJjU2MzIwPT0oNjQ1MTImKGk9dC5jaGFyQ29kZUF0KG4rMSkpKSYmKGE9NjU1MzYrKGEtNTUyOTY8PDEwKSsoaS01NjMyMCksbisrKSxvKz1hPDEyOD8xOmE8MjA0OD8yOmE8NjU1MzY/Mzo0O2ZvcihlPW5ldyBsLkJ1Zjgobyksbj1yPTA7cjxvO24rKyk1NTI5Nj09KDY0NTEyJihhPXQuY2hhckNvZGVBdChuKSkpJiZuKzE8cyYmNTYzMjA9PSg2NDUxMiYoaT10LmNoYXJDb2RlQXQobisxKSkpJiYoYT02NTUzNisoYS01NTI5Njw8MTApKyhpLTU2MzIwKSxuKyspLGE8MTI4P2VbcisrXT1hOihhPDIwNDg/ZVtyKytdPTE5MnxhPj4+NjooYTw2NTUzNj9lW3IrK109MjI0fGE+Pj4xMjooZVtyKytdPTI0MHxhPj4+MTgsZVtyKytdPTEyOHxhPj4+MTImNjMpLGVbcisrXT0xMjh8YT4+PjYmNjMpLGVbcisrXT0xMjh8NjMmYSk7cmV0dXJuIGV9LGEuYnVmMmJpbnN0cmluZz1mdW5jdGlvbih0KXtyZXR1cm4gZCh0LHQubGVuZ3RoKX0sYS5iaW5zdHJpbmcyYnVmPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgbC5CdWY4KHQubGVuZ3RoKSxhPTAsaT1lLmxlbmd0aDthPGk7YSsrKWVbYV09dC5jaGFyQ29kZUF0KGEpO3JldHVybiBlfSxhLmJ1ZjJzdHJpbmc9ZnVuY3Rpb24odCxlKXt2YXIgYSxpLG4scixzPWV8fHQubGVuZ3RoLG89bmV3IEFycmF5KDIqcyk7Zm9yKGE9aT0wO2E8czspaWYoKG49dFthKytdKTwxMjgpb1tpKytdPW47ZWxzZSBpZig0PChyPWhbbl0pKW9baSsrXT02NTUzMyxhKz1yLTE7ZWxzZXtmb3IobiY9Mj09PXI/MzE6Mz09PXI/MTU6NzsxPHImJmE8czspbj1uPDw2fDYzJnRbYSsrXSxyLS07MTxyP29baSsrXT02NTUzMzpuPDY1NTM2P29baSsrXT1uOihuLT02NTUzNixvW2krK109NTUyOTZ8bj4+MTAmMTAyMyxvW2krK109NTYzMjB8MTAyMyZuKX1yZXR1cm4gZChvLGkpfSxhLnV0Zjhib3JkZXI9ZnVuY3Rpb24odCxlKXt2YXIgYTtmb3IoKGU9ZXx8dC5sZW5ndGgpPnQubGVuZ3RoJiYoZT10Lmxlbmd0aCksYT1lLTE7MDw9YSYmMTI4PT0oMTkyJnRbYV0pOylhLS07cmV0dXJuIGE8MD9lOjA9PT1hP2U6YStoW3RbYV1dPmU/YTplfX0seyIuL2NvbW1vbiI6M31dLDU6W2Z1bmN0aW9uKHQsZSxhKXsidXNlIHN0cmljdCI7ZS5leHBvcnRzPWZ1bmN0aW9uKHQsZSxhLGkpe2Zvcih2YXIgbj02NTUzNSZ0fDAscj10Pj4+MTYmNjU1MzV8MCxzPTA7MCE9PWE7KXtmb3IoYS09cz0yZTM8YT8yZTM6YTtyPXIrKG49bitlW2krK118MCl8MCwtLXM7KTtuJT02NTUyMSxyJT02NTUyMX1yZXR1cm4gbnxyPDwxNnwwfX0se31dLDY6W2Z1bmN0aW9uKHQsZSxhKXsidXNlIHN0cmljdCI7ZS5leHBvcnRzPXtaX05PX0ZMVVNIOjAsWl9QQVJUSUFMX0ZMVVNIOjEsWl9TWU5DX0ZMVVNIOjIsWl9GVUxMX0ZMVVNIOjMsWl9GSU5JU0g6NCxaX0JMT0NLOjUsWl9UUkVFUzo2LFpfT0s6MCxaX1NUUkVBTV9FTkQ6MSxaX05FRURfRElDVDoyLFpfRVJSTk86LTEsWl9TVFJFQU1fRVJST1I6LTIsWl9EQVRBX0VSUk9SOi0zLFpfQlVGX0VSUk9SOi01LFpfTk9fQ09NUFJFU1NJT046MCxaX0JFU1RfU1BFRUQ6MSxaX0JFU1RfQ09NUFJFU1NJT046OSxaX0RFRkFVTFRfQ09NUFJFU1NJT046LTEsWl9GSUxURVJFRDoxLFpfSFVGRk1BTl9PTkxZOjIsWl9STEU6MyxaX0ZJWEVEOjQsWl9ERUZBVUxUX1NUUkFURUdZOjAsWl9CSU5BUlk6MCxaX1RFWFQ6MSxaX1VOS05PV046MixaX0RFRkxBVEVEOjh9fSx7fV0sNzpbZnVuY3Rpb24odCxlLGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgbz1mdW5jdGlvbigpe2Zvcih2YXIgdCxlPVtdLGE9MDthPDI1NjthKyspe3Q9YTtmb3IodmFyIGk9MDtpPDg7aSsrKXQ9MSZ0PzM5ODgyOTIzODRedD4+PjE6dD4+PjE7ZVthXT10fXJldHVybiBlfSgpO2UuZXhwb3J0cz1mdW5jdGlvbih0LGUsYSxpKXt2YXIgbj1vLHI9aSthO3RePS0xO2Zvcih2YXIgcz1pO3M8cjtzKyspdD10Pj4+OF5uWzI1NSYodF5lW3NdKV07cmV0dXJuLTFedH19LHt9XSw4OltmdW5jdGlvbih0LGUsYSl7InVzZSBzdHJpY3QiO3ZhciBsLF89dCgiLi4vdXRpbHMvY29tbW9uIiksaD10KCIuL3RyZWVzIiksdT10KCIuL2FkbGVyMzIiKSxjPXQoIi4vY3JjMzIiKSxpPXQoIi4vbWVzc2FnZXMiKSxkPTAsZj00LGI9MCxnPS0yLG09LTEsdz00LG49MixwPTgsdj05LHI9Mjg2LHM9MzAsbz0xOSxrPTIqcisxLHk9MTUseD0zLHo9MjU4LEI9eit4KzEsUz00MixFPTExMyxBPTEsWj0yLFI9MyxDPTQ7ZnVuY3Rpb24gTih0LGUpe3JldHVybiB0Lm1zZz1pW2VdLGV9ZnVuY3Rpb24gTyh0KXtyZXR1cm4odDw8MSktKDQ8dD85OjApfWZ1bmN0aW9uIEQodCl7Zm9yKHZhciBlPXQubGVuZ3RoOzA8PS0tZTspdFtlXT0wfWZ1bmN0aW9uIEkodCl7dmFyIGU9dC5zdGF0ZSxhPWUucGVuZGluZzthPnQuYXZhaWxfb3V0JiYoYT10LmF2YWlsX291dCksMCE9PWEmJihfLmFycmF5U2V0KHQub3V0cHV0LGUucGVuZGluZ19idWYsZS5wZW5kaW5nX291dCxhLHQubmV4dF9vdXQpLHQubmV4dF9vdXQrPWEsZS5wZW5kaW5nX291dCs9YSx0LnRvdGFsX291dCs9YSx0LmF2YWlsX291dC09YSxlLnBlbmRpbmctPWEsMD09PWUucGVuZGluZyYmKGUucGVuZGluZ19vdXQ9MCkpfWZ1bmN0aW9uIFUodCxlKXtoLl90cl9mbHVzaF9ibG9jayh0LDA8PXQuYmxvY2tfc3RhcnQ/dC5ibG9ja19zdGFydDotMSx0LnN0cnN0YXJ0LXQuYmxvY2tfc3RhcnQsZSksdC5ibG9ja19zdGFydD10LnN0cnN0YXJ0LEkodC5zdHJtKX1mdW5jdGlvbiBUKHQsZSl7dC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmcrK109ZX1mdW5jdGlvbiBGKHQsZSl7dC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmcrK109ZT4+PjgmMjU1LHQucGVuZGluZ19idWZbdC5wZW5kaW5nKytdPTI1NSZlfWZ1bmN0aW9uIEwodCxlKXt2YXIgYSxpLG49dC5tYXhfY2hhaW5fbGVuZ3RoLHI9dC5zdHJzdGFydCxzPXQucHJldl9sZW5ndGgsbz10Lm5pY2VfbWF0Y2gsbD10LnN0cnN0YXJ0PnQud19zaXplLUI/dC5zdHJzdGFydC0odC53X3NpemUtQik6MCxoPXQud2luZG93LGQ9dC53X21hc2ssZj10LnByZXYsXz10LnN0cnN0YXJ0K3osdT1oW3Ircy0xXSxjPWhbcitzXTt0LnByZXZfbGVuZ3RoPj10Lmdvb2RfbWF0Y2gmJihuPj49Miksbz50Lmxvb2thaGVhZCYmKG89dC5sb29rYWhlYWQpO2Rve2lmKGhbKGE9ZSkrc109PT1jJiZoW2Ercy0xXT09PXUmJmhbYV09PT1oW3JdJiZoWysrYV09PT1oW3IrMV0pe3IrPTIsYSsrO2Rve313aGlsZShoWysrcl09PT1oWysrYV0mJmhbKytyXT09PWhbKythXSYmaFsrK3JdPT09aFsrK2FdJiZoWysrcl09PT1oWysrYV0mJmhbKytyXT09PWhbKythXSYmaFsrK3JdPT09aFsrK2FdJiZoWysrcl09PT1oWysrYV0mJmhbKytyXT09PWhbKythXSYmcjxfKTtpZihpPXotKF8tcikscj1fLXosczxpKXtpZih0Lm1hdGNoX3N0YXJ0PWUsbzw9KHM9aSkpYnJlYWs7dT1oW3Ircy0xXSxjPWhbcitzXX19fXdoaWxlKChlPWZbZSZkXSk+bCYmMCE9LS1uKTtyZXR1cm4gczw9dC5sb29rYWhlYWQ/czp0Lmxvb2thaGVhZH1mdW5jdGlvbiBIKHQpe3ZhciBlLGEsaSxuLHIscyxvLGwsaCxkLGY9dC53X3NpemU7ZG97aWYobj10LndpbmRvd19zaXplLXQubG9va2FoZWFkLXQuc3Ryc3RhcnQsdC5zdHJzdGFydD49ZisoZi1CKSl7Zm9yKF8uYXJyYXlTZXQodC53aW5kb3csdC53aW5kb3csZixmLDApLHQubWF0Y2hfc3RhcnQtPWYsdC5zdHJzdGFydC09Zix0LmJsb2NrX3N0YXJ0LT1mLGU9YT10Lmhhc2hfc2l6ZTtpPXQuaGVhZFstLWVdLHQuaGVhZFtlXT1mPD1pP2ktZjowLC0tYTspO2ZvcihlPWE9ZjtpPXQucHJldlstLWVdLHQucHJldltlXT1mPD1pP2ktZjowLC0tYTspO24rPWZ9aWYoMD09PXQuc3RybS5hdmFpbF9pbilicmVhaztpZihzPXQuc3RybSxvPXQud2luZG93LGw9dC5zdHJzdGFydCt0Lmxvb2thaGVhZCxoPW4sZD12b2lkIDAsZD1zLmF2YWlsX2luLGg8ZCYmKGQ9aCksYT0wPT09ZD8wOihzLmF2YWlsX2luLT1kLF8uYXJyYXlTZXQobyxzLmlucHV0LHMubmV4dF9pbixkLGwpLDE9PT1zLnN0YXRlLndyYXA/cy5hZGxlcj11KHMuYWRsZXIsbyxkLGwpOjI9PT1zLnN0YXRlLndyYXAmJihzLmFkbGVyPWMocy5hZGxlcixvLGQsbCkpLHMubmV4dF9pbis9ZCxzLnRvdGFsX2luKz1kLGQpLHQubG9va2FoZWFkKz1hLHQubG9va2FoZWFkK3QuaW5zZXJ0Pj14KWZvcihyPXQuc3Ryc3RhcnQtdC5pbnNlcnQsdC5pbnNfaD10LndpbmRvd1tyXSx0Lmluc19oPSh0Lmluc19oPDx0Lmhhc2hfc2hpZnRedC53aW5kb3dbcisxXSkmdC5oYXNoX21hc2s7dC5pbnNlcnQmJih0Lmluc19oPSh0Lmluc19oPDx0Lmhhc2hfc2hpZnRedC53aW5kb3dbcit4LTFdKSZ0Lmhhc2hfbWFzayx0LnByZXZbciZ0LndfbWFza109dC5oZWFkW3QuaW5zX2hdLHQuaGVhZFt0Lmluc19oXT1yLHIrKyx0Lmluc2VydC0tLCEodC5sb29rYWhlYWQrdC5pbnNlcnQ8eCkpOyk7fXdoaWxlKHQubG9va2FoZWFkPEImJjAhPT10LnN0cm0uYXZhaWxfaW4pfWZ1bmN0aW9uIGoodCxlKXtmb3IodmFyIGEsaTs7KXtpZih0Lmxvb2thaGVhZDxCKXtpZihIKHQpLHQubG9va2FoZWFkPEImJmU9PT1kKXJldHVybiBBO2lmKDA9PT10Lmxvb2thaGVhZClicmVha31pZihhPTAsdC5sb29rYWhlYWQ+PXgmJih0Lmluc19oPSh0Lmluc19oPDx0Lmhhc2hfc2hpZnRedC53aW5kb3dbdC5zdHJzdGFydCt4LTFdKSZ0Lmhhc2hfbWFzayxhPXQucHJldlt0LnN0cnN0YXJ0JnQud19tYXNrXT10LmhlYWRbdC5pbnNfaF0sdC5oZWFkW3QuaW5zX2hdPXQuc3Ryc3RhcnQpLDAhPT1hJiZ0LnN0cnN0YXJ0LWE8PXQud19zaXplLUImJih0Lm1hdGNoX2xlbmd0aD1MKHQsYSkpLHQubWF0Y2hfbGVuZ3RoPj14KWlmKGk9aC5fdHJfdGFsbHkodCx0LnN0cnN0YXJ0LXQubWF0Y2hfc3RhcnQsdC5tYXRjaF9sZW5ndGgteCksdC5sb29rYWhlYWQtPXQubWF0Y2hfbGVuZ3RoLHQubWF0Y2hfbGVuZ3RoPD10Lm1heF9sYXp5X21hdGNoJiZ0Lmxvb2thaGVhZD49eCl7Zm9yKHQubWF0Y2hfbGVuZ3RoLS07dC5zdHJzdGFydCsrLHQuaW5zX2g9KHQuaW5zX2g8PHQuaGFzaF9zaGlmdF50LndpbmRvd1t0LnN0cnN0YXJ0K3gtMV0pJnQuaGFzaF9tYXNrLGE9dC5wcmV2W3Quc3Ryc3RhcnQmdC53X21hc2tdPXQuaGVhZFt0Lmluc19oXSx0LmhlYWRbdC5pbnNfaF09dC5zdHJzdGFydCwwIT0tLXQubWF0Y2hfbGVuZ3RoOyk7dC5zdHJzdGFydCsrfWVsc2UgdC5zdHJzdGFydCs9dC5tYXRjaF9sZW5ndGgsdC5tYXRjaF9sZW5ndGg9MCx0Lmluc19oPXQud2luZG93W3Quc3Ryc3RhcnRdLHQuaW5zX2g9KHQuaW5zX2g8PHQuaGFzaF9zaGlmdF50LndpbmRvd1t0LnN0cnN0YXJ0KzFdKSZ0Lmhhc2hfbWFzaztlbHNlIGk9aC5fdHJfdGFsbHkodCwwLHQud2luZG93W3Quc3Ryc3RhcnRdKSx0Lmxvb2thaGVhZC0tLHQuc3Ryc3RhcnQrKztpZihpJiYoVSh0LCExKSwwPT09dC5zdHJtLmF2YWlsX291dCkpcmV0dXJuIEF9cmV0dXJuIHQuaW5zZXJ0PXQuc3Ryc3RhcnQ8eC0xP3Quc3Ryc3RhcnQ6eC0xLGU9PT1mPyhVKHQsITApLDA9PT10LnN0cm0uYXZhaWxfb3V0P1I6Qyk6dC5sYXN0X2xpdCYmKFUodCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpP0E6Wn1mdW5jdGlvbiBLKHQsZSl7Zm9yKHZhciBhLGksbjs7KXtpZih0Lmxvb2thaGVhZDxCKXtpZihIKHQpLHQubG9va2FoZWFkPEImJmU9PT1kKXJldHVybiBBO2lmKDA9PT10Lmxvb2thaGVhZClicmVha31pZihhPTAsdC5sb29rYWhlYWQ+PXgmJih0Lmluc19oPSh0Lmluc19oPDx0Lmhhc2hfc2hpZnRedC53aW5kb3dbdC5zdHJzdGFydCt4LTFdKSZ0Lmhhc2hfbWFzayxhPXQucHJldlt0LnN0cnN0YXJ0JnQud19tYXNrXT10LmhlYWRbdC5pbnNfaF0sdC5oZWFkW3QuaW5zX2hdPXQuc3Ryc3RhcnQpLHQucHJldl9sZW5ndGg9dC5tYXRjaF9sZW5ndGgsdC5wcmV2X21hdGNoPXQubWF0Y2hfc3RhcnQsdC5tYXRjaF9sZW5ndGg9eC0xLDAhPT1hJiZ0LnByZXZfbGVuZ3RoPHQubWF4X2xhenlfbWF0Y2gmJnQuc3Ryc3RhcnQtYTw9dC53X3NpemUtQiYmKHQubWF0Y2hfbGVuZ3RoPUwodCxhKSx0Lm1hdGNoX2xlbmd0aDw9NSYmKDE9PT10LnN0cmF0ZWd5fHx0Lm1hdGNoX2xlbmd0aD09PXgmJjQwOTY8dC5zdHJzdGFydC10Lm1hdGNoX3N0YXJ0KSYmKHQubWF0Y2hfbGVuZ3RoPXgtMSkpLHQucHJldl9sZW5ndGg+PXgmJnQubWF0Y2hfbGVuZ3RoPD10LnByZXZfbGVuZ3RoKXtmb3Iobj10LnN0cnN0YXJ0K3QubG9va2FoZWFkLXgsaT1oLl90cl90YWxseSh0LHQuc3Ryc3RhcnQtMS10LnByZXZfbWF0Y2gsdC5wcmV2X2xlbmd0aC14KSx0Lmxvb2thaGVhZC09dC5wcmV2X2xlbmd0aC0xLHQucHJldl9sZW5ndGgtPTI7Kyt0LnN0cnN0YXJ0PD1uJiYodC5pbnNfaD0odC5pbnNfaDw8dC5oYXNoX3NoaWZ0XnQud2luZG93W3Quc3Ryc3RhcnQreC0xXSkmdC5oYXNoX21hc2ssYT10LnByZXZbdC5zdHJzdGFydCZ0LndfbWFza109dC5oZWFkW3QuaW5zX2hdLHQuaGVhZFt0Lmluc19oXT10LnN0cnN0YXJ0KSwwIT0tLXQucHJldl9sZW5ndGg7KTtpZih0Lm1hdGNoX2F2YWlsYWJsZT0wLHQubWF0Y2hfbGVuZ3RoPXgtMSx0LnN0cnN0YXJ0KyssaSYmKFUodCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpKXJldHVybiBBfWVsc2UgaWYodC5tYXRjaF9hdmFpbGFibGUpe2lmKChpPWguX3RyX3RhbGx5KHQsMCx0LndpbmRvd1t0LnN0cnN0YXJ0LTFdKSkmJlUodCwhMSksdC5zdHJzdGFydCsrLHQubG9va2FoZWFkLS0sMD09PXQuc3RybS5hdmFpbF9vdXQpcmV0dXJuIEF9ZWxzZSB0Lm1hdGNoX2F2YWlsYWJsZT0xLHQuc3Ryc3RhcnQrKyx0Lmxvb2thaGVhZC0tfXJldHVybiB0Lm1hdGNoX2F2YWlsYWJsZSYmKGk9aC5fdHJfdGFsbHkodCwwLHQud2luZG93W3Quc3Ryc3RhcnQtMV0pLHQubWF0Y2hfYXZhaWxhYmxlPTApLHQuaW5zZXJ0PXQuc3Ryc3RhcnQ8eC0xP3Quc3Ryc3RhcnQ6eC0xLGU9PT1mPyhVKHQsITApLDA9PT10LnN0cm0uYXZhaWxfb3V0P1I6Qyk6dC5sYXN0X2xpdCYmKFUodCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpP0E6Wn1mdW5jdGlvbiBNKHQsZSxhLGksbil7dGhpcy5nb29kX2xlbmd0aD10LHRoaXMubWF4X2xhenk9ZSx0aGlzLm5pY2VfbGVuZ3RoPWEsdGhpcy5tYXhfY2hhaW49aSx0aGlzLmZ1bmM9bn1mdW5jdGlvbiBQKCl7dGhpcy5zdHJtPW51bGwsdGhpcy5zdGF0dXM9MCx0aGlzLnBlbmRpbmdfYnVmPW51bGwsdGhpcy5wZW5kaW5nX2J1Zl9zaXplPTAsdGhpcy5wZW5kaW5nX291dD0wLHRoaXMucGVuZGluZz0wLHRoaXMud3JhcD0wLHRoaXMuZ3poZWFkPW51bGwsdGhpcy5nemluZGV4PTAsdGhpcy5tZXRob2Q9cCx0aGlzLmxhc3RfZmx1c2g9LTEsdGhpcy53X3NpemU9MCx0aGlzLndfYml0cz0wLHRoaXMud19tYXNrPTAsdGhpcy53aW5kb3c9bnVsbCx0aGlzLndpbmRvd19zaXplPTAsdGhpcy5wcmV2PW51bGwsdGhpcy5oZWFkPW51bGwsdGhpcy5pbnNfaD0wLHRoaXMuaGFzaF9zaXplPTAsdGhpcy5oYXNoX2JpdHM9MCx0aGlzLmhhc2hfbWFzaz0wLHRoaXMuaGFzaF9zaGlmdD0wLHRoaXMuYmxvY2tfc3RhcnQ9MCx0aGlzLm1hdGNoX2xlbmd0aD0wLHRoaXMucHJldl9tYXRjaD0wLHRoaXMubWF0Y2hfYXZhaWxhYmxlPTAsdGhpcy5zdHJzdGFydD0wLHRoaXMubWF0Y2hfc3RhcnQ9MCx0aGlzLmxvb2thaGVhZD0wLHRoaXMucHJldl9sZW5ndGg9MCx0aGlzLm1heF9jaGFpbl9sZW5ndGg9MCx0aGlzLm1heF9sYXp5X21hdGNoPTAsdGhpcy5sZXZlbD0wLHRoaXMuc3RyYXRlZ3k9MCx0aGlzLmdvb2RfbWF0Y2g9MCx0aGlzLm5pY2VfbWF0Y2g9MCx0aGlzLmR5bl9sdHJlZT1uZXcgXy5CdWYxNigyKmspLHRoaXMuZHluX2R0cmVlPW5ldyBfLkJ1ZjE2KDIqKDIqcysxKSksdGhpcy5ibF90cmVlPW5ldyBfLkJ1ZjE2KDIqKDIqbysxKSksRCh0aGlzLmR5bl9sdHJlZSksRCh0aGlzLmR5bl9kdHJlZSksRCh0aGlzLmJsX3RyZWUpLHRoaXMubF9kZXNjPW51bGwsdGhpcy5kX2Rlc2M9bnVsbCx0aGlzLmJsX2Rlc2M9bnVsbCx0aGlzLmJsX2NvdW50PW5ldyBfLkJ1ZjE2KHkrMSksdGhpcy5oZWFwPW5ldyBfLkJ1ZjE2KDIqcisxKSxEKHRoaXMuaGVhcCksdGhpcy5oZWFwX2xlbj0wLHRoaXMuaGVhcF9tYXg9MCx0aGlzLmRlcHRoPW5ldyBfLkJ1ZjE2KDIqcisxKSxEKHRoaXMuZGVwdGgpLHRoaXMubF9idWY9MCx0aGlzLmxpdF9idWZzaXplPTAsdGhpcy5sYXN0X2xpdD0wLHRoaXMuZF9idWY9MCx0aGlzLm9wdF9sZW49MCx0aGlzLnN0YXRpY19sZW49MCx0aGlzLm1hdGNoZXM9MCx0aGlzLmluc2VydD0wLHRoaXMuYmlfYnVmPTAsdGhpcy5iaV92YWxpZD0wfWZ1bmN0aW9uIFkodCl7dmFyIGU7cmV0dXJuIHQmJnQuc3RhdGU/KHQudG90YWxfaW49dC50b3RhbF9vdXQ9MCx0LmRhdGFfdHlwZT1uLChlPXQuc3RhdGUpLnBlbmRpbmc9MCxlLnBlbmRpbmdfb3V0PTAsZS53cmFwPDAmJihlLndyYXA9LWUud3JhcCksZS5zdGF0dXM9ZS53cmFwP1M6RSx0LmFkbGVyPTI9PT1lLndyYXA/MDoxLGUubGFzdF9mbHVzaD1kLGguX3RyX2luaXQoZSksYik6Tih0LGcpfWZ1bmN0aW9uIHEodCl7dmFyIGUsYT1ZKHQpO3JldHVybiBhPT09YiYmKChlPXQuc3RhdGUpLndpbmRvd19zaXplPTIqZS53X3NpemUsRChlLmhlYWQpLGUubWF4X2xhenlfbWF0Y2g9bFtlLmxldmVsXS5tYXhfbGF6eSxlLmdvb2RfbWF0Y2g9bFtlLmxldmVsXS5nb29kX2xlbmd0aCxlLm5pY2VfbWF0Y2g9bFtlLmxldmVsXS5uaWNlX2xlbmd0aCxlLm1heF9jaGFpbl9sZW5ndGg9bFtlLmxldmVsXS5tYXhfY2hhaW4sZS5zdHJzdGFydD0wLGUuYmxvY2tfc3RhcnQ9MCxlLmxvb2thaGVhZD0wLGUuaW5zZXJ0PTAsZS5tYXRjaF9sZW5ndGg9ZS5wcmV2X2xlbmd0aD14LTEsZS5tYXRjaF9hdmFpbGFibGU9MCxlLmluc19oPTApLGF9ZnVuY3Rpb24gRyh0LGUsYSxpLG4scil7aWYoIXQpcmV0dXJuIGc7dmFyIHM9MTtpZihlPT09bSYmKGU9NiksaTwwPyhzPTAsaT0taSk6MTU8aSYmKHM9MixpLT0xNiksbjwxfHx2PG58fGEhPT1wfHxpPDh8fDE1PGl8fGU8MHx8OTxlfHxyPDB8fHc8cilyZXR1cm4gTih0LGcpOzg9PT1pJiYoaT05KTt2YXIgbz1uZXcgUDtyZXR1cm4odC5zdGF0ZT1vKS5zdHJtPXQsby53cmFwPXMsby5nemhlYWQ9bnVsbCxvLndfYml0cz1pLG8ud19zaXplPTE8PG8ud19iaXRzLG8ud19tYXNrPW8ud19zaXplLTEsby5oYXNoX2JpdHM9bis3LG8uaGFzaF9zaXplPTE8PG8uaGFzaF9iaXRzLG8uaGFzaF9tYXNrPW8uaGFzaF9zaXplLTEsby5oYXNoX3NoaWZ0PX5+KChvLmhhc2hfYml0cyt4LTEpL3gpLG8ud2luZG93PW5ldyBfLkJ1ZjgoMipvLndfc2l6ZSksby5oZWFkPW5ldyBfLkJ1ZjE2KG8uaGFzaF9zaXplKSxvLnByZXY9bmV3IF8uQnVmMTYoby53X3NpemUpLG8ubGl0X2J1ZnNpemU9MTw8bis2LG8ucGVuZGluZ19idWZfc2l6ZT00Km8ubGl0X2J1ZnNpemUsby5wZW5kaW5nX2J1Zj1uZXcgXy5CdWY4KG8ucGVuZGluZ19idWZfc2l6ZSksby5kX2J1Zj0xKm8ubGl0X2J1ZnNpemUsby5sX2J1Zj0zKm8ubGl0X2J1ZnNpemUsby5sZXZlbD1lLG8uc3RyYXRlZ3k9cixvLm1ldGhvZD1hLHEodCl9bD1bbmV3IE0oMCwwLDAsMCxmdW5jdGlvbih0LGUpe3ZhciBhPTY1NTM1O2ZvcihhPnQucGVuZGluZ19idWZfc2l6ZS01JiYoYT10LnBlbmRpbmdfYnVmX3NpemUtNSk7Oyl7aWYodC5sb29rYWhlYWQ8PTEpe2lmKEgodCksMD09PXQubG9va2FoZWFkJiZlPT09ZClyZXR1cm4gQTtpZigwPT09dC5sb29rYWhlYWQpYnJlYWt9dC5zdHJzdGFydCs9dC5sb29rYWhlYWQsdC5sb29rYWhlYWQ9MDt2YXIgaT10LmJsb2NrX3N0YXJ0K2E7aWYoKDA9PT10LnN0cnN0YXJ0fHx0LnN0cnN0YXJ0Pj1pKSYmKHQubG9va2FoZWFkPXQuc3Ryc3RhcnQtaSx0LnN0cnN0YXJ0PWksVSh0LCExKSwwPT09dC5zdHJtLmF2YWlsX291dCkpcmV0dXJuIEE7aWYodC5zdHJzdGFydC10LmJsb2NrX3N0YXJ0Pj10Lndfc2l6ZS1CJiYoVSh0LCExKSwwPT09dC5zdHJtLmF2YWlsX291dCkpcmV0dXJuIEF9cmV0dXJuIHQuaW5zZXJ0PTAsZT09PWY/KFUodCwhMCksMD09PXQuc3RybS5hdmFpbF9vdXQ/UjpDKToodC5zdHJzdGFydD50LmJsb2NrX3N0YXJ0JiYoVSh0LCExKSx0LnN0cm0uYXZhaWxfb3V0KSxBKX0pLG5ldyBNKDQsNCw4LDQsaiksbmV3IE0oNCw1LDE2LDgsaiksbmV3IE0oNCw2LDMyLDMyLGopLG5ldyBNKDQsNCwxNiwxNixLKSxuZXcgTSg4LDE2LDMyLDMyLEspLG5ldyBNKDgsMTYsMTI4LDEyOCxLKSxuZXcgTSg4LDMyLDEyOCwyNTYsSyksbmV3IE0oMzIsMTI4LDI1OCwxMDI0LEspLG5ldyBNKDMyLDI1OCwyNTgsNDA5NixLKV0sYS5kZWZsYXRlSW5pdD1mdW5jdGlvbih0LGUpe3JldHVybiBHKHQsZSxwLDE1LDgsMCl9LGEuZGVmbGF0ZUluaXQyPUcsYS5kZWZsYXRlUmVzZXQ9cSxhLmRlZmxhdGVSZXNldEtlZXA9WSxhLmRlZmxhdGVTZXRIZWFkZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCYmdC5zdGF0ZT8yIT09dC5zdGF0ZS53cmFwP2c6KHQuc3RhdGUuZ3poZWFkPWUsYik6Z30sYS5kZWZsYXRlPWZ1bmN0aW9uKHQsZSl7dmFyIGEsaSxuLHI7aWYoIXR8fCF0LnN0YXRlfHw1PGV8fGU8MClyZXR1cm4gdD9OKHQsZyk6ZztpZihpPXQuc3RhdGUsIXQub3V0cHV0fHwhdC5pbnB1dCYmMCE9PXQuYXZhaWxfaW58fDY2Nj09PWkuc3RhdHVzJiZlIT09ZilyZXR1cm4gTih0LDA9PT10LmF2YWlsX291dD8tNTpnKTtpZihpLnN0cm09dCxhPWkubGFzdF9mbHVzaCxpLmxhc3RfZmx1c2g9ZSxpLnN0YXR1cz09PVMpaWYoMj09PWkud3JhcCl0LmFkbGVyPTAsVChpLDMxKSxUKGksMTM5KSxUKGksOCksaS5nemhlYWQ/KFQoaSwoaS5nemhlYWQudGV4dD8xOjApKyhpLmd6aGVhZC5oY3JjPzI6MCkrKGkuZ3poZWFkLmV4dHJhPzQ6MCkrKGkuZ3poZWFkLm5hbWU/ODowKSsoaS5nemhlYWQuY29tbWVudD8xNjowKSksVChpLDI1NSZpLmd6aGVhZC50aW1lKSxUKGksaS5nemhlYWQudGltZT4+OCYyNTUpLFQoaSxpLmd6aGVhZC50aW1lPj4xNiYyNTUpLFQoaSxpLmd6aGVhZC50aW1lPj4yNCYyNTUpLFQoaSw5PT09aS5sZXZlbD8yOjI8PWkuc3RyYXRlZ3l8fGkubGV2ZWw8Mj80OjApLFQoaSwyNTUmaS5nemhlYWQub3MpLGkuZ3poZWFkLmV4dHJhJiZpLmd6aGVhZC5leHRyYS5sZW5ndGgmJihUKGksMjU1JmkuZ3poZWFkLmV4dHJhLmxlbmd0aCksVChpLGkuZ3poZWFkLmV4dHJhLmxlbmd0aD4+OCYyNTUpKSxpLmd6aGVhZC5oY3JjJiYodC5hZGxlcj1jKHQuYWRsZXIsaS5wZW5kaW5nX2J1ZixpLnBlbmRpbmcsMCkpLGkuZ3ppbmRleD0wLGkuc3RhdHVzPTY5KTooVChpLDApLFQoaSwwKSxUKGksMCksVChpLDApLFQoaSwwKSxUKGksOT09PWkubGV2ZWw/MjoyPD1pLnN0cmF0ZWd5fHxpLmxldmVsPDI/NDowKSxUKGksMyksaS5zdGF0dXM9RSk7ZWxzZXt2YXIgcz1wKyhpLndfYml0cy04PDw0KTw8ODtzfD0oMjw9aS5zdHJhdGVneXx8aS5sZXZlbDwyPzA6aS5sZXZlbDw2PzE6Nj09PWkubGV2ZWw/MjozKTw8NiwwIT09aS5zdHJzdGFydCYmKHN8PTMyKSxzKz0zMS1zJTMxLGkuc3RhdHVzPUUsRihpLHMpLDAhPT1pLnN0cnN0YXJ0JiYoRihpLHQuYWRsZXI+Pj4xNiksRihpLDY1NTM1JnQuYWRsZXIpKSx0LmFkbGVyPTF9aWYoNjk9PT1pLnN0YXR1cylpZihpLmd6aGVhZC5leHRyYSl7Zm9yKG49aS5wZW5kaW5nO2kuZ3ppbmRleDwoNjU1MzUmaS5nemhlYWQuZXh0cmEubGVuZ3RoKSYmKGkucGVuZGluZyE9PWkucGVuZGluZ19idWZfc2l6ZXx8KGkuZ3poZWFkLmhjcmMmJmkucGVuZGluZz5uJiYodC5hZGxlcj1jKHQuYWRsZXIsaS5wZW5kaW5nX2J1ZixpLnBlbmRpbmctbixuKSksSSh0KSxuPWkucGVuZGluZyxpLnBlbmRpbmchPT1pLnBlbmRpbmdfYnVmX3NpemUpKTspVChpLDI1NSZpLmd6aGVhZC5leHRyYVtpLmd6aW5kZXhdKSxpLmd6aW5kZXgrKztpLmd6aGVhZC5oY3JjJiZpLnBlbmRpbmc+biYmKHQuYWRsZXI9Yyh0LmFkbGVyLGkucGVuZGluZ19idWYsaS5wZW5kaW5nLW4sbikpLGkuZ3ppbmRleD09PWkuZ3poZWFkLmV4dHJhLmxlbmd0aCYmKGkuZ3ppbmRleD0wLGkuc3RhdHVzPTczKX1lbHNlIGkuc3RhdHVzPTczO2lmKDczPT09aS5zdGF0dXMpaWYoaS5nemhlYWQubmFtZSl7bj1pLnBlbmRpbmc7ZG97aWYoaS5wZW5kaW5nPT09aS5wZW5kaW5nX2J1Zl9zaXplJiYoaS5nemhlYWQuaGNyYyYmaS5wZW5kaW5nPm4mJih0LmFkbGVyPWModC5hZGxlcixpLnBlbmRpbmdfYnVmLGkucGVuZGluZy1uLG4pKSxJKHQpLG49aS5wZW5kaW5nLGkucGVuZGluZz09PWkucGVuZGluZ19idWZfc2l6ZSkpe3I9MTticmVha31UKGkscj1pLmd6aW5kZXg8aS5nemhlYWQubmFtZS5sZW5ndGg/MjU1JmkuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChpLmd6aW5kZXgrKyk6MCl9d2hpbGUoMCE9PXIpO2kuZ3poZWFkLmhjcmMmJmkucGVuZGluZz5uJiYodC5hZGxlcj1jKHQuYWRsZXIsaS5wZW5kaW5nX2J1ZixpLnBlbmRpbmctbixuKSksMD09PXImJihpLmd6aW5kZXg9MCxpLnN0YXR1cz05MSl9ZWxzZSBpLnN0YXR1cz05MTtpZig5MT09PWkuc3RhdHVzKWlmKGkuZ3poZWFkLmNvbW1lbnQpe249aS5wZW5kaW5nO2Rve2lmKGkucGVuZGluZz09PWkucGVuZGluZ19idWZfc2l6ZSYmKGkuZ3poZWFkLmhjcmMmJmkucGVuZGluZz5uJiYodC5hZGxlcj1jKHQuYWRsZXIsaS5wZW5kaW5nX2J1ZixpLnBlbmRpbmctbixuKSksSSh0KSxuPWkucGVuZGluZyxpLnBlbmRpbmc9PT1pLnBlbmRpbmdfYnVmX3NpemUpKXtyPTE7YnJlYWt9VChpLHI9aS5nemluZGV4PGkuZ3poZWFkLmNvbW1lbnQubGVuZ3RoPzI1NSZpLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQoaS5nemluZGV4KyspOjApfXdoaWxlKDAhPT1yKTtpLmd6aGVhZC5oY3JjJiZpLnBlbmRpbmc+biYmKHQuYWRsZXI9Yyh0LmFkbGVyLGkucGVuZGluZ19idWYsaS5wZW5kaW5nLW4sbikpLDA9PT1yJiYoaS5zdGF0dXM9MTAzKX1lbHNlIGkuc3RhdHVzPTEwMztpZigxMDM9PT1pLnN0YXR1cyYmKGkuZ3poZWFkLmhjcmM/KGkucGVuZGluZysyPmkucGVuZGluZ19idWZfc2l6ZSYmSSh0KSxpLnBlbmRpbmcrMjw9aS5wZW5kaW5nX2J1Zl9zaXplJiYoVChpLDI1NSZ0LmFkbGVyKSxUKGksdC5hZGxlcj4+OCYyNTUpLHQuYWRsZXI9MCxpLnN0YXR1cz1FKSk6aS5zdGF0dXM9RSksMCE9PWkucGVuZGluZyl7aWYoSSh0KSwwPT09dC5hdmFpbF9vdXQpcmV0dXJuIGkubGFzdF9mbHVzaD0tMSxifWVsc2UgaWYoMD09PXQuYXZhaWxfaW4mJk8oZSk8PU8oYSkmJmUhPT1mKXJldHVybiBOKHQsLTUpO2lmKDY2Nj09PWkuc3RhdHVzJiYwIT09dC5hdmFpbF9pbilyZXR1cm4gTih0LC01KTtpZigwIT09dC5hdmFpbF9pbnx8MCE9PWkubG9va2FoZWFkfHxlIT09ZCYmNjY2IT09aS5zdGF0dXMpe3ZhciBvPTI9PT1pLnN0cmF0ZWd5P2Z1bmN0aW9uKHQsZSl7Zm9yKHZhciBhOzspe2lmKDA9PT10Lmxvb2thaGVhZCYmKEgodCksMD09PXQubG9va2FoZWFkKSl7aWYoZT09PWQpcmV0dXJuIEE7YnJlYWt9aWYodC5tYXRjaF9sZW5ndGg9MCxhPWguX3RyX3RhbGx5KHQsMCx0LndpbmRvd1t0LnN0cnN0YXJ0XSksdC5sb29rYWhlYWQtLSx0LnN0cnN0YXJ0KyssYSYmKFUodCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpKXJldHVybiBBfXJldHVybiB0Lmluc2VydD0wLGU9PT1mPyhVKHQsITApLDA9PT10LnN0cm0uYXZhaWxfb3V0P1I6Qyk6dC5sYXN0X2xpdCYmKFUodCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpP0E6Wn0oaSxlKTozPT09aS5zdHJhdGVneT9mdW5jdGlvbih0LGUpe2Zvcih2YXIgYSxpLG4scixzPXQud2luZG93Ozspe2lmKHQubG9va2FoZWFkPD16KXtpZihIKHQpLHQubG9va2FoZWFkPD16JiZlPT09ZClyZXR1cm4gQTtpZigwPT09dC5sb29rYWhlYWQpYnJlYWt9aWYodC5tYXRjaF9sZW5ndGg9MCx0Lmxvb2thaGVhZD49eCYmMDx0LnN0cnN0YXJ0JiYoaT1zW249dC5zdHJzdGFydC0xXSk9PT1zWysrbl0mJmk9PT1zWysrbl0mJmk9PT1zWysrbl0pe3I9dC5zdHJzdGFydCt6O2Rve313aGlsZShpPT09c1srK25dJiZpPT09c1srK25dJiZpPT09c1srK25dJiZpPT09c1srK25dJiZpPT09c1srK25dJiZpPT09c1srK25dJiZpPT09c1srK25dJiZpPT09c1srK25dJiZuPHIpO3QubWF0Y2hfbGVuZ3RoPXotKHItbiksdC5tYXRjaF9sZW5ndGg+dC5sb29rYWhlYWQmJih0Lm1hdGNoX2xlbmd0aD10Lmxvb2thaGVhZCl9aWYodC5tYXRjaF9sZW5ndGg+PXg/KGE9aC5fdHJfdGFsbHkodCwxLHQubWF0Y2hfbGVuZ3RoLXgpLHQubG9va2FoZWFkLT10Lm1hdGNoX2xlbmd0aCx0LnN0cnN0YXJ0Kz10Lm1hdGNoX2xlbmd0aCx0Lm1hdGNoX2xlbmd0aD0wKTooYT1oLl90cl90YWxseSh0LDAsdC53aW5kb3dbdC5zdHJzdGFydF0pLHQubG9va2FoZWFkLS0sdC5zdHJzdGFydCsrKSxhJiYoVSh0LCExKSwwPT09dC5zdHJtLmF2YWlsX291dCkpcmV0dXJuIEF9cmV0dXJuIHQuaW5zZXJ0PTAsZT09PWY/KFUodCwhMCksMD09PXQuc3RybS5hdmFpbF9vdXQ/UjpDKTp0Lmxhc3RfbGl0JiYoVSh0LCExKSwwPT09dC5zdHJtLmF2YWlsX291dCk/QTpafShpLGUpOmxbaS5sZXZlbF0uZnVuYyhpLGUpO2lmKG8hPT1SJiZvIT09Q3x8KGkuc3RhdHVzPTY2Niksbz09PUF8fG89PT1SKXJldHVybiAwPT09dC5hdmFpbF9vdXQmJihpLmxhc3RfZmx1c2g9LTEpLGI7aWYobz09PVomJigxPT09ZT9oLl90cl9hbGlnbihpKTo1IT09ZSYmKGguX3RyX3N0b3JlZF9ibG9jayhpLDAsMCwhMSksMz09PWUmJihEKGkuaGVhZCksMD09PWkubG9va2FoZWFkJiYoaS5zdHJzdGFydD0wLGkuYmxvY2tfc3RhcnQ9MCxpLmluc2VydD0wKSkpLEkodCksMD09PXQuYXZhaWxfb3V0KSlyZXR1cm4gaS5sYXN0X2ZsdXNoPS0xLGJ9cmV0dXJuIGUhPT1mP2I6aS53cmFwPD0wPzE6KDI9PT1pLndyYXA/KFQoaSwyNTUmdC5hZGxlciksVChpLHQuYWRsZXI+PjgmMjU1KSxUKGksdC5hZGxlcj4+MTYmMjU1KSxUKGksdC5hZGxlcj4+MjQmMjU1KSxUKGksMjU1JnQudG90YWxfaW4pLFQoaSx0LnRvdGFsX2luPj44JjI1NSksVChpLHQudG90YWxfaW4+PjE2JjI1NSksVChpLHQudG90YWxfaW4+PjI0JjI1NSkpOihGKGksdC5hZGxlcj4+PjE2KSxGKGksNjU1MzUmdC5hZGxlcikpLEkodCksMDxpLndyYXAmJihpLndyYXA9LWkud3JhcCksMCE9PWkucGVuZGluZz9iOjEpfSxhLmRlZmxhdGVFbmQ9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIHQmJnQuc3RhdGU/KGU9dC5zdGF0ZS5zdGF0dXMpIT09UyYmNjkhPT1lJiY3MyE9PWUmJjkxIT09ZSYmMTAzIT09ZSYmZSE9PUUmJjY2NiE9PWU/Tih0LGcpOih0LnN0YXRlPW51bGwsZT09PUU/Tih0LC0zKTpiKTpnfSxhLmRlZmxhdGVTZXREaWN0aW9uYXJ5PWZ1bmN0aW9uKHQsZSl7dmFyIGEsaSxuLHIscyxvLGwsaCxkPWUubGVuZ3RoO2lmKCF0fHwhdC5zdGF0ZSlyZXR1cm4gZztpZigyPT09KHI9KGE9dC5zdGF0ZSkud3JhcCl8fDE9PT1yJiZhLnN0YXR1cyE9PVN8fGEubG9va2FoZWFkKXJldHVybiBnO2ZvcigxPT09ciYmKHQuYWRsZXI9dSh0LmFkbGVyLGUsZCwwKSksYS53cmFwPTAsZD49YS53X3NpemUmJigwPT09ciYmKEQoYS5oZWFkKSxhLnN0cnN0YXJ0PTAsYS5ibG9ja19zdGFydD0wLGEuaW5zZXJ0PTApLGg9bmV3IF8uQnVmOChhLndfc2l6ZSksXy5hcnJheVNldChoLGUsZC1hLndfc2l6ZSxhLndfc2l6ZSwwKSxlPWgsZD1hLndfc2l6ZSkscz10LmF2YWlsX2luLG89dC5uZXh0X2luLGw9dC5pbnB1dCx0LmF2YWlsX2luPWQsdC5uZXh0X2luPTAsdC5pbnB1dD1lLEgoYSk7YS5sb29rYWhlYWQ+PXg7KXtmb3IoaT1hLnN0cnN0YXJ0LG49YS5sb29rYWhlYWQtKHgtMSk7YS5pbnNfaD0oYS5pbnNfaDw8YS5oYXNoX3NoaWZ0XmEud2luZG93W2kreC0xXSkmYS5oYXNoX21hc2ssYS5wcmV2W2kmYS53X21hc2tdPWEuaGVhZFthLmluc19oXSxhLmhlYWRbYS5pbnNfaF09aSxpKyssLS1uOyk7YS5zdHJzdGFydD1pLGEubG9va2FoZWFkPXgtMSxIKGEpfXJldHVybiBhLnN0cnN0YXJ0Kz1hLmxvb2thaGVhZCxhLmJsb2NrX3N0YXJ0PWEuc3Ryc3RhcnQsYS5pbnNlcnQ9YS5sb29rYWhlYWQsYS5sb29rYWhlYWQ9MCxhLm1hdGNoX2xlbmd0aD1hLnByZXZfbGVuZ3RoPXgtMSxhLm1hdGNoX2F2YWlsYWJsZT0wLHQubmV4dF9pbj1vLHQuaW5wdXQ9bCx0LmF2YWlsX2luPXMsYS53cmFwPXIsYn0sYS5kZWZsYXRlSW5mbz0icGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSJ9LHsiLi4vdXRpbHMvY29tbW9uIjozLCIuL2FkbGVyMzIiOjUsIi4vY3JjMzIiOjcsIi4vbWVzc2FnZXMiOjEzLCIuL3RyZWVzIjoxNH1dLDk6W2Z1bmN0aW9uKHQsZSxhKXsidXNlIHN0cmljdCI7ZS5leHBvcnRzPWZ1bmN0aW9uKCl7dGhpcy50ZXh0PTAsdGhpcy50aW1lPTAsdGhpcy54ZmxhZ3M9MCx0aGlzLm9zPTAsdGhpcy5leHRyYT1udWxsLHRoaXMuZXh0cmFfbGVuPTAsdGhpcy5uYW1lPSIiLHRoaXMuY29tbWVudD0iIix0aGlzLmhjcmM9MCx0aGlzLmRvbmU9ITF9fSx7fV0sMTA6W2Z1bmN0aW9uKHQsZSxhKXsidXNlIHN0cmljdCI7ZS5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIGEsaSxuLHIscyxvLGwsaCxkLGYsXyx1LGMsYixnLG0sdyxwLHYsayx5LHgseixCLFM7YT10LnN0YXRlLGk9dC5uZXh0X2luLEI9dC5pbnB1dCxuPWkrKHQuYXZhaWxfaW4tNSkscj10Lm5leHRfb3V0LFM9dC5vdXRwdXQscz1yLShlLXQuYXZhaWxfb3V0KSxvPXIrKHQuYXZhaWxfb3V0LTI1NyksbD1hLmRtYXgsaD1hLndzaXplLGQ9YS53aGF2ZSxmPWEud25leHQsXz1hLndpbmRvdyx1PWEuaG9sZCxjPWEuYml0cyxiPWEubGVuY29kZSxnPWEuZGlzdGNvZGUsbT0oMTw8YS5sZW5iaXRzKS0xLHc9KDE8PGEuZGlzdGJpdHMpLTE7dDpkb3tjPDE1JiYodSs9QltpKytdPDxjLGMrPTgsdSs9QltpKytdPDxjLGMrPTgpLHA9Ylt1Jm1dO2U6Zm9yKDs7KXtpZih1Pj4+PXY9cD4+PjI0LGMtPXYsMD09PSh2PXA+Pj4xNiYyNTUpKVNbcisrXT02NTUzNSZwO2Vsc2V7aWYoISgxNiZ2KSl7aWYoMD09KDY0JnYpKXtwPWJbKDY1NTM1JnApKyh1JigxPDx2KS0xKV07Y29udGludWUgZX1pZigzMiZ2KXthLm1vZGU9MTI7YnJlYWsgdH10Lm1zZz0iaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlIixhLm1vZGU9MzA7YnJlYWsgdH1rPTY1NTM1JnAsKHYmPTE1KSYmKGM8diYmKHUrPUJbaSsrXTw8YyxjKz04KSxrKz11JigxPDx2KS0xLHU+Pj49dixjLT12KSxjPDE1JiYodSs9QltpKytdPDxjLGMrPTgsdSs9QltpKytdPDxjLGMrPTgpLHA9Z1t1JnddO2E6Zm9yKDs7KXtpZih1Pj4+PXY9cD4+PjI0LGMtPXYsISgxNiYodj1wPj4+MTYmMjU1KSkpe2lmKDA9PSg2NCZ2KSl7cD1nWyg2NTUzNSZwKSsodSYoMTw8diktMSldO2NvbnRpbnVlIGF9dC5tc2c9ImludmFsaWQgZGlzdGFuY2UgY29kZSIsYS5tb2RlPTMwO2JyZWFrIHR9aWYoeT02NTUzNSZwLGM8KHYmPTE1KSYmKHUrPUJbaSsrXTw8YywoYys9OCk8diYmKHUrPUJbaSsrXTw8YyxjKz04KSksbDwoeSs9dSYoMTw8diktMSkpe3QubXNnPSJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayIsYS5tb2RlPTMwO2JyZWFrIHR9aWYodT4+Pj12LGMtPXYsKHY9ci1zKTx5KXtpZihkPCh2PXktdikmJmEuc2FuZSl7dC5tc2c9ImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrIixhLm1vZGU9MzA7YnJlYWsgdH1pZih6PV8sKHg9MCk9PT1mKXtpZih4Kz1oLXYsdjxrKXtmb3Ioay09djtTW3IrK109X1t4KytdLC0tdjspO3g9ci15LHo9U319ZWxzZSBpZihmPHYpe2lmKHgrPWgrZi12LCh2LT1mKTxrKXtmb3Ioay09djtTW3IrK109X1t4KytdLC0tdjspO2lmKHg9MCxmPGspe2ZvcihrLT12PWY7U1tyKytdPV9beCsrXSwtLXY7KTt4PXIteSx6PVN9fX1lbHNlIGlmKHgrPWYtdix2PGspe2ZvcihrLT12O1NbcisrXT1fW3grK10sLS12Oyk7eD1yLXksej1TfWZvcig7MjxrOylTW3IrK109elt4KytdLFNbcisrXT16W3grK10sU1tyKytdPXpbeCsrXSxrLT0zO2smJihTW3IrK109elt4KytdLDE8ayYmKFNbcisrXT16W3grK10pKX1lbHNle2Zvcih4PXIteTtTW3IrK109U1t4KytdLFNbcisrXT1TW3grK10sU1tyKytdPVNbeCsrXSwyPChrLT0zKTspO2smJihTW3IrK109U1t4KytdLDE8ayYmKFNbcisrXT1TW3grK10pKX1icmVha319YnJlYWt9fXdoaWxlKGk8biYmcjxvKTtpLT1rPWM+PjMsdSY9KDE8PChjLT1rPDwzKSktMSx0Lm5leHRfaW49aSx0Lm5leHRfb3V0PXIsdC5hdmFpbF9pbj1pPG4/bi1pKzU6NS0oaS1uKSx0LmF2YWlsX291dD1yPG8/by1yKzI1NzoyNTctKHItbyksYS5ob2xkPXUsYS5iaXRzPWN9fSx7fV0sMTE6W2Z1bmN0aW9uKHQsZSxhKXsidXNlIHN0cmljdCI7dmFyIFo9dCgiLi4vdXRpbHMvY29tbW9uIiksUj10KCIuL2FkbGVyMzIiKSxDPXQoIi4vY3JjMzIiKSxOPXQoIi4vaW5mZmFzdCIpLE89dCgiLi9pbmZ0cmVlcyIpLEQ9MSxJPTIsVT0wLFQ9LTIsRj0xLGk9ODUyLG49NTkyO2Z1bmN0aW9uIEwodCl7cmV0dXJuKHQ+Pj4yNCYyNTUpKyh0Pj4+OCY2NTI4MCkrKCg2NTI4MCZ0KTw8OCkrKCgyNTUmdCk8PDI0KX1mdW5jdGlvbiByKCl7dGhpcy5tb2RlPTAsdGhpcy5sYXN0PSExLHRoaXMud3JhcD0wLHRoaXMuaGF2ZWRpY3Q9ITEsdGhpcy5mbGFncz0wLHRoaXMuZG1heD0wLHRoaXMuY2hlY2s9MCx0aGlzLnRvdGFsPTAsdGhpcy5oZWFkPW51bGwsdGhpcy53Yml0cz0wLHRoaXMud3NpemU9MCx0aGlzLndoYXZlPTAsdGhpcy53bmV4dD0wLHRoaXMud2luZG93PW51bGwsdGhpcy5ob2xkPTAsdGhpcy5iaXRzPTAsdGhpcy5sZW5ndGg9MCx0aGlzLm9mZnNldD0wLHRoaXMuZXh0cmE9MCx0aGlzLmxlbmNvZGU9bnVsbCx0aGlzLmRpc3Rjb2RlPW51bGwsdGhpcy5sZW5iaXRzPTAsdGhpcy5kaXN0Yml0cz0wLHRoaXMubmNvZGU9MCx0aGlzLm5sZW49MCx0aGlzLm5kaXN0PTAsdGhpcy5oYXZlPTAsdGhpcy5uZXh0PW51bGwsdGhpcy5sZW5zPW5ldyBaLkJ1ZjE2KDMyMCksdGhpcy53b3JrPW5ldyBaLkJ1ZjE2KDI4OCksdGhpcy5sZW5keW49bnVsbCx0aGlzLmRpc3RkeW49bnVsbCx0aGlzLnNhbmU9MCx0aGlzLmJhY2s9MCx0aGlzLndhcz0wfWZ1bmN0aW9uIHModCl7dmFyIGU7cmV0dXJuIHQmJnQuc3RhdGU/KGU9dC5zdGF0ZSx0LnRvdGFsX2luPXQudG90YWxfb3V0PWUudG90YWw9MCx0Lm1zZz0iIixlLndyYXAmJih0LmFkbGVyPTEmZS53cmFwKSxlLm1vZGU9RixlLmxhc3Q9MCxlLmhhdmVkaWN0PTAsZS5kbWF4PTMyNzY4LGUuaGVhZD1udWxsLGUuaG9sZD0wLGUuYml0cz0wLGUubGVuY29kZT1lLmxlbmR5bj1uZXcgWi5CdWYzMihpKSxlLmRpc3Rjb2RlPWUuZGlzdGR5bj1uZXcgWi5CdWYzMihuKSxlLnNhbmU9MSxlLmJhY2s9LTEsVSk6VH1mdW5jdGlvbiBvKHQpe3ZhciBlO3JldHVybiB0JiZ0LnN0YXRlPygoZT10LnN0YXRlKS53c2l6ZT0wLGUud2hhdmU9MCxlLnduZXh0PTAscyh0KSk6VH1mdW5jdGlvbiBsKHQsZSl7dmFyIGEsaTtyZXR1cm4gdCYmdC5zdGF0ZT8oaT10LnN0YXRlLGU8MD8oYT0wLGU9LWUpOihhPTErKGU+PjQpLGU8NDgmJihlJj0xNSkpLGUmJihlPDh8fDE1PGUpP1Q6KG51bGwhPT1pLndpbmRvdyYmaS53Yml0cyE9PWUmJihpLndpbmRvdz1udWxsKSxpLndyYXA9YSxpLndiaXRzPWUsbyh0KSkpOlR9ZnVuY3Rpb24gaCh0LGUpe3ZhciBhLGk7cmV0dXJuIHQ/KGk9bmV3IHIsKHQuc3RhdGU9aSkud2luZG93PW51bGwsKGE9bCh0LGUpKSE9PVUmJih0LnN0YXRlPW51bGwpLGEpOlR9dmFyIGQsZixfPSEwO2Z1bmN0aW9uIEgodCl7aWYoXyl7dmFyIGU7Zm9yKGQ9bmV3IFouQnVmMzIoNTEyKSxmPW5ldyBaLkJ1ZjMyKDMyKSxlPTA7ZTwxNDQ7KXQubGVuc1tlKytdPTg7Zm9yKDtlPDI1NjspdC5sZW5zW2UrK109OTtmb3IoO2U8MjgwOyl0LmxlbnNbZSsrXT03O2Zvcig7ZTwyODg7KXQubGVuc1tlKytdPTg7Zm9yKE8oRCx0LmxlbnMsMCwyODgsZCwwLHQud29yayx7Yml0czo5fSksZT0wO2U8MzI7KXQubGVuc1tlKytdPTU7TyhJLHQubGVucywwLDMyLGYsMCx0Lndvcmsse2JpdHM6NX0pLF89ITF9dC5sZW5jb2RlPWQsdC5sZW5iaXRzPTksdC5kaXN0Y29kZT1mLHQuZGlzdGJpdHM9NX1mdW5jdGlvbiBqKHQsZSxhLGkpe3ZhciBuLHI9dC5zdGF0ZTtyZXR1cm4gbnVsbD09PXIud2luZG93JiYoci53c2l6ZT0xPDxyLndiaXRzLHIud25leHQ9MCxyLndoYXZlPTAsci53aW5kb3c9bmV3IFouQnVmOChyLndzaXplKSksaT49ci53c2l6ZT8oWi5hcnJheVNldChyLndpbmRvdyxlLGEtci53c2l6ZSxyLndzaXplLDApLHIud25leHQ9MCxyLndoYXZlPXIud3NpemUpOihpPChuPXIud3NpemUtci53bmV4dCkmJihuPWkpLFouYXJyYXlTZXQoci53aW5kb3csZSxhLWksbixyLnduZXh0KSwoaS09bik/KFouYXJyYXlTZXQoci53aW5kb3csZSxhLWksaSwwKSxyLnduZXh0PWksci53aGF2ZT1yLndzaXplKTooci53bmV4dCs9bixyLnduZXh0PT09ci53c2l6ZSYmKHIud25leHQ9MCksci53aGF2ZTxyLndzaXplJiYoci53aGF2ZSs9bikpKSwwfWEuaW5mbGF0ZVJlc2V0PW8sYS5pbmZsYXRlUmVzZXQyPWwsYS5pbmZsYXRlUmVzZXRLZWVwPXMsYS5pbmZsYXRlSW5pdD1mdW5jdGlvbih0KXtyZXR1cm4gaCh0LDE1KX0sYS5pbmZsYXRlSW5pdDI9aCxhLmluZmxhdGU9ZnVuY3Rpb24odCxlKXt2YXIgYSxpLG4scixzLG8sbCxoLGQsZixfLHUsYyxiLGcsbSx3LHAsdixrLHkseCx6LEIsUz0wLEU9bmV3IFouQnVmOCg0KSxBPVsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XTtpZighdHx8IXQuc3RhdGV8fCF0Lm91dHB1dHx8IXQuaW5wdXQmJjAhPT10LmF2YWlsX2luKXJldHVybiBUOzEyPT09KGE9dC5zdGF0ZSkubW9kZSYmKGEubW9kZT0xMykscz10Lm5leHRfb3V0LG49dC5vdXRwdXQsbD10LmF2YWlsX291dCxyPXQubmV4dF9pbixpPXQuaW5wdXQsbz10LmF2YWlsX2luLGg9YS5ob2xkLGQ9YS5iaXRzLGY9byxfPWwseD1VO3Q6Zm9yKDs7KXN3aXRjaChhLm1vZGUpe2Nhc2UgRjppZigwPT09YS53cmFwKXthLm1vZGU9MTM7YnJlYWt9Zm9yKDtkPDE2Oyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9aWYoMiZhLndyYXAmJjM1NjE1PT09aCl7RVthLmNoZWNrPTBdPTI1NSZoLEVbMV09aD4+PjgmMjU1LGEuY2hlY2s9QyhhLmNoZWNrLEUsMiwwKSxkPWg9MCxhLm1vZGU9MjticmVha31pZihhLmZsYWdzPTAsYS5oZWFkJiYoYS5oZWFkLmRvbmU9ITEpLCEoMSZhLndyYXApfHwoKCgyNTUmaCk8PDgpKyhoPj44KSklMzEpe3QubXNnPSJpbmNvcnJlY3QgaGVhZGVyIGNoZWNrIixhLm1vZGU9MzA7YnJlYWt9aWYoOCE9KDE1JmgpKXt0Lm1zZz0idW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QiLGEubW9kZT0zMDticmVha31pZihkLT00LHk9OCsoMTUmKGg+Pj49NCkpLDA9PT1hLndiaXRzKWEud2JpdHM9eTtlbHNlIGlmKHk+YS53Yml0cyl7dC5tc2c9ImludmFsaWQgd2luZG93IHNpemUiLGEubW9kZT0zMDticmVha31hLmRtYXg9MTw8eSx0LmFkbGVyPWEuY2hlY2s9MSxhLm1vZGU9NTEyJmg/MTA6MTIsZD1oPTA7YnJlYWs7Y2FzZSAyOmZvcig7ZDwxNjspe2lmKDA9PT1vKWJyZWFrIHQ7by0tLGgrPWlbcisrXTw8ZCxkKz04fWlmKGEuZmxhZ3M9aCw4IT0oMjU1JmEuZmxhZ3MpKXt0Lm1zZz0idW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QiLGEubW9kZT0zMDticmVha31pZig1NzM0NCZhLmZsYWdzKXt0Lm1zZz0idW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0IixhLm1vZGU9MzA7YnJlYWt9YS5oZWFkJiYoYS5oZWFkLnRleHQ9aD4+OCYxKSw1MTImYS5mbGFncyYmKEVbMF09MjU1JmgsRVsxXT1oPj4+OCYyNTUsYS5jaGVjaz1DKGEuY2hlY2ssRSwyLDApKSxkPWg9MCxhLm1vZGU9MztjYXNlIDM6Zm9yKDtkPDMyOyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9YS5oZWFkJiYoYS5oZWFkLnRpbWU9aCksNTEyJmEuZmxhZ3MmJihFWzBdPTI1NSZoLEVbMV09aD4+PjgmMjU1LEVbMl09aD4+PjE2JjI1NSxFWzNdPWg+Pj4yNCYyNTUsYS5jaGVjaz1DKGEuY2hlY2ssRSw0LDApKSxkPWg9MCxhLm1vZGU9NDtjYXNlIDQ6Zm9yKDtkPDE2Oyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9YS5oZWFkJiYoYS5oZWFkLnhmbGFncz0yNTUmaCxhLmhlYWQub3M9aD4+OCksNTEyJmEuZmxhZ3MmJihFWzBdPTI1NSZoLEVbMV09aD4+PjgmMjU1LGEuY2hlY2s9QyhhLmNoZWNrLEUsMiwwKSksZD1oPTAsYS5tb2RlPTU7Y2FzZSA1OmlmKDEwMjQmYS5mbGFncyl7Zm9yKDtkPDE2Oyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9YS5sZW5ndGg9aCxhLmhlYWQmJihhLmhlYWQuZXh0cmFfbGVuPWgpLDUxMiZhLmZsYWdzJiYoRVswXT0yNTUmaCxFWzFdPWg+Pj44JjI1NSxhLmNoZWNrPUMoYS5jaGVjayxFLDIsMCkpLGQ9aD0wfWVsc2UgYS5oZWFkJiYoYS5oZWFkLmV4dHJhPW51bGwpO2EubW9kZT02O2Nhc2UgNjppZigxMDI0JmEuZmxhZ3MmJihvPCh1PWEubGVuZ3RoKSYmKHU9byksdSYmKGEuaGVhZCYmKHk9YS5oZWFkLmV4dHJhX2xlbi1hLmxlbmd0aCxhLmhlYWQuZXh0cmF8fChhLmhlYWQuZXh0cmE9bmV3IEFycmF5KGEuaGVhZC5leHRyYV9sZW4pKSxaLmFycmF5U2V0KGEuaGVhZC5leHRyYSxpLHIsdSx5KSksNTEyJmEuZmxhZ3MmJihhLmNoZWNrPUMoYS5jaGVjayxpLHUscikpLG8tPXUscis9dSxhLmxlbmd0aC09dSksYS5sZW5ndGgpKWJyZWFrIHQ7YS5sZW5ndGg9MCxhLm1vZGU9NztjYXNlIDc6aWYoMjA0OCZhLmZsYWdzKXtpZigwPT09bylicmVhayB0O2Zvcih1PTA7eT1pW3IrdSsrXSxhLmhlYWQmJnkmJmEubGVuZ3RoPDY1NTM2JiYoYS5oZWFkLm5hbWUrPVN0cmluZy5mcm9tQ2hhckNvZGUoeSkpLHkmJnU8bzspO2lmKDUxMiZhLmZsYWdzJiYoYS5jaGVjaz1DKGEuY2hlY2ssaSx1LHIpKSxvLT11LHIrPXUseSlicmVhayB0fWVsc2UgYS5oZWFkJiYoYS5oZWFkLm5hbWU9bnVsbCk7YS5sZW5ndGg9MCxhLm1vZGU9ODtjYXNlIDg6aWYoNDA5NiZhLmZsYWdzKXtpZigwPT09bylicmVhayB0O2Zvcih1PTA7eT1pW3IrdSsrXSxhLmhlYWQmJnkmJmEubGVuZ3RoPDY1NTM2JiYoYS5oZWFkLmNvbW1lbnQrPVN0cmluZy5mcm9tQ2hhckNvZGUoeSkpLHkmJnU8bzspO2lmKDUxMiZhLmZsYWdzJiYoYS5jaGVjaz1DKGEuY2hlY2ssaSx1LHIpKSxvLT11LHIrPXUseSlicmVhayB0fWVsc2UgYS5oZWFkJiYoYS5oZWFkLmNvbW1lbnQ9bnVsbCk7YS5tb2RlPTk7Y2FzZSA5OmlmKDUxMiZhLmZsYWdzKXtmb3IoO2Q8MTY7KXtpZigwPT09bylicmVhayB0O28tLSxoKz1pW3IrK108PGQsZCs9OH1pZihoIT09KDY1NTM1JmEuY2hlY2spKXt0Lm1zZz0iaGVhZGVyIGNyYyBtaXNtYXRjaCIsYS5tb2RlPTMwO2JyZWFrfWQ9aD0wfWEuaGVhZCYmKGEuaGVhZC5oY3JjPWEuZmxhZ3M+PjkmMSxhLmhlYWQuZG9uZT0hMCksdC5hZGxlcj1hLmNoZWNrPTAsYS5tb2RlPTEyO2JyZWFrO2Nhc2UgMTA6Zm9yKDtkPDMyOyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9dC5hZGxlcj1hLmNoZWNrPUwoaCksZD1oPTAsYS5tb2RlPTExO2Nhc2UgMTE6aWYoMD09PWEuaGF2ZWRpY3QpcmV0dXJuIHQubmV4dF9vdXQ9cyx0LmF2YWlsX291dD1sLHQubmV4dF9pbj1yLHQuYXZhaWxfaW49byxhLmhvbGQ9aCxhLmJpdHM9ZCwyO3QuYWRsZXI9YS5jaGVjaz0xLGEubW9kZT0xMjtjYXNlIDEyOmlmKDU9PT1lfHw2PT09ZSlicmVhayB0O2Nhc2UgMTM6aWYoYS5sYXN0KXtoPj4+PTcmZCxkLT03JmQsYS5tb2RlPTI3O2JyZWFrfWZvcig7ZDwzOyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9c3dpdGNoKGEubGFzdD0xJmgsZC09MSwzJihoPj4+PTEpKXtjYXNlIDA6YS5tb2RlPTE0O2JyZWFrO2Nhc2UgMTppZihIKGEpLGEubW9kZT0yMCw2IT09ZSlicmVhaztoPj4+PTIsZC09MjticmVhayB0O2Nhc2UgMjphLm1vZGU9MTc7YnJlYWs7Y2FzZSAzOnQubXNnPSJpbnZhbGlkIGJsb2NrIHR5cGUiLGEubW9kZT0zMH1oPj4+PTIsZC09MjticmVhaztjYXNlIDE0OmZvcihoPj4+PTcmZCxkLT03JmQ7ZDwzMjspe2lmKDA9PT1vKWJyZWFrIHQ7by0tLGgrPWlbcisrXTw8ZCxkKz04fWlmKCg2NTUzNSZoKSE9KGg+Pj4xNl42NTUzNSkpe3QubXNnPSJpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzIixhLm1vZGU9MzA7YnJlYWt9aWYoYS5sZW5ndGg9NjU1MzUmaCxkPWg9MCxhLm1vZGU9MTUsNj09PWUpYnJlYWsgdDtjYXNlIDE1OmEubW9kZT0xNjtjYXNlIDE2OmlmKHU9YS5sZW5ndGgpe2lmKG88dSYmKHU9byksbDx1JiYodT1sKSwwPT09dSlicmVhayB0O1ouYXJyYXlTZXQobixpLHIsdSxzKSxvLT11LHIrPXUsbC09dSxzKz11LGEubGVuZ3RoLT11O2JyZWFrfWEubW9kZT0xMjticmVhaztjYXNlIDE3OmZvcig7ZDwxNDspe2lmKDA9PT1vKWJyZWFrIHQ7by0tLGgrPWlbcisrXTw8ZCxkKz04fWlmKGEubmxlbj0yNTcrKDMxJmgpLGg+Pj49NSxkLT01LGEubmRpc3Q9MSsoMzEmaCksaD4+Pj01LGQtPTUsYS5uY29kZT00KygxNSZoKSxoPj4+PTQsZC09NCwyODY8YS5ubGVufHwzMDxhLm5kaXN0KXt0Lm1zZz0idG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHMiLGEubW9kZT0zMDticmVha31hLmhhdmU9MCxhLm1vZGU9MTg7Y2FzZSAxODpmb3IoO2EuaGF2ZTxhLm5jb2RlOyl7Zm9yKDtkPDM7KXtpZigwPT09bylicmVhayB0O28tLSxoKz1pW3IrK108PGQsZCs9OH1hLmxlbnNbQVthLmhhdmUrK11dPTcmaCxoPj4+PTMsZC09M31mb3IoO2EuaGF2ZTwxOTspYS5sZW5zW0FbYS5oYXZlKytdXT0wO2lmKGEubGVuY29kZT1hLmxlbmR5bixhLmxlbmJpdHM9Nyx6PXtiaXRzOmEubGVuYml0c30seD1PKDAsYS5sZW5zLDAsMTksYS5sZW5jb2RlLDAsYS53b3JrLHopLGEubGVuYml0cz16LmJpdHMseCl7dC5tc2c9ImludmFsaWQgY29kZSBsZW5ndGhzIHNldCIsYS5tb2RlPTMwO2JyZWFrfWEuaGF2ZT0wLGEubW9kZT0xOTtjYXNlIDE5OmZvcig7YS5oYXZlPGEubmxlbithLm5kaXN0Oyl7Zm9yKDttPShTPWEubGVuY29kZVtoJigxPDxhLmxlbmJpdHMpLTFdKT4+PjE2JjI1NSx3PTY1NTM1JlMsISgoZz1TPj4+MjQpPD1kKTspe2lmKDA9PT1vKWJyZWFrIHQ7by0tLGgrPWlbcisrXTw8ZCxkKz04fWlmKHc8MTYpaD4+Pj1nLGQtPWcsYS5sZW5zW2EuaGF2ZSsrXT13O2Vsc2V7aWYoMTY9PT13KXtmb3IoQj1nKzI7ZDxCOyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9aWYoaD4+Pj1nLGQtPWcsMD09PWEuaGF2ZSl7dC5tc2c9ImludmFsaWQgYml0IGxlbmd0aCByZXBlYXQiLGEubW9kZT0zMDticmVha315PWEubGVuc1thLmhhdmUtMV0sdT0zKygzJmgpLGg+Pj49MixkLT0yfWVsc2UgaWYoMTc9PT13KXtmb3IoQj1nKzM7ZDxCOyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9ZC09Zyx5PTAsdT0zKyg3JihoPj4+PWcpKSxoPj4+PTMsZC09M31lbHNle2ZvcihCPWcrNztkPEI7KXtpZigwPT09bylicmVhayB0O28tLSxoKz1pW3IrK108PGQsZCs9OH1kLT1nLHk9MCx1PTExKygxMjcmKGg+Pj49ZykpLGg+Pj49NyxkLT03fWlmKGEuaGF2ZSt1PmEubmxlbithLm5kaXN0KXt0Lm1zZz0iaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCIsYS5tb2RlPTMwO2JyZWFrfWZvcig7dS0tOylhLmxlbnNbYS5oYXZlKytdPXl9fWlmKDMwPT09YS5tb2RlKWJyZWFrO2lmKDA9PT1hLmxlbnNbMjU2XSl7dC5tc2c9ImludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9jayIsYS5tb2RlPTMwO2JyZWFrfWlmKGEubGVuYml0cz05LHo9e2JpdHM6YS5sZW5iaXRzfSx4PU8oRCxhLmxlbnMsMCxhLm5sZW4sYS5sZW5jb2RlLDAsYS53b3JrLHopLGEubGVuYml0cz16LmJpdHMseCl7dC5tc2c9ImludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCIsYS5tb2RlPTMwO2JyZWFrfWlmKGEuZGlzdGJpdHM9NixhLmRpc3Rjb2RlPWEuZGlzdGR5bix6PXtiaXRzOmEuZGlzdGJpdHN9LHg9TyhJLGEubGVucyxhLm5sZW4sYS5uZGlzdCxhLmRpc3Rjb2RlLDAsYS53b3JrLHopLGEuZGlzdGJpdHM9ei5iaXRzLHgpe3QubXNnPSJpbnZhbGlkIGRpc3RhbmNlcyBzZXQiLGEubW9kZT0zMDticmVha31pZihhLm1vZGU9MjAsNj09PWUpYnJlYWsgdDtjYXNlIDIwOmEubW9kZT0yMTtjYXNlIDIxOmlmKDY8PW8mJjI1ODw9bCl7dC5uZXh0X291dD1zLHQuYXZhaWxfb3V0PWwsdC5uZXh0X2luPXIsdC5hdmFpbF9pbj1vLGEuaG9sZD1oLGEuYml0cz1kLE4odCxfKSxzPXQubmV4dF9vdXQsbj10Lm91dHB1dCxsPXQuYXZhaWxfb3V0LHI9dC5uZXh0X2luLGk9dC5pbnB1dCxvPXQuYXZhaWxfaW4saD1hLmhvbGQsZD1hLmJpdHMsMTI9PT1hLm1vZGUmJihhLmJhY2s9LTEpO2JyZWFrfWZvcihhLmJhY2s9MDttPShTPWEubGVuY29kZVtoJigxPDxhLmxlbmJpdHMpLTFdKT4+PjE2JjI1NSx3PTY1NTM1JlMsISgoZz1TPj4+MjQpPD1kKTspe2lmKDA9PT1vKWJyZWFrIHQ7by0tLGgrPWlbcisrXTw8ZCxkKz04fWlmKG0mJjA9PSgyNDAmbSkpe2ZvcihwPWcsdj1tLGs9dzttPShTPWEubGVuY29kZVtrKygoaCYoMTw8cCt2KS0xKT4+cCldKT4+PjE2JjI1NSx3PTY1NTM1JlMsIShwKyhnPVM+Pj4yNCk8PWQpOyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9aD4+Pj1wLGQtPXAsYS5iYWNrKz1wfWlmKGg+Pj49ZyxkLT1nLGEuYmFjays9ZyxhLmxlbmd0aD13LDA9PT1tKXthLm1vZGU9MjY7YnJlYWt9aWYoMzImbSl7YS5iYWNrPS0xLGEubW9kZT0xMjticmVha31pZig2NCZtKXt0Lm1zZz0iaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlIixhLm1vZGU9MzA7YnJlYWt9YS5leHRyYT0xNSZtLGEubW9kZT0yMjtjYXNlIDIyOmlmKGEuZXh0cmEpe2ZvcihCPWEuZXh0cmE7ZDxCOyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9YS5sZW5ndGgrPWgmKDE8PGEuZXh0cmEpLTEsaD4+Pj1hLmV4dHJhLGQtPWEuZXh0cmEsYS5iYWNrKz1hLmV4dHJhfWEud2FzPWEubGVuZ3RoLGEubW9kZT0yMztjYXNlIDIzOmZvcig7bT0oUz1hLmRpc3Rjb2RlW2gmKDE8PGEuZGlzdGJpdHMpLTFdKT4+PjE2JjI1NSx3PTY1NTM1JlMsISgoZz1TPj4+MjQpPD1kKTspe2lmKDA9PT1vKWJyZWFrIHQ7by0tLGgrPWlbcisrXTw8ZCxkKz04fWlmKDA9PSgyNDAmbSkpe2ZvcihwPWcsdj1tLGs9dzttPShTPWEuZGlzdGNvZGVbaysoKGgmKDE8PHArdiktMSk+PnApXSk+Pj4xNiYyNTUsdz02NTUzNSZTLCEocCsoZz1TPj4+MjQpPD1kKTspe2lmKDA9PT1vKWJyZWFrIHQ7by0tLGgrPWlbcisrXTw8ZCxkKz04fWg+Pj49cCxkLT1wLGEuYmFjays9cH1pZihoPj4+PWcsZC09ZyxhLmJhY2srPWcsNjQmbSl7dC5tc2c9ImludmFsaWQgZGlzdGFuY2UgY29kZSIsYS5tb2RlPTMwO2JyZWFrfWEub2Zmc2V0PXcsYS5leHRyYT0xNSZtLGEubW9kZT0yNDtjYXNlIDI0OmlmKGEuZXh0cmEpe2ZvcihCPWEuZXh0cmE7ZDxCOyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9YS5vZmZzZXQrPWgmKDE8PGEuZXh0cmEpLTEsaD4+Pj1hLmV4dHJhLGQtPWEuZXh0cmEsYS5iYWNrKz1hLmV4dHJhfWlmKGEub2Zmc2V0PmEuZG1heCl7dC5tc2c9ImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrIixhLm1vZGU9MzA7YnJlYWt9YS5tb2RlPTI1O2Nhc2UgMjU6aWYoMD09PWwpYnJlYWsgdDtpZih1PV8tbCxhLm9mZnNldD51KXtpZigodT1hLm9mZnNldC11KT5hLndoYXZlJiZhLnNhbmUpe3QubXNnPSJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayIsYS5tb2RlPTMwO2JyZWFrfXU+YS53bmV4dD8odS09YS53bmV4dCxjPWEud3NpemUtdSk6Yz1hLnduZXh0LXUsdT5hLmxlbmd0aCYmKHU9YS5sZW5ndGgpLGI9YS53aW5kb3d9ZWxzZSBiPW4sYz1zLWEub2Zmc2V0LHU9YS5sZW5ndGg7Zm9yKGw8dSYmKHU9bCksbC09dSxhLmxlbmd0aC09dTtuW3MrK109YltjKytdLC0tdTspOzA9PT1hLmxlbmd0aCYmKGEubW9kZT0yMSk7YnJlYWs7Y2FzZSAyNjppZigwPT09bClicmVhayB0O25bcysrXT1hLmxlbmd0aCxsLS0sYS5tb2RlPTIxO2JyZWFrO2Nhc2UgMjc6aWYoYS53cmFwKXtmb3IoO2Q8MzI7KXtpZigwPT09bylicmVhayB0O28tLSxofD1pW3IrK108PGQsZCs9OH1pZihfLT1sLHQudG90YWxfb3V0Kz1fLGEudG90YWwrPV8sXyYmKHQuYWRsZXI9YS5jaGVjaz1hLmZsYWdzP0MoYS5jaGVjayxuLF8scy1fKTpSKGEuY2hlY2ssbixfLHMtXykpLF89bCwoYS5mbGFncz9oOkwoaCkpIT09YS5jaGVjayl7dC5tc2c9ImluY29ycmVjdCBkYXRhIGNoZWNrIixhLm1vZGU9MzA7YnJlYWt9ZD1oPTB9YS5tb2RlPTI4O2Nhc2UgMjg6aWYoYS53cmFwJiZhLmZsYWdzKXtmb3IoO2Q8MzI7KXtpZigwPT09bylicmVhayB0O28tLSxoKz1pW3IrK108PGQsZCs9OH1pZihoIT09KDQyOTQ5NjcyOTUmYS50b3RhbCkpe3QubXNnPSJpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrIixhLm1vZGU9MzA7YnJlYWt9ZD1oPTB9YS5tb2RlPTI5O2Nhc2UgMjk6eD0xO2JyZWFrIHQ7Y2FzZSAzMDp4PS0zO2JyZWFrIHQ7Y2FzZSAzMTpyZXR1cm4tNDtjYXNlIDMyOmRlZmF1bHQ6cmV0dXJuIFR9cmV0dXJuIHQubmV4dF9vdXQ9cyx0LmF2YWlsX291dD1sLHQubmV4dF9pbj1yLHQuYXZhaWxfaW49byxhLmhvbGQ9aCxhLmJpdHM9ZCwoYS53c2l6ZXx8XyE9PXQuYXZhaWxfb3V0JiZhLm1vZGU8MzAmJihhLm1vZGU8Mjd8fDQhPT1lKSkmJmoodCx0Lm91dHB1dCx0Lm5leHRfb3V0LF8tdC5hdmFpbF9vdXQpPyhhLm1vZGU9MzEsLTQpOihmLT10LmF2YWlsX2luLF8tPXQuYXZhaWxfb3V0LHQudG90YWxfaW4rPWYsdC50b3RhbF9vdXQrPV8sYS50b3RhbCs9XyxhLndyYXAmJl8mJih0LmFkbGVyPWEuY2hlY2s9YS5mbGFncz9DKGEuY2hlY2ssbixfLHQubmV4dF9vdXQtXyk6UihhLmNoZWNrLG4sXyx0Lm5leHRfb3V0LV8pKSx0LmRhdGFfdHlwZT1hLmJpdHMrKGEubGFzdD82NDowKSsoMTI9PT1hLm1vZGU/MTI4OjApKygyMD09PWEubW9kZXx8MTU9PT1hLm1vZGU/MjU2OjApLCgwPT09ZiYmMD09PV98fDQ9PT1lKSYmeD09PVUmJih4PS01KSx4KX0sYS5pbmZsYXRlRW5kPWZ1bmN0aW9uKHQpe2lmKCF0fHwhdC5zdGF0ZSlyZXR1cm4gVDt2YXIgZT10LnN0YXRlO3JldHVybiBlLndpbmRvdyYmKGUud2luZG93PW51bGwpLHQuc3RhdGU9bnVsbCxVfSxhLmluZmxhdGVHZXRIZWFkZXI9ZnVuY3Rpb24odCxlKXt2YXIgYTtyZXR1cm4gdCYmdC5zdGF0ZT8wPT0oMiYoYT10LnN0YXRlKS53cmFwKT9UOigoYS5oZWFkPWUpLmRvbmU9ITEsVSk6VH0sYS5pbmZsYXRlU2V0RGljdGlvbmFyeT1mdW5jdGlvbih0LGUpe3ZhciBhLGk9ZS5sZW5ndGg7cmV0dXJuIHQmJnQuc3RhdGU/MCE9PShhPXQuc3RhdGUpLndyYXAmJjExIT09YS5tb2RlP1Q6MTE9PT1hLm1vZGUmJlIoMSxlLGksMCkhPT1hLmNoZWNrPy0zOmoodCxlLGksaSk/KGEubW9kZT0zMSwtNCk6KGEuaGF2ZWRpY3Q9MSxVKTpUfSxhLmluZmxhdGVJbmZvPSJwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpIn0seyIuLi91dGlscy9jb21tb24iOjMsIi4vYWRsZXIzMiI6NSwiLi9jcmMzMiI6NywiLi9pbmZmYXN0IjoxMCwiLi9pbmZ0cmVlcyI6MTJ9XSwxMjpbZnVuY3Rpb24odCxlLGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgRD10KCIuLi91dGlscy9jb21tb24iKSxJPVszLDQsNSw2LDcsOCw5LDEwLDExLDEzLDE1LDE3LDE5LDIzLDI3LDMxLDM1LDQzLDUxLDU5LDY3LDgzLDk5LDExNSwxMzEsMTYzLDE5NSwyMjcsMjU4LDAsMF0sVT1bMTYsMTYsMTYsMTYsMTYsMTYsMTYsMTYsMTcsMTcsMTcsMTcsMTgsMTgsMTgsMTgsMTksMTksMTksMTksMjAsMjAsMjAsMjAsMjEsMjEsMjEsMjEsMTYsNzIsNzhdLFQ9WzEsMiwzLDQsNSw3LDksMTMsMTcsMjUsMzMsNDksNjUsOTcsMTI5LDE5MywyNTcsMzg1LDUxMyw3NjksMTAyNSwxNTM3LDIwNDksMzA3Myw0MDk3LDYxNDUsODE5MywxMjI4OSwxNjM4NSwyNDU3NywwLDBdLEY9WzE2LDE2LDE2LDE2LDE3LDE3LDE4LDE4LDE5LDE5LDIwLDIwLDIxLDIxLDIyLDIyLDIzLDIzLDI0LDI0LDI1LDI1LDI2LDI2LDI3LDI3LDI4LDI4LDI5LDI5LDY0LDY0XTtlLmV4cG9ydHM9ZnVuY3Rpb24odCxlLGEsaSxuLHIscyxvKXt2YXIgbCxoLGQsZixfLHUsYyxiLGcsbT1vLmJpdHMsdz0wLHA9MCx2PTAsaz0wLHk9MCx4PTAsej0wLEI9MCxTPTAsRT0wLEE9bnVsbCxaPTAsUj1uZXcgRC5CdWYxNigxNiksQz1uZXcgRC5CdWYxNigxNiksTj1udWxsLE89MDtmb3Iodz0wO3c8PTE1O3crKylSW3ddPTA7Zm9yKHA9MDtwPGk7cCsrKVJbZVthK3BdXSsrO2Zvcih5PW0saz0xNTsxPD1rJiYwPT09UltrXTtrLS0pO2lmKGs8eSYmKHk9ayksMD09PWspcmV0dXJuIG5bcisrXT0yMDk3MTUyMCxuW3IrK109MjA5NzE1MjAsby5iaXRzPTEsMDtmb3Iodj0xO3Y8ayYmMD09PVJbdl07disrKTtmb3IoeTx2JiYoeT12KSx3PUI9MTt3PD0xNTt3KyspaWYoQjw8PTEsKEItPVJbd10pPDApcmV0dXJuLTE7aWYoMDxCJiYoMD09PXR8fDEhPT1rKSlyZXR1cm4tMTtmb3IoQ1sxXT0wLHc9MTt3PDE1O3crKylDW3crMV09Q1t3XStSW3ddO2ZvcihwPTA7cDxpO3ArKykwIT09ZVthK3BdJiYoc1tDW2VbYStwXV0rK109cCk7aWYoMD09PXQ/KEE9Tj1zLHU9MTkpOjE9PT10PyhBPUksWi09MjU3LE49VSxPLT0yNTcsdT0yNTYpOihBPVQsTj1GLHU9LTEpLHc9dixfPXIsej1wPUU9MCxkPS0xLGY9KFM9MTw8KHg9eSkpLTEsMT09PXQmJjg1MjxTfHwyPT09dCYmNTkyPFMpcmV0dXJuIDE7Zm9yKDs7KXtmb3IoYz13LXosc1twXTx1PyhiPTAsZz1zW3BdKTpzW3BdPnU/KGI9TltPK3NbcF1dLGc9QVtaK3NbcF1dKTooYj05NixnPTApLGw9MTw8dy16LHY9aD0xPDx4O25bXysoRT4+eikrKGgtPWwpXT1jPDwyNHxiPDwxNnxnfDAsMCE9PWg7KTtmb3IobD0xPDx3LTE7RSZsOylsPj49MTtpZigwIT09bD8oRSY9bC0xLEUrPWwpOkU9MCxwKyssMD09LS1SW3ddKXtpZih3PT09aylicmVhazt3PWVbYStzW3BdXX1pZih5PHcmJihFJmYpIT09ZCl7Zm9yKDA9PT16JiYoej15KSxfKz12LEI9MTw8KHg9dy16KTt4K3o8ayYmISgoQi09Ult4K3pdKTw9MCk7KXgrKyxCPDw9MTtpZihTKz0xPDx4LDE9PT10JiY4NTI8U3x8Mj09PXQmJjU5MjxTKXJldHVybiAxO25bZD1FJmZdPXk8PDI0fHg8PDE2fF8tcnwwfX1yZXR1cm4gMCE9PUUmJihuW18rRV09dy16PDwyNHw2NDw8MTZ8MCksby5iaXRzPXksMH19LHsiLi4vdXRpbHMvY29tbW9uIjozfV0sMTM6W2Z1bmN0aW9uKHQsZSxhKXsidXNlIHN0cmljdCI7ZS5leHBvcnRzPXsyOiJuZWVkIGRpY3Rpb25hcnkiLDE6InN0cmVhbSBlbmQiLDA6IiIsIi0xIjoiZmlsZSBlcnJvciIsIi0yIjoic3RyZWFtIGVycm9yIiwiLTMiOiJkYXRhIGVycm9yIiwiLTQiOiJpbnN1ZmZpY2llbnQgbWVtb3J5IiwiLTUiOiJidWZmZXIgZXJyb3IiLCItNiI6ImluY29tcGF0aWJsZSB2ZXJzaW9uIn19LHt9XSwxNDpbZnVuY3Rpb24odCxlLGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgbD10KCIuLi91dGlscy9jb21tb24iKSxvPTAsaD0xO2Z1bmN0aW9uIGkodCl7Zm9yKHZhciBlPXQubGVuZ3RoOzA8PS0tZTspdFtlXT0wfXZhciBkPTAscz0yOSxmPTI1NixfPWYrMStzLHU9MzAsYz0xOSxnPTIqXysxLG09MTUsbj0xNixiPTcsdz0yNTYscD0xNix2PTE3LGs9MTgseT1bMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXSx4PVswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzXSx6PVswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMyw3XSxCPVsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XSxTPW5ldyBBcnJheSgyKihfKzIpKTtpKFMpO3ZhciBFPW5ldyBBcnJheSgyKnUpO2koRSk7dmFyIEE9bmV3IEFycmF5KDUxMik7aShBKTt2YXIgWj1uZXcgQXJyYXkoMjU2KTtpKFopO3ZhciBSPW5ldyBBcnJheShzKTtpKFIpO3ZhciBDLE4sTyxEPW5ldyBBcnJheSh1KTtmdW5jdGlvbiBJKHQsZSxhLGksbil7dGhpcy5zdGF0aWNfdHJlZT10LHRoaXMuZXh0cmFfYml0cz1lLHRoaXMuZXh0cmFfYmFzZT1hLHRoaXMuZWxlbXM9aSx0aGlzLm1heF9sZW5ndGg9bix0aGlzLmhhc19zdHJlZT10JiZ0Lmxlbmd0aH1mdW5jdGlvbiByKHQsZSl7dGhpcy5keW5fdHJlZT10LHRoaXMubWF4X2NvZGU9MCx0aGlzLnN0YXRfZGVzYz1lfWZ1bmN0aW9uIFUodCl7cmV0dXJuIHQ8MjU2P0FbdF06QVsyNTYrKHQ+Pj43KV19ZnVuY3Rpb24gVCh0LGUpe3QucGVuZGluZ19idWZbdC5wZW5kaW5nKytdPTI1NSZlLHQucGVuZGluZ19idWZbdC5wZW5kaW5nKytdPWU+Pj44JjI1NX1mdW5jdGlvbiBGKHQsZSxhKXt0LmJpX3ZhbGlkPm4tYT8odC5iaV9idWZ8PWU8PHQuYmlfdmFsaWQmNjU1MzUsVCh0LHQuYmlfYnVmKSx0LmJpX2J1Zj1lPj5uLXQuYmlfdmFsaWQsdC5iaV92YWxpZCs9YS1uKToodC5iaV9idWZ8PWU8PHQuYmlfdmFsaWQmNjU1MzUsdC5iaV92YWxpZCs9YSl9ZnVuY3Rpb24gTCh0LGUsYSl7Rih0LGFbMiplXSxhWzIqZSsxXSl9ZnVuY3Rpb24gSCh0LGUpe2Zvcih2YXIgYT0wO2F8PTEmdCx0Pj4+PTEsYTw8PTEsMDwtLWU7KTtyZXR1cm4gYT4+PjF9ZnVuY3Rpb24gaih0LGUsYSl7dmFyIGksbixyPW5ldyBBcnJheShtKzEpLHM9MDtmb3IoaT0xO2k8PW07aSsrKXJbaV09cz1zK2FbaS0xXTw8MTtmb3Iobj0wO248PWU7bisrKXt2YXIgbz10WzIqbisxXTswIT09byYmKHRbMipuXT1IKHJbb10rKyxvKSl9fWZ1bmN0aW9uIEsodCl7dmFyIGU7Zm9yKGU9MDtlPF87ZSsrKXQuZHluX2x0cmVlWzIqZV09MDtmb3IoZT0wO2U8dTtlKyspdC5keW5fZHRyZWVbMiplXT0wO2ZvcihlPTA7ZTxjO2UrKyl0LmJsX3RyZWVbMiplXT0wO3QuZHluX2x0cmVlWzIqd109MSx0Lm9wdF9sZW49dC5zdGF0aWNfbGVuPTAsdC5sYXN0X2xpdD10Lm1hdGNoZXM9MH1mdW5jdGlvbiBNKHQpezg8dC5iaV92YWxpZD9UKHQsdC5iaV9idWYpOjA8dC5iaV92YWxpZCYmKHQucGVuZGluZ19idWZbdC5wZW5kaW5nKytdPXQuYmlfYnVmKSx0LmJpX2J1Zj0wLHQuYmlfdmFsaWQ9MH1mdW5jdGlvbiBQKHQsZSxhLGkpe3ZhciBuPTIqZSxyPTIqYTtyZXR1cm4gdFtuXTx0W3JdfHx0W25dPT09dFtyXSYmaVtlXTw9aVthXX1mdW5jdGlvbiBZKHQsZSxhKXtmb3IodmFyIGk9dC5oZWFwW2FdLG49YTw8MTtuPD10LmhlYXBfbGVuJiYobjx0LmhlYXBfbGVuJiZQKGUsdC5oZWFwW24rMV0sdC5oZWFwW25dLHQuZGVwdGgpJiZuKyssIVAoZSxpLHQuaGVhcFtuXSx0LmRlcHRoKSk7KXQuaGVhcFthXT10LmhlYXBbbl0sYT1uLG48PD0xO3QuaGVhcFthXT1pfWZ1bmN0aW9uIHEodCxlLGEpe3ZhciBpLG4scixzLG89MDtpZigwIT09dC5sYXN0X2xpdClmb3IoO2k9dC5wZW5kaW5nX2J1Zlt0LmRfYnVmKzIqb108PDh8dC5wZW5kaW5nX2J1Zlt0LmRfYnVmKzIqbysxXSxuPXQucGVuZGluZ19idWZbdC5sX2J1ZitvXSxvKyssMD09PWk/TCh0LG4sZSk6KEwodCwocj1aW25dKStmKzEsZSksMCE9PShzPXlbcl0pJiZGKHQsbi09UltyXSxzKSxMKHQscj1VKC0taSksYSksMCE9PShzPXhbcl0pJiZGKHQsaS09RFtyXSxzKSksbzx0Lmxhc3RfbGl0Oyk7TCh0LHcsZSl9ZnVuY3Rpb24gRyh0LGUpe3ZhciBhLGksbixyPWUuZHluX3RyZWUscz1lLnN0YXRfZGVzYy5zdGF0aWNfdHJlZSxvPWUuc3RhdF9kZXNjLmhhc19zdHJlZSxsPWUuc3RhdF9kZXNjLmVsZW1zLGg9LTE7Zm9yKHQuaGVhcF9sZW49MCx0LmhlYXBfbWF4PWcsYT0wO2E8bDthKyspMCE9PXJbMiphXT8odC5oZWFwWysrdC5oZWFwX2xlbl09aD1hLHQuZGVwdGhbYV09MCk6clsyKmErMV09MDtmb3IoO3QuaGVhcF9sZW48MjspclsyKihuPXQuaGVhcFsrK3QuaGVhcF9sZW5dPWg8Mj8rK2g6MCldPTEsdC5kZXB0aFtuXT0wLHQub3B0X2xlbi0tLG8mJih0LnN0YXRpY19sZW4tPXNbMipuKzFdKTtmb3IoZS5tYXhfY29kZT1oLGE9dC5oZWFwX2xlbj4+MTsxPD1hO2EtLSlZKHQscixhKTtmb3Iobj1sO2E9dC5oZWFwWzFdLHQuaGVhcFsxXT10LmhlYXBbdC5oZWFwX2xlbi0tXSxZKHQsciwxKSxpPXQuaGVhcFsxXSx0LmhlYXBbLS10LmhlYXBfbWF4XT1hLHQuaGVhcFstLXQuaGVhcF9tYXhdPWksclsyKm5dPXJbMiphXStyWzIqaV0sdC5kZXB0aFtuXT0odC5kZXB0aFthXT49dC5kZXB0aFtpXT90LmRlcHRoW2FdOnQuZGVwdGhbaV0pKzEsclsyKmErMV09clsyKmkrMV09bix0LmhlYXBbMV09bisrLFkodCxyLDEpLDI8PXQuaGVhcF9sZW47KTt0LmhlYXBbLS10LmhlYXBfbWF4XT10LmhlYXBbMV0sZnVuY3Rpb24odCxlKXt2YXIgYSxpLG4scixzLG8sbD1lLmR5bl90cmVlLGg9ZS5tYXhfY29kZSxkPWUuc3RhdF9kZXNjLnN0YXRpY190cmVlLGY9ZS5zdGF0X2Rlc2MuaGFzX3N0cmVlLF89ZS5zdGF0X2Rlc2MuZXh0cmFfYml0cyx1PWUuc3RhdF9kZXNjLmV4dHJhX2Jhc2UsYz1lLnN0YXRfZGVzYy5tYXhfbGVuZ3RoLGI9MDtmb3Iocj0wO3I8PW07cisrKXQuYmxfY291bnRbcl09MDtmb3IobFsyKnQuaGVhcFt0LmhlYXBfbWF4XSsxXT0wLGE9dC5oZWFwX21heCsxO2E8ZzthKyspYzwocj1sWzIqbFsyKihpPXQuaGVhcFthXSkrMV0rMV0rMSkmJihyPWMsYisrKSxsWzIqaSsxXT1yLGg8aXx8KHQuYmxfY291bnRbcl0rKyxzPTAsdTw9aSYmKHM9X1tpLXVdKSxvPWxbMippXSx0Lm9wdF9sZW4rPW8qKHIrcyksZiYmKHQuc3RhdGljX2xlbis9byooZFsyKmkrMV0rcykpKTtpZigwIT09Yil7ZG97Zm9yKHI9Yy0xOzA9PT10LmJsX2NvdW50W3JdOylyLS07dC5ibF9jb3VudFtyXS0tLHQuYmxfY291bnRbcisxXSs9Mix0LmJsX2NvdW50W2NdLS0sYi09Mn13aGlsZSgwPGIpO2ZvcihyPWM7MCE9PXI7ci0tKWZvcihpPXQuYmxfY291bnRbcl07MCE9PWk7KWg8KG49dC5oZWFwWy0tYV0pfHwobFsyKm4rMV0hPT1yJiYodC5vcHRfbGVuKz0oci1sWzIqbisxXSkqbFsyKm5dLGxbMipuKzFdPXIpLGktLSl9fSh0LGUpLGoocixoLHQuYmxfY291bnQpfWZ1bmN0aW9uIFgodCxlLGEpe3ZhciBpLG4scj0tMSxzPWVbMV0sbz0wLGw9NyxoPTQ7Zm9yKDA9PT1zJiYobD0xMzgsaD0zKSxlWzIqKGErMSkrMV09NjU1MzUsaT0wO2k8PWE7aSsrKW49cyxzPWVbMiooaSsxKSsxXSwrK288bCYmbj09PXN8fChvPGg/dC5ibF90cmVlWzIqbl0rPW86MCE9PW4/KG4hPT1yJiZ0LmJsX3RyZWVbMipuXSsrLHQuYmxfdHJlZVsyKnBdKyspOm88PTEwP3QuYmxfdHJlZVsyKnZdKys6dC5ibF90cmVlWzIqa10rKyxyPW4sKG89MCk9PT1zPyhsPTEzOCxoPTMpOm49PT1zPyhsPTYsaD0zKToobD03LGg9NCkpfWZ1bmN0aW9uIFcodCxlLGEpe3ZhciBpLG4scj0tMSxzPWVbMV0sbz0wLGw9NyxoPTQ7Zm9yKDA9PT1zJiYobD0xMzgsaD0zKSxpPTA7aTw9YTtpKyspaWYobj1zLHM9ZVsyKihpKzEpKzFdLCEoKytvPGwmJm49PT1zKSl7aWYobzxoKWZvcig7TCh0LG4sdC5ibF90cmVlKSwwIT0tLW87KTtlbHNlIDAhPT1uPyhuIT09ciYmKEwodCxuLHQuYmxfdHJlZSksby0tKSxMKHQscCx0LmJsX3RyZWUpLEYodCxvLTMsMikpOm88PTEwPyhMKHQsdix0LmJsX3RyZWUpLEYodCxvLTMsMykpOihMKHQsayx0LmJsX3RyZWUpLEYodCxvLTExLDcpKTtyPW4sKG89MCk9PT1zPyhsPTEzOCxoPTMpOm49PT1zPyhsPTYsaD0zKToobD03LGg9NCl9fWkoRCk7dmFyIEo9ITE7ZnVuY3Rpb24gUSh0LGUsYSxpKXt2YXIgbixyLHMsbztGKHQsKGQ8PDEpKyhpPzE6MCksMykscj1lLHM9YSxvPSEwLE0obj10KSxvJiYoVChuLHMpLFQobix+cykpLGwuYXJyYXlTZXQobi5wZW5kaW5nX2J1ZixuLndpbmRvdyxyLHMsbi5wZW5kaW5nKSxuLnBlbmRpbmcrPXN9YS5fdHJfaW5pdD1mdW5jdGlvbih0KXtKfHwoZnVuY3Rpb24oKXt2YXIgdCxlLGEsaSxuLHI9bmV3IEFycmF5KG0rMSk7Zm9yKGk9YT0wO2k8cy0xO2krKylmb3IoUltpXT1hLHQ9MDt0PDE8PHlbaV07dCsrKVpbYSsrXT1pO2ZvcihaW2EtMV09aSxpPW49MDtpPDE2O2krKylmb3IoRFtpXT1uLHQ9MDt0PDE8PHhbaV07dCsrKUFbbisrXT1pO2ZvcihuPj49NztpPHU7aSsrKWZvcihEW2ldPW48PDcsdD0wO3Q8MTw8eFtpXS03O3QrKylBWzI1NituKytdPWk7Zm9yKGU9MDtlPD1tO2UrKylyW2VdPTA7Zm9yKHQ9MDt0PD0xNDM7KVNbMip0KzFdPTgsdCsrLHJbOF0rKztmb3IoO3Q8PTI1NTspU1syKnQrMV09OSx0Kysscls5XSsrO2Zvcig7dDw9Mjc5OylTWzIqdCsxXT03LHQrKyxyWzddKys7Zm9yKDt0PD0yODc7KVNbMip0KzFdPTgsdCsrLHJbOF0rKztmb3IoaihTLF8rMSxyKSx0PTA7dDx1O3QrKylFWzIqdCsxXT01LEVbMip0XT1IKHQsNSk7Qz1uZXcgSShTLHksZisxLF8sbSksTj1uZXcgSShFLHgsMCx1LG0pLE89bmV3IEkobmV3IEFycmF5KDApLHosMCxjLGIpfSgpLEo9ITApLHQubF9kZXNjPW5ldyByKHQuZHluX2x0cmVlLEMpLHQuZF9kZXNjPW5ldyByKHQuZHluX2R0cmVlLE4pLHQuYmxfZGVzYz1uZXcgcih0LmJsX3RyZWUsTyksdC5iaV9idWY9MCx0LmJpX3ZhbGlkPTAsSyh0KX0sYS5fdHJfc3RvcmVkX2Jsb2NrPVEsYS5fdHJfZmx1c2hfYmxvY2s9ZnVuY3Rpb24odCxlLGEsaSl7dmFyIG4scixzPTA7MDx0LmxldmVsPygyPT09dC5zdHJtLmRhdGFfdHlwZSYmKHQuc3RybS5kYXRhX3R5cGU9ZnVuY3Rpb24odCl7dmFyIGUsYT00MDkzNjI0NDQ3O2ZvcihlPTA7ZTw9MzE7ZSsrLGE+Pj49MSlpZigxJmEmJjAhPT10LmR5bl9sdHJlZVsyKmVdKXJldHVybiBvO2lmKDAhPT10LmR5bl9sdHJlZVsxOF18fDAhPT10LmR5bl9sdHJlZVsyMF18fDAhPT10LmR5bl9sdHJlZVsyNl0pcmV0dXJuIGg7Zm9yKGU9MzI7ZTxmO2UrKylpZigwIT09dC5keW5fbHRyZWVbMiplXSlyZXR1cm4gaDtyZXR1cm4gb30odCkpLEcodCx0LmxfZGVzYyksRyh0LHQuZF9kZXNjKSxzPWZ1bmN0aW9uKHQpe3ZhciBlO2ZvcihYKHQsdC5keW5fbHRyZWUsdC5sX2Rlc2MubWF4X2NvZGUpLFgodCx0LmR5bl9kdHJlZSx0LmRfZGVzYy5tYXhfY29kZSksRyh0LHQuYmxfZGVzYyksZT1jLTE7Mzw9ZSYmMD09PXQuYmxfdHJlZVsyKkJbZV0rMV07ZS0tKTtyZXR1cm4gdC5vcHRfbGVuKz0zKihlKzEpKzUrNSs0LGV9KHQpLG49dC5vcHRfbGVuKzMrNz4+PjMsKHI9dC5zdGF0aWNfbGVuKzMrNz4+PjMpPD1uJiYobj1yKSk6bj1yPWErNSxhKzQ8PW4mJi0xIT09ZT9RKHQsZSxhLGkpOjQ9PT10LnN0cmF0ZWd5fHxyPT09bj8oRih0LDIrKGk/MTowKSwzKSxxKHQsUyxFKSk6KEYodCw0KyhpPzE6MCksMyksZnVuY3Rpb24odCxlLGEsaSl7dmFyIG47Zm9yKEYodCxlLTI1Nyw1KSxGKHQsYS0xLDUpLEYodCxpLTQsNCksbj0wO248aTtuKyspRih0LHQuYmxfdHJlZVsyKkJbbl0rMV0sMyk7Vyh0LHQuZHluX2x0cmVlLGUtMSksVyh0LHQuZHluX2R0cmVlLGEtMSl9KHQsdC5sX2Rlc2MubWF4X2NvZGUrMSx0LmRfZGVzYy5tYXhfY29kZSsxLHMrMSkscSh0LHQuZHluX2x0cmVlLHQuZHluX2R0cmVlKSksSyh0KSxpJiZNKHQpfSxhLl90cl90YWxseT1mdW5jdGlvbih0LGUsYSl7cmV0dXJuIHQucGVuZGluZ19idWZbdC5kX2J1ZisyKnQubGFzdF9saXRdPWU+Pj44JjI1NSx0LnBlbmRpbmdfYnVmW3QuZF9idWYrMip0Lmxhc3RfbGl0KzFdPTI1NSZlLHQucGVuZGluZ19idWZbdC5sX2J1Zit0Lmxhc3RfbGl0XT0yNTUmYSx0Lmxhc3RfbGl0KyssMD09PWU/dC5keW5fbHRyZWVbMiphXSsrOih0Lm1hdGNoZXMrKyxlLS0sdC5keW5fbHRyZWVbMiooWlthXStmKzEpXSsrLHQuZHluX2R0cmVlWzIqVShlKV0rKyksdC5sYXN0X2xpdD09PXQubGl0X2J1ZnNpemUtMX0sYS5fdHJfYWxpZ249ZnVuY3Rpb24odCl7dmFyIGU7Rih0LDIsMyksTCh0LHcsUyksMTY9PT0oZT10KS5iaV92YWxpZD8oVChlLGUuYmlfYnVmKSxlLmJpX2J1Zj0wLGUuYmlfdmFsaWQ9MCk6ODw9ZS5iaV92YWxpZCYmKGUucGVuZGluZ19idWZbZS5wZW5kaW5nKytdPTI1NSZlLmJpX2J1ZixlLmJpX2J1Zj4+PTgsZS5iaV92YWxpZC09OCl9fSx7Ii4uL3V0aWxzL2NvbW1vbiI6M31dLDE1OltmdW5jdGlvbih0LGUsYSl7InVzZSBzdHJpY3QiO2UuZXhwb3J0cz1mdW5jdGlvbigpe3RoaXMuaW5wdXQ9bnVsbCx0aGlzLm5leHRfaW49MCx0aGlzLmF2YWlsX2luPTAsdGhpcy50b3RhbF9pbj0wLHRoaXMub3V0cHV0PW51bGwsdGhpcy5uZXh0X291dD0wLHRoaXMuYXZhaWxfb3V0PTAsdGhpcy50b3RhbF9vdXQ9MCx0aGlzLm1zZz0iIix0aGlzLnN0YXRlPW51bGwsdGhpcy5kYXRhX3R5cGU9Mix0aGlzLmFkbGVyPTB9fSx7fV0sIi8iOltmdW5jdGlvbih0LGUsYSl7InVzZSBzdHJpY3QiO3ZhciBpPXt9OygwLHQoIi4vbGliL3V0aWxzL2NvbW1vbiIpLmFzc2lnbikoaSx0KCIuL2xpYi9kZWZsYXRlIiksdCgiLi9saWIvaW5mbGF0ZSIpLHQoIi4vbGliL3psaWIvY29uc3RhbnRzIikpLGUuZXhwb3J0cz1pfSx7Ii4vbGliL2RlZmxhdGUiOjEsIi4vbGliL2luZmxhdGUiOjIsIi4vbGliL3V0aWxzL2NvbW1vbiI6MywiLi9saWIvemxpYi9jb25zdGFudHMiOjZ9XX0se30sW10pKCIvIil9KTsKdmFyIEJhc2U2ND17X2tleVN0cjoiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0iLGVuY29kZTpmdW5jdGlvbihhLGIpe3ZhciBjPSIiLGQsZSxmLGcsayxsLG09MDtmb3IobnVsbCE9YiYmYnx8KGE9QmFzZTY0Ll91dGY4X2VuY29kZShhKSk7bTxhLmxlbmd0aDspZD1hLmNoYXJDb2RlQXQobSsrKSxlPWEuY2hhckNvZGVBdChtKyspLGY9YS5jaGFyQ29kZUF0KG0rKyksZz1kPj4yLGQ9KGQmMyk8PDR8ZT4+NCxrPShlJjE1KTw8MnxmPj42LGw9ZiY2Myxpc05hTihlKT9rPWw9NjQ6aXNOYU4oZikmJihsPTY0KSxjPWMrdGhpcy5fa2V5U3RyLmNoYXJBdChnKSt0aGlzLl9rZXlTdHIuY2hhckF0KGQpK3RoaXMuX2tleVN0ci5jaGFyQXQoaykrdGhpcy5fa2V5U3RyLmNoYXJBdChsKTtyZXR1cm4gY30sZGVjb2RlOmZ1bmN0aW9uKGEsYil7Yj1udWxsIT1iP2I6ITE7dmFyIGM9IiIsZCxlLGYsZyxrLGw9MDtmb3IoYT1hLnJlcGxhY2UoL1teQS1aYS16MC05XCtcL1w9XS9nLAoiIik7bDxhLmxlbmd0aDspZD10aGlzLl9rZXlTdHIuaW5kZXhPZihhLmNoYXJBdChsKyspKSxlPXRoaXMuX2tleVN0ci5pbmRleE9mKGEuY2hhckF0KGwrKykpLGc9dGhpcy5fa2V5U3RyLmluZGV4T2YoYS5jaGFyQXQobCsrKSksaz10aGlzLl9rZXlTdHIuaW5kZXhPZihhLmNoYXJBdChsKyspKSxkPWQ8PDJ8ZT4+NCxlPShlJjE1KTw8NHxnPj4yLGY9KGcmMyk8PDZ8ayxjKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGQpLDY0IT1nJiYoYys9U3RyaW5nLmZyb21DaGFyQ29kZShlKSksNjQhPWsmJihjKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGYpKTtifHwoYz1CYXNlNjQuX3V0ZjhfZGVjb2RlKGMpKTtyZXR1cm4gY30sX3V0ZjhfZW5jb2RlOmZ1bmN0aW9uKGEpe2E9YS5yZXBsYWNlKC9cclxuL2csIlxuIik7Zm9yKHZhciBiPSIiLGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGQ9YS5jaGFyQ29kZUF0KGMpOzEyOD5kP2IrPVN0cmluZy5mcm9tQ2hhckNvZGUoZCk6KDEyNzxkJiYyMDQ4PmQ/Yis9ClN0cmluZy5mcm9tQ2hhckNvZGUoZD4+NnwxOTIpOihiKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGQ+PjEyfDIyNCksYis9U3RyaW5nLmZyb21DaGFyQ29kZShkPj42JjYzfDEyOCkpLGIrPVN0cmluZy5mcm9tQ2hhckNvZGUoZCY2M3wxMjgpKX1yZXR1cm4gYn0sX3V0ZjhfZGVjb2RlOmZ1bmN0aW9uKGEpe3ZhciBiPSIiLGM9MCxkO2ZvcihjMT1jMj0wO2M8YS5sZW5ndGg7KWQ9YS5jaGFyQ29kZUF0KGMpLDEyOD5kPyhiKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGQpLGMrKyk6MTkxPGQmJjIyND5kPyhjMj1hLmNoYXJDb2RlQXQoYysxKSxiKz1TdHJpbmcuZnJvbUNoYXJDb2RlKChkJjMxKTw8NnxjMiY2MyksYys9Mik6KGMyPWEuY2hhckNvZGVBdChjKzEpLGMzPWEuY2hhckNvZGVBdChjKzIpLGIrPVN0cmluZy5mcm9tQ2hhckNvZGUoKGQmMTUpPDwxMnwoYzImNjMpPDw2fGMzJjYzKSxjKz0zKTtyZXR1cm4gYn19O3dpbmRvdy51cmxQYXJhbXM9d2luZG93LnVybFBhcmFtc3x8e307d2luZG93LmlzTG9jYWxTdG9yYWdlPXdpbmRvdy5pc0xvY2FsU3RvcmFnZXx8ITE7d2luZG93Lm14TG9hZFNldHRpbmdzPXdpbmRvdy5teExvYWRTZXR0aW5nc3x8IjEiIT11cmxQYXJhbXMuY29uZmlndXJlO3dpbmRvdy5pc1N2Z0Jyb3dzZXI9d2luZG93LmlzU3ZnQnJvd3Nlcnx8bnVsbD09bmF2aWdhdG9yLnVzZXJBZ2VudHx8MD5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIk1TSUUiKXx8OTw9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlO3dpbmRvdy5EUkFXSU9fQkFTRV9VUkw9d2luZG93LkRSQVdJT19CQVNFX1VSTHx8KC8uKlwuZHJhd1wuaW8kLy50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSk/d2luZG93LmxvY2F0aW9uLnByb3RvY29sKyIvLyIrd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lOiJodHRwczovL2FwcC5kaWFncmFtcy5uZXQiKTsKd2luZG93LkVYUE9SVF9VUkw9d2luZG93LkVYUE9SVF9VUkx8fCJodHRwczovL2V4cC5kcmF3LmlvL0ltYWdlRXhwb3J0NC9leHBvcnQiO3dpbmRvdy5QTEFOVF9VUkw9d2luZG93LlBMQU5UX1VSTHx8Imh0dHBzOi8vcGxhbnQtYXdzLmRpYWdyYW1zLm5ldCI7d2luZG93LkRSQVdfTUFUSF9VUkw9d2luZG93LkRSQVdfTUFUSF9VUkx8fHdpbmRvdy5EUkFXSU9fQkFTRV9VUkwrIi9tYXRoIjt3aW5kb3cuVlNEX0NPTlZFUlRfVVJMPXdpbmRvdy5WU0RfQ09OVkVSVF9VUkx8fCJodHRwczovL2NvbnZlcnQuZHJhdy5pby9Wc2RDb252ZXJ0ZXIvYXBpL2NvbnZlcnRlciI7d2luZG93LkVNRl9DT05WRVJUX1VSTD13aW5kb3cuRU1GX0NPTlZFUlRfVVJMfHwiaHR0cHM6Ly9jb252ZXJ0LmRyYXcuaW8vZW1mMnBuZy9jb252ZXJ0RU1GIjt3aW5kb3cuUkVBTFRJTUVfVVJMPXdpbmRvdy5SRUFMVElNRV9VUkx8fCJjYWNoZSI7CndpbmRvdy5EUkFXSU9fR0lUTEFCX1VSTD13aW5kb3cuRFJBV0lPX0dJVExBQl9VUkx8fCJodHRwczovL2dpdGxhYi5jb20iO3dpbmRvdy5EUkFXSU9fR0lUTEFCX0lEPXdpbmRvdy5EUkFXSU9fR0lUTEFCX0lEfHwiNWNkYzAxOGEzMmFjZGRmNmViYTM3NTkyZDkzNzQ5NDUyNDFlNjQ0YjgzNjhhZjg0NzQyMmQ3NGM4NzA5YmM0NCI7d2luZG93LlNBVkVfVVJMPXdpbmRvdy5TQVZFX1VSTHx8InNhdmUiO3dpbmRvdy5PUEVOX1VSTD13aW5kb3cuT1BFTl9VUkx8fCJpbXBvcnQiO3dpbmRvdy5QUk9YWV9VUkw9d2luZG93LlBST1hZX1VSTHx8InByb3h5Ijt3aW5kb3cuRFJBV0lPX1ZJRVdFUl9VUkw9d2luZG93LkRSQVdJT19WSUVXRVJfVVJMfHxudWxsO3dpbmRvdy5TSEFQRVNfUEFUSD13aW5kb3cuU0hBUEVTX1BBVEh8fCJzaGFwZXMiO3dpbmRvdy5HUkFQSF9JTUFHRV9QQVRIPXdpbmRvdy5HUkFQSF9JTUFHRV9QQVRIfHwiaW1nIjsKd2luZG93LklDT05TRUFSQ0hfUEFUSD13aW5kb3cuSUNPTlNFQVJDSF9QQVRIfHwoKG51bGwhPW5hdmlnYXRvci51c2VyQWdlbnQmJjA8PW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiTVNJRSIpfHx1cmxQYXJhbXMuZGV2KSYmImZpbGU6IiE9d2luZG93LmxvY2F0aW9uLnByb3RvY29sPyJpY29uU2VhcmNoIjp3aW5kb3cuRFJBV0lPX0JBU0VfVVJMKyIvaWNvblNlYXJjaCIpO3dpbmRvdy5URU1QTEFURV9QQVRIPXdpbmRvdy5URU1QTEFURV9QQVRIfHwidGVtcGxhdGVzIjt3aW5kb3cuTkVXX0RJQUdSQU1fQ0FUU19QQVRIPXdpbmRvdy5ORVdfRElBR1JBTV9DQVRTX1BBVEh8fCJuZXdEaWFncmFtQ2F0cyI7d2luZG93LlBMVUdJTlNfQkFTRV9QQVRIPXdpbmRvdy5QTFVHSU5TX0JBU0VfUEFUSHx8IiI7d2luZG93LlJFU09VUkNFU19QQVRIPXdpbmRvdy5SRVNPVVJDRVNfUEFUSHx8InJlc291cmNlcyI7CndpbmRvdy5SRVNPVVJDRV9CQVNFPXdpbmRvdy5SRVNPVVJDRV9CQVNFfHxSRVNPVVJDRVNfUEFUSCsiL2RpYSI7d2luZG93LkRSQVdJT19DT05GSUc9d2luZG93LkRSQVdJT19DT05GSUd8fG51bGw7d2luZG93Lm14TG9hZFJlc291cmNlcz13aW5kb3cubXhMb2FkUmVzb3VyY2VzfHwhMTt3aW5kb3cubXhMYW5ndWFnZT13aW5kb3cubXhMYW5ndWFnZXx8ZnVuY3Rpb24oKXt2YXIgYT11cmxQYXJhbXMubGFuZztpZihudWxsPT1hJiYidW5kZWZpbmVkIiE9dHlwZW9mIEpTT04mJmlzTG9jYWxTdG9yYWdlKXRyeXt2YXIgYj1sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgiLmRyYXdpby1jb25maWciKTtudWxsIT1iJiYoYT1KU09OLnBhcnNlKGIpLmxhbmd1YWdlfHxudWxsKX1jYXRjaChjKXtpc0xvY2FsU3RvcmFnZT0hMX1yZXR1cm4gYX0oKTsKd2luZG93Lm14TGFuZ3VhZ2VNYXA9d2luZG93Lm14TGFuZ3VhZ2VNYXB8fHtpMThuOiIiLGlkOiJCYWhhc2EgSW5kb25lc2lhIixtczoiQmFoYXNhIE1lbGF5dSIsYnM6IkJvc2Fuc2tpIixiZzoiQnVsZ2FyaWFuIixjYToiQ2F0YWzDoCIsY3M6IsSMZcWhdGluYSIsZGE6IkRhbnNrIixkZToiRGV1dHNjaCIsZXQ6IkVlc3RpIixlbjoiRW5nbGlzaCIsZXM6IkVzcGHDsW9sIixldToiRXVza2FkaSIsZmlsOiJGaWxpcGlubyIsZnI6IkZyYW7Dp2FpcyIsZ2w6IkdhbGVnbyIsaXQ6Ikl0YWxpYW5vIixodToiTWFneWFyIixubDoiTmVkZXJsYW5kcyIsbm86Ik5vcnNrIixwbDoiUG9sc2tpIiwicHQtYnIiOiJQb3J0dWd1w6pzIChCcmFzaWwpIixwdDoiUG9ydHVndcOqcyAoUG9ydHVnYWwpIixybzoiUm9tw6JuxIMiLGZpOiJTdW9taSIsc3Y6IlN2ZW5za2EiLHZpOiJUaeG6v25nIFZp4buHdCIsdHI6IlTDvHJrw6dlIixlbDoizpXOu867zrfOvc65zrrOrCIscnU6ItCg0YPRgdGB0LrQuNC5Iixzcjoi0KHRgNC/0YHQutC4Iix1azoi0KPQutGA0LDRl9C90YHRjNC60LAiLApoZToi16LXkdeo15nXqiIsYXI6Itin2YTYudix2KjZitipIix0aDoi4LmE4LiX4LiiIixrbzoi7ZWc6rWt7Ja0IixqYToi5pel5pys6KqeIix6aDoi566A5L2T5Lit5paHIiwiemgtdHciOiLnuYHpq5TkuK3mlocifTsidW5kZWZpbmVkIj09PXR5cGVvZiB3aW5kb3cubXhCYXNlUGF0aCYmKHdpbmRvdy5teEJhc2VQYXRoPSJteGdyYXBoIik7aWYobnVsbD09d2luZG93Lm14TGFuZ3VhZ2VzKXt3aW5kb3cubXhMYW5ndWFnZXM9W107Zm9yKHZhciBsYW5nIGluIG14TGFuZ3VhZ2VNYXApImVuIiE9bGFuZyYmd2luZG93Lm14TGFuZ3VhZ2VzLnB1c2gobGFuZyl9CndpbmRvdy51aVRoZW1lPXdpbmRvdy51aVRoZW1lfHxmdW5jdGlvbigpe3ZhciBhPXVybFBhcmFtcy51aTtpZihudWxsPT1hJiYidW5kZWZpbmVkIiE9PXR5cGVvZiBKU09OJiZpc0xvY2FsU3RvcmFnZSl0cnl7dmFyIGI9bG9jYWxTdG9yYWdlLmdldEl0ZW0oIi5kcmF3aW8tY29uZmlnIik7bnVsbCE9YiYmKGE9SlNPTi5wYXJzZShiKS51aXx8bnVsbCl9Y2F0Y2goYyl7aXNMb2NhbFN0b3JhZ2U9ITF9dHJ5e251bGw9PWEmJjQxND49KHdpbmRvdy5pbm5lcldpZHRofHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGh8fGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGgpJiYoYT0ibWluIil9Y2F0Y2goYyl7fXJldHVybiBhfSgpO2Z1bmN0aW9uIHNldEN1cnJlbnRYbWwoYSxiKXtudWxsIT13aW5kb3cucGFyZW50JiZudWxsIT13aW5kb3cucGFyZW50Lm9wZW5GaWxlJiZ3aW5kb3cucGFyZW50Lm9wZW5GaWxlLnNldERhdGEoYSxiKX0KKGZ1bmN0aW9uKCl7aWYoInVuZGVmaW5lZCIhPT10eXBlb2YgSlNPTiYmaXNMb2NhbFN0b3JhZ2UpdHJ5e3ZhciBhPWxvY2FsU3RvcmFnZS5nZXRJdGVtKCIuZHJhd2lvLWNvbmZpZyIpLGI9ITA7bnVsbCE9YSYmKGI9SlNPTi5wYXJzZShhKS5zaG93U3RhcnRTY3JlZW4pOzA9PWImJih1cmxQYXJhbXMuc3BsYXNoPSIwIil9Y2F0Y2goZCl7fWE9dXJsUGFyYW1zWyJleHBvcnQiXTtudWxsIT1hJiYoYT1kZWNvZGVVUklDb21wb25lbnQoYSksImh0dHA6Ly8iIT1hLnN1YnN0cmluZygwLDcpJiYiaHR0cHM6Ly8iIT1hLnN1YnN0cmluZygwLDgpJiYoYT0iaHR0cDovLyIrYSksRVhQT1JUX1VSTD1hKTthPXVybFBhcmFtcy5naXRsYWI7bnVsbCE9YSYmKGE9ZGVjb2RlVVJJQ29tcG9uZW50KGEpLCJodHRwOi8vIiE9YS5zdWJzdHJpbmcoMCw3KSYmImh0dHBzOi8vIiE9YS5zdWJzdHJpbmcoMCw4KSYmKGE9Imh0dHA6Ly8iK2EpLERSQVdJT19HSVRMQUJfVVJMPWEpO2E9dXJsUGFyYW1zWyJnaXRsYWItaWQiXTsKbnVsbCE9YSYmKERSQVdJT19HSVRMQUJfSUQ9YSk7d2luZG93LkRSQVdJT19MT0dfVVJMPXdpbmRvdy5EUkFXSU9fTE9HX1VSTHx8IiI7YT13aW5kb3cubG9jYXRpb24uaG9zdDtpZigidGVzdC5kcmF3LmlvIiE9YSl7dmFyIGM9ImRpYWdyYW1zLm5ldCIsYj1hLmxlbmd0aC1jLmxlbmd0aCxjPWEubGFzdEluZGV4T2YoYyxiKTstMSE9PWMmJmM9PT1iP3dpbmRvdy5EUkFXSU9fTE9HX1VSTD0iaHR0cHM6Ly9sb2cuZGlhZ3JhbXMubmV0IjooYz0iZHJhdy5pbyIsYj1hLmxlbmd0aC1jLmxlbmd0aCxjPWEubGFzdEluZGV4T2YoYyxiKSwtMSE9PWMmJmM9PT1iJiYod2luZG93LkRSQVdJT19MT0dfVVJMPSJodHRwczovL2xvZy5kcmF3LmlvIikpfX0pKCk7CmlmKCIxIj09dXJsUGFyYW1zLm9mZmxpbmV8fCIxIj09dXJsUGFyYW1zLmRlbW98fCIxIj09dXJsUGFyYW1zLnN0ZWFsdGh8fCIxIj09dXJsUGFyYW1zLmxvY2FsKXVybFBhcmFtcy5waWNrZXI9IjAiLHVybFBhcmFtcy5nYXBpPSIwIix1cmxQYXJhbXMuZGI9IjAiLHVybFBhcmFtcy5vZD0iMCIsdXJsUGFyYW1zLmdoPSIwIix1cmxQYXJhbXMuZ2w9IjAiLHVybFBhcmFtcy50cj0iMCI7ImVtYmVkLmRpYWdyYW1zLm5ldCI9PXdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSYmKHVybFBhcmFtcy5lbWJlZD0iMSIpO2lmKCIxIj09dXJsUGFyYW1zLm9mZmxpbmV8fCIxIj09dXJsUGFyYW1zLmxvY2FsKXVybFBhcmFtcy5tYXRoPSIwIjsiMSI9PXVybFBhcmFtcy5saWdodGJveCYmKHVybFBhcmFtcy5jaHJvbWU9IjAiKTsKKG51bGw9PXdpbmRvdy5sb2NhdGlvbi5oYXNofHwxPj13aW5kb3cubG9jYXRpb24uaGFzaC5sZW5ndGgpJiZudWxsIT11cmxQYXJhbXMub3BlbiYmKHdpbmRvdy5sb2NhdGlvbi5oYXNoPXVybFBhcmFtcy5vcGVuKTt3aW5kb3cudXJsUGFyYW1zPXdpbmRvdy51cmxQYXJhbXN8fHt9O3dpbmRvdy5NQVhfUkVRVUVTVF9TSVpFPXdpbmRvdy5NQVhfUkVRVUVTVF9TSVpFfHwxMDQ4NTc2MDt3aW5kb3cuTUFYX0FSRUE9d2luZG93Lk1BWF9BUkVBfHwyMjVFNjt3aW5kb3cuRVhQT1JUX1VSTD13aW5kb3cuRVhQT1JUX1VSTHx8Ii9leHBvcnQiO3dpbmRvdy5TQVZFX1VSTD13aW5kb3cuU0FWRV9VUkx8fCIvc2F2ZSI7d2luZG93Lk9QRU5fVVJMPXdpbmRvdy5PUEVOX1VSTHx8Ii9vcGVuIjt3aW5kb3cuUkVTT1VSQ0VTX1BBVEg9d2luZG93LlJFU09VUkNFU19QQVRIfHwicmVzb3VyY2VzIjt3aW5kb3cuUkVTT1VSQ0VfQkFTRT13aW5kb3cuUkVTT1VSQ0VfQkFTRXx8d2luZG93LlJFU09VUkNFU19QQVRIKyIvZ3JhcGhlZGl0b3IiO3dpbmRvdy5TVEVOQ0lMX1BBVEg9d2luZG93LlNURU5DSUxfUEFUSHx8InN0ZW5jaWxzIjt3aW5kb3cuSU1BR0VfUEFUSD13aW5kb3cuSU1BR0VfUEFUSHx8ImltYWdlcyI7CndpbmRvdy5TVFlMRV9QQVRIPXdpbmRvdy5TVFlMRV9QQVRIfHwic3R5bGVzIjt3aW5kb3cuQ1NTX1BBVEg9d2luZG93LkNTU19QQVRIfHwic3R5bGVzIjt3aW5kb3cuT1BFTl9GT1JNPXdpbmRvdy5PUEVOX0ZPUk18fCJvcGVuLmh0bWwiO3dpbmRvdy5teEJhc2VQYXRoPXdpbmRvdy5teEJhc2VQYXRofHwiLi4vLi4vLi4vc3JjIjt3aW5kb3cubXhMYW5ndWFnZT13aW5kb3cubXhMYW5ndWFnZXx8dXJsUGFyYW1zLmxhbmc7d2luZG93Lm14TGFuZ3VhZ2VzPXdpbmRvdy5teExhbmd1YWdlc3x8WyJkZSIsInNlIl07dmFyIG14Q2xpZW50PXtWRVJTSU9OOiI0LjIuMCIsSVNfSUU6bnVsbCE9bmF2aWdhdG9yLnVzZXJBZ2VudCYmMDw9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJNU0lFIiksSVNfSUU2Om51bGwhPW5hdmlnYXRvci51c2VyQWdlbnQmJjA8PW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiTVNJRSA2IiksSVNfSUUxMTpudWxsIT1uYXZpZ2F0b3IudXNlckFnZW50JiYhIW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1RyaWRlbnRcLzdcLi8pLElTX0VER0U6bnVsbCE9bmF2aWdhdG9yLnVzZXJBZ2VudCYmISFuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9FZGdlXC8vKSxJU19RVUlSS1M6bnVsbCE9bmF2aWdhdG9yLnVzZXJBZ2VudCYmMDw9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJNU0lFIikmJihudWxsPT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fDU9PWRvY3VtZW50LmRvY3VtZW50TW9kZSksSVNfRU06InNwZWxsY2hlY2siaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGV4dGFyZWEiKSYmCjg9PWRvY3VtZW50LmRvY3VtZW50TW9kZSxWTUxfUFJFRklYOiJ2IixPRkZJQ0VfUFJFRklYOiJvIixJU19OUzpudWxsIT1uYXZpZ2F0b3IudXNlckFnZW50JiYwPD1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIk1vemlsbGEvIikmJjA+bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJNU0lFIikmJjA+bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJFZGdlLyIpLElTX09QOm51bGwhPW5hdmlnYXRvci51c2VyQWdlbnQmJigwPD1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIk9wZXJhLyIpfHwwPD1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIk9QUi8iKSksSVNfT1Q6bnVsbCE9bmF2aWdhdG9yLnVzZXJBZ2VudCYmMDw9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJQcmVzdG8vIikmJjA+bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJQcmVzdG8vMi40LiIpJiYwPm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiUHJlc3RvLzIuMy4iKSYmMD5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIlByZXN0by8yLjIuIikmJgowPm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiUHJlc3RvLzIuMS4iKSYmMD5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIlByZXN0by8yLjAuIikmJjA+bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJQcmVzdG8vMS4iKSxJU19TRjovQXBwbGUgQ29tcHV0ZXIsIEluYy8udGVzdChuYXZpZ2F0b3IudmVuZG9yKSxJU19BTkRST0lEOjA8PW5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoIkFuZHJvaWQiKSxJU19JT1M6L2lQKGhvbmV8b2R8YWQpLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSksSVNfR0M6L0dvb2dsZSBJbmMvLnRlc3QobmF2aWdhdG9yLnZlbmRvciksSVNfQ0hST01FQVBQOm51bGwhPXdpbmRvdy5jaHJvbWUmJm51bGwhPWNocm9tZS5hcHAmJm51bGwhPWNocm9tZS5hcHAucnVudGltZSxJU19GRjoidW5kZWZpbmVkIiE9PXR5cGVvZiBJbnN0YWxsVHJpZ2dlcixJU19NVDowPD1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIkZpcmVmb3gvIikmJjA+Cm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiRmlyZWZveC8xLiIpJiYwPm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiRmlyZWZveC8yLiIpfHwwPD1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIkljZXdlYXNlbC8iKSYmMD5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIkljZXdlYXNlbC8xLiIpJiYwPm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiSWNld2Vhc2VsLzIuIil8fDA8PW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiU2VhTW9ua2V5LyIpJiYwPm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiU2VhTW9ua2V5LzEuIil8fDA8PW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiSWNlYXBlLyIpJiYwPm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiSWNlYXBlLzEuIiksSVNfVk1MOiJNSUNST1NPRlQgSU5URVJORVQgRVhQTE9SRVIiPT1uYXZpZ2F0b3IuYXBwTmFtZS50b1VwcGVyQ2FzZSgpLElTX1NWRzoiTUlDUk9TT0ZUIElOVEVSTkVUIEVYUExPUkVSIiE9Cm5hdmlnYXRvci5hcHBOYW1lLnRvVXBwZXJDYXNlKCksTk9fRk86IWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROU3x8IltvYmplY3QgU1ZHRm9yZWlnbk9iamVjdEVsZW1lbnRdIiE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIsImZvcmVpZ25PYmplY3QiKXx8MDw9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJPcGVyYS8iKSxJU19XSU46MDxuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKCJXaW4iKSxJU19NQUM6MDxuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKCJNYWMiKSxJU19DSFJPTUVPUzovXGJDck9TXGIvLnRlc3QobmF2aWdhdG9yLmFwcFZlcnNpb24pLElTX1RPVUNIOiJvbnRvdWNoc3RhcnQiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LElTX1BPSU5URVI6bnVsbCE9d2luZG93LlBvaW50ZXJFdmVudCYmISgwPG5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoIk1hYyIpKSxJU19MT0NBTDowPmRvY3VtZW50LmxvY2F0aW9uLmhyZWYuaW5kZXhPZigiaHR0cDovLyIpJiYKMD5kb2N1bWVudC5sb2NhdGlvbi5ocmVmLmluZGV4T2YoImh0dHBzOi8vIiksZGVmYXVsdEJ1bmRsZXM6W10saXNCcm93c2VyU3VwcG9ydGVkOmZ1bmN0aW9uKCl7cmV0dXJuIG14Q2xpZW50LklTX1ZNTHx8bXhDbGllbnQuSVNfU1ZHfSxsaW5rOmZ1bmN0aW9uKGEsYixjLGQpe2M9Y3x8ZG9jdW1lbnQ7aWYobXhDbGllbnQuSVNfSUU2KWMud3JpdGUoJzxsaW5rIHJlbD0iJythKyciIGhyZWY9IicrYisnIiBjaGFyc2V0PSJVVEYtOCIgdHlwZT0idGV4dC9jc3MiLz4nKTtlbHNle3ZhciBlPWMuY3JlYXRlRWxlbWVudCgibGluayIpO2Uuc2V0QXR0cmlidXRlKCJyZWwiLGEpO2Uuc2V0QXR0cmlidXRlKCJocmVmIixiKTtlLnNldEF0dHJpYnV0ZSgiY2hhcnNldCIsIlVURi04Iik7ZS5zZXRBdHRyaWJ1dGUoInR5cGUiLCJ0ZXh0L2NzcyIpO2QmJmUuc2V0QXR0cmlidXRlKCJpZCIsZCk7Yy5nZXRFbGVtZW50c0J5VGFnTmFtZSgiaGVhZCIpWzBdLmFwcGVuZENoaWxkKGUpfX0sbG9hZFJlc291cmNlczpmdW5jdGlvbihhLApiKXtmdW5jdGlvbiBjKCl7MD09LS1kJiZhKCl9Zm9yKHZhciBkPW14Q2xpZW50LmRlZmF1bHRCdW5kbGVzLmxlbmd0aCxlPTA7ZTxteENsaWVudC5kZWZhdWx0QnVuZGxlcy5sZW5ndGg7ZSsrKW14UmVzb3VyY2VzLmFkZChteENsaWVudC5kZWZhdWx0QnVuZGxlc1tlXSxiLGMpfSxpbmNsdWRlOmZ1bmN0aW9uKGEpe2RvY3VtZW50LndyaXRlKCc8c2NyaXB0IHNyYz0iJythKyciPlx4M2Mvc2NyaXB0PicpfX07InVuZGVmaW5lZCI9PXR5cGVvZiBteExvYWRSZXNvdXJjZXMmJihteExvYWRSZXNvdXJjZXM9ITApOyJ1bmRlZmluZWQiPT10eXBlb2YgbXhGb3JjZUluY2x1ZGVzJiYobXhGb3JjZUluY2x1ZGVzPSExKTsidW5kZWZpbmVkIj09dHlwZW9mIG14UmVzb3VyY2VFeHRlbnNpb24mJihteFJlc291cmNlRXh0ZW5zaW9uPSIudHh0Iik7InVuZGVmaW5lZCI9PXR5cGVvZiBteExvYWRTdHlsZXNoZWV0cyYmKG14TG9hZFN0eWxlc2hlZXRzPSEwKTsKInVuZGVmaW5lZCIhPXR5cGVvZiBteEJhc2VQYXRoJiYwPG14QmFzZVBhdGgubGVuZ3RoPygiLyI9PW14QmFzZVBhdGguc3Vic3RyaW5nKG14QmFzZVBhdGgubGVuZ3RoLTEpJiYobXhCYXNlUGF0aD1teEJhc2VQYXRoLnN1YnN0cmluZygwLG14QmFzZVBhdGgubGVuZ3RoLTEpKSxteENsaWVudC5iYXNlUGF0aD1teEJhc2VQYXRoKTpteENsaWVudC5iYXNlUGF0aD0iLiI7InVuZGVmaW5lZCIhPXR5cGVvZiBteEltYWdlQmFzZVBhdGgmJjA8bXhJbWFnZUJhc2VQYXRoLmxlbmd0aD8oIi8iPT1teEltYWdlQmFzZVBhdGguc3Vic3RyaW5nKG14SW1hZ2VCYXNlUGF0aC5sZW5ndGgtMSkmJihteEltYWdlQmFzZVBhdGg9bXhJbWFnZUJhc2VQYXRoLnN1YnN0cmluZygwLG14SW1hZ2VCYXNlUGF0aC5sZW5ndGgtMSkpLG14Q2xpZW50LmltYWdlQmFzZVBhdGg9bXhJbWFnZUJhc2VQYXRoKTpteENsaWVudC5pbWFnZUJhc2VQYXRoPW14Q2xpZW50LmJhc2VQYXRoKyIvaW1hZ2VzIjsKbXhDbGllbnQubGFuZ3VhZ2U9InVuZGVmaW5lZCIhPXR5cGVvZiBteExhbmd1YWdlJiZudWxsIT1teExhbmd1YWdlP214TGFuZ3VhZ2U6bXhDbGllbnQuSVNfSUU/bmF2aWdhdG9yLnVzZXJMYW5ndWFnZTpuYXZpZ2F0b3IubGFuZ3VhZ2U7bXhDbGllbnQuZGVmYXVsdExhbmd1YWdlPSJ1bmRlZmluZWQiIT10eXBlb2YgbXhEZWZhdWx0TGFuZ3VhZ2UmJm51bGwhPW14RGVmYXVsdExhbmd1YWdlP214RGVmYXVsdExhbmd1YWdlOiJlbiI7bXhMb2FkU3R5bGVzaGVldHMmJm14Q2xpZW50LmxpbmsoInN0eWxlc2hlZXQiLG14Q2xpZW50LmJhc2VQYXRoKyIvY3NzL2NvbW1vbi5jc3MiKTsidW5kZWZpbmVkIiE9dHlwZW9mIG14TGFuZ3VhZ2VzJiZudWxsIT1teExhbmd1YWdlcyYmKG14Q2xpZW50Lmxhbmd1YWdlcz1teExhbmd1YWdlcyk7Cm14Q2xpZW50LklTX1ZNTCYmKG14Q2xpZW50LklTX1NWRz9teENsaWVudC5JU19WTUw9ITE6KG51bGwhPWRvY3VtZW50Lm5hbWVzcGFjZXMmJig4PT1kb2N1bWVudC5kb2N1bWVudE1vZGU/KGRvY3VtZW50Lm5hbWVzcGFjZXMuYWRkKG14Q2xpZW50LlZNTF9QUkVGSVgsInVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sIiwiI2RlZmF1bHQjVk1MIiksZG9jdW1lbnQubmFtZXNwYWNlcy5hZGQobXhDbGllbnQuT0ZGSUNFX1BSRUZJWCwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTpvZmZpY2U6b2ZmaWNlIiwiI2RlZmF1bHQjVk1MIikpOihkb2N1bWVudC5uYW1lc3BhY2VzLmFkZChteENsaWVudC5WTUxfUFJFRklYLCJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCIpLGRvY3VtZW50Lm5hbWVzcGFjZXMuYWRkKG14Q2xpZW50Lk9GRklDRV9QUkVGSVgsInVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206b2ZmaWNlOm9mZmljZSIpKSksbXhDbGllbnQuSVNfUVVJUktTJiYzMDw9ZG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoPwpmdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInN0eWxlIik7YS50eXBlPSJ0ZXh0L2NzcyI7YS5zdHlsZVNoZWV0LmNzc1RleHQ9bXhDbGllbnQuVk1MX1BSRUZJWCsiXFw6KntiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKX0iK214Q2xpZW50Lk9GRklDRV9QUkVGSVgrIlxcOip7YmVoYXZpb3I6dXJsKCNkZWZhdWx0I1ZNTCl9Ijtkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgiaGVhZCIpWzBdLmFwcGVuZENoaWxkKGEpfSgpOmRvY3VtZW50LmNyZWF0ZVN0eWxlU2hlZXQoKS5jc3NUZXh0PW14Q2xpZW50LlZNTF9QUkVGSVgrIlxcOip7YmVoYXZpb3I6dXJsKCNkZWZhdWx0I1ZNTCl9IitteENsaWVudC5PRkZJQ0VfUFJFRklYKyJcXDoqe2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpfSIsbXhMb2FkU3R5bGVzaGVldHMmJm14Q2xpZW50LmxpbmsoInN0eWxlc2hlZXQiLG14Q2xpZW50LmJhc2VQYXRoKyIvY3NzL2V4cGxvcmVyLmNzcyIpKSk7CnZhciBteExvZz17Y29uc29sZU5hbWU6IkNvbnNvbGUiLFRSQUNFOiExLERFQlVHOiEwLFdBUk46ITAsYnVmZmVyOiIiLGluaXQ6ZnVuY3Rpb24oKXtpZihudWxsPT1teExvZy53aW5kb3cmJm51bGwhPWRvY3VtZW50LmJvZHkpe3ZhciBhPW14TG9nLmNvbnNvbGVOYW1lKyIgLSBteEdyYXBoICIrbXhDbGllbnQuVkVSU0lPTixiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRhYmxlIik7Yi5zZXRBdHRyaWJ1dGUoIndpZHRoIiwiMTAwJSIpO2Iuc2V0QXR0cmlidXRlKCJoZWlnaHQiLCIxMDAlIik7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGJvZHkiKSxkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRyIiksZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpO2Uuc3R5bGUudmVydGljYWxBbGlnbj0idG9wIjtteExvZy50ZXh0YXJlYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZXh0YXJlYSIpO214TG9nLnRleHRhcmVhLnNldEF0dHJpYnV0ZSgid3JhcCIsIm9mZiIpOwpteExvZy50ZXh0YXJlYS5zZXRBdHRyaWJ1dGUoInJlYWRPbmx5IiwidHJ1ZSIpO214TG9nLnRleHRhcmVhLnN0eWxlLmhlaWdodD0iMTAwJSI7bXhMb2cudGV4dGFyZWEuc3R5bGUucmVzaXplPSJub25lIjtteExvZy50ZXh0YXJlYS52YWx1ZT1teExvZy5idWZmZXI7bXhMb2cudGV4dGFyZWEuc3R5bGUud2lkdGg9bXhDbGllbnQuSVNfTlMmJiJCYWNrQ29tcGF0IiE9ZG9jdW1lbnQuY29tcGF0TW9kZT8iOTklIjoiMTAwJSI7ZS5hcHBlbmRDaGlsZChteExvZy50ZXh0YXJlYSk7ZC5hcHBlbmRDaGlsZChlKTtjLmFwcGVuZENoaWxkKGQpO2Q9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidHIiKTtteExvZy50ZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpO214TG9nLnRkLnN0eWxlLnZlcnRpY2FsQWxpZ249InRvcCI7bXhMb2cudGQuc2V0QXR0cmlidXRlKCJoZWlnaHQiLCIzMHB4Iik7ZC5hcHBlbmRDaGlsZChteExvZy50ZCk7Yy5hcHBlbmRDaGlsZChkKTtiLmFwcGVuZENoaWxkKGMpOwpteExvZy5hZGRCdXR0b24oIkluZm8iLGZ1bmN0aW9uKGEpe214TG9nLmluZm8oKX0pO214TG9nLmFkZEJ1dHRvbigiRE9NIixmdW5jdGlvbihhKXthPW14VXRpbHMuZ2V0SW5uZXJIdG1sKGRvY3VtZW50LmJvZHkpO214TG9nLmRlYnVnKGEpfSk7bXhMb2cuYWRkQnV0dG9uKCJUcmFjZSIsZnVuY3Rpb24oYSl7bXhMb2cuVFJBQ0U9IW14TG9nLlRSQUNFO214TG9nLlRSQUNFP214TG9nLmRlYnVnKCJUcmFjaW5nIGVuYWJsZWQiKTpteExvZy5kZWJ1ZygiVHJhY2luZyBkaXNhYmxlZCIpfSk7bXhMb2cuYWRkQnV0dG9uKCJDb3B5IixmdW5jdGlvbihhKXt0cnl7bXhVdGlscy5jb3B5KG14TG9nLnRleHRhcmVhLnZhbHVlKX1jYXRjaChrKXtteFV0aWxzLmFsZXJ0KGspfX0pO214TG9nLmFkZEJ1dHRvbigiU2hvdyIsZnVuY3Rpb24oYSl7dHJ5e214VXRpbHMucG9wdXAobXhMb2cudGV4dGFyZWEudmFsdWUpfWNhdGNoKGspe214VXRpbHMuYWxlcnQoayl9fSk7bXhMb2cuYWRkQnV0dG9uKCJDbGVhciIsCmZ1bmN0aW9uKGEpe214TG9nLnRleHRhcmVhLnZhbHVlPSIifSk7ZD1jPTA7Im51bWJlciI9PT10eXBlb2Ygd2luZG93LmlubmVyV2lkdGg/KGM9d2luZG93LmlubmVySGVpZ2h0LGQ9d2luZG93LmlubmVyV2lkdGgpOihjPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHR8fGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0LGQ9ZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCk7bXhMb2cud2luZG93PW5ldyBteFdpbmRvdyhhLGIsTWF0aC5tYXgoMCxkLTMyMCksTWF0aC5tYXgoMCxjLTIxMCksMzAwLDE2MCk7bXhMb2cud2luZG93LnNldE1heGltaXphYmxlKCEwKTtteExvZy53aW5kb3cuc2V0U2Nyb2xsYWJsZSghMSk7bXhMb2cud2luZG93LnNldFJlc2l6YWJsZSghMCk7bXhMb2cud2luZG93LnNldENsb3NhYmxlKCEwKTtteExvZy53aW5kb3cuZGVzdHJveU9uQ2xvc2U9ITE7aWYoKG14Q2xpZW50LklTX05TfHxteENsaWVudC5JU19JRSkmJiFteENsaWVudC5JU19HQyYmCiFteENsaWVudC5JU19TRiYmIkJhY2tDb21wYXQiIT1kb2N1bWVudC5jb21wYXRNb2RlfHwxMT09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKXt2YXIgZj1teExvZy53aW5kb3cuZ2V0RWxlbWVudCgpLGE9ZnVuY3Rpb24oYSxiKXtteExvZy50ZXh0YXJlYS5zdHlsZS5oZWlnaHQ9TWF0aC5tYXgoMCxmLm9mZnNldEhlaWdodC03MCkrInB4In07bXhMb2cud2luZG93LmFkZExpc3RlbmVyKG14RXZlbnQuUkVTSVpFX0VORCxhKTtteExvZy53aW5kb3cuYWRkTGlzdGVuZXIobXhFdmVudC5NQVhJTUlaRSxhKTtteExvZy53aW5kb3cuYWRkTGlzdGVuZXIobXhFdmVudC5OT1JNQUxJWkUsYSk7bXhMb2cudGV4dGFyZWEuc3R5bGUuaGVpZ2h0PSI5MnB4In19fSxpbmZvOmZ1bmN0aW9uKCl7bXhMb2cud3JpdGVsbihteFV0aWxzLnRvU3RyaW5nKG5hdmlnYXRvcikpfSxhZGRCdXR0b246ZnVuY3Rpb24oYSxiKXt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJidXR0b24iKTtteFV0aWxzLndyaXRlKGMsCmEpO214RXZlbnQuYWRkTGlzdGVuZXIoYywiY2xpY2siLGIpO214TG9nLnRkLmFwcGVuZENoaWxkKGMpfSxpc1Zpc2libGU6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9bXhMb2cud2luZG93P214TG9nLndpbmRvdy5pc1Zpc2libGUoKTohMX0sc2hvdzpmdW5jdGlvbigpe214TG9nLnNldFZpc2libGUoITApfSxzZXRWaXNpYmxlOmZ1bmN0aW9uKGEpe251bGw9PW14TG9nLndpbmRvdyYmbXhMb2cuaW5pdCgpO251bGwhPW14TG9nLndpbmRvdyYmbXhMb2cud2luZG93LnNldFZpc2libGUoYSl9LGVudGVyOmZ1bmN0aW9uKGEpe2lmKG14TG9nLlRSQUNFKXJldHVybiBteExvZy53cml0ZWxuKCJFbnRlcmluZyAiK2EpLChuZXcgRGF0ZSkuZ2V0VGltZSgpfSxsZWF2ZTpmdW5jdGlvbihhLGIpe2lmKG14TG9nLlRSQUNFKXt2YXIgYz0wIT1iPyIgKCIrKChuZXcgRGF0ZSkuZ2V0VGltZSgpLWIpKyIgbXMpIjoiIjtteExvZy53cml0ZWxuKCJMZWF2aW5nICIrYStjKX19LGRlYnVnOmZ1bmN0aW9uKCl7bXhMb2cuREVCVUcmJgpteExvZy53cml0ZWxuLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sd2FybjpmdW5jdGlvbigpe214TG9nLldBUk4mJm14TG9nLndyaXRlbG4uYXBwbHkodGhpcyxhcmd1bWVudHMpfSx3cml0ZTpmdW5jdGlvbigpe2Zvcih2YXIgYT0iIixiPTA7Yjxhcmd1bWVudHMubGVuZ3RoO2IrKylhKz1hcmd1bWVudHNbYl0sYjxhcmd1bWVudHMubGVuZ3RoLTEmJihhKz0iICIpO251bGwhPW14TG9nLnRleHRhcmVhPyhteExvZy50ZXh0YXJlYS52YWx1ZSs9YSxudWxsIT1uYXZpZ2F0b3IudXNlckFnZW50JiYwPD1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIlByZXN0by8yLjUiKSYmKG14TG9nLnRleHRhcmVhLnN0eWxlLnZpc2liaWxpdHk9ImhpZGRlbiIsbXhMb2cudGV4dGFyZWEuc3R5bGUudmlzaWJpbGl0eT0idmlzaWJsZSIpLG14TG9nLnRleHRhcmVhLnNjcm9sbFRvcD1teExvZy50ZXh0YXJlYS5zY3JvbGxIZWlnaHQpOm14TG9nLmJ1ZmZlcis9YX0sd3JpdGVsbjpmdW5jdGlvbigpe2Zvcih2YXIgYT0KIiIsYj0wO2I8YXJndW1lbnRzLmxlbmd0aDtiKyspYSs9YXJndW1lbnRzW2JdLGI8YXJndW1lbnRzLmxlbmd0aC0xJiYoYSs9IiAiKTtteExvZy53cml0ZShhKyJcbiIpfX0sbXhPYmplY3RJZGVudGl0eT17RklFTERfTkFNRToibXhPYmplY3RJZCIsY291bnRlcjowLGdldDpmdW5jdGlvbihhKXtpZihudWxsIT1hKXtpZihudWxsPT1hW214T2JqZWN0SWRlbnRpdHkuRklFTERfTkFNRV0paWYoIm9iamVjdCI9PT10eXBlb2YgYSl7dmFyIGI9bXhVdGlscy5nZXRGdW5jdGlvbk5hbWUoYS5jb25zdHJ1Y3Rvcik7YVtteE9iamVjdElkZW50aXR5LkZJRUxEX05BTUVdPWIrIiMiK214T2JqZWN0SWRlbnRpdHkuY291bnRlcisrfWVsc2UiZnVuY3Rpb24iPT09dHlwZW9mIGEmJihhW214T2JqZWN0SWRlbnRpdHkuRklFTERfTkFNRV09IkZ1bmN0aW9uIyIrbXhPYmplY3RJZGVudGl0eS5jb3VudGVyKyspO3JldHVybiBhW214T2JqZWN0SWRlbnRpdHkuRklFTERfTkFNRV19cmV0dXJuIG51bGx9LApjbGVhcjpmdW5jdGlvbihhKXsib2JqZWN0IiE9PXR5cGVvZiBhJiYiZnVuY3Rpb24iIT09dHlwZW9mIGF8fGRlbGV0ZSBhW214T2JqZWN0SWRlbnRpdHkuRklFTERfTkFNRV19fTtmdW5jdGlvbiBteERpY3Rpb25hcnkoKXt0aGlzLmNsZWFyKCl9bXhEaWN0aW9uYXJ5LnByb3RvdHlwZS5tYXA9bnVsbDtteERpY3Rpb25hcnkucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5tYXA9e319O214RGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGEpe2E9bXhPYmplY3RJZGVudGl0eS5nZXQoYSk7cmV0dXJuIHRoaXMubWFwW2FdfTtteERpY3Rpb25hcnkucHJvdG90eXBlLnB1dD1mdW5jdGlvbihhLGIpe3ZhciBjPW14T2JqZWN0SWRlbnRpdHkuZ2V0KGEpLGQ9dGhpcy5tYXBbY107dGhpcy5tYXBbY109YjtyZXR1cm4gZH07Cm14RGljdGlvbmFyeS5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKGEpe2E9bXhPYmplY3RJZGVudGl0eS5nZXQoYSk7dmFyIGI9dGhpcy5tYXBbYV07ZGVsZXRlIHRoaXMubWFwW2FdO3JldHVybiBifTtteERpY3Rpb25hcnkucHJvdG90eXBlLmdldEtleXM9ZnVuY3Rpb24oKXt2YXIgYT1bXSxiO2ZvcihiIGluIHRoaXMubWFwKWEucHVzaChiKTtyZXR1cm4gYX07bXhEaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRWYWx1ZXM9ZnVuY3Rpb24oKXt2YXIgYT1bXSxiO2ZvcihiIGluIHRoaXMubWFwKWEucHVzaCh0aGlzLm1hcFtiXSk7cmV0dXJuIGF9O214RGljdGlvbmFyeS5wcm90b3R5cGUudmlzaXQ9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiIGluIHRoaXMubWFwKWEoYix0aGlzLm1hcFtiXSl9Owp2YXIgbXhSZXNvdXJjZXM9e3Jlc291cmNlczp7fSxleHRlbnNpb246bXhSZXNvdXJjZUV4dGVuc2lvbixyZXNvdXJjZXNFbmNvZGVkOiExLGxvYWREZWZhdWx0QnVuZGxlOiEwLGxvYWRTcGVjaWFsQnVuZGxlOiEwLGlzTGFuZ3VhZ2VTdXBwb3J0ZWQ6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPW14Q2xpZW50Lmxhbmd1YWdlcz8wPD1teFV0aWxzLmluZGV4T2YobXhDbGllbnQubGFuZ3VhZ2VzLGEpOiEwfSxnZXREZWZhdWx0QnVuZGxlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIG14UmVzb3VyY2VzLmxvYWREZWZhdWx0QnVuZGxlfHwhbXhSZXNvdXJjZXMuaXNMYW5ndWFnZVN1cHBvcnRlZChiKT9hK214UmVzb3VyY2VzLmV4dGVuc2lvbjpudWxsfSxnZXRTcGVjaWFsQnVuZGxlOmZ1bmN0aW9uKGEsYil7aWYobnVsbD09bXhDbGllbnQubGFuZ3VhZ2VzfHwhdGhpcy5pc0xhbmd1YWdlU3VwcG9ydGVkKGIpKXt2YXIgYz1iLmluZGV4T2YoIi0iKTswPGMmJihiPWIuc3Vic3RyaW5nKDAsYykpfXJldHVybiBteFJlc291cmNlcy5sb2FkU3BlY2lhbEJ1bmRsZSYmCm14UmVzb3VyY2VzLmlzTGFuZ3VhZ2VTdXBwb3J0ZWQoYikmJmIhPW14Q2xpZW50LmRlZmF1bHRMYW5ndWFnZT9hKyJfIitiK214UmVzb3VyY2VzLmV4dGVuc2lvbjpudWxsfSxhZGQ6ZnVuY3Rpb24oYSxiLGMpe2I9bnVsbCE9Yj9iOm51bGwhPW14Q2xpZW50Lmxhbmd1YWdlP214Q2xpZW50Lmxhbmd1YWdlLnRvTG93ZXJDYXNlKCk6bXhDb25zdGFudHMuTk9ORTtpZihiIT1teENvbnN0YW50cy5OT05FKXt2YXIgZD1teFJlc291cmNlcy5nZXREZWZhdWx0QnVuZGxlKGEsYiksZT1teFJlc291cmNlcy5nZXRTcGVjaWFsQnVuZGxlKGEsYiksZj1mdW5jdGlvbigpe2lmKG51bGwhPWUpaWYoYylteFV0aWxzLmdldChlLGZ1bmN0aW9uKGEpe214UmVzb3VyY2VzLnBhcnNlKGEuZ2V0VGV4dCgpKTtjKCl9LGZ1bmN0aW9uKCl7YygpfSk7ZWxzZSB0cnl7dmFyIGE9bXhVdGlscy5sb2FkKGUpO2EuaXNSZWFkeSgpJiZteFJlc291cmNlcy5wYXJzZShhLmdldFRleHQoKSl9Y2F0Y2gobCl7fWVsc2UgbnVsbCE9CmMmJmMoKX07aWYobnVsbCE9ZClpZihjKW14VXRpbHMuZ2V0KGQsZnVuY3Rpb24oYSl7bXhSZXNvdXJjZXMucGFyc2UoYS5nZXRUZXh0KCkpO2YoKX0sZnVuY3Rpb24oKXtmKCl9KTtlbHNlIHRyeXt2YXIgZz1teFV0aWxzLmxvYWQoZCk7Zy5pc1JlYWR5KCkmJm14UmVzb3VyY2VzLnBhcnNlKGcuZ2V0VGV4dCgpKTtmKCl9Y2F0Y2goayl7fWVsc2UgZigpfX0scGFyc2U6ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSl7YT1hLnNwbGl0KCJcbiIpO2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKWlmKCIjIiE9YVtiXS5jaGFyQXQoMCkpe3ZhciBjPWFbYl0uaW5kZXhPZigiPSIpO2lmKDA8Yyl7dmFyIGQ9YVtiXS5zdWJzdHJpbmcoMCxjKSxlPWFbYl0ubGVuZ3RoOzEzPT1hW2JdLmNoYXJDb2RlQXQoZS0xKSYmZS0tO2M9YVtiXS5zdWJzdHJpbmcoYysxLGUpO3RoaXMucmVzb3VyY2VzRW5jb2RlZD8oYz1jLnJlcGxhY2UoL1xcKD89dVthLWZBLUZcZF17NH0pL2csIiUiKSxteFJlc291cmNlcy5yZXNvdXJjZXNbZF09CnVuZXNjYXBlKGMpKTpteFJlc291cmNlcy5yZXNvdXJjZXNbZF09Y319fX0sZ2V0OmZ1bmN0aW9uKGEsYixjKXthPW14UmVzb3VyY2VzLnJlc291cmNlc1thXTtudWxsPT1hJiYoYT1jKTtudWxsIT1hJiZudWxsIT1iJiYoYT1teFJlc291cmNlcy5yZXBsYWNlUGxhY2Vob2xkZXJzKGEsYikpO3JldHVybiBhfSxyZXBsYWNlUGxhY2Vob2xkZXJzOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPVtdLGQ9bnVsbCxlPTA7ZTxhLmxlbmd0aDtlKyspe3ZhciBmPWEuY2hhckF0KGUpOyJ7Ij09Zj9kPSIiOm51bGwhPWQmJiJ9Ij09Zj8oZD1wYXJzZUludChkKS0xLDA8PWQmJmQ8Yi5sZW5ndGgmJmMucHVzaChiW2RdKSxkPW51bGwpOm51bGwhPWQ/ZCs9ZjpjLnB1c2goZil9cmV0dXJuIGMuam9pbigiIil9LGxvYWRSZXNvdXJjZXM6ZnVuY3Rpb24oYSl7bXhSZXNvdXJjZXMuYWRkKG14Q2xpZW50LmJhc2VQYXRoKyIvcmVzb3VyY2VzL2VkaXRvciIsbnVsbCxmdW5jdGlvbigpe214UmVzb3VyY2VzLmFkZChteENsaWVudC5iYXNlUGF0aCsKIi9yZXNvdXJjZXMvZ3JhcGgiLG51bGwsYSl9KX19O2Z1bmN0aW9uIG14UG9pbnQoYSxiKXt0aGlzLng9bnVsbCE9YT9hOjA7dGhpcy55PW51bGwhPWI/YjowfW14UG9pbnQucHJvdG90eXBlLng9bnVsbDtteFBvaW50LnByb3RvdHlwZS55PW51bGw7bXhQb2ludC5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiZhLng9PXRoaXMueCYmYS55PT10aGlzLnl9O214UG9pbnQucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG14VXRpbHMuY2xvbmUodGhpcyl9O2Z1bmN0aW9uIG14UmVjdGFuZ2xlKGEsYixjLGQpe214UG9pbnQuY2FsbCh0aGlzLGEsYik7dGhpcy53aWR0aD1udWxsIT1jP2M6MDt0aGlzLmhlaWdodD1udWxsIT1kP2Q6MH1teFJlY3RhbmdsZS5wcm90b3R5cGU9bmV3IG14UG9pbnQ7bXhSZWN0YW5nbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14UmVjdGFuZ2xlO214UmVjdGFuZ2xlLnByb3RvdHlwZS53aWR0aD1udWxsOwpteFJlY3RhbmdsZS5wcm90b3R5cGUuaGVpZ2h0PW51bGw7bXhSZWN0YW5nbGUucHJvdG90eXBlLnNldFJlY3Q9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy54PWE7dGhpcy55PWI7dGhpcy53aWR0aD1jO3RoaXMuaGVpZ2h0PWR9O214UmVjdGFuZ2xlLnByb3RvdHlwZS5nZXRDZW50ZXJYPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMueCt0aGlzLndpZHRoLzJ9O214UmVjdGFuZ2xlLnByb3RvdHlwZS5nZXRDZW50ZXJZPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMueSt0aGlzLmhlaWdodC8yfTsKbXhSZWN0YW5nbGUucHJvdG90eXBlLmFkZD1mdW5jdGlvbihhKXtpZihudWxsIT1hKXt2YXIgYj1NYXRoLm1pbih0aGlzLngsYS54KSxjPU1hdGgubWluKHRoaXMueSxhLnkpLGQ9TWF0aC5tYXgodGhpcy54K3RoaXMud2lkdGgsYS54K2Eud2lkdGgpO2E9TWF0aC5tYXgodGhpcy55K3RoaXMuaGVpZ2h0LGEueSthLmhlaWdodCk7dGhpcy54PWI7dGhpcy55PWM7dGhpcy53aWR0aD1kLWI7dGhpcy5oZWlnaHQ9YS1jfX07bXhSZWN0YW5nbGUucHJvdG90eXBlLmludGVyc2VjdD1mdW5jdGlvbihhKXtpZihudWxsIT1hKXt2YXIgYj10aGlzLngrdGhpcy53aWR0aCxjPWEueCthLndpZHRoLGQ9dGhpcy55K3RoaXMuaGVpZ2h0LGU9YS55K2EuaGVpZ2h0O3RoaXMueD1NYXRoLm1heCh0aGlzLngsYS54KTt0aGlzLnk9TWF0aC5tYXgodGhpcy55LGEueSk7dGhpcy53aWR0aD1NYXRoLm1pbihiLGMpLXRoaXMueDt0aGlzLmhlaWdodD1NYXRoLm1pbihkLGUpLXRoaXMueX19OwpteFJlY3RhbmdsZS5wcm90b3R5cGUuZ3Jvdz1mdW5jdGlvbihhKXt0aGlzLngtPWE7dGhpcy55LT1hO3RoaXMud2lkdGgrPTIqYTt0aGlzLmhlaWdodCs9MiphO3JldHVybiB0aGlzfTtteFJlY3RhbmdsZS5wcm90b3R5cGUuZ2V0UG9pbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG14UG9pbnQodGhpcy54LHRoaXMueSl9O214UmVjdGFuZ2xlLnByb3RvdHlwZS5yb3RhdGU5MD1mdW5jdGlvbigpe3ZhciBhPSh0aGlzLndpZHRoLXRoaXMuaGVpZ2h0KS8yO3RoaXMueCs9YTt0aGlzLnktPWE7YT10aGlzLndpZHRoO3RoaXMud2lkdGg9dGhpcy5oZWlnaHQ7dGhpcy5oZWlnaHQ9YX07bXhSZWN0YW5nbGUucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YSYmYS54PT10aGlzLngmJmEueT09dGhpcy55JiZhLndpZHRoPT10aGlzLndpZHRoJiZhLmhlaWdodD09dGhpcy5oZWlnaHR9OwpteFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgbXhSZWN0YW5nbGUoYS54LGEueSxhLndpZHRoLGEuaGVpZ2h0KX07CnZhciBteEVmZmVjdHM9e2FuaW1hdGVDaGFuZ2VzOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD0wLGU9ZnVuY3Rpb24oKXtmb3IodmFyIGc9ITEsaz0wO2s8Yi5sZW5ndGg7aysrKXt2YXIgbD1iW2tdO2lmKGwgaW5zdGFuY2VvZiBteEdlb21ldHJ5Q2hhbmdlfHxsIGluc3RhbmNlb2YgbXhUZXJtaW5hbENoYW5nZXx8bCBpbnN0YW5jZW9mIG14VmFsdWVDaGFuZ2V8fGwgaW5zdGFuY2VvZiBteENoaWxkQ2hhbmdlfHxsIGluc3RhbmNlb2YgbXhTdHlsZUNoYW5nZSl7dmFyIG09YS5nZXRWaWV3KCkuZ2V0U3RhdGUobC5jZWxsfHxsLmNoaWxkLCExKTtpZihudWxsIT1tKWlmKGc9ITAsbC5jb25zdHJ1Y3RvciE9bXhHZW9tZXRyeUNoYW5nZXx8YS5tb2RlbC5pc0VkZ2UobC5jZWxsKSlteFV0aWxzLnNldE9wYWNpdHkobS5zaGFwZS5ub2RlLDEwMCpkLzEwKTtlbHNle3ZhciBuPWEuZ2V0VmlldygpLnNjYWxlLHA9KGwuZ2VvbWV0cnkueC1sLnByZXZpb3VzLngpKm4scT0obC5nZW9tZXRyeS55LQpsLnByZXZpb3VzLnkpKm4scj0obC5nZW9tZXRyeS53aWR0aC1sLnByZXZpb3VzLndpZHRoKSpuLG49KGwuZ2VvbWV0cnkuaGVpZ2h0LWwucHJldmlvdXMuaGVpZ2h0KSpuOzA9PWQ/KG0ueC09cCxtLnktPXEsbS53aWR0aC09cixtLmhlaWdodC09bik6KG0ueCs9cC8xMCxtLnkrPXEvMTAsbS53aWR0aCs9ci8xMCxtLmhlaWdodCs9bi8xMCk7YS5jZWxsUmVuZGVyZXIucmVkcmF3KG0pO214RWZmZWN0cy5jYXNjYWRlT3BhY2l0eShhLGwuY2VsbCwxMDAqZC8xMCl9fX0xMD5kJiZnPyhkKyssd2luZG93LnNldFRpbWVvdXQoZSxmKSk6bnVsbCE9YyYmYygpfSxmPTMwO2UoKX0sY2FzY2FkZU9wYWNpdHk6ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLm1vZGVsLmdldENoaWxkQ291bnQoYiksZT0wO2U8ZDtlKyspe3ZhciBmPWEubW9kZWwuZ2V0Q2hpbGRBdChiLGUpLGc9YS5nZXRWaWV3KCkuZ2V0U3RhdGUoZik7bnVsbCE9ZyYmKG14VXRpbHMuc2V0T3BhY2l0eShnLnNoYXBlLm5vZGUsCmMpLG14RWZmZWN0cy5jYXNjYWRlT3BhY2l0eShhLGYsYykpfWI9YS5tb2RlbC5nZXRFZGdlcyhiKTtpZihudWxsIT1iKWZvcihlPTA7ZTxiLmxlbmd0aDtlKyspZD1hLmdldFZpZXcoKS5nZXRTdGF0ZShiW2VdKSxudWxsIT1kJiZteFV0aWxzLnNldE9wYWNpdHkoZC5zaGFwZS5ub2RlLGMpfSxmYWRlT3V0OmZ1bmN0aW9uKGEsYixjLGQsZSxmKXtkPWR8fDQwO2U9ZXx8MzA7dmFyIGc9Ynx8MTAwO214VXRpbHMuc2V0T3BhY2l0eShhLGcpO2lmKGZ8fG51bGw9PWYpe3ZhciBrPWZ1bmN0aW9uKCl7Zz1NYXRoLm1heChnLWQsMCk7bXhVdGlscy5zZXRPcGFjaXR5KGEsZyk7MDxnP3dpbmRvdy5zZXRUaW1lb3V0KGssZSk6KGEuc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIixjJiZhLnBhcmVudE5vZGUmJmEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKSl9O3dpbmRvdy5zZXRUaW1lb3V0KGssZSl9ZWxzZSBhLnN0eWxlLnZpc2liaWxpdHk9ImhpZGRlbiIsYyYmYS5wYXJlbnROb2RlJiZhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSl9fSwKbXhVdGlscz17ZXJyb3JSZXNvdXJjZToibm9uZSIhPW14Q2xpZW50Lmxhbmd1YWdlPyJlcnJvciI6IiIsY2xvc2VSZXNvdXJjZToibm9uZSIhPW14Q2xpZW50Lmxhbmd1YWdlPyJjbG9zZSI6IiIsZXJyb3JJbWFnZTpteENsaWVudC5pbWFnZUJhc2VQYXRoKyIvZXJyb3IuZ2lmIixyZW1vdmVDdXJzb3JzOmZ1bmN0aW9uKGEpe251bGwhPWEuc3R5bGUmJihhLnN0eWxlLmN1cnNvcj0iIik7YT1hLmNoaWxkTm9kZXM7aWYobnVsbCE9YSlmb3IodmFyIGI9YS5sZW5ndGgsYz0wO2M8YjtjKz0xKW14VXRpbHMucmVtb3ZlQ3Vyc29ycyhhW2NdKX0sZ2V0Q3VycmVudFN0eWxlOmZ1bmN0aW9uKCl7cmV0dXJuIG14Q2xpZW50LklTX0lFJiYobnVsbD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHw5PmRvY3VtZW50LmRvY3VtZW50TW9kZSk/ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/YS5jdXJyZW50U3R5bGU6bnVsbH06ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/d2luZG93LmdldENvbXB1dGVkU3R5bGUoYSwKIiIpOm51bGx9fSgpLHBhcnNlQ3NzTnVtYmVyOmZ1bmN0aW9uKGEpeyJ0aGluIj09YT9hPSIyIjoibWVkaXVtIj09YT9hPSI0IjoidGhpY2siPT1hJiYoYT0iNiIpO2E9cGFyc2VGbG9hdChhKTtpc05hTihhKSYmKGE9MCk7cmV0dXJuIGF9LHNldFByZWZpeGVkU3R5bGU6ZnVuY3Rpb24oKXt2YXIgYT1udWxsO214Q2xpZW50LklTX09UP2E9Ik8iOm14Q2xpZW50LklTX1NGfHxteENsaWVudC5JU19HQz9hPSJXZWJraXQiOm14Q2xpZW50LklTX01UP2E9Ik1veiI6bXhDbGllbnQuSVNfSUUmJjk8PWRvY3VtZW50LmRvY3VtZW50TW9kZSYmMTA+ZG9jdW1lbnQuZG9jdW1lbnRNb2RlJiYoYT0ibXMiKTtyZXR1cm4gZnVuY3Rpb24oYixjLGQpe2JbY109ZDtudWxsIT1hJiYwPGMubGVuZ3RoJiYoYz1hK2Muc3Vic3RyaW5nKDAsMSkudG9VcHBlckNhc2UoKStjLnN1YnN0cmluZygxKSxiW2NdPWQpfX0oKSxoYXNTY3JvbGxiYXJzOmZ1bmN0aW9uKGEpe2E9bXhVdGlscy5nZXRDdXJyZW50U3R5bGUoYSk7CnJldHVybiBudWxsIT1hJiYoInNjcm9sbCI9PWEub3ZlcmZsb3d8fCJhdXRvIj09YS5vdmVyZmxvdyl9LGJpbmQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYi5hcHBseShhLGFyZ3VtZW50cyl9fSxldmFsOmZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7aWYoMDw9YS5pbmRleE9mKCJmdW5jdGlvbiIpKXRyeXtldmFsKCJ2YXIgX214SmF2YVNjcmlwdEV4cHJlc3Npb249IithKSxiPV9teEphdmFTY3JpcHRFeHByZXNzaW9uLF9teEphdmFTY3JpcHRFeHByZXNzaW9uPW51bGx9Y2F0Y2goYyl7bXhMb2cud2FybihjLm1lc3NhZ2UrIiB3aGlsZSBldmFsdWF0aW5nICIrYSl9ZWxzZSB0cnl7Yj1ldmFsKGEpfWNhdGNoKGMpe214TG9nLndhcm4oYy5tZXNzYWdlKyIgd2hpbGUgZXZhbHVhdGluZyAiK2EpfXJldHVybiBifSxmaW5kTm9kZTpmdW5jdGlvbihhLGIsYyl7aWYoYS5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVCl7dmFyIGQ9YS5nZXRBdHRyaWJ1dGUoYik7CmlmKG51bGwhPWQmJmQ9PWMpcmV0dXJuIGF9Zm9yKGE9YS5maXJzdENoaWxkO251bGwhPWE7KXtkPW14VXRpbHMuZmluZE5vZGUoYSxiLGMpO2lmKG51bGwhPWQpcmV0dXJuIGQ7YT1hLm5leHRTaWJsaW5nfXJldHVybiBudWxsfSxnZXRGdW5jdGlvbk5hbWU6ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbDtudWxsIT1hJiYobnVsbCE9YS5uYW1lP2I9YS5uYW1lOihiPW14VXRpbHMudHJpbShhLnRvU3RyaW5nKCkpLC9eZnVuY3Rpb25ccy8udGVzdChiKSYmKGI9bXhVdGlscy5sdHJpbShiLnN1YnN0cmluZyg5KSksYT1iLmluZGV4T2YoIigiKSwwPGEmJihiPWIuc3Vic3RyaW5nKDAsYSkpKSkpO3JldHVybiBifSxpbmRleE9mOmZ1bmN0aW9uKGEsYil7aWYobnVsbCE9YSYmbnVsbCE9Yilmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKylpZihhW2NdPT1iKXJldHVybiBjO3JldHVybi0xfSxmb3JFYWNoOmZ1bmN0aW9uKGEsYil7aWYobnVsbCE9YSYmbnVsbCE9Yilmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKyliKGFbY10pOwpyZXR1cm4gYX0scmVtb3ZlOmZ1bmN0aW9uKGEsYil7dmFyIGM9bnVsbDtpZigib2JqZWN0Ij09dHlwZW9mIGIpZm9yKHZhciBkPW14VXRpbHMuaW5kZXhPZihiLGEpOzA8PWQ7KWIuc3BsaWNlKGQsMSksYz1hLGQ9bXhVdGlscy5pbmRleE9mKGIsYSk7Zm9yKHZhciBlIGluIGIpYltlXT09YSYmKGRlbGV0ZSBiW2VdLGM9YSk7cmV0dXJuIGN9LGlzTm9kZTpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gbnVsbD09YXx8aXNOYU4oYS5ub2RlVHlwZSl8fG51bGwhPWImJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKSE9Yi50b0xvd2VyQ2FzZSgpPyExOm51bGw9PWN8fGEuZ2V0QXR0cmlidXRlKGMpPT1kfSxpc0FuY2VzdG9yTm9kZTpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1iO251bGwhPWM7KXtpZihjPT1hKXJldHVybiEwO2M9Yy5wYXJlbnROb2RlfXJldHVybiExfSxnZXRDaGlsZE5vZGVzOmZ1bmN0aW9uKGEsYil7Yj1ifHxteENvbnN0YW50cy5OT0RFVFlQRV9FTEVNRU5UO2Zvcih2YXIgYz0KW10sZD1hLmZpcnN0Q2hpbGQ7bnVsbCE9ZDspZC5ub2RlVHlwZT09YiYmYy5wdXNoKGQpLGQ9ZC5uZXh0U2libGluZztyZXR1cm4gY30saW1wb3J0Tm9kZTpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIG14Q2xpZW50LklTX0lFJiYobnVsbD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHwxMD5kb2N1bWVudC5kb2N1bWVudE1vZGUpP214VXRpbHMuaW1wb3J0Tm9kZUltcGxlbWVudGF0aW9uKGEsYixjKTphLmltcG9ydE5vZGUoYixjKX0saW1wb3J0Tm9kZUltcGxlbWVudGF0aW9uOmZ1bmN0aW9uKGEsYixjKXtzd2l0Y2goYi5ub2RlVHlwZSl7Y2FzZSAxOnZhciBkPWEuY3JlYXRlRWxlbWVudChiLm5vZGVOYW1lKTtpZihiLmF0dHJpYnV0ZXMmJjA8Yi5hdHRyaWJ1dGVzLmxlbmd0aClmb3IodmFyIGU9MDtlPGIuYXR0cmlidXRlcy5sZW5ndGg7ZSsrKWQuc2V0QXR0cmlidXRlKGIuYXR0cmlidXRlc1tlXS5ub2RlTmFtZSxiLmdldEF0dHJpYnV0ZShiLmF0dHJpYnV0ZXNbZV0ubm9kZU5hbWUpKTsKaWYoYyYmYi5jaGlsZE5vZGVzJiYwPGIuY2hpbGROb2Rlcy5sZW5ndGgpZm9yKGU9MDtlPGIuY2hpbGROb2Rlcy5sZW5ndGg7ZSsrKWQuYXBwZW5kQ2hpbGQobXhVdGlscy5pbXBvcnROb2RlSW1wbGVtZW50YXRpb24oYSxiLmNoaWxkTm9kZXNbZV0sYykpO3JldHVybiBkO2Nhc2UgMzpjYXNlIDQ6Y2FzZSA4OnJldHVybiBhLmNyZWF0ZVRleHROb2RlKG51bGwhPWIubm9kZVZhbHVlP2Iubm9kZVZhbHVlOmIudmFsdWUpfX0sY3JlYXRlWG1sRG9jdW1lbnQ6ZnVuY3Rpb24oKXt2YXIgYT1udWxsO2RvY3VtZW50LmltcGxlbWVudGF0aW9uJiZkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVEb2N1bWVudD9hPWRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50KCIiLCIiLG51bGwpOiJBY3RpdmVYT2JqZWN0ImluIHdpbmRvdyYmKGE9bXhVdGlscy5jcmVhdGVNc1htbERvY3VtZW50KCkpO3JldHVybiBhfSxjcmVhdGVNc1htbERvY3VtZW50OmZ1bmN0aW9uKCl7dmFyIGE9Cm5ldyBBY3RpdmVYT2JqZWN0KCJNaWNyb3NvZnQuWE1MRE9NIik7YS5hc3luYz0hMTthLnZhbGlkYXRlT25QYXJzZT0hMTthLnJlc29sdmVFeHRlcm5hbHM9ITE7cmV0dXJuIGF9LHBhcnNlWG1sOmZ1bmN0aW9uKCl7cmV0dXJuIHdpbmRvdy5ET01QYXJzZXI/ZnVuY3Rpb24oYSl7cmV0dXJuKG5ldyBET01QYXJzZXIpLnBhcnNlRnJvbVN0cmluZyhhLCJ0ZXh0L3htbCIpfTpmdW5jdGlvbihhKXt2YXIgYj1teFV0aWxzLmNyZWF0ZU1zWG1sRG9jdW1lbnQoKTtiLmxvYWRYTUwoYSk7cmV0dXJuIGJ9fSgpLGNsZWFyU2VsZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIGRvY3VtZW50LnNlbGVjdGlvbj9mdW5jdGlvbigpe2RvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSgpfTp3aW5kb3cuZ2V0U2VsZWN0aW9uP2Z1bmN0aW9uKCl7d2luZG93LmdldFNlbGVjdGlvbigpLmVtcHR5P3dpbmRvdy5nZXRTZWxlY3Rpb24oKS5lbXB0eSgpOndpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMmJgp3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCl9OmZ1bmN0aW9uKCl7fX0oKSxyZW1vdmVXaGl0ZXNwYWNlOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPWI/YS5wcmV2aW91c1NpYmxpbmc6YS5uZXh0U2libGluZztudWxsIT1jJiZjLm5vZGVUeXBlPT1teENvbnN0YW50cy5OT0RFVFlQRV9URVhUOyl7dmFyIGQ9Yj9jLnByZXZpb3VzU2libGluZzpjLm5leHRTaWJsaW5nLGU9bXhVdGlscy5nZXRUZXh0Q29udGVudChjKTswPT1teFV0aWxzLnRyaW0oZSkubGVuZ3RoJiZjLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYyk7Yz1kfX0saHRtbEVudGl0aWVzOmZ1bmN0aW9uKGEsYil7YT1TdHJpbmcoYXx8IiIpO2E9YS5yZXBsYWNlKC8mL2csIiZhbXA7Iik7YT1hLnJlcGxhY2UoLyIvZywiJnF1b3Q7Iik7YT1hLnJlcGxhY2UoL1wnL2csIiYjMzk7Iik7YT1hLnJlcGxhY2UoLzwvZywiJmx0OyIpO2E9YS5yZXBsYWNlKC8+L2csIiZndDsiKTtpZihudWxsPT1ifHxiKWE9YS5yZXBsYWNlKC9cbi9nLAoiJiN4YTsiKTtyZXR1cm4gYX0saXNWbWw6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEmJiJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCI9PWEudGFnVXJufSxnZXRYbWw6ZnVuY3Rpb24oYSxiKXt2YXIgYz0iIjtteENsaWVudC5JU19JRXx8bXhDbGllbnQuSVNfSUUxMT9jPW14VXRpbHMuZ2V0UHJldHR5WG1sKGEsIiIsIiIsIiIpOm51bGwhPXdpbmRvdy5YTUxTZXJpYWxpemVyP2M9KG5ldyBYTUxTZXJpYWxpemVyKS5zZXJpYWxpemVUb1N0cmluZyhhKTpudWxsIT1hLnhtbCYmKGM9YS54bWwucmVwbGFjZSgvXHJcblx0W1x0XSovZywiIikucmVwbGFjZSgvPlxyXG4vZywiPiIpLnJlcGxhY2UoL1xyXG4vZywiXG4iKSk7cmV0dXJuIGMucmVwbGFjZSgvXG4vZyxifHwiJiN4YTsiKX0sZ2V0UHJldHR5WG1sOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9W107aWYobnVsbCE9YSlpZihiPW51bGwhPWI/YjoiICAiLGM9bnVsbCE9Yz9jOiIiLGQ9bnVsbCE9ZD9kOiJcbiIsbnVsbCE9CmEubmFtZXNwYWNlVVJJJiZhLm5hbWVzcGFjZVVSSSE9ZSYmKGU9YS5uYW1lc3BhY2VVUkksbnVsbD09YS5nZXRBdHRyaWJ1dGUoInhtbG5zIikmJmEuc2V0QXR0cmlidXRlKCJ4bWxucyIsYS5uYW1lc3BhY2VVUkkpKSxhLm5vZGVUeXBlPT1teENvbnN0YW50cy5OT0RFVFlQRV9ET0NVTUVOVClmLnB1c2gobXhVdGlscy5nZXRQcmV0dHlYbWwoYS5kb2N1bWVudEVsZW1lbnQsYixjLGQsZSkpO2Vsc2UgaWYoYS5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfRE9DVU1FTlRfRlJBR01FTlQpe3ZhciBnPWEuZmlyc3RDaGlsZDtpZihudWxsIT1nKWZvcig7bnVsbCE9ZzspZi5wdXNoKG14VXRpbHMuZ2V0UHJldHR5WG1sKGcsYixjLGQsZSkpLGc9Zy5uZXh0U2libGluZ31lbHNlIGlmKGEubm9kZVR5cGU9PW14Q29uc3RhbnRzLk5PREVUWVBFX0NPTU1FTlQpYT1teFV0aWxzLmdldFRleHRDb250ZW50KGEpLDA8YS5sZW5ndGgmJmYucHVzaChjKyJceDNjIS0tIithKyItLVx4M2UiKwpkKTtlbHNlIGlmKGEubm9kZVR5cGU9PW14Q29uc3RhbnRzLk5PREVUWVBFX1RFWFQpYT1teFV0aWxzLmdldFRleHRDb250ZW50KGEpLDA8YS5sZW5ndGgmJmYucHVzaChjK214VXRpbHMuaHRtbEVudGl0aWVzKG14VXRpbHMudHJpbShhKSwhMSkrZCk7ZWxzZSBpZihhLm5vZGVUeXBlPT1teENvbnN0YW50cy5OT0RFVFlQRV9DREFUQSlhPW14VXRpbHMuZ2V0VGV4dENvbnRlbnQoYSksMDxhLmxlbmd0aCYmZi5wdXNoKGMrIjwhW0NEQVRBWyIrYSsiXV0iK2QpO2Vsc2V7Zi5wdXNoKGMrIjwiK2Eubm9kZU5hbWUpO2c9YS5hdHRyaWJ1dGVzO2lmKG51bGwhPWcpZm9yKHZhciBrPTA7azxnLmxlbmd0aDtrKyspe3ZhciBsPW14VXRpbHMuaHRtbEVudGl0aWVzKGdba10udmFsdWUpO2YucHVzaCgiICIrZ1trXS5ub2RlTmFtZSsnPSInK2wrJyInKX1nPWEuZmlyc3RDaGlsZDtpZihudWxsIT1nKXtmb3IoZi5wdXNoKCI+IitkKTtudWxsIT1nOylmLnB1c2gobXhVdGlscy5nZXRQcmV0dHlYbWwoZywKYixjK2IsZCxlKSksZz1nLm5leHRTaWJsaW5nO2YucHVzaChjKyI8LyIrYS5ub2RlTmFtZSsiPiIrZCl9ZWxzZSBmLnB1c2goIiAvPiIrZCl9cmV0dXJuIGYuam9pbigiIil9LGV4dHJhY3RUZXh0V2l0aFdoaXRlc3BhY2U6ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhKXtpZigxIT1hLmxlbmd0aHx8IkJSIiE9YVswXS5ub2RlTmFtZSYmIlxuIiE9YVswXS5pbm5lckhUTUwpZm9yKHZhciBlPTA7ZTxhLmxlbmd0aDtlKyspe3ZhciBnPWFbZV07IkJSIj09Zy5ub2RlTmFtZXx8IlxuIj09Zy5pbm5lckhUTUx8fCgxPT1hLmxlbmd0aHx8MD09ZSkmJiJESVYiPT1nLm5vZGVOYW1lJiYiPGJyPiI9PWcuaW5uZXJIVE1MLnRvTG93ZXJDYXNlKCk/ZC5wdXNoKCJcbiIpOigzPT09Zy5ub2RlVHlwZXx8ND09PWcubm9kZVR5cGU/MDxnLm5vZGVWYWx1ZS5sZW5ndGgmJmQucHVzaChnLm5vZGVWYWx1ZSk6OCE9PWcubm9kZVR5cGUmJjA8Zy5jaGlsZE5vZGVzLmxlbmd0aCYmYihnLmNoaWxkTm9kZXMpLAplPGEubGVuZ3RoLTEmJjA8PW14VXRpbHMuaW5kZXhPZihjLGFbZSsxXS5ub2RlTmFtZSkmJmQucHVzaCgiXG4iKSl9fXZhciBjPSJCTE9DS1FVT1RFIERJViBIMSBIMiBIMyBINCBINSBINiBPTCBQIFBSRSBUQUJMRSBVTCIuc3BsaXQoIiAiKSxkPVtdO2IoYSk7cmV0dXJuIGQuam9pbigiIil9LHJlcGxhY2VUcmFpbGluZ05ld2xpbmVzOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPSIiOzA8YS5sZW5ndGgmJiJcbiI9PWEuY2hhckF0KGEubGVuZ3RoLTEpOylhPWEuc3Vic3RyaW5nKDAsYS5sZW5ndGgtMSksYys9YjtyZXR1cm4gYStjfSxnZXRUZXh0Q29udGVudDpmdW5jdGlvbihhKXtyZXR1cm4gbXhDbGllbnQuSVNfSUUmJnZvaWQgMCE9PWEuaW5uZXJUZXh0P2EuaW5uZXJUZXh0Om51bGwhPWE/YVt2b2lkIDA9PT1hLnRleHRDb250ZW50PyJ0ZXh0IjoidGV4dENvbnRlbnQiXToiIn0sc2V0VGV4dENvbnRlbnQ6ZnVuY3Rpb24oYSxiKXt2b2lkIDAhPT1hLmlubmVyVGV4dD9hLmlubmVyVGV4dD0KYjphW3ZvaWQgMD09PWEudGV4dENvbnRlbnQ/InRleHQiOiJ0ZXh0Q29udGVudCJdPWJ9LGdldElubmVySHRtbDpmdW5jdGlvbigpe3JldHVybiBteENsaWVudC5JU19JRT9mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YT9hLmlubmVySFRNTDoiIn06ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/KG5ldyBYTUxTZXJpYWxpemVyKS5zZXJpYWxpemVUb1N0cmluZyhhKToiIn19KCksZ2V0T3V0ZXJIdG1sOmZ1bmN0aW9uKCl7cmV0dXJuIG14Q2xpZW50LklTX0lFP2Z1bmN0aW9uKGEpe2lmKG51bGwhPWEpe2lmKG51bGwhPWEub3V0ZXJIVE1MKXJldHVybiBhLm91dGVySFRNTDt2YXIgYj1bXTtiLnB1c2goIjwiK2Eubm9kZU5hbWUpO3ZhciBjPWEuYXR0cmlidXRlcztpZihudWxsIT1jKWZvcih2YXIgZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1jW2RdLnZhbHVlO251bGwhPWUmJjA8ZS5sZW5ndGgmJihiLnB1c2goIiAiKSxiLnB1c2goY1tkXS5ub2RlTmFtZSksYi5wdXNoKCc9IicpLApiLnB1c2goZSksYi5wdXNoKCciJykpfTA9PWEuaW5uZXJIVE1MLmxlbmd0aD9iLnB1c2goIi8+Iik6KGIucHVzaCgiPiIpLGIucHVzaChhLmlubmVySFRNTCksYi5wdXNoKCI8LyIrYS5ub2RlTmFtZSsiPiIpKTtyZXR1cm4gYi5qb2luKCIiKX1yZXR1cm4iIn06ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/KG5ldyBYTUxTZXJpYWxpemVyKS5zZXJpYWxpemVUb1N0cmluZyhhKToiIn19KCksd3JpdGU6ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYik7bnVsbCE9YSYmYS5hcHBlbmRDaGlsZChjKTtyZXR1cm4gY30sd3JpdGVsbjpmdW5jdGlvbihhLGIpe3ZhciBjPWEub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShiKTtudWxsIT1hJiYoYS5hcHBlbmRDaGlsZChjKSxhLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImJyIikpKTtyZXR1cm4gY30sYnI6ZnVuY3Rpb24oYSxiKXtiPWJ8fDE7Zm9yKHZhciBjPW51bGwsCmQ9MDtkPGI7ZCsrKW51bGwhPWEmJihjPWEub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCJiciIpLGEuYXBwZW5kQ2hpbGQoYykpO3JldHVybiBjfSxidXR0b246ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbCE9Yz9jOmRvY3VtZW50O2M9Yy5jcmVhdGVFbGVtZW50KCJidXR0b24iKTtteFV0aWxzLndyaXRlKGMsYSk7bXhFdmVudC5hZGRMaXN0ZW5lcihjLCJjbGljayIsZnVuY3Rpb24oYSl7YihhKX0pO3JldHVybiBjfSxwYXJhOmZ1bmN0aW9uKGEsYil7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgicCIpO214VXRpbHMud3JpdGUoYyxiKTtudWxsIT1hJiZhLmFwcGVuZENoaWxkKGMpO3JldHVybiBjfSxhZGRUcmFuc3BhcmVudEJhY2tncm91bmRGaWx0ZXI6ZnVuY3Rpb24oYSl7YS5zdHlsZS5maWx0ZXIrPSJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGFJbWFnZUxvYWRlcihzcmM9JyIrbXhDbGllbnQuaW1hZ2VCYXNlUGF0aCsiL3RyYW5zcGFyZW50LmdpZicsIHNpemluZ01ldGhvZD0nc2NhbGUnKSJ9LApsaW5rQWN0aW9uOmZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIG14VXRpbHMubGluayhhLGIsZnVuY3Rpb24oKXtjLmV4ZWN1dGUoZCl9LGUpfSxsaW5rSW52b2tlOmZ1bmN0aW9uKGEsYixjLGQsZSxmKXtyZXR1cm4gbXhVdGlscy5saW5rKGEsYixmdW5jdGlvbigpe2NbZF0oZSl9LGYpfSxsaW5rOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNwYW4iKTtlLnN0eWxlLmNvbG9yPSJibHVlIjtlLnN0eWxlLnRleHREZWNvcmF0aW9uPSJ1bmRlcmxpbmUiO2Uuc3R5bGUuY3Vyc29yPSJwb2ludGVyIjtudWxsIT1kJiYoZS5zdHlsZS5wYWRkaW5nTGVmdD1kKyJweCIpO214RXZlbnQuYWRkTGlzdGVuZXIoZSwiY2xpY2siLGMpO214VXRpbHMud3JpdGUoZSxiKTtudWxsIT1hJiZhLmFwcGVuZENoaWxkKGUpO3JldHVybiBlfSxnZXREb2N1bWVudFNpemU6ZnVuY3Rpb24oKXt2YXIgYT1kb2N1bWVudC5ib2R5LGI9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Owp0cnl7cmV0dXJuIG5ldyBteFJlY3RhbmdsZSgwLDAsYS5jbGllbnRXaWR0aHx8Yi5jbGllbnRXaWR0aCxNYXRoLm1heChhLmNsaWVudEhlaWdodHx8MCxiLmNsaWVudEhlaWdodCkpfWNhdGNoKGMpe3JldHVybiBuZXcgbXhSZWN0YW5nbGV9fSxmaXQ6ZnVuY3Rpb24oYSl7dmFyIGI9bXhVdGlscy5nZXREb2N1bWVudFNpemUoKSxjPXBhcnNlSW50KGEub2Zmc2V0TGVmdCksZD1wYXJzZUludChhLm9mZnNldFdpZHRoKSxlPW14VXRpbHMuZ2V0RG9jdW1lbnRTY3JvbGxPcmlnaW4oYS5vd25lckRvY3VtZW50KSxmPWUueCxlPWUueSxnPWYrYi53aWR0aDtjK2Q+ZyYmKGEuc3R5bGUubGVmdD1NYXRoLm1heChmLGctZCkrInB4Iik7Yz1wYXJzZUludChhLm9mZnNldFRvcCk7ZD1wYXJzZUludChhLm9mZnNldEhlaWdodCk7Yj1lK2IuaGVpZ2h0O2MrZD5iJiYoYS5zdHlsZS50b3A9TWF0aC5tYXgoZSxiLWQpKyJweCIpfSxsb2FkOmZ1bmN0aW9uKGEpe2E9bmV3IG14WG1sUmVxdWVzdChhLG51bGwsCiJHRVQiLCExKTthLnNlbmQoKTtyZXR1cm4gYX0sZ2V0OmZ1bmN0aW9uKGEsYixjLGQsZSxmLGcpe2E9bmV3IG14WG1sUmVxdWVzdChhLG51bGwsIkdFVCIpO3ZhciBrPWEuc2V0UmVxdWVzdEhlYWRlcnM7ZyYmKGEuc2V0UmVxdWVzdEhlYWRlcnM9ZnVuY3Rpb24oYSxiKXtrLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtmb3IodmFyIGMgaW4gZylhLnNldFJlcXVlc3RIZWFkZXIoYyxnW2NdKX0pO251bGwhPWQmJmEuc2V0QmluYXJ5KGQpO2Euc2VuZChiLGMsZSxmKTtyZXR1cm4gYX0sZ2V0QWxsOmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9YS5sZW5ndGgsZT1bXSxmPTAsZz1mdW5jdGlvbigpezA9PWYmJm51bGwhPWMmJmMoKTtmKyt9LGs9MDtrPGEubGVuZ3RoO2srKykoZnVuY3Rpb24oYSxjKXtteFV0aWxzLmdldChhLGZ1bmN0aW9uKGEpe3ZhciBmPWEuZ2V0U3RhdHVzKCk7MjAwPmZ8fDI5OTxmP2coKTooZVtjXT1hLGQtLSwwPT1kJiZiKGUpKX0sZyl9KShhW2tdLGspOzA9PWQmJgpiKGUpfSxwb3N0OmZ1bmN0aW9uKGEsYixjLGQpe3JldHVybihuZXcgbXhYbWxSZXF1ZXN0KGEsYikpLnNlbmQoYyxkKX0sc3VibWl0OmZ1bmN0aW9uKGEsYixjLGQpe3JldHVybihuZXcgbXhYbWxSZXF1ZXN0KGEsYikpLnNpbXVsYXRlKGMsZCl9LGxvYWRJbnRvOmZ1bmN0aW9uKGEsYixjKXtteENsaWVudC5JU19JRT9iLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpezQ9PWIucmVhZHlTdGF0ZSYmYygpfTpiLmFkZEV2ZW50TGlzdGVuZXIoImxvYWQiLGMsITEpO2IubG9hZChhKX0sZ2V0VmFsdWU6ZnVuY3Rpb24oYSxiLGMpe2E9bnVsbCE9YT9hW2JdOm51bGw7bnVsbD09YSYmKGE9Yyk7cmV0dXJuIGF9LGdldE51bWJlcjpmdW5jdGlvbihhLGIsYyl7YT1udWxsIT1hP2FbYl06bnVsbDtudWxsPT1hJiYoYT1jfHwwKTtyZXR1cm4gTnVtYmVyKGEpfSxnZXRDb2xvcjpmdW5jdGlvbihhLGIsYyl7YT1udWxsIT1hP2FbYl06bnVsbDtudWxsPT1hP2E9YzphPT1teENvbnN0YW50cy5OT05FJiYKKGE9bnVsbCk7cmV0dXJuIGF9LGNsb25lOmZ1bmN0aW9uKGEsYixjKXtjPW51bGwhPWM/YzohMTt2YXIgZD1udWxsO2lmKG51bGwhPWEmJiJmdW5jdGlvbiI9PXR5cGVvZiBhLmNvbnN0cnVjdG9yKXt2YXIgZD1uZXcgYS5jb25zdHJ1Y3RvcixlO2ZvcihlIGluIGEpZSE9bXhPYmplY3RJZGVudGl0eS5GSUVMRF9OQU1FJiYobnVsbD09Ynx8MD5teFV0aWxzLmluZGV4T2YoYixlKSkmJihkW2VdPWN8fCJvYmplY3QiIT10eXBlb2YgYVtlXT9hW2VdOm14VXRpbHMuY2xvbmUoYVtlXSkpfXJldHVybiBkfSxlcXVhbFBvaW50czpmdW5jdGlvbihhLGIpe2lmKG51bGw9PWEmJm51bGwhPWJ8fG51bGwhPWEmJm51bGw9PWJ8fG51bGwhPWEmJm51bGwhPWImJmEubGVuZ3RoIT1iLmxlbmd0aClyZXR1cm4hMTtpZihudWxsIT1hJiZudWxsIT1iKWZvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKWlmKG51bGwhPWFbY10mJm51bGw9PWJbY118fG51bGw9PWFbY10mJm51bGwhPWJbY118fG51bGwhPWFbY10mJgpudWxsIT1iW2NdJiYoYVtjXS54IT1iW2NdLnh8fGFbY10ueSE9YltjXS55KSlyZXR1cm4hMTtyZXR1cm4hMH0sZXF1YWxFbnRyaWVzOmZ1bmN0aW9uKGEsYil7dmFyIGM9MDtpZihudWxsPT1hJiZudWxsIT1ifHxudWxsIT1hJiZudWxsPT1ifHxudWxsIT1hJiZudWxsIT1iJiZhLmxlbmd0aCE9Yi5sZW5ndGgpcmV0dXJuITE7aWYobnVsbCE9YSYmbnVsbCE9Yil7Zm9yKHZhciBkIGluIGIpYysrO2ZvcihkIGluIGEpaWYoYy0tLCEobXhVdGlscy5pc05hTihhW2RdKSYmbXhVdGlscy5pc05hTihiW2RdKXx8YVtkXT09YltkXSkpcmV0dXJuITF9cmV0dXJuIDA9PWN9LHJlbW92ZUR1cGxpY2F0ZXM6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPW5ldyBteERpY3Rpb25hcnksYz1bXSxkPTA7ZDxhLmxlbmd0aDtkKyspYi5nZXQoYVtkXSl8fChjLnB1c2goYVtkXSksYi5wdXQoYVtkXSwhMCkpO3JldHVybiBjfSxpc05hTjpmdW5jdGlvbihhKXtyZXR1cm4ibnVtYmVyIj09dHlwZW9mIGEmJmlzTmFOKGEpfSwKZXh0ZW5kOmZ1bmN0aW9uKGEsYil7dmFyIGM9ZnVuY3Rpb24oKXt9O2MucHJvdG90eXBlPWIucHJvdG90eXBlO2EucHJvdG90eXBlPW5ldyBjO2EucHJvdG90eXBlLmNvbnN0cnVjdG9yPWF9LHRvU3RyaW5nOmZ1bmN0aW9uKGEpe3ZhciBiPSIiLGM7Zm9yKGMgaW4gYSl0cnl7aWYobnVsbD09YVtjXSliKz1jKyIgPSBbbnVsbF1cbiI7ZWxzZSBpZigiZnVuY3Rpb24iPT10eXBlb2YgYVtjXSliKz1jKyIgPT4gW0Z1bmN0aW9uXVxuIjtlbHNlIGlmKCJvYmplY3QiPT10eXBlb2YgYVtjXSl2YXIgZD1teFV0aWxzLmdldEZ1bmN0aW9uTmFtZShhW2NdLmNvbnN0cnVjdG9yKSxiPWIrKGMrIiA9PiBbIitkKyJdXG4iKTtlbHNlIGIrPWMrIiA9ICIrYVtjXSsiXG4ifWNhdGNoKGUpe2IrPWMrIj0iK2UubWVzc2FnZX1yZXR1cm4gYn0sdG9SYWRpYW5zOmZ1bmN0aW9uKGEpe3JldHVybiBNYXRoLlBJKmEvMTgwfSx0b0RlZ3JlZTpmdW5jdGlvbihhKXtyZXR1cm4gMTgwKmEvTWF0aC5QSX0sYXJjVG9DdXJ2ZXM6ZnVuY3Rpb24oYSwKYixjLGQsZSxmLGcsayxsKXtrLT1hO2wtPWI7aWYoMD09PWN8fDA9PT1kKXJldHVybiBxO2M9TWF0aC5hYnMoYyk7ZD1NYXRoLmFicyhkKTt2YXIgbT0tay8yLG49LWwvMixwPU1hdGguY29zKGUqTWF0aC5QSS8xODApLHE9TWF0aC5zaW4oZSpNYXRoLlBJLzE4MCk7ZT1wKm0rcSpuO3ZhciBtPS0xKnEqbStwKm4sbj1lKmUscj1tKm0sdD1jKmMsdT1kKmQseD1uL3Qrci91OzE8eD8oYyo9TWF0aC5zcXJ0KHgpLGQqPU1hdGguc3FydCh4KSxmPTApOih4PTEsZj09PWcmJih4PS0xKSxmPXgqTWF0aC5zcXJ0KCh0KnUtdCpyLXUqbikvKHQqcit1Km4pKSk7bj1mKmMqbS9kO3I9LTEqZipkKmUvYztrPXAqbi1xKnIray8yO2w9cSpuK3AqcitsLzI7dD1NYXRoLmF0YW4yKChtLXIpL2QsKGUtbikvYyktTWF0aC5hdGFuMigwLDEpO2Y9MDw9dD90OjIqTWF0aC5QSSt0O3Q9TWF0aC5hdGFuMigoLW0tcikvZCwoLWUtbikvYyktTWF0aC5hdGFuMigobS1yKS9kLChlLW4pL2MpO2U9MDw9dD90OjIqCk1hdGguUEkrdDswPT1nJiYwPGU/ZS09MipNYXRoLlBJOjAhPWcmJjA+ZSYmKGUrPTIqTWF0aC5QSSk7Zz0yKmUvTWF0aC5QSTtnPU1hdGguY2VpbCgwPmc/LTEqZzpnKTtlLz1nO209OC8zKk1hdGguc2luKGUvNCkqTWF0aC5zaW4oZS80KS9NYXRoLnNpbihlLzIpO249cCpjO3AqPWQ7Yyo9cTtkKj1xO2Zvcih2YXIgeT1NYXRoLmNvcyhmKSxCPU1hdGguc2luKGYpLHI9LW0qKG4qQitkKnkpLHQ9LW0qKGMqQi1wKnkpLHE9W10sQT0wO0E8ZzsrK0Epe2YrPWU7dmFyIHk9TWF0aC5jb3MoZiksQj1NYXRoLnNpbihmKSx1PW4qeS1kKkIrayx4PWMqeStwKkIrbCx6PS1tKihuKkIrZCp5KSx5PS1tKihjKkItcCp5KSxCPTYqQTtxW0JdPU51bWJlcihyK2EpO3FbQisxXT1OdW1iZXIodCtiKTtxW0IrMl09TnVtYmVyKHUteithKTtxW0IrM109TnVtYmVyKHgteStiKTtxW0IrNF09TnVtYmVyKHUrYSk7cVtCKzVdPU51bWJlcih4K2IpO3I9dSt6O3Q9eCt5fXJldHVybiBxfSxnZXRCb3VuZGluZ0JveDpmdW5jdGlvbihhLApiLGMpe3ZhciBkPW51bGw7aWYobnVsbCE9YSYmbnVsbCE9YiYmMCE9Yil7Yj1teFV0aWxzLnRvUmFkaWFucyhiKTt2YXIgZD1NYXRoLmNvcyhiKSxlPU1hdGguc2luKGIpO2M9bnVsbCE9Yz9jOm5ldyBteFBvaW50KGEueCthLndpZHRoLzIsYS55K2EuaGVpZ2h0LzIpO3ZhciBmPW5ldyBteFBvaW50KGEueCxhLnkpO2I9bmV3IG14UG9pbnQoYS54K2Eud2lkdGgsYS55KTt2YXIgZz1uZXcgbXhQb2ludChiLngsYS55K2EuaGVpZ2h0KTthPW5ldyBteFBvaW50KGEueCxnLnkpO2Y9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQoZixkLGUsYyk7Yj1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChiLGQsZSxjKTtnPW14VXRpbHMuZ2V0Um90YXRlZFBvaW50KGcsZCxlLGMpO2E9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQoYSxkLGUsYyk7ZD1uZXcgbXhSZWN0YW5nbGUoZi54LGYueSwwLDApO2QuYWRkKG5ldyBteFJlY3RhbmdsZShiLngsYi55LDAsMCkpO2QuYWRkKG5ldyBteFJlY3RhbmdsZShnLngsCmcueSwwLDApKTtkLmFkZChuZXcgbXhSZWN0YW5nbGUoYS54LGEueSwwLDApKX1yZXR1cm4gZH0sZ2V0Um90YXRlZFBvaW50OmZ1bmN0aW9uKGEsYixjLGQpe2Q9bnVsbCE9ZD9kOm5ldyBteFBvaW50O3ZhciBlPWEueC1kLng7YT1hLnktZC55O3JldHVybiBuZXcgbXhQb2ludChlKmItYSpjK2QueCxhKmIrZSpjK2QueSl9LGdldFBvcnRDb25zdHJhaW50czpmdW5jdGlvbihhLGIsYyxkKXtiPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9QT1JUX0NPTlNUUkFJTlQsbXhVdGlscy5nZXRWYWx1ZShiLnN0eWxlLGM/bXhDb25zdGFudHMuU1RZTEVfU09VUkNFX1BPUlRfQ09OU1RSQUlOVDpteENvbnN0YW50cy5TVFlMRV9UQVJHRVRfUE9SVF9DT05TVFJBSU5ULG51bGwpKTtpZihudWxsPT1iKXJldHVybiBkO2Q9Yi50b1N0cmluZygpO2I9bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfTk9ORTtjPTA7MT09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1BPUlRfQ09OU1RSQUlOVF9ST1RBVElPTiwKMCkmJihjPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTiwwKSk7YT0wOzQ1PGM/KGE9MSwxMzU8PWMmJihhPTIpKTotNDU+YyYmKGE9MywtMTM1Pj1jJiYoYT0yKSk7aWYoMDw9ZC5pbmRleE9mKG14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSCkpc3dpdGNoKGEpe2Nhc2UgMDpifD1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19OT1JUSDticmVhaztjYXNlIDE6Ynw9bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfRUFTVDticmVhaztjYXNlIDI6Ynw9bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfU09VVEg7YnJlYWs7Y2FzZSAzOmJ8PW14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX1dFU1R9aWYoMDw9ZC5pbmRleE9mKG14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUKSlzd2l0Y2goYSl7Y2FzZSAwOmJ8PW14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX1dFU1Q7YnJlYWs7Y2FzZSAxOmJ8PW14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX05PUlRIOwpicmVhaztjYXNlIDI6Ynw9bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfRUFTVDticmVhaztjYXNlIDM6Ynw9bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfU09VVEh9aWYoMDw9ZC5pbmRleE9mKG14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSCkpc3dpdGNoKGEpe2Nhc2UgMDpifD1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19TT1VUSDticmVhaztjYXNlIDE6Ynw9bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfV0VTVDticmVhaztjYXNlIDI6Ynw9bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfTk9SVEg7YnJlYWs7Y2FzZSAzOmJ8PW14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX0VBU1R9aWYoMDw9ZC5pbmRleE9mKG14Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNUKSlzd2l0Y2goYSl7Y2FzZSAwOmJ8PW14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX0VBU1Q7YnJlYWs7Y2FzZSAxOmJ8PW14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX1NPVVRIO2JyZWFrO2Nhc2UgMjpifD0KbXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfV0VTVDticmVhaztjYXNlIDM6Ynw9bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfTk9SVEh9cmV0dXJuIGJ9LHJldmVyc2VQb3J0Q29uc3RyYWludHM6ZnVuY3Rpb24oYSl7dmFyIGI7Yj0oYSZteENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19XRVNUKTw8MztifD0oYSZteENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19OT1JUSCk8PDE7Ynw9KGEmbXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfU09VVEgpPj4xO3JldHVybiBifChhJm14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX0VBU1QpPj4zfSxmaW5kTmVhcmVzdFNlZ21lbnQ6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPS0xO2lmKDA8YS5hYnNvbHV0ZVBvaW50cy5sZW5ndGgpZm9yKHZhciBlPWEuYWJzb2x1dGVQb2ludHNbMF0sZj1udWxsLGc9MTtnPGEuYWJzb2x1dGVQb2ludHMubGVuZ3RoO2crKyl7dmFyIGs9YS5hYnNvbHV0ZVBvaW50c1tnXSxlPW14VXRpbHMucHRTZWdEaXN0U3EoZS54LAplLnksay54LGsueSxiLGMpO2lmKG51bGw9PWZ8fGU8ZilmPWUsZD1nLTE7ZT1rfXJldHVybiBkfSxnZXREaXJlY3RlZEJvdW5kczpmdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPW14VXRpbHMuZ2V0VmFsdWUoYyxteENvbnN0YW50cy5TVFlMRV9ESVJFQ1RJT04sbXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1QpO2Q9bnVsbCE9ZD9kOm14VXRpbHMuZ2V0VmFsdWUoYyxteENvbnN0YW50cy5TVFlMRV9GTElQSCwhMSk7ZT1udWxsIT1lP2U6bXhVdGlscy5nZXRWYWx1ZShjLG14Q29uc3RhbnRzLlNUWUxFX0ZMSVBWLCExKTtiLng9TWF0aC5yb3VuZChNYXRoLm1heCgwLE1hdGgubWluKGEud2lkdGgsYi54KSkpO2IueT1NYXRoLnJvdW5kKE1hdGgubWF4KDAsTWF0aC5taW4oYS5oZWlnaHQsYi55KSkpO2Iud2lkdGg9TWF0aC5yb3VuZChNYXRoLm1heCgwLE1hdGgubWluKGEud2lkdGgsYi53aWR0aCkpKTtiLmhlaWdodD1NYXRoLnJvdW5kKE1hdGgubWF4KDAsTWF0aC5taW4oYS5oZWlnaHQsCmIuaGVpZ2h0KSkpO2lmKGUmJihmPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEh8fGY9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSCl8fGQmJihmPT1teENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVHx8Zj09bXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1QpKWM9Yi54LGIueD1iLndpZHRoLGIud2lkdGg9YztpZihkJiYoZj09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIfHxmPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEgpfHxlJiYoZj09bXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1R8fGY9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUKSljPWIueSxiLnk9Yi5oZWlnaHQsYi5oZWlnaHQ9YztkPW14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUoYik7Zj09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIPyhkLnk9Yi54LGQueD1iLmhlaWdodCxkLndpZHRoPWIueSxkLmhlaWdodD1iLndpZHRoKTpmPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVD8oZC55PWIuaGVpZ2h0LApkLng9Yi53aWR0aCxkLndpZHRoPWIueCxkLmhlaWdodD1iLnkpOmY9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSCYmKGQueT1iLndpZHRoLGQueD1iLnksZC53aWR0aD1iLmhlaWdodCxkLmhlaWdodD1iLngpO3JldHVybiBuZXcgbXhSZWN0YW5nbGUoYS54K2QueCxhLnkrZC55LGEud2lkdGgtZC53aWR0aC1kLngsYS5oZWlnaHQtZC5oZWlnaHQtZC55KX0sZ2V0UGVyaW1ldGVyUG9pbnQ6ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1udWxsLGU9MDtlPGEubGVuZ3RoLTE7ZSsrKXt2YXIgZj1teFV0aWxzLmludGVyc2VjdGlvbihhW2VdLngsYVtlXS55LGFbZSsxXS54LGFbZSsxXS55LGIueCxiLnksYy54LGMueSk7aWYobnVsbCE9Zil7dmFyIGc9Yy54LWYueCxrPWMueS1mLnksZj17cDpmLGRpc3RTcTprKmsrZypnfTtudWxsIT1mJiYobnVsbD09ZHx8ZC5kaXN0U3E+Zi5kaXN0U3EpJiYoZD1mKX19cmV0dXJuIG51bGwhPWQ/ZC5wOm51bGx9LHJlY3RhbmdsZUludGVyc2VjdHNTZWdtZW50OmZ1bmN0aW9uKGEsCmIsYyl7dmFyIGQ9YS55LGU9YS54LGY9ZCthLmhlaWdodCxnPWUrYS53aWR0aDthPWIueDt2YXIgaz1jLng7Yi54PmMueCYmKGE9Yy54LGs9Yi54KTtrPmcmJihrPWcpO2E8ZSYmKGE9ZSk7aWYoYT5rKXJldHVybiExO3ZhciBlPWIueSxnPWMueSxsPWMueC1iLng7MUUtNzxNYXRoLmFicyhsKSYmKGM9KGMueS1iLnkpL2wsYj1iLnktYypiLngsZT1jKmErYixnPWMqaytiKTtlPmcmJihiPWcsZz1lLGU9Yik7Zz5mJiYoZz1mKTtlPGQmJihlPWQpO3JldHVybiBlPmc/ITE6ITB9LGNvbnRhaW5zOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYS54PD1iJiZhLngrYS53aWR0aD49YiYmYS55PD1jJiZhLnkrYS5oZWlnaHQ+PWN9LGludGVyc2VjdHM6ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLndpZHRoLGQ9YS5oZWlnaHQsZT1iLndpZHRoLGY9Yi5oZWlnaHQ7aWYoMD49ZXx8MD49Znx8MD49Y3x8MD49ZClyZXR1cm4hMTt2YXIgZz1hLngsaz1hLnksbD1iLngsbT1iLnksZT1lK2wsZj1mK20sYz1jKwpnLGQ9ZCtrO3JldHVybihlPGx8fGU+ZykmJihmPG18fGY+aykmJihjPGd8fGM+bCkmJihkPGt8fGQ+bSl9LGludGVyc2VjdHNIb3RzcG90OmZ1bmN0aW9uKGEsYixjLGQsZSxmKXtkPW51bGwhPWQ/ZDoxO2U9bnVsbCE9ZT9lOjA7Zj1udWxsIT1mP2Y6MDtpZigwPGQpe3ZhciBnPWEuZ2V0Q2VudGVyWCgpLGs9YS5nZXRDZW50ZXJZKCksbD1hLndpZHRoLG09YS5oZWlnaHQsbj1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFKSphLnZpZXcuc2NhbGU7MDxuJiYobXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0hPUklaT05UQUwsITApPyhrPWEueStuLzIsbT1uKTooZz1hLngrbi8yLGw9bikpO2w9TWF0aC5tYXgoZSxsKmQpO209TWF0aC5tYXgoZSxtKmQpOzA8ZiYmKGw9TWF0aC5taW4obCxmKSxtPU1hdGgubWluKG0sZikpO2Q9bmV3IG14UmVjdGFuZ2xlKGctbC8yLGstbS8yLGwsbSk7Zz1teFV0aWxzLnRvUmFkaWFucyhteFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsCm14Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OKXx8MCk7MCE9ZyYmKGU9TWF0aC5jb3MoLWcpLGY9TWF0aC5zaW4oLWcpLGc9bmV3IG14UG9pbnQoYS5nZXRDZW50ZXJYKCksYS5nZXRDZW50ZXJZKCkpLGE9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQobmV3IG14UG9pbnQoYixjKSxlLGYsZyksYj1hLngsYz1hLnkpO3JldHVybiBteFV0aWxzLmNvbnRhaW5zKGQsYixjKX1yZXR1cm4hMH0sZ2V0T2Zmc2V0OmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTAsZD0wLGU9ITEsZj1hLGc9ZG9jdW1lbnQuYm9keSxrPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtudWxsIT1mJiZmIT1nJiZmIT1rJiYhZTspe3ZhciBsPW14VXRpbHMuZ2V0Q3VycmVudFN0eWxlKGYpO251bGwhPWwmJihlPWV8fCJmaXhlZCI9PWwucG9zaXRpb24pO2Y9Zi5wYXJlbnROb2RlfWJ8fGV8fChlPW14VXRpbHMuZ2V0RG9jdW1lbnRTY3JvbGxPcmlnaW4oYS5vd25lckRvY3VtZW50KSxjKz1lLngsZCs9ZS55KTtlPWEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7Cm51bGwhPWUmJihjKz1lLmxlZnQsZCs9ZS50b3ApO3JldHVybiBuZXcgbXhQb2ludChjLGQpfSxnZXREb2N1bWVudFNjcm9sbE9yaWdpbjpmdW5jdGlvbihhKXtpZihteENsaWVudC5JU19RVUlSS1MpcmV0dXJuIG5ldyBteFBvaW50KGEuYm9keS5zY3JvbGxMZWZ0LGEuYm9keS5zY3JvbGxUb3ApO2E9YS5kZWZhdWx0Vmlld3x8YS5wYXJlbnRXaW5kb3c7cmV0dXJuIG5ldyBteFBvaW50KG51bGwhPWEmJnZvaWQgMCE9PXdpbmRvdy5wYWdlWE9mZnNldD93aW5kb3cucGFnZVhPZmZzZXQ6KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudHx8ZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlfHxkb2N1bWVudC5ib2R5KS5zY3JvbGxMZWZ0LG51bGwhPWEmJnZvaWQgMCE9PXdpbmRvdy5wYWdlWU9mZnNldD93aW5kb3cucGFnZVlPZmZzZXQ6KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudHx8ZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlfHxkb2N1bWVudC5ib2R5KS5zY3JvbGxUb3ApfSxnZXRTY3JvbGxPcmlnaW46ZnVuY3Rpb24oYSwKYixjKXtiPW51bGwhPWI/YjohMTtjPW51bGwhPWM/YzohMDtmb3IodmFyIGQ9bnVsbCE9YT9hLm93bmVyRG9jdW1lbnQ6ZG9jdW1lbnQsZT1kLmJvZHksZj1kLmRvY3VtZW50RWxlbWVudCxnPW5ldyBteFBvaW50LGs9ITE7bnVsbCE9YSYmYSE9ZSYmYSE9Zjspe2lzTmFOKGEuc2Nyb2xsTGVmdCl8fGlzTmFOKGEuc2Nyb2xsVG9wKXx8KGcueCs9YS5zY3JvbGxMZWZ0LGcueSs9YS5zY3JvbGxUb3ApO3ZhciBsPW14VXRpbHMuZ2V0Q3VycmVudFN0eWxlKGEpO251bGwhPWwmJihrPWt8fCJmaXhlZCI9PWwucG9zaXRpb24pO2E9Yj9hLnBhcmVudE5vZGU6bnVsbH0hayYmYyYmKGE9bXhVdGlscy5nZXREb2N1bWVudFNjcm9sbE9yaWdpbihkKSxnLngrPWEueCxnLnkrPWEueSk7cmV0dXJuIGd9LGNvbnZlcnRQb2ludDpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9bXhVdGlscy5nZXRTY3JvbGxPcmlnaW4oYSwhMSk7YT1teFV0aWxzLmdldE9mZnNldChhKTthLngtPWQueDthLnktPWQueTtyZXR1cm4gbmV3IG14UG9pbnQoYi0KYS54LGMtYS55KX0sbHRyaW06ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbnVsbCE9YT9hLnJlcGxhY2UobmV3IFJlZ0V4cCgiXlsiKyhifHwiXFxzIikrIl0rIiwiZyIpLCIiKTpudWxsfSxydHJpbTpmdW5jdGlvbihhLGIpe3JldHVybiBudWxsIT1hP2EucmVwbGFjZShuZXcgUmVnRXhwKCJbIisoYnx8IlxccyIpKyJdKyQiLCJnIiksIiIpOm51bGx9LHRyaW06ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbXhVdGlscy5sdHJpbShteFV0aWxzLnJ0cmltKGEsYiksYil9LGlzTnVtZXJpYzpmdW5jdGlvbihhKXtyZXR1cm4haXNOYU4ocGFyc2VGbG9hdChhKSkmJmlzRmluaXRlKGEpJiYoInN0cmluZyIhPXR5cGVvZiBhfHwwPmEudG9Mb3dlckNhc2UoKS5pbmRleE9mKCIweCIpKX0saXNJbnRlZ2VyOmZ1bmN0aW9uKGEpe3JldHVybiBTdHJpbmcocGFyc2VJbnQoYSkpPT09U3RyaW5nKGEpfSxtb2Q6ZnVuY3Rpb24oYSxiKXtyZXR1cm4oYSViK2IpJWJ9LGludGVyc2VjdGlvbjpmdW5jdGlvbihhLGIsCmMsZCxlLGYsZyxrKXt2YXIgbD0oay1mKSooYy1hKS0oZy1lKSooZC1iKTtnPSgoZy1lKSooYi1mKS0oay1mKSooYS1lKSkvbDtlPSgoYy1hKSooYi1mKS0oZC1iKSooYS1lKSkvbDtyZXR1cm4gMDw9ZyYmMT49ZyYmMDw9ZSYmMT49ZT9uZXcgbXhQb2ludChhK2cqKGMtYSksYitnKihkLWIpKTpudWxsfSxwdFNlZ0Rpc3RTcTpmdW5jdGlvbihhLGIsYyxkLGUsZil7Yy09YTtkLT1iO2UtPWE7Zi09YjswPj1lKmMrZipkP2M9MDooZT1jLWUsZj1kLWYsYT1lKmMrZipkLGM9MD49YT8wOmEqYS8oYypjK2QqZCkpO2U9ZSplK2YqZi1jOzA+ZSYmKGU9MCk7cmV0dXJuIGV9LHB0TGluZURpc3Q6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3JldHVybiBNYXRoLmFicygoZC1iKSplLShjLWEpKmYrYypiLWQqYSkvTWF0aC5zcXJ0KChkLWIpKihkLWIpKyhjLWEpKihjLWEpKX0scmVsYXRpdmVDY3c6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2MtPWE7ZC09YjtlLT1hO2YtPWI7YT1lKmQtZipjOzA9PWEmJgooYT1lKmMrZipkLDA8YSYmKGE9KGUtYykqYysoZi1kKSpkLDA+YSYmKGE9MCkpKTtyZXR1cm4gMD5hPy0xOjA8YT8xOjB9LGFuaW1hdGVDaGFuZ2VzOmZ1bmN0aW9uKGEsYil7bXhFZmZlY3RzLmFuaW1hdGVDaGFuZ2VzLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sY2FzY2FkZU9wYWNpdHk6ZnVuY3Rpb24oYSxiLGMpe214RWZmZWN0cy5jYXNjYWRlT3BhY2l0eS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGZhZGVPdXQ6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe214RWZmZWN0cy5mYWRlT3V0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sc2V0T3BhY2l0eTpmdW5jdGlvbihhLGIpe214VXRpbHMuaXNWbWwoYSk/YS5zdHlsZS5maWx0ZXI9MTAwPD1iPyIiOiJhbHBoYShvcGFjaXR5PSIrYi81KyIpIjpteENsaWVudC5JU19JRSYmKCJ1bmRlZmluZWQiPT09dHlwZW9mIGRvY3VtZW50LmRvY3VtZW50TW9kZXx8OT5kb2N1bWVudC5kb2N1bWVudE1vZGUpP2Euc3R5bGUuZmlsdGVyPTEwMDw9Yj8iIjoKImFscGhhKG9wYWNpdHk9IitiKyIpIjphLnN0eWxlLm9wYWNpdHk9Yi8xMDB9LGNyZWF0ZUltYWdlOmZ1bmN0aW9uKGEpe3ZhciBiO214Q2xpZW50LklTX0lFNiYmIkNTUzFDb21wYXQiIT1kb2N1bWVudC5jb21wYXRNb2RlPyhiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobXhDbGllbnQuVk1MX1BSRUZJWCsiOmltYWdlIiksYi5zZXRBdHRyaWJ1dGUoInNyYyIsYSksYi5zdHlsZS5ib3JkZXJTdHlsZT0ibm9uZSIpOihiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImltZyIpLGIuc2V0QXR0cmlidXRlKCJzcmMiLGEpLGIuc2V0QXR0cmlidXRlKCJib3JkZXIiLCIwIikpO3JldHVybiBifSxzb3J0Q2VsbHM6ZnVuY3Rpb24oYSxiKXtiPW51bGwhPWI/YjohMDt2YXIgYz1uZXcgbXhEaWN0aW9uYXJ5O2Euc29ydChmdW5jdGlvbihhLGUpe3ZhciBkPWMuZ2V0KGEpO251bGw9PWQmJihkPW14Q2VsbFBhdGguY3JlYXRlKGEpLnNwbGl0KG14Q2VsbFBhdGguUEFUSF9TRVBBUkFUT1IpLGMucHV0KGEsCmQpKTt2YXIgZz1jLmdldChlKTtudWxsPT1nJiYoZz1teENlbGxQYXRoLmNyZWF0ZShlKS5zcGxpdChteENlbGxQYXRoLlBBVEhfU0VQQVJBVE9SKSxjLnB1dChlLGcpKTtkPW14Q2VsbFBhdGguY29tcGFyZShkLGcpO3JldHVybiAwPT1kPzA6MDxkPT1iPzE6LTF9KTtyZXR1cm4gYX0sZ2V0U3R5bGVuYW1lOmZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiYoYT1hLnNwbGl0KCI7IilbMF0sMD5hLmluZGV4T2YoIj0iKSk/YToiIn0sZ2V0U3R5bGVuYW1lczpmdW5jdGlvbihhKXt2YXIgYj1bXTtpZihudWxsIT1hKXthPWEuc3BsaXQoIjsiKTtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKykwPmFbY10uaW5kZXhPZigiPSIpJiZiLnB1c2goYVtjXSl9cmV0dXJuIGJ9LGluZGV4T2ZTdHlsZW5hbWU6ZnVuY3Rpb24oYSxiKXtpZihudWxsIT1hJiZudWxsIT1iKWZvcih2YXIgYz1hLnNwbGl0KCI7IiksZD0wLGU9MDtlPGMubGVuZ3RoO2UrKyl7aWYoY1tlXT09YilyZXR1cm4gZDtkKz1jW2VdLmxlbmd0aCsKMX1yZXR1cm4tMX0sYWRkU3R5bGVuYW1lOmZ1bmN0aW9uKGEsYil7MD5teFV0aWxzLmluZGV4T2ZTdHlsZW5hbWUoYSxiKSYmKG51bGw9PWE/YT0iIjowPGEubGVuZ3RoJiYiOyIhPWEuY2hhckF0KGEubGVuZ3RoLTEpJiYoYSs9IjsiKSxhKz1iKTtyZXR1cm4gYX0scmVtb3ZlU3R5bGVuYW1lOmZ1bmN0aW9uKGEsYil7dmFyIGM9W107aWYobnVsbCE9YSlmb3IodmFyIGQ9YS5zcGxpdCgiOyIpLGU9MDtlPGQubGVuZ3RoO2UrKylkW2VdIT1iJiZjLnB1c2goZFtlXSk7cmV0dXJuIGMuam9pbigiOyIpfSxyZW1vdmVBbGxTdHlsZW5hbWVzOmZ1bmN0aW9uKGEpe3ZhciBiPVtdO2lmKG51bGwhPWEpe2E9YS5zcGxpdCgiOyIpO2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKTA8PWFbY10uaW5kZXhPZigiPSIpJiZiLnB1c2goYVtjXSl9cmV0dXJuIGIuam9pbigiOyIpfSxzZXRDZWxsU3R5bGVzOmZ1bmN0aW9uKGEsYixjLGQpe2lmKG51bGwhPWImJjA8Yi5sZW5ndGgpe2EuYmVnaW5VcGRhdGUoKTsKdHJ5e2Zvcih2YXIgZT0wO2U8Yi5sZW5ndGg7ZSsrKWlmKG51bGwhPWJbZV0pe3ZhciBmPW14VXRpbHMuc2V0U3R5bGUoYS5nZXRTdHlsZShiW2VdKSxjLGQpO2Euc2V0U3R5bGUoYltlXSxmKX19ZmluYWxseXthLmVuZFVwZGF0ZSgpfX19LHNldFN0eWxlOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1udWxsIT1jJiYoInVuZGVmaW5lZCI9PXR5cGVvZiBjLmxlbmd0aHx8MDxjLmxlbmd0aCk7aWYobnVsbD09YXx8MD09YS5sZW5ndGgpZCYmKGE9YisiPSIrYysiOyIpO2Vsc2UgaWYoYS5zdWJzdHJpbmcoMCxiLmxlbmd0aCsxKT09YisiPSIpe3ZhciBlPWEuaW5kZXhPZigiOyIpO2E9ZD9iKyI9IitjKygwPmU/IjsiOmEuc3Vic3RyaW5nKGUpKTowPmV8fGU9PWEubGVuZ3RoLTE/IiI6YS5zdWJzdHJpbmcoZSsxKX1lbHNle3ZhciBmPWEuaW5kZXhPZigiOyIrYisiPSIpOzA+Zj9kJiYoZD0iOyI9PWEuY2hhckF0KGEubGVuZ3RoLTEpPyIiOiI7IixhPWErZCtiKyI9IitjKyI7Iik6KGU9YS5pbmRleE9mKCI7IiwKZisxKSxhPWQ/YS5zdWJzdHJpbmcoMCxmKzEpK2IrIj0iK2MrKDA+ZT8iOyI6YS5zdWJzdHJpbmcoZSkpOmEuc3Vic3RyaW5nKDAsZikrKDA+ZT8iOyI6YS5zdWJzdHJpbmcoZSkpKX1yZXR1cm4gYX0sc2V0Q2VsbFN0eWxlRmxhZ3M6ZnVuY3Rpb24oYSxiLGMsZCxlKXtpZihudWxsIT1iJiYwPGIubGVuZ3RoKXthLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgZj0wO2Y8Yi5sZW5ndGg7ZisrKWlmKG51bGwhPWJbZl0pe3ZhciBnPW14VXRpbHMuc2V0U3R5bGVGbGFnKGEuZ2V0U3R5bGUoYltmXSksYyxkLGUpO2Euc2V0U3R5bGUoYltmXSxnKX19ZmluYWxseXthLmVuZFVwZGF0ZSgpfX19LHNldFN0eWxlRmxhZzpmdW5jdGlvbihhLGIsYyxkKXtpZihudWxsPT1hfHwwPT1hLmxlbmd0aClhPWR8fG51bGw9PWQ/YisiPSIrYzpiKyI9MCI7ZWxzZXt2YXIgZT1hLmluZGV4T2YoYisiPSIpO2lmKDA+ZSllPSI7Ij09YS5jaGFyQXQoYS5sZW5ndGgtMSk/IiI6IjsiLGE9ZHx8bnVsbD09ZD9hKwplK2IrIj0iK2M6YStlK2IrIj0wIjtlbHNle3ZhciBmPWEuaW5kZXhPZigiOyIsZSksZztnPTA+Zj9hLnN1YnN0cmluZyhlK2IubGVuZ3RoKzEpOmEuc3Vic3RyaW5nKGUrYi5sZW5ndGgrMSxmKTtnPW51bGw9PWQ/cGFyc2VJbnQoZyleYzpkP3BhcnNlSW50KGcpfGM6cGFyc2VJbnQoZykmfmM7YT1hLnN1YnN0cmluZygwLGUpK2IrIj0iK2crKDA8PWY/YS5zdWJzdHJpbmcoZik6IiIpfX1yZXR1cm4gYX0sZ2V0QWxpZ25tZW50QXNQb2ludDpmdW5jdGlvbihhLGIpe3ZhciBjPS0uNSxkPS0uNTthPT1teENvbnN0YW50cy5BTElHTl9MRUZUP2M9MDphPT1teENvbnN0YW50cy5BTElHTl9SSUdIVCYmKGM9LTEpO2I9PW14Q29uc3RhbnRzLkFMSUdOX1RPUD9kPTA6Yj09bXhDb25zdGFudHMuQUxJR05fQk9UVE9NJiYoZD0tMSk7cmV0dXJuIG5ldyBteFBvaW50KGMsZCl9LGdldFNpemVGb3JTdHJpbmc6ZnVuY3Rpb24oYSxiLGMsZCxlKXtiPW51bGwhPWI/YjpteENvbnN0YW50cy5ERUZBVUxUX0ZPTlRTSVpFOwpjPW51bGwhPWM/YzpteENvbnN0YW50cy5ERUZBVUxUX0ZPTlRGQU1JTFk7dmFyIGY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Zi5zdHlsZS5mb250RmFtaWx5PWM7Zi5zdHlsZS5mb250U2l6ZT1NYXRoLnJvdW5kKGIpKyJweCI7Zi5zdHlsZS5saW5lSGVpZ2h0PU1hdGgucm91bmQoYipteENvbnN0YW50cy5MSU5FX0hFSUdIVCkrInB4IjtudWxsIT1lJiYoKGUmbXhDb25zdGFudHMuRk9OVF9CT0xEKT09bXhDb25zdGFudHMuRk9OVF9CT0xEJiYoZi5zdHlsZS5mb250V2VpZ2h0PSJib2xkIiksKGUmbXhDb25zdGFudHMuRk9OVF9JVEFMSUMpPT1teENvbnN0YW50cy5GT05UX0lUQUxJQyYmKGYuc3R5bGUuZm9udFN0eWxlPSJpdGFsaWMiKSxiPVtdLChlJm14Q29uc3RhbnRzLkZPTlRfVU5ERVJMSU5FKT09bXhDb25zdGFudHMuRk9OVF9VTkRFUkxJTkUmJmIucHVzaCgidW5kZXJsaW5lIiksKGUmbXhDb25zdGFudHMuRk9OVF9TVFJJS0VUSFJPVUdIKT09bXhDb25zdGFudHMuRk9OVF9TVFJJS0VUSFJPVUdIJiYKYi5wdXNoKCJsaW5lLXRocm91Z2giKSwwPGIubGVuZ3RoJiYoZi5zdHlsZS50ZXh0RGVjb3JhdGlvbj1iLmpvaW4oIiAiKSkpO2Yuc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtmLnN0eWxlLnZpc2liaWxpdHk9ImhpZGRlbiI7Zi5zdHlsZS5kaXNwbGF5PW14Q2xpZW50LklTX1FVSVJLUz8iaW5saW5lIjoiaW5saW5lLWJsb2NrIjtmLnN0eWxlLnpvb209IjEiO251bGwhPWQ/KGYuc3R5bGUud2lkdGg9ZCsicHgiLGYuc3R5bGUud2hpdGVTcGFjZT0ibm9ybWFsIik6Zi5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiO2YuaW5uZXJIVE1MPWE7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmKTthPW5ldyBteFJlY3RhbmdsZSgwLDAsZi5vZmZzZXRXaWR0aCxmLm9mZnNldEhlaWdodCk7ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChmKTtyZXR1cm4gYX0sZ2V0Vmlld1htbDpmdW5jdGlvbihhLGIsYyxkLGUpe2Q9bnVsbCE9ZD9kOjA7ZT1udWxsIT1lP2U6MDtiPW51bGwhPWI/YjoxO251bGw9PQpjJiYoYz1bYS5nZXRNb2RlbCgpLmdldFJvb3QoKV0pO3ZhciBmPWEuZ2V0VmlldygpLGc9bnVsbCxrPWYuaXNFdmVudHNFbmFibGVkKCk7Zi5zZXRFdmVudHNFbmFibGVkKCExKTt2YXIgbD1mLmRyYXdQYW5lLG09Zi5vdmVybGF5UGFuZTthLmRpYWxlY3Q9PW14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHPyhmLmRyYXdQYW5lPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhteENvbnN0YW50cy5OU19TVkcsImciKSxmLmNhbnZhcy5hcHBlbmRDaGlsZChmLmRyYXdQYW5lKSxmLm92ZXJsYXlQYW5lPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhteENvbnN0YW50cy5OU19TVkcsImciKSk6KGYuZHJhd1BhbmU9Zi5kcmF3UGFuZS5jbG9uZU5vZGUoITEpLGYuY2FudmFzLmFwcGVuZENoaWxkKGYuZHJhd1BhbmUpLGYub3ZlcmxheVBhbmU9Zi5vdmVybGF5UGFuZS5jbG9uZU5vZGUoITEpKTtmLmNhbnZhcy5hcHBlbmRDaGlsZChmLm92ZXJsYXlQYW5lKTt2YXIgbj1mLmdldFRyYW5zbGF0ZSgpO2YudHJhbnNsYXRlPQpuZXcgbXhQb2ludChkLGUpO2I9bmV3IG14VGVtcG9yYXJ5Q2VsbFN0YXRlcyhhLmdldFZpZXcoKSxiLGMpO3RyeXtnPShuZXcgbXhDb2RlYykuZW5jb2RlKGEuZ2V0VmlldygpKX1maW5hbGx5e2IuZGVzdHJveSgpLGYudHJhbnNsYXRlPW4sZi5jYW52YXMucmVtb3ZlQ2hpbGQoZi5kcmF3UGFuZSksZi5jYW52YXMucmVtb3ZlQ2hpbGQoZi5vdmVybGF5UGFuZSksZi5kcmF3UGFuZT1sLGYub3ZlcmxheVBhbmU9bSxmLnNldEV2ZW50c0VuYWJsZWQoayl9cmV0dXJuIGd9LGdldFNjYWxlRm9yUGFnZUNvdW50OmZ1bmN0aW9uKGEsYixjLGQpe2lmKDE+YSlyZXR1cm4gMTtjPW51bGwhPWM/YzpteENvbnN0YW50cy5QQUdFX0ZPUk1BVF9BNF9QT1JUUkFJVDtkPW51bGwhPWQ/ZDowO3ZhciBlPWMud2lkdGgtMipkO2M9Yy5oZWlnaHQtMipkO2Q9Yi5nZXRHcmFwaEJvdW5kcygpLmNsb25lKCk7Yj1iLmdldFZpZXcoKS5nZXRTY2FsZSgpO2Qud2lkdGgvPWI7ZC5oZWlnaHQvPWI7Yj1kLndpZHRoOwp2YXIgZj1NYXRoLnNxcnQoYSk7ZD1NYXRoLnNxcnQoYi9kLmhlaWdodC8oZS9jKSk7Yz1mKmQ7ZD1mL2Q7aWYoMT5jJiZkPmEpe3ZhciBnPWQvYTtkPWE7Yy89Z30xPmQmJmM+YSYmKGc9Yy9hLGM9YSxkLz1nKTtnPU1hdGguY2VpbChjKSpNYXRoLmNlaWwoZCk7Zm9yKGY9MDtnPmE7KXt2YXIgZz1NYXRoLmZsb29yKGMpL2Msaz1NYXRoLmZsb29yKGQpL2Q7MT09ZyYmKGc9TWF0aC5mbG9vcihjLTEpL2MpOzE9PWsmJihrPU1hdGguZmxvb3IoZC0xKS9kKTtnPWc+az9nOms7Yyo9ZztkKj1nO2c9TWF0aC5jZWlsKGMpKk1hdGguY2VpbChkKTtmKys7aWYoMTA8ZilicmVha31yZXR1cm4gZSpjL2IqLjk5OTk5fSxzaG93OmZ1bmN0aW9uKGEsYixjLGQsZSxmKXtjPW51bGwhPWM/YzowO2Q9bnVsbCE9ZD9kOjA7bnVsbD09Yj9iPXdpbmRvdy5vcGVuKCkuZG9jdW1lbnQ6Yi5vcGVuKCk7OT09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlJiZiLndyaXRlbG4oJ1x4M2MhLS1baWYgSUVdPjxtZXRhIGh0dHAtZXF1aXY9IlgtVUEtQ29tcGF0aWJsZSIgY29udGVudD0iSUU9OSI+PCFbZW5kaWZdLS1ceDNlJyk7CnZhciBnPWEuZ2V0R3JhcGhCb3VuZHMoKSxrPU1hdGguY2VpbChjLWcueCksbD1NYXRoLmNlaWwoZC1nLnkpO251bGw9PWUmJihlPU1hdGguY2VpbChnLndpZHRoK2MpK01hdGguY2VpbChNYXRoLmNlaWwoZy54KS1nLngpKTtudWxsPT1mJiYoZj1NYXRoLmNlaWwoZy5oZWlnaHQrZCkrTWF0aC5jZWlsKE1hdGguY2VpbChnLnkpLWcueSkpO2lmKG14Q2xpZW50LklTX0lFfHwxMT09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKXtkPSI8aHRtbD48aGVhZD4iO2c9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImJhc2UiKTtmb3IoYz0wO2M8Zy5sZW5ndGg7YysrKWQrPWdbY10ub3V0ZXJIVE1MO2QrPSI8c3R5bGU+Ijtmb3IoYz0wO2M8ZG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoO2MrKyl0cnl7ZCs9ZG9jdW1lbnQuc3R5bGVTaGVldHNbY10uY3NzVGV4dH1jYXRjaChtKXt9ZD1kKyc8L3N0eWxlPjwvaGVhZD48Ym9keSBzdHlsZT0ibWFyZ2luOjBweDsiPicrKCc8ZGl2IHN0eWxlPSJwb3NpdGlvbjphYnNvbHV0ZTtvdmVyZmxvdzpoaWRkZW47d2lkdGg6JysKZSsicHg7aGVpZ2h0OiIrZisncHg7Ij48ZGl2IHN0eWxlPSJwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OicraysicHg7dG9wOiIrbCsncHg7Ij4nKSthLmNvbnRhaW5lci5pbm5lckhUTUw7Yi53cml0ZWxuKGQrIjwvZGl2PjwvZGl2PjwvYm9keT48aHRtbD4iKTtiLmNsb3NlKCl9ZWxzZXtiLndyaXRlbG4oIjxodG1sPjxoZWFkPiIpO2c9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImJhc2UiKTtmb3IoYz0wO2M8Zy5sZW5ndGg7YysrKWIud3JpdGVsbihteFV0aWxzLmdldE91dGVySHRtbChnW2NdKSk7ZD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgibGluayIpO2ZvcihjPTA7YzxkLmxlbmd0aDtjKyspYi53cml0ZWxuKG14VXRpbHMuZ2V0T3V0ZXJIdG1sKGRbY10pKTtkPWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJzdHlsZSIpO2ZvcihjPTA7YzxkLmxlbmd0aDtjKyspYi53cml0ZWxuKG14VXRpbHMuZ2V0T3V0ZXJIdG1sKGRbY10pKTtiLndyaXRlbG4oJzwvaGVhZD48Ym9keSBzdHlsZT0ibWFyZ2luOjBweDsiPjwvYm9keT48L2h0bWw+Jyk7CmIuY2xvc2UoKTtjPWIuY3JlYXRlRWxlbWVudCgiZGl2Iik7Yy5wb3NpdGlvbj0iYWJzb2x1dGUiO2Mub3ZlcmZsb3c9ImhpZGRlbiI7Yy5zdHlsZS53aWR0aD1lKyJweCI7Yy5zdHlsZS5oZWlnaHQ9ZisicHgiO2U9Yi5jcmVhdGVFbGVtZW50KCJkaXYiKTtlLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7ZS5zdHlsZS5sZWZ0PWsrInB4IjtlLnN0eWxlLnRvcD1sKyJweCI7Zj1hLmNvbnRhaW5lci5maXJzdENoaWxkO2ZvcihkPW51bGw7bnVsbCE9ZjspZz1mLmNsb25lTm9kZSghMCksZj09YS52aWV3LmRyYXdQYW5lLm93bmVyU1ZHRWxlbWVudD8oYy5hcHBlbmRDaGlsZChnKSxkPWcpOmUuYXBwZW5kQ2hpbGQoZyksZj1mLm5leHRTaWJsaW5nO2IuYm9keS5hcHBlbmRDaGlsZChjKTtudWxsIT1lLmZpcnN0Q2hpbGQmJmIuYm9keS5hcHBlbmRDaGlsZChlKTtudWxsIT1kJiYoZC5zdHlsZS5taW5XaWR0aD0iIixkLnN0eWxlLm1pbkhlaWdodD0iIixkLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCJ0cmFuc2Zvcm0iLAoidHJhbnNsYXRlKCIraysiLCIrbCsiKSIpKX1teFV0aWxzLnJlbW92ZUN1cnNvcnMoYi5ib2R5KTtyZXR1cm4gYn0scHJpbnRTY3JlZW46ZnVuY3Rpb24oYSl7dmFyIGI9d2luZG93Lm9wZW4oKTthLmdldEdyYXBoQm91bmRzKCk7bXhVdGlscy5zaG93KGEsYi5kb2N1bWVudCk7YT1mdW5jdGlvbigpe2IuZm9jdXMoKTtiLnByaW50KCk7Yi5jbG9zZSgpfTtteENsaWVudC5JU19HQz9iLnNldFRpbWVvdXQoYSw1MDApOmEoKX0scG9wdXA6ZnVuY3Rpb24oYSxiKXtpZihiKXt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtjLnN0eWxlLm92ZXJmbG93PSJzY3JvbGwiO2Muc3R5bGUud2lkdGg9IjYzNnB4IjtjLnN0eWxlLmhlaWdodD0iNDYwcHgiO3ZhciBkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInByZSIpO2QuaW5uZXJIVE1MPW14VXRpbHMuaHRtbEVudGl0aWVzKGEsITEpLnJlcGxhY2UoL1xuL2csIjxicj4iKS5yZXBsYWNlKC8gL2csIiZuYnNwOyIpO2MuYXBwZW5kQ2hpbGQoZCk7CmM9bmV3IG14V2luZG93KCJQb3B1cCBXaW5kb3ciLGMsZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aC8yLTMyMCxNYXRoLm1heChkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodHx8MCxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KS8yLTI0MCw2NDAsNDgwLCExLCEwKTtjLnNldENsb3NhYmxlKCEwKTtjLnNldFZpc2libGUoITApfWVsc2UgbXhDbGllbnQuSVNfTlM/KGM9d2luZG93Lm9wZW4oKSxjLmRvY3VtZW50LndyaXRlbG4oIjxwcmU+IitteFV0aWxzLmh0bWxFbnRpdGllcyhhKSsiPC9wcmUiKSxjLmRvY3VtZW50LmNsb3NlKCkpOihjPXdpbmRvdy5vcGVuKCksZD1jLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInByZSIpLGQuaW5uZXJIVE1MPW14VXRpbHMuaHRtbEVudGl0aWVzKGEsITEpLnJlcGxhY2UoL1xuL2csIjxicj4iKS5yZXBsYWNlKC8gL2csIiZuYnNwOyIpLGMuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkKSl9LGFsZXJ0OmZ1bmN0aW9uKGEpe2FsZXJ0KGEpfSwKcHJvbXB0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIHByb21wdChhLG51bGwhPWI/YjoiIil9LGNvbmZpcm06ZnVuY3Rpb24oYSl7cmV0dXJuIGNvbmZpcm0oYSl9LGVycm9yOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Uuc3R5bGUucGFkZGluZz0iMjBweCI7dmFyIGY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIik7Zi5zZXRBdHRyaWJ1dGUoInNyYyIsZHx8bXhVdGlscy5lcnJvckltYWdlKTtmLnNldEF0dHJpYnV0ZSgidmFsaWduIiwiYm90dG9tIik7Zi5zdHlsZS52ZXJ0aWNhbEFsaWduPSJtaWRkbGUiO2UuYXBwZW5kQ2hpbGQoZik7ZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgiwqAiKSk7ZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgiwqAiKSk7ZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgiwqAiKSk7bXhVdGlscy53cml0ZShlLGEpO2E9ZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aDsKZD1kb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDt2YXIgZz1uZXcgbXhXaW5kb3cobXhSZXNvdXJjZXMuZ2V0KG14VXRpbHMuZXJyb3JSZXNvdXJjZSl8fG14VXRpbHMuZXJyb3JSZXNvdXJjZSxlLChhLWIpLzIsZC80LGIsbnVsbCwhMSwhMCk7YyYmKG14VXRpbHMuYnIoZSksYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJwIiksYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJidXR0b24iKSxteENsaWVudC5JU19JRT9jLnN0eWxlLmNzc1RleHQ9ImZsb2F0OnJpZ2h0IjpjLnNldEF0dHJpYnV0ZSgic3R5bGUiLCJmbG9hdDpyaWdodCIpLG14RXZlbnQuYWRkTGlzdGVuZXIoYywiY2xpY2siLGZ1bmN0aW9uKGEpe2cuZGVzdHJveSgpfSksbXhVdGlscy53cml0ZShjLG14UmVzb3VyY2VzLmdldChteFV0aWxzLmNsb3NlUmVzb3VyY2UpfHxteFV0aWxzLmNsb3NlUmVzb3VyY2UpLGIuYXBwZW5kQ2hpbGQoYyksZS5hcHBlbmRDaGlsZChiKSwKbXhVdGlscy5icihlKSxnLnNldENsb3NhYmxlKCEwKSk7Zy5zZXRWaXNpYmxlKCEwKTtyZXR1cm4gZ30sbWFrZURyYWdnYWJsZTpmdW5jdGlvbihhLGIsYyxkLGUsZixnLGssbCxtKXthPW5ldyBteERyYWdTb3VyY2UoYSxjKTthLmRyYWdPZmZzZXQ9bmV3IG14UG9pbnQobnVsbCE9ZT9lOjAsbnVsbCE9Zj9mOm14Q29uc3RhbnRzLlRPT0xUSVBfVkVSVElDQUxfT0ZGU0VUKTthLmF1dG9zY3JvbGw9ZzthLnNldEd1aWRlc0VuYWJsZWQoITEpO251bGwhPWwmJihhLmhpZ2hsaWdodERyb3BUYXJnZXRzPWwpO251bGwhPW0mJihhLmdldERyb3BUYXJnZXQ9bSk7YS5nZXRHcmFwaEZvckV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiBiP2IoYSk6Yn07bnVsbCE9ZCYmKGEuY3JlYXRlRHJhZ0VsZW1lbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gZC5jbG9uZU5vZGUoITApfSxrJiYoYS5jcmVhdGVQcmV2aWV3RWxlbWVudD1mdW5jdGlvbihhKXt2YXIgYj1kLmNsb25lTm9kZSghMCksCmM9cGFyc2VJbnQoYi5zdHlsZS53aWR0aCksZT1wYXJzZUludChiLnN0eWxlLmhlaWdodCk7Yi5zdHlsZS53aWR0aD1NYXRoLnJvdW5kKGMqYS52aWV3LnNjYWxlKSsicHgiO2Iuc3R5bGUuaGVpZ2h0PU1hdGgucm91bmQoZSphLnZpZXcuc2NhbGUpKyJweCI7cmV0dXJuIGJ9KSk7cmV0dXJuIGF9fSxteENvbnN0YW50cz17REVGQVVMVF9IT1RTUE9UOi4zLE1JTl9IT1RTUE9UX1NJWkU6OCxNQVhfSE9UU1BPVF9TSVpFOjAsUkVOREVSSU5HX0hJTlRfRVhBQ1Q6ImV4YWN0IixSRU5ERVJJTkdfSElOVF9GQVNURVI6ImZhc3RlciIsUkVOREVSSU5HX0hJTlRfRkFTVEVTVDoiZmFzdGVzdCIsRElBTEVDVF9TVkc6InN2ZyIsRElBTEVDVF9WTUw6InZtbCIsRElBTEVDVF9NSVhFREhUTUw6Im1peGVkSHRtbCIsRElBTEVDVF9QUkVGRVJIVE1MOiJwcmVmZXJIdG1sIixESUFMRUNUX1NUUklDVEhUTUw6InN0cmljdEh0bWwiLE5TX1NWRzoiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLE5TX1hIVE1MOiJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiwKTlNfWExJTks6Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiLFNIQURPV0NPTE9SOiJncmF5IixWTUxfU0hBRE9XQ09MT1I6ImdyYXkiLFNIQURPV19PRkZTRVRfWDoyLFNIQURPV19PRkZTRVRfWTozLFNIQURPV19PUEFDSVRZOjEsTk9ERVRZUEVfRUxFTUVOVDoxLE5PREVUWVBFX0FUVFJJQlVURToyLE5PREVUWVBFX1RFWFQ6MyxOT0RFVFlQRV9DREFUQTo0LE5PREVUWVBFX0VOVElUWV9SRUZFUkVOQ0U6NSxOT0RFVFlQRV9FTlRJVFk6NixOT0RFVFlQRV9QUk9DRVNTSU5HX0lOU1RSVUNUSU9OOjcsTk9ERVRZUEVfQ09NTUVOVDo4LE5PREVUWVBFX0RPQ1VNRU5UOjksTk9ERVRZUEVfRE9DVU1FTlRUWVBFOjEwLE5PREVUWVBFX0RPQ1VNRU5UX0ZSQUdNRU5UOjExLE5PREVUWVBFX05PVEFUSU9OOjEyLFRPT0xUSVBfVkVSVElDQUxfT0ZGU0VUOjE2LERFRkFVTFRfVkFMSURfQ09MT1I6IiMwMEZGMDAiLERFRkFVTFRfSU5WQUxJRF9DT0xPUjoiI0ZGMDAwMCIsT1VUTElORV9ISUdITElHSFRfQ09MT1I6IiMwMEZGMDAiLApPVVRMSU5FX0hJR0hMSUdIVF9TVFJPS0VXSURUSDo1LEhJR0hMSUdIVF9TVFJPS0VXSURUSDozLEhJR0hMSUdIVF9TSVpFOjIsSElHSExJR0hUX09QQUNJVFk6MTAwLENVUlNPUl9NT1ZBQkxFX1ZFUlRFWDoibW92ZSIsQ1VSU09SX01PVkFCTEVfRURHRToibW92ZSIsQ1VSU09SX0xBQkVMX0hBTkRMRToiZGVmYXVsdCIsQ1VSU09SX1RFUk1JTkFMX0hBTkRMRToicG9pbnRlciIsQ1VSU09SX0JFTkRfSEFORExFOiJjcm9zc2hhaXIiLENVUlNPUl9WSVJUVUFMX0JFTkRfSEFORExFOiJjcm9zc2hhaXIiLENVUlNPUl9DT05ORUNUOiJwb2ludGVyIixISUdITElHSFRfQ09MT1I6IiMwMEZGMDAiLENPTk5FQ1RfVEFSR0VUX0NPTE9SOiIjMDAwMEZGIixJTlZBTElEX0NPTk5FQ1RfVEFSR0VUX0NPTE9SOiIjRkYwMDAwIixEUk9QX1RBUkdFVF9DT0xPUjoiIzAwMDBGRiIsVkFMSURfQ09MT1I6IiMwMEZGMDAiLElOVkFMSURfQ09MT1I6IiNGRjAwMDAiLEVER0VfU0VMRUNUSU9OX0NPTE9SOiIjMDBGRjAwIiwKVkVSVEVYX1NFTEVDVElPTl9DT0xPUjoiIzAwRkYwMCIsVkVSVEVYX1NFTEVDVElPTl9TVFJPS0VXSURUSDoxLEVER0VfU0VMRUNUSU9OX1NUUk9LRVdJRFRIOjEsVkVSVEVYX1NFTEVDVElPTl9EQVNIRUQ6ITAsRURHRV9TRUxFQ1RJT05fREFTSEVEOiEwLEdVSURFX0NPTE9SOiIjRkYwMDAwIixHVUlERV9TVFJPS0VXSURUSDoxLE9VVExJTkVfQ09MT1I6IiMwMDk5RkYiLE9VVExJTkVfU1RST0tFV0lEVEg6bXhDbGllbnQuSVNfSUU/MjozLEhBTkRMRV9TSVpFOjYsTEFCRUxfSEFORExFX1NJWkU6NCxIQU5ETEVfRklMTENPTE9SOiIjMDBGRjAwIixIQU5ETEVfU1RST0tFQ09MT1I6ImJsYWNrIixMQUJFTF9IQU5ETEVfRklMTENPTE9SOiJ5ZWxsb3ciLENPTk5FQ1RfSEFORExFX0ZJTExDT0xPUjoiIzAwMDBGRiIsTE9DS0VEX0hBTkRMRV9GSUxMQ09MT1I6IiNGRjAwMDAiLE9VVExJTkVfSEFORExFX0ZJTExDT0xPUjoiIzAwRkZGRiIsT1VUTElORV9IQU5ETEVfU1RST0tFQ09MT1I6IiMwMDMzRkYiLApERUZBVUxUX0ZPTlRGQU1JTFk6IkFyaWFsLEhlbHZldGljYSIsREVGQVVMVF9GT05UU0laRToxMSxERUZBVUxUX1RFWFRfRElSRUNUSU9OOiIiLExJTkVfSEVJR0hUOjEuMixXT1JEX1dSQVA6Im5vcm1hbCIsQUJTT0xVVEVfTElORV9IRUlHSFQ6ITEsREVGQVVMVF9GT05UU1RZTEU6MCxERUZBVUxUX1NUQVJUU0laRTo0MCxERUZBVUxUX01BUktFUlNJWkU6NixERUZBVUxUX0lNQUdFU0laRToyNCxFTlRJVFlfU0VHTUVOVDozMCxSRUNUQU5HTEVfUk9VTkRJTkdfRkFDVE9SOi4xNSxMSU5FX0FSQ1NJWkU6MjAsQVJST1dfU1BBQ0lORzowLEFSUk9XX1dJRFRIOjMwLEFSUk9XX1NJWkU6MzAsUEFHRV9GT1JNQVRfQTRfUE9SVFJBSVQ6bmV3IG14UmVjdGFuZ2xlKDAsMCw4MjcsMTE2OSksUEFHRV9GT1JNQVRfQTRfTEFORFNDQVBFOm5ldyBteFJlY3RhbmdsZSgwLDAsMTE2OSw4MjcpLFBBR0VfRk9STUFUX0xFVFRFUl9QT1JUUkFJVDpuZXcgbXhSZWN0YW5nbGUoMCwwLDg1MCwxMTAwKSwKUEFHRV9GT1JNQVRfTEVUVEVSX0xBTkRTQ0FQRTpuZXcgbXhSZWN0YW5nbGUoMCwwLDExMDAsODUwKSxOT05FOiJub25lIixTVFlMRV9QRVJJTUVURVI6InBlcmltZXRlciIsU1RZTEVfU09VUkNFX1BPUlQ6InNvdXJjZVBvcnQiLFNUWUxFX1RBUkdFVF9QT1JUOiJ0YXJnZXRQb3J0IixTVFlMRV9QT1JUX0NPTlNUUkFJTlQ6InBvcnRDb25zdHJhaW50IixTVFlMRV9QT1JUX0NPTlNUUkFJTlRfUk9UQVRJT046InBvcnRDb25zdHJhaW50Um90YXRpb24iLFNUWUxFX1NPVVJDRV9QT1JUX0NPTlNUUkFJTlQ6InNvdXJjZVBvcnRDb25zdHJhaW50IixTVFlMRV9UQVJHRVRfUE9SVF9DT05TVFJBSU5UOiJ0YXJnZXRQb3J0Q29uc3RyYWludCIsU1RZTEVfT1BBQ0lUWToib3BhY2l0eSIsU1RZTEVfRklMTF9PUEFDSVRZOiJmaWxsT3BhY2l0eSIsU1RZTEVfU1RST0tFX09QQUNJVFk6InN0cm9rZU9wYWNpdHkiLFNUWUxFX1RFWFRfT1BBQ0lUWToidGV4dE9wYWNpdHkiLFNUWUxFX1RFWFRfRElSRUNUSU9OOiJ0ZXh0RGlyZWN0aW9uIiwKU1RZTEVfT1ZFUkZMT1c6Im92ZXJmbG93IixTVFlMRV9PUlRIT0dPTkFMOiJvcnRob2dvbmFsIixTVFlMRV9FWElUX1g6ImV4aXRYIixTVFlMRV9FWElUX1k6ImV4aXRZIixTVFlMRV9FWElUX0RYOiJleGl0RHgiLFNUWUxFX0VYSVRfRFk6ImV4aXREeSIsU1RZTEVfRVhJVF9QRVJJTUVURVI6ImV4aXRQZXJpbWV0ZXIiLFNUWUxFX0VOVFJZX1g6ImVudHJ5WCIsU1RZTEVfRU5UUllfWToiZW50cnlZIixTVFlMRV9FTlRSWV9EWDoiZW50cnlEeCIsU1RZTEVfRU5UUllfRFk6ImVudHJ5RHkiLFNUWUxFX0VOVFJZX1BFUklNRVRFUjoiZW50cnlQZXJpbWV0ZXIiLFNUWUxFX1dISVRFX1NQQUNFOiJ3aGl0ZVNwYWNlIixTVFlMRV9ST1RBVElPTjoicm90YXRpb24iLFNUWUxFX0ZJTExDT0xPUjoiZmlsbENvbG9yIixTVFlMRV9QT0lOVEVSX0VWRU5UUzoicG9pbnRlckV2ZW50cyIsU1RZTEVfU1dJTUxBTkVfRklMTENPTE9SOiJzd2ltbGFuZUZpbGxDb2xvciIsU1RZTEVfTUFSR0lOOiJtYXJnaW4iLApTVFlMRV9HUkFESUVOVENPTE9SOiJncmFkaWVudENvbG9yIixTVFlMRV9HUkFESUVOVF9ESVJFQ1RJT046ImdyYWRpZW50RGlyZWN0aW9uIixTVFlMRV9TVFJPS0VDT0xPUjoic3Ryb2tlQ29sb3IiLFNUWUxFX1NFUEFSQVRPUkNPTE9SOiJzZXBhcmF0b3JDb2xvciIsU1RZTEVfU1RST0tFV0lEVEg6InN0cm9rZVdpZHRoIixTVFlMRV9BTElHTjoiYWxpZ24iLFNUWUxFX1ZFUlRJQ0FMX0FMSUdOOiJ2ZXJ0aWNhbEFsaWduIixTVFlMRV9MQUJFTF9XSURUSDoibGFiZWxXaWR0aCIsU1RZTEVfTEFCRUxfUE9TSVRJT046ImxhYmVsUG9zaXRpb24iLFNUWUxFX1ZFUlRJQ0FMX0xBQkVMX1BPU0lUSU9OOiJ2ZXJ0aWNhbExhYmVsUG9zaXRpb24iLFNUWUxFX0lNQUdFX0FTUEVDVDoiaW1hZ2VBc3BlY3QiLFNUWUxFX0lNQUdFX0FMSUdOOiJpbWFnZUFsaWduIixTVFlMRV9JTUFHRV9WRVJUSUNBTF9BTElHTjoiaW1hZ2VWZXJ0aWNhbEFsaWduIixTVFlMRV9HTEFTUzoiZ2xhc3MiLFNUWUxFX0lNQUdFOiJpbWFnZSIsClNUWUxFX0lNQUdFX1dJRFRIOiJpbWFnZVdpZHRoIixTVFlMRV9JTUFHRV9IRUlHSFQ6ImltYWdlSGVpZ2h0IixTVFlMRV9JTUFHRV9CQUNLR1JPVU5EOiJpbWFnZUJhY2tncm91bmQiLFNUWUxFX0lNQUdFX0JPUkRFUjoiaW1hZ2VCb3JkZXIiLFNUWUxFX0ZMSVBIOiJmbGlwSCIsU1RZTEVfRkxJUFY6ImZsaXBWIixTVFlMRV9OT0xBQkVMOiJub0xhYmVsIixTVFlMRV9OT0VER0VTVFlMRToibm9FZGdlU3R5bGUiLFNUWUxFX0xBQkVMX0JBQ0tHUk9VTkRDT0xPUjoibGFiZWxCYWNrZ3JvdW5kQ29sb3IiLFNUWUxFX0xBQkVMX0JPUkRFUkNPTE9SOiJsYWJlbEJvcmRlckNvbG9yIixTVFlMRV9MQUJFTF9QQURESU5HOiJsYWJlbFBhZGRpbmciLFNUWUxFX0lORElDQVRPUl9TSEFQRToiaW5kaWNhdG9yU2hhcGUiLFNUWUxFX0lORElDQVRPUl9JTUFHRToiaW5kaWNhdG9ySW1hZ2UiLFNUWUxFX0lORElDQVRPUl9DT0xPUjoiaW5kaWNhdG9yQ29sb3IiLFNUWUxFX0lORElDQVRPUl9TVFJPS0VDT0xPUjoiaW5kaWNhdG9yU3Ryb2tlQ29sb3IiLApTVFlMRV9JTkRJQ0FUT1JfR1JBRElFTlRDT0xPUjoiaW5kaWNhdG9yR3JhZGllbnRDb2xvciIsU1RZTEVfSU5ESUNBVE9SX1NQQUNJTkc6ImluZGljYXRvclNwYWNpbmciLFNUWUxFX0lORElDQVRPUl9XSURUSDoiaW5kaWNhdG9yV2lkdGgiLFNUWUxFX0lORElDQVRPUl9IRUlHSFQ6ImluZGljYXRvckhlaWdodCIsU1RZTEVfSU5ESUNBVE9SX0RJUkVDVElPTjoiaW5kaWNhdG9yRGlyZWN0aW9uIixTVFlMRV9TSEFET1c6InNoYWRvdyIsU1RZTEVfU0VHTUVOVDoic2VnbWVudCIsU1RZTEVfRU5EQVJST1c6ImVuZEFycm93IixTVFlMRV9TVEFSVEFSUk9XOiJzdGFydEFycm93IixTVFlMRV9FTkRTSVpFOiJlbmRTaXplIixTVFlMRV9TVEFSVFNJWkU6InN0YXJ0U2l6ZSIsU1RZTEVfU1dJTUxBTkVfTElORToic3dpbWxhbmVMaW5lIixTVFlMRV9FTkRGSUxMOiJlbmRGaWxsIixTVFlMRV9TVEFSVEZJTEw6InN0YXJ0RmlsbCIsU1RZTEVfREFTSEVEOiJkYXNoZWQiLFNUWUxFX0RBU0hfUEFUVEVSTjoiZGFzaFBhdHRlcm4iLApTVFlMRV9GSVhfREFTSDoiZml4RGFzaCIsU1RZTEVfUk9VTkRFRDoicm91bmRlZCIsU1RZTEVfQ1VSVkVEOiJjdXJ2ZWQiLFNUWUxFX0FSQ1NJWkU6ImFyY1NpemUiLFNUWUxFX0FCU09MVVRFX0FSQ1NJWkU6ImFic29sdXRlQXJjU2l6ZSIsU1RZTEVfU09VUkNFX1BFUklNRVRFUl9TUEFDSU5HOiJzb3VyY2VQZXJpbWV0ZXJTcGFjaW5nIixTVFlMRV9UQVJHRVRfUEVSSU1FVEVSX1NQQUNJTkc6InRhcmdldFBlcmltZXRlclNwYWNpbmciLFNUWUxFX1BFUklNRVRFUl9TUEFDSU5HOiJwZXJpbWV0ZXJTcGFjaW5nIixTVFlMRV9TUEFDSU5HOiJzcGFjaW5nIixTVFlMRV9TUEFDSU5HX1RPUDoic3BhY2luZ1RvcCIsU1RZTEVfU1BBQ0lOR19MRUZUOiJzcGFjaW5nTGVmdCIsU1RZTEVfU1BBQ0lOR19CT1RUT006InNwYWNpbmdCb3R0b20iLFNUWUxFX1NQQUNJTkdfUklHSFQ6InNwYWNpbmdSaWdodCIsU1RZTEVfSE9SSVpPTlRBTDoiaG9yaXpvbnRhbCIsU1RZTEVfRElSRUNUSU9OOiJkaXJlY3Rpb24iLApTVFlMRV9BTkNIT1JfUE9JTlRfRElSRUNUSU9OOiJhbmNob3JQb2ludERpcmVjdGlvbiIsU1RZTEVfRUxCT1c6ImVsYm93IixTVFlMRV9GT05UQ09MT1I6ImZvbnRDb2xvciIsU1RZTEVfRk9OVEZBTUlMWToiZm9udEZhbWlseSIsU1RZTEVfRk9OVFNJWkU6ImZvbnRTaXplIixTVFlMRV9GT05UU1RZTEU6ImZvbnRTdHlsZSIsU1RZTEVfQVNQRUNUOiJhc3BlY3QiLFNUWUxFX0FVVE9TSVpFOiJhdXRvc2l6ZSIsU1RZTEVfRk9MREFCTEU6ImZvbGRhYmxlIixTVFlMRV9FRElUQUJMRToiZWRpdGFibGUiLFNUWUxFX0JBQ0tHUk9VTkRfT1VUTElORToiYmFja2dyb3VuZE91dGxpbmUiLFNUWUxFX0JFTkRBQkxFOiJiZW5kYWJsZSIsU1RZTEVfTU9WQUJMRToibW92YWJsZSIsU1RZTEVfUkVTSVpBQkxFOiJyZXNpemFibGUiLFNUWUxFX1JFU0laRV9XSURUSDoicmVzaXplV2lkdGgiLFNUWUxFX1JFU0laRV9IRUlHSFQ6InJlc2l6ZUhlaWdodCIsU1RZTEVfUk9UQVRBQkxFOiJyb3RhdGFibGUiLApTVFlMRV9DTE9ORUFCTEU6ImNsb25lYWJsZSIsU1RZTEVfREVMRVRBQkxFOiJkZWxldGFibGUiLFNUWUxFX1NIQVBFOiJzaGFwZSIsU1RZTEVfRURHRToiZWRnZVN0eWxlIixTVFlMRV9KRVRUWV9TSVpFOiJqZXR0eVNpemUiLFNUWUxFX1NPVVJDRV9KRVRUWV9TSVpFOiJzb3VyY2VKZXR0eVNpemUiLFNUWUxFX1RBUkdFVF9KRVRUWV9TSVpFOiJ0YXJnZXRKZXR0eVNpemUiLFNUWUxFX0xPT1A6Imxvb3BTdHlsZSIsU1RZTEVfT1JUSE9HT05BTF9MT09QOiJvcnRob2dvbmFsTG9vcCIsU1RZTEVfUk9VVElOR19DRU5URVJfWDoicm91dGluZ0NlbnRlclgiLFNUWUxFX1JPVVRJTkdfQ0VOVEVSX1k6InJvdXRpbmdDZW50ZXJZIixGT05UX0JPTEQ6MSxGT05UX0lUQUxJQzoyLEZPTlRfVU5ERVJMSU5FOjQsRk9OVF9TVFJJS0VUSFJPVUdIOjgsU0hBUEVfUkVDVEFOR0xFOiJyZWN0YW5nbGUiLFNIQVBFX0VMTElQU0U6ImVsbGlwc2UiLFNIQVBFX0RPVUJMRV9FTExJUFNFOiJkb3VibGVFbGxpcHNlIiwKU0hBUEVfUkhPTUJVUzoicmhvbWJ1cyIsU0hBUEVfTElORToibGluZSIsU0hBUEVfSU1BR0U6ImltYWdlIixTSEFQRV9BUlJPVzoiYXJyb3ciLFNIQVBFX0FSUk9XX0NPTk5FQ1RPUjoiYXJyb3dDb25uZWN0b3IiLFNIQVBFX0xBQkVMOiJsYWJlbCIsU0hBUEVfQ1lMSU5ERVI6ImN5bGluZGVyIixTSEFQRV9TV0lNTEFORToic3dpbWxhbmUiLFNIQVBFX0NPTk5FQ1RPUjoiY29ubmVjdG9yIixTSEFQRV9BQ1RPUjoiYWN0b3IiLFNIQVBFX0NMT1VEOiJjbG91ZCIsU0hBUEVfVFJJQU5HTEU6InRyaWFuZ2xlIixTSEFQRV9IRVhBR09OOiJoZXhhZ29uIixBUlJPV19DTEFTU0lDOiJjbGFzc2ljIixBUlJPV19DTEFTU0lDX1RISU46ImNsYXNzaWNUaGluIixBUlJPV19CTE9DSzoiYmxvY2siLEFSUk9XX0JMT0NLX1RISU46ImJsb2NrVGhpbiIsQVJST1dfT1BFTjoib3BlbiIsQVJST1dfT1BFTl9USElOOiJvcGVuVGhpbiIsQVJST1dfT1ZBTDoib3ZhbCIsQVJST1dfRElBTU9ORDoiZGlhbW9uZCIsCkFSUk9XX0RJQU1PTkRfVEhJTjoiZGlhbW9uZFRoaW4iLEFMSUdOX0xFRlQ6ImxlZnQiLEFMSUdOX0NFTlRFUjoiY2VudGVyIixBTElHTl9SSUdIVDoicmlnaHQiLEFMSUdOX1RPUDoidG9wIixBTElHTl9NSURETEU6Im1pZGRsZSIsQUxJR05fQk9UVE9NOiJib3R0b20iLERJUkVDVElPTl9OT1JUSDoibm9ydGgiLERJUkVDVElPTl9TT1VUSDoic291dGgiLERJUkVDVElPTl9FQVNUOiJlYXN0IixESVJFQ1RJT05fV0VTVDoid2VzdCIsVEVYVF9ESVJFQ1RJT05fREVGQVVMVDoiIixURVhUX0RJUkVDVElPTl9BVVRPOiJhdXRvIixURVhUX0RJUkVDVElPTl9MVFI6Imx0ciIsVEVYVF9ESVJFQ1RJT05fUlRMOiJydGwiLERJUkVDVElPTl9NQVNLX05PTkU6MCxESVJFQ1RJT05fTUFTS19XRVNUOjEsRElSRUNUSU9OX01BU0tfTk9SVEg6MixESVJFQ1RJT05fTUFTS19TT1VUSDo0LERJUkVDVElPTl9NQVNLX0VBU1Q6OCxESVJFQ1RJT05fTUFTS19BTEw6MTUsRUxCT1dfVkVSVElDQUw6InZlcnRpY2FsIiwKRUxCT1dfSE9SSVpPTlRBTDoiaG9yaXpvbnRhbCIsRURHRVNUWUxFX0VMQk9XOiJlbGJvd0VkZ2VTdHlsZSIsRURHRVNUWUxFX0VOVElUWV9SRUxBVElPTjoiZW50aXR5UmVsYXRpb25FZGdlU3R5bGUiLEVER0VTVFlMRV9MT09QOiJsb29wRWRnZVN0eWxlIixFREdFU1RZTEVfU0lERVRPU0lERToic2lkZVRvU2lkZUVkZ2VTdHlsZSIsRURHRVNUWUxFX1RPUFRPQk9UVE9NOiJ0b3BUb0JvdHRvbUVkZ2VTdHlsZSIsRURHRVNUWUxFX09SVEhPR09OQUw6Im9ydGhvZ29uYWxFZGdlU3R5bGUiLEVER0VTVFlMRV9TRUdNRU5UOiJzZWdtZW50RWRnZVN0eWxlIixQRVJJTUVURVJfRUxMSVBTRToiZWxsaXBzZVBlcmltZXRlciIsUEVSSU1FVEVSX1JFQ1RBTkdMRToicmVjdGFuZ2xlUGVyaW1ldGVyIixQRVJJTUVURVJfUkhPTUJVUzoicmhvbWJ1c1BlcmltZXRlciIsUEVSSU1FVEVSX0hFWEFHT046ImhleGFnb25QZXJpbWV0ZXIiLFBFUklNRVRFUl9UUklBTkdMRToidHJpYW5nbGVQZXJpbWV0ZXIifTsKZnVuY3Rpb24gbXhFdmVudE9iamVjdChhKXt0aGlzLm5hbWU9YTt0aGlzLnByb3BlcnRpZXM9W107Zm9yKHZhciBiPTE7Yjxhcmd1bWVudHMubGVuZ3RoO2IrPTIpbnVsbCE9YXJndW1lbnRzW2IrMV0mJih0aGlzLnByb3BlcnRpZXNbYXJndW1lbnRzW2JdXT1hcmd1bWVudHNbYisxXSl9bXhFdmVudE9iamVjdC5wcm90b3R5cGUubmFtZT1udWxsO214RXZlbnRPYmplY3QucHJvdG90eXBlLnByb3BlcnRpZXM9bnVsbDtteEV2ZW50T2JqZWN0LnByb3RvdHlwZS5jb25zdW1lZD0hMTtteEV2ZW50T2JqZWN0LnByb3RvdHlwZS5nZXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmFtZX07bXhFdmVudE9iamVjdC5wcm90b3R5cGUuZ2V0UHJvcGVydGllcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3BlcnRpZXN9O214RXZlbnRPYmplY3QucHJvdG90eXBlLmdldFByb3BlcnR5PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnByb3BlcnRpZXNbYV19OwpteEV2ZW50T2JqZWN0LnByb3RvdHlwZS5pc0NvbnN1bWVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3VtZWR9O214RXZlbnRPYmplY3QucHJvdG90eXBlLmNvbnN1bWU9ZnVuY3Rpb24oKXt0aGlzLmNvbnN1bWVkPSEwfTtmdW5jdGlvbiBteE1vdXNlRXZlbnQoYSxiKXt0aGlzLmV2dD1hO3RoaXMuc291cmNlU3RhdGU9dGhpcy5zdGF0ZT1ifW14TW91c2VFdmVudC5wcm90b3R5cGUuY29uc3VtZWQ9ITE7bXhNb3VzZUV2ZW50LnByb3RvdHlwZS5ldnQ9bnVsbDtteE1vdXNlRXZlbnQucHJvdG90eXBlLmdyYXBoWD1udWxsO214TW91c2VFdmVudC5wcm90b3R5cGUuZ3JhcGhZPW51bGw7bXhNb3VzZUV2ZW50LnByb3RvdHlwZS5zdGF0ZT1udWxsO214TW91c2VFdmVudC5wcm90b3R5cGUuc291cmNlU3RhdGU9bnVsbDtteE1vdXNlRXZlbnQucHJvdG90eXBlLmdldEV2ZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXZ0fTsKbXhNb3VzZUV2ZW50LnByb3RvdHlwZS5nZXRTb3VyY2U9ZnVuY3Rpb24oKXtyZXR1cm4gbXhFdmVudC5nZXRTb3VyY2UodGhpcy5ldnQpfTtteE1vdXNlRXZlbnQucHJvdG90eXBlLmlzU291cmNlPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hP214VXRpbHMuaXNBbmNlc3Rvck5vZGUoYS5ub2RlLHRoaXMuZ2V0U291cmNlKCkpOiExfTtteE1vdXNlRXZlbnQucHJvdG90eXBlLmdldFg9ZnVuY3Rpb24oKXtyZXR1cm4gbXhFdmVudC5nZXRDbGllbnRYKHRoaXMuZ2V0RXZlbnQoKSl9O214TW91c2VFdmVudC5wcm90b3R5cGUuZ2V0WT1mdW5jdGlvbigpe3JldHVybiBteEV2ZW50LmdldENsaWVudFkodGhpcy5nZXRFdmVudCgpKX07bXhNb3VzZUV2ZW50LnByb3RvdHlwZS5nZXRHcmFwaFg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmFwaFh9O214TW91c2VFdmVudC5wcm90b3R5cGUuZ2V0R3JhcGhZPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ3JhcGhZfTsKbXhNb3VzZUV2ZW50LnByb3RvdHlwZS5nZXRTdGF0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlfTtteE1vdXNlRXZlbnQucHJvdG90eXBlLmdldENlbGw9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdldFN0YXRlKCk7cmV0dXJuIG51bGwhPWE/YS5jZWxsOm51bGx9O214TW91c2VFdmVudC5wcm90b3R5cGUuaXNQb3B1cFRyaWdnZXI9ZnVuY3Rpb24oKXtyZXR1cm4gbXhFdmVudC5pc1BvcHVwVHJpZ2dlcih0aGlzLmdldEV2ZW50KCkpfTtteE1vdXNlRXZlbnQucHJvdG90eXBlLmlzQ29uc3VtZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdW1lZH07Cm14TW91c2VFdmVudC5wcm90b3R5cGUuY29uc3VtZT1mdW5jdGlvbihhKXsobnVsbCE9YT9hOm51bGwhPXRoaXMuZXZ0LnRvdWNoZXN8fG14RXZlbnQuaXNNb3VzZUV2ZW50KHRoaXMuZXZ0KSkmJnRoaXMuZXZ0LnByZXZlbnREZWZhdWx0JiZ0aGlzLmV2dC5wcmV2ZW50RGVmYXVsdCgpO214Q2xpZW50LklTX0lFJiYodGhpcy5ldnQucmV0dXJuVmFsdWU9ITApO3RoaXMuY29uc3VtZWQ9ITB9O2Z1bmN0aW9uIG14RXZlbnRTb3VyY2UoYSl7dGhpcy5zZXRFdmVudFNvdXJjZShhKX1teEV2ZW50U291cmNlLnByb3RvdHlwZS5ldmVudExpc3RlbmVycz1udWxsO214RXZlbnRTb3VyY2UucHJvdG90eXBlLmV2ZW50c0VuYWJsZWQ9ITA7bXhFdmVudFNvdXJjZS5wcm90b3R5cGUuZXZlbnRTb3VyY2U9bnVsbDtteEV2ZW50U291cmNlLnByb3RvdHlwZS5pc0V2ZW50c0VuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ldmVudHNFbmFibGVkfTsKbXhFdmVudFNvdXJjZS5wcm90b3R5cGUuc2V0RXZlbnRzRW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLmV2ZW50c0VuYWJsZWQ9YX07bXhFdmVudFNvdXJjZS5wcm90b3R5cGUuZ2V0RXZlbnRTb3VyY2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ldmVudFNvdXJjZX07bXhFdmVudFNvdXJjZS5wcm90b3R5cGUuc2V0RXZlbnRTb3VyY2U9ZnVuY3Rpb24oYSl7dGhpcy5ldmVudFNvdXJjZT1hfTtteEV2ZW50U291cmNlLnByb3RvdHlwZS5hZGRMaXN0ZW5lcj1mdW5jdGlvbihhLGIpe251bGw9PXRoaXMuZXZlbnRMaXN0ZW5lcnMmJih0aGlzLmV2ZW50TGlzdGVuZXJzPVtdKTt0aGlzLmV2ZW50TGlzdGVuZXJzLnB1c2goYSk7dGhpcy5ldmVudExpc3RlbmVycy5wdXNoKGIpfTsKbXhFdmVudFNvdXJjZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI9ZnVuY3Rpb24oYSl7aWYobnVsbCE9dGhpcy5ldmVudExpc3RlbmVycylmb3IodmFyIGI9MDtiPHRoaXMuZXZlbnRMaXN0ZW5lcnMubGVuZ3RoOyl0aGlzLmV2ZW50TGlzdGVuZXJzW2IrMV09PWE/dGhpcy5ldmVudExpc3RlbmVycy5zcGxpY2UoYiwyKTpiKz0yfTsKbXhFdmVudFNvdXJjZS5wcm90b3R5cGUuZmlyZUV2ZW50PWZ1bmN0aW9uKGEsYil7aWYobnVsbCE9dGhpcy5ldmVudExpc3RlbmVycyYmdGhpcy5pc0V2ZW50c0VuYWJsZWQoKSl7bnVsbD09YSYmKGE9bmV3IG14RXZlbnRPYmplY3QpO251bGw9PWImJihiPXRoaXMuZ2V0RXZlbnRTb3VyY2UoKSk7bnVsbD09YiYmKGI9dGhpcyk7Zm9yKHZhciBjPVtiLGFdLGQ9MDtkPHRoaXMuZXZlbnRMaXN0ZW5lcnMubGVuZ3RoO2QrPTIpe3ZhciBlPXRoaXMuZXZlbnRMaXN0ZW5lcnNbZF07bnVsbCE9ZSYmZSE9YS5nZXROYW1lKCl8fHRoaXMuZXZlbnRMaXN0ZW5lcnNbZCsxXS5hcHBseSh0aGlzLGMpfX19Owp2YXIgbXhFdmVudD17YWRkTGlzdGVuZXI6ZnVuY3Rpb24oKXtyZXR1cm4gd2luZG93LmFkZEV2ZW50TGlzdGVuZXI/ZnVuY3Rpb24oYSxiLGMpe2EuYWRkRXZlbnRMaXN0ZW5lcihiLGMsITEpO251bGw9PWEubXhMaXN0ZW5lckxpc3QmJihhLm14TGlzdGVuZXJMaXN0PVtdKTthLm14TGlzdGVuZXJMaXN0LnB1c2goe25hbWU6YixmOmN9KX06ZnVuY3Rpb24oYSxiLGMpe2EuYXR0YWNoRXZlbnQoIm9uIitiLGMpO251bGw9PWEubXhMaXN0ZW5lckxpc3QmJihhLm14TGlzdGVuZXJMaXN0PVtdKTthLm14TGlzdGVuZXJMaXN0LnB1c2goe25hbWU6YixmOmN9KX19KCkscmVtb3ZlTGlzdGVuZXI6ZnVuY3Rpb24oKXt2YXIgYT1mdW5jdGlvbihhLGMsZCl7aWYobnVsbCE9YS5teExpc3RlbmVyTGlzdCl7Yz1hLm14TGlzdGVuZXJMaXN0Lmxlbmd0aDtmb3IodmFyIGI9MDtiPGM7YisrKWlmKGEubXhMaXN0ZW5lckxpc3RbYl0uZj09ZCl7YS5teExpc3RlbmVyTGlzdC5zcGxpY2UoYiwxKTticmVha30wPT0KYS5teExpc3RlbmVyTGlzdC5sZW5ndGgmJihhLm14TGlzdGVuZXJMaXN0PW51bGwpfX07cmV0dXJuIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyP2Z1bmN0aW9uKGIsYyxkKXtiLnJlbW92ZUV2ZW50TGlzdGVuZXIoYyxkLCExKTthKGIsYyxkKX06ZnVuY3Rpb24oYixjLGQpe2IuZGV0YWNoRXZlbnQoIm9uIitjLGQpO2EoYixjLGQpfX0oKSxyZW1vdmVBbGxMaXN0ZW5lcnM6ZnVuY3Rpb24oYSl7dmFyIGI9YS5teExpc3RlbmVyTGlzdDtpZihudWxsIT1iKWZvcig7MDxiLmxlbmd0aDspe3ZhciBjPWJbMF07bXhFdmVudC5yZW1vdmVMaXN0ZW5lcihhLGMubmFtZSxjLmYpfX0sYWRkR2VzdHVyZUxpc3RlbmVyczpmdW5jdGlvbihhLGIsYyxkKXtudWxsIT1iJiZteEV2ZW50LmFkZExpc3RlbmVyKGEsbXhDbGllbnQuSVNfUE9JTlRFUj8icG9pbnRlcmRvd24iOiJtb3VzZWRvd24iLGIpO251bGwhPWMmJm14RXZlbnQuYWRkTGlzdGVuZXIoYSxteENsaWVudC5JU19QT0lOVEVSPyJwb2ludGVybW92ZSI6CiJtb3VzZW1vdmUiLGMpO251bGwhPWQmJm14RXZlbnQuYWRkTGlzdGVuZXIoYSxteENsaWVudC5JU19QT0lOVEVSPyJwb2ludGVydXAiOiJtb3VzZXVwIixkKTshbXhDbGllbnQuSVNfUE9JTlRFUiYmbXhDbGllbnQuSVNfVE9VQ0gmJihudWxsIT1iJiZteEV2ZW50LmFkZExpc3RlbmVyKGEsInRvdWNoc3RhcnQiLGIpLG51bGwhPWMmJm14RXZlbnQuYWRkTGlzdGVuZXIoYSwidG91Y2htb3ZlIixjKSxudWxsIT1kJiZteEV2ZW50LmFkZExpc3RlbmVyKGEsInRvdWNoZW5kIixkKSl9LHJlbW92ZUdlc3R1cmVMaXN0ZW5lcnM6ZnVuY3Rpb24oYSxiLGMsZCl7bnVsbCE9YiYmbXhFdmVudC5yZW1vdmVMaXN0ZW5lcihhLG14Q2xpZW50LklTX1BPSU5URVI/InBvaW50ZXJkb3duIjoibW91c2Vkb3duIixiKTtudWxsIT1jJiZteEV2ZW50LnJlbW92ZUxpc3RlbmVyKGEsbXhDbGllbnQuSVNfUE9JTlRFUj8icG9pbnRlcm1vdmUiOiJtb3VzZW1vdmUiLGMpO251bGwhPWQmJm14RXZlbnQucmVtb3ZlTGlzdGVuZXIoYSwKbXhDbGllbnQuSVNfUE9JTlRFUj8icG9pbnRlcnVwIjoibW91c2V1cCIsZCk7IW14Q2xpZW50LklTX1BPSU5URVImJm14Q2xpZW50LklTX1RPVUNIJiYobnVsbCE9YiYmbXhFdmVudC5yZW1vdmVMaXN0ZW5lcihhLCJ0b3VjaHN0YXJ0IixiKSxudWxsIT1jJiZteEV2ZW50LnJlbW92ZUxpc3RlbmVyKGEsInRvdWNobW92ZSIsYyksbnVsbCE9ZCYmbXhFdmVudC5yZW1vdmVMaXN0ZW5lcihhLCJ0b3VjaGVuZCIsZCkpfSxyZWRpcmVjdE1vdXNlRXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGcpe3ZhciBrPWZ1bmN0aW9uKGEpe3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiBjP2MoYSk6Y307bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKGEsZnVuY3Rpb24oYSl7bnVsbCE9ZD9kKGEpOm14RXZlbnQuaXNDb25zdW1lZChhKXx8Yi5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX0RPV04sbmV3IG14TW91c2VFdmVudChhLGsoYSkpKX0sZnVuY3Rpb24oYSl7bnVsbCE9ZT9lKGEpOm14RXZlbnQuaXNDb25zdW1lZChhKXx8CmIuZmlyZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9NT1ZFLG5ldyBteE1vdXNlRXZlbnQoYSxrKGEpKSl9LGZ1bmN0aW9uKGEpe251bGwhPWY/ZihhKTpteEV2ZW50LmlzQ29uc3VtZWQoYSl8fGIuZmlyZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9VUCxuZXcgbXhNb3VzZUV2ZW50KGEsayhhKSkpfSk7bXhFdmVudC5hZGRMaXN0ZW5lcihhLCJkYmxjbGljayIsZnVuY3Rpb24oYSl7aWYobnVsbCE9ZylnKGEpO2Vsc2UgaWYoIW14RXZlbnQuaXNDb25zdW1lZChhKSl7dmFyIGM9ayhhKTtiLmRibENsaWNrKGEsbnVsbCE9Yz9jLmNlbGw6bnVsbCl9fSl9LHJlbGVhc2U6ZnVuY3Rpb24oYSl7dHJ5e2lmKG51bGwhPWEpe214RXZlbnQucmVtb3ZlQWxsTGlzdGVuZXJzKGEpO3ZhciBiPWEuY2hpbGROb2RlcztpZihudWxsIT1iKXt2YXIgYz1iLmxlbmd0aDtmb3IoYT0wO2E8YzthKz0xKW14RXZlbnQucmVsZWFzZShiW2FdKX19fWNhdGNoKGQpe319LGFkZE1vdXNlV2hlZWxMaXN0ZW5lcjpmdW5jdGlvbihhLApiKXtpZihudWxsIT1hKXtiPW51bGwhPWI/Yjp3aW5kb3c7aWYobXhDbGllbnQuSVNfU0YmJiFteENsaWVudC5JU19UT1VDSCl7dmFyIGM9MTtteEV2ZW50LmFkZExpc3RlbmVyKGIsImdlc3R1cmVzdGFydCIsZnVuY3Rpb24oYSl7bXhFdmVudC5jb25zdW1lKGEpO2M9MX0pO214RXZlbnQuYWRkTGlzdGVuZXIoYiwiZ2VzdHVyZWNoYW5nZSIsZnVuY3Rpb24oYil7bXhFdmVudC5jb25zdW1lKGIpO3ZhciBkPWMtYi5zY2FsZTsuMjxNYXRoLmFicyhkKSYmKGEoYiwwPmQsITApLGM9Yi5zY2FsZSl9KTtteEV2ZW50LmFkZExpc3RlbmVyKGIsImdlc3R1cmVlbmQiLGZ1bmN0aW9uKGEpe214RXZlbnQuY29uc3VtZShhKX0pfW14RXZlbnQuYWRkTGlzdGVuZXIoYiwid2hlZWwiLGZ1bmN0aW9uKGIpe251bGw9PWImJihiPXdpbmRvdy5ldmVudCk7Yi5jdHJsS2V5JiZiLnByZXZlbnREZWZhdWx0KCk7KC41PE1hdGguYWJzKGIuZGVsdGFYKXx8LjU8TWF0aC5hYnMoYi5kZWx0YVkpKSYmYShiLDA9PQpiLmRlbHRhWT8wPC1iLmRlbHRhWDowPC1iLmRlbHRhWSl9KX19LGRpc2FibGVDb250ZXh0TWVudTpmdW5jdGlvbihhKXtteEV2ZW50LmFkZExpc3RlbmVyKGEsImNvbnRleHRtZW51IixmdW5jdGlvbihhKXthLnByZXZlbnREZWZhdWx0JiZhLnByZXZlbnREZWZhdWx0KCk7cmV0dXJuITF9KX0sZ2V0U291cmNlOmZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hLnNyY0VsZW1lbnQ/YS5zcmNFbGVtZW50OmEudGFyZ2V0fSxpc0NvbnN1bWVkOmZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hLmlzQ29uc3VtZWQmJmEuaXNDb25zdW1lZH0saXNUb3VjaEV2ZW50OmZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hLnBvaW50ZXJUeXBlPyJ0b3VjaCI9PWEucG9pbnRlclR5cGV8fGEucG9pbnRlclR5cGU9PT1hLk1TUE9JTlRFUl9UWVBFX1RPVUNIOm51bGwhPWEubW96SW5wdXRTb3VyY2U/NT09YS5tb3pJbnB1dFNvdXJjZTowPT1hLnR5cGUuaW5kZXhPZigidG91Y2giKX0saXNQZW5FdmVudDpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9CmEucG9pbnRlclR5cGU/InBlbiI9PWEucG9pbnRlclR5cGV8fGEucG9pbnRlclR5cGU9PT1hLk1TUE9JTlRFUl9UWVBFX1BFTjpudWxsIT1hLm1veklucHV0U291cmNlPzI9PWEubW96SW5wdXRTb3VyY2U6MD09YS50eXBlLmluZGV4T2YoInBlbiIpfSxpc011bHRpVG91Y2hFdmVudDpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YS50eXBlJiYwPT1hLnR5cGUuaW5kZXhPZigidG91Y2giKSYmbnVsbCE9YS50b3VjaGVzJiYxPGEudG91Y2hlcy5sZW5ndGh9LGlzTW91c2VFdmVudDpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YS5wb2ludGVyVHlwZT8ibW91c2UiPT1hLnBvaW50ZXJUeXBlfHxhLnBvaW50ZXJUeXBlPT09YS5NU1BPSU5URVJfVFlQRV9NT1VTRTpudWxsIT1hLm1veklucHV0U291cmNlPzE9PWEubW96SW5wdXRTb3VyY2U6MD09YS50eXBlLmluZGV4T2YoIm1vdXNlIil9LGlzTGVmdE1vdXNlQnV0dG9uOmZ1bmN0aW9uKGEpe3JldHVybiJidXR0b25zImluIGEmJigibW91c2Vkb3duIj09CmEudHlwZXx8Im1vdXNlbW92ZSI9PWEudHlwZSk/MT09YS5idXR0b25zOiJ3aGljaCJpbiBhPzE9PT1hLndoaWNoOjE9PT1hLmJ1dHRvbn0saXNNaWRkbGVNb3VzZUJ1dHRvbjpmdW5jdGlvbihhKXtyZXR1cm4id2hpY2giaW4gYT8yPT09YS53aGljaDo0PT09YS5idXR0b259LGlzUmlnaHRNb3VzZUJ1dHRvbjpmdW5jdGlvbihhKXtyZXR1cm4id2hpY2giaW4gYT8zPT09YS53aGljaDoyPT09YS5idXR0b259LGlzUG9wdXBUcmlnZ2VyOmZ1bmN0aW9uKGEpe3JldHVybiBteEV2ZW50LmlzUmlnaHRNb3VzZUJ1dHRvbihhKXx8bXhDbGllbnQuSVNfTUFDJiZteEV2ZW50LmlzQ29udHJvbERvd24oYSkmJiFteEV2ZW50LmlzU2hpZnREb3duKGEpJiYhbXhFdmVudC5pc01ldGFEb3duKGEpJiYhbXhFdmVudC5pc0FsdERvd24oYSl9LGlzU2hpZnREb3duOmZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hP2Euc2hpZnRLZXk6ITF9LGlzQWx0RG93bjpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YT8KYS5hbHRLZXk6ITF9LGlzQ29udHJvbERvd246ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/YS5jdHJsS2V5OiExfSxpc01ldGFEb3duOmZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hP2EubWV0YUtleTohMX0sZ2V0TWFpbkV2ZW50OmZ1bmN0aW9uKGEpeyJ0b3VjaHN0YXJ0IiE9YS50eXBlJiYidG91Y2htb3ZlIiE9YS50eXBlfHxudWxsPT1hLnRvdWNoZXN8fG51bGw9PWEudG91Y2hlc1swXT8idG91Y2hlbmQiPT1hLnR5cGUmJm51bGwhPWEuY2hhbmdlZFRvdWNoZXMmJm51bGwhPWEuY2hhbmdlZFRvdWNoZXNbMF0mJihhPWEuY2hhbmdlZFRvdWNoZXNbMF0pOmE9YS50b3VjaGVzWzBdO3JldHVybiBhfSxnZXRDbGllbnRYOmZ1bmN0aW9uKGEpe3JldHVybiBteEV2ZW50LmdldE1haW5FdmVudChhKS5jbGllbnRYfSxnZXRDbGllbnRZOmZ1bmN0aW9uKGEpe3JldHVybiBteEV2ZW50LmdldE1haW5FdmVudChhKS5jbGllbnRZfSxjb25zdW1lOmZ1bmN0aW9uKGEsYixjKXtjPW51bGwhPQpjP2M6ITA7aWYobnVsbCE9Yj9iOjEpYS5wcmV2ZW50RGVmYXVsdD8oYyYmYS5zdG9wUHJvcGFnYXRpb24oKSxhLnByZXZlbnREZWZhdWx0KCkpOmMmJihhLmNhbmNlbEJ1YmJsZT0hMCk7YS5pc0NvbnN1bWVkPSEwO2EucHJldmVudERlZmF1bHR8fChhLnJldHVyblZhbHVlPSExKX0sTEFCRUxfSEFORExFOi0xLFJPVEFUSU9OX0hBTkRMRTotMixDVVNUT01fSEFORExFOi0xMDAsVklSVFVBTF9IQU5ETEU6LTFFNSxNT1VTRV9ET1dOOiJtb3VzZURvd24iLE1PVVNFX01PVkU6Im1vdXNlTW92ZSIsTU9VU0VfVVA6Im1vdXNlVXAiLEFDVElWQVRFOiJhY3RpdmF0ZSIsUkVTSVpFX1NUQVJUOiJyZXNpemVTdGFydCIsUkVTSVpFOiJyZXNpemUiLFJFU0laRV9FTkQ6InJlc2l6ZUVuZCIsTU9WRV9TVEFSVDoibW92ZVN0YXJ0IixNT1ZFOiJtb3ZlIixNT1ZFX0VORDoibW92ZUVuZCIsUEFOX1NUQVJUOiJwYW5TdGFydCIsUEFOOiJwYW4iLFBBTl9FTkQ6InBhbkVuZCIsTUlOSU1JWkU6Im1pbmltaXplIiwKTk9STUFMSVpFOiJub3JtYWxpemUiLE1BWElNSVpFOiJtYXhpbWl6ZSIsSElERToiaGlkZSIsU0hPVzoic2hvdyIsQ0xPU0U6ImNsb3NlIixERVNUUk9ZOiJkZXN0cm95IixSRUZSRVNIOiJyZWZyZXNoIixTSVpFOiJzaXplIixTRUxFQ1Q6InNlbGVjdCIsRklSRUQ6ImZpcmVkIixGSVJFX01PVVNFX0VWRU5UOiJmaXJlTW91c2VFdmVudCIsR0VTVFVSRToiZ2VzdHVyZSIsVEFQX0FORF9IT0xEOiJ0YXBBbmRIb2xkIixHRVQ6ImdldCIsUkVDRUlWRToicmVjZWl2ZSIsQ09OTkVDVDoiY29ubmVjdCIsRElTQ09OTkVDVDoiZGlzY29ubmVjdCIsU1VTUEVORDoic3VzcGVuZCIsUkVTVU1FOiJyZXN1bWUiLE1BUks6Im1hcmsiLFJPT1Q6InJvb3QiLFBPU1Q6InBvc3QiLE9QRU46Im9wZW4iLFNBVkU6InNhdmUiLEJFRk9SRV9BRERfVkVSVEVYOiJiZWZvcmVBZGRWZXJ0ZXgiLEFERF9WRVJURVg6ImFkZFZlcnRleCIsQUZURVJfQUREX1ZFUlRFWDoiYWZ0ZXJBZGRWZXJ0ZXgiLERPTkU6ImRvbmUiLApFWEVDVVRFOiJleGVjdXRlIixFWEVDVVRFRDoiZXhlY3V0ZWQiLEJFR0lOX1VQREFURToiYmVnaW5VcGRhdGUiLFNUQVJUX0VESVQ6InN0YXJ0RWRpdCIsRU5EX1VQREFURToiZW5kVXBkYXRlIixFTkRfRURJVDoiZW5kRWRpdCIsQkVGT1JFX1VORE86ImJlZm9yZVVuZG8iLFVORE86InVuZG8iLFJFRE86InJlZG8iLENIQU5HRToiY2hhbmdlIixOT1RJRlk6Im5vdGlmeSIsTEFZT1VUX0NFTExTOiJsYXlvdXRDZWxscyIsQ0xJQ0s6ImNsaWNrIixTQ0FMRToic2NhbGUiLFRSQU5TTEFURToidHJhbnNsYXRlIixTQ0FMRV9BTkRfVFJBTlNMQVRFOiJzY2FsZUFuZFRyYW5zbGF0ZSIsVVA6InVwIixET1dOOiJkb3duIixBREQ6ImFkZCIsUkVNT1ZFOiJyZW1vdmUiLENMRUFSOiJjbGVhciIsQUREX0NFTExTOiJhZGRDZWxscyIsQ0VMTFNfQURERUQ6ImNlbGxzQWRkZWQiLE1PVkVfQ0VMTFM6Im1vdmVDZWxscyIsQ0VMTFNfTU9WRUQ6ImNlbGxzTW92ZWQiLFJFU0laRV9DRUxMUzoicmVzaXplQ2VsbHMiLApDRUxMU19SRVNJWkVEOiJjZWxsc1Jlc2l6ZWQiLFRPR0dMRV9DRUxMUzoidG9nZ2xlQ2VsbHMiLENFTExTX1RPR0dMRUQ6ImNlbGxzVG9nZ2xlZCIsT1JERVJfQ0VMTFM6Im9yZGVyQ2VsbHMiLENFTExTX09SREVSRUQ6ImNlbGxzT3JkZXJlZCIsUkVNT1ZFX0NFTExTOiJyZW1vdmVDZWxscyIsQ0VMTFNfUkVNT1ZFRDoiY2VsbHNSZW1vdmVkIixHUk9VUF9DRUxMUzoiZ3JvdXBDZWxscyIsVU5HUk9VUF9DRUxMUzoidW5ncm91cENlbGxzIixSRU1PVkVfQ0VMTFNfRlJPTV9QQVJFTlQ6InJlbW92ZUNlbGxzRnJvbVBhcmVudCIsRk9MRF9DRUxMUzoiZm9sZENlbGxzIixDRUxMU19GT0xERUQ6ImNlbGxzRm9sZGVkIixBTElHTl9DRUxMUzoiYWxpZ25DZWxscyIsTEFCRUxfQ0hBTkdFRDoibGFiZWxDaGFuZ2VkIixDT05ORUNUX0NFTEw6ImNvbm5lY3RDZWxsIixDRUxMX0NPTk5FQ1RFRDoiY2VsbENvbm5lY3RlZCIsU1BMSVRfRURHRToic3BsaXRFZGdlIixGTElQX0VER0U6ImZsaXBFZGdlIiwKU1RBUlRfRURJVElORzoic3RhcnRFZGl0aW5nIixFRElUSU5HX1NUQVJURUQ6ImVkaXRpbmdTdGFydGVkIixFRElUSU5HX1NUT1BQRUQ6ImVkaXRpbmdTdG9wcGVkIixBRERfT1ZFUkxBWToiYWRkT3ZlcmxheSIsUkVNT1ZFX09WRVJMQVk6InJlbW92ZU92ZXJsYXkiLFVQREFURV9DRUxMX1NJWkU6InVwZGF0ZUNlbGxTaXplIixFU0NBUEU6ImVzY2FwZSIsRE9VQkxFX0NMSUNLOiJkb3VibGVDbGljayIsU1RBUlQ6InN0YXJ0IixSRVNFVDoicmVzZXQifTtmdW5jdGlvbiBteFhtbFJlcXVlc3QoYSxiLGMsZCxlLGYpe3RoaXMudXJsPWE7dGhpcy5wYXJhbXM9Yjt0aGlzLm1ldGhvZD1jfHwiUE9TVCI7dGhpcy5hc3luYz1udWxsIT1kP2Q6ITA7dGhpcy51c2VybmFtZT1lO3RoaXMucGFzc3dvcmQ9Zn1teFhtbFJlcXVlc3QucHJvdG90eXBlLnVybD1udWxsO214WG1sUmVxdWVzdC5wcm90b3R5cGUucGFyYW1zPW51bGw7bXhYbWxSZXF1ZXN0LnByb3RvdHlwZS5tZXRob2Q9bnVsbDsKbXhYbWxSZXF1ZXN0LnByb3RvdHlwZS5hc3luYz1udWxsO214WG1sUmVxdWVzdC5wcm90b3R5cGUuYmluYXJ5PSExO214WG1sUmVxdWVzdC5wcm90b3R5cGUud2l0aENyZWRlbnRpYWxzPSExO214WG1sUmVxdWVzdC5wcm90b3R5cGUudXNlcm5hbWU9bnVsbDtteFhtbFJlcXVlc3QucHJvdG90eXBlLnBhc3N3b3JkPW51bGw7bXhYbWxSZXF1ZXN0LnByb3RvdHlwZS5yZXF1ZXN0PW51bGw7bXhYbWxSZXF1ZXN0LnByb3RvdHlwZS5kZWNvZGVTaW11bGF0ZVZhbHVlcz0hMTtteFhtbFJlcXVlc3QucHJvdG90eXBlLmlzQmluYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmluYXJ5fTtteFhtbFJlcXVlc3QucHJvdG90eXBlLnNldEJpbmFyeT1mdW5jdGlvbihhKXt0aGlzLmJpbmFyeT1hfTtteFhtbFJlcXVlc3QucHJvdG90eXBlLmdldFRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXF1ZXN0LnJlc3BvbnNlVGV4dH07Cm14WG1sUmVxdWVzdC5wcm90b3R5cGUuaXNSZWFkeT1mdW5jdGlvbigpe3JldHVybiA0PT10aGlzLnJlcXVlc3QucmVhZHlTdGF0ZX07bXhYbWxSZXF1ZXN0LnByb3RvdHlwZS5nZXREb2N1bWVudEVsZW1lbnQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdldFhtbCgpO3JldHVybiBudWxsIT1hP2EuZG9jdW1lbnRFbGVtZW50Om51bGx9O214WG1sUmVxdWVzdC5wcm90b3R5cGUuZ2V0WG1sPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5yZXF1ZXN0LnJlc3BvbnNlWE1MO2lmKDk8PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8bnVsbD09YXx8bnVsbD09YS5kb2N1bWVudEVsZW1lbnQpYT1teFV0aWxzLnBhcnNlWG1sKHRoaXMucmVxdWVzdC5yZXNwb25zZVRleHQpO3JldHVybiBhfTtteFhtbFJlcXVlc3QucHJvdG90eXBlLmdldFRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXF1ZXN0LnJlc3BvbnNlVGV4dH07Cm14WG1sUmVxdWVzdC5wcm90b3R5cGUuZ2V0U3RhdHVzPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMucmVxdWVzdD90aGlzLnJlcXVlc3Quc3RhdHVzOm51bGx9O214WG1sUmVxdWVzdC5wcm90b3R5cGUuY3JlYXRlPWZ1bmN0aW9uKCl7aWYod2luZG93LlhNTEh0dHBSZXF1ZXN0KXJldHVybiBmdW5jdGlvbigpe3ZhciBhPW5ldyBYTUxIdHRwUmVxdWVzdDt0aGlzLmlzQmluYXJ5KCkmJmEub3ZlcnJpZGVNaW1lVHlwZSYmYS5vdmVycmlkZU1pbWVUeXBlKCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkIik7cmV0dXJuIGF9O2lmKCJ1bmRlZmluZWQiIT10eXBlb2YgQWN0aXZlWE9iamVjdClyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoIk1pY3Jvc29mdC5YTUxIVFRQIil9fSgpOwpteFhtbFJlcXVlc3QucHJvdG90eXBlLnNlbmQ9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5yZXF1ZXN0PXRoaXMuY3JlYXRlKCk7bnVsbCE9dGhpcy5yZXF1ZXN0JiYobnVsbCE9YSYmKHRoaXMucmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2U9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmlzUmVhZHkoKSYmKGEodGhpcyksdGhpcy5yZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsKX0pKSx0aGlzLnJlcXVlc3Qub3Blbih0aGlzLm1ldGhvZCx0aGlzLnVybCx0aGlzLmFzeW5jLHRoaXMudXNlcm5hbWUsdGhpcy5wYXNzd29yZCksdGhpcy5zZXRSZXF1ZXN0SGVhZGVycyh0aGlzLnJlcXVlc3QsdGhpcy5wYXJhbXMpLHdpbmRvdy5YTUxIdHRwUmVxdWVzdCYmdGhpcy53aXRoQ3JlZGVudGlhbHMmJih0aGlzLnJlcXVlc3Qud2l0aENyZWRlbnRpYWxzPSJ0cnVlIiksIW14Q2xpZW50LklTX1FVSVJLUyYmKG51bGw9PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8OTxkb2N1bWVudC5kb2N1bWVudE1vZGUpJiYKd2luZG93LlhNTEh0dHBSZXF1ZXN0JiZudWxsIT1jJiZudWxsIT1kJiYodGhpcy5yZXF1ZXN0LnRpbWVvdXQ9Yyx0aGlzLnJlcXVlc3Qub250aW1lb3V0PWQpLHRoaXMucmVxdWVzdC5zZW5kKHRoaXMucGFyYW1zKSl9O214WG1sUmVxdWVzdC5wcm90b3R5cGUuc2V0UmVxdWVzdEhlYWRlcnM9ZnVuY3Rpb24oYSxiKXtudWxsIT1iJiZhLnNldFJlcXVlc3RIZWFkZXIoIkNvbnRlbnQtVHlwZSIsImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCIpfTsKbXhYbWxSZXF1ZXN0LnByb3RvdHlwZS5zaW11bGF0ZT1mdW5jdGlvbihhLGIpe2E9YXx8ZG9jdW1lbnQ7dmFyIGM9bnVsbDthPT1kb2N1bWVudCYmKGM9d2luZG93Lm9uYmVmb3JldW5sb2FkLHdpbmRvdy5vbmJlZm9yZXVubG9hZD1udWxsKTt2YXIgZD1hLmNyZWF0ZUVsZW1lbnQoImZvcm0iKTtkLnNldEF0dHJpYnV0ZSgibWV0aG9kIix0aGlzLm1ldGhvZCk7ZC5zZXRBdHRyaWJ1dGUoImFjdGlvbiIsdGhpcy51cmwpO251bGwhPWImJmQuc2V0QXR0cmlidXRlKCJ0YXJnZXQiLGIpO2Quc3R5bGUuZGlzcGxheT0ibm9uZSI7ZC5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4iO2Zvcih2YXIgZT0wPHRoaXMucGFyYW1zLmluZGV4T2YoIiYiKT90aGlzLnBhcmFtcy5zcGxpdCgiJiIpOnRoaXMucGFyYW1zLnNwbGl0KCksZj0wO2Y8ZS5sZW5ndGg7ZisrKXt2YXIgZz1lW2ZdLmluZGV4T2YoIj0iKTtpZigwPGcpe3ZhciBrPWVbZl0uc3Vic3RyaW5nKDAsZyksZz1lW2ZdLnN1YnN0cmluZyhnKwoxKTt0aGlzLmRlY29kZVNpbXVsYXRlVmFsdWVzJiYoZz1kZWNvZGVVUklDb21wb25lbnQoZykpO3ZhciBsPWEuY3JlYXRlRWxlbWVudCgidGV4dGFyZWEiKTtsLnNldEF0dHJpYnV0ZSgid3JhcCIsIm9mZiIpO2wuc2V0QXR0cmlidXRlKCJuYW1lIixrKTtteFV0aWxzLndyaXRlKGwsZyk7ZC5hcHBlbmRDaGlsZChsKX19YS5ib2R5LmFwcGVuZENoaWxkKGQpO2Quc3VibWl0KCk7bnVsbCE9ZC5wYXJlbnROb2RlJiZkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCk7bnVsbCE9YyYmKHdpbmRvdy5vbmJlZm9yZXVubG9hZD1jKX07CnZhciBteENsaXBib2FyZD17U1RFUFNJWkU6MTAsaW5zZXJ0Q291bnQ6MSxjZWxsczpudWxsLHNldENlbGxzOmZ1bmN0aW9uKGEpe214Q2xpcGJvYXJkLmNlbGxzPWF9LGdldENlbGxzOmZ1bmN0aW9uKCl7cmV0dXJuIG14Q2xpcGJvYXJkLmNlbGxzfSxpc0VtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PW14Q2xpcGJvYXJkLmdldENlbGxzKCl9LGN1dDpmdW5jdGlvbihhLGIpe2I9bXhDbGlwYm9hcmQuY29weShhLGIpO214Q2xpcGJvYXJkLmluc2VydENvdW50PTA7bXhDbGlwYm9hcmQucmVtb3ZlQ2VsbHMoYSxiKTtyZXR1cm4gYn0scmVtb3ZlQ2VsbHM6ZnVuY3Rpb24oYSxiKXthLnJlbW92ZUNlbGxzKGIpfSxjb3B5OmZ1bmN0aW9uKGEsYil7Yj1ifHxhLmdldFNlbGVjdGlvbkNlbGxzKCk7dmFyIGM9YS5nZXRFeHBvcnRhYmxlQ2VsbHMoYS5tb2RlbC5nZXRUb3Btb3N0Q2VsbHMoYikpO214Q2xpcGJvYXJkLmluc2VydENvdW50PTE7bXhDbGlwYm9hcmQuc2V0Q2VsbHMoYS5jbG9uZUNlbGxzKGMpKTsKcmV0dXJuIGN9LHBhc3RlOmZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7aWYoIW14Q2xpcGJvYXJkLmlzRW1wdHkoKSl7dmFyIGI9YS5nZXRJbXBvcnRhYmxlQ2VsbHMobXhDbGlwYm9hcmQuZ2V0Q2VsbHMoKSksYz1teENsaXBib2FyZC5pbnNlcnRDb3VudCpteENsaXBib2FyZC5TVEVQU0laRSxkPWEuZ2V0RGVmYXVsdFBhcmVudCgpLGI9YS5pbXBvcnRDZWxscyhiLGMsYyxkKTtteENsaXBib2FyZC5pbnNlcnRDb3VudCsrO2Euc2V0U2VsZWN0aW9uQ2VsbHMoYil9cmV0dXJuIGJ9fTsKZnVuY3Rpb24gbXhXaW5kb3coYSxiLGMsZCxlLGYsZyxrLGwsbSl7bnVsbCE9YiYmKGc9bnVsbCE9Zz9nOiEwLHRoaXMuY29udGVudD1iLHRoaXMuaW5pdChjLGQsZSxmLG0pLHRoaXMuaW5zdGFsbE1heGltaXplSGFuZGxlcigpLHRoaXMuaW5zdGFsbE1pbmltaXplSGFuZGxlcigpLHRoaXMuaW5zdGFsbENsb3NlSGFuZGxlcigpLHRoaXMuc2V0TWluaW1pemFibGUoZyksdGhpcy5zZXRUaXRsZShhKSwobnVsbD09a3x8aykmJnRoaXMuaW5zdGFsbE1vdmVIYW5kbGVyKCksbnVsbCE9bCYmbnVsbCE9bC5wYXJlbnROb2RlP2wucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodGhpcy5kaXYsbCk6ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRpdikpfW14V2luZG93LnByb3RvdHlwZT1uZXcgbXhFdmVudFNvdXJjZTtteFdpbmRvdy5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhXaW5kb3c7bXhXaW5kb3cucHJvdG90eXBlLmNsb3NlSW1hZ2U9bXhDbGllbnQuaW1hZ2VCYXNlUGF0aCsiL2Nsb3NlLmdpZiI7Cm14V2luZG93LnByb3RvdHlwZS5taW5pbWl6ZUltYWdlPW14Q2xpZW50LmltYWdlQmFzZVBhdGgrIi9taW5pbWl6ZS5naWYiO214V2luZG93LnByb3RvdHlwZS5ub3JtYWxpemVJbWFnZT1teENsaWVudC5pbWFnZUJhc2VQYXRoKyIvbm9ybWFsaXplLmdpZiI7bXhXaW5kb3cucHJvdG90eXBlLm1heGltaXplSW1hZ2U9bXhDbGllbnQuaW1hZ2VCYXNlUGF0aCsiL21heGltaXplLmdpZiI7bXhXaW5kb3cucHJvdG90eXBlLnJlc2l6ZUltYWdlPW14Q2xpZW50LmltYWdlQmFzZVBhdGgrIi9yZXNpemUuZ2lmIjtteFdpbmRvdy5wcm90b3R5cGUudmlzaWJsZT0hMTtteFdpbmRvdy5wcm90b3R5cGUubWluaW11bVNpemU9bmV3IG14UmVjdGFuZ2xlKDAsMCw1MCw0MCk7bXhXaW5kb3cucHJvdG90eXBlLmRlc3Ryb3lPbkNsb3NlPSEwOwpteFdpbmRvdy5wcm90b3R5cGUuY29udGVudEhlaWdodENvcnJlY3Rpb249OD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHw3PT1kb2N1bWVudC5kb2N1bWVudE1vZGU/NjoyO214V2luZG93LnByb3RvdHlwZS50aXRsZT1udWxsO214V2luZG93LnByb3RvdHlwZS5jb250ZW50PW51bGw7Cm14V2luZG93LnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKGEsYixjLGQsZSl7ZT1udWxsIT1lP2U6Im14V2luZG93Ijt0aGlzLmRpdj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTt0aGlzLmRpdi5jbGFzc05hbWU9ZTt0aGlzLmRpdi5zdHlsZS5sZWZ0PWErInB4Ijt0aGlzLmRpdi5zdHlsZS50b3A9YisicHgiO3RoaXMudGFibGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGFibGUiKTt0aGlzLnRhYmxlLmNsYXNzTmFtZT1lO214Q2xpZW50LklTX1BPSU5URVImJih0aGlzLmRpdi5zdHlsZS50b3VjaEFjdGlvbj0ibm9uZSIpO251bGwhPWMmJihteENsaWVudC5JU19RVUlSS1N8fCh0aGlzLmRpdi5zdHlsZS53aWR0aD1jKyJweCIpLHRoaXMudGFibGUuc3R5bGUud2lkdGg9YysicHgiKTtudWxsIT1kJiYobXhDbGllbnQuSVNfUVVJUktTfHwodGhpcy5kaXYuc3R5bGUuaGVpZ2h0PWQrInB4IiksdGhpcy50YWJsZS5zdHlsZS5oZWlnaHQ9ZCsicHgiKTthPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRib2R5Iik7CmI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidHIiKTt0aGlzLnRpdGxlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRkIik7dGhpcy50aXRsZS5jbGFzc05hbWU9ZSsiVGl0bGUiO3RoaXMuYnV0dG9ucz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTt0aGlzLmJ1dHRvbnMuc3R5bGUucG9zaXRpb249ImFic29sdXRlIjt0aGlzLmJ1dHRvbnMuc3R5bGUuZGlzcGxheT0iaW5saW5lLWJsb2NrIjt0aGlzLmJ1dHRvbnMuc3R5bGUucmlnaHQ9IjRweCI7dGhpcy5idXR0b25zLnN0eWxlLnRvcD0iNXB4Ijt0aGlzLnRpdGxlLmFwcGVuZENoaWxkKHRoaXMuYnV0dG9ucyk7Yi5hcHBlbmRDaGlsZCh0aGlzLnRpdGxlKTthLmFwcGVuZENoaWxkKGIpO2I9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidHIiKTt0aGlzLnRkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRkIik7dGhpcy50ZC5jbGFzc05hbWU9ZSsiUGFuZSI7Nz09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlJiYodGhpcy50ZC5zdHlsZS5oZWlnaHQ9CiIxMDAlIik7dGhpcy5jb250ZW50V3JhcHBlcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTt0aGlzLmNvbnRlbnRXcmFwcGVyLmNsYXNzTmFtZT1lKyJQYW5lIjt0aGlzLmNvbnRlbnRXcmFwcGVyLnN0eWxlLndpZHRoPSIxMDAlIjt0aGlzLmNvbnRlbnRXcmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuY29udGVudCk7aWYobXhDbGllbnQuSVNfUVVJUktTfHwiRElWIiE9dGhpcy5jb250ZW50Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkpdGhpcy5jb250ZW50V3JhcHBlci5zdHlsZS5oZWlnaHQ9IjEwMCUiO3RoaXMudGQuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50V3JhcHBlcik7Yi5hcHBlbmRDaGlsZCh0aGlzLnRkKTthLmFwcGVuZENoaWxkKGIpO3RoaXMudGFibGUuYXBwZW5kQ2hpbGQoYSk7dGhpcy5kaXYuYXBwZW5kQ2hpbGQodGhpcy50YWJsZSk7ZT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmFjdGl2YXRlKCl9KTtteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnModGhpcy50aXRsZSwKZSk7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKHRoaXMudGFibGUsZSk7dGhpcy5oaWRlKCl9O214V2luZG93LnByb3RvdHlwZS5zZXRUaXRsZT1mdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcy50aXRsZS5maXJzdENoaWxkO251bGwhPWI7KXt2YXIgYz1iLm5leHRTaWJsaW5nO2Iubm9kZVR5cGU9PW14Q29uc3RhbnRzLk5PREVUWVBFX1RFWFQmJmIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKTtiPWN9bXhVdGlscy53cml0ZSh0aGlzLnRpdGxlLGF8fCIiKTt0aGlzLnRpdGxlLmFwcGVuZENoaWxkKHRoaXMuYnV0dG9ucyl9O214V2luZG93LnByb3RvdHlwZS5zZXRTY3JvbGxhYmxlPWZ1bmN0aW9uKGEpe2lmKG51bGw9PW5hdmlnYXRvci51c2VyQWdlbnR8fDA+bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJQcmVzdG8vMi41IikpdGhpcy5jb250ZW50V3JhcHBlci5zdHlsZS5vdmVyZmxvdz1hPyJhdXRvIjoiaGlkZGVuIn07Cm14V2luZG93LnByb3RvdHlwZS5hY3RpdmF0ZT1mdW5jdGlvbigpe2lmKG14V2luZG93LmFjdGl2ZVdpbmRvdyE9dGhpcyl7dmFyIGE9bXhVdGlscy5nZXRDdXJyZW50U3R5bGUodGhpcy5nZXRFbGVtZW50KCkpLGE9bnVsbCE9YT9hLnpJbmRleDozO2lmKG14V2luZG93LmFjdGl2ZVdpbmRvdyl7dmFyIGI9bXhXaW5kb3cuYWN0aXZlV2luZG93LmdldEVsZW1lbnQoKTtudWxsIT1iJiZudWxsIT1iLnN0eWxlJiYoYi5zdHlsZS56SW5kZXg9YSl9Yj1teFdpbmRvdy5hY3RpdmVXaW5kb3c7dGhpcy5nZXRFbGVtZW50KCkuc3R5bGUuekluZGV4PXBhcnNlSW50KGEpKzE7bXhXaW5kb3cuYWN0aXZlV2luZG93PXRoaXM7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5BQ1RJVkFURSwicHJldmlvdXNXaW5kb3ciLGIpKX19O214V2luZG93LnByb3RvdHlwZS5nZXRFbGVtZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGl2fTsKbXhXaW5kb3cucHJvdG90eXBlLmZpdD1mdW5jdGlvbigpe214VXRpbHMuZml0KHRoaXMuZGl2KX07bXhXaW5kb3cucHJvdG90eXBlLmlzUmVzaXphYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMucmVzaXplPyJub25lIiE9dGhpcy5yZXNpemUuc3R5bGUuZGlzcGxheTohMX07Cm14V2luZG93LnByb3RvdHlwZS5zZXRSZXNpemFibGU9ZnVuY3Rpb24oYSl7aWYoYSlpZihudWxsPT10aGlzLnJlc2l6ZSl7dGhpcy5yZXNpemU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIik7dGhpcy5yZXNpemUuc3R5bGUucG9zaXRpb249ImFic29sdXRlIjt0aGlzLnJlc2l6ZS5zdHlsZS5ib3R0b209IjJweCI7dGhpcy5yZXNpemUuc3R5bGUucmlnaHQ9IjJweCI7dGhpcy5yZXNpemUuc2V0QXR0cmlidXRlKCJzcmMiLHRoaXMucmVzaXplSW1hZ2UpO3RoaXMucmVzaXplLnN0eWxlLmN1cnNvcj0ibnctcmVzaXplIjt2YXIgYj1udWxsLGM9bnVsbCxkPW51bGwsZT1udWxsO2E9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5hY3RpdmF0ZSgpO2I9bXhFdmVudC5nZXRDbGllbnRYKGEpO2M9bXhFdmVudC5nZXRDbGllbnRZKGEpO2Q9dGhpcy5kaXYub2Zmc2V0V2lkdGg7ZT10aGlzLmRpdi5vZmZzZXRIZWlnaHQ7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKGRvY3VtZW50LApudWxsLGYsZyk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5SRVNJWkVfU1RBUlQsImV2ZW50IixhKSk7bXhFdmVudC5jb25zdW1lKGEpfSk7dmFyIGY9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7aWYobnVsbCE9YiYmbnVsbCE9Yyl7dmFyIGY9bXhFdmVudC5nZXRDbGllbnRYKGEpLWIsZz1teEV2ZW50LmdldENsaWVudFkoYSktYzt0aGlzLnNldFNpemUoZCtmLGUrZyk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5SRVNJWkUsImV2ZW50IixhKSk7bXhFdmVudC5jb25zdW1lKGEpfX0pLGc9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bnVsbCE9YiYmbnVsbCE9YyYmKGM9Yj1udWxsLG14RXZlbnQucmVtb3ZlR2VzdHVyZUxpc3RlbmVycyhkb2N1bWVudCxudWxsLGYsZyksdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5SRVNJWkVfRU5ELCJldmVudCIsYSkpLG14RXZlbnQuY29uc3VtZShhKSl9KTsKbXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKHRoaXMucmVzaXplLGEsZixnKTt0aGlzLmRpdi5hcHBlbmRDaGlsZCh0aGlzLnJlc2l6ZSl9ZWxzZSB0aGlzLnJlc2l6ZS5zdHlsZS5kaXNwbGF5PSJpbmxpbmUiO2Vsc2UgbnVsbCE9dGhpcy5yZXNpemUmJih0aGlzLnJlc2l6ZS5zdHlsZS5kaXNwbGF5PSJub25lIil9OwpteFdpbmRvdy5wcm90b3R5cGUuc2V0U2l6ZT1mdW5jdGlvbihhLGIpe2E9TWF0aC5tYXgodGhpcy5taW5pbXVtU2l6ZS53aWR0aCxhKTtiPU1hdGgubWF4KHRoaXMubWluaW11bVNpemUuaGVpZ2h0LGIpO214Q2xpZW50LklTX1FVSVJLU3x8KHRoaXMuZGl2LnN0eWxlLndpZHRoPWErInB4Iix0aGlzLmRpdi5zdHlsZS5oZWlnaHQ9YisicHgiKTt0aGlzLnRhYmxlLnN0eWxlLndpZHRoPWErInB4Ijt0aGlzLnRhYmxlLnN0eWxlLmhlaWdodD1iKyJweCI7bXhDbGllbnQuSVNfUVVJUktTfHwodGhpcy5jb250ZW50V3JhcHBlci5zdHlsZS5oZWlnaHQ9dGhpcy5kaXYub2Zmc2V0SGVpZ2h0LXRoaXMudGl0bGUub2Zmc2V0SGVpZ2h0LXRoaXMuY29udGVudEhlaWdodENvcnJlY3Rpb24rInB4Iil9O214V2luZG93LnByb3RvdHlwZS5zZXRNaW5pbWl6YWJsZT1mdW5jdGlvbihhKXt0aGlzLm1pbmltaXplLnN0eWxlLmRpc3BsYXk9YT8iIjoibm9uZSJ9OwpteFdpbmRvdy5wcm90b3R5cGUuZ2V0TWluaW11bVNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKDAsMCwwLHRoaXMudGl0bGUub2Zmc2V0SGVpZ2h0KX07Cm14V2luZG93LnByb3RvdHlwZS5pbnN0YWxsTWluaW1pemVIYW5kbGVyPWZ1bmN0aW9uKCl7dGhpcy5taW5pbWl6ZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTt0aGlzLm1pbmltaXplLnNldEF0dHJpYnV0ZSgic3JjIix0aGlzLm1pbmltaXplSW1hZ2UpO3RoaXMubWluaW1pemUuc2V0QXR0cmlidXRlKCJ0aXRsZSIsIk1pbmltaXplIik7dGhpcy5taW5pbWl6ZS5zdHlsZS5jdXJzb3I9InBvaW50ZXIiO3RoaXMubWluaW1pemUuc3R5bGUubWFyZ2luTGVmdD0iMnB4Ijt0aGlzLm1pbmltaXplLnN0eWxlLmRpc3BsYXk9Im5vbmUiO3RoaXMuYnV0dG9ucy5hcHBlbmRDaGlsZCh0aGlzLm1pbmltaXplKTt2YXIgYT0hMSxiPW51bGwsYz1udWxsLGQ9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oZCl7dGhpcy5hY3RpdmF0ZSgpO2lmKGEpYT0hMSx0aGlzLm1pbmltaXplLnNldEF0dHJpYnV0ZSgic3JjIix0aGlzLm1pbmltaXplSW1hZ2UpLHRoaXMubWluaW1pemUuc2V0QXR0cmlidXRlKCJ0aXRsZSIsCiJNaW5pbWl6ZSIpLHRoaXMuY29udGVudFdyYXBwZXIuc3R5bGUuZGlzcGxheT0iIix0aGlzLm1heGltaXplLnN0eWxlLmRpc3BsYXk9YixteENsaWVudC5JU19RVUlSS1N8fCh0aGlzLmRpdi5zdHlsZS5oZWlnaHQ9YyksdGhpcy50YWJsZS5zdHlsZS5oZWlnaHQ9YyxudWxsIT10aGlzLnJlc2l6ZSYmKHRoaXMucmVzaXplLnN0eWxlLnZpc2liaWxpdHk9IiIpLHRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuTk9STUFMSVpFLCJldmVudCIsZCkpO2Vsc2V7YT0hMDt0aGlzLm1pbmltaXplLnNldEF0dHJpYnV0ZSgic3JjIix0aGlzLm5vcm1hbGl6ZUltYWdlKTt0aGlzLm1pbmltaXplLnNldEF0dHJpYnV0ZSgidGl0bGUiLCJOb3JtYWxpemUiKTt0aGlzLmNvbnRlbnRXcmFwcGVyLnN0eWxlLmRpc3BsYXk9Im5vbmUiO2I9dGhpcy5tYXhpbWl6ZS5zdHlsZS5kaXNwbGF5O3RoaXMubWF4aW1pemUuc3R5bGUuZGlzcGxheT0ibm9uZSI7Yz10aGlzLnRhYmxlLnN0eWxlLmhlaWdodDsKdmFyIGU9dGhpcy5nZXRNaW5pbXVtU2l6ZSgpOzA8ZS5oZWlnaHQmJihteENsaWVudC5JU19RVUlSS1N8fCh0aGlzLmRpdi5zdHlsZS5oZWlnaHQ9ZS5oZWlnaHQrInB4IiksdGhpcy50YWJsZS5zdHlsZS5oZWlnaHQ9ZS5oZWlnaHQrInB4Iik7MDxlLndpZHRoJiYobXhDbGllbnQuSVNfUVVJUktTfHwodGhpcy5kaXYuc3R5bGUud2lkdGg9ZS53aWR0aCsicHgiKSx0aGlzLnRhYmxlLnN0eWxlLndpZHRoPWUud2lkdGgrInB4Iik7bnVsbCE9dGhpcy5yZXNpemUmJih0aGlzLnJlc2l6ZS5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4iKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50Lk1JTklNSVpFLCJldmVudCIsZCkpfW14RXZlbnQuY29uc3VtZShkKX0pO214RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyh0aGlzLm1pbmltaXplLGQpfTsKbXhXaW5kb3cucHJvdG90eXBlLnNldE1heGltaXphYmxlPWZ1bmN0aW9uKGEpe3RoaXMubWF4aW1pemUuc3R5bGUuZGlzcGxheT1hPyIiOiJub25lIn07Cm14V2luZG93LnByb3RvdHlwZS5pbnN0YWxsTWF4aW1pemVIYW5kbGVyPWZ1bmN0aW9uKCl7dGhpcy5tYXhpbWl6ZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTt0aGlzLm1heGltaXplLnNldEF0dHJpYnV0ZSgic3JjIix0aGlzLm1heGltaXplSW1hZ2UpO3RoaXMubWF4aW1pemUuc2V0QXR0cmlidXRlKCJ0aXRsZSIsIk1heGltaXplIik7dGhpcy5tYXhpbWl6ZS5zdHlsZS5jdXJzb3I9ImRlZmF1bHQiO3RoaXMubWF4aW1pemUuc3R5bGUubWFyZ2luTGVmdD0iMnB4Ijt0aGlzLm1heGltaXplLnN0eWxlLmN1cnNvcj0icG9pbnRlciI7dGhpcy5tYXhpbWl6ZS5zdHlsZS5kaXNwbGF5PSJub25lIjt0aGlzLmJ1dHRvbnMuYXBwZW5kQ2hpbGQodGhpcy5tYXhpbWl6ZSk7dmFyIGE9ITEsYj1udWxsLGM9bnVsbCxkPW51bGwsZT1udWxsLGY9bnVsbCxnPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGcpe3RoaXMuYWN0aXZhdGUoKTtpZigibm9uZSIhPXRoaXMubWF4aW1pemUuc3R5bGUuZGlzcGxheSl7aWYoYSlhPQohMSx0aGlzLm1heGltaXplLnNldEF0dHJpYnV0ZSgic3JjIix0aGlzLm1heGltaXplSW1hZ2UpLHRoaXMubWF4aW1pemUuc2V0QXR0cmlidXRlKCJ0aXRsZSIsIk1heGltaXplIiksdGhpcy5jb250ZW50V3JhcHBlci5zdHlsZS5kaXNwbGF5PSIiLHRoaXMubWluaW1pemUuc3R5bGUuZGlzcGxheT1mLHRoaXMuZGl2LnN0eWxlLmxlZnQ9YisicHgiLHRoaXMuZGl2LnN0eWxlLnRvcD1jKyJweCIsbXhDbGllbnQuSVNfUVVJUktTfHwodGhpcy5kaXYuc3R5bGUuaGVpZ2h0PWQsdGhpcy5kaXYuc3R5bGUud2lkdGg9ZSxrPW14VXRpbHMuZ2V0Q3VycmVudFN0eWxlKHRoaXMuY29udGVudFdyYXBwZXIpLCJhdXRvIiE9ay5vdmVyZmxvdyYmbnVsbD09dGhpcy5yZXNpemUpfHwodGhpcy5jb250ZW50V3JhcHBlci5zdHlsZS5oZWlnaHQ9dGhpcy5kaXYub2Zmc2V0SGVpZ2h0LXRoaXMudGl0bGUub2Zmc2V0SGVpZ2h0LXRoaXMuY29udGVudEhlaWdodENvcnJlY3Rpb24rInB4IiksdGhpcy50YWJsZS5zdHlsZS5oZWlnaHQ9CmQsdGhpcy50YWJsZS5zdHlsZS53aWR0aD1lLG51bGwhPXRoaXMucmVzaXplJiYodGhpcy5yZXNpemUuc3R5bGUudmlzaWJpbGl0eT0iIiksdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5OT1JNQUxJWkUsImV2ZW50IixnKSk7ZWxzZXthPSEwO3RoaXMubWF4aW1pemUuc2V0QXR0cmlidXRlKCJzcmMiLHRoaXMubm9ybWFsaXplSW1hZ2UpO3RoaXMubWF4aW1pemUuc2V0QXR0cmlidXRlKCJ0aXRsZSIsIk5vcm1hbGl6ZSIpO3RoaXMuY29udGVudFdyYXBwZXIuc3R5bGUuZGlzcGxheT0iIjtmPXRoaXMubWluaW1pemUuc3R5bGUuZGlzcGxheTt0aGlzLm1pbmltaXplLnN0eWxlLmRpc3BsYXk9Im5vbmUiO2I9cGFyc2VJbnQodGhpcy5kaXYuc3R5bGUubGVmdCk7Yz1wYXJzZUludCh0aGlzLmRpdi5zdHlsZS50b3ApO2Q9dGhpcy50YWJsZS5zdHlsZS5oZWlnaHQ7ZT10aGlzLnRhYmxlLnN0eWxlLndpZHRoO3RoaXMuZGl2LnN0eWxlLmxlZnQ9IjBweCI7dGhpcy5kaXYuc3R5bGUudG9wPQoiMHB4IjtrPU1hdGgubWF4KGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0fHwwLGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHR8fDApO214Q2xpZW50LklTX1FVSVJLU3x8KHRoaXMuZGl2LnN0eWxlLndpZHRoPWRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGgtMisicHgiLHRoaXMuZGl2LnN0eWxlLmhlaWdodD1rLTIrInB4Iik7dGhpcy50YWJsZS5zdHlsZS53aWR0aD1kb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoLTIrInB4Ijt0aGlzLnRhYmxlLnN0eWxlLmhlaWdodD1rLTIrInB4IjtudWxsIT10aGlzLnJlc2l6ZSYmKHRoaXMucmVzaXplLnN0eWxlLnZpc2liaWxpdHk9ImhpZGRlbiIpO2lmKCFteENsaWVudC5JU19RVUlSS1Mpe3ZhciBrPW14VXRpbHMuZ2V0Q3VycmVudFN0eWxlKHRoaXMuY29udGVudFdyYXBwZXIpO2lmKCJhdXRvIj09ay5vdmVyZmxvd3x8bnVsbCE9dGhpcy5yZXNpemUpdGhpcy5jb250ZW50V3JhcHBlci5zdHlsZS5oZWlnaHQ9dGhpcy5kaXYub2Zmc2V0SGVpZ2h0LQp0aGlzLnRpdGxlLm9mZnNldEhlaWdodC10aGlzLmNvbnRlbnRIZWlnaHRDb3JyZWN0aW9uKyJweCJ9dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5NQVhJTUlaRSwiZXZlbnQiLGcpKX1teEV2ZW50LmNvbnN1bWUoZyl9fSk7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKHRoaXMubWF4aW1pemUsZyk7bXhFdmVudC5hZGRMaXN0ZW5lcih0aGlzLnRpdGxlLCJkYmxjbGljayIsZyl9OwpteFdpbmRvdy5wcm90b3R5cGUuaW5zdGFsbE1vdmVIYW5kbGVyPWZ1bmN0aW9uKCl7dGhpcy50aXRsZS5zdHlsZS5jdXJzb3I9Im1vdmUiO214RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyh0aGlzLnRpdGxlLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBiPW14RXZlbnQuZ2V0Q2xpZW50WChhKSxjPW14RXZlbnQuZ2V0Q2xpZW50WShhKSxkPXRoaXMuZ2V0WCgpLGU9dGhpcy5nZXRZKCksZj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt2YXIgZj1teEV2ZW50LmdldENsaWVudFgoYSktYixnPW14RXZlbnQuZ2V0Q2xpZW50WShhKS1jO3RoaXMuc2V0TG9jYXRpb24oZCtmLGUrZyk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5NT1ZFLCJldmVudCIsYSkpO214RXZlbnQuY29uc3VtZShhKX0pLGc9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bXhFdmVudC5yZW1vdmVHZXN0dXJlTGlzdGVuZXJzKGRvY3VtZW50LG51bGwsZiwKZyk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5NT1ZFX0VORCwiZXZlbnQiLGEpKTtteEV2ZW50LmNvbnN1bWUoYSl9KTtteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnMoZG9jdW1lbnQsbnVsbCxmLGcpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuTU9WRV9TVEFSVCwiZXZlbnQiLGEpKTtteEV2ZW50LmNvbnN1bWUoYSl9KSk7bXhDbGllbnQuSVNfUE9JTlRFUiYmKHRoaXMudGl0bGUuc3R5bGUudG91Y2hBY3Rpb249Im5vbmUiKX07bXhXaW5kb3cucHJvdG90eXBlLnNldExvY2F0aW9uPWZ1bmN0aW9uKGEsYil7dGhpcy5kaXYuc3R5bGUubGVmdD1hKyJweCI7dGhpcy5kaXYuc3R5bGUudG9wPWIrInB4In07bXhXaW5kb3cucHJvdG90eXBlLmdldFg9ZnVuY3Rpb24oKXtyZXR1cm4gcGFyc2VJbnQodGhpcy5kaXYuc3R5bGUubGVmdCl9O214V2luZG93LnByb3RvdHlwZS5nZXRZPWZ1bmN0aW9uKCl7cmV0dXJuIHBhcnNlSW50KHRoaXMuZGl2LnN0eWxlLnRvcCl9OwpteFdpbmRvdy5wcm90b3R5cGUuaW5zdGFsbENsb3NlSGFuZGxlcj1mdW5jdGlvbigpe3RoaXMuY2xvc2VJbWc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIik7dGhpcy5jbG9zZUltZy5zZXRBdHRyaWJ1dGUoInNyYyIsdGhpcy5jbG9zZUltYWdlKTt0aGlzLmNsb3NlSW1nLnNldEF0dHJpYnV0ZSgidGl0bGUiLCJDbG9zZSIpO3RoaXMuY2xvc2VJbWcuc3R5bGUubWFyZ2luTGVmdD0iMnB4Ijt0aGlzLmNsb3NlSW1nLnN0eWxlLmN1cnNvcj0icG9pbnRlciI7dGhpcy5jbG9zZUltZy5zdHlsZS5kaXNwbGF5PSJub25lIjt0aGlzLmJ1dHRvbnMuYXBwZW5kQ2hpbGQodGhpcy5jbG9zZUltZyk7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKHRoaXMuY2xvc2VJbWcsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5DTE9TRSwiZXZlbnQiLGEpKTt0aGlzLmRlc3Ryb3lPbkNsb3NlP3RoaXMuZGVzdHJveSgpOgp0aGlzLnNldFZpc2libGUoITEpO214RXZlbnQuY29uc3VtZShhKX0pKX07bXhXaW5kb3cucHJvdG90eXBlLnNldEltYWdlPWZ1bmN0aW9uKGEpe3RoaXMuaW1hZ2U9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIik7dGhpcy5pbWFnZS5zZXRBdHRyaWJ1dGUoInNyYyIsYSk7dGhpcy5pbWFnZS5zZXRBdHRyaWJ1dGUoImFsaWduIiwibGVmdCIpO3RoaXMuaW1hZ2Uuc3R5bGUubWFyZ2luUmlnaHQ9IjRweCI7dGhpcy5pbWFnZS5zdHlsZS5tYXJnaW5MZWZ0PSIwcHgiO3RoaXMuaW1hZ2Uuc3R5bGUubWFyZ2luVG9wPSItMnB4Ijt0aGlzLnRpdGxlLmluc2VydEJlZm9yZSh0aGlzLmltYWdlLHRoaXMudGl0bGUuZmlyc3RDaGlsZCl9O214V2luZG93LnByb3RvdHlwZS5zZXRDbG9zYWJsZT1mdW5jdGlvbihhKXt0aGlzLmNsb3NlSW1nLnN0eWxlLmRpc3BsYXk9YT8iIjoibm9uZSJ9OwpteFdpbmRvdy5wcm90b3R5cGUuaXNWaXNpYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuZGl2PyJub25lIiE9dGhpcy5kaXYuc3R5bGUuZGlzcGxheTohMX07bXhXaW5kb3cucHJvdG90eXBlLnNldFZpc2libGU9ZnVuY3Rpb24oYSl7bnVsbCE9dGhpcy5kaXYmJnRoaXMuaXNWaXNpYmxlKCkhPWEmJihhP3RoaXMuc2hvdygpOnRoaXMuaGlkZSgpKX07Cm14V2luZG93LnByb3RvdHlwZS5zaG93PWZ1bmN0aW9uKCl7dGhpcy5kaXYuc3R5bGUuZGlzcGxheT0iIjt0aGlzLmFjdGl2YXRlKCk7dmFyIGE9bXhVdGlscy5nZXRDdXJyZW50U3R5bGUodGhpcy5jb250ZW50V3JhcHBlcik7bXhDbGllbnQuSVNfUVVJUktTfHwiYXV0byIhPWEub3ZlcmZsb3cmJm51bGw9PXRoaXMucmVzaXplfHwibm9uZSI9PXRoaXMuY29udGVudFdyYXBwZXIuc3R5bGUuZGlzcGxheXx8KHRoaXMuY29udGVudFdyYXBwZXIuc3R5bGUuaGVpZ2h0PXRoaXMuZGl2Lm9mZnNldEhlaWdodC10aGlzLnRpdGxlLm9mZnNldEhlaWdodC10aGlzLmNvbnRlbnRIZWlnaHRDb3JyZWN0aW9uKyJweCIpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuU0hPVykpfTtteFdpbmRvdy5wcm90b3R5cGUuaGlkZT1mdW5jdGlvbigpe3RoaXMuZGl2LnN0eWxlLmRpc3BsYXk9Im5vbmUiO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuSElERSkpfTsKbXhXaW5kb3cucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkRFU1RST1kpKTtudWxsIT10aGlzLmRpdiYmKG14RXZlbnQucmVsZWFzZSh0aGlzLmRpdiksdGhpcy5kaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRpdiksdGhpcy5kaXY9bnVsbCk7dGhpcy5jb250ZW50V3JhcHBlcj10aGlzLmNvbnRlbnQ9dGhpcy50aXRsZT1udWxsfTtmdW5jdGlvbiBteEZvcm0oYSl7dGhpcy50YWJsZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0YWJsZSIpO3RoaXMudGFibGUuY2xhc3NOYW1lPWE7dGhpcy5ib2R5PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRib2R5Iik7dGhpcy50YWJsZS5hcHBlbmRDaGlsZCh0aGlzLmJvZHkpfW14Rm9ybS5wcm90b3R5cGUudGFibGU9bnVsbDtteEZvcm0ucHJvdG90eXBlLmJvZHk9ITE7bXhGb3JtLnByb3RvdHlwZS5nZXRUYWJsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRhYmxlfTsKbXhGb3JtLnByb3RvdHlwZS5hZGRCdXR0b25zPWZ1bmN0aW9uKGEsYil7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidHIiKSxkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRkIik7Yy5hcHBlbmRDaGlsZChkKTt2YXIgZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpLGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYnV0dG9uIik7bXhVdGlscy53cml0ZShlLG14UmVzb3VyY2VzLmdldCgib2siKXx8Ik9LIik7ZC5hcHBlbmRDaGlsZChlKTtteEV2ZW50LmFkZExpc3RlbmVyKGUsImNsaWNrIixmdW5jdGlvbigpe2EoKX0pO2U9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYnV0dG9uIik7bXhVdGlscy53cml0ZShlLG14UmVzb3VyY2VzLmdldCgiY2FuY2VsIil8fCJDYW5jZWwiKTtkLmFwcGVuZENoaWxkKGUpO214RXZlbnQuYWRkTGlzdGVuZXIoZSwiY2xpY2siLGZ1bmN0aW9uKCl7YigpfSk7Yy5hcHBlbmRDaGlsZChkKTt0aGlzLmJvZHkuYXBwZW5kQ2hpbGQoYyl9OwpteEZvcm0ucHJvdG90eXBlLmFkZFRleHQ9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7ZC5zZXRBdHRyaWJ1dGUoInR5cGUiLGN8fCJ0ZXh0Iik7ZC52YWx1ZT1iO3JldHVybiB0aGlzLmFkZEZpZWxkKGEsZCl9O214Rm9ybS5wcm90b3R5cGUuYWRkQ2hlY2tib3g9ZnVuY3Rpb24oYSxiKXt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpO2Muc2V0QXR0cmlidXRlKCJ0eXBlIiwiY2hlY2tib3giKTt0aGlzLmFkZEZpZWxkKGEsYyk7YiYmKGMuY2hlY2tlZD0hMCk7cmV0dXJuIGN9O214Rm9ybS5wcm90b3R5cGUuYWRkVGV4dGFyZWE9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRleHRhcmVhIik7bXhDbGllbnQuSVNfTlMmJmMtLTtkLnNldEF0dHJpYnV0ZSgicm93cyIsY3x8Mik7ZC52YWx1ZT1iO3JldHVybiB0aGlzLmFkZEZpZWxkKGEsZCl9OwpteEZvcm0ucHJvdG90eXBlLmFkZENvbWJvPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzZWxlY3QiKTtudWxsIT1jJiZkLnNldEF0dHJpYnV0ZSgic2l6ZSIsYyk7YiYmZC5zZXRBdHRyaWJ1dGUoIm11bHRpcGxlIiwidHJ1ZSIpO3JldHVybiB0aGlzLmFkZEZpZWxkKGEsZCl9O214Rm9ybS5wcm90b3R5cGUuYWRkT3B0aW9uPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIm9wdGlvbiIpO214VXRpbHMud3JpdGVsbihlLGIpO2Uuc2V0QXR0cmlidXRlKCJ2YWx1ZSIsYyk7ZCYmZS5zZXRBdHRyaWJ1dGUoInNlbGVjdGVkIixkKTthLmFwcGVuZENoaWxkKGUpfTsKbXhGb3JtLnByb3RvdHlwZS5hZGRGaWVsZD1mdW5jdGlvbihhLGIpe3ZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRyIiksZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpO214VXRpbHMud3JpdGUoZCxhKTtjLmFwcGVuZENoaWxkKGQpO2Q9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKTtkLmFwcGVuZENoaWxkKGIpO2MuYXBwZW5kQ2hpbGQoZCk7dGhpcy5ib2R5LmFwcGVuZENoaWxkKGMpO3JldHVybiBifTtmdW5jdGlvbiBteEltYWdlKGEsYixjKXt0aGlzLnNyYz1hO3RoaXMud2lkdGg9Yjt0aGlzLmhlaWdodD1jfW14SW1hZ2UucHJvdG90eXBlLnNyYz1udWxsO214SW1hZ2UucHJvdG90eXBlLndpZHRoPW51bGw7bXhJbWFnZS5wcm90b3R5cGUuaGVpZ2h0PW51bGw7CmZ1bmN0aW9uIG14RGl2UmVzaXplcihhLGIpe2lmKCJkaXYiPT1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpe251bGw9PWImJihiPXdpbmRvdyk7dGhpcy5kaXY9YTt2YXIgYz1teFV0aWxzLmdldEN1cnJlbnRTdHlsZShhKTtudWxsIT1jJiYodGhpcy5yZXNpemVXaWR0aD0iYXV0byI9PWMud2lkdGgsdGhpcy5yZXNpemVIZWlnaHQ9ImF1dG8iPT1jLmhlaWdodCk7bXhFdmVudC5hZGRMaXN0ZW5lcihiLCJyZXNpemUiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuaGFuZGxpbmdSZXNpemV8fCh0aGlzLmhhbmRsaW5nUmVzaXplPSEwLHRoaXMucmVzaXplKCksdGhpcy5oYW5kbGluZ1Jlc2l6ZT0hMSl9KSk7dGhpcy5yZXNpemUoKX19bXhEaXZSZXNpemVyLnByb3RvdHlwZS5yZXNpemVXaWR0aD0hMDtteERpdlJlc2l6ZXIucHJvdG90eXBlLnJlc2l6ZUhlaWdodD0hMDtteERpdlJlc2l6ZXIucHJvdG90eXBlLmhhbmRsaW5nUmVzaXplPSExOwpteERpdlJlc2l6ZXIucHJvdG90eXBlLnJlc2l6ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0RG9jdW1lbnRXaWR0aCgpLGI9dGhpcy5nZXREb2N1bWVudEhlaWdodCgpLGM9cGFyc2VJbnQodGhpcy5kaXYuc3R5bGUubGVmdCksZD1wYXJzZUludCh0aGlzLmRpdi5zdHlsZS5yaWdodCksZT1wYXJzZUludCh0aGlzLmRpdi5zdHlsZS50b3ApLGY9cGFyc2VJbnQodGhpcy5kaXYuc3R5bGUuYm90dG9tKTt0aGlzLnJlc2l6ZVdpZHRoJiYhaXNOYU4oYykmJiFpc05hTihkKSYmMDw9YyYmMDw9ZCYmMDxhLWQtYyYmKHRoaXMuZGl2LnN0eWxlLndpZHRoPWEtZC1jKyJweCIpO3RoaXMucmVzaXplSGVpZ2h0JiYhaXNOYU4oZSkmJiFpc05hTihmKSYmMDw9ZSYmMDw9ZiYmMDxiLWUtZiYmKHRoaXMuZGl2LnN0eWxlLmhlaWdodD1iLWUtZisicHgiKX07bXhEaXZSZXNpemVyLnByb3RvdHlwZS5nZXREb2N1bWVudFdpZHRoPWZ1bmN0aW9uKCl7cmV0dXJuIGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGh9OwpteERpdlJlc2l6ZXIucHJvdG90eXBlLmdldERvY3VtZW50SGVpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuIGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0fTtmdW5jdGlvbiBteERyYWdTb3VyY2UoYSxiKXt0aGlzLmVsZW1lbnQ9YTt0aGlzLmRyb3BIYW5kbGVyPWI7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKGEsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5tb3VzZURvd24oYSl9KSk7bXhFdmVudC5hZGRMaXN0ZW5lcihhLCJkcmFnc3RhcnQiLGZ1bmN0aW9uKGEpe214RXZlbnQuY29uc3VtZShhKX0pO3RoaXMuZXZlbnRDb25zdW1lcj1mdW5jdGlvbihhLGIpe3ZhciBjPWIuZ2V0UHJvcGVydHkoImV2ZW50TmFtZSIpLGQ9Yi5nZXRQcm9wZXJ0eSgiZXZlbnQiKTtjIT1teEV2ZW50Lk1PVVNFX0RPV04mJmQuY29uc3VtZSgpfX1teERyYWdTb3VyY2UucHJvdG90eXBlLmVsZW1lbnQ9bnVsbDtteERyYWdTb3VyY2UucHJvdG90eXBlLmRyb3BIYW5kbGVyPW51bGw7Cm14RHJhZ1NvdXJjZS5wcm90b3R5cGUuZHJhZ09mZnNldD1udWxsO214RHJhZ1NvdXJjZS5wcm90b3R5cGUuZHJhZ0VsZW1lbnQ9bnVsbDtteERyYWdTb3VyY2UucHJvdG90eXBlLnByZXZpZXdFbGVtZW50PW51bGw7bXhEcmFnU291cmNlLnByb3RvdHlwZS5lbmFibGVkPSEwO214RHJhZ1NvdXJjZS5wcm90b3R5cGUuY3VycmVudEdyYXBoPW51bGw7bXhEcmFnU291cmNlLnByb3RvdHlwZS5jdXJyZW50RHJvcFRhcmdldD1udWxsO214RHJhZ1NvdXJjZS5wcm90b3R5cGUuY3VycmVudFBvaW50PW51bGw7bXhEcmFnU291cmNlLnByb3RvdHlwZS5jdXJyZW50R3VpZGU9bnVsbDtteERyYWdTb3VyY2UucHJvdG90eXBlLmN1cnJlbnRIaWdobGlnaHQ9bnVsbDtteERyYWdTb3VyY2UucHJvdG90eXBlLmF1dG9zY3JvbGw9ITA7bXhEcmFnU291cmNlLnByb3RvdHlwZS5ndWlkZXNFbmFibGVkPSEwO214RHJhZ1NvdXJjZS5wcm90b3R5cGUuZ3JpZEVuYWJsZWQ9ITA7Cm14RHJhZ1NvdXJjZS5wcm90b3R5cGUuaGlnaGxpZ2h0RHJvcFRhcmdldHM9ITA7bXhEcmFnU291cmNlLnByb3RvdHlwZS5kcmFnRWxlbWVudFpJbmRleD0xMDA7bXhEcmFnU291cmNlLnByb3RvdHlwZS5kcmFnRWxlbWVudE9wYWNpdHk9NzA7bXhEcmFnU291cmNlLnByb3RvdHlwZS5jaGVja0V2ZW50U291cmNlPSEwO214RHJhZ1NvdXJjZS5wcm90b3R5cGUuaXNFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5hYmxlZH07bXhEcmFnU291cmNlLnByb3RvdHlwZS5zZXRFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuZW5hYmxlZD1hfTtteERyYWdTb3VyY2UucHJvdG90eXBlLmlzR3VpZGVzRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmd1aWRlc0VuYWJsZWR9O214RHJhZ1NvdXJjZS5wcm90b3R5cGUuc2V0R3VpZGVzRW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLmd1aWRlc0VuYWJsZWQ9YX07bXhEcmFnU291cmNlLnByb3RvdHlwZS5pc0dyaWRFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ3JpZEVuYWJsZWR9OwpteERyYWdTb3VyY2UucHJvdG90eXBlLnNldEdyaWRFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuZ3JpZEVuYWJsZWQ9YX07bXhEcmFnU291cmNlLnByb3RvdHlwZS5nZXRHcmFwaEZvckV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiBudWxsfTtteERyYWdTb3VyY2UucHJvdG90eXBlLmdldERyb3BUYXJnZXQ9ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIGEuZ2V0Q2VsbEF0KGIsYyl9O214RHJhZ1NvdXJjZS5wcm90b3R5cGUuY3JlYXRlRHJhZ0VsZW1lbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZWxlbWVudC5jbG9uZU5vZGUoITApfTtteERyYWdTb3VyY2UucHJvdG90eXBlLmNyZWF0ZVByZXZpZXdFbGVtZW50PWZ1bmN0aW9uKGEpe3JldHVybiBudWxsfTtteERyYWdTb3VyY2UucHJvdG90eXBlLmlzQWN0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMubW91c2VNb3ZlSGFuZGxlcn07Cm14RHJhZ1NvdXJjZS5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmN1cnJlbnRHcmFwaCYmKHRoaXMuZHJhZ0V4aXQodGhpcy5jdXJyZW50R3JhcGgpLHRoaXMuY3VycmVudEdyYXBoPW51bGwpO3RoaXMucmVtb3ZlRHJhZ0VsZW1lbnQoKTt0aGlzLnJlbW92ZUxpc3RlbmVycygpO3RoaXMuc3RvcERyYWcoKX07Cm14RHJhZ1NvdXJjZS5wcm90b3R5cGUubW91c2VEb3duPWZ1bmN0aW9uKGEpe3RoaXMuZW5hYmxlZCYmIW14RXZlbnQuaXNDb25zdW1lZChhKSYmbnVsbD09dGhpcy5tb3VzZU1vdmVIYW5kbGVyJiYodGhpcy5zdGFydERyYWcoYSksdGhpcy5tb3VzZU1vdmVIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLHRoaXMubW91c2VNb3ZlKSx0aGlzLm1vdXNlVXBIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLHRoaXMubW91c2VVcCksbXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKGRvY3VtZW50LG51bGwsdGhpcy5tb3VzZU1vdmVIYW5kbGVyLHRoaXMubW91c2VVcEhhbmRsZXIpLG14Q2xpZW50LklTX1RPVUNIJiYhbXhFdmVudC5pc01vdXNlRXZlbnQoYSkmJih0aGlzLmV2ZW50U291cmNlPW14RXZlbnQuZ2V0U291cmNlKGEpLG14RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyh0aGlzLmV2ZW50U291cmNlLG51bGwsdGhpcy5tb3VzZU1vdmVIYW5kbGVyLHRoaXMubW91c2VVcEhhbmRsZXIpKSl9OwpteERyYWdTb3VyY2UucHJvdG90eXBlLnN0YXJ0RHJhZz1mdW5jdGlvbihhKXt0aGlzLmRyYWdFbGVtZW50PXRoaXMuY3JlYXRlRHJhZ0VsZW1lbnQoYSk7dGhpcy5kcmFnRWxlbWVudC5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO3RoaXMuZHJhZ0VsZW1lbnQuc3R5bGUuekluZGV4PXRoaXMuZHJhZ0VsZW1lbnRaSW5kZXg7bXhVdGlscy5zZXRPcGFjaXR5KHRoaXMuZHJhZ0VsZW1lbnQsdGhpcy5kcmFnRWxlbWVudE9wYWNpdHkpO3RoaXMuY2hlY2tFdmVudFNvdXJjZSYmbXhDbGllbnQuSVNfU1ZHJiYodGhpcy5kcmFnRWxlbWVudC5zdHlsZS5wb2ludGVyRXZlbnRzPSJub25lIil9O214RHJhZ1NvdXJjZS5wcm90b3R5cGUuc3RvcERyYWc9ZnVuY3Rpb24oKXt0aGlzLnJlbW92ZURyYWdFbGVtZW50KCl9OwpteERyYWdTb3VyY2UucHJvdG90eXBlLnJlbW92ZURyYWdFbGVtZW50PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5kcmFnRWxlbWVudCYmKG51bGwhPXRoaXMuZHJhZ0VsZW1lbnQucGFyZW50Tm9kZSYmdGhpcy5kcmFnRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZHJhZ0VsZW1lbnQpLHRoaXMuZHJhZ0VsZW1lbnQ9bnVsbCl9O214RHJhZ1NvdXJjZS5wcm90b3R5cGUuZ2V0RWxlbWVudEZvckV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiBteEV2ZW50LmlzVG91Y2hFdmVudChhKXx8bXhFdmVudC5pc1BlbkV2ZW50KGEpP2RvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQobXhFdmVudC5nZXRDbGllbnRYKGEpLG14RXZlbnQuZ2V0Q2xpZW50WShhKSk6bXhFdmVudC5nZXRTb3VyY2UoYSl9OwpteERyYWdTb3VyY2UucHJvdG90eXBlLmdyYXBoQ29udGFpbnNFdmVudD1mdW5jdGlvbihhLGIpe3ZhciBjPW14RXZlbnQuZ2V0Q2xpZW50WChiKSxkPW14RXZlbnQuZ2V0Q2xpZW50WShiKSxlPW14VXRpbHMuZ2V0T2Zmc2V0KGEuY29udGFpbmVyKSxmPW14VXRpbHMuZ2V0U2Nyb2xsT3JpZ2luKCksZz10aGlzLmdldEVsZW1lbnRGb3JFdmVudChiKTtpZih0aGlzLmNoZWNrRXZlbnRTb3VyY2UpZm9yKDtudWxsIT1nJiZnIT1hLmNvbnRhaW5lcjspZz1nLnBhcmVudE5vZGU7cmV0dXJuIG51bGwhPWcmJmM+PWUueC1mLngmJmQ+PWUueS1mLnkmJmM8PWUueC1mLngrYS5jb250YWluZXIub2Zmc2V0V2lkdGgmJmQ8PWUueS1mLnkrYS5jb250YWluZXIub2Zmc2V0SGVpZ2h0fTsKbXhEcmFnU291cmNlLnByb3RvdHlwZS5tb3VzZU1vdmU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5nZXRHcmFwaEZvckV2ZW50KGEpO251bGw9PWJ8fHRoaXMuZ3JhcGhDb250YWluc0V2ZW50KGIsYSl8fChiPW51bGwpO2IhPXRoaXMuY3VycmVudEdyYXBoJiYobnVsbCE9dGhpcy5jdXJyZW50R3JhcGgmJnRoaXMuZHJhZ0V4aXQodGhpcy5jdXJyZW50R3JhcGgsYSksdGhpcy5jdXJyZW50R3JhcGg9YixudWxsIT10aGlzLmN1cnJlbnRHcmFwaCYmdGhpcy5kcmFnRW50ZXIodGhpcy5jdXJyZW50R3JhcGgsYSkpO251bGwhPXRoaXMuY3VycmVudEdyYXBoJiZ0aGlzLmRyYWdPdmVyKHRoaXMuY3VycmVudEdyYXBoLGEpO2lmKG51bGw9PXRoaXMuZHJhZ0VsZW1lbnR8fG51bGwhPXRoaXMucHJldmlld0VsZW1lbnQmJiJ2aXNpYmxlIj09dGhpcy5wcmV2aWV3RWxlbWVudC5zdHlsZS52aXNpYmlsaXR5KW51bGwhPXRoaXMuZHJhZ0VsZW1lbnQmJih0aGlzLmRyYWdFbGVtZW50LnN0eWxlLnZpc2liaWxpdHk9CiJoaWRkZW4iKTtlbHNle3ZhciBiPW14RXZlbnQuZ2V0Q2xpZW50WChhKSxjPW14RXZlbnQuZ2V0Q2xpZW50WShhKTtudWxsPT10aGlzLmRyYWdFbGVtZW50LnBhcmVudE5vZGUmJmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5kcmFnRWxlbWVudCk7dGhpcy5kcmFnRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5PSJ2aXNpYmxlIjtudWxsIT10aGlzLmRyYWdPZmZzZXQmJihiKz10aGlzLmRyYWdPZmZzZXQueCxjKz10aGlzLmRyYWdPZmZzZXQueSk7dmFyIGQ9bXhVdGlscy5nZXREb2N1bWVudFNjcm9sbE9yaWdpbihkb2N1bWVudCk7dGhpcy5kcmFnRWxlbWVudC5zdHlsZS5sZWZ0PWIrZC54KyJweCI7dGhpcy5kcmFnRWxlbWVudC5zdHlsZS50b3A9YytkLnkrInB4In1teEV2ZW50LmNvbnN1bWUoYSl9OwpteERyYWdTb3VyY2UucHJvdG90eXBlLm1vdXNlVXA9ZnVuY3Rpb24oYSl7aWYobnVsbCE9dGhpcy5jdXJyZW50R3JhcGgpe2lmKG51bGwhPXRoaXMuY3VycmVudFBvaW50JiYobnVsbD09dGhpcy5wcmV2aWV3RWxlbWVudHx8ImhpZGRlbiIhPXRoaXMucHJldmlld0VsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSkpe3ZhciBiPXRoaXMuY3VycmVudEdyYXBoLnZpZXcuc2NhbGUsYz10aGlzLmN1cnJlbnRHcmFwaC52aWV3LnRyYW5zbGF0ZTt0aGlzLmRyb3AodGhpcy5jdXJyZW50R3JhcGgsYSx0aGlzLmN1cnJlbnREcm9wVGFyZ2V0LHRoaXMuY3VycmVudFBvaW50LngvYi1jLngsdGhpcy5jdXJyZW50UG9pbnQueS9iLWMueSl9dGhpcy5kcmFnRXhpdCh0aGlzLmN1cnJlbnRHcmFwaCk7dGhpcy5jdXJyZW50R3JhcGg9bnVsbH10aGlzLnN0b3BEcmFnKCk7dGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtteEV2ZW50LmNvbnN1bWUoYSl9OwpteERyYWdTb3VyY2UucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVycz1mdW5jdGlvbigpe251bGwhPXRoaXMuZXZlbnRTb3VyY2UmJihteEV2ZW50LnJlbW92ZUdlc3R1cmVMaXN0ZW5lcnModGhpcy5ldmVudFNvdXJjZSxudWxsLHRoaXMubW91c2VNb3ZlSGFuZGxlcix0aGlzLm1vdXNlVXBIYW5kbGVyKSx0aGlzLmV2ZW50U291cmNlPW51bGwpO214RXZlbnQucmVtb3ZlR2VzdHVyZUxpc3RlbmVycyhkb2N1bWVudCxudWxsLHRoaXMubW91c2VNb3ZlSGFuZGxlcix0aGlzLm1vdXNlVXBIYW5kbGVyKTt0aGlzLm1vdXNlVXBIYW5kbGVyPXRoaXMubW91c2VNb3ZlSGFuZGxlcj1udWxsfTsKbXhEcmFnU291cmNlLnByb3RvdHlwZS5kcmFnRW50ZXI9ZnVuY3Rpb24oYSxiKXthLmlzTW91c2VEb3duPSEwO2EuaXNNb3VzZVRyaWdnZXI9bXhFdmVudC5pc01vdXNlRXZlbnQoYik7dGhpcy5wcmV2aWV3RWxlbWVudD10aGlzLmNyZWF0ZVByZXZpZXdFbGVtZW50KGEpO251bGwhPXRoaXMucHJldmlld0VsZW1lbnQmJnRoaXMuY2hlY2tFdmVudFNvdXJjZSYmbXhDbGllbnQuSVNfU1ZHJiYodGhpcy5wcmV2aWV3RWxlbWVudC5zdHlsZS5wb2ludGVyRXZlbnRzPSJub25lIik7dGhpcy5pc0d1aWRlc0VuYWJsZWQoKSYmbnVsbCE9dGhpcy5wcmV2aWV3RWxlbWVudCYmKHRoaXMuY3VycmVudEd1aWRlPW5ldyBteEd1aWRlKGEsYS5ncmFwaEhhbmRsZXIuZ2V0R3VpZGVTdGF0ZXMoKSkpO3RoaXMuaGlnaGxpZ2h0RHJvcFRhcmdldHMmJih0aGlzLmN1cnJlbnRIaWdobGlnaHQ9bmV3IG14Q2VsbEhpZ2hsaWdodChhLG14Q29uc3RhbnRzLkRST1BfVEFSR0VUX0NPTE9SKSk7YS5hZGRMaXN0ZW5lcihteEV2ZW50LkZJUkVfTU9VU0VfRVZFTlQsCnRoaXMuZXZlbnRDb25zdW1lcil9O214RHJhZ1NvdXJjZS5wcm90b3R5cGUuZHJhZ0V4aXQ9ZnVuY3Rpb24oYSxiKXt0aGlzLmN1cnJlbnRQb2ludD10aGlzLmN1cnJlbnREcm9wVGFyZ2V0PW51bGw7YS5pc01vdXNlRG93bj0hMTthLnJlbW92ZUxpc3RlbmVyKHRoaXMuZXZlbnRDb25zdW1lcik7bnVsbCE9dGhpcy5wcmV2aWV3RWxlbWVudCYmKG51bGwhPXRoaXMucHJldmlld0VsZW1lbnQucGFyZW50Tm9kZSYmdGhpcy5wcmV2aWV3RWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucHJldmlld0VsZW1lbnQpLHRoaXMucHJldmlld0VsZW1lbnQ9bnVsbCk7bnVsbCE9dGhpcy5jdXJyZW50R3VpZGUmJih0aGlzLmN1cnJlbnRHdWlkZS5kZXN0cm95KCksdGhpcy5jdXJyZW50R3VpZGU9bnVsbCk7bnVsbCE9dGhpcy5jdXJyZW50SGlnaGxpZ2h0JiYodGhpcy5jdXJyZW50SGlnaGxpZ2h0LmRlc3Ryb3koKSx0aGlzLmN1cnJlbnRIaWdobGlnaHQ9bnVsbCl9OwpteERyYWdTb3VyY2UucHJvdG90eXBlLmRyYWdPdmVyPWZ1bmN0aW9uKGEsYil7dmFyIGM9bXhVdGlscy5nZXRPZmZzZXQoYS5jb250YWluZXIpLGQ9bXhVdGlscy5nZXRTY3JvbGxPcmlnaW4oYS5jb250YWluZXIpLGU9bXhFdmVudC5nZXRDbGllbnRYKGIpLWMueCtkLngtYS5wYW5EeCxjPW14RXZlbnQuZ2V0Q2xpZW50WShiKS1jLnkrZC55LWEucGFuRHk7YS5hdXRvU2Nyb2xsJiYobnVsbD09dGhpcy5hdXRvc2Nyb2xsfHx0aGlzLmF1dG9zY3JvbGwpJiZhLnNjcm9sbFBvaW50VG9WaXNpYmxlKGUsYyxhLmF1dG9FeHRlbmQpO251bGwhPXRoaXMuY3VycmVudEhpZ2hsaWdodCYmYS5pc0Ryb3BFbmFibGVkKCkmJih0aGlzLmN1cnJlbnREcm9wVGFyZ2V0PXRoaXMuZ2V0RHJvcFRhcmdldChhLGUsYyxiKSxkPWEuZ2V0VmlldygpLmdldFN0YXRlKHRoaXMuY3VycmVudERyb3BUYXJnZXQpLHRoaXMuY3VycmVudEhpZ2hsaWdodC5oaWdobGlnaHQoZCkpO2lmKG51bGwhPXRoaXMucHJldmlld0VsZW1lbnQpe251bGw9PQp0aGlzLnByZXZpZXdFbGVtZW50LnBhcmVudE5vZGUmJihhLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnByZXZpZXdFbGVtZW50KSx0aGlzLnByZXZpZXdFbGVtZW50LnN0eWxlLnpJbmRleD0iMyIsdGhpcy5wcmV2aWV3RWxlbWVudC5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiKTt2YXIgZD10aGlzLmlzR3JpZEVuYWJsZWQoKSYmYS5pc0dyaWRFbmFibGVkRXZlbnQoYiksZj0hMDtpZihudWxsIT10aGlzLmN1cnJlbnRHdWlkZSYmdGhpcy5jdXJyZW50R3VpZGUuaXNFbmFibGVkRm9yRXZlbnQoYikpdmFyIGY9cGFyc2VJbnQodGhpcy5wcmV2aWV3RWxlbWVudC5zdHlsZS53aWR0aCksZz1wYXJzZUludCh0aGlzLnByZXZpZXdFbGVtZW50LnN0eWxlLmhlaWdodCksZj1uZXcgbXhSZWN0YW5nbGUoMCwwLGYsZyksYz1uZXcgbXhQb2ludChlLGMpLGM9dGhpcy5jdXJyZW50R3VpZGUubW92ZShmLGMsZCwhMCksZj0hMSxlPWMueCxjPWMueTtlbHNlIGlmKGQpdmFyIGQ9YS52aWV3LnNjYWxlLApnPWEudmlldy50cmFuc2xhdGUsaz1hLmdyaWRTaXplLzIsZT0oYS5zbmFwKGUvZC1nLngtaykrZy54KSpkLGM9KGEuc25hcChjL2QtZy55LWspK2cueSkqZDtudWxsIT10aGlzLmN1cnJlbnRHdWlkZSYmZiYmdGhpcy5jdXJyZW50R3VpZGUuaGlkZSgpO251bGwhPXRoaXMucHJldmlld09mZnNldCYmKGUrPXRoaXMucHJldmlld09mZnNldC54LGMrPXRoaXMucHJldmlld09mZnNldC55KTt0aGlzLnByZXZpZXdFbGVtZW50LnN0eWxlLmxlZnQ9TWF0aC5yb3VuZChlKSsicHgiO3RoaXMucHJldmlld0VsZW1lbnQuc3R5bGUudG9wPU1hdGgucm91bmQoYykrInB4Ijt0aGlzLnByZXZpZXdFbGVtZW50LnN0eWxlLnZpc2liaWxpdHk9InZpc2libGUifXRoaXMuY3VycmVudFBvaW50PW5ldyBteFBvaW50KGUsYyl9OwpteERyYWdTb3VyY2UucHJvdG90eXBlLmRyb3A9ZnVuY3Rpb24oYSxiLGMsZCxlKXt0aGlzLmRyb3BIYW5kbGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsiaGlkZGVuIiE9YS5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSYmYS5jb250YWluZXIuZm9jdXMoKX07ZnVuY3Rpb24gbXhUb29sYmFyKGEpe3RoaXMuY29udGFpbmVyPWF9bXhUb29sYmFyLnByb3RvdHlwZT1uZXcgbXhFdmVudFNvdXJjZTtteFRvb2xiYXIucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14VG9vbGJhcjtteFRvb2xiYXIucHJvdG90eXBlLmNvbnRhaW5lcj1udWxsO214VG9vbGJhci5wcm90b3R5cGUuZW5hYmxlZD0hMDtteFRvb2xiYXIucHJvdG90eXBlLm5vUmVzZXQ9ITE7bXhUb29sYmFyLnByb3RvdHlwZS51cGRhdGVEZWZhdWx0TW9kZT0hMDsKbXhUb29sYmFyLnByb3RvdHlwZS5hZGRJdGVtPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KG51bGwhPWI/ImltZyI6ImJ1dHRvbiIpLGs9ZXx8KG51bGwhPWY/Im14VG9vbGJhck1vZGUiOiJteFRvb2xiYXJJdGVtIik7Zy5jbGFzc05hbWU9aztnLnNldEF0dHJpYnV0ZSgic3JjIixiKTtudWxsIT1hJiYobnVsbCE9Yj9nLnNldEF0dHJpYnV0ZSgidGl0bGUiLGEpOm14VXRpbHMud3JpdGUoZyxhKSk7dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZyk7bnVsbCE9YyYmKG14RXZlbnQuYWRkTGlzdGVuZXIoZywiY2xpY2siLGMpLG14Q2xpZW50LklTX1RPVUNIJiZteEV2ZW50LmFkZExpc3RlbmVyKGcsInRvdWNoZW5kIixjKSk7YT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsIT1kP2cuc2V0QXR0cmlidXRlKCJzcmMiLGIpOmcuc3R5bGUuYmFja2dyb3VuZENvbG9yPSIifSk7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKGcsCm14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe251bGwhPWQ/Zy5zZXRBdHRyaWJ1dGUoInNyYyIsZCk6Zy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9ImdyYXkiO2lmKG51bGwhPWYpe251bGw9PXRoaXMubWVudSYmKHRoaXMubWVudT1uZXcgbXhQb3B1cE1lbnUsdGhpcy5tZW51LmluaXQoKSk7dmFyIGI9dGhpcy5jdXJyZW50SW1nO3RoaXMubWVudS5pc01lbnVTaG93aW5nKCkmJnRoaXMubWVudS5oaWRlTWVudSgpO2IhPWcmJih0aGlzLmN1cnJlbnRJbWc9Zyx0aGlzLm1lbnUuZmFjdG9yeU1ldGhvZD1mLGI9bmV3IG14UG9pbnQoZy5vZmZzZXRMZWZ0LGcub2Zmc2V0VG9wK2cub2Zmc2V0SGVpZ2h0KSx0aGlzLm1lbnUucG9wdXAoYi54LGIueSxudWxsLGEpLHRoaXMubWVudS5pc01lbnVTaG93aW5nKCkmJihnLmNsYXNzTmFtZT1rKyJTZWxlY3RlZCIsdGhpcy5tZW51LmhpZGVNZW51PWZ1bmN0aW9uKCl7bXhQb3B1cE1lbnUucHJvdG90eXBlLmhpZGVNZW51LmFwcGx5KHRoaXMpOwpnLmNsYXNzTmFtZT1rO3RoaXMuY3VycmVudEltZz1udWxsfSkpfX0pLG51bGwsYSk7bXhFdmVudC5hZGRMaXN0ZW5lcihnLCJtb3VzZW91dCIsYSk7cmV0dXJuIGd9O214VG9vbGJhci5wcm90b3R5cGUuYWRkQ29tYm89ZnVuY3Rpb24oYSl7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Yi5zdHlsZS5kaXNwbGF5PSJpbmxpbmUiO2IuY2xhc3NOYW1lPSJteFRvb2xiYXJDb21ib0NvbnRhaW5lciI7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic2VsZWN0Iik7Yy5jbGFzc05hbWU9YXx8Im14VG9vbGJhckNvbWJvIjtiLmFwcGVuZENoaWxkKGMpO3RoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGIpO3JldHVybiBjfTsKbXhUb29sYmFyLnByb3RvdHlwZS5hZGRBY3Rpb25Db21ibz1mdW5jdGlvbihhLGIpe3ZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNlbGVjdCIpO2MuY2xhc3NOYW1lPWJ8fCJteFRvb2xiYXJDb21ibyI7dGhpcy5hZGRPcHRpb24oYyxhLG51bGwpO214RXZlbnQuYWRkTGlzdGVuZXIoYywiY2hhbmdlIixmdW5jdGlvbihhKXt2YXIgYj1jLm9wdGlvbnNbYy5zZWxlY3RlZEluZGV4XTtjLnNlbGVjdGVkSW5kZXg9MDtudWxsIT1iLmZ1bmN0JiZiLmZ1bmN0KGEpfSk7dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoYyk7cmV0dXJuIGN9O214VG9vbGJhci5wcm90b3R5cGUuYWRkT3B0aW9uPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJvcHRpb24iKTtteFV0aWxzLndyaXRlbG4oZCxiKTsiZnVuY3Rpb24iPT10eXBlb2YgYz9kLmZ1bmN0PWM6ZC5zZXRBdHRyaWJ1dGUoInZhbHVlIixjKTthLmFwcGVuZENoaWxkKGQpO3JldHVybiBkfTsKbXhUb29sYmFyLnByb3RvdHlwZS5hZGRTd2l0Y2hNb2RlPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIik7Zi5pbml0aWFsQ2xhc3NOYW1lPWV8fCJteFRvb2xiYXJNb2RlIjtmLmNsYXNzTmFtZT1mLmluaXRpYWxDbGFzc05hbWU7Zi5zZXRBdHRyaWJ1dGUoInNyYyIsYik7Zi5hbHRJY29uPWQ7bnVsbCE9YSYmZi5zZXRBdHRyaWJ1dGUoInRpdGxlIixhKTtteEV2ZW50LmFkZExpc3RlbmVyKGYsImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXthPXRoaXMuc2VsZWN0ZWRNb2RlLmFsdEljb247bnVsbCE9YT8odGhpcy5zZWxlY3RlZE1vZGUuYWx0SWNvbj10aGlzLnNlbGVjdGVkTW9kZS5nZXRBdHRyaWJ1dGUoInNyYyIpLHRoaXMuc2VsZWN0ZWRNb2RlLnNldEF0dHJpYnV0ZSgic3JjIixhKSk6dGhpcy5zZWxlY3RlZE1vZGUuY2xhc3NOYW1lPXRoaXMuc2VsZWN0ZWRNb2RlLmluaXRpYWxDbGFzc05hbWU7dGhpcy51cGRhdGVEZWZhdWx0TW9kZSYmCih0aGlzLmRlZmF1bHRNb2RlPWYpO3RoaXMuc2VsZWN0ZWRNb2RlPWY7YT1mLmFsdEljb247bnVsbCE9YT8oZi5hbHRJY29uPWYuZ2V0QXR0cmlidXRlKCJzcmMiKSxmLnNldEF0dHJpYnV0ZSgic3JjIixhKSk6Zi5jbGFzc05hbWU9Zi5pbml0aWFsQ2xhc3NOYW1lKyJTZWxlY3RlZCI7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5TRUxFQ1QpKTtjKCl9KSk7dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZik7bnVsbD09dGhpcy5kZWZhdWx0TW9kZSYmKHRoaXMuZGVmYXVsdE1vZGU9Zix0aGlzLnNlbGVjdE1vZGUoZiksYygpKTtyZXR1cm4gZn07Cm14VG9vbGJhci5wcm90b3R5cGUuYWRkTW9kZT1mdW5jdGlvbihhLGIsYyxkLGUsZil7Zj1udWxsIT1mP2Y6ITA7dmFyIGc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChudWxsIT1iPyJpbWciOiJidXR0b24iKTtnLmluaXRpYWxDbGFzc05hbWU9ZXx8Im14VG9vbGJhck1vZGUiO2cuY2xhc3NOYW1lPWcuaW5pdGlhbENsYXNzTmFtZTtnLnNldEF0dHJpYnV0ZSgic3JjIixiKTtnLmFsdEljb249ZDtudWxsIT1hJiZnLnNldEF0dHJpYnV0ZSgidGl0bGUiLGEpO3RoaXMuZW5hYmxlZCYmZiYmKG14RXZlbnQuYWRkTGlzdGVuZXIoZywiY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuc2VsZWN0TW9kZShnLGMpO3RoaXMubm9SZXNldD0hMX0pKSxteEV2ZW50LmFkZExpc3RlbmVyKGcsImRibGNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLnNlbGVjdE1vZGUoZyxjKTt0aGlzLm5vUmVzZXQ9ITB9KSksbnVsbD09dGhpcy5kZWZhdWx0TW9kZSYmCih0aGlzLmRlZmF1bHRNb2RlPWcsdGhpcy5kZWZhdWx0RnVuY3Rpb249Yyx0aGlzLnNlbGVjdE1vZGUoZyxjKSkpO3RoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGcpO3JldHVybiBnfTsKbXhUb29sYmFyLnByb3RvdHlwZS5zZWxlY3RNb2RlPWZ1bmN0aW9uKGEsYil7aWYodGhpcy5zZWxlY3RlZE1vZGUhPWEpe2lmKG51bGwhPXRoaXMuc2VsZWN0ZWRNb2RlKXt2YXIgYz10aGlzLnNlbGVjdGVkTW9kZS5hbHRJY29uO251bGwhPWM/KHRoaXMuc2VsZWN0ZWRNb2RlLmFsdEljb249dGhpcy5zZWxlY3RlZE1vZGUuZ2V0QXR0cmlidXRlKCJzcmMiKSx0aGlzLnNlbGVjdGVkTW9kZS5zZXRBdHRyaWJ1dGUoInNyYyIsYykpOnRoaXMuc2VsZWN0ZWRNb2RlLmNsYXNzTmFtZT10aGlzLnNlbGVjdGVkTW9kZS5pbml0aWFsQ2xhc3NOYW1lfXRoaXMuc2VsZWN0ZWRNb2RlPWE7Yz10aGlzLnNlbGVjdGVkTW9kZS5hbHRJY29uO251bGwhPWM/KHRoaXMuc2VsZWN0ZWRNb2RlLmFsdEljb249dGhpcy5zZWxlY3RlZE1vZGUuZ2V0QXR0cmlidXRlKCJzcmMiKSx0aGlzLnNlbGVjdGVkTW9kZS5zZXRBdHRyaWJ1dGUoInNyYyIsYykpOnRoaXMuc2VsZWN0ZWRNb2RlLmNsYXNzTmFtZT10aGlzLnNlbGVjdGVkTW9kZS5pbml0aWFsQ2xhc3NOYW1lKwoiU2VsZWN0ZWQiO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuU0VMRUNULCJmdW5jdGlvbiIsYikpfX07bXhUb29sYmFyLnByb3RvdHlwZS5yZXNldE1vZGU9ZnVuY3Rpb24oYSl7IWEmJnRoaXMubm9SZXNldHx8dGhpcy5zZWxlY3RlZE1vZGU9PXRoaXMuZGVmYXVsdE1vZGV8fHRoaXMuc2VsZWN0TW9kZSh0aGlzLmRlZmF1bHRNb2RlLHRoaXMuZGVmYXVsdEZ1bmN0aW9uKX07bXhUb29sYmFyLnByb3RvdHlwZS5hZGRTZXBhcmF0b3I9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYWRkSXRlbShudWxsLGEsbnVsbCl9O214VG9vbGJhci5wcm90b3R5cGUuYWRkQnJlYWs9ZnVuY3Rpb24oKXtteFV0aWxzLmJyKHRoaXMuY29udGFpbmVyKX07Cm14VG9vbGJhci5wcm90b3R5cGUuYWRkTGluZT1mdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImhyIik7YS5zdHlsZS5tYXJnaW5SaWdodD0iNnB4IjthLnNldEF0dHJpYnV0ZSgic2l6ZSIsIjEiKTt0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChhKX07bXhUb29sYmFyLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7bXhFdmVudC5yZWxlYXNlKHRoaXMuY29udGFpbmVyKTt0aGlzLnNlbGVjdGVkTW9kZT10aGlzLmRlZmF1bHRGdW5jdGlvbj10aGlzLmRlZmF1bHRNb2RlPXRoaXMuY29udGFpbmVyPW51bGw7bnVsbCE9dGhpcy5tZW51JiZ0aGlzLm1lbnUuZGVzdHJveSgpfTtmdW5jdGlvbiBteFVuZG9hYmxlRWRpdChhLGIpe3RoaXMuc291cmNlPWE7dGhpcy5jaGFuZ2VzPVtdO3RoaXMuc2lnbmlmaWNhbnQ9bnVsbCE9Yj9iOiEwfW14VW5kb2FibGVFZGl0LnByb3RvdHlwZS5zb3VyY2U9bnVsbDsKbXhVbmRvYWJsZUVkaXQucHJvdG90eXBlLmNoYW5nZXM9bnVsbDtteFVuZG9hYmxlRWRpdC5wcm90b3R5cGUuc2lnbmlmaWNhbnQ9bnVsbDtteFVuZG9hYmxlRWRpdC5wcm90b3R5cGUudW5kb25lPSExO214VW5kb2FibGVFZGl0LnByb3RvdHlwZS5yZWRvbmU9ITE7bXhVbmRvYWJsZUVkaXQucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09dGhpcy5jaGFuZ2VzLmxlbmd0aH07bXhVbmRvYWJsZUVkaXQucHJvdG90eXBlLmlzU2lnbmlmaWNhbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaWduaWZpY2FudH07bXhVbmRvYWJsZUVkaXQucHJvdG90eXBlLmFkZD1mdW5jdGlvbihhKXt0aGlzLmNoYW5nZXMucHVzaChhKX07bXhVbmRvYWJsZUVkaXQucHJvdG90eXBlLm5vdGlmeT1mdW5jdGlvbigpe307bXhVbmRvYWJsZUVkaXQucHJvdG90eXBlLmRpZT1mdW5jdGlvbigpe307Cm14VW5kb2FibGVFZGl0LnByb3RvdHlwZS51bmRvPWZ1bmN0aW9uKCl7aWYoIXRoaXMudW5kb25lKXt0aGlzLnNvdXJjZS5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5TVEFSVF9FRElUKSk7Zm9yKHZhciBhPXRoaXMuY2hhbmdlcy5sZW5ndGgtMTswPD1hO2EtLSl7dmFyIGI9dGhpcy5jaGFuZ2VzW2FdO251bGwhPWIuZXhlY3V0ZT9iLmV4ZWN1dGUoKTpudWxsIT1iLnVuZG8mJmIudW5kbygpO3RoaXMuc291cmNlLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkVYRUNVVEVELCJjaGFuZ2UiLGIpKX10aGlzLnVuZG9uZT0hMDt0aGlzLnJlZG9uZT0hMTt0aGlzLnNvdXJjZS5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5FTkRfRURJVCkpfXRoaXMubm90aWZ5KCl9OwpteFVuZG9hYmxlRWRpdC5wcm90b3R5cGUucmVkbz1mdW5jdGlvbigpe2lmKCF0aGlzLnJlZG9uZSl7dGhpcy5zb3VyY2UuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuU1RBUlRfRURJVCkpO2Zvcih2YXIgYT10aGlzLmNoYW5nZXMubGVuZ3RoLGI9MDtiPGE7YisrKXt2YXIgYz10aGlzLmNoYW5nZXNbYl07bnVsbCE9Yy5leGVjdXRlP2MuZXhlY3V0ZSgpOm51bGwhPWMucmVkbyYmYy5yZWRvKCk7dGhpcy5zb3VyY2UuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuRVhFQ1VURUQsImNoYW5nZSIsYykpfXRoaXMudW5kb25lPSExO3RoaXMucmVkb25lPSEwO3RoaXMuc291cmNlLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkVORF9FRElUKSl9dGhpcy5ub3RpZnkoKX07ZnVuY3Rpb24gbXhVbmRvTWFuYWdlcihhKXt0aGlzLnNpemU9bnVsbCE9YT9hOjEwMDt0aGlzLmNsZWFyKCl9bXhVbmRvTWFuYWdlci5wcm90b3R5cGU9bmV3IG14RXZlbnRTb3VyY2U7Cm14VW5kb01hbmFnZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14VW5kb01hbmFnZXI7bXhVbmRvTWFuYWdlci5wcm90b3R5cGUuc2l6ZT1udWxsO214VW5kb01hbmFnZXIucHJvdG90eXBlLmhpc3Rvcnk9bnVsbDtteFVuZG9NYW5hZ2VyLnByb3RvdHlwZS5pbmRleE9mTmV4dEFkZD0wO214VW5kb01hbmFnZXIucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09dGhpcy5oaXN0b3J5Lmxlbmd0aH07bXhVbmRvTWFuYWdlci5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLmhpc3Rvcnk9W107dGhpcy5pbmRleE9mTmV4dEFkZD0wO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuQ0xFQVIpKX07bXhVbmRvTWFuYWdlci5wcm90b3R5cGUuY2FuVW5kbz1mdW5jdGlvbigpe3JldHVybiAwPHRoaXMuaW5kZXhPZk5leHRBZGR9OwpteFVuZG9NYW5hZ2VyLnByb3RvdHlwZS51bmRvPWZ1bmN0aW9uKCl7Zm9yKDswPHRoaXMuaW5kZXhPZk5leHRBZGQ7KXt2YXIgYT10aGlzLmhpc3RvcnlbLS10aGlzLmluZGV4T2ZOZXh0QWRkXTthLnVuZG8oKTtpZihhLmlzU2lnbmlmaWNhbnQoKSl7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5VTkRPLCJlZGl0IixhKSk7YnJlYWt9fX07bXhVbmRvTWFuYWdlci5wcm90b3R5cGUuY2FuUmVkbz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmluZGV4T2ZOZXh0QWRkPHRoaXMuaGlzdG9yeS5sZW5ndGh9OwpteFVuZG9NYW5hZ2VyLnByb3RvdHlwZS5yZWRvPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMuaGlzdG9yeS5sZW5ndGg7dGhpcy5pbmRleE9mTmV4dEFkZDxhOyl7dmFyIGI9dGhpcy5oaXN0b3J5W3RoaXMuaW5kZXhPZk5leHRBZGQrK107Yi5yZWRvKCk7aWYoYi5pc1NpZ25pZmljYW50KCkpe3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuUkVETywiZWRpdCIsYikpO2JyZWFrfX19O214VW5kb01hbmFnZXIucHJvdG90eXBlLnVuZG9hYmxlRWRpdEhhcHBlbmVkPWZ1bmN0aW9uKGEpe3RoaXMudHJpbSgpOzA8dGhpcy5zaXplJiZ0aGlzLnNpemU9PXRoaXMuaGlzdG9yeS5sZW5ndGgmJnRoaXMuaGlzdG9yeS5zaGlmdCgpO3RoaXMuaGlzdG9yeS5wdXNoKGEpO3RoaXMuaW5kZXhPZk5leHRBZGQ9dGhpcy5oaXN0b3J5Lmxlbmd0aDt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkFERCwiZWRpdCIsYSkpfTsKbXhVbmRvTWFuYWdlci5wcm90b3R5cGUudHJpbT1mdW5jdGlvbigpe2lmKHRoaXMuaGlzdG9yeS5sZW5ndGg+dGhpcy5pbmRleE9mTmV4dEFkZClmb3IodmFyIGE9dGhpcy5oaXN0b3J5LnNwbGljZSh0aGlzLmluZGV4T2ZOZXh0QWRkLHRoaXMuaGlzdG9yeS5sZW5ndGgtdGhpcy5pbmRleE9mTmV4dEFkZCksYj0wO2I8YS5sZW5ndGg7YisrKWFbYl0uZGllKCl9O3ZhciBteFVybENvbnZlcnRlcj1mdW5jdGlvbigpe307bXhVcmxDb252ZXJ0ZXIucHJvdG90eXBlLmVuYWJsZWQ9ITA7bXhVcmxDb252ZXJ0ZXIucHJvdG90eXBlLmJhc2VVcmw9bnVsbDtteFVybENvbnZlcnRlci5wcm90b3R5cGUuYmFzZURvbWFpbj1udWxsOwpteFVybENvbnZlcnRlci5wcm90b3R5cGUudXBkYXRlQmFzZVVybD1mdW5jdGlvbigpe3RoaXMuYmFzZURvbWFpbj1sb2NhdGlvbi5wcm90b2NvbCsiLy8iK2xvY2F0aW9uLmhvc3Q7dGhpcy5iYXNlVXJsPXRoaXMuYmFzZURvbWFpbitsb2NhdGlvbi5wYXRobmFtZTt2YXIgYT10aGlzLmJhc2VVcmwubGFzdEluZGV4T2YoIi8iKTswPGEmJih0aGlzLmJhc2VVcmw9dGhpcy5iYXNlVXJsLnN1YnN0cmluZygwLGErMSkpfTtteFVybENvbnZlcnRlci5wcm90b3R5cGUuaXNFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5hYmxlZH07bXhVcmxDb252ZXJ0ZXIucHJvdG90eXBlLnNldEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5lbmFibGVkPWF9O214VXJsQ29udmVydGVyLnByb3RvdHlwZS5nZXRCYXNlVXJsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmFzZVVybH07bXhVcmxDb252ZXJ0ZXIucHJvdG90eXBlLnNldEJhc2VVcmw9ZnVuY3Rpb24oYSl7dGhpcy5iYXNlVXJsPWF9OwpteFVybENvbnZlcnRlci5wcm90b3R5cGUuZ2V0QmFzZURvbWFpbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJhc2VEb21haW59O214VXJsQ29udmVydGVyLnByb3RvdHlwZS5zZXRCYXNlRG9tYWluPWZ1bmN0aW9uKGEpe3RoaXMuYmFzZURvbWFpbj1hfTtteFVybENvbnZlcnRlci5wcm90b3R5cGUuaXNSZWxhdGl2ZVVybD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YSYmIi8vIiE9YS5zdWJzdHJpbmcoMCwyKSYmImh0dHA6Ly8iIT1hLnN1YnN0cmluZygwLDcpJiYiaHR0cHM6Ly8iIT1hLnN1YnN0cmluZygwLDgpJiYiZGF0YTppbWFnZSIhPWEuc3Vic3RyaW5nKDAsMTApJiYiZmlsZTovLyIhPWEuc3Vic3RyaW5nKDAsNyl9OwpteFVybENvbnZlcnRlci5wcm90b3R5cGUuY29udmVydD1mdW5jdGlvbihhKXt0aGlzLmlzRW5hYmxlZCgpJiZ0aGlzLmlzUmVsYXRpdmVVcmwoYSkmJihudWxsPT10aGlzLmdldEJhc2VVcmwoKSYmdGhpcy51cGRhdGVCYXNlVXJsKCksYT0iLyI9PWEuY2hhckF0KDApP3RoaXMuZ2V0QmFzZURvbWFpbigpK2E6dGhpcy5nZXRCYXNlVXJsKCkrYSk7cmV0dXJuIGF9OwpmdW5jdGlvbiBteFBhbm5pbmdNYW5hZ2VyKGEpe3RoaXMudGhyZWFkPW51bGw7dGhpcy5hY3RpdmU9ITE7dGhpcy5keT10aGlzLmR4PXRoaXMudDB5PXRoaXMudDB4PXRoaXMudGR5PXRoaXMudGR4PTA7dGhpcy5zY3JvbGxiYXJzPSExO3RoaXMuc2Nyb2xsVG9wPXRoaXMuc2Nyb2xsTGVmdD0wO3RoaXMubW91c2VMaXN0ZW5lcj17bW91c2VEb3duOmZ1bmN0aW9uKGEsYil7fSxtb3VzZU1vdmU6ZnVuY3Rpb24oYSxiKXt9LG1vdXNlVXA6bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiKXt0aGlzLmFjdGl2ZSYmdGhpcy5zdG9wKCl9KX07YS5hZGRNb3VzZUxpc3RlbmVyKHRoaXMubW91c2VMaXN0ZW5lcik7dGhpcy5tb3VzZVVwTGlzdGVuZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmFjdGl2ZSYmdGhpcy5zdG9wKCl9KTtteEV2ZW50LmFkZExpc3RlbmVyKGRvY3VtZW50LCJtb3VzZXVwIix0aGlzLm1vdXNlVXBMaXN0ZW5lcik7dmFyIGI9bXhVdGlscy5iaW5kKHRoaXMsCmZ1bmN0aW9uKCl7dGhpcy5zY3JvbGxiYXJzPW14VXRpbHMuaGFzU2Nyb2xsYmFycyhhLmNvbnRhaW5lcik7dGhpcy5zY3JvbGxMZWZ0PWEuY29udGFpbmVyLnNjcm9sbExlZnQ7dGhpcy5zY3JvbGxUb3A9YS5jb250YWluZXIuc2Nyb2xsVG9wO3JldHVybiB3aW5kb3cuc2V0SW50ZXJ2YWwobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnRkeC09dGhpcy5keDt0aGlzLnRkeS09dGhpcy5keTt0aGlzLnNjcm9sbGJhcnM/KGEucGFuR3JhcGgoLWEuY29udGFpbmVyLnNjcm9sbExlZnQtTWF0aC5jZWlsKHRoaXMuZHgpLC1hLmNvbnRhaW5lci5zY3JvbGxUb3AtTWF0aC5jZWlsKHRoaXMuZHkpKSxhLnBhbkR4PXRoaXMuc2Nyb2xsTGVmdC1hLmNvbnRhaW5lci5zY3JvbGxMZWZ0LGEucGFuRHk9dGhpcy5zY3JvbGxUb3AtYS5jb250YWluZXIuc2Nyb2xsVG9wLGEuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuUEFOKSkpOmEucGFuR3JhcGgodGhpcy5nZXREeCgpLAp0aGlzLmdldER5KCkpfSksdGhpcy5kZWxheSl9KTt0aGlzLmlzQWN0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIGFjdGl2ZX07dGhpcy5nZXREeD1mdW5jdGlvbigpe3JldHVybiBNYXRoLnJvdW5kKHRoaXMudGR4KX07dGhpcy5nZXREeT1mdW5jdGlvbigpe3JldHVybiBNYXRoLnJvdW5kKHRoaXMudGR5KX07dGhpcy5zdGFydD1mdW5jdGlvbigpe3RoaXMudDB4PWEudmlldy50cmFuc2xhdGUueDt0aGlzLnQweT1hLnZpZXcudHJhbnNsYXRlLnk7dGhpcy5hY3RpdmU9ITB9O3RoaXMucGFuVG89ZnVuY3Rpb24oYyxkLGUsZil7dGhpcy5hY3RpdmV8fHRoaXMuc3RhcnQoKTt0aGlzLnNjcm9sbExlZnQ9YS5jb250YWluZXIuc2Nyb2xsTGVmdDt0aGlzLnNjcm9sbFRvcD1hLmNvbnRhaW5lci5zY3JvbGxUb3A7dmFyIGc9YS5jb250YWluZXI7dGhpcy5keD1jKyhudWxsIT1lP2U6MCktZy5zY3JvbGxMZWZ0LWcuY2xpZW50V2lkdGg7dGhpcy5keD0wPnRoaXMuZHgmJk1hdGguYWJzKHRoaXMuZHgpPAp0aGlzLmJvcmRlcj90aGlzLmJvcmRlcit0aGlzLmR4OnRoaXMuaGFuZGxlTW91c2VPdXQ/TWF0aC5tYXgodGhpcy5keCwwKTowOzA9PXRoaXMuZHgmJih0aGlzLmR4PWMtZy5zY3JvbGxMZWZ0LHRoaXMuZHg9MDx0aGlzLmR4JiZ0aGlzLmR4PHRoaXMuYm9yZGVyP3RoaXMuZHgtdGhpcy5ib3JkZXI6dGhpcy5oYW5kbGVNb3VzZU91dD9NYXRoLm1pbigwLHRoaXMuZHgpOjApO3RoaXMuZHk9ZCsobnVsbCE9Zj9mOjApLWcuc2Nyb2xsVG9wLWcuY2xpZW50SGVpZ2h0O3RoaXMuZHk9MD50aGlzLmR5JiZNYXRoLmFicyh0aGlzLmR5KTx0aGlzLmJvcmRlcj90aGlzLmJvcmRlcit0aGlzLmR5OnRoaXMuaGFuZGxlTW91c2VPdXQ/TWF0aC5tYXgodGhpcy5keSwwKTowOzA9PXRoaXMuZHkmJih0aGlzLmR5PWQtZy5zY3JvbGxUb3AsdGhpcy5keT0wPHRoaXMuZHkmJnRoaXMuZHk8dGhpcy5ib3JkZXI/dGhpcy5keS10aGlzLmJvcmRlcjp0aGlzLmhhbmRsZU1vdXNlT3V0P01hdGgubWluKDAsdGhpcy5keSk6CjApOzAhPXRoaXMuZHh8fDAhPXRoaXMuZHk/KHRoaXMuZHgqPXRoaXMuZGFtcGVyLHRoaXMuZHkqPXRoaXMuZGFtcGVyLG51bGw9PXRoaXMudGhyZWFkJiYodGhpcy50aHJlYWQ9YigpKSk6bnVsbCE9dGhpcy50aHJlYWQmJih3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLnRocmVhZCksdGhpcy50aHJlYWQ9bnVsbCl9O3RoaXMuc3RvcD1mdW5jdGlvbigpe2lmKHRoaXMuYWN0aXZlKWlmKHRoaXMuYWN0aXZlPSExLG51bGwhPXRoaXMudGhyZWFkJiYod2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy50aHJlYWQpLHRoaXMudGhyZWFkPW51bGwpLHRoaXMudGR5PXRoaXMudGR4PTAsdGhpcy5zY3JvbGxiYXJzKWEucGFuRHg9MCxhLnBhbkR5PTAsYS5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5QQU4pKTtlbHNle3ZhciBiPWEucGFuRHgsZD1hLnBhbkR5O2lmKDAhPWJ8fDAhPWQpYS5wYW5HcmFwaCgwLDApLGEudmlldy5zZXRUcmFuc2xhdGUodGhpcy50MHgrYi9hLnZpZXcuc2NhbGUsCnRoaXMudDB5K2QvYS52aWV3LnNjYWxlKX19O3RoaXMuZGVzdHJveT1mdW5jdGlvbigpe2EucmVtb3ZlTW91c2VMaXN0ZW5lcih0aGlzLm1vdXNlTGlzdGVuZXIpO214RXZlbnQucmVtb3ZlTGlzdGVuZXIoZG9jdW1lbnQsIm1vdXNldXAiLHRoaXMubW91c2VVcExpc3RlbmVyKX19bXhQYW5uaW5nTWFuYWdlci5wcm90b3R5cGUuZGFtcGVyPTEvNjtteFBhbm5pbmdNYW5hZ2VyLnByb3RvdHlwZS5kZWxheT0xMDtteFBhbm5pbmdNYW5hZ2VyLnByb3RvdHlwZS5oYW5kbGVNb3VzZU91dD0hMDtteFBhbm5pbmdNYW5hZ2VyLnByb3RvdHlwZS5ib3JkZXI9MDtmdW5jdGlvbiBteFBvcHVwTWVudShhKXt0aGlzLmZhY3RvcnlNZXRob2Q9YTtudWxsIT1hJiZ0aGlzLmluaXQoKX1teFBvcHVwTWVudS5wcm90b3R5cGU9bmV3IG14RXZlbnRTb3VyY2U7bXhQb3B1cE1lbnUucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14UG9wdXBNZW51OwpteFBvcHVwTWVudS5wcm90b3R5cGUuc3VibWVudUltYWdlPW14Q2xpZW50LmltYWdlQmFzZVBhdGgrIi9zdWJtZW51LmdpZiI7bXhQb3B1cE1lbnUucHJvdG90eXBlLnpJbmRleD0xMDAwNjtteFBvcHVwTWVudS5wcm90b3R5cGUuZmFjdG9yeU1ldGhvZD1udWxsO214UG9wdXBNZW51LnByb3RvdHlwZS51c2VMZWZ0QnV0dG9uRm9yUG9wdXA9ITE7bXhQb3B1cE1lbnUucHJvdG90eXBlLmVuYWJsZWQ9ITA7bXhQb3B1cE1lbnUucHJvdG90eXBlLml0ZW1Db3VudD0wO214UG9wdXBNZW51LnByb3RvdHlwZS5hdXRvRXhwYW5kPSExO214UG9wdXBNZW51LnByb3RvdHlwZS5zbWFydFNlcGFyYXRvcnM9ITE7bXhQb3B1cE1lbnUucHJvdG90eXBlLmxhYmVscz0hMDsKbXhQb3B1cE1lbnUucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oKXt0aGlzLnRhYmxlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRhYmxlIik7dGhpcy50YWJsZS5jbGFzc05hbWU9Im14UG9wdXBNZW51Ijt0aGlzLnRib2R5PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRib2R5Iik7dGhpcy50YWJsZS5hcHBlbmRDaGlsZCh0aGlzLnRib2R5KTt0aGlzLmRpdj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTt0aGlzLmRpdi5jbGFzc05hbWU9Im14UG9wdXBNZW51Ijt0aGlzLmRpdi5zdHlsZS5kaXNwbGF5PSJpbmxpbmUiO3RoaXMuZGl2LnN0eWxlLnpJbmRleD10aGlzLnpJbmRleDt0aGlzLmRpdi5hcHBlbmRDaGlsZCh0aGlzLnRhYmxlKTtteEV2ZW50LmRpc2FibGVDb250ZXh0TWVudSh0aGlzLmRpdil9O214UG9wdXBNZW51LnByb3RvdHlwZS5pc0VuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbmFibGVkfTsKbXhQb3B1cE1lbnUucHJvdG90eXBlLnNldEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5lbmFibGVkPWF9O214UG9wdXBNZW51LnByb3RvdHlwZS5pc1BvcHVwVHJpZ2dlcj1mdW5jdGlvbihhKXtyZXR1cm4gYS5pc1BvcHVwVHJpZ2dlcigpfHx0aGlzLnVzZUxlZnRCdXR0b25Gb3JQb3B1cCYmbXhFdmVudC5pc0xlZnRNb3VzZUJ1dHRvbihhLmdldEV2ZW50KCkpfTsKbXhQb3B1cE1lbnUucHJvdG90eXBlLmFkZEl0ZW09ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxrKXtkPWR8fHRoaXM7dGhpcy5pdGVtQ291bnQrKztkLndpbGxBZGRTZXBhcmF0b3ImJihkLmNvbnRhaW5zSXRlbXMmJnRoaXMuYWRkU2VwYXJhdG9yKGQsITApLGQud2lsbEFkZFNlcGFyYXRvcj0hMSk7ZC5jb250YWluc0l0ZW1zPSEwO3ZhciBsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRyIik7bC5jbGFzc05hbWU9Im14UG9wdXBNZW51SXRlbSI7dmFyIG09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKTttLmNsYXNzTmFtZT0ibXhQb3B1cE1lbnVJY29uIjtudWxsIT1iPyhlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImltZyIpLGUuc3JjPWIsbS5hcHBlbmRDaGlsZChlKSk6bnVsbCE9ZSYmKGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2IiksYi5jbGFzc05hbWU9ZSxtLmFwcGVuZENoaWxkKGIpKTtsLmFwcGVuZENoaWxkKG0pO3RoaXMubGFiZWxzJiYobT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpLAptLmNsYXNzTmFtZT0ibXhQb3B1cE1lbnVJdGVtIisobnVsbD09Znx8Zj8iIjoiIG14RGlzYWJsZWQiKSxteFV0aWxzLndyaXRlKG0sYSksbS5hbGlnbj0ibGVmdCIsbC5hcHBlbmRDaGlsZChtKSxhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRkIiksYS5jbGFzc05hbWU9Im14UG9wdXBNZW51SXRlbSIrKG51bGw9PWZ8fGY/IiI6IiBteERpc2FibGVkIiksYS5zdHlsZS5wYWRkaW5nUmlnaHQ9IjZweCIsYS5zdHlsZS50ZXh0QWxpZ249InJpZ2h0IixsLmFwcGVuZENoaWxkKGEpLG51bGw9PWQuZGl2JiZ0aGlzLmNyZWF0ZVN1Ym1lbnUoZCkpO2QudGJvZHkuYXBwZW5kQ2hpbGQobCk7aWYoMCE9ZyYmMCE9Zil7dmFyIG49bnVsbDtteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnMobCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmV2ZW50UmVjZWl2ZXI9bDtkLmFjdGl2ZVJvdyE9bCYmZC5hY3RpdmVSb3chPWQmJihudWxsIT1kLmFjdGl2ZVJvdyYmbnVsbCE9ZC5hY3RpdmVSb3cuZGl2LnBhcmVudE5vZGUmJgp0aGlzLmhpZGVTdWJtZW51KGQpLG51bGwhPWwuZGl2JiYodGhpcy5zaG93U3VibWVudShkLGwpLGQuYWN0aXZlUm93PWwpKTtudWxsPT1kb2N1bWVudC5zZWxlY3Rpb258fCFteENsaWVudC5JU19RVUlSS1MmJjghPWRvY3VtZW50LmRvY3VtZW50TW9kZXx8KG49ZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkpO214RXZlbnQuY29uc3VtZShhKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2QuYWN0aXZlUm93IT1sJiZkLmFjdGl2ZVJvdyE9ZCYmKG51bGwhPWQuYWN0aXZlUm93JiZudWxsIT1kLmFjdGl2ZVJvdy5kaXYucGFyZW50Tm9kZSYmdGhpcy5oaWRlU3VibWVudShkKSx0aGlzLmF1dG9FeHBhbmQmJm51bGwhPWwuZGl2JiYodGhpcy5zaG93U3VibWVudShkLGwpLGQuYWN0aXZlUm93PWwpKTtrfHwobC5jbGFzc05hbWU9Im14UG9wdXBNZW51SXRlbUhvdmVyIil9KSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtpZih0aGlzLmV2ZW50UmVjZWl2ZXI9PQpsKXtkLmFjdGl2ZVJvdyE9bCYmdGhpcy5oaWRlTWVudSgpO2lmKG51bGwhPW4pe3RyeXtuLnNlbGVjdCgpfWNhdGNoKHEpe31uPW51bGx9bnVsbCE9YyYmYyhhKX10aGlzLmV2ZW50UmVjZWl2ZXI9bnVsbDtteEV2ZW50LmNvbnN1bWUoYSl9KSk7a3x8bXhFdmVudC5hZGRMaXN0ZW5lcihsLCJtb3VzZW91dCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bC5jbGFzc05hbWU9Im14UG9wdXBNZW51SXRlbSJ9KSl9cmV0dXJuIGx9O214UG9wdXBNZW51LnByb3RvdHlwZS5hZGRDaGVja21hcms9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmZpcnN0Q2hpbGQubmV4dFNpYmxpbmc7Yy5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2U9InVybCgnIitiKyInKSI7Yy5zdHlsZS5iYWNrZ3JvdW5kUmVwZWF0PSJuby1yZXBlYXQiO2Muc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uPSIycHggNTAlIn07Cm14UG9wdXBNZW51LnByb3RvdHlwZS5jcmVhdGVTdWJtZW51PWZ1bmN0aW9uKGEpe2EudGFibGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGFibGUiKTthLnRhYmxlLmNsYXNzTmFtZT0ibXhQb3B1cE1lbnUiO2EudGJvZHk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGJvZHkiKTthLnRhYmxlLmFwcGVuZENoaWxkKGEudGJvZHkpO2EuZGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2EuZGl2LmNsYXNzTmFtZT0ibXhQb3B1cE1lbnUiO2EuZGl2LnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7YS5kaXYuc3R5bGUuZGlzcGxheT0iaW5saW5lIjthLmRpdi5zdHlsZS56SW5kZXg9dGhpcy56SW5kZXg7YS5kaXYuYXBwZW5kQ2hpbGQoYS50YWJsZSk7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIik7Yi5zZXRBdHRyaWJ1dGUoInNyYyIsdGhpcy5zdWJtZW51SW1hZ2UpO3RkPWEuZmlyc3RDaGlsZC5uZXh0U2libGluZy5uZXh0U2libGluZzt0ZC5hcHBlbmRDaGlsZChiKX07Cm14UG9wdXBNZW51LnByb3RvdHlwZS5zaG93U3VibWVudT1mdW5jdGlvbihhLGIpe2lmKG51bGwhPWIuZGl2KXtiLmRpdi5zdHlsZS5sZWZ0PWEuZGl2Lm9mZnNldExlZnQrYi5vZmZzZXRMZWZ0K2Iub2Zmc2V0V2lkdGgtMSsicHgiO2IuZGl2LnN0eWxlLnRvcD1hLmRpdi5vZmZzZXRUb3ArYi5vZmZzZXRUb3ArInB4Ijtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGIuZGl2KTt2YXIgYz1wYXJzZUludChiLmRpdi5vZmZzZXRMZWZ0KSxkPXBhcnNlSW50KGIuZGl2Lm9mZnNldFdpZHRoKSxlPW14VXRpbHMuZ2V0RG9jdW1lbnRTY3JvbGxPcmlnaW4oZG9jdW1lbnQpLGY9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O2MrZD5lLngrKGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGh8fGYuY2xpZW50V2lkdGgpJiYoYi5kaXYuc3R5bGUubGVmdD1NYXRoLm1heCgwLGEuZGl2Lm9mZnNldExlZnQtZCsobXhDbGllbnQuSVNfSUU/NjotNikpKyJweCIpO214VXRpbHMuZml0KGIuZGl2KX19OwpteFBvcHVwTWVudS5wcm90b3R5cGUuYWRkU2VwYXJhdG9yPWZ1bmN0aW9uKGEsYil7YT1hfHx0aGlzO2lmKHRoaXMuc21hcnRTZXBhcmF0b3JzJiYhYilhLndpbGxBZGRTZXBhcmF0b3I9ITA7ZWxzZSBpZihudWxsIT1hLnRib2R5KXthLndpbGxBZGRTZXBhcmF0b3I9ITE7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidHIiKSxkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRkIik7ZC5jbGFzc05hbWU9Im14UG9wdXBNZW51SWNvbiI7ZC5zdHlsZS5wYWRkaW5nPSIwIDAgMCAwcHgiO2MuYXBwZW5kQ2hpbGQoZCk7ZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpO2Quc3R5bGUucGFkZGluZz0iMCAwIDAgMHB4IjtkLnNldEF0dHJpYnV0ZSgiY29sU3BhbiIsIjIiKTt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJociIpO2Uuc2V0QXR0cmlidXRlKCJzaXplIiwiMSIpO2QuYXBwZW5kQ2hpbGQoZSk7Yy5hcHBlbmRDaGlsZChkKTthLnRib2R5LmFwcGVuZENoaWxkKGMpfX07Cm14UG9wdXBNZW51LnByb3RvdHlwZS5wb3B1cD1mdW5jdGlvbihhLGIsYyxkKXtpZihudWxsIT10aGlzLmRpdiYmbnVsbCE9dGhpcy50Ym9keSYmbnVsbCE9dGhpcy5mYWN0b3J5TWV0aG9kKXt0aGlzLmRpdi5zdHlsZS5sZWZ0PWErInB4Ijtmb3IodGhpcy5kaXYuc3R5bGUudG9wPWIrInB4IjtudWxsIT10aGlzLnRib2R5LmZpcnN0Q2hpbGQ7KW14RXZlbnQucmVsZWFzZSh0aGlzLnRib2R5LmZpcnN0Q2hpbGQpLHRoaXMudGJvZHkucmVtb3ZlQ2hpbGQodGhpcy50Ym9keS5maXJzdENoaWxkKTt0aGlzLml0ZW1Db3VudD0wO3RoaXMuZmFjdG9yeU1ldGhvZCh0aGlzLGMsZCk7MDx0aGlzLml0ZW1Db3VudCYmKHRoaXMuc2hvd01lbnUoKSx0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlNIT1cpKSl9fTsKbXhQb3B1cE1lbnUucHJvdG90eXBlLmlzTWVudVNob3dpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5kaXYmJnRoaXMuZGl2LnBhcmVudE5vZGU9PWRvY3VtZW50LmJvZHl9O214UG9wdXBNZW51LnByb3RvdHlwZS5zaG93TWVudT1mdW5jdGlvbigpezk8PWRvY3VtZW50LmRvY3VtZW50TW9kZSYmKHRoaXMuZGl2LnN0eWxlLmZpbHRlcj0ibm9uZSIpO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5kaXYpO214VXRpbHMuZml0KHRoaXMuZGl2KX07bXhQb3B1cE1lbnUucHJvdG90eXBlLmhpZGVNZW51PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5kaXYmJihudWxsIT10aGlzLmRpdi5wYXJlbnROb2RlJiZ0aGlzLmRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZGl2KSx0aGlzLmhpZGVTdWJtZW51KHRoaXMpLHRoaXMuY29udGFpbnNJdGVtcz0hMSx0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkhJREUpKSl9OwpteFBvcHVwTWVudS5wcm90b3R5cGUuaGlkZVN1Ym1lbnU9ZnVuY3Rpb24oYSl7bnVsbCE9YS5hY3RpdmVSb3cmJih0aGlzLmhpZGVTdWJtZW51KGEuYWN0aXZlUm93KSxudWxsIT1hLmFjdGl2ZVJvdy5kaXYucGFyZW50Tm9kZSYmYS5hY3RpdmVSb3cuZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYS5hY3RpdmVSb3cuZGl2KSxhLmFjdGl2ZVJvdz1udWxsKX07bXhQb3B1cE1lbnUucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmRpdiYmKG14RXZlbnQucmVsZWFzZSh0aGlzLmRpdiksbnVsbCE9dGhpcy5kaXYucGFyZW50Tm9kZSYmdGhpcy5kaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRpdiksdGhpcy5kaXY9bnVsbCl9OwpmdW5jdGlvbiBteEF1dG9TYXZlTWFuYWdlcihhKXt0aGlzLmNoYW5nZUhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXt0aGlzLmlzRW5hYmxlZCgpJiZ0aGlzLmdyYXBoTW9kZWxDaGFuZ2VkKGMuZ2V0UHJvcGVydHkoImVkaXQiKS5jaGFuZ2VzKX0pO3RoaXMuc2V0R3JhcGgoYSl9bXhBdXRvU2F2ZU1hbmFnZXIucHJvdG90eXBlPW5ldyBteEV2ZW50U291cmNlO214QXV0b1NhdmVNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1teEF1dG9TYXZlTWFuYWdlcjtteEF1dG9TYXZlTWFuYWdlci5wcm90b3R5cGUuZ3JhcGg9bnVsbDtteEF1dG9TYXZlTWFuYWdlci5wcm90b3R5cGUuYXV0b1NhdmVEZWxheT0xMDtteEF1dG9TYXZlTWFuYWdlci5wcm90b3R5cGUuYXV0b1NhdmVUaHJvdHRsZT0yO214QXV0b1NhdmVNYW5hZ2VyLnByb3RvdHlwZS5hdXRvU2F2ZVRocmVzaG9sZD01O214QXV0b1NhdmVNYW5hZ2VyLnByb3RvdHlwZS5pZ25vcmVkQ2hhbmdlcz0wOwpteEF1dG9TYXZlTWFuYWdlci5wcm90b3R5cGUubGFzdFNuYXBzaG90PTA7bXhBdXRvU2F2ZU1hbmFnZXIucHJvdG90eXBlLmVuYWJsZWQ9ITA7bXhBdXRvU2F2ZU1hbmFnZXIucHJvdG90eXBlLmNoYW5nZUhhbmRsZXI9bnVsbDtteEF1dG9TYXZlTWFuYWdlci5wcm90b3R5cGUuaXNFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5hYmxlZH07bXhBdXRvU2F2ZU1hbmFnZXIucHJvdG90eXBlLnNldEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5lbmFibGVkPWF9O214QXV0b1NhdmVNYW5hZ2VyLnByb3RvdHlwZS5zZXRHcmFwaD1mdW5jdGlvbihhKXtudWxsIT10aGlzLmdyYXBoJiZ0aGlzLmdyYXBoLmdldE1vZGVsKCkucmVtb3ZlTGlzdGVuZXIodGhpcy5jaGFuZ2VIYW5kbGVyKTt0aGlzLmdyYXBoPWE7bnVsbCE9dGhpcy5ncmFwaCYmdGhpcy5ncmFwaC5nZXRNb2RlbCgpLmFkZExpc3RlbmVyKG14RXZlbnQuQ0hBTkdFLHRoaXMuY2hhbmdlSGFuZGxlcil9OwpteEF1dG9TYXZlTWFuYWdlci5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbigpe307bXhBdXRvU2F2ZU1hbmFnZXIucHJvdG90eXBlLmdyYXBoTW9kZWxDaGFuZ2VkPWZ1bmN0aW9uKGEpe2E9KChuZXcgRGF0ZSkuZ2V0VGltZSgpLXRoaXMubGFzdFNuYXBzaG90KS8xRTM7YT50aGlzLmF1dG9TYXZlRGVsYXl8fHRoaXMuaWdub3JlZENoYW5nZXM+PXRoaXMuYXV0b1NhdmVUaHJlc2hvbGQmJmE+dGhpcy5hdXRvU2F2ZVRocm90dGxlPyh0aGlzLnNhdmUoKSx0aGlzLnJlc2V0KCkpOnRoaXMuaWdub3JlZENoYW5nZXMrK307bXhBdXRvU2F2ZU1hbmFnZXIucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5sYXN0U25hcHNob3Q9KG5ldyBEYXRlKS5nZXRUaW1lKCk7dGhpcy5pZ25vcmVkQ2hhbmdlcz0wfTtteEF1dG9TYXZlTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuc2V0R3JhcGgobnVsbCl9OwpmdW5jdGlvbiBteEFuaW1hdGlvbihhKXt0aGlzLmRlbGF5PW51bGwhPWE/YToyMH1teEFuaW1hdGlvbi5wcm90b3R5cGU9bmV3IG14RXZlbnRTb3VyY2U7bXhBbmltYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14QW5pbWF0aW9uO214QW5pbWF0aW9uLnByb3RvdHlwZS5kZWxheT1udWxsO214QW5pbWF0aW9uLnByb3RvdHlwZS50aHJlYWQ9bnVsbDtteEFuaW1hdGlvbi5wcm90b3R5cGUuaXNSdW5uaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMudGhyZWFkfTtteEFuaW1hdGlvbi5wcm90b3R5cGUuc3RhcnRBbmltYXRpb249ZnVuY3Rpb24oKXtudWxsPT10aGlzLnRocmVhZCYmKHRoaXMudGhyZWFkPXdpbmRvdy5zZXRJbnRlcnZhbChteFV0aWxzLmJpbmQodGhpcyx0aGlzLnVwZGF0ZUFuaW1hdGlvbiksdGhpcy5kZWxheSkpfTtteEFuaW1hdGlvbi5wcm90b3R5cGUudXBkYXRlQW5pbWF0aW9uPWZ1bmN0aW9uKCl7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5FWEVDVVRFKSl9OwpteEFuaW1hdGlvbi5wcm90b3R5cGUuc3RvcEFuaW1hdGlvbj1mdW5jdGlvbigpe251bGwhPXRoaXMudGhyZWFkJiYod2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy50aHJlYWQpLHRoaXMudGhyZWFkPW51bGwsdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5ET05FKSkpfTtmdW5jdGlvbiBteE1vcnBoaW5nKGEsYixjLGQpe214QW5pbWF0aW9uLmNhbGwodGhpcyxkKTt0aGlzLmdyYXBoPWE7dGhpcy5zdGVwcz1udWxsIT1iP2I6Njt0aGlzLmVhc2U9bnVsbCE9Yz9jOjEuNX1teE1vcnBoaW5nLnByb3RvdHlwZT1uZXcgbXhBbmltYXRpb247bXhNb3JwaGluZy5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhNb3JwaGluZztteE1vcnBoaW5nLnByb3RvdHlwZS5ncmFwaD1udWxsO214TW9ycGhpbmcucHJvdG90eXBlLnN0ZXBzPW51bGw7bXhNb3JwaGluZy5wcm90b3R5cGUuc3RlcD0wO214TW9ycGhpbmcucHJvdG90eXBlLmVhc2U9bnVsbDsKbXhNb3JwaGluZy5wcm90b3R5cGUuY2VsbHM9bnVsbDtteE1vcnBoaW5nLnByb3RvdHlwZS51cGRhdGVBbmltYXRpb249ZnVuY3Rpb24oKXtteEFuaW1hdGlvbi5wcm90b3R5cGUudXBkYXRlQW5pbWF0aW9uLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgYT1uZXcgbXhDZWxsU3RhdGVQcmV2aWV3KHRoaXMuZ3JhcGgpO2lmKG51bGwhPXRoaXMuY2VsbHMpZm9yKHZhciBiPTA7Yjx0aGlzLmNlbGxzLmxlbmd0aDtiKyspdGhpcy5hbmltYXRlQ2VsbCh0aGlzLmNlbGxzW2JdLGEsITEpO2Vsc2UgdGhpcy5hbmltYXRlQ2VsbCh0aGlzLmdyYXBoLmdldE1vZGVsKCkuZ2V0Um9vdCgpLGEsITApO3RoaXMuc2hvdyhhKTsoYS5pc0VtcHR5KCl8fHRoaXMuc3RlcCsrPj10aGlzLnN0ZXBzKSYmdGhpcy5zdG9wQW5pbWF0aW9uKCl9O214TW9ycGhpbmcucHJvdG90eXBlLnNob3c9ZnVuY3Rpb24oYSl7YS5zaG93KCl9OwpteE1vcnBoaW5nLnByb3RvdHlwZS5hbmltYXRlQ2VsbD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0U3RhdGUoYSksZT1udWxsO2lmKG51bGwhPWQmJihlPXRoaXMuZ2V0RGVsdGEoZCksdGhpcy5ncmFwaC5nZXRNb2RlbCgpLmlzVmVydGV4KGEpJiYoMCE9ZS54fHwwIT1lLnkpKSl7dmFyIGY9dGhpcy5ncmFwaC52aWV3LmdldFRyYW5zbGF0ZSgpLGc9dGhpcy5ncmFwaC52aWV3LmdldFNjYWxlKCk7ZS54Kz1mLngqZztlLnkrPWYueSpnO2IubW92ZVN0YXRlKGQsLWUueC90aGlzLmVhc2UsLWUueS90aGlzLmVhc2UpfWlmKGMmJiF0aGlzLnN0b3BSZWN1cnNpb24oZCxlKSlmb3IoZD10aGlzLmdyYXBoLmdldE1vZGVsKCkuZ2V0Q2hpbGRDb3VudChhKSxlPTA7ZTxkO2UrKyl0aGlzLmFuaW1hdGVDZWxsKHRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5nZXRDaGlsZEF0KGEsZSksYixjKX07Cm14TW9ycGhpbmcucHJvdG90eXBlLnN0b3BSZWN1cnNpb249ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbnVsbCE9YiYmKDAhPWIueHx8MCE9Yi55KX07bXhNb3JwaGluZy5wcm90b3R5cGUuZ2V0RGVsdGE9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5nZXRPcmlnaW5Gb3JDZWxsKGEuY2VsbCksYz10aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRUcmFuc2xhdGUoKSxkPXRoaXMuZ3JhcGguZ2V0VmlldygpLmdldFNjYWxlKCk7cmV0dXJuIG5ldyBteFBvaW50KChiLngtKGEueC9kLWMueCkpKmQsKGIueS0oYS55L2QtYy55KSkqZCl9OwpteE1vcnBoaW5nLnByb3RvdHlwZS5nZXRPcmlnaW5Gb3JDZWxsPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7aWYobnVsbCE9YSl7dmFyIGM9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldFBhcmVudChhKTthPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGEpO2I9dGhpcy5nZXRPcmlnaW5Gb3JDZWxsKGMpO251bGwhPWEmJihhLnJlbGF0aXZlPyhjPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGMpLG51bGwhPWMmJihiLngrPWEueCpjLndpZHRoLGIueSs9YS55KmMuaGVpZ2h0KSk6KGIueCs9YS54LGIueSs9YS55KSl9bnVsbD09YiYmKGI9dGhpcy5ncmFwaC52aWV3LmdldFRyYW5zbGF0ZSgpLGI9bmV3IG14UG9pbnQoLWIueCwtYi55KSk7cmV0dXJuIGJ9O2Z1bmN0aW9uIG14SW1hZ2VCdW5kbGUoYSl7dGhpcy5pbWFnZXM9W107dGhpcy5hbHQ9bnVsbCE9YT9hOiExfW14SW1hZ2VCdW5kbGUucHJvdG90eXBlLmltYWdlcz1udWxsOwpteEltYWdlQnVuZGxlLnByb3RvdHlwZS5hbHQ9bnVsbDtteEltYWdlQnVuZGxlLnByb3RvdHlwZS5wdXRJbWFnZT1mdW5jdGlvbihhLGIsYyl7dGhpcy5pbWFnZXNbYV09e3ZhbHVlOmIsZmFsbGJhY2s6Y319O214SW1hZ2VCdW5kbGUucHJvdG90eXBlLmdldEltYWdlPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7bnVsbCE9YSYmKGE9dGhpcy5pbWFnZXNbYV0sbnVsbCE9YSYmKGI9dGhpcy5hbHQ/YS5mYWxsYmFjazphLnZhbHVlKSk7cmV0dXJuIGJ9O2Z1bmN0aW9uIG14SW1hZ2VFeHBvcnQoKXt9bXhJbWFnZUV4cG9ydC5wcm90b3R5cGUuaW5jbHVkZU92ZXJsYXlzPSExOwpteEltYWdlRXhwb3J0LnByb3RvdHlwZS5kcmF3U3RhdGU9ZnVuY3Rpb24oYSxiKXtudWxsIT1hJiYodGhpcy52aXNpdFN0YXRlc1JlY3Vyc2l2ZShhLGIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmRyYXdDZWxsU3RhdGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfSkpLHRoaXMuaW5jbHVkZU92ZXJsYXlzJiZ0aGlzLnZpc2l0U3RhdGVzUmVjdXJzaXZlKGEsYixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuZHJhd092ZXJsYXlzLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pKSl9OwpteEltYWdlRXhwb3J0LnByb3RvdHlwZS52aXNpdFN0YXRlc1JlY3Vyc2l2ZT1mdW5jdGlvbihhLGIsYyl7aWYobnVsbCE9YSl7YyhhLGIpO2Zvcih2YXIgZD1hLnZpZXcuZ3JhcGgsZT1kLm1vZGVsLmdldENoaWxkQ291bnQoYS5jZWxsKSxmPTA7ZjxlO2YrKyl7dmFyIGc9ZC52aWV3LmdldFN0YXRlKGQubW9kZWwuZ2V0Q2hpbGRBdChhLmNlbGwsZikpO3RoaXMudmlzaXRTdGF0ZXNSZWN1cnNpdmUoZyxiLGMpfX19O214SW1hZ2VFeHBvcnQucHJvdG90eXBlLmdldExpbmtGb3JDZWxsU3RhdGU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbnVsbH07bXhJbWFnZUV4cG9ydC5wcm90b3R5cGUuZHJhd0NlbGxTdGF0ZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ2V0TGlua0ZvckNlbGxTdGF0ZShhLGIpO251bGwhPWMmJmIuc2V0TGluayhjKTt0aGlzLmRyYXdTaGFwZShhLGIpO3RoaXMuZHJhd1RleHQoYSxiKTtudWxsIT1jJiZiLnNldExpbmsobnVsbCl9OwpteEltYWdlRXhwb3J0LnByb3RvdHlwZS5kcmF3U2hhcGU9ZnVuY3Rpb24oYSxiKXthLnNoYXBlIGluc3RhbmNlb2YgbXhTaGFwZSYmYS5zaGFwZS5jaGVja0JvdW5kcygpJiYoYi5zYXZlKCksYS5zaGFwZS5wYWludChiKSxiLnJlc3RvcmUoKSl9O214SW1hZ2VFeHBvcnQucHJvdG90eXBlLmRyYXdUZXh0PWZ1bmN0aW9uKGEsYil7bnVsbCE9YS50ZXh0JiZhLnRleHQuY2hlY2tCb3VuZHMoKSYmKGIuc2F2ZSgpLGEudGV4dC5wYWludChiKSxiLnJlc3RvcmUoKSl9O214SW1hZ2VFeHBvcnQucHJvdG90eXBlLmRyYXdPdmVybGF5cz1mdW5jdGlvbihhLGIpe251bGwhPWEub3ZlcmxheXMmJmEub3ZlcmxheXMudmlzaXQoZnVuY3Rpb24oYSxkKXtkIGluc3RhbmNlb2YgbXhTaGFwZSYmZC5wYWludChiKX0pfTtmdW5jdGlvbiBteEFic3RyYWN0Q2FudmFzMkQoKXt0aGlzLmNvbnZlcnRlcj10aGlzLmNyZWF0ZVVybENvbnZlcnRlcigpO3RoaXMucmVzZXQoKX0KbXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zdGF0ZT1udWxsO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc3RhdGVzPW51bGw7bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5wYXRoPW51bGw7bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5yb3RhdGVIdG1sPSEwO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUubGFzdFg9MDtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLmxhc3RZPTA7bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5tb3ZlT3A9Ik0iO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUubGluZU9wPSJMIjtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnF1YWRPcD0iUSI7bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5jdXJ2ZU9wPSJDIjtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLmNsb3NlT3A9IloiO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUucG9pbnRlckV2ZW50cz0hMTsKbXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5jcmVhdGVVcmxDb252ZXJ0ZXI9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG14VXJsQ29udmVydGVyfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5zdGF0ZT10aGlzLmNyZWF0ZVN0YXRlKCk7dGhpcy5zdGF0ZXM9W119OwpteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLmNyZWF0ZVN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJue2R4OjAsZHk6MCxzY2FsZToxLGFscGhhOjEsZmlsbEFscGhhOjEsc3Ryb2tlQWxwaGE6MSxmaWxsQ29sb3I6bnVsbCxncmFkaWVudEZpbGxBbHBoYToxLGdyYWRpZW50Q29sb3I6bnVsbCxncmFkaWVudEFscGhhOjEsZ3JhZGllbnREaXJlY3Rpb246bnVsbCxzdHJva2VDb2xvcjpudWxsLHN0cm9rZVdpZHRoOjEsZGFzaGVkOiExLGRhc2hQYXR0ZXJuOiIzIDMiLGZpeERhc2g6ITEsbGluZUNhcDoiZmxhdCIsbGluZUpvaW46Im1pdGVyIixtaXRlckxpbWl0OjEwLGZvbnRDb2xvcjoiIzAwMDAwMCIsZm9udEJhY2tncm91bmRDb2xvcjpudWxsLGZvbnRCb3JkZXJDb2xvcjpudWxsLGZvbnRTaXplOm14Q29uc3RhbnRzLkRFRkFVTFRfRk9OVFNJWkUsZm9udEZhbWlseTpteENvbnN0YW50cy5ERUZBVUxUX0ZPTlRGQU1JTFksZm9udFN0eWxlOjAsc2hhZG93OiExLHNoYWRvd0NvbG9yOm14Q29uc3RhbnRzLlNIQURPV0NPTE9SLApzaGFkb3dBbHBoYTpteENvbnN0YW50cy5TSEFET1dfT1BBQ0lUWSxzaGFkb3dEeDpteENvbnN0YW50cy5TSEFET1dfT0ZGU0VUX1gsc2hhZG93RHk6bXhDb25zdGFudHMuU0hBRE9XX09GRlNFVF9ZLHJvdGF0aW9uOjAscm90YXRpb25DeDowLHJvdGF0aW9uQ3k6MH19O214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuZm9ybWF0PWZ1bmN0aW9uKGEpe3JldHVybiBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoYSkpfTsKbXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5hZGRPcD1mdW5jdGlvbigpe2lmKG51bGwhPXRoaXMucGF0aCYmKHRoaXMucGF0aC5wdXNoKGFyZ3VtZW50c1swXSksMjxhcmd1bWVudHMubGVuZ3RoKSlmb3IodmFyIGE9dGhpcy5zdGF0ZSxiPTI7Yjxhcmd1bWVudHMubGVuZ3RoO2IrPTIpdGhpcy5sYXN0WD1hcmd1bWVudHNbYi0xXSx0aGlzLmxhc3RZPWFyZ3VtZW50c1tiXSx0aGlzLnBhdGgucHVzaCh0aGlzLmZvcm1hdCgodGhpcy5sYXN0WCthLmR4KSphLnNjYWxlKSksdGhpcy5wYXRoLnB1c2godGhpcy5mb3JtYXQoKHRoaXMubGFzdFkrYS5keSkqYS5zY2FsZSkpfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnJvdGF0ZVBvaW50PWZ1bmN0aW9uKGEsYixjLGQsZSl7Yyo9TWF0aC5QSS8xODA7cmV0dXJuIG14VXRpbHMuZ2V0Um90YXRlZFBvaW50KG5ldyBteFBvaW50KGEsYiksTWF0aC5jb3MoYyksTWF0aC5zaW4oYyksbmV3IG14UG9pbnQoZCxlKSl9OwpteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24oKXt0aGlzLnN0YXRlcy5wdXNoKHRoaXMuc3RhdGUpO3RoaXMuc3RhdGU9bXhVdGlscy5jbG9uZSh0aGlzLnN0YXRlKX07bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5yZXN0b3JlPWZ1bmN0aW9uKCl7MDx0aGlzLnN0YXRlcy5sZW5ndGgmJih0aGlzLnN0YXRlPXRoaXMuc3RhdGVzLnBvcCgpKX07bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRMaW5rPWZ1bmN0aW9uKGEpe307bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zY2FsZT1mdW5jdGlvbihhKXt0aGlzLnN0YXRlLnNjYWxlKj1hO3RoaXMuc3RhdGUuc3Ryb2tlV2lkdGgqPWF9O214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUudHJhbnNsYXRlPWZ1bmN0aW9uKGEsYil7dGhpcy5zdGF0ZS5keCs9YTt0aGlzLnN0YXRlLmR5Kz1ifTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnJvdGF0ZT1mdW5jdGlvbihhLGIsYyxkLGUpe307Cm14QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0QWxwaGE9ZnVuY3Rpb24oYSl7dGhpcy5zdGF0ZS5hbHBoYT1hfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldEZpbGxBbHBoYT1mdW5jdGlvbihhKXt0aGlzLnN0YXRlLmZpbGxBbHBoYT1hfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldFN0cm9rZUFscGhhPWZ1bmN0aW9uKGEpe3RoaXMuc3RhdGUuc3Ryb2tlQWxwaGE9YX07bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRGaWxsQ29sb3I9ZnVuY3Rpb24oYSl7YT09bXhDb25zdGFudHMuTk9ORSYmKGE9bnVsbCk7dGhpcy5zdGF0ZS5maWxsQ29sb3I9YTt0aGlzLnN0YXRlLmdyYWRpZW50Q29sb3I9bnVsbH07Cm14QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0R3JhZGllbnQ9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxrLGwpe2M9dGhpcy5zdGF0ZTtjLmZpbGxDb2xvcj1hO2MuZ3JhZGllbnRGaWxsQWxwaGE9bnVsbCE9az9rOjE7Yy5ncmFkaWVudENvbG9yPWI7Yy5ncmFkaWVudEFscGhhPW51bGwhPWw/bDoxO2MuZ3JhZGllbnREaXJlY3Rpb249Z307bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRTdHJva2VDb2xvcj1mdW5jdGlvbihhKXthPT1teENvbnN0YW50cy5OT05FJiYoYT1udWxsKTt0aGlzLnN0YXRlLnN0cm9rZUNvbG9yPWF9O214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0U3Ryb2tlV2lkdGg9ZnVuY3Rpb24oYSl7dGhpcy5zdGF0ZS5zdHJva2VXaWR0aD1hfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldERhc2hlZD1mdW5jdGlvbihhLGIpe3RoaXMuc3RhdGUuZGFzaGVkPWE7dGhpcy5zdGF0ZS5maXhEYXNoPWJ9OwpteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldERhc2hQYXR0ZXJuPWZ1bmN0aW9uKGEpe3RoaXMuc3RhdGUuZGFzaFBhdHRlcm49YX07bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRMaW5lQ2FwPWZ1bmN0aW9uKGEpe3RoaXMuc3RhdGUubGluZUNhcD1hfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldExpbmVKb2luPWZ1bmN0aW9uKGEpe3RoaXMuc3RhdGUubGluZUpvaW49YX07bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRNaXRlckxpbWl0PWZ1bmN0aW9uKGEpe3RoaXMuc3RhdGUubWl0ZXJMaW1pdD1hfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldEZvbnRDb2xvcj1mdW5jdGlvbihhKXthPT1teENvbnN0YW50cy5OT05FJiYoYT1udWxsKTt0aGlzLnN0YXRlLmZvbnRDb2xvcj1hfTsKbXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRGb250QmFja2dyb3VuZENvbG9yPWZ1bmN0aW9uKGEpe2E9PW14Q29uc3RhbnRzLk5PTkUmJihhPW51bGwpO3RoaXMuc3RhdGUuZm9udEJhY2tncm91bmRDb2xvcj1hfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldEZvbnRCb3JkZXJDb2xvcj1mdW5jdGlvbihhKXthPT1teENvbnN0YW50cy5OT05FJiYoYT1udWxsKTt0aGlzLnN0YXRlLmZvbnRCb3JkZXJDb2xvcj1hfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldEZvbnRTaXplPWZ1bmN0aW9uKGEpe3RoaXMuc3RhdGUuZm9udFNpemU9cGFyc2VGbG9hdChhKX07bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRGb250RmFtaWx5PWZ1bmN0aW9uKGEpe3RoaXMuc3RhdGUuZm9udEZhbWlseT1hfTsKbXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRGb250U3R5bGU9ZnVuY3Rpb24oYSl7bnVsbD09YSYmKGE9MCk7dGhpcy5zdGF0ZS5mb250U3R5bGU9YX07bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRTaGFkb3c9ZnVuY3Rpb24oYSl7dGhpcy5zdGF0ZS5zaGFkb3c9YX07bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRTaGFkb3dDb2xvcj1mdW5jdGlvbihhKXthPT1teENvbnN0YW50cy5OT05FJiYoYT1udWxsKTt0aGlzLnN0YXRlLnNoYWRvd0NvbG9yPWF9O214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0U2hhZG93QWxwaGE9ZnVuY3Rpb24oYSl7dGhpcy5zdGF0ZS5zaGFkb3dBbHBoYT1hfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldFNoYWRvd09mZnNldD1mdW5jdGlvbihhLGIpe3RoaXMuc3RhdGUuc2hhZG93RHg9YTt0aGlzLnN0YXRlLnNoYWRvd0R5PWJ9OwpteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLmJlZ2luPWZ1bmN0aW9uKCl7dGhpcy5sYXN0WT10aGlzLmxhc3RYPTA7dGhpcy5wYXRoPVtdfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLm1vdmVUbz1mdW5jdGlvbihhLGIpe3RoaXMuYWRkT3AodGhpcy5tb3ZlT3AsYSxiKX07bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5saW5lVG89ZnVuY3Rpb24oYSxiKXt0aGlzLmFkZE9wKHRoaXMubGluZU9wLGEsYil9O214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUucXVhZFRvPWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMuYWRkT3AodGhpcy5xdWFkT3AsYSxiLGMsZCl9O214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuY3VydmVUbz1mdW5jdGlvbihhLGIsYyxkLGUsZil7dGhpcy5hZGRPcCh0aGlzLmN1cnZlT3AsYSxiLGMsZCxlLGYpfTsKbXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5hcmNUbz1mdW5jdGlvbihhLGIsYyxkLGUsZixnKXthPW14VXRpbHMuYXJjVG9DdXJ2ZXModGhpcy5sYXN0WCx0aGlzLmxhc3RZLGEsYixjLGQsZSxmLGcpO2lmKG51bGwhPWEpZm9yKGI9MDtiPGEubGVuZ3RoO2IrPTYpdGhpcy5jdXJ2ZVRvKGFbYl0sYVtiKzFdLGFbYisyXSxhW2IrM10sYVtiKzRdLGFbYis1XSl9O214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuY2xvc2U9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3RoaXMuYWRkT3AodGhpcy5jbG9zZU9wKX07bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5lbmQ9ZnVuY3Rpb24oKXt9O2Z1bmN0aW9uIG14WG1sQ2FudmFzMkQoYSl7bXhBYnN0cmFjdENhbnZhczJELmNhbGwodGhpcyk7dGhpcy5yb290PWE7dGhpcy53cml0ZURlZmF1bHRzKCl9bXhVdGlscy5leHRlbmQobXhYbWxDYW52YXMyRCxteEFic3RyYWN0Q2FudmFzMkQpOwpteFhtbENhbnZhczJELnByb3RvdHlwZS50ZXh0RW5hYmxlZD0hMDtteFhtbENhbnZhczJELnByb3RvdHlwZS5jb21wcmVzc2VkPSEwOwpteFhtbENhbnZhczJELnByb3RvdHlwZS53cml0ZURlZmF1bHRzPWZ1bmN0aW9uKCl7dmFyIGE7YT10aGlzLmNyZWF0ZUVsZW1lbnQoImZvbnRmYW1pbHkiKTthLnNldEF0dHJpYnV0ZSgiZmFtaWx5IixteENvbnN0YW50cy5ERUZBVUxUX0ZPTlRGQU1JTFkpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChhKTthPXRoaXMuY3JlYXRlRWxlbWVudCgiZm9udHNpemUiKTthLnNldEF0dHJpYnV0ZSgic2l6ZSIsbXhDb25zdGFudHMuREVGQVVMVF9GT05UU0laRSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGEpO2E9dGhpcy5jcmVhdGVFbGVtZW50KCJzaGFkb3djb2xvciIpO2Euc2V0QXR0cmlidXRlKCJjb2xvciIsbXhDb25zdGFudHMuU0hBRE9XQ09MT1IpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChhKTthPXRoaXMuY3JlYXRlRWxlbWVudCgic2hhZG93YWxwaGEiKTthLnNldEF0dHJpYnV0ZSgiYWxwaGEiLG14Q29uc3RhbnRzLlNIQURPV19PUEFDSVRZKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYSk7CmE9dGhpcy5jcmVhdGVFbGVtZW50KCJzaGFkb3dvZmZzZXQiKTthLnNldEF0dHJpYnV0ZSgiZHgiLG14Q29uc3RhbnRzLlNIQURPV19PRkZTRVRfWCk7YS5zZXRBdHRyaWJ1dGUoImR5IixteENvbnN0YW50cy5TSEFET1dfT0ZGU0VUX1kpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChhKX07bXhYbWxDYW52YXMyRC5wcm90b3R5cGUuZm9ybWF0PWZ1bmN0aW9uKGEpe3JldHVybiBwYXJzZUZsb2F0KHBhcnNlRmxvYXQoYSkudG9GaXhlZCgyKSl9O214WG1sQ2FudmFzMkQucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucm9vdC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoYSl9O214WG1sQ2FudmFzMkQucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24oKXt0aGlzLmNvbXByZXNzZWQmJm14QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2F2ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy5yb290LmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlRWxlbWVudCgic2F2ZSIpKX07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLnJlc3RvcmU9ZnVuY3Rpb24oKXt0aGlzLmNvbXByZXNzZWQmJm14QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUucmVzdG9yZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy5yb290LmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlRWxlbWVudCgicmVzdG9yZSIpKX07bXhYbWxDYW52YXMyRC5wcm90b3R5cGUuc2NhbGU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jcmVhdGVFbGVtZW50KCJzY2FsZSIpO2Iuc2V0QXR0cmlidXRlKCJzY2FsZSIsYSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGIpfTtteFhtbENhbnZhczJELnByb3RvdHlwZS50cmFuc2xhdGU9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmNyZWF0ZUVsZW1lbnQoInRyYW5zbGF0ZSIpO2Muc2V0QXR0cmlidXRlKCJkeCIsdGhpcy5mb3JtYXQoYSkpO2Muc2V0QXR0cmlidXRlKCJkeSIsdGhpcy5mb3JtYXQoYikpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChjKX07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLnJvdGF0ZT1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPXRoaXMuY3JlYXRlRWxlbWVudCgicm90YXRlIik7aWYoMCE9YXx8Ynx8YylmLnNldEF0dHJpYnV0ZSgidGhldGEiLHRoaXMuZm9ybWF0KGEpKSxmLnNldEF0dHJpYnV0ZSgiZmxpcEgiLGI/IjEiOiIwIiksZi5zZXRBdHRyaWJ1dGUoImZsaXBWIixjPyIxIjoiMCIpLGYuc2V0QXR0cmlidXRlKCJjeCIsdGhpcy5mb3JtYXQoZCkpLGYuc2V0QXR0cmlidXRlKCJjeSIsdGhpcy5mb3JtYXQoZSkpLHRoaXMucm9vdC5hcHBlbmRDaGlsZChmKX07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLnNldEFscGhhPWZ1bmN0aW9uKGEpe2lmKHRoaXMuY29tcHJlc3NlZCl7aWYodGhpcy5zdGF0ZS5hbHBoYT09YSlyZXR1cm47bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRBbHBoYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIGI9dGhpcy5jcmVhdGVFbGVtZW50KCJhbHBoYSIpO2Iuc2V0QXR0cmlidXRlKCJhbHBoYSIsdGhpcy5mb3JtYXQoYSkpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChiKX07bXhYbWxDYW52YXMyRC5wcm90b3R5cGUuc2V0RmlsbEFscGhhPWZ1bmN0aW9uKGEpe2lmKHRoaXMuY29tcHJlc3NlZCl7aWYodGhpcy5zdGF0ZS5maWxsQWxwaGE9PWEpcmV0dXJuO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0RmlsbEFscGhhLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgYj10aGlzLmNyZWF0ZUVsZW1lbnQoImZpbGxhbHBoYSIpO2Iuc2V0QXR0cmlidXRlKCJhbHBoYSIsdGhpcy5mb3JtYXQoYSkpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChiKX07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLnNldFN0cm9rZUFscGhhPWZ1bmN0aW9uKGEpe2lmKHRoaXMuY29tcHJlc3NlZCl7aWYodGhpcy5zdGF0ZS5zdHJva2VBbHBoYT09YSlyZXR1cm47bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRTdHJva2VBbHBoYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIGI9dGhpcy5jcmVhdGVFbGVtZW50KCJzdHJva2VhbHBoYSIpO2Iuc2V0QXR0cmlidXRlKCJhbHBoYSIsdGhpcy5mb3JtYXQoYSkpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChiKX07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLnNldEZpbGxDb2xvcj1mdW5jdGlvbihhKXthPT1teENvbnN0YW50cy5OT05FJiYoYT1udWxsKTtpZih0aGlzLmNvbXByZXNzZWQpe2lmKHRoaXMuc3RhdGUuZmlsbENvbG9yPT1hKXJldHVybjtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldEZpbGxDb2xvci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIGI9dGhpcy5jcmVhdGVFbGVtZW50KCJmaWxsY29sb3IiKTtiLnNldEF0dHJpYnV0ZSgiY29sb3IiLG51bGwhPWE/YTpteENvbnN0YW50cy5OT05FKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYil9OwpteFhtbENhbnZhczJELnByb3RvdHlwZS5zZXRHcmFkaWVudD1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGssbCl7aWYobnVsbCE9YSYmbnVsbCE9Yil7bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRHcmFkaWVudC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIG09dGhpcy5jcmVhdGVFbGVtZW50KCJncmFkaWVudCIpO20uc2V0QXR0cmlidXRlKCJjMSIsYSk7bS5zZXRBdHRyaWJ1dGUoImMyIixiKTttLnNldEF0dHJpYnV0ZSgieCIsdGhpcy5mb3JtYXQoYykpO20uc2V0QXR0cmlidXRlKCJ5Iix0aGlzLmZvcm1hdChkKSk7bS5zZXRBdHRyaWJ1dGUoInciLHRoaXMuZm9ybWF0KGUpKTttLnNldEF0dHJpYnV0ZSgiaCIsdGhpcy5mb3JtYXQoZikpO251bGwhPWcmJm0uc2V0QXR0cmlidXRlKCJkaXJlY3Rpb24iLGcpO251bGwhPWsmJm0uc2V0QXR0cmlidXRlKCJhbHBoYTEiLGspO251bGwhPWwmJm0uc2V0QXR0cmlidXRlKCJhbHBoYTIiLGwpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChtKX19OwpteFhtbENhbnZhczJELnByb3RvdHlwZS5zZXRTdHJva2VDb2xvcj1mdW5jdGlvbihhKXthPT1teENvbnN0YW50cy5OT05FJiYoYT1udWxsKTtpZih0aGlzLmNvbXByZXNzZWQpe2lmKHRoaXMuc3RhdGUuc3Ryb2tlQ29sb3I9PWEpcmV0dXJuO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0U3Ryb2tlQ29sb3IuYXBwbHkodGhpcyxhcmd1bWVudHMpfXZhciBiPXRoaXMuY3JlYXRlRWxlbWVudCgic3Ryb2tlY29sb3IiKTtiLnNldEF0dHJpYnV0ZSgiY29sb3IiLG51bGwhPWE/YTpteENvbnN0YW50cy5OT05FKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYil9OwpteFhtbENhbnZhczJELnByb3RvdHlwZS5zZXRTdHJva2VXaWR0aD1mdW5jdGlvbihhKXtpZih0aGlzLmNvbXByZXNzZWQpe2lmKHRoaXMuc3RhdGUuc3Ryb2tlV2lkdGg9PWEpcmV0dXJuO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0U3Ryb2tlV2lkdGguYXBwbHkodGhpcyxhcmd1bWVudHMpfXZhciBiPXRoaXMuY3JlYXRlRWxlbWVudCgic3Ryb2tld2lkdGgiKTtiLnNldEF0dHJpYnV0ZSgid2lkdGgiLHRoaXMuZm9ybWF0KGEpKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYil9OwpteFhtbENhbnZhczJELnByb3RvdHlwZS5zZXREYXNoZWQ9ZnVuY3Rpb24oYSxiKXtpZih0aGlzLmNvbXByZXNzZWQpe2lmKHRoaXMuc3RhdGUuZGFzaGVkPT1hKXJldHVybjtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldERhc2hlZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIGM9dGhpcy5jcmVhdGVFbGVtZW50KCJkYXNoZWQiKTtjLnNldEF0dHJpYnV0ZSgiZGFzaGVkIixhPyIxIjoiMCIpO251bGwhPWImJmMuc2V0QXR0cmlidXRlKCJmaXhEYXNoIixiPyIxIjoiMCIpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChjKX07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLnNldERhc2hQYXR0ZXJuPWZ1bmN0aW9uKGEpe2lmKHRoaXMuY29tcHJlc3NlZCl7aWYodGhpcy5zdGF0ZS5kYXNoUGF0dGVybj09YSlyZXR1cm47bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXREYXNoUGF0dGVybi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIGI9dGhpcy5jcmVhdGVFbGVtZW50KCJkYXNocGF0dGVybiIpO2Iuc2V0QXR0cmlidXRlKCJwYXR0ZXJuIixhKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYil9O214WG1sQ2FudmFzMkQucHJvdG90eXBlLnNldExpbmVDYXA9ZnVuY3Rpb24oYSl7aWYodGhpcy5jb21wcmVzc2VkKXtpZih0aGlzLnN0YXRlLmxpbmVDYXA9PWEpcmV0dXJuO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0TGluZUNhcC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIGI9dGhpcy5jcmVhdGVFbGVtZW50KCJsaW5lY2FwIik7Yi5zZXRBdHRyaWJ1dGUoImNhcCIsYSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGIpfTsKbXhYbWxDYW52YXMyRC5wcm90b3R5cGUuc2V0TGluZUpvaW49ZnVuY3Rpb24oYSl7aWYodGhpcy5jb21wcmVzc2VkKXtpZih0aGlzLnN0YXRlLmxpbmVKb2luPT1hKXJldHVybjtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldExpbmVKb2luLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgYj10aGlzLmNyZWF0ZUVsZW1lbnQoImxpbmVqb2luIik7Yi5zZXRBdHRyaWJ1dGUoImpvaW4iLGEpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChiKX07bXhYbWxDYW52YXMyRC5wcm90b3R5cGUuc2V0TWl0ZXJMaW1pdD1mdW5jdGlvbihhKXtpZih0aGlzLmNvbXByZXNzZWQpe2lmKHRoaXMuc3RhdGUubWl0ZXJMaW1pdD09YSlyZXR1cm47bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRNaXRlckxpbWl0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgYj10aGlzLmNyZWF0ZUVsZW1lbnQoIm1pdGVybGltaXQiKTtiLnNldEF0dHJpYnV0ZSgibGltaXQiLGEpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChiKX07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLnNldEZvbnRDb2xvcj1mdW5jdGlvbihhKXtpZih0aGlzLnRleHRFbmFibGVkKXthPT1teENvbnN0YW50cy5OT05FJiYoYT1udWxsKTtpZih0aGlzLmNvbXByZXNzZWQpe2lmKHRoaXMuc3RhdGUuZm9udENvbG9yPT1hKXJldHVybjtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldEZvbnRDb2xvci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIGI9dGhpcy5jcmVhdGVFbGVtZW50KCJmb250Y29sb3IiKTtiLnNldEF0dHJpYnV0ZSgiY29sb3IiLG51bGwhPWE/YTpteENvbnN0YW50cy5OT05FKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYil9fTsKbXhYbWxDYW52YXMyRC5wcm90b3R5cGUuc2V0Rm9udEJhY2tncm91bmRDb2xvcj1mdW5jdGlvbihhKXtpZih0aGlzLnRleHRFbmFibGVkKXthPT1teENvbnN0YW50cy5OT05FJiYoYT1udWxsKTtpZih0aGlzLmNvbXByZXNzZWQpe2lmKHRoaXMuc3RhdGUuZm9udEJhY2tncm91bmRDb2xvcj09YSlyZXR1cm47bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRGb250QmFja2dyb3VuZENvbG9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgYj10aGlzLmNyZWF0ZUVsZW1lbnQoImZvbnRiYWNrZ3JvdW5kY29sb3IiKTtiLnNldEF0dHJpYnV0ZSgiY29sb3IiLG51bGwhPWE/YTpteENvbnN0YW50cy5OT05FKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYil9fTsKbXhYbWxDYW52YXMyRC5wcm90b3R5cGUuc2V0Rm9udEJvcmRlckNvbG9yPWZ1bmN0aW9uKGEpe2lmKHRoaXMudGV4dEVuYWJsZWQpe2E9PW14Q29uc3RhbnRzLk5PTkUmJihhPW51bGwpO2lmKHRoaXMuY29tcHJlc3NlZCl7aWYodGhpcy5zdGF0ZS5mb250Qm9yZGVyQ29sb3I9PWEpcmV0dXJuO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0Rm9udEJvcmRlckNvbG9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgYj10aGlzLmNyZWF0ZUVsZW1lbnQoImZvbnRib3JkZXJjb2xvciIpO2Iuc2V0QXR0cmlidXRlKCJjb2xvciIsbnVsbCE9YT9hOm14Q29uc3RhbnRzLk5PTkUpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChiKX19OwpteFhtbENhbnZhczJELnByb3RvdHlwZS5zZXRGb250U2l6ZT1mdW5jdGlvbihhKXtpZih0aGlzLnRleHRFbmFibGVkKXtpZih0aGlzLmNvbXByZXNzZWQpe2lmKHRoaXMuc3RhdGUuZm9udFNpemU9PWEpcmV0dXJuO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0Rm9udFNpemUuYXBwbHkodGhpcyxhcmd1bWVudHMpfXZhciBiPXRoaXMuY3JlYXRlRWxlbWVudCgiZm9udHNpemUiKTtiLnNldEF0dHJpYnV0ZSgic2l6ZSIsYSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGIpfX07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLnNldEZvbnRGYW1pbHk9ZnVuY3Rpb24oYSl7aWYodGhpcy50ZXh0RW5hYmxlZCl7aWYodGhpcy5jb21wcmVzc2VkKXtpZih0aGlzLnN0YXRlLmZvbnRGYW1pbHk9PWEpcmV0dXJuO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0Rm9udEZhbWlseS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIGI9dGhpcy5jcmVhdGVFbGVtZW50KCJmb250ZmFtaWx5Iik7Yi5zZXRBdHRyaWJ1dGUoImZhbWlseSIsYSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGIpfX07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLnNldEZvbnRTdHlsZT1mdW5jdGlvbihhKXtpZih0aGlzLnRleHRFbmFibGVkKXtudWxsPT1hJiYoYT0wKTtpZih0aGlzLmNvbXByZXNzZWQpe2lmKHRoaXMuc3RhdGUuZm9udFN0eWxlPT1hKXJldHVybjtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldEZvbnRTdHlsZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIGI9dGhpcy5jcmVhdGVFbGVtZW50KCJmb250c3R5bGUiKTtiLnNldEF0dHJpYnV0ZSgic3R5bGUiLGEpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChiKX19OwpteFhtbENhbnZhczJELnByb3RvdHlwZS5zZXRTaGFkb3c9ZnVuY3Rpb24oYSl7aWYodGhpcy5jb21wcmVzc2VkKXtpZih0aGlzLnN0YXRlLnNoYWRvdz09YSlyZXR1cm47bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRTaGFkb3cuYXBwbHkodGhpcyxhcmd1bWVudHMpfXZhciBiPXRoaXMuY3JlYXRlRWxlbWVudCgic2hhZG93Iik7Yi5zZXRBdHRyaWJ1dGUoImVuYWJsZWQiLGE/IjEiOiIwIik7dGhpcy5yb290LmFwcGVuZENoaWxkKGIpfTsKbXhYbWxDYW52YXMyRC5wcm90b3R5cGUuc2V0U2hhZG93Q29sb3I9ZnVuY3Rpb24oYSl7aWYodGhpcy5jb21wcmVzc2VkKXthPT1teENvbnN0YW50cy5OT05FJiYoYT1udWxsKTtpZih0aGlzLnN0YXRlLnNoYWRvd0NvbG9yPT1hKXJldHVybjtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldFNoYWRvd0NvbG9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgYj10aGlzLmNyZWF0ZUVsZW1lbnQoInNoYWRvd2NvbG9yIik7Yi5zZXRBdHRyaWJ1dGUoImNvbG9yIixudWxsIT1hP2E6bXhDb25zdGFudHMuTk9ORSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGIpfTsKbXhYbWxDYW52YXMyRC5wcm90b3R5cGUuc2V0U2hhZG93QWxwaGE9ZnVuY3Rpb24oYSl7aWYodGhpcy5jb21wcmVzc2VkKXtpZih0aGlzLnN0YXRlLnNoYWRvd0FscGhhPT1hKXJldHVybjtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldFNoYWRvd0FscGhhLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgYj10aGlzLmNyZWF0ZUVsZW1lbnQoInNoYWRvd2FscGhhIik7Yi5zZXRBdHRyaWJ1dGUoImFscGhhIixhKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYil9OwpteFhtbENhbnZhczJELnByb3RvdHlwZS5zZXRTaGFkb3dPZmZzZXQ9ZnVuY3Rpb24oYSxiKXtpZih0aGlzLmNvbXByZXNzZWQpe2lmKHRoaXMuc3RhdGUuc2hhZG93RHg9PWEmJnRoaXMuc3RhdGUuc2hhZG93RHk9PWIpcmV0dXJuO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0U2hhZG93T2Zmc2V0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgYz10aGlzLmNyZWF0ZUVsZW1lbnQoInNoYWRvd29mZnNldCIpO2Muc2V0QXR0cmlidXRlKCJkeCIsYSk7Yy5zZXRBdHRyaWJ1dGUoImR5IixiKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYyl9OwpteFhtbENhbnZhczJELnByb3RvdHlwZS5yZWN0PWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMuY3JlYXRlRWxlbWVudCgicmVjdCIpO2Uuc2V0QXR0cmlidXRlKCJ4Iix0aGlzLmZvcm1hdChhKSk7ZS5zZXRBdHRyaWJ1dGUoInkiLHRoaXMuZm9ybWF0KGIpKTtlLnNldEF0dHJpYnV0ZSgidyIsdGhpcy5mb3JtYXQoYykpO2Uuc2V0QXR0cmlidXRlKCJoIix0aGlzLmZvcm1hdChkKSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGUpfTsKbXhYbWxDYW52YXMyRC5wcm90b3R5cGUucm91bmRyZWN0PWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgZz10aGlzLmNyZWF0ZUVsZW1lbnQoInJvdW5kcmVjdCIpO2cuc2V0QXR0cmlidXRlKCJ4Iix0aGlzLmZvcm1hdChhKSk7Zy5zZXRBdHRyaWJ1dGUoInkiLHRoaXMuZm9ybWF0KGIpKTtnLnNldEF0dHJpYnV0ZSgidyIsdGhpcy5mb3JtYXQoYykpO2cuc2V0QXR0cmlidXRlKCJoIix0aGlzLmZvcm1hdChkKSk7Zy5zZXRBdHRyaWJ1dGUoImR4Iix0aGlzLmZvcm1hdChlKSk7Zy5zZXRBdHRyaWJ1dGUoImR5Iix0aGlzLmZvcm1hdChmKSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGcpfTsKbXhYbWxDYW52YXMyRC5wcm90b3R5cGUuZWxsaXBzZT1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLmNyZWF0ZUVsZW1lbnQoImVsbGlwc2UiKTtlLnNldEF0dHJpYnV0ZSgieCIsdGhpcy5mb3JtYXQoYSkpO2Uuc2V0QXR0cmlidXRlKCJ5Iix0aGlzLmZvcm1hdChiKSk7ZS5zZXRBdHRyaWJ1dGUoInciLHRoaXMuZm9ybWF0KGMpKTtlLnNldEF0dHJpYnV0ZSgiaCIsdGhpcy5mb3JtYXQoZCkpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChlKX07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLmltYWdlPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayl7ZT10aGlzLmNvbnZlcnRlci5jb252ZXJ0KGUpO3ZhciBsPXRoaXMuY3JlYXRlRWxlbWVudCgiaW1hZ2UiKTtsLnNldEF0dHJpYnV0ZSgieCIsdGhpcy5mb3JtYXQoYSkpO2wuc2V0QXR0cmlidXRlKCJ5Iix0aGlzLmZvcm1hdChiKSk7bC5zZXRBdHRyaWJ1dGUoInciLHRoaXMuZm9ybWF0KGMpKTtsLnNldEF0dHJpYnV0ZSgiaCIsdGhpcy5mb3JtYXQoZCkpO2wuc2V0QXR0cmlidXRlKCJzcmMiLGUpO2wuc2V0QXR0cmlidXRlKCJhc3BlY3QiLGY/IjEiOiIwIik7bC5zZXRBdHRyaWJ1dGUoImZsaXBIIixnPyIxIjoiMCIpO2wuc2V0QXR0cmlidXRlKCJmbGlwViIsaz8iMSI6IjAiKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQobCl9OwpteFhtbENhbnZhczJELnByb3RvdHlwZS5iZWdpbj1mdW5jdGlvbigpe3RoaXMucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUVsZW1lbnQoImJlZ2luIikpO3RoaXMubGFzdFk9dGhpcy5sYXN0WD0wfTtteFhtbENhbnZhczJELnByb3RvdHlwZS5tb3ZlVG89ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmNyZWF0ZUVsZW1lbnQoIm1vdmUiKTtjLnNldEF0dHJpYnV0ZSgieCIsdGhpcy5mb3JtYXQoYSkpO2Muc2V0QXR0cmlidXRlKCJ5Iix0aGlzLmZvcm1hdChiKSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGMpO3RoaXMubGFzdFg9YTt0aGlzLmxhc3RZPWJ9OwpteFhtbENhbnZhczJELnByb3RvdHlwZS5saW5lVG89ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmNyZWF0ZUVsZW1lbnQoImxpbmUiKTtjLnNldEF0dHJpYnV0ZSgieCIsdGhpcy5mb3JtYXQoYSkpO2Muc2V0QXR0cmlidXRlKCJ5Iix0aGlzLmZvcm1hdChiKSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGMpO3RoaXMubGFzdFg9YTt0aGlzLmxhc3RZPWJ9O214WG1sQ2FudmFzMkQucHJvdG90eXBlLnF1YWRUbz1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLmNyZWF0ZUVsZW1lbnQoInF1YWQiKTtlLnNldEF0dHJpYnV0ZSgieDEiLHRoaXMuZm9ybWF0KGEpKTtlLnNldEF0dHJpYnV0ZSgieTEiLHRoaXMuZm9ybWF0KGIpKTtlLnNldEF0dHJpYnV0ZSgieDIiLHRoaXMuZm9ybWF0KGMpKTtlLnNldEF0dHJpYnV0ZSgieTIiLHRoaXMuZm9ybWF0KGQpKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoZSk7dGhpcy5sYXN0WD1jO3RoaXMubGFzdFk9ZH07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLmN1cnZlVG89ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnPXRoaXMuY3JlYXRlRWxlbWVudCgiY3VydmUiKTtnLnNldEF0dHJpYnV0ZSgieDEiLHRoaXMuZm9ybWF0KGEpKTtnLnNldEF0dHJpYnV0ZSgieTEiLHRoaXMuZm9ybWF0KGIpKTtnLnNldEF0dHJpYnV0ZSgieDIiLHRoaXMuZm9ybWF0KGMpKTtnLnNldEF0dHJpYnV0ZSgieTIiLHRoaXMuZm9ybWF0KGQpKTtnLnNldEF0dHJpYnV0ZSgieDMiLHRoaXMuZm9ybWF0KGUpKTtnLnNldEF0dHJpYnV0ZSgieTMiLHRoaXMuZm9ybWF0KGYpKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoZyk7dGhpcy5sYXN0WD1lO3RoaXMubGFzdFk9Zn07bXhYbWxDYW52YXMyRC5wcm90b3R5cGUuY2xvc2U9ZnVuY3Rpb24oKXt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVFbGVtZW50KCJjbG9zZSIpKX07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLnRleHQ9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxrLGwsbSxuLHAscSl7aWYodGhpcy50ZXh0RW5hYmxlZCYmbnVsbCE9ZSl7bXhVdGlscy5pc05vZGUoZSkmJihlPW14VXRpbHMuZ2V0T3V0ZXJIdG1sKGUpKTt2YXIgcj10aGlzLmNyZWF0ZUVsZW1lbnQoInRleHQiKTtyLnNldEF0dHJpYnV0ZSgieCIsdGhpcy5mb3JtYXQoYSkpO3Iuc2V0QXR0cmlidXRlKCJ5Iix0aGlzLmZvcm1hdChiKSk7ci5zZXRBdHRyaWJ1dGUoInciLHRoaXMuZm9ybWF0KGMpKTtyLnNldEF0dHJpYnV0ZSgiaCIsdGhpcy5mb3JtYXQoZCkpO3Iuc2V0QXR0cmlidXRlKCJzdHIiLGUpO251bGwhPWYmJnIuc2V0QXR0cmlidXRlKCJhbGlnbiIsZik7bnVsbCE9ZyYmci5zZXRBdHRyaWJ1dGUoInZhbGlnbiIsZyk7ci5zZXRBdHRyaWJ1dGUoIndyYXAiLGs/IjEiOiIwIik7bnVsbD09bCYmKGw9IiIpO3Iuc2V0QXR0cmlidXRlKCJmb3JtYXQiLGwpO251bGwhPW0mJnIuc2V0QXR0cmlidXRlKCJvdmVyZmxvdyIsCm0pO251bGwhPW4mJnIuc2V0QXR0cmlidXRlKCJjbGlwIixuPyIxIjoiMCIpO251bGwhPXAmJnIuc2V0QXR0cmlidXRlKCJyb3RhdGlvbiIscCk7bnVsbCE9cSYmci5zZXRBdHRyaWJ1dGUoImRpciIscSk7dGhpcy5yb290LmFwcGVuZENoaWxkKHIpfX07bXhYbWxDYW52YXMyRC5wcm90b3R5cGUuc3Ryb2tlPWZ1bmN0aW9uKCl7dGhpcy5yb290LmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlRWxlbWVudCgic3Ryb2tlIikpfTtteFhtbENhbnZhczJELnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKCl7dGhpcy5yb290LmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlRWxlbWVudCgiZmlsbCIpKX07bXhYbWxDYW52YXMyRC5wcm90b3R5cGUuZmlsbEFuZFN0cm9rZT1mdW5jdGlvbigpe3RoaXMucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUVsZW1lbnQoImZpbGxzdHJva2UiKSl9OwpmdW5jdGlvbiBteFN2Z0NhbnZhczJEKGEsYil7bXhBYnN0cmFjdENhbnZhczJELmNhbGwodGhpcyk7dGhpcy5yb290PWE7dGhpcy5ncmFkaWVudHM9W107dGhpcy5kZWZzPW51bGw7dGhpcy5zdHlsZUVuYWJsZWQ9bnVsbCE9Yj9iOiExO3ZhciBjPW51bGw7aWYoYS5vd25lckRvY3VtZW50IT1kb2N1bWVudClmb3IoYz1hO251bGwhPWMmJiJzdmciIT1jLm5vZGVOYW1lOyljPWMucGFyZW50Tm9kZTtudWxsIT1jJiYoMDxjLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkZWZzIikubGVuZ3RoJiYodGhpcy5kZWZzPWMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRlZnMiKVswXSksbnVsbD09dGhpcy5kZWZzJiYodGhpcy5kZWZzPXRoaXMuY3JlYXRlRWxlbWVudCgiZGVmcyIpLG51bGwhPWMuZmlyc3RDaGlsZD9jLmluc2VydEJlZm9yZSh0aGlzLmRlZnMsYy5maXJzdENoaWxkKTpjLmFwcGVuZENoaWxkKHRoaXMuZGVmcykpLHRoaXMuc3R5bGVFbmFibGVkJiZ0aGlzLmRlZnMuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVTdHlsZSgpKSl9Cm14VXRpbHMuZXh0ZW5kKG14U3ZnQ2FudmFzMkQsbXhBYnN0cmFjdENhbnZhczJEKTsoZnVuY3Rpb24oKXtteFN2Z0NhbnZhczJELnByb3RvdHlwZS51c2VEb21QYXJzZXI9IW14Q2xpZW50LklTX0lFJiYiZnVuY3Rpb24iPT09dHlwZW9mIERPTVBhcnNlciYmImZ1bmN0aW9uIj09PXR5cGVvZiBYTUxTZXJpYWxpemVyO2lmKG14U3ZnQ2FudmFzMkQucHJvdG90eXBlLnVzZURvbVBhcnNlcil0cnl7dmFyIGE9KG5ldyBET01QYXJzZXIpLnBhcnNlRnJvbVN0cmluZygidGVzdCB0ZXh0IiwidGV4dC9odG1sIik7bXhTdmdDYW52YXMyRC5wcm90b3R5cGUudXNlRG9tUGFyc2VyPW51bGwhPWF9Y2F0Y2goYil7bXhTdmdDYW52YXMyRC5wcm90b3R5cGUudXNlRG9tUGFyc2VyPSExfX0pKCk7bXhTdmdDYW52YXMyRC5wcm90b3R5cGUubm9kZT1udWxsO214U3ZnQ2FudmFzMkQucHJvdG90eXBlLm1hdGNoSHRtbEFsaWdubWVudD0hMDsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUudGV4dEVuYWJsZWQ9ITA7bXhTdmdDYW52YXMyRC5wcm90b3R5cGUuZm9FbmFibGVkPSEwO214U3ZnQ2FudmFzMkQucHJvdG90eXBlLmZvQWx0VGV4dD0iW09iamVjdF0iO214U3ZnQ2FudmFzMkQucHJvdG90eXBlLmZvT2Zmc2V0PTA7bXhTdmdDYW52YXMyRC5wcm90b3R5cGUudGV4dE9mZnNldD0wO214U3ZnQ2FudmFzMkQucHJvdG90eXBlLmltYWdlT2Zmc2V0PTA7bXhTdmdDYW52YXMyRC5wcm90b3R5cGUuc3Ryb2tlVG9sZXJhbmNlPTA7bXhTdmdDYW52YXMyRC5wcm90b3R5cGUubWluU3Ryb2tlV2lkdGg9MTtteFN2Z0NhbnZhczJELnByb3RvdHlwZS5yZWZDb3VudD0wO214U3ZnQ2FudmFzMkQucHJvdG90eXBlLmxpbmVIZWlnaHRDb3JyZWN0aW9uPTE7bXhTdmdDYW52YXMyRC5wcm90b3R5cGUucG9pbnRlckV2ZW50c1ZhbHVlPSJhbGwiO214U3ZnQ2FudmFzMkQucHJvdG90eXBlLmZvbnRNZXRyaWNzUGFkZGluZz0xMDsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUuY2FjaGVPZmZzZXRTaXplPSEwO214U3ZnQ2FudmFzMkQucHJvdG90eXBlLmZvcm1hdD1mdW5jdGlvbihhKXtyZXR1cm4gcGFyc2VGbG9hdChwYXJzZUZsb2F0KGEpLnRvRml4ZWQoMikpfTtteFN2Z0NhbnZhczJELnByb3RvdHlwZS5nZXRCYXNlVXJsPWZ1bmN0aW9uKCl7dmFyIGE9d2luZG93LmxvY2F0aW9uLmhyZWYsYj1hLmxhc3RJbmRleE9mKCIjIik7MDxiJiYoYT1hLnN1YnN0cmluZygwLGIpKTtyZXR1cm4gYX07bXhTdmdDYW52YXMyRC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnJlc2V0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLmdyYWRpZW50cz1bXX07Cm14U3ZnQ2FudmFzMkQucHJvdG90eXBlLmNyZWF0ZVN0eWxlPWZ1bmN0aW9uKGEpe2E9dGhpcy5jcmVhdGVFbGVtZW50KCJzdHlsZSIpO2Euc2V0QXR0cmlidXRlKCJ0eXBlIiwidGV4dC9jc3MiKTtteFV0aWxzLndyaXRlKGEsInN2Z3tmb250LWZhbWlseToiK214Q29uc3RhbnRzLkRFRkFVTFRfRk9OVEZBTUlMWSsiO2ZvbnQtc2l6ZToiK214Q29uc3RhbnRzLkRFRkFVTFRfRk9OVFNJWkUrIjtmaWxsOm5vbmU7c3Ryb2tlLW1pdGVybGltaXQ6MTB9Iik7cmV0dXJuIGF9OwpteFN2Z0NhbnZhczJELnByb3RvdHlwZS5jcmVhdGVFbGVtZW50PWZ1bmN0aW9uKGEsYil7aWYobnVsbCE9dGhpcy5yb290Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKXJldHVybiB0aGlzLnJvb3Qub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoYnx8bXhDb25zdGFudHMuTlNfU1ZHLGEpO3ZhciBjPXRoaXMucm9vdC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoYSk7bnVsbCE9YiYmYy5zZXRBdHRyaWJ1dGUoInhtbG5zIixiKTtyZXR1cm4gY307bXhTdmdDYW52YXMyRC5wcm90b3R5cGUuZ2V0QWx0ZXJuYXRlVGV4dD1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGssbCxtLG4scCxxKXtyZXR1cm4gbnVsbCE9Zj90aGlzLmZvQWx0VGV4dDpudWxsfTsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUuY3JlYXRlQWx0ZXJuYXRlQ29udGVudD1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGssbCxtLG4scCxxKXthPXRoaXMuZ2V0QWx0ZXJuYXRlVGV4dChhLGIsYyxkLGUsZixnLGssbCxtLG4scCxxKTtkPXRoaXMuc3RhdGU7cmV0dXJuIG51bGwhPWEmJjA8ZC5mb250U2l6ZT8oaz1rPT1teENvbnN0YW50cy5BTElHTl9UT1A/MTprPT1teENvbnN0YW50cy5BTElHTl9CT1RUT00/MDouMyxlPWc9PW14Q29uc3RhbnRzLkFMSUdOX1JJR0hUPyJlbmQiOmc9PW14Q29uc3RhbnRzLkFMSUdOX0xFRlQ/InN0YXJ0IjoibWlkZGxlIixnPXRoaXMuY3JlYXRlRWxlbWVudCgidGV4dCIpLGcuc2V0QXR0cmlidXRlKCJ4IixNYXRoLnJvdW5kKGIrZC5keCkpLGcuc2V0QXR0cmlidXRlKCJ5IixNYXRoLnJvdW5kKGMrZC5keStrKmQuZm9udFNpemUpKSxnLnNldEF0dHJpYnV0ZSgiZmlsbCIsZC5mb250Q29sb3J8fCJibGFjayIpLGcuc2V0QXR0cmlidXRlKCJmb250LWZhbWlseSIsCmQuZm9udEZhbWlseSksZy5zZXRBdHRyaWJ1dGUoImZvbnQtc2l6ZSIsTWF0aC5yb3VuZChkLmZvbnRTaXplKSsicHgiKSwic3RhcnQiIT1lJiZnLnNldEF0dHJpYnV0ZSgidGV4dC1hbmNob3IiLGUpLChkLmZvbnRTdHlsZSZteENvbnN0YW50cy5GT05UX0JPTEQpPT1teENvbnN0YW50cy5GT05UX0JPTEQmJmcuc2V0QXR0cmlidXRlKCJmb250LXdlaWdodCIsImJvbGQiKSwoZC5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9JVEFMSUMpPT1teENvbnN0YW50cy5GT05UX0lUQUxJQyYmZy5zZXRBdHRyaWJ1dGUoImZvbnQtc3R5bGUiLCJpdGFsaWMiKSxiPVtdLChkLmZvbnRTdHlsZSZteENvbnN0YW50cy5GT05UX1VOREVSTElORSk9PW14Q29uc3RhbnRzLkZPTlRfVU5ERVJMSU5FJiZiLnB1c2goInVuZGVybGluZSIpLChkLmZvbnRTdHlsZSZteENvbnN0YW50cy5GT05UX1NUUklLRVRIUk9VR0gpPT1teENvbnN0YW50cy5GT05UX1NUUklLRVRIUk9VR0gmJmIucHVzaCgibGluZS10aHJvdWdoIiksCjA8Yi5sZW5ndGgmJmcuc2V0QXR0cmlidXRlKCJ0ZXh0LWRlY29yYXRpb24iLGIuam9pbigiICIpKSxteFV0aWxzLndyaXRlKGcsYSksZyk6bnVsbH07bXhTdmdDYW52YXMyRC5wcm90b3R5cGUuY3JlYXRlR3JhZGllbnRJZD1mdW5jdGlvbihhLGIsYyxkLGUpeyIjIj09YS5jaGFyQXQoMCkmJihhPWEuc3Vic3RyaW5nKDEpKTsiIyI9PWIuY2hhckF0KDApJiYoYj1iLnN1YnN0cmluZygxKSk7YT1hLnRvTG93ZXJDYXNlKCkrIi0iK2M7Yj1iLnRvTG93ZXJDYXNlKCkrIi0iK2Q7Yz1udWxsO251bGw9PWV8fGU9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSD9jPSJzIjplPT1teENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVD9jPSJlIjooZD1hLGE9YixiPWQsZT09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIP2M9InMiOmU9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUJiYoYz0iZSIpKTtyZXR1cm4ibXgtZ3JhZGllbnQtIithKyItIitiKyItIitjfTsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUuZ2V0U3ZnR3JhZGllbnQ9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj10aGlzLmNyZWF0ZUdyYWRpZW50SWQoYSxiLGMsZCxlKSxnPXRoaXMuZ3JhZGllbnRzW2ZdO2lmKG51bGw9PWcpe3ZhciBrPXRoaXMucm9vdC5vd25lclNWR0VsZW1lbnQsbD0wLG09ZisiLSIrbDtpZihudWxsIT1rKWZvcihnPWsub3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZChtKTtudWxsIT1nJiZnLm93bmVyU1ZHRWxlbWVudCE9azspbT1mKyItIitsKyssZz1rLm93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobSk7ZWxzZSBtPSJpZCIrICsrdGhpcy5yZWZDb3VudDtudWxsPT1nJiYoZz10aGlzLmNyZWF0ZVN2Z0dyYWRpZW50KGEsYixjLGQsZSksZy5zZXRBdHRyaWJ1dGUoImlkIixtKSxudWxsIT10aGlzLmRlZnM/dGhpcy5kZWZzLmFwcGVuZENoaWxkKGcpOmsuYXBwZW5kQ2hpbGQoZykpO3RoaXMuZ3JhZGllbnRzW2ZdPWd9cmV0dXJuIGcuZ2V0QXR0cmlidXRlKCJpZCIpfTsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUuY3JlYXRlU3ZnR3JhZGllbnQ9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj10aGlzLmNyZWF0ZUVsZW1lbnQoImxpbmVhckdyYWRpZW50Iik7Zi5zZXRBdHRyaWJ1dGUoIngxIiwiMCUiKTtmLnNldEF0dHJpYnV0ZSgieTEiLCIwJSIpO2Yuc2V0QXR0cmlidXRlKCJ4MiIsIjAlIik7Zi5zZXRBdHRyaWJ1dGUoInkyIiwiMCUiKTtudWxsPT1lfHxlPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEg/Zi5zZXRBdHRyaWJ1dGUoInkyIiwiMTAwJSIpOmU9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNUP2Yuc2V0QXR0cmlidXRlKCJ4MiIsIjEwMCUiKTplPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEg/Zi5zZXRBdHRyaWJ1dGUoInkxIiwiMTAwJSIpOmU9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUJiZmLnNldEF0dHJpYnV0ZSgieDEiLCIxMDAlIik7Yz0xPmM/IjtzdG9wLW9wYWNpdHk6IitjOiIiO2U9dGhpcy5jcmVhdGVFbGVtZW50KCJzdG9wIik7CmUuc2V0QXR0cmlidXRlKCJvZmZzZXQiLCIwJSIpO2Uuc2V0QXR0cmlidXRlKCJzdHlsZSIsInN0b3AtY29sb3I6IithK2MpO2YuYXBwZW5kQ2hpbGQoZSk7Yz0xPmQ/IjtzdG9wLW9wYWNpdHk6IitkOiIiO2U9dGhpcy5jcmVhdGVFbGVtZW50KCJzdG9wIik7ZS5zZXRBdHRyaWJ1dGUoIm9mZnNldCIsIjEwMCUiKTtlLnNldEF0dHJpYnV0ZSgic3R5bGUiLCJzdG9wLWNvbG9yOiIrYitjKTtmLmFwcGVuZENoaWxkKGUpO3JldHVybiBmfTsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUuYWRkTm9kZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMubm9kZSxkPXRoaXMuc3RhdGU7aWYobnVsbCE9Yyl7aWYoInBhdGgiPT1jLm5vZGVOYW1lKWlmKG51bGwhPXRoaXMucGF0aCYmMDx0aGlzLnBhdGgubGVuZ3RoKWMuc2V0QXR0cmlidXRlKCJkIix0aGlzLnBhdGguam9pbigiICIpKTtlbHNlIHJldHVybjthJiZudWxsIT1kLmZpbGxDb2xvcj90aGlzLnVwZGF0ZUZpbGwoKTp0aGlzLnN0eWxlRW5hYmxlZHx8KCJlbGxpcHNlIj09Yy5ub2RlTmFtZSYmbXhDbGllbnQuSVNfRkY/Yy5zZXRBdHRyaWJ1dGUoImZpbGwiLCJ0cmFuc3BhcmVudCIpOmMuc2V0QXR0cmlidXRlKCJmaWxsIiwibm9uZSIpLGE9ITEpO2ImJm51bGwhPWQuc3Ryb2tlQ29sb3I/dGhpcy51cGRhdGVTdHJva2UoKTp0aGlzLnN0eWxlRW5hYmxlZHx8Yy5zZXRBdHRyaWJ1dGUoInN0cm9rZSIsIm5vbmUiKTtudWxsIT1kLnRyYW5zZm9ybSYmMDxkLnRyYW5zZm9ybS5sZW5ndGgmJgpjLnNldEF0dHJpYnV0ZSgidHJhbnNmb3JtIixkLnRyYW5zZm9ybSk7ZC5zaGFkb3cmJnRoaXMucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZVNoYWRvdyhjKSk7MDx0aGlzLnN0cm9rZVRvbGVyYW5jZSYmIWEmJnRoaXMucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZVRvbGVyYW5jZShjKSk7dGhpcy5wb2ludGVyRXZlbnRzP2Muc2V0QXR0cmlidXRlKCJwb2ludGVyLWV2ZW50cyIsdGhpcy5wb2ludGVyRXZlbnRzVmFsdWUpOnRoaXMucG9pbnRlckV2ZW50c3x8bnVsbCE9dGhpcy5vcmlnaW5hbFJvb3R8fGMuc2V0QXR0cmlidXRlKCJwb2ludGVyLWV2ZW50cyIsIm5vbmUiKTsoInJlY3QiIT1jLm5vZGVOYW1lJiYicGF0aCIhPWMubm9kZU5hbWUmJiJlbGxpcHNlIiE9Yy5ub2RlTmFtZXx8Im5vbmUiIT1jLmdldEF0dHJpYnV0ZSgiZmlsbCIpJiYidHJhbnNwYXJlbnQiIT1jLmdldEF0dHJpYnV0ZSgiZmlsbCIpfHwibm9uZSIhPWMuZ2V0QXR0cmlidXRlKCJzdHJva2UiKXx8Im5vbmUiIT0KYy5nZXRBdHRyaWJ1dGUoInBvaW50ZXItZXZlbnRzIikpJiZ0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYyk7dGhpcy5ub2RlPW51bGx9fTsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUudXBkYXRlRmlsbD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuc3RhdGU7KDE+YS5hbHBoYXx8MT5hLmZpbGxBbHBoYSkmJnRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoImZpbGwtb3BhY2l0eSIsYS5hbHBoYSphLmZpbGxBbHBoYSk7aWYobnVsbCE9YS5maWxsQ29sb3IpaWYobnVsbCE9YS5ncmFkaWVudENvbG9yKWlmKGE9dGhpcy5nZXRTdmdHcmFkaWVudChTdHJpbmcoYS5maWxsQ29sb3IpLFN0cmluZyhhLmdyYWRpZW50Q29sb3IpLGEuZ3JhZGllbnRGaWxsQWxwaGEsYS5ncmFkaWVudEFscGhhLGEuZ3JhZGllbnREaXJlY3Rpb24pLG14Q2xpZW50LklTX0NIUk9NRUFQUHx8bXhDbGllbnQuSVNfSUV8fG14Q2xpZW50LklTX0lFMTF8fG14Q2xpZW50LklTX0VER0V8fHRoaXMucm9vdC5vd25lckRvY3VtZW50IT1kb2N1bWVudCl0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCJmaWxsIiwidXJsKCMiK2ErIikiKTtlbHNle3ZhciBiPXRoaXMuZ2V0QmFzZVVybCgpLnJlcGxhY2UoLyhbXChcKV0pL2csCiJcXCQxIik7dGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgiZmlsbCIsInVybCgiK2IrIiMiK2ErIikiKX1lbHNlIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoImZpbGwiLFN0cmluZyhhLmZpbGxDb2xvcikudG9Mb3dlckNhc2UoKSl9O214U3ZnQ2FudmFzMkQucHJvdG90eXBlLmdldEN1cnJlbnRTdHJva2VXaWR0aD1mdW5jdGlvbigpe3JldHVybiBNYXRoLm1heCh0aGlzLm1pblN0cm9rZVdpZHRoLE1hdGgubWF4KC4wMSx0aGlzLmZvcm1hdCh0aGlzLnN0YXRlLnN0cm9rZVdpZHRoKnRoaXMuc3RhdGUuc2NhbGUpKSl9OwpteFN2Z0NhbnZhczJELnByb3RvdHlwZS51cGRhdGVTdHJva2U9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnN0YXRlO3RoaXMubm9kZS5zZXRBdHRyaWJ1dGUoInN0cm9rZSIsU3RyaW5nKGEuc3Ryb2tlQ29sb3IpLnRvTG93ZXJDYXNlKCkpOygxPmEuYWxwaGF8fDE+YS5zdHJva2VBbHBoYSkmJnRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoInN0cm9rZS1vcGFjaXR5IixhLmFscGhhKmEuc3Ryb2tlQWxwaGEpO3ZhciBiPXRoaXMuZ2V0Q3VycmVudFN0cm9rZVdpZHRoKCk7MSE9YiYmdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgic3Ryb2tlLXdpZHRoIixiKTsicGF0aCI9PXRoaXMubm9kZS5ub2RlTmFtZSYmdGhpcy51cGRhdGVTdHJva2VBdHRyaWJ1dGVzKCk7YS5kYXNoZWQmJnRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoInN0cm9rZS1kYXNoYXJyYXkiLHRoaXMuY3JlYXRlRGFzaFBhdHRlcm4oKGEuZml4RGFzaD8xOmEuc3Ryb2tlV2lkdGgpKmEuc2NhbGUpKX07Cm14U3ZnQ2FudmFzMkQucHJvdG90eXBlLnVwZGF0ZVN0cm9rZUF0dHJpYnV0ZXM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnN0YXRlO251bGwhPWEubGluZUpvaW4mJiJtaXRlciIhPWEubGluZUpvaW4mJnRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoInN0cm9rZS1saW5lam9pbiIsYS5saW5lSm9pbik7aWYobnVsbCE9YS5saW5lQ2FwKXt2YXIgYj1hLmxpbmVDYXA7ImZsYXQiPT1iJiYoYj0iYnV0dCIpOyJidXR0IiE9YiYmdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgic3Ryb2tlLWxpbmVjYXAiLGIpfW51bGw9PWEubWl0ZXJMaW1pdHx8dGhpcy5zdHlsZUVuYWJsZWQmJjEwPT1hLm1pdGVyTGltaXR8fHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoInN0cm9rZS1taXRlcmxpbWl0IixhLm1pdGVyTGltaXQpfTsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUuY3JlYXRlRGFzaFBhdHRlcm49ZnVuY3Rpb24oYSl7dmFyIGI9W107aWYoInN0cmluZyI9PT10eXBlb2YgdGhpcy5zdGF0ZS5kYXNoUGF0dGVybil7dmFyIGM9dGhpcy5zdGF0ZS5kYXNoUGF0dGVybi5zcGxpdCgiICIpO2lmKDA8Yy5sZW5ndGgpZm9yKHZhciBkPTA7ZDxjLmxlbmd0aDtkKyspYltkXT1OdW1iZXIoY1tkXSkqYX1yZXR1cm4gYi5qb2luKCIgIil9OwpteFN2Z0NhbnZhczJELnByb3RvdHlwZS5jcmVhdGVUb2xlcmFuY2U9ZnVuY3Rpb24oYSl7YT1hLmNsb25lTm9kZSghMCk7dmFyIGI9cGFyc2VGbG9hdChhLmdldEF0dHJpYnV0ZSgic3Ryb2tlLXdpZHRoIil8fDEpK3RoaXMuc3Ryb2tlVG9sZXJhbmNlO2Euc2V0QXR0cmlidXRlKCJwb2ludGVyLWV2ZW50cyIsInN0cm9rZSIpO2Euc2V0QXR0cmlidXRlKCJ2aXNpYmlsaXR5IiwiaGlkZGVuIik7YS5yZW1vdmVBdHRyaWJ1dGUoInN0cm9rZS1kYXNoYXJyYXkiKTthLnNldEF0dHJpYnV0ZSgic3Ryb2tlLXdpZHRoIixiKTthLnNldEF0dHJpYnV0ZSgiZmlsbCIsIm5vbmUiKTthLnNldEF0dHJpYnV0ZSgic3Ryb2tlIixteENsaWVudC5JU19PVD8ibm9uZSI6IndoaXRlIik7cmV0dXJuIGF9OwpteFN2Z0NhbnZhczJELnByb3RvdHlwZS5jcmVhdGVTaGFkb3c9ZnVuY3Rpb24oYSl7YT1hLmNsb25lTm9kZSghMCk7dmFyIGI9dGhpcy5zdGF0ZTsibm9uZSI9PWEuZ2V0QXR0cmlidXRlKCJmaWxsIil8fG14Q2xpZW50LklTX0ZGJiYidHJhbnNwYXJlbnQiPT1hLmdldEF0dHJpYnV0ZSgiZmlsbCIpfHxhLnNldEF0dHJpYnV0ZSgiZmlsbCIsYi5zaGFkb3dDb2xvcik7Im5vbmUiIT1hLmdldEF0dHJpYnV0ZSgic3Ryb2tlIikmJmEuc2V0QXR0cmlidXRlKCJzdHJva2UiLGIuc2hhZG93Q29sb3IpO2Euc2V0QXR0cmlidXRlKCJ0cmFuc2Zvcm0iLCJ0cmFuc2xhdGUoIit0aGlzLmZvcm1hdChiLnNoYWRvd0R4KmIuc2NhbGUpKyIsIit0aGlzLmZvcm1hdChiLnNoYWRvd0R5KmIuc2NhbGUpKyIpIisoYi50cmFuc2Zvcm18fCIiKSk7YS5zZXRBdHRyaWJ1dGUoIm9wYWNpdHkiLGIuc2hhZG93QWxwaGEpO3JldHVybiBhfTsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUuc2V0TGluaz1mdW5jdGlvbihhKXtpZihudWxsPT1hKXRoaXMucm9vdD10aGlzLm9yaWdpbmFsUm9vdDtlbHNle3RoaXMub3JpZ2luYWxSb290PXRoaXMucm9vdDt2YXIgYj10aGlzLmNyZWF0ZUVsZW1lbnQoImEiKTtudWxsPT1iLnNldEF0dHJpYnV0ZU5TfHx0aGlzLnJvb3Qub3duZXJEb2N1bWVudCE9ZG9jdW1lbnQmJm51bGw9PWRvY3VtZW50LmRvY3VtZW50TW9kZT9iLnNldEF0dHJpYnV0ZSgieGxpbms6aHJlZiIsYSk6Yi5zZXRBdHRyaWJ1dGVOUyhteENvbnN0YW50cy5OU19YTElOSywieGxpbms6aHJlZiIsYSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGIpO3RoaXMucm9vdD1ifX07Cm14U3ZnQ2FudmFzMkQucHJvdG90eXBlLnJvdGF0ZT1mdW5jdGlvbihhLGIsYyxkLGUpe2lmKDAhPWF8fGJ8fGMpe3ZhciBmPXRoaXMuc3RhdGU7ZCs9Zi5keDtlKz1mLmR5O2QqPWYuc2NhbGU7ZSo9Zi5zY2FsZTtmLnRyYW5zZm9ybT1mLnRyYW5zZm9ybXx8IiI7aWYoYiYmYylhKz0xODA7ZWxzZSBpZihiIT1jKXt2YXIgZz1iP2Q6MCxrPWI/LTE6MSxsPWM/ZTowLG09Yz8tMToxO2YudHJhbnNmb3JtKz0idHJhbnNsYXRlKCIrdGhpcy5mb3JtYXQoZykrIiwiK3RoaXMuZm9ybWF0KGwpKyIpc2NhbGUoIit0aGlzLmZvcm1hdChrKSsiLCIrdGhpcy5mb3JtYXQobSkrIil0cmFuc2xhdGUoIit0aGlzLmZvcm1hdCgtZykrIiwiK3RoaXMuZm9ybWF0KC1sKSsiKSJ9aWYoYj8hYzpjKWEqPS0xOzAhPWEmJihmLnRyYW5zZm9ybSs9InJvdGF0ZSgiK3RoaXMuZm9ybWF0KGEpKyIsIit0aGlzLmZvcm1hdChkKSsiLCIrdGhpcy5mb3JtYXQoZSkrIikiKTtmLnJvdGF0aW9uKz1hO2Yucm90YXRpb25DeD0KZDtmLnJvdGF0aW9uQ3k9ZX19O214U3ZnQ2FudmFzMkQucHJvdG90eXBlLmJlZ2luPWZ1bmN0aW9uKCl7bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5iZWdpbi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy5ub2RlPXRoaXMuY3JlYXRlRWxlbWVudCgicGF0aCIpfTtteFN2Z0NhbnZhczJELnByb3RvdHlwZS5yZWN0PWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMuc3RhdGUsZj10aGlzLmNyZWF0ZUVsZW1lbnQoInJlY3QiKTtmLnNldEF0dHJpYnV0ZSgieCIsdGhpcy5mb3JtYXQoKGErZS5keCkqZS5zY2FsZSkpO2Yuc2V0QXR0cmlidXRlKCJ5Iix0aGlzLmZvcm1hdCgoYitlLmR5KSplLnNjYWxlKSk7Zi5zZXRBdHRyaWJ1dGUoIndpZHRoIix0aGlzLmZvcm1hdChjKmUuc2NhbGUpKTtmLnNldEF0dHJpYnV0ZSgiaGVpZ2h0Iix0aGlzLmZvcm1hdChkKmUuc2NhbGUpKTt0aGlzLm5vZGU9Zn07Cm14U3ZnQ2FudmFzMkQucHJvdG90eXBlLnJvdW5kcmVjdD1mdW5jdGlvbihhLGIsYyxkLGUsZil7dGhpcy5yZWN0KGEsYixjLGQpOzA8ZSYmdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgicngiLHRoaXMuZm9ybWF0KGUqdGhpcy5zdGF0ZS5zY2FsZSkpOzA8ZiYmdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgicnkiLHRoaXMuZm9ybWF0KGYqdGhpcy5zdGF0ZS5zY2FsZSkpfTtteFN2Z0NhbnZhczJELnByb3RvdHlwZS5lbGxpcHNlPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMuc3RhdGUsZj10aGlzLmNyZWF0ZUVsZW1lbnQoImVsbGlwc2UiKTtmLnNldEF0dHJpYnV0ZSgiY3giLHRoaXMuZm9ybWF0KChhK2MvMitlLmR4KSplLnNjYWxlKSk7Zi5zZXRBdHRyaWJ1dGUoImN5Iix0aGlzLmZvcm1hdCgoYitkLzIrZS5keSkqZS5zY2FsZSkpO2Yuc2V0QXR0cmlidXRlKCJyeCIsYy8yKmUuc2NhbGUpO2Yuc2V0QXR0cmlidXRlKCJyeSIsZC8yKmUuc2NhbGUpO3RoaXMubm9kZT1mfTsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUuaW1hZ2U9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxrKXtlPXRoaXMuY29udmVydGVyLmNvbnZlcnQoZSk7Zj1udWxsIT1mP2Y6ITA7Zz1udWxsIT1nP2c6ITE7az1udWxsIT1rP2s6ITE7dmFyIGw9dGhpcy5zdGF0ZTthKz1sLmR4O2IrPWwuZHk7dmFyIG09dGhpcy5jcmVhdGVFbGVtZW50KCJpbWFnZSIpO20uc2V0QXR0cmlidXRlKCJ4Iix0aGlzLmZvcm1hdChhKmwuc2NhbGUpK3RoaXMuaW1hZ2VPZmZzZXQpO20uc2V0QXR0cmlidXRlKCJ5Iix0aGlzLmZvcm1hdChiKmwuc2NhbGUpK3RoaXMuaW1hZ2VPZmZzZXQpO20uc2V0QXR0cmlidXRlKCJ3aWR0aCIsdGhpcy5mb3JtYXQoYypsLnNjYWxlKSk7bS5zZXRBdHRyaWJ1dGUoImhlaWdodCIsdGhpcy5mb3JtYXQoZCpsLnNjYWxlKSk7bnVsbD09bS5zZXRBdHRyaWJ1dGVOUz9tLnNldEF0dHJpYnV0ZSgieGxpbms6aHJlZiIsZSk6bS5zZXRBdHRyaWJ1dGVOUyhteENvbnN0YW50cy5OU19YTElOSywKInhsaW5rOmhyZWYiLGUpO2Z8fG0uc2V0QXR0cmlidXRlKCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwibm9uZSIpOygxPmwuYWxwaGF8fDE+bC5maWxsQWxwaGEpJiZtLnNldEF0dHJpYnV0ZSgib3BhY2l0eSIsbC5hbHBoYSpsLmZpbGxBbHBoYSk7ZT10aGlzLnN0YXRlLnRyYW5zZm9ybXx8IiI7aWYoZ3x8ayl7dmFyIG49Zj0xLHA9MCxxPTA7ZyYmKGY9LTEscD0tYy0yKmEpO2smJihuPS0xLHE9LWQtMipiKTtlKz0ic2NhbGUoIitmKyIsIituKyIpdHJhbnNsYXRlKCIrcCpsLnNjYWxlKyIsIitxKmwuc2NhbGUrIikifTA8ZS5sZW5ndGgmJm0uc2V0QXR0cmlidXRlKCJ0cmFuc2Zvcm0iLGUpO3RoaXMucG9pbnRlckV2ZW50c3x8bS5zZXRBdHRyaWJ1dGUoInBvaW50ZXItZXZlbnRzIiwibm9uZSIpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChtKX07Cm14U3ZnQ2FudmFzMkQucHJvdG90eXBlLmNvbnZlcnRIdG1sPWZ1bmN0aW9uKGEpe2lmKHRoaXMudXNlRG9tUGFyc2VyKXt2YXIgYj0obmV3IERPTVBhcnNlcikucGFyc2VGcm9tU3RyaW5nKGEsInRleHQvaHRtbCIpO251bGwhPWImJihhPShuZXcgWE1MU2VyaWFsaXplcikuc2VyaWFsaXplVG9TdHJpbmcoYi5ib2R5KSwiPGJvZHkiPT1hLnN1YnN0cmluZygwLDUpJiYoYT1hLnN1YnN0cmluZyhhLmluZGV4T2YoIj4iLDUpKzEpKSwiPC9ib2R5PiI9PWEuc3Vic3RyaW5nKGEubGVuZ3RoLTcsYS5sZW5ndGgpJiYoYT1hLnN1YnN0cmluZygwLGEubGVuZ3RoLTcpKSl9ZWxzZXtpZihudWxsIT1kb2N1bWVudC5pbXBsZW1lbnRhdGlvbiYmbnVsbCE9ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQpe3ZhciBiPWRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50KCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiwiaHRtbCIsbnVsbCksYz1iLmNyZWF0ZUVsZW1lbnQoImJvZHkiKTsKYi5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoYyk7dmFyIGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7ZC5pbm5lckhUTUw9YTtmb3IoYT1kLmZpcnN0Q2hpbGQ7bnVsbCE9YTspZD1hLm5leHRTaWJsaW5nLGMuYXBwZW5kQ2hpbGQoYi5hZG9wdE5vZGUoYSkpLGE9ZDtyZXR1cm4gYy5pbm5lckhUTUx9Yj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZXh0YXJlYSIpO2IuaW5uZXJIVE1MPWEucmVwbGFjZSgvJmFtcDsvZywiJmFtcDthbXA7IikucmVwbGFjZSgvJiM2MDsvZywiJmFtcDtsdDsiKS5yZXBsYWNlKC8mIzYyOy9nLCImYW1wO2d0OyIpLnJlcGxhY2UoLyZsdDsvZywiJmFtcDtsdDsiKS5yZXBsYWNlKC8mZ3Q7L2csIiZhbXA7Z3Q7IikucmVwbGFjZSgvPC9nLCImbHQ7IikucmVwbGFjZSgvPi9nLCImZ3Q7Iik7YT1iLnZhbHVlLnJlcGxhY2UoLyYvZywiJmFtcDsiKS5yZXBsYWNlKC8mYW1wO2x0Oy9nLCImbHQ7IikucmVwbGFjZSgvJmFtcDtndDsvZywiJmd0OyIpLnJlcGxhY2UoLyZhbXA7YW1wOy9nLAoiJmFtcDsiKS5yZXBsYWNlKC88YnI+L2csIjxiciAvPiIpLnJlcGxhY2UoLzxocj4vZywiPGhyIC8+IikucmVwbGFjZSgvKDxpbWdbXj5dKyk+L2dtLCIkMSAvPiIpfXJldHVybiBhfTsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUuY3JlYXRlRGl2PWZ1bmN0aW9uKGEpe214VXRpbHMuaXNOb2RlKGEpfHwoYT0iPGRpdj48ZGl2PiIrdGhpcy5jb252ZXJ0SHRtbChhKSsiPC9kaXY+PC9kaXY+Iik7aWYobXhDbGllbnQuSVNfSUV8fG14Q2xpZW50LklTX0lFMTF8fCFkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMpcmV0dXJuIG14VXRpbHMuaXNOb2RlKGEpJiYoYT0iPGRpdj48ZGl2PiIrbXhVdGlscy5nZXRYbWwoYSkrIjwvZGl2PjwvZGl2PiIpLG14VXRpbHMucGFyc2VYbWwoJzxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPicrYSsiPC9kaXY+IikuZG9jdW1lbnRFbGVtZW50O3ZhciBiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIsImRpdiIpO2lmKG14VXRpbHMuaXNOb2RlKGEpKXt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxkPWMuY2xvbmVOb2RlKCExKTt0aGlzLnJvb3Qub3duZXJEb2N1bWVudCE9CmRvY3VtZW50P2MuYXBwZW5kQ2hpbGQoYS5jbG9uZU5vZGUoITApKTpjLmFwcGVuZENoaWxkKGEpO2QuYXBwZW5kQ2hpbGQoYyk7Yi5hcHBlbmRDaGlsZChkKX1lbHNlIGIuaW5uZXJIVE1MPWE7cmV0dXJuIGJ9O214U3ZnQ2FudmFzMkQucHJvdG90eXBlLnVwZGF0ZVRleHQ9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxrLGwsbSxuKXtudWxsIT1uJiZudWxsIT1uLmZpcnN0Q2hpbGQmJm51bGwhPW4uZmlyc3RDaGlsZC5maXJzdENoaWxkJiZ0aGlzLnVwZGF0ZVRleHROb2RlcyhhLGIsYyxkLGUsZixnLGssbCxtLG4uZmlyc3RDaGlsZCl9OwpteFN2Z0NhbnZhczJELnByb3RvdHlwZS5hZGRGb3JlaWduT2JqZWN0PWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayxsLG0sbixwLHEscix0KXtxPXRoaXMuY3JlYXRlRWxlbWVudCgiZyIpO3ZhciB1PXRoaXMuY3JlYXRlRWxlbWVudCgiZm9yZWlnbk9iamVjdCIpO3Uuc2V0QXR0cmlidXRlKCJzdHlsZSIsIm92ZXJmbG93OiB2aXNpYmxlOyB0ZXh0LWFsaWduOiBsZWZ0OyIpO3Uuc2V0QXR0cmlidXRlKCJwb2ludGVyLWV2ZW50cyIsIm5vbmUiKTtyLm93bmVyRG9jdW1lbnQhPWRvY3VtZW50JiYocj1teFV0aWxzLmltcG9ydE5vZGVJbXBsZW1lbnRhdGlvbih1Lm93bmVyRG9jdW1lbnQsciwhMCkpO3UuYXBwZW5kQ2hpbGQocik7cS5hcHBlbmRDaGlsZCh1KTt0aGlzLnVwZGF0ZVRleHROb2RlcyhhLGIsYyxkLGYsZyxrLG0sbixwLHEpO3RoaXMucm9vdC5vd25lckRvY3VtZW50IT1kb2N1bWVudCYmKGE9dGhpcy5jcmVhdGVBbHRlcm5hdGVDb250ZW50KHUsYSxiLGMsZCxlLGYsZyxrLGwsCm0sbixwKSxudWxsIT1hJiYodS5zZXRBdHRyaWJ1dGUoInJlcXVpcmVkRmVhdHVyZXMiLCJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiKSxiPXRoaXMuY3JlYXRlRWxlbWVudCgic3dpdGNoIiksYi5hcHBlbmRDaGlsZCh1KSxiLmFwcGVuZENoaWxkKGEpLHEuYXBwZW5kQ2hpbGQoYikpKTt0LmFwcGVuZENoaWxkKHEpfTsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUudXBkYXRlVGV4dE5vZGVzPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayxsLG0sbil7dmFyIHA9dGhpcy5zdGF0ZS5zY2FsZTtteFN2Z0NhbnZhczJELmNyZWF0ZUNzcyhjKzIsZCxlLGYsZyxrLGwsbnVsbCE9dGhpcy5zdGF0ZS5mb250QmFja2dyb3VuZENvbG9yP3RoaXMuc3RhdGUuZm9udEJhY2tncm91bmRDb2xvcjpudWxsLG51bGwhPXRoaXMuc3RhdGUuZm9udEJvcmRlckNvbG9yP3RoaXMuc3RhdGUuZm9udEJvcmRlckNvbG9yOm51bGwsImRpc3BsYXk6IGZsZXg7IGFsaWduLWl0ZW1zOiB1bnNhZmUgIisoZj09bXhDb25zdGFudHMuQUxJR05fVE9QPyJmbGV4LXN0YXJ0IjpmPT1teENvbnN0YW50cy5BTElHTl9CT1RUT00/ImZsZXgtZW5kIjoiY2VudGVyIikrIjsganVzdGlmeS1jb250ZW50OiB1bnNhZmUgIisoZT09bXhDb25zdGFudHMuQUxJR05fTEVGVD8iZmxleC1zdGFydCI6ZT09bXhDb25zdGFudHMuQUxJR05fUklHSFQ/ImZsZXgtZW5kIjoKImNlbnRlciIpKyI7ICIsdGhpcy5nZXRUZXh0Q3NzKCkscCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihjLGQsZSxmLGcpe2ErPXRoaXMuc3RhdGUuZHg7Yis9dGhpcy5zdGF0ZS5keTt2YXIgaz1uLmZpcnN0Q2hpbGQsbD1rLmZpcnN0Q2hpbGQscT1sLmZpcnN0Q2hpbGQscj0odGhpcy5yb3RhdGVIdG1sP3RoaXMuc3RhdGUucm90YXRpb246MCkrKG51bGwhPW0/bTowKSx0PSgwIT10aGlzLmZvT2Zmc2V0PyJ0cmFuc2xhdGUoIit0aGlzLmZvT2Zmc2V0KyIgIit0aGlzLmZvT2Zmc2V0KyIpIjoiIikrKDEhPXA/InNjYWxlKCIrcCsiKSI6IiIpO3EuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoInN0eWxlIixnKTtxLnNldEF0dHJpYnV0ZSgic3R5bGUiLGYpO2suc2V0QXR0cmlidXRlKCJ3aWR0aCIsTWF0aC5jZWlsKDEvTWF0aC5taW4oMSxwKSoxMDApKyIlIik7ay5zZXRBdHRyaWJ1dGUoImhlaWdodCIsTWF0aC5jZWlsKDEvTWF0aC5taW4oMSxwKSoxMDApKyIlIik7ZD1NYXRoLnJvdW5kKGIrCmQpOzA+ZD9rLnNldEF0dHJpYnV0ZSgieSIsZCk6KGsucmVtb3ZlQXR0cmlidXRlKCJ5IiksZSs9InBhZGRpbmctdG9wOiAiK2QrInB4OyAiKTtsLnNldEF0dHJpYnV0ZSgic3R5bGUiLGUrIm1hcmdpbi1sZWZ0OiAiK01hdGgucm91bmQoYStjKSsicHg7Iik7dCs9MCE9cj8icm90YXRlKCIrcisiICIrYSsiICIrYisiKSI6IiI7IiIhPXQ/bi5zZXRBdHRyaWJ1dGUoInRyYW5zZm9ybSIsdCk6bi5yZW1vdmVBdHRyaWJ1dGUoInRyYW5zZm9ybSIpOzEhPXRoaXMuc3RhdGUuYWxwaGE/bi5zZXRBdHRyaWJ1dGUoIm9wYWNpdHkiLHRoaXMuc3RhdGUuYWxwaGEpOm4ucmVtb3ZlQXR0cmlidXRlKCJvcGFjaXR5Iil9KSl9OwpteFN2Z0NhbnZhczJELmNyZWF0ZUNzcz1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGssbCxtLG4scCxxKXtwPSJib3gtc2l6aW5nOiBib3JkZXItYm94OyBmb250LXNpemU6IDA7IHRleHQtYWxpZ246ICIrKGM9PW14Q29uc3RhbnRzLkFMSUdOX0xFRlQ/ImxlZnQiOmM9PW14Q29uc3RhbnRzLkFMSUdOX1JJR0hUPyJyaWdodCI6ImNlbnRlciIpKyI7ICI7dmFyIHI9bXhVdGlscy5nZXRBbGlnbm1lbnRBc1BvaW50KGMsZCk7Yz0ib3ZlcmZsb3c6IGhpZGRlbjsgIjtkPSJ3aWR0aDogMXB4OyAiO3ZhciB0PSJoZWlnaHQ6IDFweDsgIix1PXIueCphLHI9ci55KmI7Zz8oZD0id2lkdGg6ICIrTWF0aC5yb3VuZChhKSsicHg7ICIscCs9Im1heC1oZWlnaHQ6ICIrTWF0aC5yb3VuZChiKSsicHg7ICIscj0wKToiZmlsbCI9PWY/KGQ9IndpZHRoOiAiK01hdGgucm91bmQoYSkrInB4OyAiLHQ9ImhlaWdodDogIitNYXRoLnJvdW5kKGIpKyJweDsgIixuKz0id2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgIiwKcCs9ZCt0KToid2lkdGgiPT1mPyhkPSJ3aWR0aDogIitNYXRoLnJvdW5kKGEpKyJweDsgIixuKz0id2lkdGg6IDEwMCU7ICIscCs9ZCxyPTAsMDxiJiYocCs9Im1heC1oZWlnaHQ6ICIrTWF0aC5yb3VuZChiKSsicHg7ICIpKTooYz0iIixyPTApO2I9IiI7bnVsbCE9ayYmKGIrPSJiYWNrZ3JvdW5kLWNvbG9yOiAiK2srIjsgIik7bnVsbCE9bCYmKGIrPSJib3JkZXI6IDFweCBzb2xpZCAiK2wrIjsgIik7IiI9PWN8fGc/bis9YjpwKz1iO2UmJjA8YT8obis9IndoaXRlLXNwYWNlOiBub3JtYWw7IHdvcmQtd3JhcDogIitteENvbnN0YW50cy5XT1JEX1dSQVArIjsgIixkPSJ3aWR0aDogIitNYXRoLnJvdW5kKGEpKyJweDsgIiwiIiE9YyYmImZpbGwiIT1mJiYocj0wKSk6KG4rPSJ3aGl0ZS1zcGFjZTogbm93cmFwOyAiLCIiPT1jJiYodT0wKSk7cSh1LHIsbStkK3QscCtjLG4sYyl9OwpteFN2Z0NhbnZhczJELnByb3RvdHlwZS5nZXRUZXh0Q3NzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5zdGF0ZSxiPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGZvbnQtc2l6ZTogIithLmZvbnRTaXplKyJweDsgZm9udC1mYW1pbHk6ICIrYS5mb250RmFtaWx5KyI7IGNvbG9yOiAiK2EuZm9udENvbG9yKyI7IGxpbmUtaGVpZ2h0OiAiKyhteENvbnN0YW50cy5BQlNPTFVURV9MSU5FX0hFSUdIVD9hLmZvbnRTaXplKm14Q29uc3RhbnRzLkxJTkVfSEVJR0hUKyJweCI6bXhDb25zdGFudHMuTElORV9IRUlHSFQqdGhpcy5saW5lSGVpZ2h0Q29ycmVjdGlvbikrIjsgcG9pbnRlci1ldmVudHM6ICIrKHRoaXMucG9pbnRlckV2ZW50cz90aGlzLnBvaW50ZXJFdmVudHNWYWx1ZToibm9uZSIpKyI7ICI7KGEuZm9udFN0eWxlJm14Q29uc3RhbnRzLkZPTlRfQk9MRCk9PW14Q29uc3RhbnRzLkZPTlRfQk9MRCYmKGIrPSJmb250LXdlaWdodDogYm9sZDsgIik7KGEuZm9udFN0eWxlJm14Q29uc3RhbnRzLkZPTlRfSVRBTElDKT09Cm14Q29uc3RhbnRzLkZPTlRfSVRBTElDJiYoYis9ImZvbnQtc3R5bGU6IGl0YWxpYzsgIik7dmFyIGM9W107KGEuZm9udFN0eWxlJm14Q29uc3RhbnRzLkZPTlRfVU5ERVJMSU5FKT09bXhDb25zdGFudHMuRk9OVF9VTkRFUkxJTkUmJmMucHVzaCgidW5kZXJsaW5lIik7KGEuZm9udFN0eWxlJm14Q29uc3RhbnRzLkZPTlRfU1RSSUtFVEhST1VHSCk9PW14Q29uc3RhbnRzLkZPTlRfU1RSSUtFVEhST1VHSCYmYy5wdXNoKCJsaW5lLXRocm91Z2giKTswPGMubGVuZ3RoJiYoYis9InRleHQtZGVjb3JhdGlvbjogIitjLmpvaW4oIiAiKSsiOyAiKTtyZXR1cm4gYn07Cm14U3ZnQ2FudmFzMkQucHJvdG90eXBlLnRleHQ9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxrLGwsbSxuLHAscSl7aWYodGhpcy50ZXh0RW5hYmxlZCYmbnVsbCE9ZSlpZihwPW51bGwhPXA/cDowLHRoaXMuZm9FbmFibGVkJiYiaHRtbCI9PWwpe3ZhciByPXRoaXMuY3JlYXRlRGl2KGUpO251bGwhPXImJihudWxsIT1xJiZyLnNldEF0dHJpYnV0ZSgiZGlyIixxKSx0aGlzLmFkZEZvcmVpZ25PYmplY3QoYSxiLGMsZCxlLGYsZyxrLGwsbSxuLHAscSxyLHRoaXMucm9vdCkpfWVsc2UgdGhpcy5wbGFpblRleHQoYSt0aGlzLnN0YXRlLmR4LGIrdGhpcy5zdGF0ZS5keSxjLGQsZSxmLGcsayxtLG4scCxxKX07Cm14U3ZnQ2FudmFzMkQucHJvdG90eXBlLmNyZWF0ZUNsaXA9ZnVuY3Rpb24oYSxiLGMsZCl7YT1NYXRoLnJvdW5kKGEpO2I9TWF0aC5yb3VuZChiKTtjPU1hdGgucm91bmQoYyk7ZD1NYXRoLnJvdW5kKGQpO2Zvcih2YXIgZT0ibXgtY2xpcC0iK2ErIi0iK2IrIi0iK2MrIi0iK2QsZj0wLGc9ZSsiLSIrZjtudWxsIT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChnKTspZz1lKyItIisgKytmO2NsaXA9dGhpcy5jcmVhdGVFbGVtZW50KCJjbGlwUGF0aCIpO2NsaXAuc2V0QXR0cmlidXRlKCJpZCIsZyk7ZT10aGlzLmNyZWF0ZUVsZW1lbnQoInJlY3QiKTtlLnNldEF0dHJpYnV0ZSgieCIsYSk7ZS5zZXRBdHRyaWJ1dGUoInkiLGIpO2Uuc2V0QXR0cmlidXRlKCJ3aWR0aCIsYyk7ZS5zZXRBdHRyaWJ1dGUoImhlaWdodCIsZCk7Y2xpcC5hcHBlbmRDaGlsZChlKTtyZXR1cm4gY2xpcH07Cm14U3ZnQ2FudmFzMkQucHJvdG90eXBlLnBsYWluVGV4dD1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGssbCxtLG4scCl7bj1udWxsIT1uP246MDtrPXRoaXMuc3RhdGU7dmFyIHE9ay5mb250U2l6ZSxyPXRoaXMuY3JlYXRlRWxlbWVudCgiZyIpLHQ9ay50cmFuc2Zvcm18fCIiO3RoaXMudXBkYXRlRm9udChyKTswIT1uJiYodCs9InJvdGF0ZSgiK24rIiwiK3RoaXMuZm9ybWF0KGEqay5zY2FsZSkrIiwiK3RoaXMuZm9ybWF0KGIqay5zY2FsZSkrIikiKTtudWxsIT1wJiZyLnNldEF0dHJpYnV0ZSgiZGlyZWN0aW9uIixwKTttJiYwPGMmJjA8ZCYmKHA9YSxuPWIsZj09bXhDb25zdGFudHMuQUxJR05fQ0VOVEVSP3AtPWMvMjpmPT1teENvbnN0YW50cy5BTElHTl9SSUdIVCYmKHAtPWMpLCJmaWxsIiE9bCYmKGc9PW14Q29uc3RhbnRzLkFMSUdOX01JRERMRT9uLT1kLzI6Zz09bXhDb25zdGFudHMuQUxJR05fQk9UVE9NJiYobi09ZCkpLG49dGhpcy5jcmVhdGVDbGlwKHAqay5zY2FsZS0yLApuKmsuc2NhbGUtMixjKmsuc2NhbGUrNCxkKmsuc2NhbGUrNCksbnVsbCE9dGhpcy5kZWZzP3RoaXMuZGVmcy5hcHBlbmRDaGlsZChuKTp0aGlzLnJvb3QuYXBwZW5kQ2hpbGQobiksbXhDbGllbnQuSVNfQ0hST01FQVBQfHxteENsaWVudC5JU19JRXx8bXhDbGllbnQuSVNfSUUxMXx8bXhDbGllbnQuSVNfRURHRXx8dGhpcy5yb290Lm93bmVyRG9jdW1lbnQhPWRvY3VtZW50P3Iuc2V0QXR0cmlidXRlKCJjbGlwLXBhdGgiLCJ1cmwoIyIrbi5nZXRBdHRyaWJ1dGUoImlkIikrIikiKToocD10aGlzLmdldEJhc2VVcmwoKS5yZXBsYWNlKC8oW1woXCldKS9nLCJcXCQxIiksci5zZXRBdHRyaWJ1dGUoImNsaXAtcGF0aCIsInVybCgiK3ArIiMiK24uZ2V0QXR0cmlidXRlKCJpZCIpKyIpIikpKTtuPWY9PW14Q29uc3RhbnRzLkFMSUdOX1JJR0hUPyJlbmQiOmY9PW14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUj8ibWlkZGxlIjoic3RhcnQiOyJzdGFydCIhPW4mJnIuc2V0QXR0cmlidXRlKCJ0ZXh0LWFuY2hvciIsCm4pO3RoaXMuc3R5bGVFbmFibGVkJiZxPT1teENvbnN0YW50cy5ERUZBVUxUX0ZPTlRTSVpFfHxyLnNldEF0dHJpYnV0ZSgiZm9udC1zaXplIixxKmsuc2NhbGUrInB4Iik7MDx0Lmxlbmd0aCYmci5zZXRBdHRyaWJ1dGUoInRyYW5zZm9ybSIsdCk7MT5rLmFscGhhJiZyLnNldEF0dHJpYnV0ZSgib3BhY2l0eSIsay5hbHBoYSk7dD1lLnNwbGl0KCJcbiIpO3A9TWF0aC5yb3VuZChxKm14Q29uc3RhbnRzLkxJTkVfSEVJR0hUKTt2YXIgdT1xKyh0Lmxlbmd0aC0xKSpwO249YitxLTE7Zz09bXhDb25zdGFudHMuQUxJR05fTUlERExFPyJmaWxsIj09bD9uLT1kLzI6KG09KHRoaXMubWF0Y2hIdG1sQWxpZ25tZW50JiZtJiYwPGQ/TWF0aC5taW4odSxkKTp1KS8yLG4tPW0pOmc9PW14Q29uc3RhbnRzLkFMSUdOX0JPVFRPTSYmKCJmaWxsIj09bD9uLT1kOihtPXRoaXMubWF0Y2hIdG1sQWxpZ25tZW50JiZtJiYwPGQ/TWF0aC5taW4odSxkKTp1LG4tPW0rMSkpO2ZvcihtPTA7bTx0Lmxlbmd0aDttKyspMDwKdFttXS5sZW5ndGgmJjA8bXhVdGlscy50cmltKHRbbV0pLmxlbmd0aCYmKHE9dGhpcy5jcmVhdGVFbGVtZW50KCJ0ZXh0IikscS5zZXRBdHRyaWJ1dGUoIngiLHRoaXMuZm9ybWF0KGEqay5zY2FsZSkrdGhpcy50ZXh0T2Zmc2V0KSxxLnNldEF0dHJpYnV0ZSgieSIsdGhpcy5mb3JtYXQobiprLnNjYWxlKSt0aGlzLnRleHRPZmZzZXQpLG14VXRpbHMud3JpdGUocSx0W21dKSxyLmFwcGVuZENoaWxkKHEpKSxuKz1wO3RoaXMucm9vdC5hcHBlbmRDaGlsZChyKTt0aGlzLmFkZFRleHRCYWNrZ3JvdW5kKHIsZSxhLGIsYywiZmlsbCI9PWw/ZDp1LGYsZyxsKX07Cm14U3ZnQ2FudmFzMkQucHJvdG90eXBlLnVwZGF0ZUZvbnQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5zdGF0ZTthLnNldEF0dHJpYnV0ZSgiZmlsbCIsYi5mb250Q29sb3IpO3RoaXMuc3R5bGVFbmFibGVkJiZiLmZvbnRGYW1pbHk9PW14Q29uc3RhbnRzLkRFRkFVTFRfRk9OVEZBTUlMWXx8YS5zZXRBdHRyaWJ1dGUoImZvbnQtZmFtaWx5IixiLmZvbnRGYW1pbHkpOyhiLmZvbnRTdHlsZSZteENvbnN0YW50cy5GT05UX0JPTEQpPT1teENvbnN0YW50cy5GT05UX0JPTEQmJmEuc2V0QXR0cmlidXRlKCJmb250LXdlaWdodCIsImJvbGQiKTsoYi5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9JVEFMSUMpPT1teENvbnN0YW50cy5GT05UX0lUQUxJQyYmYS5zZXRBdHRyaWJ1dGUoImZvbnQtc3R5bGUiLCJpdGFsaWMiKTt2YXIgYz1bXTsoYi5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9VTkRFUkxJTkUpPT1teENvbnN0YW50cy5GT05UX1VOREVSTElORSYmYy5wdXNoKCJ1bmRlcmxpbmUiKTsKKGIuZm9udFN0eWxlJm14Q29uc3RhbnRzLkZPTlRfU1RSSUtFVEhST1VHSCk9PW14Q29uc3RhbnRzLkZPTlRfU1RSSUtFVEhST1VHSCYmYy5wdXNoKCJsaW5lLXRocm91Z2giKTswPGMubGVuZ3RoJiZhLnNldEF0dHJpYnV0ZSgidGV4dC1kZWNvcmF0aW9uIixjLmpvaW4oIiAiKSl9OwpteFN2Z0NhbnZhczJELnByb3RvdHlwZS5hZGRUZXh0QmFja2dyb3VuZD1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGssbCl7dmFyIG09dGhpcy5zdGF0ZTtpZihudWxsIT1tLmZvbnRCYWNrZ3JvdW5kQ29sb3J8fG51bGwhPW0uZm9udEJvcmRlckNvbG9yKXt2YXIgbj1udWxsO2lmKCJmaWxsIj09bHx8IndpZHRoIj09bClnPT1teENvbnN0YW50cy5BTElHTl9DRU5URVI/Yy09ZS8yOmc9PW14Q29uc3RhbnRzLkFMSUdOX1JJR0hUJiYoYy09ZSksaz09bXhDb25zdGFudHMuQUxJR05fTUlERExFP2QtPWYvMjprPT1teENvbnN0YW50cy5BTElHTl9CT1RUT00mJihkLT1mKSxuPW5ldyBteFJlY3RhbmdsZSgoYysxKSptLnNjYWxlLGQqbS5zY2FsZSwoZS0yKSptLnNjYWxlLChmKzIpKm0uc2NhbGUpO2Vsc2UgaWYobnVsbCE9YS5nZXRCQm94JiZ0aGlzLnJvb3Qub3duZXJEb2N1bWVudD09ZG9jdW1lbnQpdHJ5e3ZhciBuPWEuZ2V0QkJveCgpLHA9bXhDbGllbnQuSVNfSUUmJm14Q2xpZW50LklTX1NWRywKbj1uZXcgbXhSZWN0YW5nbGUobi54LG4ueSsocD8wOjEpLG4ud2lkdGgsbi5oZWlnaHQrKHA/MTowKSl9Y2F0Y2gocSl7fWVsc2Ugbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxuLnN0eWxlLmxpbmVIZWlnaHQ9bXhDb25zdGFudHMuQUJTT0xVVEVfTElORV9IRUlHSFQ/bS5mb250U2l6ZSpteENvbnN0YW50cy5MSU5FX0hFSUdIVCsicHgiOm14Q29uc3RhbnRzLkxJTkVfSEVJR0hULG4uc3R5bGUuZm9udFNpemU9bS5mb250U2l6ZSsicHgiLG4uc3R5bGUuZm9udEZhbWlseT1tLmZvbnRGYW1pbHksbi5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiLG4uc3R5bGUucG9zaXRpb249ImFic29sdXRlIixuLnN0eWxlLnZpc2liaWxpdHk9ImhpZGRlbiIsbi5zdHlsZS5kaXNwbGF5PW14Q2xpZW50LklTX1FVSVJLUz8iaW5saW5lIjoiaW5saW5lLWJsb2NrIixuLnN0eWxlLnpvb209IjEiLChtLmZvbnRTdHlsZSZteENvbnN0YW50cy5GT05UX0JPTEQpPT1teENvbnN0YW50cy5GT05UX0JPTEQmJgoobi5zdHlsZS5mb250V2VpZ2h0PSJib2xkIiksKG0uZm9udFN0eWxlJm14Q29uc3RhbnRzLkZPTlRfSVRBTElDKT09bXhDb25zdGFudHMuRk9OVF9JVEFMSUMmJihuLnN0eWxlLmZvbnRTdHlsZT0iaXRhbGljIiksYj1teFV0aWxzLmh0bWxFbnRpdGllcyhiLCExKSxuLmlubmVySFRNTD1iLnJlcGxhY2UoL1xuL2csIjxici8+IiksZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChuKSxlPW4ub2Zmc2V0V2lkdGgsZj1uLm9mZnNldEhlaWdodCxuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobiksZz09bXhDb25zdGFudHMuQUxJR05fQ0VOVEVSP2MtPWUvMjpnPT1teENvbnN0YW50cy5BTElHTl9SSUdIVCYmKGMtPWUpLGs9PW14Q29uc3RhbnRzLkFMSUdOX01JRERMRT9kLT1mLzI6az09bXhDb25zdGFudHMuQUxJR05fQk9UVE9NJiYoZC09Ziksbj1uZXcgbXhSZWN0YW5nbGUoKGMrMSkqbS5zY2FsZSwoZCsyKSptLnNjYWxlLGUqbS5zY2FsZSwoZisxKSptLnNjYWxlKTtudWxsIT1uJiYoYj0KdGhpcy5jcmVhdGVFbGVtZW50KCJyZWN0IiksYi5zZXRBdHRyaWJ1dGUoImZpbGwiLG0uZm9udEJhY2tncm91bmRDb2xvcnx8Im5vbmUiKSxiLnNldEF0dHJpYnV0ZSgic3Ryb2tlIixtLmZvbnRCb3JkZXJDb2xvcnx8Im5vbmUiKSxiLnNldEF0dHJpYnV0ZSgieCIsTWF0aC5mbG9vcihuLngtMSkpLGIuc2V0QXR0cmlidXRlKCJ5IixNYXRoLmZsb29yKG4ueS0xKSksYi5zZXRBdHRyaWJ1dGUoIndpZHRoIixNYXRoLmNlaWwobi53aWR0aCsyKSksYi5zZXRBdHRyaWJ1dGUoImhlaWdodCIsTWF0aC5jZWlsKG4uaGVpZ2h0KSksbT1udWxsIT1tLmZvbnRCb3JkZXJDb2xvcj9NYXRoLm1heCgxLHRoaXMuZm9ybWF0KG0uc2NhbGUpKTowLGIuc2V0QXR0cmlidXRlKCJzdHJva2Utd2lkdGgiLG0pLHRoaXMucm9vdC5vd25lckRvY3VtZW50PT1kb2N1bWVudCYmMT09bXhVdGlscy5tb2QobSwyKSYmYi5zZXRBdHRyaWJ1dGUoInRyYW5zZm9ybSIsInRyYW5zbGF0ZSgwLjUsIDAuNSkiKSxhLmluc2VydEJlZm9yZShiLAphLmZpcnN0Q2hpbGQpKX19O214U3ZnQ2FudmFzMkQucHJvdG90eXBlLnN0cm9rZT1mdW5jdGlvbigpe3RoaXMuYWRkTm9kZSghMSwhMCl9O214U3ZnQ2FudmFzMkQucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24oKXt0aGlzLmFkZE5vZGUoITAsITEpfTtteFN2Z0NhbnZhczJELnByb3RvdHlwZS5maWxsQW5kU3Ryb2tlPWZ1bmN0aW9uKCl7dGhpcy5hZGROb2RlKCEwLCEwKX07dmFyIG14Vm1sQ2FudmFzMkQ9ZnVuY3Rpb24oYSl7bXhBYnN0cmFjdENhbnZhczJELmNhbGwodGhpcyk7dGhpcy5yb290PWF9O214VXRpbHMuZXh0ZW5kKG14Vm1sQ2FudmFzMkQsbXhBYnN0cmFjdENhbnZhczJEKTtteFZtbENhbnZhczJELnByb3RvdHlwZS5ub2RlPW51bGw7bXhWbWxDYW52YXMyRC5wcm90b3R5cGUudGV4dEVuYWJsZWQ9ITA7bXhWbWxDYW52YXMyRC5wcm90b3R5cGUubW92ZU9wPSJtIjtteFZtbENhbnZhczJELnByb3RvdHlwZS5saW5lT3A9ImwiOwpteFZtbENhbnZhczJELnByb3RvdHlwZS5jdXJ2ZU9wPSJjIjtteFZtbENhbnZhczJELnByb3RvdHlwZS5jbG9zZU9wPSJ4IjtteFZtbENhbnZhczJELnByb3RvdHlwZS5yb3RhdGVkSHRtbEJhY2tncm91bmQ9IiI7bXhWbWxDYW52YXMyRC5wcm90b3R5cGUudm1sU2NhbGU9MTtteFZtbENhbnZhczJELnByb3RvdHlwZS5jcmVhdGVFbGVtZW50PWZ1bmN0aW9uKGEpe3JldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGEpfTtteFZtbENhbnZhczJELnByb3RvdHlwZS5jcmVhdGVWbWxFbGVtZW50PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmNyZWF0ZUVsZW1lbnQobXhDbGllbnQuVk1MX1BSRUZJWCsiOiIrYSl9OwpteFZtbENhbnZhczJELnByb3RvdHlwZS5hZGROb2RlPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5ub2RlLGQ9dGhpcy5zdGF0ZTtpZihudWxsIT1jKXtpZigic2hhcGUiPT1jLm5vZGVOYW1lKWlmKG51bGwhPXRoaXMucGF0aCYmMDx0aGlzLnBhdGgubGVuZ3RoKWMucGF0aD10aGlzLnBhdGguam9pbigiICIpKyIgZSIsYy5zdHlsZS53aWR0aD10aGlzLnJvb3Quc3R5bGUud2lkdGgsYy5zdHlsZS5oZWlnaHQ9dGhpcy5yb290LnN0eWxlLmhlaWdodCxjLmNvb3Jkc2l6ZT1wYXJzZUludChjLnN0eWxlLndpZHRoKSsiICIrcGFyc2VJbnQoYy5zdHlsZS5oZWlnaHQpO2Vsc2UgcmV0dXJuO2Muc3Ryb2tld2VpZ2h0PXRoaXMuZm9ybWF0KE1hdGgubWF4KDEsZC5zdHJva2VXaWR0aCpkLnNjYWxlL3RoaXMudm1sU2NhbGUpKSsicHgiO2Quc2hhZG93JiZ0aGlzLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVTaGFkb3coYyxhJiZudWxsIT1kLmZpbGxDb2xvcixiJiZudWxsIT1kLnN0cm9rZUNvbG9yKSk7CmImJm51bGwhPWQuc3Ryb2tlQ29sb3I/KGMuc3Ryb2tlZD0idHJ1ZSIsYy5zdHJva2Vjb2xvcj1kLnN0cm9rZUNvbG9yKTpjLnN0cm9rZWQ9ImZhbHNlIjtjLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlU3Ryb2tlKCkpO2EmJm51bGwhPWQuZmlsbENvbG9yP2MuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVGaWxsKCkpOiF0aGlzLnBvaW50ZXJFdmVudHN8fCJzaGFwZSI9PWMubm9kZU5hbWUmJnRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoLTFdIT10aGlzLmNsb3NlT3A/Yy5maWxsZWQ9ImZhbHNlIjpjLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlVHJhbnNwYXJlbnRGaWxsKCkpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChjKX19OwpteFZtbENhbnZhczJELnByb3RvdHlwZS5jcmVhdGVUcmFuc3BhcmVudEZpbGw9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNyZWF0ZVZtbEVsZW1lbnQoImZpbGwiKTthLnNyYz1teENsaWVudC5pbWFnZUJhc2VQYXRoKyIvdHJhbnNwYXJlbnQuZ2lmIjthLnR5cGU9InRpbGUiO3JldHVybiBhfTsKbXhWbWxDYW52YXMyRC5wcm90b3R5cGUuY3JlYXRlRmlsbD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuc3RhdGUsYj10aGlzLmNyZWF0ZVZtbEVsZW1lbnQoImZpbGwiKTtiLmNvbG9yPWEuZmlsbENvbG9yO2lmKG51bGwhPWEuZ3JhZGllbnRDb2xvcil7Yi50eXBlPSJncmFkaWVudCI7Yi5tZXRob2Q9Im5vbmUiO2IuY29sb3IyPWEuZ3JhZGllbnRDb2xvcjt2YXIgYz0xODAtYS5yb3RhdGlvbixjPWEuZ3JhZGllbnREaXJlY3Rpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUP2MtKDkwKygieCI9PXRoaXMucm9vdC5zdHlsZS5mbGlwPzE4MDowKSk6YS5ncmFkaWVudERpcmVjdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1Q/YysoOTArKCJ4Ij09dGhpcy5yb290LnN0eWxlLmZsaXA/MTgwOjApKTphLmdyYWRpZW50RGlyZWN0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEg/Yy0oMTgwKygieSI9PXRoaXMucm9vdC5zdHlsZS5mbGlwPy0xODA6MCkpOmMrKCJ5Ij09CnRoaXMucm9vdC5zdHlsZS5mbGlwPy0xODA6MCk7aWYoIngiPT10aGlzLnJvb3Quc3R5bGUuZmxpcHx8InkiPT10aGlzLnJvb3Quc3R5bGUuZmxpcCljKj0tMTtiLmFuZ2xlPW14VXRpbHMubW9kKGMsMzYwKTtiLm9wYWNpdHk9YS5hbHBoYSphLmdyYWRpZW50RmlsbEFscGhhKjEwMCsiJSI7Yi5zZXRBdHRyaWJ1dGUobXhDbGllbnQuT0ZGSUNFX1BSRUZJWCsiOm9wYWNpdHkyIixhLmFscGhhKmEuZ3JhZGllbnRBbHBoYSoxMDArIiUiKX1lbHNlIGlmKDE+YS5hbHBoYXx8MT5hLmZpbGxBbHBoYSliLm9wYWNpdHk9YS5hbHBoYSphLmZpbGxBbHBoYSoxMDArIiUiO3JldHVybiBifTsKbXhWbWxDYW52YXMyRC5wcm90b3R5cGUuY3JlYXRlU3Ryb2tlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5zdGF0ZSxiPXRoaXMuY3JlYXRlVm1sRWxlbWVudCgic3Ryb2tlIik7Yi5lbmRjYXA9YS5saW5lQ2FwfHwiZmxhdCI7Yi5qb2luc3R5bGU9YS5saW5lSm9pbnx8Im1pdGVyIjtiLm1pdGVybGltaXQ9YS5taXRlckxpbWl0fHwiMTAiO2lmKDE+YS5hbHBoYXx8MT5hLnN0cm9rZUFscGhhKWIub3BhY2l0eT1hLmFscGhhKmEuc3Ryb2tlQWxwaGEqMTAwKyIlIjthLmRhc2hlZCYmKGIuZGFzaHN0eWxlPXRoaXMuZ2V0Vm1sRGFzaFN0eWxlKCkpO3JldHVybiBifTtteFZtbENhbnZhczJELnByb3RvdHlwZS5nZXRWbWxEYXNoU3R5bGU9ZnVuY3Rpb24oKXt2YXIgYT0iZGFzaCI7aWYoInN0cmluZyI9PT10eXBlb2YgdGhpcy5zdGF0ZS5kYXNoUGF0dGVybil7dmFyIGI9dGhpcy5zdGF0ZS5kYXNoUGF0dGVybi5zcGxpdCgiICIpOzA8Yi5sZW5ndGgmJjE9PWJbMF0mJihhPSIwIDIiKX1yZXR1cm4gYX07Cm14Vm1sQ2FudmFzMkQucHJvdG90eXBlLmNyZWF0ZVNoYWRvdz1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5zdGF0ZSxlPU1hdGguUEkvMTgwKi1kLnJvdGF0aW9uLGY9TWF0aC5jb3MoZSksZT1NYXRoLnNpbihlKSxnPWQuc2hhZG93RHgqZC5zY2FsZSxrPWQuc2hhZG93RHkqZC5zY2FsZTsieCI9PXRoaXMucm9vdC5zdHlsZS5mbGlwP2cqPS0xOiJ5Ij09dGhpcy5yb290LnN0eWxlLmZsaXAmJihrKj0tMSk7dmFyIGw9YS5jbG9uZU5vZGUoITApO2wuc3R5bGUubWFyZ2luTGVmdD1NYXRoLnJvdW5kKGcqZi1rKmUpKyJweCI7bC5zdHlsZS5tYXJnaW5Ub3A9TWF0aC5yb3VuZChnKmUraypmKSsicHgiOzg9PWRvY3VtZW50LmRvY3VtZW50TW9kZSYmKGwuc3Ryb2tld2VpZ2h0PWEuc3Ryb2tld2VpZ2h0LCJzaGFwZSI9PWEubm9kZU5hbWUmJihsLnBhdGg9dGhpcy5wYXRoLmpvaW4oIiAiKSsiIGUiLGwuc3R5bGUud2lkdGg9dGhpcy5yb290LnN0eWxlLndpZHRoLGwuc3R5bGUuaGVpZ2h0PQp0aGlzLnJvb3Quc3R5bGUuaGVpZ2h0LGwuY29vcmRzaXplPXBhcnNlSW50KGEuc3R5bGUud2lkdGgpKyIgIitwYXJzZUludChhLnN0eWxlLmhlaWdodCkpKTtjPyhsLnN0cm9rZWNvbG9yPWQuc2hhZG93Q29sb3IsbC5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZVNoYWRvd1N0cm9rZSgpKSk6bC5zdHJva2VkPSJmYWxzZSI7Yj9sLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlU2hhZG93RmlsbCgpKTpsLmZpbGxlZD0iZmFsc2UiO3JldHVybiBsfTtteFZtbENhbnZhczJELnByb3RvdHlwZS5jcmVhdGVTaGFkb3dGaWxsPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jcmVhdGVWbWxFbGVtZW50KCJmaWxsIik7YS5jb2xvcj10aGlzLnN0YXRlLnNoYWRvd0NvbG9yO2Eub3BhY2l0eT10aGlzLnN0YXRlLmFscGhhKnRoaXMuc3RhdGUuc2hhZG93QWxwaGEqMTAwKyIlIjtyZXR1cm4gYX07Cm14Vm1sQ2FudmFzMkQucHJvdG90eXBlLmNyZWF0ZVNoYWRvd1N0cm9rZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuY3JlYXRlU3Ryb2tlKCk7YS5vcGFjaXR5PXRoaXMuc3RhdGUuYWxwaGEqdGhpcy5zdGF0ZS5zaGFkb3dBbHBoYSoxMDArIiUiO3JldHVybiBhfTtteFZtbENhbnZhczJELnByb3RvdHlwZS5yb3RhdGU9ZnVuY3Rpb24oYSxiLGMsZCxlKXtiJiZjP2ErPTE4MDpiP3RoaXMucm9vdC5zdHlsZS5mbGlwPSJ4IjpjJiYodGhpcy5yb290LnN0eWxlLmZsaXA9InkiKTtpZihiPyFjOmMpYSo9LTE7dGhpcy5yb290LnN0eWxlLnJvdGF0aW9uPWE7dGhpcy5zdGF0ZS5yb3RhdGlvbis9YTt0aGlzLnN0YXRlLnJvdGF0aW9uQ3g9ZDt0aGlzLnN0YXRlLnJvdGF0aW9uQ3k9ZX07Cm14Vm1sQ2FudmFzMkQucHJvdG90eXBlLmJlZ2luPWZ1bmN0aW9uKCl7bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5iZWdpbi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy5ub2RlPXRoaXMuY3JlYXRlVm1sRWxlbWVudCgic2hhcGUiKTt0aGlzLm5vZGUuc3R5bGUucG9zaXRpb249ImFic29sdXRlIn07Cm14Vm1sQ2FudmFzMkQucHJvdG90eXBlLnF1YWRUbz1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLnN0YXRlLGY9KHRoaXMubGFzdFgrZS5keCkqZS5zY2FsZSxnPSh0aGlzLmxhc3RZK2UuZHkpKmUuc2NhbGU7YT0oYStlLmR4KSplLnNjYWxlO2I9KGIrZS5keSkqZS5zY2FsZTtjPShjK2UuZHgpKmUuc2NhbGU7ZD0oZCtlLmR5KSplLnNjYWxlO3ZhciBnPWcrMi8zKihiLWcpLGs9YysyLzMqKGEtYyk7Yj1kKzIvMyooYi1kKTt0aGlzLnBhdGgucHVzaCgiYyAiK3RoaXMuZm9ybWF0KGYrMi8zKihhLWYpKSsiICIrdGhpcy5mb3JtYXQoZykrIiAiK3RoaXMuZm9ybWF0KGspKyIgIit0aGlzLmZvcm1hdChiKSsiICIrdGhpcy5mb3JtYXQoYykrIiAiK3RoaXMuZm9ybWF0KGQpKTt0aGlzLmxhc3RYPWMvZS5zY2FsZS1lLmR4O3RoaXMubGFzdFk9ZC9lLnNjYWxlLWUuZHl9OwpteFZtbENhbnZhczJELnByb3RvdHlwZS5jcmVhdGVSZWN0PWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9dGhpcy5zdGF0ZTthPXRoaXMuY3JlYXRlVm1sRWxlbWVudChhKTthLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7YS5zdHlsZS5sZWZ0PXRoaXMuZm9ybWF0KChiK2YuZHgpKmYuc2NhbGUpKyJweCI7YS5zdHlsZS50b3A9dGhpcy5mb3JtYXQoKGMrZi5keSkqZi5zY2FsZSkrInB4IjthLnN0eWxlLndpZHRoPXRoaXMuZm9ybWF0KGQqZi5zY2FsZSkrInB4IjthLnN0eWxlLmhlaWdodD10aGlzLmZvcm1hdChlKmYuc2NhbGUpKyJweCI7cmV0dXJuIGF9O214Vm1sQ2FudmFzMkQucHJvdG90eXBlLnJlY3Q9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5ub2RlPXRoaXMuY3JlYXRlUmVjdCgicmVjdCIsYSxiLGMsZCl9OwpteFZtbENhbnZhczJELnByb3RvdHlwZS5yb3VuZHJlY3Q9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3RoaXMubm9kZT10aGlzLmNyZWF0ZVJlY3QoInJvdW5kcmVjdCIsYSxiLGMsZCk7dGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgiYXJjc2l6ZSIsTWF0aC5tYXgoMTAwKmUvYywxMDAqZi9kKSsiJSIpfTtteFZtbENhbnZhczJELnByb3RvdHlwZS5lbGxpcHNlPWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMubm9kZT10aGlzLmNyZWF0ZVJlY3QoIm92YWwiLGEsYixjLGQpfTsKbXhWbWxDYW52YXMyRC5wcm90b3R5cGUuaW1hZ2U9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxrKXtmPyhhPXRoaXMuY3JlYXRlUmVjdCgicmVjdCIsYSxiLGMsZCksYS5zdHJva2VkPSJmYWxzZSIsYj10aGlzLmNyZWF0ZVZtbEVsZW1lbnQoImZpbGwiKSxiLmFzcGVjdD1mPyJhdG1vc3QiOiJpZ25vcmUiLGIucm90YXRlPSJ0cnVlIixiLnR5cGU9ImZyYW1lIixiLnNyYz1lLGEuYXBwZW5kQ2hpbGQoYikpOihhPXRoaXMuY3JlYXRlUmVjdCgiaW1hZ2UiLGEsYixjLGQpLGEuc3JjPWUpO2cmJms/YS5zdHlsZS5yb3RhdGlvbj0iMTgwIjpnP2Euc3R5bGUuZmxpcD0ieCI6ayYmKGEuc3R5bGUuZmxpcD0ieSIpO2lmKDE+dGhpcy5zdGF0ZS5hbHBoYXx8MT50aGlzLnN0YXRlLmZpbGxBbHBoYSlhLnN0eWxlLmZpbHRlcis9ImFscGhhKG9wYWNpdHk9Iit0aGlzLnN0YXRlLmFscGhhKnRoaXMuc3RhdGUuZmlsbEFscGhhKjEwMCsiKSI7dGhpcy5yb290LmFwcGVuZENoaWxkKGEpfTsKbXhWbWxDYW52YXMyRC5wcm90b3R5cGUuY3JlYXRlRGl2PWZ1bmN0aW9uKGEsYixjLGQpe2M9dGhpcy5jcmVhdGVFbGVtZW50KCJkaXYiKTt2YXIgZT10aGlzLnN0YXRlLGY9IiI7bnVsbCE9ZS5mb250QmFja2dyb3VuZENvbG9yJiYoZis9ImJhY2tncm91bmQtY29sb3I6IitteFV0aWxzLmh0bWxFbnRpdGllcyhlLmZvbnRCYWNrZ3JvdW5kQ29sb3IpKyI7Iik7bnVsbCE9ZS5mb250Qm9yZGVyQ29sb3ImJihmKz0iYm9yZGVyOjFweCBzb2xpZCAiK214VXRpbHMuaHRtbEVudGl0aWVzKGUuZm9udEJvcmRlckNvbG9yKSsiOyIpO214VXRpbHMuaXNOb2RlKGEpP2MuYXBwZW5kQ2hpbGQoYSk6ImZpbGwiIT1kJiYid2lkdGgiIT1kPyhkPXRoaXMuY3JlYXRlRWxlbWVudCgiZGl2IiksZC5zdHlsZS5jc3NUZXh0PWYsZC5zdHlsZS5kaXNwbGF5PW14Q2xpZW50LklTX1FVSVJLUz8iaW5saW5lIjoiaW5saW5lLWJsb2NrIixkLnN0eWxlLnpvb209IjEiLGQuc3R5bGUudGV4dERlY29yYXRpb249CiJpbmhlcml0IixkLmlubmVySFRNTD1hLGMuYXBwZW5kQ2hpbGQoZCkpOihjLnN0eWxlLmNzc1RleHQ9ZixjLmlubmVySFRNTD1hKTthPWMuc3R5bGU7YS5mb250U2l6ZT1lLmZvbnRTaXplL3RoaXMudm1sU2NhbGUrInB4IjthLmZvbnRGYW1pbHk9ZS5mb250RmFtaWx5O2EuY29sb3I9ZS5mb250Q29sb3I7YS52ZXJ0aWNhbEFsaWduPSJ0b3AiO2EudGV4dEFsaWduPWJ8fCJsZWZ0IjthLmxpbmVIZWlnaHQ9bXhDb25zdGFudHMuQUJTT0xVVEVfTElORV9IRUlHSFQ/ZS5mb250U2l6ZSpteENvbnN0YW50cy5MSU5FX0hFSUdIVC90aGlzLnZtbFNjYWxlKyJweCI6bXhDb25zdGFudHMuTElORV9IRUlHSFQ7KGUuZm9udFN0eWxlJm14Q29uc3RhbnRzLkZPTlRfQk9MRCk9PW14Q29uc3RhbnRzLkZPTlRfQk9MRCYmKGEuZm9udFdlaWdodD0iYm9sZCIpOyhlLmZvbnRTdHlsZSZteENvbnN0YW50cy5GT05UX0lUQUxJQyk9PW14Q29uc3RhbnRzLkZPTlRfSVRBTElDJiYoYS5mb250U3R5bGU9Iml0YWxpYyIpOwooZS5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9VTkRFUkxJTkUpPT1teENvbnN0YW50cy5GT05UX1VOREVSTElORSYmKGEudGV4dERlY29yYXRpb249InVuZGVybGluZSIpO3JldHVybiBjfTsKbXhWbWxDYW52YXMyRC5wcm90b3R5cGUudGV4dD1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGssbCxtLG4scCxxKXtpZih0aGlzLnRleHRFbmFibGVkJiZudWxsIT1lKXt2YXIgcj10aGlzLnN0YXRlO2lmKCJodG1sIj09bCl7bnVsbCE9ci5yb3RhdGlvbiYmKGI9dGhpcy5yb3RhdGVQb2ludChhLGIsci5yb3RhdGlvbixyLnJvdGF0aW9uQ3gsci5yb3RhdGlvbkN5KSxhPWIueCxiPWIueSk7OCE9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHxteENsaWVudC5JU19FTT8oYSo9ci5zY2FsZSxiKj1yLnNjYWxlKTooYSs9ci5keCxiKz1yLmR5LCJmaWxsIiE9bSYmZz09bXhDb25zdGFudHMuQUxJR05fVE9QJiYtLWIpO2w9OCE9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHxteENsaWVudC5JU19FTT90aGlzLmNyZWF0ZUVsZW1lbnQoImRpdiIpOnRoaXMuY3JlYXRlVm1sRWxlbWVudCgiZ3JvdXAiKTtsLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7bC5zdHlsZS5kaXNwbGF5PSJpbmxpbmUiO2wuc3R5bGUubGVmdD0KdGhpcy5mb3JtYXQoYSkrInB4IjtsLnN0eWxlLnRvcD10aGlzLmZvcm1hdChiKSsicHgiO2wuc3R5bGUuem9vbT1yLnNjYWxlO3ZhciB0PXRoaXMuY3JlYXRlRWxlbWVudCgiZGl2Iik7dC5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiO3Quc3R5bGUuZGlzcGxheT0iaW5saW5lIjt2YXIgdT1teFV0aWxzLmdldEFsaWdubWVudEFzUG9pbnQoZixnKSx4PXUueCx1PXUueTtlPXRoaXMuY3JlYXRlRGl2KGUsZixnLG0pO2Y9dGhpcy5jcmVhdGVFbGVtZW50KCJkaXYiKTtudWxsIT1xJiZlLnNldEF0dHJpYnV0ZSgiZGlyIixxKTtpZihrJiYwPGMpe2lmKG58fChlLnN0eWxlLndpZHRoPU1hdGgucm91bmQoYykrInB4IiksZS5zdHlsZS53b3JkV3JhcD1teENvbnN0YW50cy5XT1JEX1dSQVAsZS5zdHlsZS53aGl0ZVNwYWNlPSJub3JtYWwiLCJicmVhay13b3JkIj09ZS5zdHlsZS53b3JkV3JhcCl7dmFyIHk9ZTtudWxsIT15LmZpcnN0Q2hpbGQmJiJESVYiPT15LmZpcnN0Q2hpbGQubm9kZU5hbWUmJgooeS5maXJzdENoaWxkLnN0eWxlLndpZHRoPSIxMDAlIil9fWVsc2UgZS5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiO3A9ci5yb3RhdGlvbisocHx8MCk7dGhpcy5yb3RhdGVIdG1sJiYwIT1wPyhmLnN0eWxlLmRpc3BsYXk9ImlubGluZSIsZi5zdHlsZS56b29tPSIxIixmLmFwcGVuZENoaWxkKGUpLDghPWRvY3VtZW50LmRvY3VtZW50TW9kZXx8bXhDbGllbnQuSVNfRU18fCJESVYiPT10aGlzLnJvb3Qubm9kZU5hbWU/bC5hcHBlbmRDaGlsZChmKToodC5hcHBlbmRDaGlsZChmKSxsLmFwcGVuZENoaWxkKHQpKSk6OCE9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHxteENsaWVudC5JU19FTT8oZS5zdHlsZS5kaXNwbGF5PSJpbmxpbmUiLGwuYXBwZW5kQ2hpbGQoZSkpOih0LmFwcGVuZENoaWxkKGUpLGwuYXBwZW5kQ2hpbGQodCkpOyJESVYiIT10aGlzLnJvb3Qubm9kZU5hbWU/KHE9dGhpcy5jcmVhdGVWbWxFbGVtZW50KCJyZWN0IikscS5zdHJva2VkPSJmYWxzZSIscS5maWxsZWQ9ImZhbHNlIiwKcS5hcHBlbmRDaGlsZChsKSx0aGlzLnJvb3QuYXBwZW5kQ2hpbGQocSkpOnRoaXMucm9vdC5hcHBlbmRDaGlsZChsKTtuPyhlLnN0eWxlLm92ZXJmbG93PSJoaWRkZW4iLGUuc3R5bGUud2lkdGg9TWF0aC5yb3VuZChjKSsicHgiLG14Q2xpZW50LklTX1FVSVJLU3x8KGUuc3R5bGUubWF4SGVpZ2h0PU1hdGgucm91bmQoZCkrInB4IikpOiJmaWxsIj09bT8oZS5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIixlLnN0eWxlLndpZHRoPU1hdGgubWF4KDAsYykrMSsicHgiLGUuc3R5bGUuaGVpZ2h0PU1hdGgubWF4KDAsZCkrMSsicHgiKToid2lkdGgiPT1tJiYoZS5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIixlLnN0eWxlLndpZHRoPU1hdGgubWF4KDAsYykrMSsicHgiLGUuc3R5bGUubWF4SGVpZ2h0PU1hdGgubWF4KDAsZCkrMSsicHgiKTtpZih0aGlzLnJvdGF0ZUh0bWwmJjAhPXApe3k9TWF0aC5QSS8xODAqcDtwPXBhcnNlRmxvYXQocGFyc2VGbG9hdChNYXRoLmNvcyh5KSkudG9GaXhlZCg4KSk7CnE9cGFyc2VGbG9hdChwYXJzZUZsb2F0KE1hdGguc2luKC15KSkudG9GaXhlZCg4KSk7eSU9MipNYXRoLlBJOzA+eSYmKHkrPTIqTWF0aC5QSSk7eSU9TWF0aC5QSTt5Pk1hdGguUEkvMiYmKHk9TWF0aC5QSS15KTtnPU1hdGguY29zKHkpO3ZhciBCPU1hdGguc2luKHkpOzghPWRvY3VtZW50LmRvY3VtZW50TW9kZXx8bXhDbGllbnQuSVNfRU18fChlLnN0eWxlLmRpc3BsYXk9ImlubGluZS1ibG9jayIsZi5zdHlsZS5kaXNwbGF5PSJpbmxpbmUtYmxvY2siLHQuc3R5bGUuZGlzcGxheT0iaW5saW5lLWJsb2NrIik7ZS5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4iO2Uuc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGUpO3Q9ZTtudWxsIT10LmZpcnN0Q2hpbGQmJiJESVYiPT10LmZpcnN0Q2hpbGQubm9kZU5hbWUmJih0PXQuZmlyc3RDaGlsZCk7eT10Lm9mZnNldFdpZHRoKzM7dD10Lm9mZnNldEhlaWdodDtuPyhjPU1hdGgubWluKGMseSksdD0KTWF0aC5taW4odCxkKSk6Yz15O2smJihlLnN0eWxlLndpZHRoPWMrInB4Iik7bXhDbGllbnQuSVNfUVVJUktTJiYobnx8IndpZHRoIj09bSkmJnQ+ZCYmKHQ9ZCxlLnN0eWxlLmhlaWdodD10KyJweCIpO2Q9dDtuPShkLWQqZytjKi1CKS8yLXEqYyooeCsuNSkrcCpkKih1Ky41KTtrPShjLWMqZytkKi1CKS8yK3AqYyooeCsuNSkrcSpkKih1Ky41KTsiZ3JvdXAiPT1sLm5vZGVOYW1lJiYiRElWIj09dGhpcy5yb290Lm5vZGVOYW1lPyhtPXRoaXMuY3JlYXRlRWxlbWVudCgiZGl2IiksbS5zdHlsZS5kaXNwbGF5PSJpbmxpbmUtYmxvY2siLG0uc3R5bGUucG9zaXRpb249ImFic29sdXRlIixtLnN0eWxlLmxlZnQ9dGhpcy5mb3JtYXQoYSsoay1jLzIpKnIuc2NhbGUpKyJweCIsbS5zdHlsZS50b3A9dGhpcy5mb3JtYXQoYisobi1kLzIpKnIuc2NhbGUpKyJweCIsbC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKG0pLG0uYXBwZW5kQ2hpbGQobCkpOihyPTghPWRvY3VtZW50LmRvY3VtZW50TW9kZXx8Cm14Q2xpZW50LklTX0VNP3Iuc2NhbGU6MSxsLnN0eWxlLmxlZnQ9dGhpcy5mb3JtYXQoYSsoay1jLzIpKnIpKyJweCIsbC5zdHlsZS50b3A9dGhpcy5mb3JtYXQoYisobi1kLzIpKnIpKyJweCIpO2Yuc3R5bGUuZmlsdGVyPSJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT0iK3ArIiwgTTEyPSIrcSsiLCBNMjE9IistcSsiLCBNMjI9IitwKyIsIHNpemluZ01ldGhvZD0nYXV0byBleHBhbmQnKSI7Zi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9dGhpcy5yb3RhdGVkSHRtbEJhY2tncm91bmQ7MT50aGlzLnN0YXRlLmFscGhhJiYoZi5zdHlsZS5maWx0ZXIrPSJhbHBoYShvcGFjaXR5PSIrMTAwKnRoaXMuc3RhdGUuYWxwaGErIikiKTtmLmFwcGVuZENoaWxkKGUpO2Uuc3R5bGUucG9zaXRpb249IiI7ZS5zdHlsZS52aXNpYmlsaXR5PSIifWVsc2UgOCE9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHxteENsaWVudC5JU19FTT8oZS5zdHlsZS52ZXJ0aWNhbEFsaWduPQoidG9wIiwxPnRoaXMuc3RhdGUuYWxwaGEmJihsLnN0eWxlLmZpbHRlcj0iYWxwaGEob3BhY2l0eT0iKzEwMCp0aGlzLnN0YXRlLmFscGhhKyIpIikscj1lLnBhcmVudE5vZGUsZS5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4iLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZSksYz1lLm9mZnNldFdpZHRoLHQ9ZS5vZmZzZXRIZWlnaHQsbXhDbGllbnQuSVNfUVVJUktTJiZuJiZ0PmQmJih0PWQsZS5zdHlsZS5oZWlnaHQ9dCsicHgiKSxkPXQsZS5zdHlsZS52aXNpYmlsaXR5PSIiLHIuYXBwZW5kQ2hpbGQoZSksbC5zdHlsZS5sZWZ0PXRoaXMuZm9ybWF0KGErYyp4KnRoaXMuc3RhdGUuc2NhbGUpKyJweCIsbC5zdHlsZS50b3A9dGhpcy5mb3JtYXQoYitkKnUqdGhpcy5zdGF0ZS5zY2FsZSkrInB4Iik6KDE+dGhpcy5zdGF0ZS5hbHBoYSYmKGUuc3R5bGUuZmlsdGVyPSJhbHBoYShvcGFjaXR5PSIrMTAwKnRoaXMuc3RhdGUuYWxwaGErIikiKSx0LnN0eWxlLmxlZnQ9MTAwKngrIiUiLHQuc3R5bGUudG9wPQoxMDAqdSsiJSIpfWVsc2UgdGhpcy5wbGFpblRleHQoYSxiLGMsZCxteFV0aWxzLmh0bWxFbnRpdGllcyhlLCExKSxmLGcsayxsLG0sbixwLHEpfX07Cm14Vm1sQ2FudmFzMkQucHJvdG90eXBlLnBsYWluVGV4dD1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGssbCxtLG4scCxxKXtrPXRoaXMuc3RhdGU7YT0oYStrLmR4KSprLnNjYWxlO2I9KGIray5keSkqay5zY2FsZTtjPXRoaXMuY3JlYXRlVm1sRWxlbWVudCgic2hhcGUiKTtjLnN0eWxlLndpZHRoPSIxcHgiO2Muc3R5bGUuaGVpZ2h0PSIxcHgiO2Muc3Ryb2tlZD0iZmFsc2UiO2Q9dGhpcy5jcmVhdGVWbWxFbGVtZW50KCJmaWxsIik7ZC5jb2xvcj1rLmZvbnRDb2xvcjtkLm9wYWNpdHk9MTAwKmsuYWxwaGErIiUiO2MuYXBwZW5kQ2hpbGQoZCk7ZD10aGlzLmNyZWF0ZVZtbEVsZW1lbnQoInBhdGgiKTtkLnRleHRwYXRob2s9InRydWUiO2Qudj0ibSAiK3RoaXMuZm9ybWF0KDApKyIgIit0aGlzLmZvcm1hdCgwKSsiIGwgIit0aGlzLmZvcm1hdCgxKSsiICIrdGhpcy5mb3JtYXQoMCk7Yy5hcHBlbmRDaGlsZChkKTtkPXRoaXMuY3JlYXRlVm1sRWxlbWVudCgidGV4dHBhdGgiKTtkLnN0eWxlLmNzc1RleHQ9CiJ2LXRleHQtYWxpZ246IitmO2Quc3R5bGUuYWxpZ249ZjtkLnN0eWxlLmZvbnRGYW1pbHk9ay5mb250RmFtaWx5O2Quc3RyaW5nPWU7ZC5vbj0idHJ1ZSI7Zj1rLmZvbnRTaXplKmsuc2NhbGUvdGhpcy52bWxTY2FsZTtkLnN0eWxlLmZvbnRTaXplPWYrInB4Ijsoay5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9CT0xEKT09bXhDb25zdGFudHMuRk9OVF9CT0xEJiYoZC5zdHlsZS5mb250V2VpZ2h0PSJib2xkIik7KGsuZm9udFN0eWxlJm14Q29uc3RhbnRzLkZPTlRfSVRBTElDKT09bXhDb25zdGFudHMuRk9OVF9JVEFMSUMmJihkLnN0eWxlLmZvbnRTdHlsZT0iaXRhbGljIik7KGsuZm9udFN0eWxlJm14Q29uc3RhbnRzLkZPTlRfVU5ERVJMSU5FKT09bXhDb25zdGFudHMuRk9OVF9VTkRFUkxJTkUmJihkLnN0eWxlLnRleHREZWNvcmF0aW9uPSJ1bmRlcmxpbmUiKTtlPWUuc3BsaXQoIlxuIik7az1mKyhlLmxlbmd0aC0xKSpmKm14Q29uc3RhbnRzLkxJTkVfSEVJR0hUO2Y9ZT0wOwpnPT1teENvbnN0YW50cy5BTElHTl9CT1RUT00/Zj0tay8yOmchPW14Q29uc3RhbnRzLkFMSUdOX01JRERMRSYmKGY9ay8yKTtudWxsIT1wJiYoYy5zdHlsZS5yb3RhdGlvbj1wLGc9TWF0aC5QSS8xODAqcCxlPU1hdGguc2luKGcpKmYsZio9TWF0aC5jb3MoZykpO2MuYXBwZW5kQ2hpbGQoZCk7Yy5zdHlsZS5sZWZ0PXRoaXMuZm9ybWF0KGEtZSkrInB4IjtjLnN0eWxlLnRvcD10aGlzLmZvcm1hdChiK2YpKyJweCI7dGhpcy5yb290LmFwcGVuZENoaWxkKGMpfTtteFZtbENhbnZhczJELnByb3RvdHlwZS5zdHJva2U9ZnVuY3Rpb24oKXt0aGlzLmFkZE5vZGUoITEsITApfTtteFZtbENhbnZhczJELnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKCl7dGhpcy5hZGROb2RlKCEwLCExKX07bXhWbWxDYW52YXMyRC5wcm90b3R5cGUuZmlsbEFuZFN0cm9rZT1mdW5jdGlvbigpe3RoaXMuYWRkTm9kZSghMCwhMCl9OwpmdW5jdGlvbiBteEd1aWRlKGEsYil7dGhpcy5ncmFwaD1hO3RoaXMuc2V0U3RhdGVzKGIpfW14R3VpZGUucHJvdG90eXBlLmdyYXBoPW51bGw7bXhHdWlkZS5wcm90b3R5cGUuc3RhdGVzPW51bGw7bXhHdWlkZS5wcm90b3R5cGUuaG9yaXpvbnRhbD0hMDtteEd1aWRlLnByb3RvdHlwZS52ZXJ0aWNhbD0hMDtteEd1aWRlLnByb3RvdHlwZS5ndWlkZVg9bnVsbDtteEd1aWRlLnByb3RvdHlwZS5ndWlkZVk9bnVsbDtteEd1aWRlLnByb3RvdHlwZS5yb3VuZGVkPSExO214R3VpZGUucHJvdG90eXBlLnRvbGVyYW5jZT0yO214R3VpZGUucHJvdG90eXBlLnNldFN0YXRlcz1mdW5jdGlvbihhKXt0aGlzLnN0YXRlcz1hfTtteEd1aWRlLnByb3RvdHlwZS5pc0VuYWJsZWRGb3JFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4hMH07Cm14R3VpZGUucHJvdG90eXBlLmdldEd1aWRlVG9sZXJhbmNlPWZ1bmN0aW9uKGEpe3JldHVybiBhJiZ0aGlzLmdyYXBoLmdyaWRFbmFibGVkP3RoaXMuZ3JhcGguZ3JpZFNpemUvMjp0aGlzLnRvbGVyYW5jZX07bXhHdWlkZS5wcm90b3R5cGUuY3JlYXRlR3VpZGVTaGFwZT1mdW5jdGlvbihhKXthPW5ldyBteFBvbHlsaW5lKFtdLG14Q29uc3RhbnRzLkdVSURFX0NPTE9SLG14Q29uc3RhbnRzLkdVSURFX1NUUk9LRVdJRFRIKTthLmlzRGFzaGVkPSEwO3JldHVybiBhfTtteEd1aWRlLnByb3RvdHlwZS5pc1N0YXRlSWdub3JlZD1mdW5jdGlvbihhKXtyZXR1cm4hMX07Cm14R3VpZGUucHJvdG90eXBlLm1vdmU9ZnVuY3Rpb24oYSxiLGMsZCl7aWYobnVsbCE9dGhpcy5zdGF0ZXMmJih0aGlzLmhvcml6b250YWx8fHRoaXMudmVydGljYWwpJiZudWxsIT1hJiZudWxsIT1iKXtkPWZ1bmN0aW9uKGMsZCxlKXt2YXIgZj0hMTtlJiZNYXRoLmFicyhjLXopPHQ/KGIueT1jLWEuZ2V0Q2VudGVyWSgpLHQ9TWF0aC5hYnMoYy16KSxmPSEwKTplfHwoTWF0aC5hYnMoYy1CKTx0PyhiLnk9Yy1hLnksdD1NYXRoLmFicyhjLUIpLGY9ITApOk1hdGguYWJzKGMtQSk8dCYmKGIueT1jLWEueS1hLmhlaWdodCx0PU1hdGguYWJzKGMtQSksZj0hMCkpO2YmJihwPWQscT1jLG51bGw9PXRoaXMuZ3VpZGVZJiYodGhpcy5ndWlkZVk9dGhpcy5jcmVhdGVHdWlkZVNoYXBlKCExKSx0aGlzLmd1aWRlWS5kaWFsZWN0PXRoaXMuZ3JhcGguZGlhbGVjdCE9bXhDb25zdGFudHMuRElBTEVDVF9TVkc/bXhDb25zdGFudHMuRElBTEVDVF9WTUw6bXhDb25zdGFudHMuRElBTEVDVF9TVkcsdGhpcy5ndWlkZVkucG9pbnRlckV2ZW50cz0KITEsdGhpcy5ndWlkZVkuaW5pdCh0aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRPdmVybGF5UGFuZSgpKSkpO249bnx8Zn07dmFyIGU9ZnVuY3Rpb24oYyxkLGUpe3ZhciBmPSExO2UmJk1hdGguYWJzKGMteSk8cj8oYi54PWMtYS5nZXRDZW50ZXJYKCkscj1NYXRoLmFicyhjLXkpLGY9ITApOmV8fChNYXRoLmFicyhjLXUpPHI/KGIueD1jLWEueCxyPU1hdGguYWJzKGMtdSksZj0hMCk6TWF0aC5hYnMoYy14KTxyJiYoYi54PWMtYS54LWEud2lkdGgscj1NYXRoLmFicyhjLXgpLGY9ITApKTtmJiYobD1kLG09YyxudWxsPT10aGlzLmd1aWRlWCYmKHRoaXMuZ3VpZGVYPXRoaXMuY3JlYXRlR3VpZGVTaGFwZSghMCksdGhpcy5ndWlkZVguZGlhbGVjdD10aGlzLmdyYXBoLmRpYWxlY3QhPW14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHP214Q29uc3RhbnRzLkRJQUxFQ1RfVk1MOm14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHLHRoaXMuZ3VpZGVYLnBvaW50ZXJFdmVudHM9ITEsdGhpcy5ndWlkZVguaW5pdCh0aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRPdmVybGF5UGFuZSgpKSkpOwprPWt8fGZ9LGY9dGhpcy5ncmFwaC5nZXRWaWV3KCkuc2NhbGUsZj10aGlzLmdldEd1aWRlVG9sZXJhbmNlKGMpKmYsZz1hLmNsb25lKCk7Zy54Kz1iLng7Zy55Kz1iLnk7Zm9yKHZhciBrPSExLGw9bnVsbCxtPW51bGwsbj0hMSxwPW51bGwscT1udWxsLHI9Zix0PWYsdT1nLngseD1nLngrZy53aWR0aCx5PWcuZ2V0Q2VudGVyWCgpLEI9Zy55LEE9Zy55K2cuaGVpZ2h0LHo9Zy5nZXRDZW50ZXJZKCksZj0wO2Y8dGhpcy5zdGF0ZXMubGVuZ3RoO2YrKylnPXRoaXMuc3RhdGVzW2ZdLG51bGw9PWd8fHRoaXMuaXNTdGF0ZUlnbm9yZWQoZyl8fCh0aGlzLmhvcml6b250YWwmJihlLmNhbGwodGhpcyxnLmdldENlbnRlclgoKSxnLCEwKSxlLmNhbGwodGhpcyxnLngsZywhMSksZS5jYWxsKHRoaXMsZy54K2cud2lkdGgsZywhMSksbnVsbD09Zy5jZWxsJiZlLmNhbGwodGhpcyxnLmdldENlbnRlclgoKSxnLCExKSksdGhpcy52ZXJ0aWNhbCYmKGQuY2FsbCh0aGlzLGcuZ2V0Q2VudGVyWSgpLGcsCiEwKSxkLmNhbGwodGhpcyxnLnksZywhMSksZC5jYWxsKHRoaXMsZy55K2cuaGVpZ2h0LGcsITEpLG51bGw9PWcuY2VsbCYmZC5jYWxsKHRoaXMsZy5nZXRDZW50ZXJZKCksZywhMSkpKTt0aGlzLmdyYXBoLnNuYXBEZWx0YShiLGEsIWMsayxuKTtiPXRoaXMuZ2V0RGVsdGEoYSxsLGIueCxwLGIueSk7Yz10aGlzLmdyYXBoLmNvbnRhaW5lcjtrfHxudWxsPT10aGlzLmd1aWRlWD9udWxsIT10aGlzLmd1aWRlWCYmKGU9ZD1udWxsLG51bGwhPWwmJm51bGwhPWEmJihkPU1hdGgubWluKGEueStiLnktdGhpcy5ncmFwaC5wYW5EeSxsLnkpLGU9TWF0aC5tYXgoYS55K2EuaGVpZ2h0K2IueS10aGlzLmdyYXBoLnBhbkR5LGwueStsLmhlaWdodCkpLHRoaXMuZ3VpZGVYLnBvaW50cz1udWxsIT1kJiZudWxsIT1lP1tuZXcgbXhQb2ludChtLGQpLG5ldyBteFBvaW50KG0sZSldOltuZXcgbXhQb2ludChtLC10aGlzLmdyYXBoLnBhbkR5KSxuZXcgbXhQb2ludChtLGMuc2Nyb2xsSGVpZ2h0LTMtdGhpcy5ncmFwaC5wYW5EeSldLAp0aGlzLmd1aWRlWC5zdHJva2U9dGhpcy5nZXRHdWlkZUNvbG9yKGwsITApLHRoaXMuZ3VpZGVYLm5vZGUuc3R5bGUudmlzaWJpbGl0eT0idmlzaWJsZSIsdGhpcy5ndWlkZVgucmVkcmF3KCkpOnRoaXMuZ3VpZGVYLm5vZGUuc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIjtufHxudWxsPT10aGlzLmd1aWRlWT9udWxsIT10aGlzLmd1aWRlWSYmKGU9ZD1udWxsLG51bGwhPXAmJm51bGwhPWEmJihkPU1hdGgubWluKGEueCtiLngtdGhpcy5ncmFwaC5wYW5EeCxwLngpLGU9TWF0aC5tYXgoYS54K2Eud2lkdGgrYi54LXRoaXMuZ3JhcGgucGFuRHgscC54K3Aud2lkdGgpKSx0aGlzLmd1aWRlWS5wb2ludHM9bnVsbCE9ZCYmbnVsbCE9ZT9bbmV3IG14UG9pbnQoZCxxKSxuZXcgbXhQb2ludChlLHEpXTpbbmV3IG14UG9pbnQoLXRoaXMuZ3JhcGgucGFuRHgscSksbmV3IG14UG9pbnQoYy5zY3JvbGxXaWR0aC0zLXRoaXMuZ3JhcGgucGFuRHgscSldLHRoaXMuZ3VpZGVZLnN0cm9rZT10aGlzLmdldEd1aWRlQ29sb3IocCwKITEpLHRoaXMuZ3VpZGVZLm5vZGUuc3R5bGUudmlzaWJpbGl0eT0idmlzaWJsZSIsdGhpcy5ndWlkZVkucmVkcmF3KCkpOnRoaXMuZ3VpZGVZLm5vZGUuc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIn1yZXR1cm4gYn07bXhHdWlkZS5wcm90b3R5cGUuZ2V0RGVsdGE9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj10aGlzLmdyYXBoLnZpZXcuc2NhbGU7aWYodGhpcy5yb3VuZGVkfHxudWxsIT1iJiZudWxsPT1iLmNlbGwpYz1NYXRoLnJvdW5kKChhLngrYykvZikqZi1hLng7aWYodGhpcy5yb3VuZGVkfHxudWxsIT1kJiZudWxsPT1kLmNlbGwpZT1NYXRoLnJvdW5kKChhLnkrZSkvZikqZi1hLnk7cmV0dXJuIG5ldyBteFBvaW50KGMsZSl9O214R3VpZGUucHJvdG90eXBlLmdldEd1aWRlQ29sb3I9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbXhDb25zdGFudHMuR1VJREVfQ09MT1J9O214R3VpZGUucHJvdG90eXBlLmhpZGU9ZnVuY3Rpb24oKXt0aGlzLnNldFZpc2libGUoITEpfTsKbXhHdWlkZS5wcm90b3R5cGUuc2V0VmlzaWJsZT1mdW5jdGlvbihhKXtudWxsIT10aGlzLmd1aWRlWCYmKHRoaXMuZ3VpZGVYLm5vZGUuc3R5bGUudmlzaWJpbGl0eT1hPyJ2aXNpYmxlIjoiaGlkZGVuIik7bnVsbCE9dGhpcy5ndWlkZVkmJih0aGlzLmd1aWRlWS5ub2RlLnN0eWxlLnZpc2liaWxpdHk9YT8idmlzaWJsZSI6ImhpZGRlbiIpfTtteEd1aWRlLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5ndWlkZVgmJih0aGlzLmd1aWRlWC5kZXN0cm95KCksdGhpcy5ndWlkZVg9bnVsbCk7bnVsbCE9dGhpcy5ndWlkZVkmJih0aGlzLmd1aWRlWS5kZXN0cm95KCksdGhpcy5ndWlkZVk9bnVsbCl9O2Z1bmN0aW9uIG14U2hhcGUoYSl7dGhpcy5zdGVuY2lsPWE7dGhpcy5pbml0U3R5bGVzKCl9bXhTaGFwZS5wcm90b3R5cGUuZGlhbGVjdD1udWxsO214U2hhcGUucHJvdG90eXBlLnNjYWxlPTE7bXhTaGFwZS5wcm90b3R5cGUuYW50aUFsaWFzPSEwOwpteFNoYXBlLnByb3RvdHlwZS5taW5TdmdTdHJva2VXaWR0aD0xO214U2hhcGUucHJvdG90eXBlLmJvdW5kcz1udWxsO214U2hhcGUucHJvdG90eXBlLnBvaW50cz1udWxsO214U2hhcGUucHJvdG90eXBlLm5vZGU9bnVsbDtteFNoYXBlLnByb3RvdHlwZS5zdGF0ZT1udWxsO214U2hhcGUucHJvdG90eXBlLnN0eWxlPW51bGw7bXhTaGFwZS5wcm90b3R5cGUuYm91bmRpbmdCb3g9bnVsbDtteFNoYXBlLnByb3RvdHlwZS5zdGVuY2lsPW51bGw7bXhTaGFwZS5wcm90b3R5cGUuc3ZnU3Ryb2tlVG9sZXJhbmNlPTg7bXhTaGFwZS5wcm90b3R5cGUucG9pbnRlckV2ZW50cz0hMDtteFNoYXBlLnByb3RvdHlwZS5zdmdQb2ludGVyRXZlbnRzPSJhbGwiO214U2hhcGUucHJvdG90eXBlLnNoYXBlUG9pbnRlckV2ZW50cz0hMTtteFNoYXBlLnByb3RvdHlwZS5zdGVuY2lsUG9pbnRlckV2ZW50cz0hMTtteFNoYXBlLnByb3RvdHlwZS52bWxTY2FsZT0xOwpteFNoYXBlLnByb3RvdHlwZS5vdXRsaW5lPSExO214U2hhcGUucHJvdG90eXBlLnZpc2libGU9ITA7bXhTaGFwZS5wcm90b3R5cGUudXNlU3ZnQm91bmRpbmdCb3g9ITE7bXhTaGFwZS5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbihhKXtudWxsPT10aGlzLm5vZGUmJih0aGlzLm5vZGU9dGhpcy5jcmVhdGUoYSksbnVsbCE9YSYmYS5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpKX07bXhTaGFwZS5wcm90b3R5cGUuaW5pdFN0eWxlcz1mdW5jdGlvbihhKXt0aGlzLnN0cm9rZXdpZHRoPTE7dGhpcy5yb3RhdGlvbj0wO3RoaXMuc3Ryb2tlT3BhY2l0eT10aGlzLmZpbGxPcGFjaXR5PXRoaXMub3BhY2l0eT0xMDA7dGhpcy5mbGlwVj10aGlzLmZsaXBIPSExfTtteFNoYXBlLnByb3RvdHlwZS5pc1BhcnNlVm1sPWZ1bmN0aW9uKCl7cmV0dXJuITB9O214U2hhcGUucHJvdG90eXBlLmlzSHRtbEFsbG93ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX07Cm14U2hhcGUucHJvdG90eXBlLmdldFN2Z1NjcmVlbk9mZnNldD1mdW5jdGlvbigpe3JldHVybiAxPT1teFV0aWxzLm1vZChNYXRoLm1heCgxLE1hdGgucm91bmQoKHRoaXMuc3RlbmNpbCYmImluaGVyaXQiIT10aGlzLnN0ZW5jaWwuc3Ryb2tld2lkdGg/TnVtYmVyKHRoaXMuc3RlbmNpbC5zdHJva2V3aWR0aCk6dGhpcy5zdHJva2V3aWR0aCkqdGhpcy5zY2FsZSkpLDIpPy41OjB9O214U2hhcGUucHJvdG90eXBlLmNyZWF0ZT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YSYmbnVsbCE9YS5vd25lclNWR0VsZW1lbnQ/dGhpcy5jcmVhdGVTdmcoYSk6OD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHwhbXhDbGllbnQuSVNfVk1MfHx0aGlzLmRpYWxlY3QhPW14Q29uc3RhbnRzLkRJQUxFQ1RfVk1MJiZ0aGlzLmlzSHRtbEFsbG93ZWQoKT90aGlzLmNyZWF0ZUh0bWwoYSk6dGhpcy5jcmVhdGVWbWwoYSl9OwpteFNoYXBlLnByb3RvdHlwZS5jcmVhdGVTdmc9ZnVuY3Rpb24oKXtyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG14Q29uc3RhbnRzLk5TX1NWRywiZyIpfTtteFNoYXBlLnByb3RvdHlwZS5jcmVhdGVWbWw9ZnVuY3Rpb24oKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KG14Q2xpZW50LlZNTF9QUkVGSVgrIjpncm91cCIpO2Euc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtyZXR1cm4gYX07bXhTaGFwZS5wcm90b3R5cGUuY3JlYXRlSHRtbD1mdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Euc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtyZXR1cm4gYX07bXhTaGFwZS5wcm90b3R5cGUucmVjb25maWd1cmU9ZnVuY3Rpb24oKXt0aGlzLnJlZHJhdygpfTsKbXhTaGFwZS5wcm90b3R5cGUucmVkcmF3PWZ1bmN0aW9uKCl7dGhpcy51cGRhdGVCb3VuZHNGcm9tUG9pbnRzKCk7dGhpcy52aXNpYmxlJiZ0aGlzLmNoZWNrQm91bmRzKCk/KHRoaXMubm9kZS5zdHlsZS52aXNpYmlsaXR5PSJ2aXNpYmxlIix0aGlzLmNsZWFyKCksIkRJViIhPXRoaXMubm9kZS5ub2RlTmFtZXx8IXRoaXMuaXNIdG1sQWxsb3dlZCgpJiZteENsaWVudC5JU19WTUw/dGhpcy5yZWRyYXdTaGFwZSgpOnRoaXMucmVkcmF3SHRtbFNoYXBlKCksdGhpcy51cGRhdGVCb3VuZGluZ0JveCgpKToodGhpcy5ub2RlLnN0eWxlLnZpc2liaWxpdHk9ImhpZGRlbiIsdGhpcy5ib3VuZGluZ0JveD1udWxsKX07Cm14U2hhcGUucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7aWYobnVsbCE9dGhpcy5ub2RlLm93bmVyU1ZHRWxlbWVudClmb3IoO251bGwhPXRoaXMubm9kZS5sYXN0Q2hpbGQ7KXRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUubGFzdENoaWxkKTtlbHNlIHRoaXMubm9kZS5zdHlsZS5jc3NUZXh0PSJwb3NpdGlvbjphYnNvbHV0ZTsiKyhudWxsIT10aGlzLmN1cnNvcj8iY3Vyc29yOiIrdGhpcy5jdXJzb3IrIjsiOiIiKSx0aGlzLm5vZGUuaW5uZXJIVE1MPSIifTsKbXhTaGFwZS5wcm90b3R5cGUudXBkYXRlQm91bmRzRnJvbVBvaW50cz1mdW5jdGlvbigpe3ZhciBhPXRoaXMucG9pbnRzO2lmKG51bGwhPWEmJjA8YS5sZW5ndGgmJm51bGwhPWFbMF0pe3RoaXMuYm91bmRzPW5ldyBteFJlY3RhbmdsZShOdW1iZXIoYVswXS54KSxOdW1iZXIoYVswXS55KSwxLDEpO2Zvcih2YXIgYj0xO2I8dGhpcy5wb2ludHMubGVuZ3RoO2IrKyludWxsIT1hW2JdJiZ0aGlzLmJvdW5kcy5hZGQobmV3IG14UmVjdGFuZ2xlKE51bWJlcihhW2JdLngpLE51bWJlcihhW2JdLnkpLDEsMSkpfX07Cm14U2hhcGUucHJvdG90eXBlLmdldExhYmVsQm91bmRzPWZ1bmN0aW9uKGEpe3ZhciBiPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ESVJFQ1RJT04sbXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1QpLGM9YTtiIT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEgmJmIhPW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSCYmbnVsbCE9dGhpcy5zdGF0ZSYmbnVsbCE9dGhpcy5zdGF0ZS50ZXh0JiZ0aGlzLnN0YXRlLnRleHQuaXNQYWludEJvdW5kc0ludmVydGVkKCkmJihjPWMuY2xvbmUoKSxiPWMud2lkdGgsYy53aWR0aD1jLmhlaWdodCxjLmhlaWdodD1iKTtjPXRoaXMuZ2V0TGFiZWxNYXJnaW5zKGMpO2lmKG51bGwhPWMpe3ZhciBkPSIxIj09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZMSVBILCExKSxlPSIxIj09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZMSVBWLAohMSk7bnVsbCE9dGhpcy5zdGF0ZSYmbnVsbCE9dGhpcy5zdGF0ZS50ZXh0JiZ0aGlzLnN0YXRlLnRleHQuaXNQYWludEJvdW5kc0ludmVydGVkKCkmJihiPWMueCxjLng9Yy5oZWlnaHQsYy5oZWlnaHQ9Yy53aWR0aCxjLndpZHRoPWMueSxjLnk9YixiPWQsZD1lLGU9Yik7cmV0dXJuIG14VXRpbHMuZ2V0RGlyZWN0ZWRCb3VuZHMoYSxjLHRoaXMuc3R5bGUsZCxlKX1yZXR1cm4gYX07bXhTaGFwZS5wcm90b3R5cGUuZ2V0TGFiZWxNYXJnaW5zPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsfTsKbXhTaGFwZS5wcm90b3R5cGUuY2hlY2tCb3VuZHM9ZnVuY3Rpb24oKXtyZXR1cm4haXNOYU4odGhpcy5zY2FsZSkmJmlzRmluaXRlKHRoaXMuc2NhbGUpJiYwPHRoaXMuc2NhbGUmJm51bGwhPXRoaXMuYm91bmRzJiYhaXNOYU4odGhpcy5ib3VuZHMueCkmJiFpc05hTih0aGlzLmJvdW5kcy55KSYmIWlzTmFOKHRoaXMuYm91bmRzLndpZHRoKSYmIWlzTmFOKHRoaXMuYm91bmRzLmhlaWdodCkmJjA8dGhpcy5ib3VuZHMud2lkdGgmJjA8dGhpcy5ib3VuZHMuaGVpZ2h0fTtteFNoYXBlLnByb3RvdHlwZS5jcmVhdGVWbWxHcm91cD1mdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobXhDbGllbnQuVk1MX1BSRUZJWCsiOmdyb3VwIik7YS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO2Euc3R5bGUud2lkdGg9dGhpcy5ub2RlLnN0eWxlLndpZHRoO2Euc3R5bGUuaGVpZ2h0PXRoaXMubm9kZS5zdHlsZS5oZWlnaHQ7cmV0dXJuIGF9OwpteFNoYXBlLnByb3RvdHlwZS5yZWRyYXdTaGFwZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuY3JlYXRlQ2FudmFzKCk7bnVsbCE9YSYmKGEucG9pbnRlckV2ZW50cz10aGlzLnBvaW50ZXJFdmVudHMsdGhpcy5wYWludChhKSx0aGlzLm5vZGUhPWEucm9vdCYmdGhpcy5ub2RlLmluc2VydEFkamFjZW50SFRNTCgiYmVmb3JlZW5kIixhLnJvb3Qub3V0ZXJIVE1MKSwiRElWIj09dGhpcy5ub2RlLm5vZGVOYW1lJiY4PT1kb2N1bWVudC5kb2N1bWVudE1vZGUmJih0aGlzLm5vZGUuc3R5bGUuZmlsdGVyPSIiLG14VXRpbHMuYWRkVHJhbnNwYXJlbnRCYWNrZ3JvdW5kRmlsdGVyKHRoaXMubm9kZSkpLHRoaXMuZGVzdHJveUNhbnZhcyhhKSl9OwpteFNoYXBlLnByb3RvdHlwZS5jcmVhdGVDYW52YXM9ZnVuY3Rpb24oKXt2YXIgYT1udWxsO251bGwhPXRoaXMubm9kZS5vd25lclNWR0VsZW1lbnQ/YT10aGlzLmNyZWF0ZVN2Z0NhbnZhcygpOm14Q2xpZW50LklTX1ZNTCYmKHRoaXMudXBkYXRlVm1sQ29udGFpbmVyKCksYT10aGlzLmNyZWF0ZVZtbENhbnZhcygpKTtudWxsIT1hJiZ0aGlzLm91dGxpbmUmJihhLnNldFN0cm9rZVdpZHRoKHRoaXMuc3Ryb2tld2lkdGgpLGEuc2V0U3Ryb2tlQ29sb3IodGhpcy5zdHJva2UpLG51bGwhPXRoaXMuaXNEYXNoZWQmJmEuc2V0RGFzaGVkKHRoaXMuaXNEYXNoZWQpLGEuc2V0U3Ryb2tlV2lkdGg9ZnVuY3Rpb24oKXt9LGEuc2V0U3Ryb2tlQ29sb3I9ZnVuY3Rpb24oKXt9LGEuc2V0RmlsbENvbG9yPWZ1bmN0aW9uKCl7fSxhLnNldEdyYWRpZW50PWZ1bmN0aW9uKCl7fSxhLnNldERhc2hlZD1mdW5jdGlvbigpe30sYS50ZXh0PWZ1bmN0aW9uKCl7fSk7cmV0dXJuIGF9OwpteFNoYXBlLnByb3RvdHlwZS5jcmVhdGVTdmdDYW52YXM9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhTdmdDYW52YXMyRCh0aGlzLm5vZGUsITEpO2Euc3Ryb2tlVG9sZXJhbmNlPXRoaXMucG9pbnRlckV2ZW50cz90aGlzLnN2Z1N0cm9rZVRvbGVyYW5jZTowO2EucG9pbnRlckV2ZW50c1ZhbHVlPXRoaXMuc3ZnUG9pbnRlckV2ZW50czt2YXIgYj10aGlzLmdldFN2Z1NjcmVlbk9mZnNldCgpOzAhPWI/dGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgidHJhbnNmb3JtIiwidHJhbnNsYXRlKCIrYisiLCIrYisiKSIpOnRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoInRyYW5zZm9ybSIpO2EubWluU3Ryb2tlV2lkdGg9dGhpcy5taW5TdmdTdHJva2VXaWR0aDt0aGlzLmFudGlBbGlhc3x8KGEuZm9ybWF0PWZ1bmN0aW9uKGEpe3JldHVybiBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoYSkpfSk7cmV0dXJuIGF9OwpteFNoYXBlLnByb3RvdHlwZS5jcmVhdGVWbWxDYW52YXM9ZnVuY3Rpb24oKXt2YXIgYT04PT1kb2N1bWVudC5kb2N1bWVudE1vZGUmJnRoaXMuaXNQYXJzZVZtbCgpP3RoaXMuY3JlYXRlVm1sR3JvdXAoKTp0aGlzLm5vZGUsYj1uZXcgbXhWbWxDYW52YXMyRChhLCExKTsiIiE9YS50YWdVcm4mJihhLmNvb3Jkc2l6ZT1NYXRoLm1heCgxLE1hdGgucm91bmQodGhpcy5ib3VuZHMud2lkdGgpKSp0aGlzLnZtbFNjYWxlKyIsIitNYXRoLm1heCgxLE1hdGgucm91bmQodGhpcy5ib3VuZHMuaGVpZ2h0KSkqdGhpcy52bWxTY2FsZSxiLnNjYWxlKHRoaXMudm1sU2NhbGUpLGIudm1sU2NhbGU9dGhpcy52bWxTY2FsZSk7YT10aGlzLnNjYWxlO2IudHJhbnNsYXRlKC1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLngvYSksLU1hdGgucm91bmQodGhpcy5ib3VuZHMueS9hKSk7cmV0dXJuIGJ9OwpteFNoYXBlLnByb3RvdHlwZS51cGRhdGVWbWxDb250YWluZXI9ZnVuY3Rpb24oKXt0aGlzLm5vZGUuc3R5bGUubGVmdD1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLngpKyJweCI7dGhpcy5ub2RlLnN0eWxlLnRvcD1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLnkpKyJweCI7dmFyIGE9TWF0aC5tYXgoMSxNYXRoLnJvdW5kKHRoaXMuYm91bmRzLmhlaWdodCkpO3RoaXMubm9kZS5zdHlsZS53aWR0aD1NYXRoLm1heCgxLE1hdGgucm91bmQodGhpcy5ib3VuZHMud2lkdGgpKSsicHgiO3RoaXMubm9kZS5zdHlsZS5oZWlnaHQ9YSsicHgiO3RoaXMubm9kZS5zdHlsZS5vdmVyZmxvdz0idmlzaWJsZSJ9O214U2hhcGUucHJvdG90eXBlLnJlZHJhd0h0bWxTaGFwZT1mdW5jdGlvbigpe3RoaXMudXBkYXRlSHRtbEJvdW5kcyh0aGlzLm5vZGUpO3RoaXMudXBkYXRlSHRtbEZpbHRlcnModGhpcy5ub2RlKTt0aGlzLnVwZGF0ZUh0bWxDb2xvcnModGhpcy5ub2RlKX07Cm14U2hhcGUucHJvdG90eXBlLnVwZGF0ZUh0bWxGaWx0ZXJzPWZ1bmN0aW9uKGEpe3ZhciBiPSIiOzEwMD50aGlzLm9wYWNpdHkmJihiKz0iYWxwaGEob3BhY2l0eT0iK3RoaXMub3BhY2l0eSsiKSIpO3RoaXMuaXNTaGFkb3cmJihiKz0icHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmRyb3BTaGFkb3cgKE9mZlg9JyIrTWF0aC5yb3VuZChteENvbnN0YW50cy5TSEFET1dfT0ZGU0VUX1gqdGhpcy5zY2FsZSkrIicsIE9mZlk9JyIrTWF0aC5yb3VuZChteENvbnN0YW50cy5TSEFET1dfT0ZGU0VUX1kqdGhpcy5zY2FsZSkrIicsIENvbG9yPSciK214Q29uc3RhbnRzLlZNTF9TSEFET1dDT0xPUisiJykiKTtpZihudWxsIT10aGlzLmZpbGwmJnRoaXMuZmlsbCE9bXhDb25zdGFudHMuTk9ORSYmdGhpcy5ncmFkaWVudCYmdGhpcy5ncmFkaWVudCE9bXhDb25zdGFudHMuTk9ORSl7dmFyIGM9dGhpcy5maWxsLGQ9dGhpcy5ncmFkaWVudCxlPSIwIixmPXtlYXN0OjAsc291dGg6MSwKd2VzdDoyLG5vcnRoOjN9LGc9bnVsbCE9dGhpcy5kaXJlY3Rpb24/Zlt0aGlzLmRpcmVjdGlvbl06MDtudWxsIT10aGlzLmdyYWRpZW50RGlyZWN0aW9uJiYoZz1teFV0aWxzLm1vZChnK2ZbdGhpcy5ncmFkaWVudERpcmVjdGlvbl0tMSw0KSk7MT09Zz8oZT0iMSIsZj1jLGM9ZCxkPWYpOjI9PWc/KGY9YyxjPWQsZD1mKTozPT1nJiYoZT0iMSIpO2IrPSJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoc3RhcnRDb2xvclN0cj0nIitjKyInLCBlbmRDb2xvclN0cj0nIitkKyInLCBncmFkaWVudFR5cGU9JyIrZSsiJykifWEuc3R5bGUuZmlsdGVyPWJ9OwpteFNoYXBlLnByb3RvdHlwZS51cGRhdGVIdG1sQ29sb3JzPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc3Ryb2tlO251bGwhPWImJmIhPW14Q29uc3RhbnRzLk5PTkU/KGEuc3R5bGUuYm9yZGVyQ29sb3I9Yix0aGlzLmlzRGFzaGVkP2Euc3R5bGUuYm9yZGVyU3R5bGU9ImRhc2hlZCI6MDx0aGlzLnN0cm9rZXdpZHRoJiYoYS5zdHlsZS5ib3JkZXJTdHlsZT0ic29saWQiKSxhLnN0eWxlLmJvcmRlcldpZHRoPU1hdGgubWF4KDEsTWF0aC5jZWlsKHRoaXMuc3Ryb2tld2lkdGgqdGhpcy5zY2FsZSkpKyJweCIpOmEuc3R5bGUuYm9yZGVyV2lkdGg9IjBweCI7Yj10aGlzLm91dGxpbmU/bnVsbDp0aGlzLmZpbGw7bnVsbCE9YiYmYiE9bXhDb25zdGFudHMuTk9ORT8oYS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9YixhLnN0eWxlLmJhY2tncm91bmRJbWFnZT0ibm9uZSIpOnRoaXMucG9pbnRlckV2ZW50cz9hLnN0eWxlLmJhY2tncm91bmRDb2xvcj0idHJhbnNwYXJlbnQiOjg9PWRvY3VtZW50LmRvY3VtZW50TW9kZT8KbXhVdGlscy5hZGRUcmFuc3BhcmVudEJhY2tncm91bmRGaWx0ZXIoYSk6dGhpcy5zZXRUcmFuc3BhcmVudEJhY2tncm91bmRJbWFnZShhKX07Cm14U2hhcGUucHJvdG90eXBlLnVwZGF0ZUh0bWxCb3VuZHM9ZnVuY3Rpb24oYSl7dmFyIGI9OTw9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlPzA6TWF0aC5jZWlsKHRoaXMuc3Ryb2tld2lkdGgqdGhpcy5zY2FsZSk7YS5zdHlsZS5ib3JkZXJXaWR0aD1NYXRoLm1heCgxLGIpKyJweCI7YS5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjthLnN0eWxlLmxlZnQ9TWF0aC5yb3VuZCh0aGlzLmJvdW5kcy54LWIvMikrInB4IjthLnN0eWxlLnRvcD1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLnktYi8yKSsicHgiOyJDU1MxQ29tcGF0Ij09ZG9jdW1lbnQuY29tcGF0TW9kZSYmKGI9LWIpO2Euc3R5bGUud2lkdGg9TWF0aC5yb3VuZChNYXRoLm1heCgwLHRoaXMuYm91bmRzLndpZHRoK2IpKSsicHgiO2Euc3R5bGUuaGVpZ2h0PU1hdGgucm91bmQoTWF0aC5tYXgoMCx0aGlzLmJvdW5kcy5oZWlnaHQrYikpKyJweCJ9OwpteFNoYXBlLnByb3RvdHlwZS5kZXN0cm95Q2FudmFzPWZ1bmN0aW9uKGEpe2lmKGEgaW5zdGFuY2VvZiBteFN2Z0NhbnZhczJEKXtmb3IodmFyIGIgaW4gYS5ncmFkaWVudHMpe3ZhciBjPWEuZ3JhZGllbnRzW2JdO251bGwhPWMmJihjLm14UmVmQ291bnQ9KGMubXhSZWZDb3VudHx8MCkrMSl9dGhpcy5yZWxlYXNlU3ZnR3JhZGllbnRzKHRoaXMub2xkR3JhZGllbnRzKTt0aGlzLm9sZEdyYWRpZW50cz1hLmdyYWRpZW50c319OwpteFNoYXBlLnByb3RvdHlwZS5wYWludD1mdW5jdGlvbihhKXt2YXIgYj0hMTtpZihudWxsIT1hJiZ0aGlzLm91dGxpbmUpe3ZhciBjPWEuc3Ryb2tlO2Euc3Ryb2tlPWZ1bmN0aW9uKCl7Yj0hMDtjLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dmFyIGQ9YS5maWxsQW5kU3Ryb2tlO2EuZmlsbEFuZFN0cm9rZT1mdW5jdGlvbigpe2I9ITA7ZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fXZhciBlPXRoaXMuc2NhbGUsZj10aGlzLmJvdW5kcy54L2UsZz10aGlzLmJvdW5kcy55L2Usaz10aGlzLmJvdW5kcy53aWR0aC9lLGw9dGhpcy5ib3VuZHMuaGVpZ2h0L2U7aWYodGhpcy5pc1BhaW50Qm91bmRzSW52ZXJ0ZWQoKSl2YXIgbT0oay1sKS8yLGY9ZittLGc9Zy1tLG09ayxrPWwsbD1tO3RoaXMudXBkYXRlVHJhbnNmb3JtKGEsZixnLGssbCk7dGhpcy5jb25maWd1cmVDYW52YXMoYSxmLGcsayxsKTttPW51bGw7aWYobnVsbD09dGhpcy5zdGVuY2lsJiZudWxsPT10aGlzLnBvaW50cyYmdGhpcy5zaGFwZVBvaW50ZXJFdmVudHN8fApudWxsIT10aGlzLnN0ZW5jaWwmJnRoaXMuc3RlbmNpbFBvaW50ZXJFdmVudHMpe3ZhciBuPXRoaXMuY3JlYXRlQm91bmRpbmdCb3goKTt0aGlzLmRpYWxlY3Q9PW14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHPyhtPXRoaXMuY3JlYXRlVHJhbnNwYXJlbnRTdmdSZWN0YW5nbGUobi54LG4ueSxuLndpZHRoLG4uaGVpZ2h0KSx0aGlzLm5vZGUuYXBwZW5kQ2hpbGQobSkpOihuPWEuY3JlYXRlUmVjdCgicmVjdCIsbi54L2Usbi55L2Usbi53aWR0aC9lLG4uaGVpZ2h0L2UpLG4uYXBwZW5kQ2hpbGQoYS5jcmVhdGVUcmFuc3BhcmVudEZpbGwoKSksbi5zdHJva2VkPSJmYWxzZSIsYS5yb290LmFwcGVuZENoaWxkKG4pKX1pZihudWxsIT10aGlzLnN0ZW5jaWwpdGhpcy5zdGVuY2lsLmRyYXdTaGFwZShhLHRoaXMsZixnLGssbCk7ZWxzZSBpZihhLnNldFN0cm9rZVdpZHRoKHRoaXMuc3Ryb2tld2lkdGgpLG51bGwhPXRoaXMucG9pbnRzKXtmb3IodmFyIG49W10scD0wO3A8dGhpcy5wb2ludHMubGVuZ3RoO3ArKyludWxsIT0KdGhpcy5wb2ludHNbcF0mJm4ucHVzaChuZXcgbXhQb2ludCh0aGlzLnBvaW50c1twXS54L2UsdGhpcy5wb2ludHNbcF0ueS9lKSk7dGhpcy5wYWludEVkZ2VTaGFwZShhLG4pfWVsc2UgdGhpcy5wYWludFZlcnRleFNoYXBlKGEsZixnLGssbCk7bnVsbCE9bSYmbnVsbCE9YS5zdGF0ZSYmbnVsbCE9YS5zdGF0ZS50cmFuc2Zvcm0mJm0uc2V0QXR0cmlidXRlKCJ0cmFuc2Zvcm0iLGEuc3RhdGUudHJhbnNmb3JtKTtudWxsIT1hJiZ0aGlzLm91dGxpbmUmJiFiJiYoYS5yZWN0KGYsZyxrLGwpLGEuc3Ryb2tlKCkpfTsKbXhTaGFwZS5wcm90b3R5cGUuY29uZmlndXJlQ2FudmFzPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9bnVsbDtudWxsIT10aGlzLnN0eWxlJiYoZj10aGlzLnN0eWxlLmRhc2hQYXR0ZXJuKTthLnNldEFscGhhKHRoaXMub3BhY2l0eS8xMDApO2Euc2V0RmlsbEFscGhhKHRoaXMuZmlsbE9wYWNpdHkvMTAwKTthLnNldFN0cm9rZUFscGhhKHRoaXMuc3Ryb2tlT3BhY2l0eS8xMDApO251bGwhPXRoaXMuaXNTaGFkb3cmJmEuc2V0U2hhZG93KHRoaXMuaXNTaGFkb3cpO251bGwhPXRoaXMuaXNEYXNoZWQmJmEuc2V0RGFzaGVkKHRoaXMuaXNEYXNoZWQsbnVsbCE9dGhpcy5zdHlsZT8xPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRklYX0RBU0gsITEpOiExKTtudWxsIT1mJiZhLnNldERhc2hQYXR0ZXJuKGYpO251bGwhPXRoaXMuZmlsbCYmdGhpcy5maWxsIT1teENvbnN0YW50cy5OT05FJiZ0aGlzLmdyYWRpZW50JiZ0aGlzLmdyYWRpZW50IT1teENvbnN0YW50cy5OT05FPwooYj10aGlzLmdldEdyYWRpZW50Qm91bmRzKGEsYixjLGQsZSksYS5zZXRHcmFkaWVudCh0aGlzLmZpbGwsdGhpcy5ncmFkaWVudCxiLngsYi55LGIud2lkdGgsYi5oZWlnaHQsdGhpcy5ncmFkaWVudERpcmVjdGlvbikpOmEuc2V0RmlsbENvbG9yKHRoaXMuZmlsbCk7YS5zZXRTdHJva2VDb2xvcih0aGlzLnN0cm9rZSl9O214U2hhcGUucHJvdG90eXBlLmdldEdyYWRpZW50Qm91bmRzPWZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIG5ldyBteFJlY3RhbmdsZShiLGMsZCxlKX07bXhTaGFwZS5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtPWZ1bmN0aW9uKGEsYixjLGQsZSl7YS5zY2FsZSh0aGlzLnNjYWxlKTthLnJvdGF0ZSh0aGlzLmdldFNoYXBlUm90YXRpb24oKSx0aGlzLmZsaXBILHRoaXMuZmxpcFYsYitkLzIsYytlLzIpfTsKbXhTaGFwZS5wcm90b3R5cGUucGFpbnRWZXJ0ZXhTaGFwZT1mdW5jdGlvbihhLGIsYyxkLGUpe3RoaXMucGFpbnRCYWNrZ3JvdW5kKGEsYixjLGQsZSk7dGhpcy5vdXRsaW5lJiZudWxsIT10aGlzLnN0eWxlJiYwIT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQkFDS0dST1VORF9PVVRMSU5FLDApfHwoYS5zZXRTaGFkb3coITEpLHRoaXMucGFpbnRGb3JlZ3JvdW5kKGEsYixjLGQsZSkpfTtteFNoYXBlLnByb3RvdHlwZS5wYWludEJhY2tncm91bmQ9ZnVuY3Rpb24oYSxiLGMsZCxlKXt9O214U2hhcGUucHJvdG90eXBlLnBhaW50Rm9yZWdyb3VuZD1mdW5jdGlvbihhLGIsYyxkLGUpe307bXhTaGFwZS5wcm90b3R5cGUucGFpbnRFZGdlU2hhcGU9ZnVuY3Rpb24oYSxiKXt9OwpteFNoYXBlLnByb3RvdHlwZS5nZXRBcmNTaXplPWZ1bmN0aW9uKGEsYil7dmFyIGM7IjEiPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQUJTT0xVVEVfQVJDU0laRSwwKT9jPU1hdGgubWluKGEvMixNYXRoLm1pbihiLzIsbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkUsbXhDb25zdGFudHMuTElORV9BUkNTSVpFKS8yKSk6KGM9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkUsMTAwKm14Q29uc3RhbnRzLlJFQ1RBTkdMRV9ST1VORElOR19GQUNUT1IpLzEwMCxjPU1hdGgubWluKGEqYyxiKmMpKTtyZXR1cm4gY307Cm14U2hhcGUucHJvdG90eXBlLnBhaW50R2xhc3NFZmZlY3Q9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnPU1hdGguY2VpbCh0aGlzLnN0cm9rZXdpZHRoLzIpO2Euc2V0R3JhZGllbnQoIiNmZmZmZmYiLCIjZmZmZmZmIixiLGMsZCwuNiplLCJzb3V0aCIsLjksLjEpO2EuYmVnaW4oKTtmKz0yKmc7dGhpcy5pc1JvdW5kZWQ/KGEubW92ZVRvKGItZytmLGMtZyksYS5xdWFkVG8oYi1nLGMtZyxiLWcsYy1nK2YpLGEubGluZVRvKGItZyxjKy40KmUpLGEucXVhZFRvKGIrLjUqZCxjKy43KmUsYitkK2csYysuNCplKSxhLmxpbmVUbyhiK2QrZyxjLWcrZiksYS5xdWFkVG8oYitkK2csYy1nLGIrZCtnLWYsYy1nKSk6KGEubW92ZVRvKGItZyxjLWcpLGEubGluZVRvKGItZyxjKy40KmUpLGEucXVhZFRvKGIrLjUqZCxjKy43KmUsYitkK2csYysuNCplKSxhLmxpbmVUbyhiK2QrZyxjLWcpKTthLmNsb3NlKCk7YS5maWxsKCl9OwpteFNoYXBlLnByb3RvdHlwZS5hZGRQb2ludHM9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyl7aWYobnVsbCE9YiYmMDxiLmxlbmd0aCl7Zz1udWxsIT1nP2c6ITA7dmFyIGs9YltiLmxlbmd0aC0xXTtpZihlJiZjKXtiPWIuc2xpY2UoKTt2YXIgbD1iWzBdLGw9bmV3IG14UG9pbnQoay54KyhsLngtay54KS8yLGsueSsobC55LWsueSkvMik7Yi5zcGxpY2UoMCwwLGwpfXZhciBtPWJbMF0sbD0xO2ZvcihnP2EubW92ZVRvKG0ueCxtLnkpOmEubGluZVRvKG0ueCxtLnkpO2w8KGU/Yi5sZW5ndGg6Yi5sZW5ndGgtMSk7KXtnPWJbbXhVdGlscy5tb2QobCxiLmxlbmd0aCldO3ZhciBuPW0ueC1nLngsbT1tLnktZy55O2lmKGMmJigwIT1ufHwwIT1tKSYmKG51bGw9PWZ8fDA+bXhVdGlscy5pbmRleE9mKGYsbC0xKSkpe3ZhciBwPU1hdGguc3FydChuKm4rbSptKTthLmxpbmVUbyhnLngrbipNYXRoLm1pbihkLHAvMikvcCxnLnkrbSpNYXRoLm1pbihkLHAvMikvcCk7Zm9yKG09YltteFV0aWxzLm1vZChsKwoxLGIubGVuZ3RoKV07bDxiLmxlbmd0aC0yJiYwPT1NYXRoLnJvdW5kKG0ueC1nLngpJiYwPT1NYXRoLnJvdW5kKG0ueS1nLnkpOyltPWJbbXhVdGlscy5tb2QobCsyLGIubGVuZ3RoKV0sbCsrO249bS54LWcueDttPW0ueS1nLnk7cD1NYXRoLm1heCgxLE1hdGguc3FydChuKm4rbSptKSk7bj1nLngrbipNYXRoLm1pbihkLHAvMikvcDttPWcueSttKk1hdGgubWluKGQscC8yKS9wO2EucXVhZFRvKGcueCxnLnksbixtKTtnPW5ldyBteFBvaW50KG4sbSl9ZWxzZSBhLmxpbmVUbyhnLngsZy55KTttPWc7bCsrfWU/YS5jbG9zZSgpOmEubGluZVRvKGsueCxrLnkpfX07Cm14U2hhcGUucHJvdG90eXBlLnJlc2V0U3R5bGVzPWZ1bmN0aW9uKCl7dGhpcy5pbml0U3R5bGVzKCk7dGhpcy5zcGFjaW5nPTA7ZGVsZXRlIHRoaXMuZmlsbDtkZWxldGUgdGhpcy5ncmFkaWVudDtkZWxldGUgdGhpcy5ncmFkaWVudERpcmVjdGlvbjtkZWxldGUgdGhpcy5zdHJva2U7ZGVsZXRlIHRoaXMuc3RhcnRTaXplO2RlbGV0ZSB0aGlzLmVuZFNpemU7ZGVsZXRlIHRoaXMuc3RhcnRBcnJvdztkZWxldGUgdGhpcy5lbmRBcnJvdztkZWxldGUgdGhpcy5kaXJlY3Rpb247ZGVsZXRlIHRoaXMuaXNTaGFkb3c7ZGVsZXRlIHRoaXMuaXNEYXNoZWQ7ZGVsZXRlIHRoaXMuaXNSb3VuZGVkO2RlbGV0ZSB0aGlzLmdsYXNzfTsKbXhTaGFwZS5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oYSl7dGhpcy5zdGF0ZT1hO3RoaXMuc3R5bGU9YS5zdHlsZTtpZihudWxsIT10aGlzLnN0eWxlKXt0aGlzLmZpbGw9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZJTExDT0xPUix0aGlzLmZpbGwpO3RoaXMuZ3JhZGllbnQ9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0dSQURJRU5UQ09MT1IsdGhpcy5ncmFkaWVudCk7dGhpcy5ncmFkaWVudERpcmVjdGlvbj1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfR1JBRElFTlRfRElSRUNUSU9OLHRoaXMuZ3JhZGllbnREaXJlY3Rpb24pO3RoaXMub3BhY2l0eT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfT1BBQ0lUWSx0aGlzLm9wYWNpdHkpO3RoaXMuZmlsbE9wYWNpdHk9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZJTExfT1BBQ0lUWSwKdGhpcy5maWxsT3BhY2l0eSk7dGhpcy5zdHJva2VPcGFjaXR5PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TVFJPS0VfT1BBQ0lUWSx0aGlzLnN0cm9rZU9wYWNpdHkpO3RoaXMuc3Ryb2tlPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TVFJPS0VDT0xPUix0aGlzLnN0cm9rZSk7dGhpcy5zdHJva2V3aWR0aD1teFV0aWxzLmdldE51bWJlcih0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1NUUk9LRVdJRFRILHRoaXMuc3Ryb2tld2lkdGgpO3RoaXMuc3BhY2luZz1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lORyx0aGlzLnNwYWNpbmcpO3RoaXMuc3RhcnRTaXplPW14VXRpbHMuZ2V0TnVtYmVyKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFLHRoaXMuc3RhcnRTaXplKTt0aGlzLmVuZFNpemU9bXhVdGlscy5nZXROdW1iZXIodGhpcy5zdHlsZSwKbXhDb25zdGFudHMuU1RZTEVfRU5EU0laRSx0aGlzLmVuZFNpemUpO3RoaXMuc3RhcnRBcnJvdz1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1RBUlRBUlJPVyx0aGlzLnN0YXJ0QXJyb3cpO3RoaXMuZW5kQXJyb3c9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0VOREFSUk9XLHRoaXMuZW5kQXJyb3cpO3RoaXMucm90YXRpb249bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OLHRoaXMucm90YXRpb24pO3RoaXMuZGlyZWN0aW9uPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ESVJFQ1RJT04sdGhpcy5kaXJlY3Rpb24pO3RoaXMuZmxpcEg9MT09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZMSVBILDApO3RoaXMuZmxpcFY9MT09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZMSVBWLAowKTtudWxsIT10aGlzLnN0ZW5jaWwmJih0aGlzLmZsaXBIPTE9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic3RlbmNpbEZsaXBIIiwwKXx8dGhpcy5mbGlwSCx0aGlzLmZsaXBWPTE9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic3RlbmNpbEZsaXBWIiwwKXx8dGhpcy5mbGlwVik7aWYodGhpcy5kaXJlY3Rpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSHx8dGhpcy5kaXJlY3Rpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSClhPXRoaXMuZmxpcEgsdGhpcy5mbGlwSD10aGlzLmZsaXBWLHRoaXMuZmxpcFY9YTt0aGlzLmlzU2hhZG93PTE9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TSEFET1csdGhpcy5pc1NoYWRvdyk7dGhpcy5pc0Rhc2hlZD0xPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfREFTSEVELHRoaXMuaXNEYXNoZWQpO3RoaXMuaXNSb3VuZGVkPTE9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwKbXhDb25zdGFudHMuU1RZTEVfUk9VTkRFRCx0aGlzLmlzUm91bmRlZCk7dGhpcy5nbGFzcz0xPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfR0xBU1MsdGhpcy5nbGFzcyk7dGhpcy5maWxsPT1teENvbnN0YW50cy5OT05FJiYodGhpcy5maWxsPW51bGwpO3RoaXMuZ3JhZGllbnQ9PW14Q29uc3RhbnRzLk5PTkUmJih0aGlzLmdyYWRpZW50PW51bGwpO3RoaXMuc3Ryb2tlPT1teENvbnN0YW50cy5OT05FJiYodGhpcy5zdHJva2U9bnVsbCl9fTtteFNoYXBlLnByb3RvdHlwZS5zZXRDdXJzb3I9ZnVuY3Rpb24oYSl7bnVsbD09YSYmKGE9IiIpO3RoaXMuY3Vyc29yPWE7bnVsbCE9dGhpcy5ub2RlJiYodGhpcy5ub2RlLnN0eWxlLmN1cnNvcj1hKX07bXhTaGFwZS5wcm90b3R5cGUuZ2V0Q3Vyc29yPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3Vyc29yfTtteFNoYXBlLnByb3RvdHlwZS5pc1JvdW5kYWJsZT1mdW5jdGlvbigpe3JldHVybiExfTsKbXhTaGFwZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdCb3g9ZnVuY3Rpb24oKXtpZih0aGlzLnVzZVN2Z0JvdW5kaW5nQm94JiZudWxsIT10aGlzLm5vZGUmJm51bGwhPXRoaXMubm9kZS5vd25lclNWR0VsZW1lbnQpdHJ5e3ZhciBhPXRoaXMubm9kZS5nZXRCQm94KCk7aWYoMDxhLndpZHRoJiYwPGEuaGVpZ2h0KXt0aGlzLmJvdW5kaW5nQm94PW5ldyBteFJlY3RhbmdsZShhLngsYS55LGEud2lkdGgsYS5oZWlnaHQpO3RoaXMuYm91bmRpbmdCb3guZ3Jvdyh0aGlzLnN0cm9rZXdpZHRoKnRoaXMuc2NhbGUvMik7cmV0dXJufX1jYXRjaChjKXt9aWYobnVsbCE9dGhpcy5ib3VuZHMpe2E9dGhpcy5jcmVhdGVCb3VuZGluZ0JveCgpO2lmKG51bGwhPWEpe3RoaXMuYXVnbWVudEJvdW5kaW5nQm94KGEpO3ZhciBiPXRoaXMuZ2V0U2hhcGVSb3RhdGlvbigpOzAhPWImJihhPW14VXRpbHMuZ2V0Qm91bmRpbmdCb3goYSxiKSl9dGhpcy5ib3VuZGluZ0JveD1hfX07Cm14U2hhcGUucHJvdG90eXBlLmNyZWF0ZUJvdW5kaW5nQm94PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5ib3VuZHMuY2xvbmUoKTsobnVsbCE9dGhpcy5zdGVuY2lsJiYodGhpcy5kaXJlY3Rpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSHx8dGhpcy5kaXJlY3Rpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSCl8fHRoaXMuaXNQYWludEJvdW5kc0ludmVydGVkKCkpJiZhLnJvdGF0ZTkwKCk7cmV0dXJuIGF9O214U2hhcGUucHJvdG90eXBlLmF1Z21lbnRCb3VuZGluZ0JveD1mdW5jdGlvbihhKXt0aGlzLmlzU2hhZG93JiYoYS53aWR0aCs9TWF0aC5jZWlsKG14Q29uc3RhbnRzLlNIQURPV19PRkZTRVRfWCp0aGlzLnNjYWxlKSxhLmhlaWdodCs9TWF0aC5jZWlsKG14Q29uc3RhbnRzLlNIQURPV19PRkZTRVRfWSp0aGlzLnNjYWxlKSk7YS5ncm93KHRoaXMuc3Ryb2tld2lkdGgqdGhpcy5zY2FsZS8yKX07Cm14U2hhcGUucHJvdG90eXBlLmlzUGFpbnRCb3VuZHNJbnZlcnRlZD1mdW5jdGlvbigpe3JldHVybiBudWxsPT10aGlzLnN0ZW5jaWwmJih0aGlzLmRpcmVjdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIfHx0aGlzLmRpcmVjdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIKX07bXhTaGFwZS5wcm90b3R5cGUuZ2V0Um90YXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5yb3RhdGlvbj90aGlzLnJvdGF0aW9uOjB9O214U2hhcGUucHJvdG90eXBlLmdldFRleHRSb3RhdGlvbj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0Um90YXRpb24oKTsxIT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfSE9SSVpPTlRBTCwxKSYmKGErPW14VGV4dC5wcm90b3R5cGUudmVydGljYWxUZXh0Um90YXRpb24pO3JldHVybiBhfTsKbXhTaGFwZS5wcm90b3R5cGUuZ2V0U2hhcGVSb3RhdGlvbj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0Um90YXRpb24oKTtudWxsIT10aGlzLmRpcmVjdGlvbiYmKHRoaXMuZGlyZWN0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEg/YSs9MjcwOnRoaXMuZGlyZWN0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVD9hKz0xODA6dGhpcy5kaXJlY3Rpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSCYmKGErPTkwKSk7cmV0dXJuIGF9OwpteFNoYXBlLnByb3RvdHlwZS5jcmVhdGVUcmFuc3BhcmVudFN2Z1JlY3RhbmdsZT1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobXhDb25zdGFudHMuTlNfU1ZHLCJyZWN0Iik7ZS5zZXRBdHRyaWJ1dGUoIngiLGEpO2Uuc2V0QXR0cmlidXRlKCJ5IixiKTtlLnNldEF0dHJpYnV0ZSgid2lkdGgiLGMpO2Uuc2V0QXR0cmlidXRlKCJoZWlnaHQiLGQpO2Uuc2V0QXR0cmlidXRlKCJmaWxsIiwibm9uZSIpO2Uuc2V0QXR0cmlidXRlKCJzdHJva2UiLCJub25lIik7ZS5zZXRBdHRyaWJ1dGUoInBvaW50ZXItZXZlbnRzIiwiYWxsIik7cmV0dXJuIGV9O214U2hhcGUucHJvdG90eXBlLnNldFRyYW5zcGFyZW50QmFja2dyb3VuZEltYWdlPWZ1bmN0aW9uKGEpe2Euc3R5bGUuYmFja2dyb3VuZEltYWdlPSJ1cmwoJyIrbXhDbGllbnQuaW1hZ2VCYXNlUGF0aCsiL3RyYW5zcGFyZW50LmdpZicpIn07Cm14U2hhcGUucHJvdG90eXBlLnJlbGVhc2VTdmdHcmFkaWVudHM9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSlmb3IodmFyIGIgaW4gYSl7dmFyIGM9YVtiXTtudWxsIT1jJiYoYy5teFJlZkNvdW50PShjLm14UmVmQ291bnR8fDApLTEsMD09Yy5teFJlZkNvdW50JiZudWxsIT1jLnBhcmVudE5vZGUmJmMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKSl9fTtteFNoYXBlLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5ub2RlJiYobXhFdmVudC5yZWxlYXNlKHRoaXMubm9kZSksbnVsbCE9dGhpcy5ub2RlLnBhcmVudE5vZGUmJnRoaXMubm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZSksdGhpcy5ub2RlPW51bGwpO3RoaXMucmVsZWFzZVN2Z0dyYWRpZW50cyh0aGlzLm9sZEdyYWRpZW50cyk7dGhpcy5vbGRHcmFkaWVudHM9bnVsbH07CmZ1bmN0aW9uIG14U3RlbmNpbChhKXt0aGlzLmRlc2M9YTt0aGlzLnBhcnNlRGVzY3JpcHRpb24oKTt0aGlzLnBhcnNlQ29uc3RyYWludHMoKX1teFV0aWxzLmV4dGVuZChteFN0ZW5jaWwsbXhTaGFwZSk7bXhTdGVuY2lsLmRlZmF1bHRMb2NhbGl6ZWQ9ITE7bXhTdGVuY2lsLmFsbG93RXZhbD0hMTtteFN0ZW5jaWwucHJvdG90eXBlLmRlc2M9bnVsbDtteFN0ZW5jaWwucHJvdG90eXBlLmNvbnN0cmFpbnRzPW51bGw7bXhTdGVuY2lsLnByb3RvdHlwZS5hc3BlY3Q9bnVsbDtteFN0ZW5jaWwucHJvdG90eXBlLncwPW51bGw7bXhTdGVuY2lsLnByb3RvdHlwZS5oMD1udWxsO214U3RlbmNpbC5wcm90b3R5cGUuYmdOb2RlPW51bGw7bXhTdGVuY2lsLnByb3RvdHlwZS5mZ05vZGU9bnVsbDtteFN0ZW5jaWwucHJvdG90eXBlLnN0cm9rZXdpZHRoPW51bGw7Cm14U3RlbmNpbC5wcm90b3R5cGUucGFyc2VEZXNjcmlwdGlvbj1mdW5jdGlvbigpe3RoaXMuZmdOb2RlPXRoaXMuZGVzYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZm9yZWdyb3VuZCIpWzBdO3RoaXMuYmdOb2RlPXRoaXMuZGVzYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYmFja2dyb3VuZCIpWzBdO3RoaXMudzA9TnVtYmVyKHRoaXMuZGVzYy5nZXRBdHRyaWJ1dGUoInciKXx8MTAwKTt0aGlzLmgwPU51bWJlcih0aGlzLmRlc2MuZ2V0QXR0cmlidXRlKCJoIil8fDEwMCk7dmFyIGE9dGhpcy5kZXNjLmdldEF0dHJpYnV0ZSgiYXNwZWN0Iik7dGhpcy5hc3BlY3Q9bnVsbCE9YT9hOiJ2YXJpYWJsZSI7YT10aGlzLmRlc2MuZ2V0QXR0cmlidXRlKCJzdHJva2V3aWR0aCIpO3RoaXMuc3Ryb2tld2lkdGg9bnVsbCE9YT9hOiIxIn07Cm14U3RlbmNpbC5wcm90b3R5cGUucGFyc2VDb25zdHJhaW50cz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZGVzYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgiY29ubmVjdGlvbnMiKVswXTtpZihudWxsIT1hJiYoYT1teFV0aWxzLmdldENoaWxkTm9kZXMoYSksbnVsbCE9YSYmMDxhLmxlbmd0aCkpe3RoaXMuY29uc3RyYWludHM9W107Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspdGhpcy5jb25zdHJhaW50cy5wdXNoKHRoaXMucGFyc2VDb25zdHJhaW50KGFbYl0pKX19O214U3RlbmNpbC5wcm90b3R5cGUucGFyc2VDb25zdHJhaW50PWZ1bmN0aW9uKGEpe3ZhciBiPU51bWJlcihhLmdldEF0dHJpYnV0ZSgieCIpKSxjPU51bWJlcihhLmdldEF0dHJpYnV0ZSgieSIpKSxkPSIxIj09YS5nZXRBdHRyaWJ1dGUoInBlcmltZXRlciIpO2E9YS5nZXRBdHRyaWJ1dGUoIm5hbWUiKTtyZXR1cm4gbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoYixjKSxkLGEpfTsKbXhTdGVuY2lsLnByb3RvdHlwZS5ldmFsdWF0ZVRleHRBdHRyaWJ1dGU9ZnVuY3Rpb24oYSxiLGMpe2I9dGhpcy5ldmFsdWF0ZUF0dHJpYnV0ZShhLGIsYyk7YT1hLmdldEF0dHJpYnV0ZSgibG9jYWxpemVkIik7aWYobXhTdGVuY2lsLmRlZmF1bHRMb2NhbGl6ZWQmJm51bGw9PWF8fCIxIj09YSliPW14UmVzb3VyY2VzLmdldChiKTtyZXR1cm4gYn07bXhTdGVuY2lsLnByb3RvdHlwZS5ldmFsdWF0ZUF0dHJpYnV0ZT1mdW5jdGlvbihhLGIsYyl7Yj1hLmdldEF0dHJpYnV0ZShiKTtudWxsPT1iJiYoYT1teFV0aWxzLmdldFRleHRDb250ZW50KGEpLG51bGwhPWEmJm14U3RlbmNpbC5hbGxvd0V2YWwmJihhPW14VXRpbHMuZXZhbChhKSwiZnVuY3Rpb24iPT10eXBlb2YgYSYmKGI9YShjKSkpKTtyZXR1cm4gYn07Cm14U3RlbmNpbC5wcm90b3R5cGUuZHJhd1NoYXBlPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgZz1hLnN0YXRlcy5zbGljZSgpLGs9bXhVdGlscy5nZXRWYWx1ZShiLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0RJUkVDVElPTixudWxsKSxrPXRoaXMuY29tcHV0ZUFzcGVjdChiLnN0eWxlLGMsZCxlLGYsayksbD1NYXRoLm1pbihrLndpZHRoLGsuaGVpZ2h0KSxsPSJpbmhlcml0Ij09dGhpcy5zdHJva2V3aWR0aD9OdW1iZXIobXhVdGlscy5nZXROdW1iZXIoYi5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TVFJPS0VXSURUSCwxKSk6TnVtYmVyKHRoaXMuc3Ryb2tld2lkdGgpKmw7YS5zZXRTdHJva2VXaWR0aChsKTtudWxsIT1iLnN0eWxlJiYiMSI9PW14VXRpbHMuZ2V0VmFsdWUoYi5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9QT0lOVEVSX0VWRU5UUywiMCIpJiYoYS5zZXRTdHJva2VDb2xvcihteENvbnN0YW50cy5OT05FKSxhLnJlY3QoYyxkLGUsZiksYS5zdHJva2UoKSxhLnNldFN0cm9rZUNvbG9yKGIuc3Ryb2tlKSk7CnRoaXMuZHJhd0NoaWxkcmVuKGEsYixjLGQsZSxmLHRoaXMuYmdOb2RlLGssITEsITApO3RoaXMuZHJhd0NoaWxkcmVuKGEsYixjLGQsZSxmLHRoaXMuZmdOb2RlLGssITAsIWIub3V0bGluZXx8bnVsbD09Yi5zdHlsZXx8MD09bXhVdGlscy5nZXRWYWx1ZShiLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0JBQ0tHUk9VTkRfT1VUTElORSwwKSk7YS5zdGF0ZXMubGVuZ3RoIT1nLmxlbmd0aCYmKGEuc3RhdGVzPWcpfTtteFN0ZW5jaWwucHJvdG90eXBlLmRyYXdDaGlsZHJlbj1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGssbCxtKXtpZihudWxsIT1nJiYwPGUmJjA8Zilmb3IoYz1nLmZpcnN0Q2hpbGQ7bnVsbCE9YzspYy5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVCYmdGhpcy5kcmF3Tm9kZShhLGIsYyxrLGwsbSksYz1jLm5leHRTaWJsaW5nfTsKbXhTdGVuY2lsLnByb3RvdHlwZS5jb21wdXRlQXNwZWN0PWZ1bmN0aW9uKGEsYixjLGQsZSxmKXthPWI7Yj1kL3RoaXMudzA7dmFyIGc9ZS90aGlzLmgwO2lmKGY9Zj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIfHxmPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEgpe2c9ZC90aGlzLmgwO2I9ZS90aGlzLncwO3ZhciBrPShkLWUpLzI7YSs9aztjLT1rfSJmaXhlZCI9PXRoaXMuYXNwZWN0JiYoYj1nPU1hdGgubWluKGIsZyksZj8oYSs9KGUtdGhpcy53MCpiKS8yLGMrPShkLXRoaXMuaDAqZykvMik6KGErPShkLXRoaXMudzAqYikvMixjKz0oZS10aGlzLmgwKmcpLzIpKTtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKGEsYyxiLGcpfTsKbXhTdGVuY2lsLnByb3RvdHlwZS5kcmF3Tm9kZT1mdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGc9Yy5ub2RlTmFtZSxrPWQueCxsPWQueSxtPWQud2lkdGgsbj1kLmhlaWdodCxwPU1hdGgubWluKG0sbik7aWYoInNhdmUiPT1nKWEuc2F2ZSgpO2Vsc2UgaWYoInJlc3RvcmUiPT1nKWEucmVzdG9yZSgpO2Vsc2UgaWYoZil7aWYoInBhdGgiPT1nKXthLmJlZ2luKCk7cD0hMDtpZigiMSI9PWMuZ2V0QXR0cmlidXRlKCJyb3VuZGVkIikpe2Zvcih2YXIgcD0hMSxxPU51bWJlcihjLmdldEF0dHJpYnV0ZSgiYXJjU2l6ZSIpKSxyPTAsdD1bXSx1PWMuZmlyc3RDaGlsZDtudWxsIT11Oyl7aWYodS5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVCl7dmFyIHg9dS5ub2RlTmFtZTtpZigibW92ZSI9PXh8fCJsaW5lIj09eCkibW92ZSIhPXgmJjAhPXQubGVuZ3RofHx0LnB1c2goW10pLHRbdC5sZW5ndGgtMV0ucHVzaChuZXcgbXhQb2ludChrK051bWJlcih1LmdldEF0dHJpYnV0ZSgieCIpKSoKbSxsK051bWJlcih1LmdldEF0dHJpYnV0ZSgieSIpKSpuKSkscisrO2Vsc2V7cD0hMDticmVha319dT11Lm5leHRTaWJsaW5nfWlmKCFwJiYwPHIpZm9yKG09MDttPHQubGVuZ3RoO20rKyluPSExLGw9dFttXVswXSxrPXRbbV1bdFttXS5sZW5ndGgtMV0sbC54PT1rLngmJmwueT09ay55JiYodFttXS5wb3AoKSxuPSEwKSx0aGlzLmFkZFBvaW50cyhhLHRbbV0sITAscSxuKTtlbHNlIHA9ITB9aWYocClmb3IodT1jLmZpcnN0Q2hpbGQ7bnVsbCE9dTspdS5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVCYmdGhpcy5kcmF3Tm9kZShhLGIsdSxkLGUsZiksdT11Lm5leHRTaWJsaW5nfWVsc2UgaWYoImNsb3NlIj09ZylhLmNsb3NlKCk7ZWxzZSBpZigibW92ZSI9PWcpYS5tb3ZlVG8oaytOdW1iZXIoYy5nZXRBdHRyaWJ1dGUoIngiKSkqbSxsK051bWJlcihjLmdldEF0dHJpYnV0ZSgieSIpKSpuKTtlbHNlIGlmKCJsaW5lIj09ZylhLmxpbmVUbyhrK051bWJlcihjLmdldEF0dHJpYnV0ZSgieCIpKSoKbSxsK051bWJlcihjLmdldEF0dHJpYnV0ZSgieSIpKSpuKTtlbHNlIGlmKCJxdWFkIj09ZylhLnF1YWRUbyhrK051bWJlcihjLmdldEF0dHJpYnV0ZSgieDEiKSkqbSxsK051bWJlcihjLmdldEF0dHJpYnV0ZSgieTEiKSkqbixrK051bWJlcihjLmdldEF0dHJpYnV0ZSgieDIiKSkqbSxsK051bWJlcihjLmdldEF0dHJpYnV0ZSgieTIiKSkqbik7ZWxzZSBpZigiY3VydmUiPT1nKWEuY3VydmVUbyhrK051bWJlcihjLmdldEF0dHJpYnV0ZSgieDEiKSkqbSxsK051bWJlcihjLmdldEF0dHJpYnV0ZSgieTEiKSkqbixrK051bWJlcihjLmdldEF0dHJpYnV0ZSgieDIiKSkqbSxsK051bWJlcihjLmdldEF0dHJpYnV0ZSgieTIiKSkqbixrK051bWJlcihjLmdldEF0dHJpYnV0ZSgieDMiKSkqbSxsK051bWJlcihjLmdldEF0dHJpYnV0ZSgieTMiKSkqbik7ZWxzZSBpZigiYXJjIj09ZylhLmFyY1RvKE51bWJlcihjLmdldEF0dHJpYnV0ZSgicngiKSkqbSxOdW1iZXIoYy5nZXRBdHRyaWJ1dGUoInJ5IikpKgpuLE51bWJlcihjLmdldEF0dHJpYnV0ZSgieC1heGlzLXJvdGF0aW9uIikpLE51bWJlcihjLmdldEF0dHJpYnV0ZSgibGFyZ2UtYXJjLWZsYWciKSksTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJzd2VlcC1mbGFnIikpLGsrTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ4IikpKm0sbCtOdW1iZXIoYy5nZXRBdHRyaWJ1dGUoInkiKSkqbik7ZWxzZSBpZigicmVjdCI9PWcpYS5yZWN0KGsrTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ4IikpKm0sbCtOdW1iZXIoYy5nZXRBdHRyaWJ1dGUoInkiKSkqbixOdW1iZXIoYy5nZXRBdHRyaWJ1dGUoInciKSkqbSxOdW1iZXIoYy5nZXRBdHRyaWJ1dGUoImgiKSkqbik7ZWxzZSBpZigicm91bmRyZWN0Ij09ZyliPU51bWJlcihjLmdldEF0dHJpYnV0ZSgiYXJjc2l6ZSIpKSwwPT1iJiYoYj0xMDAqbXhDb25zdGFudHMuUkVDVEFOR0xFX1JPVU5ESU5HX0ZBQ1RPUiksZD1OdW1iZXIoYy5nZXRBdHRyaWJ1dGUoInciKSkqbSxmPU51bWJlcihjLmdldEF0dHJpYnV0ZSgiaCIpKSoKbixiPU51bWJlcihiKS8xMDAsYj1NYXRoLm1pbihkKmIsZipiKSxhLnJvdW5kcmVjdChrK051bWJlcihjLmdldEF0dHJpYnV0ZSgieCIpKSptLGwrTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ5IikpKm4sZCxmLGIsYik7ZWxzZSBpZigiZWxsaXBzZSI9PWcpYS5lbGxpcHNlKGsrTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ4IikpKm0sbCtOdW1iZXIoYy5nZXRBdHRyaWJ1dGUoInkiKSkqbixOdW1iZXIoYy5nZXRBdHRyaWJ1dGUoInciKSkqbSxOdW1iZXIoYy5nZXRBdHRyaWJ1dGUoImgiKSkqbik7ZWxzZSBpZigiaW1hZ2UiPT1nKWIub3V0bGluZXx8KGI9dGhpcy5ldmFsdWF0ZUF0dHJpYnV0ZShjLCJzcmMiLGIpLGEuaW1hZ2UoaytOdW1iZXIoYy5nZXRBdHRyaWJ1dGUoIngiKSkqbSxsK051bWJlcihjLmdldEF0dHJpYnV0ZSgieSIpKSpuLE51bWJlcihjLmdldEF0dHJpYnV0ZSgidyIpKSptLE51bWJlcihjLmdldEF0dHJpYnV0ZSgiaCIpKSpuLGIsITEsIjEiPT1jLmdldEF0dHJpYnV0ZSgiZmxpcEgiKSwKIjEiPT1jLmdldEF0dHJpYnV0ZSgiZmxpcFYiKSkpO2Vsc2UgaWYoInRleHQiPT1nKWIub3V0bGluZXx8KGQ9dGhpcy5ldmFsdWF0ZVRleHRBdHRyaWJ1dGUoYywic3RyIixiKSxmPSIxIj09Yy5nZXRBdHRyaWJ1dGUoInZlcnRpY2FsIik/LTkwOjAsIjAiPT1jLmdldEF0dHJpYnV0ZSgiYWxpZ24tc2hhcGUiKSYmKHA9Yi5yb3RhdGlvbixxPTE9PW14VXRpbHMuZ2V0VmFsdWUoYi5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GTElQSCwwKSxiPTE9PW14VXRpbHMuZ2V0VmFsdWUoYi5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GTElQViwwKSxmPXEmJmI/Zi1wOnF8fGI/ZitwOmYtcCksZi09Yy5nZXRBdHRyaWJ1dGUoInJvdGF0aW9uIiksYS50ZXh0KGsrTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ4IikpKm0sbCtOdW1iZXIoYy5nZXRBdHRyaWJ1dGUoInkiKSkqbiwwLDAsZCxjLmdldEF0dHJpYnV0ZSgiYWxpZ24iKXx8ImxlZnQiLGMuZ2V0QXR0cmlidXRlKCJ2YWxpZ24iKXx8InRvcCIsCiExLCIiLG51bGwsITEsZikpO2Vsc2UgaWYoImluY2x1ZGUtc2hhcGUiPT1nKXA9bXhTdGVuY2lsUmVnaXN0cnkuZ2V0U3RlbmNpbChjLmdldEF0dHJpYnV0ZSgibmFtZSIpKSxudWxsIT1wJiYoays9TnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ4IikpKm0sbCs9TnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ5IikpKm4sZD1OdW1iZXIoYy5nZXRBdHRyaWJ1dGUoInciKSkqbSxmPU51bWJlcihjLmdldEF0dHJpYnV0ZSgiaCIpKSpuLHAuZHJhd1NoYXBlKGEsYixrLGwsZCxmKSk7ZWxzZSBpZigiZmlsbHN0cm9rZSI9PWcpYS5maWxsQW5kU3Ryb2tlKCk7ZWxzZSBpZigiZmlsbCI9PWcpYS5maWxsKCk7ZWxzZSBpZigic3Ryb2tlIj09ZylhLnN0cm9rZSgpO2Vsc2UgaWYoInN0cm9rZXdpZHRoIj09ZyltPSIxIj09Yy5nZXRBdHRyaWJ1dGUoImZpeGVkIik/MTpwLGEuc2V0U3Ryb2tlV2lkdGgoTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ3aWR0aCIpKSptKTtlbHNlIGlmKCJkYXNoZWQiPT1nKWEuc2V0RGFzaGVkKCIxIj09CmMuZ2V0QXR0cmlidXRlKCJkYXNoZWQiKSk7ZWxzZSBpZigiZGFzaHBhdHRlcm4iPT1nKXtpZihjPWMuZ2V0QXR0cmlidXRlKCJwYXR0ZXJuIiksbnVsbCE9Yyl7Yz1jLnNwbGl0KCIgIik7bj1bXTtmb3IobT0wO208Yy5sZW5ndGg7bSsrKTA8Y1ttXS5sZW5ndGgmJm4ucHVzaChOdW1iZXIoY1ttXSkqcCk7Yz1uLmpvaW4oIiAiKTthLnNldERhc2hQYXR0ZXJuKGMpfX1lbHNlInN0cm9rZWNvbG9yIj09Zz9hLnNldFN0cm9rZUNvbG9yKGMuZ2V0QXR0cmlidXRlKCJjb2xvciIpKToibGluZWNhcCI9PWc/YS5zZXRMaW5lQ2FwKGMuZ2V0QXR0cmlidXRlKCJjYXAiKSk6ImxpbmVqb2luIj09Zz9hLnNldExpbmVKb2luKGMuZ2V0QXR0cmlidXRlKCJqb2luIikpOiJtaXRlcmxpbWl0Ij09Zz9hLnNldE1pdGVyTGltaXQoTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJsaW1pdCIpKSk6ImZpbGxjb2xvciI9PWc/YS5zZXRGaWxsQ29sb3IoYy5nZXRBdHRyaWJ1dGUoImNvbG9yIikpOiJhbHBoYSI9PQpnP2Euc2V0QWxwaGEoYy5nZXRBdHRyaWJ1dGUoImFscGhhIikpOiJmaWxsYWxwaGEiPT1nP2Euc2V0QWxwaGEoYy5nZXRBdHRyaWJ1dGUoImFscGhhIikpOiJzdHJva2VhbHBoYSI9PWc/YS5zZXRBbHBoYShjLmdldEF0dHJpYnV0ZSgiYWxwaGEiKSk6ImZvbnRjb2xvciI9PWc/YS5zZXRGb250Q29sb3IoYy5nZXRBdHRyaWJ1dGUoImNvbG9yIikpOiJmb250c3R5bGUiPT1nP2Euc2V0Rm9udFN0eWxlKGMuZ2V0QXR0cmlidXRlKCJzdHlsZSIpKToiZm9udGZhbWlseSI9PWc/YS5zZXRGb250RmFtaWx5KGMuZ2V0QXR0cmlidXRlKCJmYW1pbHkiKSk6ImZvbnRzaXplIj09ZyYmYS5zZXRGb250U2l6ZShOdW1iZXIoYy5nZXRBdHRyaWJ1dGUoInNpemUiKSkqcCk7IWV8fCJmaWxsc3Ryb2tlIiE9ZyYmImZpbGwiIT1nJiYic3Ryb2tlIiE9Z3x8YS5zZXRTaGFkb3coITEpfX07CnZhciBteFN0ZW5jaWxSZWdpc3RyeT17c3RlbmNpbHM6e30sYWRkU3RlbmNpbDpmdW5jdGlvbihhLGIpe214U3RlbmNpbFJlZ2lzdHJ5LnN0ZW5jaWxzW2FdPWJ9LGdldFN0ZW5jaWw6ZnVuY3Rpb24oYSl7cmV0dXJuIG14U3RlbmNpbFJlZ2lzdHJ5LnN0ZW5jaWxzW2FdfX0sbXhNYXJrZXI9e21hcmtlcnM6W10sYWRkTWFya2VyOmZ1bmN0aW9uKGEsYil7bXhNYXJrZXIubWFya2Vyc1thXT1ifSxjcmVhdGVNYXJrZXI6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxrLGwsbSl7dmFyIG49bXhNYXJrZXIubWFya2Vyc1tjXTtyZXR1cm4gbnVsbCE9bj9uKGEsYixjLGQsZSxmLGcsayxsLG0pOm51bGx9fTsKKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhKXthPW51bGwhPWE/YToyO3JldHVybiBmdW5jdGlvbihiLGMsZCxrLGwsbSxuLHAscSxyKXtjPWwqcSoxLjExODtwPW0qcSoxLjExODtsKj1uK3E7bSo9bitxO3ZhciBlPWsuY2xvbmUoKTtlLngtPWM7ZS55LT1wO249ZCE9bXhDb25zdGFudHMuQVJST1dfQ0xBU1NJQyYmZCE9bXhDb25zdGFudHMuQVJST1dfQ0xBU1NJQ19USElOPzE6Ljc1O2sueCs9LWwqbi1jO2sueSs9LW0qbi1wO3JldHVybiBmdW5jdGlvbigpe2IuYmVnaW4oKTtiLm1vdmVUbyhlLngsZS55KTtiLmxpbmVUbyhlLngtbC1tL2EsZS55LW0rbC9hKTtkIT1teENvbnN0YW50cy5BUlJPV19DTEFTU0lDJiZkIT1teENvbnN0YW50cy5BUlJPV19DTEFTU0lDX1RISU58fGIubGluZVRvKGUueC0zKmwvNCxlLnktMyptLzQpO2IubGluZVRvKGUueCttL2EtbCxlLnktbS1sL2EpO2IuY2xvc2UoKTtyP2IuZmlsbEFuZFN0cm9rZSgpOmIuc3Ryb2tlKCl9fX1mdW5jdGlvbiBiKGEpe2E9Cm51bGwhPWE/YToyO3JldHVybiBmdW5jdGlvbihiLGMsZCxrLGwsbSxuLHAscSxyKXtjPWwqcSoxLjExODtkPW0qcSoxLjExODtsKj1uK3E7bSo9bitxO3ZhciBlPWsuY2xvbmUoKTtlLngtPWM7ZS55LT1kO2sueCs9MiotYztrLnkrPTIqLWQ7cmV0dXJuIGZ1bmN0aW9uKCl7Yi5iZWdpbigpO2IubW92ZVRvKGUueC1sLW0vYSxlLnktbStsL2EpO2IubGluZVRvKGUueCxlLnkpO2IubGluZVRvKGUueCttL2EtbCxlLnktbS1sL2EpO2Iuc3Ryb2tlKCl9fX1mdW5jdGlvbiBjKGEsYixjLGcsayxsLG0sbixwLHEpe249Yz09bXhDb25zdGFudHMuQVJST1dfRElBTU9ORD8uNzA3MTouOTg2MjtiPWsqcCpuO24qPWwqcDtrKj1tK3A7bCo9bStwO3ZhciBkPWcuY2xvbmUoKTtkLngtPWI7ZC55LT1uO2cueCs9LWstYjtnLnkrPS1sLW47dmFyIGU9Yz09bXhDb25zdGFudHMuQVJST1dfRElBTU9ORD8yOjMuNDtyZXR1cm4gZnVuY3Rpb24oKXthLmJlZ2luKCk7YS5tb3ZlVG8oZC54LGQueSk7YS5saW5lVG8oZC54LQprLzItbC9lLGQueStrL2UtbC8yKTthLmxpbmVUbyhkLngtayxkLnktbCk7YS5saW5lVG8oZC54LWsvMitsL2UsZC55LWwvMi1rL2UpO2EuY2xvc2UoKTtxP2EuZmlsbEFuZFN0cm9rZSgpOmEuc3Ryb2tlKCl9fW14TWFya2VyLmFkZE1hcmtlcigiY2xhc3NpYyIsYSgyKSk7bXhNYXJrZXIuYWRkTWFya2VyKCJjbGFzc2ljVGhpbiIsYSgzKSk7bXhNYXJrZXIuYWRkTWFya2VyKCJibG9jayIsYSgyKSk7bXhNYXJrZXIuYWRkTWFya2VyKCJibG9ja1RoaW4iLGEoMykpO214TWFya2VyLmFkZE1hcmtlcigib3BlbiIsYigyKSk7bXhNYXJrZXIuYWRkTWFya2VyKCJvcGVuVGhpbiIsYigzKSk7bXhNYXJrZXIuYWRkTWFya2VyKCJvdmFsIixmdW5jdGlvbihhLGIsYyxnLGssbCxtLG4scCxxKXt2YXIgZD1tLzIsZT1nLmNsb25lKCk7Zy54LT1rKmQ7Zy55LT1sKmQ7cmV0dXJuIGZ1bmN0aW9uKCl7YS5lbGxpcHNlKGUueC1kLGUueS1kLG0sbSk7cT9hLmZpbGxBbmRTdHJva2UoKTphLnN0cm9rZSgpfX0pOwpteE1hcmtlci5hZGRNYXJrZXIoImRpYW1vbmQiLGMpO214TWFya2VyLmFkZE1hcmtlcigiZGlhbW9uZFRoaW4iLGMpfSkoKTtmdW5jdGlvbiBteEFjdG9yKGEsYixjLGQpe214U2hhcGUuY2FsbCh0aGlzKTt0aGlzLmJvdW5kcz1hO3RoaXMuZmlsbD1iO3RoaXMuc3Ryb2tlPWM7dGhpcy5zdHJva2V3aWR0aD1udWxsIT1kP2Q6MX1teFV0aWxzLmV4dGVuZChteEFjdG9yLG14U2hhcGUpO214QWN0b3IucHJvdG90eXBlLnBhaW50VmVydGV4U2hhcGU9ZnVuY3Rpb24oYSxiLGMsZCxlKXthLnRyYW5zbGF0ZShiLGMpO2EuYmVnaW4oKTt0aGlzLnJlZHJhd1BhdGgoYSxiLGMsZCxlKTthLmZpbGxBbmRTdHJva2UoKX07Cm14QWN0b3IucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGMsZCxlKXtiPWQvMzthLm1vdmVUbygwLGUpO2EuY3VydmVUbygwLDMqZS81LDAsMiplLzUsZC8yLDIqZS81KTthLmN1cnZlVG8oZC8yLWIsMiplLzUsZC8yLWIsMCxkLzIsMCk7YS5jdXJ2ZVRvKGQvMitiLDAsZC8yK2IsMiplLzUsZC8yLDIqZS81KTthLmN1cnZlVG8oZCwyKmUvNSxkLDMqZS81LGQsZSk7YS5jbG9zZSgpfTtmdW5jdGlvbiBteENsb3VkKGEsYixjLGQpe214QWN0b3IuY2FsbCh0aGlzKTt0aGlzLmJvdW5kcz1hO3RoaXMuZmlsbD1iO3RoaXMuc3Ryb2tlPWM7dGhpcy5zdHJva2V3aWR0aD1udWxsIT1kP2Q6MX1teFV0aWxzLmV4dGVuZChteENsb3VkLG14QWN0b3IpOwpteENsb3VkLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixjLGQsZSl7YS5tb3ZlVG8oLjI1KmQsLjI1KmUpO2EuY3VydmVUbyguMDUqZCwuMjUqZSwwLC41KmUsLjE2KmQsLjU1KmUpO2EuY3VydmVUbygwLC42NiplLC4xOCpkLC45KmUsLjMxKmQsLjgqZSk7YS5jdXJ2ZVRvKC40KmQsZSwuNypkLGUsLjgqZCwuOCplKTthLmN1cnZlVG8oZCwuOCplLGQsLjYqZSwuODc1KmQsLjUqZSk7YS5jdXJ2ZVRvKGQsLjMqZSwuOCpkLC4xKmUsLjYyNSpkLC4yKmUpO2EuY3VydmVUbyguNSpkLC4wNSplLC4zKmQsLjA1KmUsLjI1KmQsLjI1KmUpO2EuY2xvc2UoKX07ZnVuY3Rpb24gbXhSZWN0YW5nbGVTaGFwZShhLGIsYyxkKXtteFNoYXBlLmNhbGwodGhpcyk7dGhpcy5ib3VuZHM9YTt0aGlzLmZpbGw9Yjt0aGlzLnN0cm9rZT1jO3RoaXMuc3Ryb2tld2lkdGg9bnVsbCE9ZD9kOjF9bXhVdGlscy5leHRlbmQobXhSZWN0YW5nbGVTaGFwZSxteFNoYXBlKTsKbXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUuaXNIdG1sQWxsb3dlZD1mdW5jdGlvbigpe3ZhciBhPSEwO251bGwhPXRoaXMuc3R5bGUmJihhPSIxIj09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1BPSU5URVJfRVZFTlRTLCIxIikpO3JldHVybiF0aGlzLmlzUm91bmRlZCYmIXRoaXMuZ2xhc3MmJjA9PXRoaXMucm90YXRpb24mJihhfHxudWxsIT10aGlzLmZpbGwmJnRoaXMuZmlsbCE9bXhDb25zdGFudHMuTk9ORSl9OwpteFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5wYWludEJhY2tncm91bmQ9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj0hMDtudWxsIT10aGlzLnN0eWxlJiYoZj0iMSI9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9QT0lOVEVSX0VWRU5UUywiMSIpKTtpZihmfHxudWxsIT10aGlzLmZpbGwmJnRoaXMuZmlsbCE9bXhDb25zdGFudHMuTk9ORXx8bnVsbCE9dGhpcy5zdHJva2UmJnRoaXMuc3Ryb2tlIT1teENvbnN0YW50cy5OT05FKWZ8fG51bGwhPXRoaXMuZmlsbCYmdGhpcy5maWxsIT1teENvbnN0YW50cy5OT05FfHwoYS5wb2ludGVyRXZlbnRzPSExKSx0aGlzLmlzUm91bmRlZD8oIjEiPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQUJTT0xVVEVfQVJDU0laRSwwKT9mPU1hdGgubWluKGQvMixNYXRoLm1pbihlLzIsbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkUsCm14Q29uc3RhbnRzLkxJTkVfQVJDU0laRSkvMikpOihmPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLDEwMCpteENvbnN0YW50cy5SRUNUQU5HTEVfUk9VTkRJTkdfRkFDVE9SKS8xMDAsZj1NYXRoLm1pbihkKmYsZSpmKSksYS5yb3VuZHJlY3QoYixjLGQsZSxmLGYpKTphLnJlY3QoYixjLGQsZSksYS5maWxsQW5kU3Ryb2tlKCl9O214UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLmlzUm91bmRhYmxlPWZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuITB9O214UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLnBhaW50Rm9yZWdyb3VuZD1mdW5jdGlvbihhLGIsYyxkLGUpe3RoaXMuZ2xhc3MmJiF0aGlzLm91dGxpbmUmJm51bGwhPXRoaXMuZmlsbCYmdGhpcy5maWxsIT1teENvbnN0YW50cy5OT05FJiZ0aGlzLnBhaW50R2xhc3NFZmZlY3QoYSxiLGMsZCxlLHRoaXMuZ2V0QXJjU2l6ZShkK3RoaXMuc3Ryb2tld2lkdGgsZSt0aGlzLnN0cm9rZXdpZHRoKSl9OwpmdW5jdGlvbiBteEVsbGlwc2UoYSxiLGMsZCl7bXhTaGFwZS5jYWxsKHRoaXMpO3RoaXMuYm91bmRzPWE7dGhpcy5maWxsPWI7dGhpcy5zdHJva2U9Yzt0aGlzLnN0cm9rZXdpZHRoPW51bGwhPWQ/ZDoxfW14VXRpbHMuZXh0ZW5kKG14RWxsaXBzZSxteFNoYXBlKTtteEVsbGlwc2UucHJvdG90eXBlLnBhaW50VmVydGV4U2hhcGU9ZnVuY3Rpb24oYSxiLGMsZCxlKXthLmVsbGlwc2UoYixjLGQsZSk7YS5maWxsQW5kU3Ryb2tlKCl9O2Z1bmN0aW9uIG14RG91YmxlRWxsaXBzZShhLGIsYyxkKXtteFNoYXBlLmNhbGwodGhpcyk7dGhpcy5ib3VuZHM9YTt0aGlzLmZpbGw9Yjt0aGlzLnN0cm9rZT1jO3RoaXMuc3Ryb2tld2lkdGg9bnVsbCE9ZD9kOjF9bXhVdGlscy5leHRlbmQobXhEb3VibGVFbGxpcHNlLG14U2hhcGUpO214RG91YmxlRWxsaXBzZS5wcm90b3R5cGUudm1sU2NhbGU9MTA7Cm14RG91YmxlRWxsaXBzZS5wcm90b3R5cGUucGFpbnRCYWNrZ3JvdW5kPWZ1bmN0aW9uKGEsYixjLGQsZSl7YS5lbGxpcHNlKGIsYyxkLGUpO2EuZmlsbEFuZFN0cm9rZSgpfTtteERvdWJsZUVsbGlwc2UucHJvdG90eXBlLnBhaW50Rm9yZWdyb3VuZD1mdW5jdGlvbihhLGIsYyxkLGUpe2lmKCF0aGlzLm91dGxpbmUpe3ZhciBmPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9NQVJHSU4sTWF0aC5taW4oMyt0aGlzLnN0cm9rZXdpZHRoLE1hdGgubWluKGQvNSxlLzUpKSk7ZC09MipmO2UtPTIqZjswPGQmJjA8ZSYmYS5lbGxpcHNlKGIrZixjK2YsZCxlKTthLnN0cm9rZSgpfX07Cm14RG91YmxlRWxsaXBzZS5wcm90b3R5cGUuZ2V0TGFiZWxCb3VuZHM9ZnVuY3Rpb24oYSl7dmFyIGI9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX01BUkdJTixNYXRoLm1pbigzK3RoaXMuc3Ryb2tld2lkdGgsTWF0aC5taW4oYS53aWR0aC81L3RoaXMuc2NhbGUsYS5oZWlnaHQvNS90aGlzLnNjYWxlKSkpKnRoaXMuc2NhbGU7cmV0dXJuIG5ldyBteFJlY3RhbmdsZShhLngrYixhLnkrYixhLndpZHRoLTIqYixhLmhlaWdodC0yKmIpfTtmdW5jdGlvbiBteFJob21idXMoYSxiLGMsZCl7bXhTaGFwZS5jYWxsKHRoaXMpO3RoaXMuYm91bmRzPWE7dGhpcy5maWxsPWI7dGhpcy5zdHJva2U9Yzt0aGlzLnN0cm9rZXdpZHRoPW51bGwhPWQ/ZDoxfW14VXRpbHMuZXh0ZW5kKG14UmhvbWJ1cyxteFNoYXBlKTtteFJob21idXMucHJvdG90eXBlLmlzUm91bmRhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuITB9OwpteFJob21idXMucHJvdG90eXBlLnBhaW50VmVydGV4U2hhcGU9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1kLzIsZz1lLzIsaz1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSxteENvbnN0YW50cy5MSU5FX0FSQ1NJWkUpLzI7YS5iZWdpbigpO3RoaXMuYWRkUG9pbnRzKGEsW25ldyBteFBvaW50KGIrZixjKSxuZXcgbXhQb2ludChiK2QsYytnKSxuZXcgbXhQb2ludChiK2YsYytlKSxuZXcgbXhQb2ludChiLGMrZyldLHRoaXMuaXNSb3VuZGVkLGssITApO2EuZmlsbEFuZFN0cm9rZSgpfTtmdW5jdGlvbiBteFBvbHlsaW5lKGEsYixjKXtteFNoYXBlLmNhbGwodGhpcyk7dGhpcy5wb2ludHM9YTt0aGlzLnN0cm9rZT1iO3RoaXMuc3Ryb2tld2lkdGg9bnVsbCE9Yz9jOjF9bXhVdGlscy5leHRlbmQobXhQb2x5bGluZSxteFNoYXBlKTtteFBvbHlsaW5lLnByb3RvdHlwZS5nZXRSb3RhdGlvbj1mdW5jdGlvbigpe3JldHVybiAwfTsKbXhQb2x5bGluZS5wcm90b3R5cGUuZ2V0U2hhcGVSb3RhdGlvbj1mdW5jdGlvbigpe3JldHVybiAwfTtteFBvbHlsaW5lLnByb3RvdHlwZS5pc1BhaW50Qm91bmRzSW52ZXJ0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX07bXhQb2x5bGluZS5wcm90b3R5cGUucGFpbnRFZGdlU2hhcGU9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLnBvaW50ZXJFdmVudHNWYWx1ZTthLnBvaW50ZXJFdmVudHNWYWx1ZT0ic3Ryb2tlIjtudWxsPT10aGlzLnN0eWxlfHwxIT10aGlzLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0NVUlZFRF0/dGhpcy5wYWludExpbmUoYSxiLHRoaXMuaXNSb3VuZGVkKTp0aGlzLnBhaW50Q3VydmVkTGluZShhLGIpO2EucG9pbnRlckV2ZW50c1ZhbHVlPWN9OwpteFBvbHlsaW5lLnByb3RvdHlwZS5wYWludExpbmU9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLG14Q29uc3RhbnRzLkxJTkVfQVJDU0laRSkvMjthLmJlZ2luKCk7dGhpcy5hZGRQb2ludHMoYSxiLGMsZCwhMSk7YS5zdHJva2UoKX07bXhQb2x5bGluZS5wcm90b3R5cGUucGFpbnRDdXJ2ZWRMaW5lPWZ1bmN0aW9uKGEsYil7YS5iZWdpbigpO3ZhciBjPWJbMF0sZD1iLmxlbmd0aDthLm1vdmVUbyhjLngsYy55KTtmb3IoYz0xO2M8ZC0yO2MrKyl7dmFyIGU9YltjXSxmPWJbYysxXTthLnF1YWRUbyhlLngsZS55LChlLngrZi54KS8yLChlLnkrZi55KS8yKX1lPWJbZC0yXTtmPWJbZC0xXTthLnF1YWRUbyhlLngsZS55LGYueCxmLnkpO2Euc3Ryb2tlKCl9OwpmdW5jdGlvbiBteEFycm93KGEsYixjLGQsZSxmLGcpe214U2hhcGUuY2FsbCh0aGlzKTt0aGlzLnBvaW50cz1hO3RoaXMuZmlsbD1iO3RoaXMuc3Ryb2tlPWM7dGhpcy5zdHJva2V3aWR0aD1udWxsIT1kP2Q6MTt0aGlzLmFycm93V2lkdGg9bnVsbCE9ZT9lOm14Q29uc3RhbnRzLkFSUk9XX1dJRFRIO3RoaXMuc3BhY2luZz1udWxsIT1mP2Y6bXhDb25zdGFudHMuQVJST1dfU1BBQ0lORzt0aGlzLmVuZFNpemU9bnVsbCE9Zz9nOm14Q29uc3RhbnRzLkFSUk9XX1NJWkV9bXhVdGlscy5leHRlbmQobXhBcnJvdyxteFNoYXBlKTtteEFycm93LnByb3RvdHlwZS5hdWdtZW50Qm91bmRpbmdCb3g9ZnVuY3Rpb24oYSl7bXhTaGFwZS5wcm90b3R5cGUuYXVnbWVudEJvdW5kaW5nQm94LmFwcGx5KHRoaXMsYXJndW1lbnRzKTthLmdyb3coKE1hdGgubWF4KHRoaXMuYXJyb3dXaWR0aCx0aGlzLmVuZFNpemUpLzIrdGhpcy5zdHJva2V3aWR0aCkqdGhpcy5zY2FsZSl9OwpteEFycm93LnByb3RvdHlwZS5wYWludEVkZ2VTaGFwZT1mdW5jdGlvbihhLGIpe3ZhciBjPW14Q29uc3RhbnRzLkFSUk9XX1NQQUNJTkcsZD1teENvbnN0YW50cy5BUlJPV19XSURUSCxlPWJbMF0sZj1iW2IubGVuZ3RoLTFdLGc9Zi54LWUueCxrPWYueS1lLnksbD1NYXRoLnNxcnQoZypnK2sqayksbT1sLTIqYy1teENvbnN0YW50cy5BUlJPV19TSVpFLGc9Zy9sLGs9ay9sLGw9ZCprLzMsZD0tZCpnLzMsbj1lLngtbC8yK2MqZyxlPWUueS1kLzIrYyprLHA9bitsLHE9ZStkLHI9cCttKmcsbT1xK20qayx0PXIrbCx1PW0rZCx4PXQtMypsLHk9dS0zKmQ7YS5iZWdpbigpO2EubW92ZVRvKG4sZSk7YS5saW5lVG8ocCxxKTthLmxpbmVUbyhyLG0pO2EubGluZVRvKHQsdSk7YS5saW5lVG8oZi54LWMqZyxmLnktYyprKTthLmxpbmVUbyh4LHkpO2EubGluZVRvKHgrbCx5K2QpO2EuY2xvc2UoKTthLmZpbGxBbmRTdHJva2UoKX07CmZ1bmN0aW9uIG14QXJyb3dDb25uZWN0b3IoYSxiLGMsZCxlLGYsZyl7bXhTaGFwZS5jYWxsKHRoaXMpO3RoaXMucG9pbnRzPWE7dGhpcy5maWxsPWI7dGhpcy5zdHJva2U9Yzt0aGlzLnN0cm9rZXdpZHRoPW51bGwhPWQ/ZDoxO3RoaXMuYXJyb3dXaWR0aD1udWxsIT1lP2U6bXhDb25zdGFudHMuQVJST1dfV0lEVEg7dGhpcy5hcnJvd1NwYWNpbmc9bnVsbCE9Zj9mOm14Q29uc3RhbnRzLkFSUk9XX1NQQUNJTkc7dGhpcy5zdGFydFNpemU9bXhDb25zdGFudHMuQVJST1dfU0laRS81O3RoaXMuZW5kU2l6ZT1teENvbnN0YW50cy5BUlJPV19TSVpFLzV9bXhVdGlscy5leHRlbmQobXhBcnJvd0Nvbm5lY3RvcixteFNoYXBlKTtteEFycm93Q29ubmVjdG9yLnByb3RvdHlwZS51c2VTdmdCb3VuZGluZ0JveD0hMDsKbXhBcnJvd0Nvbm5lY3Rvci5wcm90b3R5cGUucmVzZXRTdHlsZXM9ZnVuY3Rpb24oKXtteFNoYXBlLnByb3RvdHlwZS5yZXNldFN0eWxlcy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy5hcnJvd1NwYWNpbmc9bXhDb25zdGFudHMuQVJST1dfU1BBQ0lOR307bXhBcnJvd0Nvbm5lY3Rvci5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oYSl7bXhTaGFwZS5wcm90b3R5cGUuYXBwbHkuYXBwbHkodGhpcyxhcmd1bWVudHMpO251bGwhPXRoaXMuc3R5bGUmJih0aGlzLnN0YXJ0U2l6ZT0zKm14VXRpbHMuZ2V0TnVtYmVyKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFLG14Q29uc3RhbnRzLkFSUk9XX1NJWkUvNSksdGhpcy5lbmRTaXplPTMqbXhVdGlscy5nZXROdW1iZXIodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9FTkRTSVpFLG14Q29uc3RhbnRzLkFSUk9XX1NJWkUvNSkpfTsKbXhBcnJvd0Nvbm5lY3Rvci5wcm90b3R5cGUuYXVnbWVudEJvdW5kaW5nQm94PWZ1bmN0aW9uKGEpe214U2hhcGUucHJvdG90eXBlLmF1Z21lbnRCb3VuZGluZ0JveC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGI9dGhpcy5nZXRFZGdlV2lkdGgoKTt0aGlzLmlzTWFya2VyU3RhcnQoKSYmKGI9TWF0aC5tYXgoYix0aGlzLmdldFN0YXJ0QXJyb3dXaWR0aCgpKSk7dGhpcy5pc01hcmtlckVuZCgpJiYoYj1NYXRoLm1heChiLHRoaXMuZ2V0RW5kQXJyb3dXaWR0aCgpKSk7YS5ncm93KChiLzIrdGhpcy5zdHJva2V3aWR0aCkqdGhpcy5zY2FsZSl9OwpteEFycm93Q29ubmVjdG9yLnByb3RvdHlwZS5wYWludEVkZ2VTaGFwZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuc3Ryb2tld2lkdGg7dGhpcy5vdXRsaW5lJiYoYz1NYXRoLm1heCgxLG14VXRpbHMuZ2V0TnVtYmVyKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1RST0tFV0lEVEgsdGhpcy5zdHJva2V3aWR0aCkpKTtmb3IodmFyIGQ9dGhpcy5nZXRTdGFydEFycm93V2lkdGgoKStjLGU9dGhpcy5nZXRFbmRBcnJvd1dpZHRoKCkrYyxmPXRoaXMub3V0bGluZT90aGlzLmdldEVkZ2VXaWR0aCgpK2M6dGhpcy5nZXRFZGdlV2lkdGgoKSxnPXRoaXMuaXNPcGVuRW5kZWQoKSxrPXRoaXMuaXNNYXJrZXJTdGFydCgpLGw9dGhpcy5pc01hcmtlckVuZCgpLG09Zz8wOnRoaXMuYXJyb3dTcGFjaW5nK2MvMixuPXRoaXMuc3RhcnRTaXplK2MsYz10aGlzLmVuZFNpemUrYyxwPXRoaXMuaXNBcnJvd1JvdW5kZWQoKSxxPWJbYi5sZW5ndGgtMV0scj0xO3I8Yi5sZW5ndGgtMSYmYltyXS54PT0KYlswXS54JiZiW3JdLnk9PWJbMF0ueTspcisrO3ZhciB0PWJbcl0ueC1iWzBdLngscj1iW3JdLnktYlswXS55LHU9TWF0aC5zcXJ0KHQqdCtyKnIpO2lmKDAhPXUpe3ZhciB4PXQvdSx5LEI9eCxBPXIvdSx6LEM9QSx1PWYqQSx2PS1mKngsRD1bXTtwP2Euc2V0TGluZUpvaW4oInJvdW5kIik6MjxiLmxlbmd0aCYmYS5zZXRNaXRlckxpbWl0KDEuNDIpO2EuYmVnaW4oKTt0PXg7cj1BO2lmKGsmJiFnKXRoaXMucGFpbnRNYXJrZXIoYSxiWzBdLngsYlswXS55LHgsQSxuLGQsZixtLCEwKTtlbHNle3k9YlswXS54K3UvMittKng7ej1iWzBdLnkrdi8yK20qQTt2YXIgRz1iWzBdLngtdS8yK20qeCxKPWJbMF0ueS12LzIrbSpBO2c/KGEubW92ZVRvKHkseiksRC5wdXNoKGZ1bmN0aW9uKCl7YS5saW5lVG8oRyxKKX0pKTooYS5tb3ZlVG8oRyxKKSxhLmxpbmVUbyh5LHopKX1mb3IodmFyIEU9ej15PTAsdT0wO3U8Yi5sZW5ndGgtMjt1KyspaWYodj1teFV0aWxzLnJlbGF0aXZlQ2N3KGJbdV0ueCwKYlt1XS55LGJbdSsxXS54LGJbdSsxXS55LGJbdSsyXS54LGJbdSsyXS55KSx5PWJbdSsyXS54LWJbdSsxXS54LHo9Ylt1KzJdLnktYlt1KzFdLnksRT1NYXRoLnNxcnQoeSp5K3oqeiksMCE9RSl7Qj15L0U7Qz16L0U7RT1NYXRoLm1heChNYXRoLnNxcnQoKHgqQitBKkMrMSkvMiksLjA0KTt5PXgrQjt6PUErQzt2YXIgSD1NYXRoLnNxcnQoeSp5K3oqeik7aWYoMCE9SCl7eS89SDt6Lz1IO3ZhciBIPU1hdGgubWF4KEUsTWF0aC5taW4odGhpcy5zdHJva2V3aWR0aC8yMDArLjA0LC4zNSkpLEU9MCE9diYmcD9NYXRoLm1heCguMSxIKTpNYXRoLm1heChFLC4wNiksST1iW3UrMV0ueCt6KmYvMi9FLEY9Ylt1KzFdLnkteSpmLzIvRTt6PWJbdSsxXS54LXoqZi8yL0U7eT1iW3UrMV0ueSt5KmYvMi9FOzAhPXYmJnA/LTE9PXY/KHY9eitDKmYsRT15LUIqZixhLmxpbmVUbyh6K0EqZix5LXgqZiksYS5xdWFkVG8oSSxGLHYsRSksZnVuY3Rpb24oYixjKXtELnB1c2goZnVuY3Rpb24oKXthLmxpbmVUbyhiLApjKX0pfSh6LHkpKTooYS5saW5lVG8oSSxGKSxmdW5jdGlvbihiLGMpe3ZhciBkPUktQSpmLGU9Rit4KmYsZz1JLUMqZixrPUYrQipmO0QucHVzaChmdW5jdGlvbigpe2EucXVhZFRvKGIsYyxkLGUpfSk7RC5wdXNoKGZ1bmN0aW9uKCl7YS5saW5lVG8oZyxrKX0pfSh6LHkpKTooYS5saW5lVG8oSSxGKSxmdW5jdGlvbihiLGMpe0QucHVzaChmdW5jdGlvbigpe2EubGluZVRvKGIsYyl9KX0oeix5KSk7eD1CO0E9Q319dT1mKkM7dj0tZipCO2lmKGwmJiFnKXRoaXMucGFpbnRNYXJrZXIoYSxxLngscS55LC14LC1BLGMsZSxmLG0sITEpO2Vsc2V7YS5saW5lVG8ocS54LW0qQit1LzIscS55LW0qQyt2LzIpO3ZhciBLPXEueC1tKkItdS8yLEw9cS55LW0qQy12LzI7Zz8oYS5tb3ZlVG8oSyxMKSxELnNwbGljZSgwLDAsZnVuY3Rpb24oKXthLm1vdmVUbyhLLEwpfSkpOmEubGluZVRvKEssTCl9Zm9yKHU9RC5sZW5ndGgtMTswPD11O3UtLSlEW3VdKCk7Zz8oYS5lbmQoKSxhLnN0cm9rZSgpKToKKGEuY2xvc2UoKSxhLmZpbGxBbmRTdHJva2UoKSk7YS5zZXRTaGFkb3coITEpO2Euc2V0TWl0ZXJMaW1pdCg0KTtwJiZhLnNldExpbmVKb2luKCJmbGF0Iik7MjxiLmxlbmd0aCYmKGEuc2V0TWl0ZXJMaW1pdCg0KSxrJiYhZyYmKGEuYmVnaW4oKSx0aGlzLnBhaW50TWFya2VyKGEsYlswXS54LGJbMF0ueSx0LHIsbixkLGYsbSwhMCksYS5zdHJva2UoKSxhLmVuZCgpKSxsJiYhZyYmKGEuYmVnaW4oKSx0aGlzLnBhaW50TWFya2VyKGEscS54LHEueSwteCwtQSxjLGUsZixtLCEwKSxhLnN0cm9rZSgpLGEuZW5kKCkpKX19OwpteEFycm93Q29ubmVjdG9yLnByb3RvdHlwZS5wYWludE1hcmtlcj1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGssbCxtKXtnPWsvZzt2YXIgbj1rKmUvMjtrPS1rKmQvMjt2YXIgcD0obCtmKSpkO2Y9KGwrZikqZTttP2EubW92ZVRvKGItbitwLGMtaytmKTphLmxpbmVUbyhiLW4rcCxjLWsrZik7YS5saW5lVG8oYi1uL2crcCxjLWsvZytmKTthLmxpbmVUbyhiK2wqZCxjK2wqZSk7YS5saW5lVG8oYituL2crcCxjK2svZytmKTthLmxpbmVUbyhiK24rcCxjK2srZil9O214QXJyb3dDb25uZWN0b3IucHJvdG90eXBlLmlzQXJyb3dSb3VuZGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNSb3VuZGVkfTtteEFycm93Q29ubmVjdG9yLnByb3RvdHlwZS5nZXRTdGFydEFycm93V2lkdGg9ZnVuY3Rpb24oKXtyZXR1cm4gbXhDb25zdGFudHMuQVJST1dfV0lEVEh9O214QXJyb3dDb25uZWN0b3IucHJvdG90eXBlLmdldEVuZEFycm93V2lkdGg9ZnVuY3Rpb24oKXtyZXR1cm4gbXhDb25zdGFudHMuQVJST1dfV0lEVEh9OwpteEFycm93Q29ubmVjdG9yLnByb3RvdHlwZS5nZXRFZGdlV2lkdGg9ZnVuY3Rpb24oKXtyZXR1cm4gbXhDb25zdGFudHMuQVJST1dfV0lEVEgvM307bXhBcnJvd0Nvbm5lY3Rvci5wcm90b3R5cGUuaXNPcGVuRW5kZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX07bXhBcnJvd0Nvbm5lY3Rvci5wcm90b3R5cGUuaXNNYXJrZXJTdGFydD1mdW5jdGlvbigpe3JldHVybiBteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1RBUlRBUlJPVyxteENvbnN0YW50cy5OT05FKSE9bXhDb25zdGFudHMuTk9ORX07bXhBcnJvd0Nvbm5lY3Rvci5wcm90b3R5cGUuaXNNYXJrZXJFbmQ9ZnVuY3Rpb24oKXtyZXR1cm4gbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0VOREFSUk9XLG14Q29uc3RhbnRzLk5PTkUpIT1teENvbnN0YW50cy5OT05FfTsKZnVuY3Rpb24gbXhUZXh0KGEsYixjLGQsZSxmLGcsayxsLG0sbixwLHEscix0LHUseCx5LEIsQSx6KXtteFNoYXBlLmNhbGwodGhpcyk7dGhpcy52YWx1ZT1hO3RoaXMuYm91bmRzPWI7dGhpcy5jb2xvcj1udWxsIT1lP2U6ImJsYWNrIjt0aGlzLmFsaWduPW51bGwhPWM/YzpteENvbnN0YW50cy5BTElHTl9DRU5URVI7dGhpcy52YWxpZ249bnVsbCE9ZD9kOm14Q29uc3RhbnRzLkFMSUdOX01JRERMRTt0aGlzLmZhbWlseT1udWxsIT1mP2Y6bXhDb25zdGFudHMuREVGQVVMVF9GT05URkFNSUxZO3RoaXMuc2l6ZT1udWxsIT1nP2c6bXhDb25zdGFudHMuREVGQVVMVF9GT05UU0laRTt0aGlzLmZvbnRTdHlsZT1udWxsIT1rP2s6bXhDb25zdGFudHMuREVGQVVMVF9GT05UU1RZTEU7dGhpcy5zcGFjaW5nPXBhcnNlSW50KGx8fDIpO3RoaXMuc3BhY2luZ1RvcD10aGlzLnNwYWNpbmcrcGFyc2VJbnQobXx8MCk7dGhpcy5zcGFjaW5nUmlnaHQ9dGhpcy5zcGFjaW5nK3BhcnNlSW50KG58fDApOwp0aGlzLnNwYWNpbmdCb3R0b209dGhpcy5zcGFjaW5nK3BhcnNlSW50KHB8fDApO3RoaXMuc3BhY2luZ0xlZnQ9dGhpcy5zcGFjaW5nK3BhcnNlSW50KHF8fDApO3RoaXMuaG9yaXpvbnRhbD1udWxsIT1yP3I6ITA7dGhpcy5iYWNrZ3JvdW5kPXQ7dGhpcy5ib3JkZXI9dTt0aGlzLndyYXA9bnVsbCE9eD94OiExO3RoaXMuY2xpcHBlZD1udWxsIT15P3k6ITE7dGhpcy5vdmVyZmxvdz1udWxsIT1CP0I6InZpc2libGUiO3RoaXMubGFiZWxQYWRkaW5nPW51bGwhPUE/QTowO3RoaXMudGV4dERpcmVjdGlvbj16O3RoaXMucm90YXRpb249MDt0aGlzLnVwZGF0ZU1hcmdpbigpfW14VXRpbHMuZXh0ZW5kKG14VGV4dCxteFNoYXBlKTtteFRleHQucHJvdG90eXBlLmJhc2VTcGFjaW5nVG9wPTA7bXhUZXh0LnByb3RvdHlwZS5iYXNlU3BhY2luZ0JvdHRvbT0wO214VGV4dC5wcm90b3R5cGUuYmFzZVNwYWNpbmdMZWZ0PTA7bXhUZXh0LnByb3RvdHlwZS5iYXNlU3BhY2luZ1JpZ2h0PTA7Cm14VGV4dC5wcm90b3R5cGUucmVwbGFjZUxpbmVmZWVkcz0hMDtteFRleHQucHJvdG90eXBlLnZlcnRpY2FsVGV4dFJvdGF0aW9uPS05MDtteFRleHQucHJvdG90eXBlLmlnbm9yZUNsaXBwZWRTdHJpbmdTaXplPSEwO214VGV4dC5wcm90b3R5cGUuaWdub3JlU3RyaW5nU2l6ZT0hMTtteFRleHQucHJvdG90eXBlLnRleHRXaWR0aFBhZGRpbmc9OCE9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHxteENsaWVudC5JU19FTT8zOjQ7bXhUZXh0LnByb3RvdHlwZS5sYXN0VmFsdWU9bnVsbDtteFRleHQucHJvdG90eXBlLmNhY2hlRW5hYmxlZD0hMDtteFRleHQucHJvdG90eXBlLmlzUGFyc2VWbWw9ZnVuY3Rpb24oKXtyZXR1cm4hMX07bXhUZXh0LnByb3RvdHlwZS5pc0h0bWxBbGxvd2VkPWZ1bmN0aW9uKCl7cmV0dXJuIDghPWRvY3VtZW50LmRvY3VtZW50TW9kZXx8bXhDbGllbnQuSVNfRU19O214VGV4dC5wcm90b3R5cGUuZ2V0U3ZnU2NyZWVuT2Zmc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIDB9OwpteFRleHQucHJvdG90eXBlLmNoZWNrQm91bmRzPWZ1bmN0aW9uKCl7cmV0dXJuIWlzTmFOKHRoaXMuc2NhbGUpJiZpc0Zpbml0ZSh0aGlzLnNjYWxlKSYmMDx0aGlzLnNjYWxlJiZudWxsIT10aGlzLmJvdW5kcyYmIWlzTmFOKHRoaXMuYm91bmRzLngpJiYhaXNOYU4odGhpcy5ib3VuZHMueSkmJiFpc05hTih0aGlzLmJvdW5kcy53aWR0aCkmJiFpc05hTih0aGlzLmJvdW5kcy5oZWlnaHQpfTsKbXhUZXh0LnByb3RvdHlwZS5wYWludD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuc2NhbGUsZD10aGlzLmJvdW5kcy54L2MsZT10aGlzLmJvdW5kcy55L2MsZj10aGlzLmJvdW5kcy53aWR0aC9jLGM9dGhpcy5ib3VuZHMuaGVpZ2h0L2M7dGhpcy51cGRhdGVUcmFuc2Zvcm0oYSxkLGUsZixjKTt0aGlzLmNvbmZpZ3VyZUNhbnZhcyhhLGQsZSxmLGMpO2lmKGIpYS51cGRhdGVUZXh0KGQsZSxmLGMsdGhpcy5hbGlnbix0aGlzLnZhbGlnbix0aGlzLndyYXAsdGhpcy5vdmVyZmxvdyx0aGlzLmNsaXBwZWQsdGhpcy5nZXRUZXh0Um90YXRpb24oKSx0aGlzLm5vZGUpO2Vsc2V7dmFyIGc9bXhVdGlscy5pc05vZGUodGhpcy52YWx1ZSl8fHRoaXMuZGlhbGVjdD09bXhDb25zdGFudHMuRElBTEVDVF9TVFJJQ1RIVE1MLGs9Z3x8YSBpbnN0YW5jZW9mIG14Vm1sQ2FudmFzMkQ/Imh0bWwiOiIiLGw9dGhpcy52YWx1ZTtnfHwiaHRtbCIhPWt8fChsPW14VXRpbHMuaHRtbEVudGl0aWVzKGwsITEpKTsKImh0bWwiIT1rfHxteFV0aWxzLmlzTm9kZSh0aGlzLnZhbHVlKXx8KGw9bXhVdGlscy5yZXBsYWNlVHJhaWxpbmdOZXdsaW5lcyhsLCI8ZGl2Pjxicj48L2Rpdj4iKSk7dmFyIGw9IW14VXRpbHMuaXNOb2RlKHRoaXMudmFsdWUpJiZ0aGlzLnJlcGxhY2VMaW5lZmVlZHMmJiJodG1sIj09az9sLnJlcGxhY2UoL1xuL2csIjxici8+Iik6bCxtPXRoaXMudGV4dERpcmVjdGlvbjttIT1teENvbnN0YW50cy5URVhUX0RJUkVDVElPTl9BVVRPfHxnfHwobT10aGlzLmdldEF1dG9EaXJlY3Rpb24oKSk7bSE9bXhDb25zdGFudHMuVEVYVF9ESVJFQ1RJT05fTFRSJiZtIT1teENvbnN0YW50cy5URVhUX0RJUkVDVElPTl9SVEwmJihtPW51bGwpO2EudGV4dChkLGUsZixjLGwsdGhpcy5hbGlnbix0aGlzLnZhbGlnbix0aGlzLndyYXAsayx0aGlzLm92ZXJmbG93LHRoaXMuY2xpcHBlZCx0aGlzLmdldFRleHRSb3RhdGlvbigpLG0pfX07Cm14VGV4dC5wcm90b3R5cGUucmVkcmF3PWZ1bmN0aW9uKCl7aWYodGhpcy52aXNpYmxlJiZ0aGlzLmNoZWNrQm91bmRzKCkmJnRoaXMuY2FjaGVFbmFibGVkJiZ0aGlzLmxhc3RWYWx1ZT09dGhpcy52YWx1ZSYmKG14VXRpbHMuaXNOb2RlKHRoaXMudmFsdWUpfHx0aGlzLmRpYWxlY3Q9PW14Q29uc3RhbnRzLkRJQUxFQ1RfU1RSSUNUSFRNTCkpaWYoIkRJViIhPXRoaXMubm9kZS5ub2RlTmFtZXx8IXRoaXMuaXNIdG1sQWxsb3dlZCgpJiZteENsaWVudC5JU19WTUwpe3ZhciBhPXRoaXMuY3JlYXRlQ2FudmFzKCk7bnVsbCE9YSYmbnVsbCE9YS51cGRhdGVUZXh0PyhhLnBvaW50ZXJFdmVudHM9dGhpcy5wb2ludGVyRXZlbnRzLHRoaXMucGFpbnQoYSwhMCksdGhpcy5kZXN0cm95Q2FudmFzKGEpLHRoaXMudXBkYXRlQm91bmRpbmdCb3goKSk6bXhTaGFwZS5wcm90b3R5cGUucmVkcmF3LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1lbHNlIG14Q2xpZW50LklTX1NWRz90aGlzLnJlZHJhd0h0bWxTaGFwZVdpdGhDc3MzKCk6Cih0aGlzLnVwZGF0ZVNpemUodGhpcy5ub2RlLG51bGw9PXRoaXMuc3RhdGV8fG51bGw9PXRoaXMuc3RhdGUudmlldy50ZXh0RGl2KSxteENsaWVudC5JU19JRSYmKG51bGw9PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8OD49ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKT90aGlzLnVwZGF0ZUh0bWxGaWx0ZXIoKTp0aGlzLnVwZGF0ZUh0bWxUcmFuc2Zvcm0oKSksdGhpcy51cGRhdGVCb3VuZGluZ0JveCgpO2Vsc2UgbXhTaGFwZS5wcm90b3R5cGUucmVkcmF3LmFwcGx5KHRoaXMsYXJndW1lbnRzKSxteFV0aWxzLmlzTm9kZSh0aGlzLnZhbHVlKXx8dGhpcy5kaWFsZWN0PT1teENvbnN0YW50cy5ESUFMRUNUX1NUUklDVEhUTUw/dGhpcy5sYXN0VmFsdWU9dGhpcy52YWx1ZTp0aGlzLmxhc3RWYWx1ZT1udWxsfTsKbXhUZXh0LnByb3RvdHlwZS5yZXNldFN0eWxlcz1mdW5jdGlvbigpe214U2hhcGUucHJvdG90eXBlLnJlc2V0U3R5bGVzLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLmNvbG9yPSJibGFjayI7dGhpcy5hbGlnbj1teENvbnN0YW50cy5BTElHTl9DRU5URVI7dGhpcy52YWxpZ249bXhDb25zdGFudHMuQUxJR05fTUlERExFO3RoaXMuZmFtaWx5PW14Q29uc3RhbnRzLkRFRkFVTFRfRk9OVEZBTUlMWTt0aGlzLnNpemU9bXhDb25zdGFudHMuREVGQVVMVF9GT05UU0laRTt0aGlzLmZvbnRTdHlsZT1teENvbnN0YW50cy5ERUZBVUxUX0ZPTlRTVFlMRTt0aGlzLnNwYWNpbmdMZWZ0PXRoaXMuc3BhY2luZ0JvdHRvbT10aGlzLnNwYWNpbmdSaWdodD10aGlzLnNwYWNpbmdUb3A9dGhpcy5zcGFjaW5nPTI7dGhpcy5ob3Jpem9udGFsPSEwO2RlbGV0ZSB0aGlzLmJhY2tncm91bmQ7ZGVsZXRlIHRoaXMuYm9yZGVyO3RoaXMudGV4dERpcmVjdGlvbj1teENvbnN0YW50cy5ERUZBVUxUX1RFWFRfRElSRUNUSU9OOwpkZWxldGUgdGhpcy5tYXJnaW59OwpteFRleHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc3BhY2luZztteFNoYXBlLnByb3RvdHlwZS5hcHBseS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbCE9dGhpcy5zdHlsZSYmKHRoaXMuZm9udFN0eWxlPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GT05UU1RZTEUsdGhpcy5mb250U3R5bGUpLHRoaXMuZmFtaWx5PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GT05URkFNSUxZLHRoaXMuZmFtaWx5KSx0aGlzLnNpemU9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRTSVpFLHRoaXMuc2l6ZSksdGhpcy5jb2xvcj1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRk9OVENPTE9SLHRoaXMuY29sb3IpLHRoaXMuYWxpZ249bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FMSUdOLAp0aGlzLmFsaWduKSx0aGlzLnZhbGlnbj1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfVkVSVElDQUxfQUxJR04sdGhpcy52YWxpZ24pLHRoaXMuc3BhY2luZz1wYXJzZUludChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lORyx0aGlzLnNwYWNpbmcpKSx0aGlzLnNwYWNpbmdUb3A9cGFyc2VJbnQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkdfVE9QLHRoaXMuc3BhY2luZ1RvcC1iKSkrdGhpcy5zcGFjaW5nLHRoaXMuc3BhY2luZ1JpZ2h0PXBhcnNlSW50KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HX1JJR0hULHRoaXMuc3BhY2luZ1JpZ2h0LWIpKSt0aGlzLnNwYWNpbmcsdGhpcy5zcGFjaW5nQm90dG9tPXBhcnNlSW50KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HX0JPVFRPTSwKdGhpcy5zcGFjaW5nQm90dG9tLWIpKSt0aGlzLnNwYWNpbmcsdGhpcy5zcGFjaW5nTGVmdD1wYXJzZUludChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lOR19MRUZULHRoaXMuc3BhY2luZ0xlZnQtYikpK3RoaXMuc3BhY2luZyx0aGlzLmhvcml6b250YWw9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0hPUklaT05UQUwsdGhpcy5ob3Jpem9udGFsKSx0aGlzLmJhY2tncm91bmQ9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0xBQkVMX0JBQ0tHUk9VTkRDT0xPUix0aGlzLmJhY2tncm91bmQpLHRoaXMuYm9yZGVyPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9MQUJFTF9CT1JERVJDT0xPUix0aGlzLmJvcmRlciksdGhpcy50ZXh0RGlyZWN0aW9uPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9URVhUX0RJUkVDVElPTiwKbXhDb25zdGFudHMuREVGQVVMVF9URVhUX0RJUkVDVElPTiksdGhpcy5vcGFjaXR5PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9URVhUX09QQUNJVFksMTAwKSx0aGlzLnVwZGF0ZU1hcmdpbigpKTt0aGlzLmZsaXBIPXRoaXMuZmxpcFY9bnVsbH07bXhUZXh0LnByb3RvdHlwZS5nZXRBdXRvRGlyZWN0aW9uPWZ1bmN0aW9uKCl7dmFyIGE9L1tBLVphLXpcdTA1ZDAtXHUwNjVmXHUwNjZhLVx1MDZlZlx1MDZmYS1cdTA3ZmZcdWZiMWQtXHVmZGZmXHVmZTcwLVx1ZmVmY10vLmV4ZWModGhpcy52YWx1ZSk7cmV0dXJuIG51bGwhPWEmJjA8YS5sZW5ndGgmJiJ6IjxhWzBdP214Q29uc3RhbnRzLlRFWFRfRElSRUNUSU9OX1JUTDpteENvbnN0YW50cy5URVhUX0RJUkVDVElPTl9MVFJ9OwpteFRleHQucHJvdG90eXBlLmdldENvbnRlbnROb2RlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5ub2RlO251bGwhPWEmJihhPW51bGw9PWEub3duZXJTVkdFbGVtZW50P3RoaXMubm9kZS5maXJzdENoaWxkLmZpcnN0Q2hpbGQ6YS5maXJzdENoaWxkLmZpcnN0Q2hpbGQuZmlyc3RDaGlsZC5maXJzdENoaWxkLmZpcnN0Q2hpbGQpO3JldHVybiBhfTsKbXhUZXh0LnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ0JveD1mdW5jdGlvbigpe3ZhciBhPXRoaXMubm9kZTt0aGlzLmJvdW5kaW5nQm94PXRoaXMuYm91bmRzLmNsb25lKCk7dmFyIGI9dGhpcy5nZXRUZXh0Um90YXRpb24oKSxjPW51bGwhPXRoaXMuc3R5bGU/bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0xBQkVMX1BPU0lUSU9OLG14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUik6bnVsbCxkPW51bGwhPXRoaXMuc3R5bGU/bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1ZFUlRJQ0FMX0xBQkVMX1BPU0lUSU9OLG14Q29uc3RhbnRzLkFMSUdOX01JRERMRSk6bnVsbDtpZighKHRoaXMuaWdub3JlU3RyaW5nU2l6ZXx8bnVsbD09YXx8ImZpbGwiPT10aGlzLm92ZXJmbG93fHx0aGlzLmNsaXBwZWQmJnRoaXMuaWdub3JlQ2xpcHBlZFN0cmluZ1NpemUmJmM9PW14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUiYmZD09bXhDb25zdGFudHMuQUxJR05fTUlERExFKSl7ZD0KYz1udWxsO2lmKG51bGwhPWEub3duZXJTVkdFbGVtZW50KWlmKG51bGwhPWEuZmlyc3RDaGlsZCYmbnVsbCE9YS5maXJzdENoaWxkLmZpcnN0Q2hpbGQmJiJmb3JlaWduT2JqZWN0Ij09YS5maXJzdENoaWxkLmZpcnN0Q2hpbGQubm9kZU5hbWUpYT1hLmZpcnN0Q2hpbGQuZmlyc3RDaGlsZC5maXJzdENoaWxkLmZpcnN0Q2hpbGQsZD1hLm9mZnNldEhlaWdodCp0aGlzLnNjYWxlLGM9IndpZHRoIj09dGhpcy5vdmVyZmxvdz90aGlzLmJvdW5kaW5nQm94LndpZHRoOmEub2Zmc2V0V2lkdGgqdGhpcy5zY2FsZTtlbHNlIHRyeXt2YXIgZT1hLmdldEJCb3goKTsic3RyaW5nIj09dHlwZW9mIHRoaXMudmFsdWUmJjA9PW14VXRpbHMudHJpbSh0aGlzLnZhbHVlKT90aGlzLmJvdW5kaW5nQm94PW51bGw6dGhpcy5ib3VuZGluZ0JveD0wPT1lLndpZHRoJiYwPT1lLmhlaWdodD9udWxsOm5ldyBteFJlY3RhbmdsZShlLngsZS55LGUud2lkdGgsZS5oZWlnaHQpO3JldHVybn1jYXRjaChmKXt9ZWxzZXtjPQpudWxsIT10aGlzLnN0YXRlP3RoaXMuc3RhdGUudmlldy50ZXh0RGl2Om51bGw7aWYobnVsbD09dGhpcy5vZmZzZXRXaWR0aHx8bnVsbD09dGhpcy5vZmZzZXRIZWlnaHQpbnVsbCE9YyYmKHRoaXMudXBkYXRlRm9udChjKSx0aGlzLnVwZGF0ZVNpemUoYywhMSksdGhpcy51cGRhdGVJbm5lckh0bWwoYyksYT1jKSxlPWEsOCE9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHxteENsaWVudC5JU19FTT9udWxsIT1lLmZpcnN0Q2hpbGQmJiJESVYiPT1lLmZpcnN0Q2hpbGQubm9kZU5hbWUmJihlPWUuZmlyc3RDaGlsZCk6KGQ9TWF0aC5yb3VuZCh0aGlzLmJvdW5kcy53aWR0aC90aGlzLnNjYWxlKSx0aGlzLndyYXAmJjA8ZD8oYS5zdHlsZS53b3JkV3JhcD1teENvbnN0YW50cy5XT1JEX1dSQVAsYS5zdHlsZS53aGl0ZVNwYWNlPSJub3JtYWwiLCJicmVhay13b3JkIiE9YS5zdHlsZS53b3JkV3JhcCYmKGE9ZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGl2IiksMDxhLmxlbmd0aCYmKGU9YVthLmxlbmd0aC0KMV0pLGM9ZS5vZmZzZXRXaWR0aCsyLGE9dGhpcy5ub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaXYiKSx0aGlzLmNsaXBwZWQmJihjPU1hdGgubWluKGQsYykpLDE8YS5sZW5ndGgmJihhW2EubGVuZ3RoLTJdLnN0eWxlLndpZHRoPWMrInB4IikpKTphLnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCIpLHRoaXMub2Zmc2V0V2lkdGg9ZS5vZmZzZXRXaWR0aCt0aGlzLnRleHRXaWR0aFBhZGRpbmcsdGhpcy5vZmZzZXRIZWlnaHQ9ZS5vZmZzZXRIZWlnaHQ7Yz10aGlzLm9mZnNldFdpZHRoKnRoaXMuc2NhbGU7ZD10aGlzLm9mZnNldEhlaWdodCp0aGlzLnNjYWxlfW51bGwhPWMmJm51bGwhPWQmJih0aGlzLmJvdW5kaW5nQm94PW5ldyBteFJlY3RhbmdsZSh0aGlzLmJvdW5kcy54LHRoaXMuYm91bmRzLnksYyxkKSl9bnVsbCE9dGhpcy5ib3VuZGluZ0JveCYmKDAhPWI/KGI9bXhVdGlscy5nZXRCb3VuZGluZ0JveChuZXcgbXhSZWN0YW5nbGUodGhpcy5tYXJnaW4ueCp0aGlzLmJvdW5kaW5nQm94LndpZHRoLAp0aGlzLm1hcmdpbi55KnRoaXMuYm91bmRpbmdCb3guaGVpZ2h0LHRoaXMuYm91bmRpbmdCb3gud2lkdGgsdGhpcy5ib3VuZGluZ0JveC5oZWlnaHQpLGIsbmV3IG14UG9pbnQoMCwwKSksdGhpcy51bnJvdGF0ZWRCb3VuZGluZ0JveD1teFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlKHRoaXMuYm91bmRpbmdCb3gpLHRoaXMudW5yb3RhdGVkQm91bmRpbmdCb3gueCs9dGhpcy5tYXJnaW4ueCp0aGlzLnVucm90YXRlZEJvdW5kaW5nQm94LndpZHRoLHRoaXMudW5yb3RhdGVkQm91bmRpbmdCb3gueSs9dGhpcy5tYXJnaW4ueSp0aGlzLnVucm90YXRlZEJvdW5kaW5nQm94LmhlaWdodCx0aGlzLmJvdW5kaW5nQm94LngrPWIueCx0aGlzLmJvdW5kaW5nQm94LnkrPWIueSx0aGlzLmJvdW5kaW5nQm94LndpZHRoPWIud2lkdGgsdGhpcy5ib3VuZGluZ0JveC5oZWlnaHQ9Yi5oZWlnaHQpOih0aGlzLmJvdW5kaW5nQm94LngrPXRoaXMubWFyZ2luLngqdGhpcy5ib3VuZGluZ0JveC53aWR0aCx0aGlzLmJvdW5kaW5nQm94LnkrPQp0aGlzLm1hcmdpbi55KnRoaXMuYm91bmRpbmdCb3guaGVpZ2h0LHRoaXMudW5yb3RhdGVkQm91bmRpbmdCb3g9bnVsbCkpfTtteFRleHQucHJvdG90eXBlLmdldFNoYXBlUm90YXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gMH07bXhUZXh0LnByb3RvdHlwZS5nZXRUZXh0Um90YXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5zdGF0ZSYmbnVsbCE9dGhpcy5zdGF0ZS5zaGFwZT90aGlzLnN0YXRlLnNoYXBlLmdldFRleHRSb3RhdGlvbigpOjB9O214VGV4dC5wcm90b3R5cGUuaXNQYWludEJvdW5kc0ludmVydGVkPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuaG9yaXpvbnRhbCYmbnVsbCE9dGhpcy5zdGF0ZSYmdGhpcy5zdGF0ZS52aWV3LmdyYXBoLm1vZGVsLmlzVmVydGV4KHRoaXMuc3RhdGUuY2VsbCl9OwpteFRleHQucHJvdG90eXBlLmNvbmZpZ3VyZUNhbnZhcz1mdW5jdGlvbihhLGIsYyxkLGUpe214U2hhcGUucHJvdG90eXBlLmNvbmZpZ3VyZUNhbnZhcy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YS5zZXRGb250Q29sb3IodGhpcy5jb2xvcik7YS5zZXRGb250QmFja2dyb3VuZENvbG9yKHRoaXMuYmFja2dyb3VuZCk7YS5zZXRGb250Qm9yZGVyQ29sb3IodGhpcy5ib3JkZXIpO2Euc2V0Rm9udEZhbWlseSh0aGlzLmZhbWlseSk7YS5zZXRGb250U2l6ZSh0aGlzLnNpemUpO2Euc2V0Rm9udFN0eWxlKHRoaXMuZm9udFN0eWxlKX07Cm14VGV4dC5wcm90b3R5cGUudXBkYXRlVm1sQ29udGFpbmVyPWZ1bmN0aW9uKCl7dGhpcy5ub2RlLnN0eWxlLmxlZnQ9TWF0aC5yb3VuZCh0aGlzLmJvdW5kcy54KSsicHgiO3RoaXMubm9kZS5zdHlsZS50b3A9TWF0aC5yb3VuZCh0aGlzLmJvdW5kcy55KSsicHgiO3RoaXMubm9kZS5zdHlsZS53aWR0aD0iMXB4Ijt0aGlzLm5vZGUuc3R5bGUuaGVpZ2h0PSIxcHgiO3RoaXMubm9kZS5zdHlsZS5vdmVyZmxvdz0idmlzaWJsZSJ9O214VGV4dC5wcm90b3R5cGUuZ2V0SHRtbFZhbHVlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy52YWx1ZTt0aGlzLmRpYWxlY3QhPW14Q29uc3RhbnRzLkRJQUxFQ1RfU1RSSUNUSFRNTCYmKGE9bXhVdGlscy5odG1sRW50aXRpZXMoYSwhMSkpO2E9bXhVdGlscy5yZXBsYWNlVHJhaWxpbmdOZXdsaW5lcyhhLCI8ZGl2Pjxicj48L2Rpdj4iKTtyZXR1cm4gdGhpcy5yZXBsYWNlTGluZWZlZWRzP2EucmVwbGFjZSgvXG4vZywiPGJyLz4iKTphfTsKbXhUZXh0LnByb3RvdHlwZS5nZXRUZXh0Q3NzPWZ1bmN0aW9uKCl7dmFyIGE9ImRpc3BsYXk6IGlubGluZS1ibG9jazsgZm9udC1zaXplOiAiK3RoaXMuc2l6ZSsicHg7IGZvbnQtZmFtaWx5OiAiK3RoaXMuZmFtaWx5KyI7IGNvbG9yOiAiK3RoaXMuY29sb3IrIjsgbGluZS1oZWlnaHQ6ICIrKG14Q29uc3RhbnRzLkFCU09MVVRFX0xJTkVfSEVJR0hUP3RoaXMuc2l6ZSpteENvbnN0YW50cy5MSU5FX0hFSUdIVCsicHgiOm14Q29uc3RhbnRzLkxJTkVfSEVJR0hUKSsiOyBwb2ludGVyLWV2ZW50czogIisodGhpcy5wb2ludGVyRXZlbnRzPyJhbGwiOiJub25lIikrIjsgIjsodGhpcy5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9CT0xEKT09bXhDb25zdGFudHMuRk9OVF9CT0xEJiYoYSs9ImZvbnQtd2VpZ2h0OiBib2xkOyAiKTsodGhpcy5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9JVEFMSUMpPT1teENvbnN0YW50cy5GT05UX0lUQUxJQyYmKGErPSJmb250LXN0eWxlOiBpdGFsaWM7ICIpOwp2YXIgYj1bXTsodGhpcy5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9VTkRFUkxJTkUpPT1teENvbnN0YW50cy5GT05UX1VOREVSTElORSYmYi5wdXNoKCJ1bmRlcmxpbmUiKTsodGhpcy5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9TVFJJS0VUSFJPVUdIKT09bXhDb25zdGFudHMuRk9OVF9TVFJJS0VUSFJPVUdIJiZiLnB1c2goImxpbmUtdGhyb3VnaCIpOzA8Yi5sZW5ndGgmJihhKz0idGV4dC1kZWNvcmF0aW9uOiAiK2Iuam9pbigiICIpKyI7ICIpO3JldHVybiBhfTsKbXhUZXh0LnByb3RvdHlwZS5yZWRyYXdIdG1sU2hhcGU9ZnVuY3Rpb24oKXtpZihteENsaWVudC5JU19TVkcpdGhpcy5yZWRyYXdIdG1sU2hhcGVXaXRoQ3NzMygpO2Vsc2V7dmFyIGE9dGhpcy5ub2RlLnN0eWxlO2Eud2hpdGVTcGFjZT0ibm9ybWFsIjthLm92ZXJmbG93PSIiO2Eud2lkdGg9IiI7YS5oZWlnaHQ9IiI7dGhpcy51cGRhdGVWYWx1ZSgpO3RoaXMudXBkYXRlRm9udCh0aGlzLm5vZGUpO3RoaXMudXBkYXRlU2l6ZSh0aGlzLm5vZGUsbnVsbD09dGhpcy5zdGF0ZXx8bnVsbD09dGhpcy5zdGF0ZS52aWV3LnRleHREaXYpO3RoaXMub2Zmc2V0SGVpZ2h0PXRoaXMub2Zmc2V0V2lkdGg9bnVsbDtteENsaWVudC5JU19JRSYmKG51bGw9PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8OD49ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKT90aGlzLnVwZGF0ZUh0bWxGaWx0ZXIoKTp0aGlzLnVwZGF0ZUh0bWxUcmFuc2Zvcm0oKX19OwpteFRleHQucHJvdG90eXBlLnJlZHJhd0h0bWxTaGFwZVdpdGhDc3MzPWZ1bmN0aW9uKCl7dmFyIGE9TWF0aC5tYXgoMCxNYXRoLnJvdW5kKHRoaXMuYm91bmRzLndpZHRoL3RoaXMuc2NhbGUpKSxiPU1hdGgubWF4KDAsTWF0aC5yb3VuZCh0aGlzLmJvdW5kcy5oZWlnaHQvdGhpcy5zY2FsZSkpLGM9InBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogIitNYXRoLnJvdW5kKHRoaXMuYm91bmRzLngpKyJweDsgdG9wOiAiK01hdGgucm91bmQodGhpcy5ib3VuZHMueSkrInB4OyBwb2ludGVyLWV2ZW50czogbm9uZTsgIixkPXRoaXMuZ2V0VGV4dENzcygpO214U3ZnQ2FudmFzMkQuY3JlYXRlQ3NzKGErMixiLHRoaXMuYWxpZ24sdGhpcy52YWxpZ24sdGhpcy53cmFwLHRoaXMub3ZlcmZsb3csdGhpcy5jbGlwcGVkLG51bGwhPXRoaXMuYmFja2dyb3VuZD9teFV0aWxzLmh0bWxFbnRpdGllcyh0aGlzLmJhY2tncm91bmQpOm51bGwsbnVsbCE9dGhpcy5ib3JkZXI/bXhVdGlscy5odG1sRW50aXRpZXModGhpcy5ib3JkZXIpOgpudWxsLGMsZCx0aGlzLnNjYWxlLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYixjLGQsbCxtKXthPXRoaXMuZ2V0VGV4dFJvdGF0aW9uKCk7YT0oMSE9dGhpcy5zY2FsZT8ic2NhbGUoIit0aGlzLnNjYWxlKyIpICI6IiIpKygwIT1hPyJyb3RhdGUoIithKyJkZWcpICI6IiIpKygwIT10aGlzLm1hcmdpbi54fHwwIT10aGlzLm1hcmdpbi55PyJ0cmFuc2xhdGUoIisxMDAqdGhpcy5tYXJnaW4ueCsiJSwiKzEwMCp0aGlzLm1hcmdpbi55KyIlKSI6IiIpOyIiIT1hJiYoYT0idHJhbnNmb3JtLW9yaWdpbjogMCAwOyB0cmFuc2Zvcm06ICIrYSsiOyAiKTsiIj09bT8oYys9ZCxkPSJkaXNwbGF5OmlubGluZS1ibG9jazsgbWluLXdpZHRoOiAxMDAlOyAiK2EpOmQrPWE7MTAwPnRoaXMub3BhY2l0eSYmKGwrPSJvcGFjaXR5OiAiK3RoaXMub3BhY2l0eS8xMDArIjsgIik7dGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgic3R5bGUiLGMpO2M9bXhVdGlscy5pc05vZGUodGhpcy52YWx1ZSk/dGhpcy52YWx1ZS5vdXRlckhUTUw6CnRoaXMuZ2V0SHRtbFZhbHVlKCk7bnVsbD09dGhpcy5ub2RlLmZpcnN0Q2hpbGQmJih0aGlzLm5vZGUuaW5uZXJIVE1MPSI8ZGl2PjxkaXY+IitjKyI8L2Rpdj48L2Rpdj4iKTt0aGlzLm5vZGUuZmlyc3RDaGlsZC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSgic3R5bGUiLGwpO3RoaXMubm9kZS5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSgic3R5bGUiLGQpfSkpfTsKbXhUZXh0LnByb3RvdHlwZS51cGRhdGVIdG1sVHJhbnNmb3JtPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRUZXh0Um90YXRpb24oKSxiPXRoaXMubm9kZS5zdHlsZSxjPXRoaXMubWFyZ2luLngsZD10aGlzLm1hcmdpbi55OzAhPWE/KG14VXRpbHMuc2V0UHJlZml4ZWRTdHlsZShiLCJ0cmFuc2Zvcm1PcmlnaW4iLDEwMCotYysiJSAiKzEwMCotZCsiJSIpLG14VXRpbHMuc2V0UHJlZml4ZWRTdHlsZShiLCJ0cmFuc2Zvcm0iLCJ0cmFuc2xhdGUoIisxMDAqYysiJSwiKzEwMCpkKyIlKSBzY2FsZSgiK3RoaXMuc2NhbGUrIikgcm90YXRlKCIrYSsiZGVnKSIpKToobXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGIsInRyYW5zZm9ybU9yaWdpbiIsIjAlIDAlIiksbXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGIsInRyYW5zZm9ybSIsInNjYWxlKCIrdGhpcy5zY2FsZSsiKSB0cmFuc2xhdGUoIisxMDAqYysiJSwiKzEwMCpkKyIlKSIpKTtiLmxlZnQ9TWF0aC5yb3VuZCh0aGlzLmJvdW5kcy54LQpNYXRoLmNlaWwoYyooImZpbGwiIT10aGlzLm92ZXJmbG93JiYid2lkdGgiIT10aGlzLm92ZXJmbG93PzM6MSkpKSsicHgiO2IudG9wPU1hdGgucm91bmQodGhpcy5ib3VuZHMueS1kKigiZmlsbCIhPXRoaXMub3ZlcmZsb3c/MzoxKSkrInB4IjtiLm9wYWNpdHk9MTAwPnRoaXMub3BhY2l0eT90aGlzLm9wYWNpdHkvMTAwOiIifTsKbXhUZXh0LnByb3RvdHlwZS51cGRhdGVJbm5lckh0bWw9ZnVuY3Rpb24oYSl7aWYobXhVdGlscy5pc05vZGUodGhpcy52YWx1ZSkpYS5pbm5lckhUTUw9dGhpcy52YWx1ZS5vdXRlckhUTUw7ZWxzZXt2YXIgYj10aGlzLnZhbHVlO3RoaXMuZGlhbGVjdCE9bXhDb25zdGFudHMuRElBTEVDVF9TVFJJQ1RIVE1MJiYoYj1teFV0aWxzLmh0bWxFbnRpdGllcyhiLCExKSk7Yj1teFV0aWxzLnJlcGxhY2VUcmFpbGluZ05ld2xpbmVzKGIsIjxkaXY+Jm5ic3A7PC9kaXY+Iik7Yj10aGlzLnJlcGxhY2VMaW5lZmVlZHM/Yi5yZXBsYWNlKC9cbi9nLCI8YnIvPiIpOmI7YS5pbm5lckhUTUw9JzxkaXYgc3R5bGU9ImRpc3BsYXk6aW5saW5lLWJsb2NrO19kaXNwbGF5OmlubGluZTsiPicrYisiPC9kaXY+In19OwpteFRleHQucHJvdG90eXBlLnVwZGF0ZUh0bWxGaWx0ZXI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm5vZGUuc3R5bGUsYj10aGlzLm1hcmdpbi54LGM9dGhpcy5tYXJnaW4ueSxkPXRoaXMuc2NhbGU7bXhVdGlscy5zZXRPcGFjaXR5KHRoaXMubm9kZSx0aGlzLm9wYWNpdHkpO3ZhciBlLGY9MCxnPW51bGwhPXRoaXMuc3RhdGU/dGhpcy5zdGF0ZS52aWV3LnRleHREaXY6bnVsbCxrPXRoaXMubm9kZTtpZihudWxsIT1nKXtnLnN0eWxlLm92ZXJmbG93PSIiO2cuc3R5bGUuaGVpZ2h0PSIiO2cuc3R5bGUud2lkdGg9IiI7dGhpcy51cGRhdGVGb250KGcpO3RoaXMudXBkYXRlU2l6ZShnLCExKTt0aGlzLnVwZGF0ZUlubmVySHRtbChnKTt2YXIgbD1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLndpZHRoL3RoaXMuc2NhbGUpO3RoaXMud3JhcCYmMDxsPyhnLnN0eWxlLndoaXRlU3BhY2U9Im5vcm1hbCIsZy5zdHlsZS53b3JkV3JhcD1teENvbnN0YW50cy5XT1JEX1dSQVAsZT1sLHRoaXMuY2xpcHBlZCYmCihlPU1hdGgubWluKGUsdGhpcy5ib3VuZHMud2lkdGgpKSxnLnN0eWxlLndpZHRoPWUrInB4Iik6Zy5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiO2s9ZztudWxsIT1rLmZpcnN0Q2hpbGQmJiJESVYiPT1rLmZpcnN0Q2hpbGQubm9kZU5hbWUmJihrPWsuZmlyc3RDaGlsZCx0aGlzLndyYXAmJiJicmVhay13b3JkIj09Zy5zdHlsZS53b3JkV3JhcCYmKGsuc3R5bGUud2lkdGg9IjEwMCUiKSk7IXRoaXMuY2xpcHBlZCYmdGhpcy53cmFwJiYwPGwmJihlPWsub2Zmc2V0V2lkdGgrdGhpcy50ZXh0V2lkdGhQYWRkaW5nLGcuc3R5bGUud2lkdGg9ZSsicHgiKTtmPWsub2Zmc2V0SGVpZ2h0KzI7bXhDbGllbnQuSVNfUVVJUktTJiZudWxsIT10aGlzLmJvcmRlciYmdGhpcy5ib3JkZXIhPW14Q29uc3RhbnRzLk5PTkUmJihmKz0zKX1lbHNlIG51bGwhPWsuZmlyc3RDaGlsZCYmIkRJViI9PWsuZmlyc3RDaGlsZC5ub2RlTmFtZSYmKGs9ay5maXJzdENoaWxkLGY9ay5vZmZzZXRIZWlnaHQpO2U9ay5vZmZzZXRXaWR0aCsKdGhpcy50ZXh0V2lkdGhQYWRkaW5nO3RoaXMuY2xpcHBlZCYmKGY9TWF0aC5taW4oZix0aGlzLmJvdW5kcy5oZWlnaHQpKTtsPXRoaXMuYm91bmRzLndpZHRoL2Q7Zz10aGlzLmJvdW5kcy5oZWlnaHQvZDsiZmlsbCI9PXRoaXMub3ZlcmZsb3c/KGY9ZyxlPWwpOiJ3aWR0aCI9PXRoaXMub3ZlcmZsb3cmJihmPWsuc2Nyb2xsSGVpZ2h0LGU9bCk7dGhpcy5vZmZzZXRXaWR0aD1lO3RoaXMub2Zmc2V0SGVpZ2h0PWY7bXhDbGllbnQuSVNfUVVJUktTJiYodGhpcy5jbGlwcGVkfHwid2lkdGgiPT10aGlzLm92ZXJmbG93JiYwPGcpPyhnPU1hdGgubWluKGcsZiksYS5oZWlnaHQ9TWF0aC5yb3VuZChnKSsicHgiKTpnPWY7ImZpbGwiIT10aGlzLm92ZXJmbG93JiYid2lkdGgiIT10aGlzLm92ZXJmbG93JiYodGhpcy5jbGlwcGVkJiYoZT1NYXRoLm1pbihsLGUpKSxsPWUsbXhDbGllbnQuSVNfUVVJUktTJiZ0aGlzLmNsaXBwZWR8fHRoaXMud3JhcCkmJihhLndpZHRoPU1hdGgucm91bmQobCkrCiJweCIpO3ZhciBnPWcqZCxsPWwqZCxtPXRoaXMuZ2V0VGV4dFJvdGF0aW9uKCkqKE1hdGguUEkvMTgwKTtlPXBhcnNlRmxvYXQocGFyc2VGbG9hdChNYXRoLmNvcyhtKSkudG9GaXhlZCg4KSk7Zj1wYXJzZUZsb2F0KHBhcnNlRmxvYXQoTWF0aC5zaW4oLW0pKS50b0ZpeGVkKDgpKTttJT0yKk1hdGguUEk7MD5tJiYobSs9MipNYXRoLlBJKTttJT1NYXRoLlBJO20+TWF0aC5QSS8yJiYobT1NYXRoLlBJLW0pO3ZhciBrPU1hdGguY29zKG0pLG49TWF0aC5zaW4oLW0pLGI9bCotKGIrLjUpLHA9ZyotKGMrLjUpOzAhPW0mJihjPSJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT0iK2UrIiwgTTEyPSIrZisiLCBNMjE9IistZisiLCBNMjI9IitlKyIsIHNpemluZ01ldGhvZD0nYXV0byBleHBhbmQnKSIsYS5maWx0ZXI9bnVsbCE9YS5maWx0ZXImJjA8YS5maWx0ZXIubGVuZ3RoP2EuZmlsdGVyKygiICIrYyk6Yyk7Yz0wOyJmaWxsIiE9dGhpcy5vdmVyZmxvdyYmCm14Q2xpZW50LklTX1FVSVJLUyYmKGM9dGhpcy52YWxpZ249PW14Q29uc3RhbnRzLkFMSUdOX1RPUD9jLTE6dGhpcy52YWxpZ249PW14Q29uc3RhbnRzLkFMSUdOX0JPVFRPTT9jKzI6YysxKTthLnpvb209ZDthLmxlZnQ9TWF0aC5yb3VuZCh0aGlzLmJvdW5kcy54KygobC1sKmsrZypuKS8yLWUqYi1mKnApLWwvMikrInB4IjthLnRvcD1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLnkrKChnLWcqaytsKm4pLzIrZipiLWUqcCktZy8yK2MpKyJweCJ9OwpteFRleHQucHJvdG90eXBlLnVwZGF0ZVZhbHVlPWZ1bmN0aW9uKCl7aWYobXhVdGlscy5pc05vZGUodGhpcy52YWx1ZSkpdGhpcy5ub2RlLmlubmVySFRNTD0iIix0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy52YWx1ZSk7ZWxzZXt2YXIgYT10aGlzLnZhbHVlO3RoaXMuZGlhbGVjdCE9bXhDb25zdGFudHMuRElBTEVDVF9TVFJJQ1RIVE1MJiYoYT1teFV0aWxzLmh0bWxFbnRpdGllcyhhLCExKSk7dmFyIGE9bXhVdGlscy5yZXBsYWNlVHJhaWxpbmdOZXdsaW5lcyhhLCI8ZGl2Pjxicj48L2Rpdj4iKSxhPXRoaXMucmVwbGFjZUxpbmVmZWVkcz9hLnJlcGxhY2UoL1xuL2csIjxici8+Iik6YSxiPW51bGwhPXRoaXMuYmFja2dyb3VuZCYmdGhpcy5iYWNrZ3JvdW5kIT1teENvbnN0YW50cy5OT05FP3RoaXMuYmFja2dyb3VuZDpudWxsLGM9bnVsbCE9dGhpcy5ib3JkZXImJnRoaXMuYm9yZGVyIT1teENvbnN0YW50cy5OT05FP3RoaXMuYm9yZGVyOm51bGw7aWYoImZpbGwiPT10aGlzLm92ZXJmbG93fHwKIndpZHRoIj09dGhpcy5vdmVyZmxvdyludWxsIT1iJiYodGhpcy5ub2RlLnN0eWxlLmJhY2tncm91bmRDb2xvcj1iKSxudWxsIT1jJiYodGhpcy5ub2RlLnN0eWxlLmJvcmRlcj0iMXB4IHNvbGlkICIrYyk7ZWxzZXt2YXIgZD0iIjtudWxsIT1iJiYoZCs9ImJhY2tncm91bmQtY29sb3I6IitteFV0aWxzLmh0bWxFbnRpdGllcyhiKSsiOyIpO251bGwhPWMmJihkKz0iYm9yZGVyOjFweCBzb2xpZCAiK214VXRpbHMuaHRtbEVudGl0aWVzKGMpKyI7Iik7YT0nPGRpdiBzdHlsZT0iem9vbToxOycrZCsiZGlzcGxheTppbmxpbmUtYmxvY2s7X2Rpc3BsYXk6aW5saW5lO3RleHQtZGVjb3JhdGlvbjppbmhlcml0O3BhZGRpbmctYm90dG9tOjFweDtwYWRkaW5nLXJpZ2h0OjFweDtsaW5lLWhlaWdodDoiKyhteENvbnN0YW50cy5BQlNPTFVURV9MSU5FX0hFSUdIVD90aGlzLnNpemUqbXhDb25zdGFudHMuTElORV9IRUlHSFQrInB4IjpteENvbnN0YW50cy5MSU5FX0hFSUdIVCkrJyI+JythKyI8L2Rpdj4ifXRoaXMubm9kZS5pbm5lckhUTUw9CmE7YT10aGlzLm5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpOzA8YS5sZW5ndGgmJihiPXRoaXMudGV4dERpcmVjdGlvbixiPT1teENvbnN0YW50cy5URVhUX0RJUkVDVElPTl9BVVRPJiZ0aGlzLmRpYWxlY3QhPW14Q29uc3RhbnRzLkRJQUxFQ1RfU1RSSUNUSFRNTCYmKGI9dGhpcy5nZXRBdXRvRGlyZWN0aW9uKCkpLGI9PW14Q29uc3RhbnRzLlRFWFRfRElSRUNUSU9OX0xUUnx8Yj09bXhDb25zdGFudHMuVEVYVF9ESVJFQ1RJT05fUlRMP2FbYS5sZW5ndGgtMV0uc2V0QXR0cmlidXRlKCJkaXIiLGIpOmFbYS5sZW5ndGgtMV0ucmVtb3ZlQXR0cmlidXRlKCJkaXIiKSl9fTsKbXhUZXh0LnByb3RvdHlwZS51cGRhdGVGb250PWZ1bmN0aW9uKGEpe2E9YS5zdHlsZTthLmxpbmVIZWlnaHQ9bXhDb25zdGFudHMuQUJTT0xVVEVfTElORV9IRUlHSFQ/dGhpcy5zaXplKm14Q29uc3RhbnRzLkxJTkVfSEVJR0hUKyJweCI6bXhDb25zdGFudHMuTElORV9IRUlHSFQ7YS5mb250U2l6ZT10aGlzLnNpemUrInB4IjthLmZvbnRGYW1pbHk9dGhpcy5mYW1pbHk7YS52ZXJ0aWNhbEFsaWduPSJ0b3AiO2EuY29sb3I9dGhpcy5jb2xvcjthLmZvbnRXZWlnaHQ9KHRoaXMuZm9udFN0eWxlJm14Q29uc3RhbnRzLkZPTlRfQk9MRCk9PW14Q29uc3RhbnRzLkZPTlRfQk9MRD8iYm9sZCI6IiI7YS5mb250U3R5bGU9KHRoaXMuZm9udFN0eWxlJm14Q29uc3RhbnRzLkZPTlRfSVRBTElDKT09bXhDb25zdGFudHMuRk9OVF9JVEFMSUM/Iml0YWxpYyI6IiI7dmFyIGI9W107KHRoaXMuZm9udFN0eWxlJm14Q29uc3RhbnRzLkZPTlRfVU5ERVJMSU5FKT09bXhDb25zdGFudHMuRk9OVF9VTkRFUkxJTkUmJgpiLnB1c2goInVuZGVybGluZSIpOyh0aGlzLmZvbnRTdHlsZSZteENvbnN0YW50cy5GT05UX1NUUklLRVRIUk9VR0gpPT1teENvbnN0YW50cy5GT05UX1NUUklLRVRIUk9VR0gmJmIucHVzaCgibGluZS10aHJvdWdoIik7YS50ZXh0RGVjb3JhdGlvbj1iLmpvaW4oIiAiKTthLnRleHRBbGlnbj10aGlzLmFsaWduPT1teENvbnN0YW50cy5BTElHTl9DRU5URVI/ImNlbnRlciI6dGhpcy5hbGlnbj09bXhDb25zdGFudHMuQUxJR05fUklHSFQ/InJpZ2h0IjoibGVmdCJ9OwpteFRleHQucHJvdG90eXBlLnVwZGF0ZVNpemU9ZnVuY3Rpb24oYSxiKXt2YXIgYz1NYXRoLm1heCgwLE1hdGgucm91bmQodGhpcy5ib3VuZHMud2lkdGgvdGhpcy5zY2FsZSkpLGQ9TWF0aC5tYXgoMCxNYXRoLnJvdW5kKHRoaXMuYm91bmRzLmhlaWdodC90aGlzLnNjYWxlKSksZT1hLnN0eWxlO3RoaXMuY2xpcHBlZD8oZS5vdmVyZmxvdz0iaGlkZGVuIixteENsaWVudC5JU19RVUlSS1M/ZS53aWR0aD1jKyJweCI6KGUubWF4SGVpZ2h0PWQrInB4IixlLm1heFdpZHRoPWMrInB4IikpOiJmaWxsIj09dGhpcy5vdmVyZmxvdz8oZS53aWR0aD1jKzErInB4IixlLmhlaWdodD1kKzErInB4IixlLm92ZXJmbG93PSJoaWRkZW4iKToid2lkdGgiPT10aGlzLm92ZXJmbG93JiYoZS53aWR0aD1jKzErInB4IixlLm1heEhlaWdodD1kKzErInB4IixlLm92ZXJmbG93PSJoaWRkZW4iKTtpZih0aGlzLndyYXAmJjA8Yyl7aWYoZS53b3JkV3JhcD1teENvbnN0YW50cy5XT1JEX1dSQVAsZS53aGl0ZVNwYWNlPQoibm9ybWFsIixlLndpZHRoPWMrInB4IixiJiYiZmlsbCIhPXRoaXMub3ZlcmZsb3cmJiJ3aWR0aCIhPXRoaXMub3ZlcmZsb3cpe2Q9YTtudWxsIT1kLmZpcnN0Q2hpbGQmJiJESVYiPT1kLmZpcnN0Q2hpbGQubm9kZU5hbWUmJihkPWQuZmlyc3RDaGlsZCwiYnJlYWstd29yZCI9PWEuc3R5bGUud29yZFdyYXAmJihkLnN0eWxlLndpZHRoPSIxMDAlIikpO3ZhciBmPWQub2Zmc2V0V2lkdGg7aWYoMD09Zil7dmFyIGc9YS5wYXJlbnROb2RlO2Euc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIjtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpO2Y9ZC5vZmZzZXRXaWR0aDthLnN0eWxlLnZpc2liaWxpdHk9IiI7Zy5hcHBlbmRDaGlsZChhKX1mKz0zO3RoaXMuY2xpcHBlZCYmKGY9TWF0aC5taW4oZixjKSk7ZS53aWR0aD1mKyJweCJ9fWVsc2UgZS53aGl0ZVNwYWNlPSJub3dyYXAifTsKbXhUZXh0LnByb3RvdHlwZS51cGRhdGVNYXJnaW49ZnVuY3Rpb24oKXt0aGlzLm1hcmdpbj1teFV0aWxzLmdldEFsaWdubWVudEFzUG9pbnQodGhpcy5hbGlnbix0aGlzLnZhbGlnbil9OwpteFRleHQucHJvdG90eXBlLmdldFNwYWNpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG14UG9pbnQodGhpcy5hbGlnbj09bXhDb25zdGFudHMuQUxJR05fQ0VOVEVSPyh0aGlzLnNwYWNpbmdMZWZ0LXRoaXMuc3BhY2luZ1JpZ2h0KS8yOnRoaXMuYWxpZ249PW14Q29uc3RhbnRzLkFMSUdOX1JJR0hUPy10aGlzLnNwYWNpbmdSaWdodC10aGlzLmJhc2VTcGFjaW5nUmlnaHQ6dGhpcy5zcGFjaW5nTGVmdCt0aGlzLmJhc2VTcGFjaW5nTGVmdCx0aGlzLnZhbGlnbj09bXhDb25zdGFudHMuQUxJR05fTUlERExFPyh0aGlzLnNwYWNpbmdUb3AtdGhpcy5zcGFjaW5nQm90dG9tKS8yOnRoaXMudmFsaWduPT1teENvbnN0YW50cy5BTElHTl9CT1RUT00/LXRoaXMuc3BhY2luZ0JvdHRvbS10aGlzLmJhc2VTcGFjaW5nQm90dG9tOnRoaXMuc3BhY2luZ1RvcCt0aGlzLmJhc2VTcGFjaW5nVG9wKX07ZnVuY3Rpb24gbXhUcmlhbmdsZSgpe214QWN0b3IuY2FsbCh0aGlzKX0KbXhVdGlscy5leHRlbmQobXhUcmlhbmdsZSxteEFjdG9yKTtteFRyaWFuZ2xlLnByb3RvdHlwZS5pc1JvdW5kYWJsZT1mdW5jdGlvbigpe3JldHVybiEwfTtteFRyaWFuZ2xlLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixjLGQsZSl7Yj1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSxteENvbnN0YW50cy5MSU5FX0FSQ1NJWkUpLzI7dGhpcy5hZGRQb2ludHMoYSxbbmV3IG14UG9pbnQoMCwwKSxuZXcgbXhQb2ludChkLC41KmUpLG5ldyBteFBvaW50KDAsZSldLHRoaXMuaXNSb3VuZGVkLGIsITApfTtmdW5jdGlvbiBteEhleGFnb24oKXtteEFjdG9yLmNhbGwodGhpcyl9bXhVdGlscy5leHRlbmQobXhIZXhhZ29uLG14QWN0b3IpOwpteEhleGFnb24ucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGMsZCxlKXtiPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLG14Q29uc3RhbnRzLkxJTkVfQVJDU0laRSkvMjt0aGlzLmFkZFBvaW50cyhhLFtuZXcgbXhQb2ludCguMjUqZCwwKSxuZXcgbXhQb2ludCguNzUqZCwwKSxuZXcgbXhQb2ludChkLC41KmUpLG5ldyBteFBvaW50KC43NSpkLGUpLG5ldyBteFBvaW50KC4yNSpkLGUpLG5ldyBteFBvaW50KDAsLjUqZSldLHRoaXMuaXNSb3VuZGVkLGIsITApfTtmdW5jdGlvbiBteExpbmUoYSxiLGMsZCl7bXhTaGFwZS5jYWxsKHRoaXMpO3RoaXMuYm91bmRzPWE7dGhpcy5zdHJva2U9Yjt0aGlzLnN0cm9rZXdpZHRoPW51bGwhPWM/YzoxO3RoaXMudmVydGljYWw9bnVsbCE9ZD9kOnRoaXMudmVydGljYWx9bXhVdGlscy5leHRlbmQobXhMaW5lLG14U2hhcGUpO214TGluZS5wcm90b3R5cGUudmVydGljYWw9ITE7Cm14TGluZS5wcm90b3R5cGUucGFpbnRWZXJ0ZXhTaGFwZT1mdW5jdGlvbihhLGIsYyxkLGUpe2EuYmVnaW4oKTtpZih0aGlzLnZlcnRpY2FsKXt2YXIgZj1iK2QvMjthLm1vdmVUbyhmLGMpO2EubGluZVRvKGYsYytlKX1lbHNlIGY9YytlLzIsYS5tb3ZlVG8oYixmKSxhLmxpbmVUbyhiK2QsZik7YS5zdHJva2UoKX07ZnVuY3Rpb24gbXhJbWFnZVNoYXBlKGEsYixjLGQsZSl7bXhTaGFwZS5jYWxsKHRoaXMpO3RoaXMuYm91bmRzPWE7dGhpcy5pbWFnZT1iO3RoaXMuZmlsbD1jO3RoaXMuc3Ryb2tlPWQ7dGhpcy5zdHJva2V3aWR0aD1udWxsIT1lP2U6MTt0aGlzLnNoYWRvdz0hMX1teFV0aWxzLmV4dGVuZChteEltYWdlU2hhcGUsbXhSZWN0YW5nbGVTaGFwZSk7bXhJbWFnZVNoYXBlLnByb3RvdHlwZS5wcmVzZXJ2ZUltYWdlQXNwZWN0PSEwO214SW1hZ2VTaGFwZS5wcm90b3R5cGUuZ2V0U3ZnU2NyZWVuT2Zmc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIDB9OwpteEltYWdlU2hhcGUucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGEpe214U2hhcGUucHJvdG90eXBlLmFwcGx5LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLmdyYWRpZW50PXRoaXMuc3Ryb2tlPXRoaXMuZmlsbD1udWxsO251bGwhPXRoaXMuc3R5bGUmJih0aGlzLnByZXNlcnZlSW1hZ2VBc3BlY3Q9MT09bXhVdGlscy5nZXROdW1iZXIodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9JTUFHRV9BU1BFQ1QsMSksdGhpcy5mbGlwSD10aGlzLmZsaXBIfHwxPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImltYWdlRmxpcEgiLDApLHRoaXMuZmxpcFY9dGhpcy5mbGlwVnx8MT09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJpbWFnZUZsaXBWIiwwKSl9O214SW1hZ2VTaGFwZS5wcm90b3R5cGUuaXNIdG1sQWxsb3dlZD1mdW5jdGlvbigpe3JldHVybiF0aGlzLnByZXNlcnZlSW1hZ2VBc3BlY3R9OwpteEltYWdlU2hhcGUucHJvdG90eXBlLmNyZWF0ZUh0bWw9ZnVuY3Rpb24oKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTthLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7cmV0dXJuIGF9O214SW1hZ2VTaGFwZS5wcm90b3R5cGUuaXNSb3VuZGFibGU9ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4hMX07Cm14SW1hZ2VTaGFwZS5wcm90b3R5cGUucGFpbnRWZXJ0ZXhTaGFwZT1mdW5jdGlvbihhLGIsYyxkLGUpe2lmKG51bGwhPXRoaXMuaW1hZ2Upe3ZhciBmPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9JTUFHRV9CQUNLR1JPVU5ELG51bGwpLGc9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0lNQUdFX0JPUkRFUixudWxsKTtudWxsIT1mJiYoYS5zZXRGaWxsQ29sb3IoZiksYS5zZXRTdHJva2VDb2xvcihnKSxhLnJlY3QoYixjLGQsZSksYS5maWxsQW5kU3Ryb2tlKCkpO2EuaW1hZ2UoYixjLGQsZSx0aGlzLmltYWdlLHRoaXMucHJlc2VydmVJbWFnZUFzcGVjdCwhMSwhMSk7Zz1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfSU1BR0VfQk9SREVSLG51bGwpO251bGwhPWcmJihhLnNldFNoYWRvdyghMSksYS5zZXRTdHJva2VDb2xvcihnKSxhLnJlY3QoYixjLGQsZSksYS5zdHJva2UoKSl9ZWxzZSBteFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5wYWludEJhY2tncm91bmQuYXBwbHkodGhpcywKYXJndW1lbnRzKX07Cm14SW1hZ2VTaGFwZS5wcm90b3R5cGUucmVkcmF3SHRtbFNoYXBlPWZ1bmN0aW9uKCl7dGhpcy5ub2RlLnN0eWxlLmxlZnQ9TWF0aC5yb3VuZCh0aGlzLmJvdW5kcy54KSsicHgiO3RoaXMubm9kZS5zdHlsZS50b3A9TWF0aC5yb3VuZCh0aGlzLmJvdW5kcy55KSsicHgiO3RoaXMubm9kZS5zdHlsZS53aWR0aD1NYXRoLm1heCgwLE1hdGgucm91bmQodGhpcy5ib3VuZHMud2lkdGgpKSsicHgiO3RoaXMubm9kZS5zdHlsZS5oZWlnaHQ9TWF0aC5tYXgoMCxNYXRoLnJvdW5kKHRoaXMuYm91bmRzLmhlaWdodCkpKyJweCI7dGhpcy5ub2RlLmlubmVySFRNTD0iIjtpZihudWxsIT10aGlzLmltYWdlKXt2YXIgYT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfSU1BR0VfQkFDS0dST1VORCwiIiksYj1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfSU1BR0VfQk9SREVSLCIiKTt0aGlzLm5vZGUuc3R5bGUuYmFja2dyb3VuZENvbG9yPWE7CnRoaXMubm9kZS5zdHlsZS5ib3JkZXJDb2xvcj1iO2E9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChteENsaWVudC5JU19JRTZ8fChudWxsPT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fDg+PWRvY3VtZW50LmRvY3VtZW50TW9kZSkmJjAhPXRoaXMucm90YXRpb24/bXhDbGllbnQuVk1MX1BSRUZJWCsiOmltYWdlIjoiaW1nIik7YS5zZXRBdHRyaWJ1dGUoImJvcmRlciIsIjAiKTthLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7YS5zcmM9dGhpcy5pbWFnZTtiPTEwMD50aGlzLm9wYWNpdHk/ImFscGhhKG9wYWNpdHk9Iit0aGlzLm9wYWNpdHkrIikiOiIiO3RoaXMubm9kZS5zdHlsZS5maWx0ZXI9Yjt0aGlzLmZsaXBIJiZ0aGlzLmZsaXBWP2IrPSJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQmFzaWNJbWFnZShyb3RhdGlvbj0yKSI6dGhpcy5mbGlwSD9iKz0icHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkJhc2ljSW1hZ2UobWlycm9yPTEpIjp0aGlzLmZsaXBWJiYKKGIrPSJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQmFzaWNJbWFnZShyb3RhdGlvbj0yLCBtaXJyb3I9MSkiKTthLnN0eWxlLmZpbHRlciE9YiYmKGEuc3R5bGUuZmlsdGVyPWIpOyJpbWFnZSI9PWEubm9kZU5hbWU/YS5zdHlsZS5yb3RhdGlvbj10aGlzLnJvdGF0aW9uOjAhPXRoaXMucm90YXRpb24/bXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGEuc3R5bGUsInRyYW5zZm9ybSIsInJvdGF0ZSgiK3RoaXMucm90YXRpb24rImRlZykiKTpteFV0aWxzLnNldFByZWZpeGVkU3R5bGUoYS5zdHlsZSwidHJhbnNmb3JtIiwiIik7YS5zdHlsZS53aWR0aD10aGlzLm5vZGUuc3R5bGUud2lkdGg7YS5zdHlsZS5oZWlnaHQ9dGhpcy5ub2RlLnN0eWxlLmhlaWdodDt0aGlzLm5vZGUuc3R5bGUuYmFja2dyb3VuZEltYWdlPSIiO3RoaXMubm9kZS5hcHBlbmRDaGlsZChhKX1lbHNlIHRoaXMuc2V0VHJhbnNwYXJlbnRCYWNrZ3JvdW5kSW1hZ2UodGhpcy5ub2RlKX07CmZ1bmN0aW9uIG14TGFiZWwoYSxiLGMsZCl7bXhSZWN0YW5nbGVTaGFwZS5jYWxsKHRoaXMsYSxiLGMsZCl9bXhVdGlscy5leHRlbmQobXhMYWJlbCxteFJlY3RhbmdsZVNoYXBlKTtteExhYmVsLnByb3RvdHlwZS5pbWFnZVNpemU9bXhDb25zdGFudHMuREVGQVVMVF9JTUFHRVNJWkU7bXhMYWJlbC5wcm90b3R5cGUuc3BhY2luZz0yO214TGFiZWwucHJvdG90eXBlLmluZGljYXRvclNpemU9MTA7bXhMYWJlbC5wcm90b3R5cGUuaW5kaWNhdG9yU3BhY2luZz0yO214TGFiZWwucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oYSl7bXhTaGFwZS5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbCE9dGhpcy5pbmRpY2F0b3JTaGFwZSYmKHRoaXMuaW5kaWNhdG9yPW5ldyB0aGlzLmluZGljYXRvclNoYXBlLHRoaXMuaW5kaWNhdG9yLmRpYWxlY3Q9dGhpcy5kaWFsZWN0LHRoaXMuaW5kaWNhdG9yLmluaXQodGhpcy5ub2RlKSl9OwpteExhYmVsLnByb3RvdHlwZS5yZWRyYXc9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmluZGljYXRvciYmKHRoaXMuaW5kaWNhdG9yLmZpbGw9dGhpcy5pbmRpY2F0b3JDb2xvcix0aGlzLmluZGljYXRvci5zdHJva2U9dGhpcy5pbmRpY2F0b3JTdHJva2VDb2xvcix0aGlzLmluZGljYXRvci5ncmFkaWVudD10aGlzLmluZGljYXRvckdyYWRpZW50Q29sb3IsdGhpcy5pbmRpY2F0b3IuZGlyZWN0aW9uPXRoaXMuaW5kaWNhdG9yRGlyZWN0aW9uLHRoaXMuaW5kaWNhdG9yLnJlZHJhdygpKTtteFNoYXBlLnByb3RvdHlwZS5yZWRyYXcuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtteExhYmVsLnByb3RvdHlwZS5pc0h0bWxBbGxvd2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG14UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLmlzSHRtbEFsbG93ZWQuYXBwbHkodGhpcyxhcmd1bWVudHMpJiZudWxsPT10aGlzLmluZGljYXRvckNvbG9yJiZudWxsPT10aGlzLmluZGljYXRvclNoYXBlfTsKbXhMYWJlbC5wcm90b3R5cGUucGFpbnRGb3JlZ3JvdW5kPWZ1bmN0aW9uKGEsYixjLGQsZSl7dGhpcy5wYWludEltYWdlKGEsYixjLGQsZSk7dGhpcy5wYWludEluZGljYXRvcihhLGIsYyxkLGUpO214UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLnBhaW50Rm9yZWdyb3VuZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O214TGFiZWwucHJvdG90eXBlLnBhaW50SW1hZ2U9ZnVuY3Rpb24oYSxiLGMsZCxlKXtudWxsIT10aGlzLmltYWdlJiYoYj10aGlzLmdldEltYWdlQm91bmRzKGIsYyxkLGUpLGEuaW1hZ2UoYi54LGIueSxiLndpZHRoLGIuaGVpZ2h0LHRoaXMuaW1hZ2UsITEsITEsITEpKX07Cm14TGFiZWwucHJvdG90eXBlLmdldEltYWdlQm91bmRzPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9JTUFHRV9BTElHTixteENvbnN0YW50cy5BTElHTl9MRUZUKSxmPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9JTUFHRV9WRVJUSUNBTF9BTElHTixteENvbnN0YW50cy5BTElHTl9NSURETEUpLGc9bXhVdGlscy5nZXROdW1iZXIodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9JTUFHRV9XSURUSCxteENvbnN0YW50cy5ERUZBVUxUX0lNQUdFU0laRSksaz1teFV0aWxzLmdldE51bWJlcih0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0lNQUdFX0hFSUdIVCxteENvbnN0YW50cy5ERUZBVUxUX0lNQUdFU0laRSksbD1teFV0aWxzLmdldE51bWJlcih0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkcsdGhpcy5zcGFjaW5nKSs1O2E9ZT09bXhDb25zdGFudHMuQUxJR05fQ0VOVEVSPwphKyhjLWcpLzI6ZT09bXhDb25zdGFudHMuQUxJR05fUklHSFQ/YSsoYy1nLWwpOmErbDtiPWY9PW14Q29uc3RhbnRzLkFMSUdOX1RPUD9iK2w6Zj09bXhDb25zdGFudHMuQUxJR05fQk9UVE9NP2IrKGQtay1sKTpiKyhkLWspLzI7cmV0dXJuIG5ldyBteFJlY3RhbmdsZShhLGIsZyxrKX07bXhMYWJlbC5wcm90b3R5cGUucGFpbnRJbmRpY2F0b3I9ZnVuY3Rpb24oYSxiLGMsZCxlKXtudWxsIT10aGlzLmluZGljYXRvcj8odGhpcy5pbmRpY2F0b3IuYm91bmRzPXRoaXMuZ2V0SW5kaWNhdG9yQm91bmRzKGIsYyxkLGUpLHRoaXMuaW5kaWNhdG9yLnBhaW50KGEpKTpudWxsIT10aGlzLmluZGljYXRvckltYWdlJiYoYj10aGlzLmdldEluZGljYXRvckJvdW5kcyhiLGMsZCxlKSxhLmltYWdlKGIueCxiLnksYi53aWR0aCxiLmhlaWdodCx0aGlzLmluZGljYXRvckltYWdlLCExLCExLCExKSl9OwpteExhYmVsLnByb3RvdHlwZS5nZXRJbmRpY2F0b3JCb3VuZHM9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0lNQUdFX0FMSUdOLG14Q29uc3RhbnRzLkFMSUdOX0xFRlQpLGY9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0lNQUdFX1ZFUlRJQ0FMX0FMSUdOLG14Q29uc3RhbnRzLkFMSUdOX01JRERMRSksZz1teFV0aWxzLmdldE51bWJlcih0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0lORElDQVRPUl9XSURUSCx0aGlzLmluZGljYXRvclNpemUpLGs9bXhVdGlscy5nZXROdW1iZXIodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9JTkRJQ0FUT1JfSEVJR0hULHRoaXMuaW5kaWNhdG9yU2l6ZSksbD10aGlzLnNwYWNpbmcrNTthPWU9PW14Q29uc3RhbnRzLkFMSUdOX1JJR0hUP2ErKGMtZy1sKTplPT1teENvbnN0YW50cy5BTElHTl9DRU5URVI/YSsoYy1nKS8KMjphK2w7Yj1mPT1teENvbnN0YW50cy5BTElHTl9CT1RUT00/YisoZC1rLWwpOmY9PW14Q29uc3RhbnRzLkFMSUdOX1RPUD9iK2w6YisoZC1rKS8yO3JldHVybiBuZXcgbXhSZWN0YW5nbGUoYSxiLGcsayl9OwpteExhYmVsLnByb3RvdHlwZS5yZWRyYXdIdG1sU2hhcGU9ZnVuY3Rpb24oKXtmb3IobXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUucmVkcmF3SHRtbFNoYXBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLm5vZGUuaGFzQ2hpbGROb2RlcygpOyl0aGlzLm5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ub2RlLmxhc3RDaGlsZCk7aWYobnVsbCE9dGhpcy5pbWFnZSl7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIik7YS5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiO2Euc2V0QXR0cmlidXRlKCJib3JkZXIiLCIwIik7dmFyIGI9dGhpcy5nZXRJbWFnZUJvdW5kcyh0aGlzLmJvdW5kcy54LHRoaXMuYm91bmRzLnksdGhpcy5ib3VuZHMud2lkdGgsdGhpcy5ib3VuZHMuaGVpZ2h0KTtiLngtPXRoaXMuYm91bmRzLng7Yi55LT10aGlzLmJvdW5kcy55O2Euc3R5bGUubGVmdD1NYXRoLnJvdW5kKGIueCkrInB4IjthLnN0eWxlLnRvcD1NYXRoLnJvdW5kKGIueSkrInB4IjthLnN0eWxlLndpZHRoPQpNYXRoLnJvdW5kKGIud2lkdGgpKyJweCI7YS5zdHlsZS5oZWlnaHQ9TWF0aC5yb3VuZChiLmhlaWdodCkrInB4IjthLnNyYz10aGlzLmltYWdlO3RoaXMubm9kZS5hcHBlbmRDaGlsZChhKX19O2Z1bmN0aW9uIG14Q3lsaW5kZXIoYSxiLGMsZCl7bXhTaGFwZS5jYWxsKHRoaXMpO3RoaXMuYm91bmRzPWE7dGhpcy5maWxsPWI7dGhpcy5zdHJva2U9Yzt0aGlzLnN0cm9rZXdpZHRoPW51bGwhPWQ/ZDoxfW14VXRpbHMuZXh0ZW5kKG14Q3lsaW5kZXIsbXhTaGFwZSk7bXhDeWxpbmRlci5wcm90b3R5cGUubWF4SGVpZ2h0PTQwO214Q3lsaW5kZXIucHJvdG90eXBlLnN2Z1N0cm9rZVRvbGVyYW5jZT0wOwpteEN5bGluZGVyLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlPWZ1bmN0aW9uKGEsYixjLGQsZSl7YS50cmFuc2xhdGUoYixjKTthLmJlZ2luKCk7dGhpcy5yZWRyYXdQYXRoKGEsYixjLGQsZSwhMSk7YS5maWxsQW5kU3Ryb2tlKCk7dGhpcy5vdXRsaW5lJiZudWxsIT10aGlzLnN0eWxlJiYwIT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQkFDS0dST1VORF9PVVRMSU5FLDApfHwoYS5zZXRTaGFkb3coITEpLGEuYmVnaW4oKSx0aGlzLnJlZHJhd1BhdGgoYSxiLGMsZCxlLCEwKSxhLnN0cm9rZSgpKX07bXhDeWxpbmRlci5wcm90b3R5cGUuZ2V0Q3lsaW5kZXJTaXplPWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBNYXRoLm1pbih0aGlzLm1heEhlaWdodCxNYXRoLnJvdW5kKGQvNSkpfTsKbXhDeWxpbmRlci5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsYyxkLGUsZil7Yj10aGlzLmdldEN5bGluZGVyU2l6ZShiLGMsZCxlKTtpZihmJiZudWxsIT10aGlzLmZpbGx8fCFmJiZudWxsPT10aGlzLmZpbGwpYS5tb3ZlVG8oMCxiKSxhLmN1cnZlVG8oMCwyKmIsZCwyKmIsZCxiKSxmfHwoYS5zdHJva2UoKSxhLmJlZ2luKCkpO2Z8fChhLm1vdmVUbygwLGIpLGEuY3VydmVUbygwLC1iLzMsZCwtYi8zLGQsYiksYS5saW5lVG8oZCxlLWIpLGEuY3VydmVUbyhkLGUrYi8zLDAsZStiLzMsMCxlLWIpLGEuY2xvc2UoKSl9O2Z1bmN0aW9uIG14Q29ubmVjdG9yKGEsYixjKXtteFBvbHlsaW5lLmNhbGwodGhpcyxhLGIsYyl9bXhVdGlscy5leHRlbmQobXhDb25uZWN0b3IsbXhQb2x5bGluZSk7Cm14Q29ubmVjdG9yLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ0JveD1mdW5jdGlvbigpe3RoaXMudXNlU3ZnQm91bmRpbmdCb3g9bnVsbCE9dGhpcy5zdHlsZSYmMT09dGhpcy5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9DVVJWRURdO214U2hhcGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nQm94LmFwcGx5KHRoaXMsYXJndW1lbnRzKX07bXhDb25uZWN0b3IucHJvdG90eXBlLnBhaW50RWRnZVNoYXBlPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5jcmVhdGVNYXJrZXIoYSxiLCEwKSxkPXRoaXMuY3JlYXRlTWFya2VyKGEsYiwhMSk7bXhQb2x5bGluZS5wcm90b3R5cGUucGFpbnRFZGdlU2hhcGUuYXBwbHkodGhpcyxhcmd1bWVudHMpO2Euc2V0RmlsbENvbG9yKHRoaXMuc3Ryb2tlKTthLnNldFNoYWRvdyghMSk7YS5zZXREYXNoZWQoITEpO251bGwhPWMmJmMoKTtudWxsIT1kJiZkKCl9OwpteENvbm5lY3Rvci5wcm90b3R5cGUuY3JlYXRlTWFya2VyPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1udWxsLGU9Yi5sZW5ndGgsZj1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsYz9teENvbnN0YW50cy5TVFlMRV9TVEFSVEFSUk9XOm14Q29uc3RhbnRzLlNUWUxFX0VOREFSUk9XKSxnPWM/YlsxXTpiW2UtMl0saz1jP2JbMF06YltlLTFdO2lmKG51bGwhPWYmJm51bGwhPWcmJm51bGwhPWspe2ZvcihkPTE7ZDxlLTEmJjA9PU1hdGgucm91bmQoZy54LWsueCkmJjA9PU1hdGgucm91bmQoZy55LWsueSk7KWc9Yz9iWzErZF06YltlLTItZF0sZCsrO2I9ay54LWcueDtlPWsueS1nLnk7ZD1NYXRoLm1heCgxLE1hdGguc3FydChiKmIrZSplKSk7Zz1iL2Q7Yj1lL2Q7ZT1teFV0aWxzLmdldE51bWJlcih0aGlzLnN0eWxlLGM/bXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFOm14Q29uc3RhbnRzLlNUWUxFX0VORFNJWkUsbXhDb25zdGFudHMuREVGQVVMVF9NQVJLRVJTSVpFKTtkPW14TWFya2VyLmNyZWF0ZU1hcmtlcihhLAp0aGlzLGYsayxnLGIsZSxjLHRoaXMuc3Ryb2tld2lkdGgsMCE9dGhpcy5zdHlsZVtjP214Q29uc3RhbnRzLlNUWUxFX1NUQVJURklMTDpteENvbnN0YW50cy5TVFlMRV9FTkRGSUxMXSl9cmV0dXJuIGR9OwpteENvbm5lY3Rvci5wcm90b3R5cGUuYXVnbWVudEJvdW5kaW5nQm94PWZ1bmN0aW9uKGEpe214U2hhcGUucHJvdG90eXBlLmF1Z21lbnRCb3VuZGluZ0JveC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGI9MDtteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1RBUlRBUlJPVyxteENvbnN0YW50cy5OT05FKSE9bXhDb25zdGFudHMuTk9ORSYmKGI9bXhVdGlscy5nZXROdW1iZXIodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkUsbXhDb25zdGFudHMuREVGQVVMVF9NQVJLRVJTSVpFKSsxKTtteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRU5EQVJST1csbXhDb25zdGFudHMuTk9ORSkhPW14Q29uc3RhbnRzLk5PTkUmJihiPU1hdGgubWF4KGIsbXhVdGlscy5nZXROdW1iZXIodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9FTkRTSVpFLG14Q29uc3RhbnRzLkRFRkFVTFRfTUFSS0VSU0laRSkpKwoxKTthLmdyb3coYip0aGlzLnNjYWxlKX07ZnVuY3Rpb24gbXhTd2ltbGFuZShhLGIsYyxkKXtteFNoYXBlLmNhbGwodGhpcyk7dGhpcy5ib3VuZHM9YTt0aGlzLmZpbGw9Yjt0aGlzLnN0cm9rZT1jO3RoaXMuc3Ryb2tld2lkdGg9bnVsbCE9ZD9kOjF9bXhVdGlscy5leHRlbmQobXhTd2ltbGFuZSxteFNoYXBlKTtteFN3aW1sYW5lLnByb3RvdHlwZS5pbWFnZVNpemU9MTY7bXhTd2ltbGFuZS5wcm90b3R5cGUuaXNSb3VuZGFibGU9ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4hMH07bXhTd2ltbGFuZS5wcm90b3R5cGUuZ2V0VGl0bGVTaXplPWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGgubWF4KDAsbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRSxteENvbnN0YW50cy5ERUZBVUxUX1NUQVJUU0laRSkpfTsKbXhTd2ltbGFuZS5wcm90b3R5cGUuZ2V0TGFiZWxCb3VuZHM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5nZXRUaXRsZVNpemUoKTthPW5ldyBteFJlY3RhbmdsZShhLngsYS55LGEud2lkdGgsYS5oZWlnaHQpO3ZhciBjPXRoaXMuaXNIb3Jpem9udGFsKCksZD0xPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRkxJUEgsMCksZT0xPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRkxJUFYsMCksZj10aGlzLmRpcmVjdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIfHx0aGlzLmRpcmVjdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRILGM9Yz09IWYsZD0hYyYmZCE9KHRoaXMuZGlyZWN0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEh8fHRoaXMuZGlyZWN0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVCksZT1jJiZlIT0odGhpcy5kaXJlY3Rpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSHx8CnRoaXMuZGlyZWN0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVCk7aWYoZil7Yj1NYXRoLm1pbihhLndpZHRoLGIqdGhpcy5zY2FsZSk7aWYoZHx8ZSlhLngrPWEud2lkdGgtYjthLndpZHRoPWJ9ZWxzZXtiPU1hdGgubWluKGEuaGVpZ2h0LGIqdGhpcy5zY2FsZSk7aWYoZHx8ZSlhLnkrPWEuaGVpZ2h0LWI7YS5oZWlnaHQ9Yn1yZXR1cm4gYX07bXhTd2ltbGFuZS5wcm90b3R5cGUuZ2V0R3JhZGllbnRCb3VuZHM9ZnVuY3Rpb24oYSxiLGMsZCxlKXthPXRoaXMuZ2V0VGl0bGVTaXplKCk7aWYodGhpcy5pc0hvcml6b250YWwoKSlyZXR1cm4gYT1NYXRoLm1pbihhLGUpLG5ldyBteFJlY3RhbmdsZShiLGMsZCxhKTthPU1hdGgubWluKGEsZCk7cmV0dXJuIG5ldyBteFJlY3RhbmdsZShiLGMsYSxlKX07Cm14U3dpbWxhbmUucHJvdG90eXBlLmdldFN3aW1sYW5lQXJjU2l6ZT1mdW5jdGlvbihhLGIsYyl7aWYoIjEiPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQUJTT0xVVEVfQVJDU0laRSwwKSlyZXR1cm4gTWF0aC5taW4oYS8yLE1hdGgubWluKGIvMixteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSxteENvbnN0YW50cy5MSU5FX0FSQ1NJWkUpLzIpKTthPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLDEwMCpteENvbnN0YW50cy5SRUNUQU5HTEVfUk9VTkRJTkdfRkFDVE9SKS8xMDA7cmV0dXJuIGMqYSozfTtteFN3aW1sYW5lLnByb3RvdHlwZS5pc0hvcml6b250YWw9ZnVuY3Rpb24oKXtyZXR1cm4gMT09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0hPUklaT05UQUwsMSl9OwpteFN3aW1sYW5lLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9dGhpcy5nZXRUaXRsZVNpemUoKSxnPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TV0lNTEFORV9GSUxMQ09MT1IsbXhDb25zdGFudHMuTk9ORSksaz0xPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1dJTUxBTkVfTElORSwxKSxsPTAsZj10aGlzLmlzSG9yaXpvbnRhbCgpP01hdGgubWluKGYsZSk6TWF0aC5taW4oZixkKTthLnRyYW5zbGF0ZShiLGMpO3RoaXMuaXNSb3VuZGVkPyhsPXRoaXMuZ2V0U3dpbWxhbmVBcmNTaXplKGQsZSxmKSxsPU1hdGgubWluKCh0aGlzLmlzSG9yaXpvbnRhbCgpP2U6ZCktZixNYXRoLm1pbihmLGwpKSx0aGlzLnBhaW50Um91bmRlZFN3aW1sYW5lKGEsYixjLGQsZSxmLGwsZyxrKSk6dGhpcy5wYWludFN3aW1sYW5lKGEsYixjLGQsZSxmLGcsayk7Zz1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsCm14Q29uc3RhbnRzLlNUWUxFX1NFUEFSQVRPUkNPTE9SLG14Q29uc3RhbnRzLk5PTkUpO3RoaXMucGFpbnRTZXBhcmF0b3IoYSxiLGMsZCxlLGYsZyk7bnVsbCE9dGhpcy5pbWFnZSYmKGU9dGhpcy5nZXRJbWFnZUJvdW5kcyhiLGMsZCxlKSxhLmltYWdlKGUueC1iLGUueS1jLGUud2lkdGgsZS5oZWlnaHQsdGhpcy5pbWFnZSwhMSwhMSwhMSkpO3RoaXMuZ2xhc3MmJihhLnNldFNoYWRvdyghMSksdGhpcy5wYWludEdsYXNzRWZmZWN0KGEsMCwwLGQsZixsKSl9OwpteFN3aW1sYW5lLnByb3RvdHlwZS5wYWludFN3aW1sYW5lPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayl7YS5iZWdpbigpO3ZhciBsPSEwO251bGwhPXRoaXMuc3R5bGUmJihsPSIxIj09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1BPSU5URVJfRVZFTlRTLCIxIikpO2x8fG51bGwhPXRoaXMuZmlsbCYmdGhpcy5maWxsIT1teENvbnN0YW50cy5OT05FfHwoYS5wb2ludGVyRXZlbnRzPSExKTt0aGlzLmlzSG9yaXpvbnRhbCgpPyhhLm1vdmVUbygwLGYpLGEubGluZVRvKDAsMCksYS5saW5lVG8oZCwwKSxhLmxpbmVUbyhkLGYpLGEuZmlsbEFuZFN0cm9rZSgpLGY8ZSYmKGchPW14Q29uc3RhbnRzLk5PTkUmJmx8fChhLnBvaW50ZXJFdmVudHM9ITEpLGchPW14Q29uc3RhbnRzLk5PTkUmJmEuc2V0RmlsbENvbG9yKGcpLGEuYmVnaW4oKSxhLm1vdmVUbygwLGYpLGEubGluZVRvKDAsZSksYS5saW5lVG8oZCxlKSxhLmxpbmVUbyhkLGYpLGc9PW14Q29uc3RhbnRzLk5PTkU/CmEuc3Ryb2tlKCk6YS5maWxsQW5kU3Ryb2tlKCkpKTooYS5tb3ZlVG8oZiwwKSxhLmxpbmVUbygwLDApLGEubGluZVRvKDAsZSksYS5saW5lVG8oZixlKSxhLmZpbGxBbmRTdHJva2UoKSxmPGQmJihnIT1teENvbnN0YW50cy5OT05FJiZsfHwoYS5wb2ludGVyRXZlbnRzPSExKSxnIT1teENvbnN0YW50cy5OT05FJiZhLnNldEZpbGxDb2xvcihnKSxhLmJlZ2luKCksYS5tb3ZlVG8oZiwwKSxhLmxpbmVUbyhkLDApLGEubGluZVRvKGQsZSksYS5saW5lVG8oZixlKSxnPT1teENvbnN0YW50cy5OT05FP2Euc3Ryb2tlKCk6YS5maWxsQW5kU3Ryb2tlKCkpKTtrJiZ0aGlzLnBhaW50RGl2aWRlcihhLGIsYyxkLGUsZixnPT1teENvbnN0YW50cy5OT05FKX07Cm14U3dpbWxhbmUucHJvdG90eXBlLnBhaW50Um91bmRlZFN3aW1sYW5lPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayxsKXthLmJlZ2luKCk7dmFyIG09ITA7bnVsbCE9dGhpcy5zdHlsZSYmKG09IjEiPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfUE9JTlRFUl9FVkVOVFMsIjEiKSk7bXx8bnVsbCE9dGhpcy5maWxsJiZ0aGlzLmZpbGwhPW14Q29uc3RhbnRzLk5PTkV8fChhLnBvaW50ZXJFdmVudHM9ITEpO3RoaXMuaXNIb3Jpem9udGFsKCk/KGEubW92ZVRvKGQsZiksYS5saW5lVG8oZCxnKSxhLnF1YWRUbyhkLDAsZC1NYXRoLm1pbihkLzIsZyksMCksYS5saW5lVG8oTWF0aC5taW4oZC8yLGcpLDApLGEucXVhZFRvKDAsMCwwLGcpLGEubGluZVRvKDAsZiksYS5maWxsQW5kU3Ryb2tlKCksZjxlJiYoayE9bXhDb25zdGFudHMuTk9ORSYmbXx8KGEucG9pbnRlckV2ZW50cz0hMSksayE9bXhDb25zdGFudHMuTk9ORSYmYS5zZXRGaWxsQ29sb3IoayksCmEuYmVnaW4oKSxhLm1vdmVUbygwLGYpLGEubGluZVRvKDAsZS1nKSxhLnF1YWRUbygwLGUsTWF0aC5taW4oZC8yLGcpLGUpLGEubGluZVRvKGQtTWF0aC5taW4oZC8yLGcpLGUpLGEucXVhZFRvKGQsZSxkLGUtZyksYS5saW5lVG8oZCxmKSxrPT1teENvbnN0YW50cy5OT05FP2Euc3Ryb2tlKCk6YS5maWxsQW5kU3Ryb2tlKCkpKTooYS5tb3ZlVG8oZiwwKSxhLmxpbmVUbyhnLDApLGEucXVhZFRvKDAsMCwwLE1hdGgubWluKGUvMixnKSksYS5saW5lVG8oMCxlLU1hdGgubWluKGUvMixnKSksYS5xdWFkVG8oMCxlLGcsZSksYS5saW5lVG8oZixlKSxhLmZpbGxBbmRTdHJva2UoKSxmPGQmJihrIT1teENvbnN0YW50cy5OT05FJiZtfHwoYS5wb2ludGVyRXZlbnRzPSExKSxrIT1teENvbnN0YW50cy5OT05FJiZhLnNldEZpbGxDb2xvcihrKSxhLmJlZ2luKCksYS5tb3ZlVG8oZixlKSxhLmxpbmVUbyhkLWcsZSksYS5xdWFkVG8oZCxlLGQsZS1NYXRoLm1pbihlLzIsZykpLGEubGluZVRvKGQsCk1hdGgubWluKGUvMixnKSksYS5xdWFkVG8oZCwwLGQtZywwKSxhLmxpbmVUbyhmLDApLGs9PW14Q29uc3RhbnRzLk5PTkU/YS5zdHJva2UoKTphLmZpbGxBbmRTdHJva2UoKSkpO2wmJnRoaXMucGFpbnREaXZpZGVyKGEsYixjLGQsZSxmLGs9PW14Q29uc3RhbnRzLk5PTkUpfTtteFN3aW1sYW5lLnByb3RvdHlwZS5wYWludERpdmlkZXI9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyl7Z3x8YS5zZXRTaGFkb3coITEpO2EuYmVnaW4oKTt0aGlzLmlzSG9yaXpvbnRhbCgpPyhhLm1vdmVUbygwLGYpLGEubGluZVRvKGQsZikpOihhLm1vdmVUbyhmLDApLGEubGluZVRvKGYsZSkpO2Euc3Ryb2tlKCl9OwpteFN3aW1sYW5lLnByb3RvdHlwZS5wYWludFNlcGFyYXRvcj1mdW5jdGlvbihhLGIsYyxkLGUsZixnKXtnIT1teENvbnN0YW50cy5OT05FJiYoYS5zZXRTdHJva2VDb2xvcihnKSxhLnNldERhc2hlZCghMCksYS5iZWdpbigpLHRoaXMuaXNIb3Jpem9udGFsKCk/KGEubW92ZVRvKGQsZiksYS5saW5lVG8oZCxlKSk6KGEubW92ZVRvKGYsMCksYS5saW5lVG8oZCwwKSksYS5zdHJva2UoKSxhLnNldERhc2hlZCghMSkpfTtteFN3aW1sYW5lLnByb3RvdHlwZS5nZXRJbWFnZUJvdW5kcz1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gdGhpcy5pc0hvcml6b250YWwoKT9uZXcgbXhSZWN0YW5nbGUoYStjLXRoaXMuaW1hZ2VTaXplLGIsdGhpcy5pbWFnZVNpemUsdGhpcy5pbWFnZVNpemUpOm5ldyBteFJlY3RhbmdsZShhLGIsdGhpcy5pbWFnZVNpemUsdGhpcy5pbWFnZVNpemUpfTtmdW5jdGlvbiBteEdyYXBoTGF5b3V0KGEpe3RoaXMuZ3JhcGg9YX0KbXhHcmFwaExheW91dC5wcm90b3R5cGUuZ3JhcGg9bnVsbDtteEdyYXBoTGF5b3V0LnByb3RvdHlwZS51c2VCb3VuZGluZ0JveD0hMDtteEdyYXBoTGF5b3V0LnByb3RvdHlwZS5wYXJlbnQ9bnVsbDtteEdyYXBoTGF5b3V0LnByb3RvdHlwZS5tb3ZlQ2VsbD1mdW5jdGlvbihhLGIsYyl7fTtteEdyYXBoTGF5b3V0LnByb3RvdHlwZS5yZXNpemVDZWxsPWZ1bmN0aW9uKGEsYil7fTtteEdyYXBoTGF5b3V0LnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGEpe307bXhHcmFwaExheW91dC5wcm90b3R5cGUuZ2V0R3JhcGg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmFwaH07bXhHcmFwaExheW91dC5wcm90b3R5cGUuZ2V0Q29uc3RyYWludD1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gdGhpcy5ncmFwaC5nZXRDdXJyZW50Q2VsbFN0eWxlKGIpW2FdfTsKbXhHcmFwaExheW91dC50cmF2ZXJzZT1mdW5jdGlvbihhLGIsYyxkLGUpe2lmKG51bGwhPWMmJm51bGwhPWEmJihiPW51bGwhPWI/YjohMCxlPWV8fG5ldyBteERpY3Rpb25hcnksIWUuZ2V0KGEpJiYoZS5wdXQoYSwhMCksZD1jKGEsZCksbnVsbD09ZHx8ZCkpJiYoZD10aGlzLmdyYXBoLm1vZGVsLmdldEVkZ2VDb3VudChhKSwwPGQpKWZvcih2YXIgZj0wO2Y8ZDtmKyspe3ZhciBnPXRoaXMuZ3JhcGgubW9kZWwuZ2V0RWRnZUF0KGEsZiksaz10aGlzLmdyYXBoLm1vZGVsLmdldFRlcm1pbmFsKGcsITApPT1hO2lmKCFifHxrKWs9dGhpcy5ncmFwaC52aWV3LmdldFZpc2libGVUZXJtaW5hbChnLCFrKSx0aGlzLnRyYXZlcnNlKGssYixjLGcsZSl9fTsKbXhHcmFwaExheW91dC5wcm90b3R5cGUuaXNBbmNlc3Rvcj1mdW5jdGlvbihhLGIsYyl7aWYoIWMpcmV0dXJuIHRoaXMuZ3JhcGgubW9kZWwuZ2V0UGFyZW50KGIpPT1hO2lmKGI9PWEpcmV0dXJuITE7Zm9yKDtudWxsIT1iJiZiIT1hOyliPXRoaXMuZ3JhcGgubW9kZWwuZ2V0UGFyZW50KGIpO3JldHVybiBiPT1hfTtteEdyYXBoTGF5b3V0LnByb3RvdHlwZS5pc1ZlcnRleE1vdmFibGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZ3JhcGguaXNDZWxsTW92YWJsZShhKX07bXhHcmFwaExheW91dC5wcm90b3R5cGUuaXNWZXJ0ZXhJZ25vcmVkPWZ1bmN0aW9uKGEpe3JldHVybiF0aGlzLmdyYXBoLmdldE1vZGVsKCkuaXNWZXJ0ZXgoYSl8fCF0aGlzLmdyYXBoLmlzQ2VsbFZpc2libGUoYSl9OwpteEdyYXBoTGF5b3V0LnByb3RvdHlwZS5pc0VkZ2VJZ25vcmVkPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKTtyZXR1cm4hYi5pc0VkZ2UoYSl8fCF0aGlzLmdyYXBoLmlzQ2VsbFZpc2libGUoYSl8fG51bGw9PWIuZ2V0VGVybWluYWwoYSwhMCl8fG51bGw9PWIuZ2V0VGVybWluYWwoYSwhMSl9O214R3JhcGhMYXlvdXQucHJvdG90eXBlLnNldEVkZ2VTdHlsZUVuYWJsZWQ9ZnVuY3Rpb24oYSxiKXt0aGlzLmdyYXBoLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfTk9FREdFU1RZTEUsYj8iMCI6IjEiLFthXSl9O214R3JhcGhMYXlvdXQucHJvdG90eXBlLnNldE9ydGhvZ29uYWxFZGdlPWZ1bmN0aW9uKGEsYil7dGhpcy5ncmFwaC5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX09SVEhPR09OQUwsYj8iMSI6IjAiLFthXSl9OwpteEdyYXBoTGF5b3V0LnByb3RvdHlwZS5nZXRQYXJlbnRPZmZzZXQ9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IG14UG9pbnQ7aWYobnVsbCE9YSYmYSE9dGhpcy5wYXJlbnQpe3ZhciBjPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKTtpZihjLmlzQW5jZXN0b3IodGhpcy5wYXJlbnQsYSkpZm9yKHZhciBkPWMuZ2V0R2VvbWV0cnkoYSk7YSE9dGhpcy5wYXJlbnQ7KWIueCs9ZC54LGIueSs9ZC55LGE9Yy5nZXRQYXJlbnQoYSksZD1jLmdldEdlb21ldHJ5KGEpfXJldHVybiBifTsKbXhHcmFwaExheW91dC5wcm90b3R5cGUuc2V0RWRnZVBvaW50cz1mdW5jdGlvbihhLGIpe2lmKG51bGwhPWEpe3ZhciBjPXRoaXMuZ3JhcGgubW9kZWwsZD1jLmdldEdlb21ldHJ5KGEpO251bGw9PWQ/KGQ9bmV3IG14R2VvbWV0cnksZC5zZXRSZWxhdGl2ZSghMCkpOmQ9ZC5jbG9uZSgpO2lmKG51bGwhPXRoaXMucGFyZW50JiZudWxsIT1iKWZvcih2YXIgZT1jLmdldFBhcmVudChhKSxlPXRoaXMuZ2V0UGFyZW50T2Zmc2V0KGUpLGY9MDtmPGIubGVuZ3RoO2YrKyliW2ZdLngtPWUueCxiW2ZdLnktPWUueTtkLnBvaW50cz1iO2Muc2V0R2VvbWV0cnkoYSxkKX19OwpteEdyYXBoTGF5b3V0LnByb3RvdHlwZS5zZXRWZXJ0ZXhMb2NhdGlvbj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGU9ZC5nZXRHZW9tZXRyeShhKSxmPW51bGw7aWYobnVsbCE9ZSl7Zj1uZXcgbXhSZWN0YW5nbGUoYixjLGUud2lkdGgsZS5oZWlnaHQpO2lmKHRoaXMudXNlQm91bmRpbmdCb3gpe3ZhciBnPXRoaXMuZ3JhcGguZ2V0VmlldygpLmdldFN0YXRlKGEpO2lmKG51bGwhPWcmJm51bGwhPWcudGV4dCYmbnVsbCE9Zy50ZXh0LmJvdW5kaW5nQm94KXt2YXIgaz10aGlzLmdyYXBoLmdldFZpZXcoKS5zY2FsZSxsPWcudGV4dC5ib3VuZGluZ0JveDtnLnRleHQuYm91bmRpbmdCb3gueDxnLngmJihiKz0oZy54LWwueCkvayxmLndpZHRoPWwud2lkdGgpO2cudGV4dC5ib3VuZGluZ0JveC55PGcueSYmKGMrPShnLnktbC55KS9rLGYuaGVpZ2h0PWwuaGVpZ2h0KX19bnVsbCE9dGhpcy5wYXJlbnQmJihnPWQuZ2V0UGFyZW50KGEpLG51bGwhPWcmJmchPQp0aGlzLnBhcmVudCYmKGc9dGhpcy5nZXRQYXJlbnRPZmZzZXQoZyksYi09Zy54LGMtPWcueSkpO2lmKGUueCE9Ynx8ZS55IT1jKWU9ZS5jbG9uZSgpLGUueD1iLGUueT1jLGQuc2V0R2VvbWV0cnkoYSxlKX1yZXR1cm4gZn07Cm14R3JhcGhMYXlvdXQucHJvdG90eXBlLmdldFZlcnRleEJvdW5kcz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdyYXBoLmdldE1vZGVsKCkuZ2V0R2VvbWV0cnkoYSk7aWYodGhpcy51c2VCb3VuZGluZ0JveCl7dmFyIGM9dGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0U3RhdGUoYSk7aWYobnVsbCE9YyYmbnVsbCE9Yy50ZXh0JiZudWxsIT1jLnRleHQuYm91bmRpbmdCb3gpdmFyIGQ9dGhpcy5ncmFwaC5nZXRWaWV3KCkuc2NhbGUsZT1jLnRleHQuYm91bmRpbmdCb3gsZj1NYXRoLm1heChjLngtZS54LDApL2QsZz1NYXRoLm1heChjLnktZS55LDApL2QsYj1uZXcgbXhSZWN0YW5nbGUoYi54LWYsYi55LWcsYi53aWR0aCtmK01hdGgubWF4KGUueCtlLndpZHRoLShjLngrYy53aWR0aCksMCkvZCxiLmhlaWdodCtnK01hdGgubWF4KGUueStlLmhlaWdodC0oYy55K2MuaGVpZ2h0KSwwKS9kKX1udWxsIT10aGlzLnBhcmVudCYmKGE9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldFBhcmVudChhKSwKYj1iLmNsb25lKCksbnVsbCE9YSYmYSE9dGhpcy5wYXJlbnQmJihhPXRoaXMuZ2V0UGFyZW50T2Zmc2V0KGEpLGIueCs9YS54LGIueSs9YS55KSk7cmV0dXJuIG5ldyBteFJlY3RhbmdsZShiLngsYi55LGIud2lkdGgsYi5oZWlnaHQpfTtteEdyYXBoTGF5b3V0LnByb3RvdHlwZS5hcnJhbmdlR3JvdXBzPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtyZXR1cm4gdGhpcy5ncmFwaC51cGRhdGVHcm91cEJvdW5kcyhhLGIsITAsYyxkLGUsZil9O2Z1bmN0aW9uIFdlaWdodGVkQ2VsbFNvcnRlcihhLGIpe3RoaXMuY2VsbD1hO3RoaXMud2VpZ2h0ZWRWYWx1ZT1ifVdlaWdodGVkQ2VsbFNvcnRlci5wcm90b3R5cGUud2VpZ2h0ZWRWYWx1ZT0wO1dlaWdodGVkQ2VsbFNvcnRlci5wcm90b3R5cGUubnVkZ2U9ITE7V2VpZ2h0ZWRDZWxsU29ydGVyLnByb3RvdHlwZS52aXNpdGVkPSExO1dlaWdodGVkQ2VsbFNvcnRlci5wcm90b3R5cGUucmFua0luZGV4PW51bGw7CldlaWdodGVkQ2VsbFNvcnRlci5wcm90b3R5cGUuY2VsbD1udWxsO1dlaWdodGVkQ2VsbFNvcnRlci5wcm90b3R5cGUuY29tcGFyZT1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsIT1hJiZudWxsIT1iP2Iud2VpZ2h0ZWRWYWx1ZT5hLndlaWdodGVkVmFsdWU/LTE6Yi53ZWlnaHRlZFZhbHVlPGEud2VpZ2h0ZWRWYWx1ZT8xOmIubnVkZ2U/LTE6MTowfTtmdW5jdGlvbiBteFN0YWNrTGF5b3V0KGEsYixjLGQsZSxmKXtteEdyYXBoTGF5b3V0LmNhbGwodGhpcyxhKTt0aGlzLmhvcml6b250YWw9bnVsbCE9Yj9iOiEwO3RoaXMuc3BhY2luZz1udWxsIT1jP2M6MDt0aGlzLngwPW51bGwhPWQ/ZDowO3RoaXMueTA9bnVsbCE9ZT9lOjA7dGhpcy5ib3JkZXI9bnVsbCE9Zj9mOjB9bXhTdGFja0xheW91dC5wcm90b3R5cGU9bmV3IG14R3JhcGhMYXlvdXQ7bXhTdGFja0xheW91dC5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhTdGFja0xheW91dDsKbXhTdGFja0xheW91dC5wcm90b3R5cGUuaG9yaXpvbnRhbD1udWxsO214U3RhY2tMYXlvdXQucHJvdG90eXBlLnNwYWNpbmc9bnVsbDtteFN0YWNrTGF5b3V0LnByb3RvdHlwZS54MD1udWxsO214U3RhY2tMYXlvdXQucHJvdG90eXBlLnkwPW51bGw7bXhTdGFja0xheW91dC5wcm90b3R5cGUuYm9yZGVyPTA7bXhTdGFja0xheW91dC5wcm90b3R5cGUubWFyZ2luVG9wPTA7bXhTdGFja0xheW91dC5wcm90b3R5cGUubWFyZ2luTGVmdD0wO214U3RhY2tMYXlvdXQucHJvdG90eXBlLm1hcmdpblJpZ2h0PTA7bXhTdGFja0xheW91dC5wcm90b3R5cGUubWFyZ2luQm90dG9tPTA7bXhTdGFja0xheW91dC5wcm90b3R5cGUua2VlcEZpcnN0TG9jYXRpb249ITE7bXhTdGFja0xheW91dC5wcm90b3R5cGUuZmlsbD0hMTtteFN0YWNrTGF5b3V0LnByb3RvdHlwZS5yZXNpemVQYXJlbnQ9ITE7bXhTdGFja0xheW91dC5wcm90b3R5cGUucmVzaXplUGFyZW50TWF4PSExOwpteFN0YWNrTGF5b3V0LnByb3RvdHlwZS5yZXNpemVMYXN0PSExO214U3RhY2tMYXlvdXQucHJvdG90eXBlLndyYXA9bnVsbDtteFN0YWNrTGF5b3V0LnByb3RvdHlwZS5ib3JkZXJDb2xsYXBzZT0hMDtteFN0YWNrTGF5b3V0LnByb3RvdHlwZS5hbGxvd0dhcHM9ITE7bXhTdGFja0xheW91dC5wcm90b3R5cGUuZ3JpZFNpemU9MDtteFN0YWNrTGF5b3V0LnByb3RvdHlwZS5pc0hvcml6b250YWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ob3Jpem9udGFsfTsKbXhTdGFja0xheW91dC5wcm90b3R5cGUubW92ZUNlbGw9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxlPWQuZ2V0UGFyZW50KGEpLGY9dGhpcy5pc0hvcml6b250YWwoKTtpZihudWxsIT1hJiZudWxsIT1lKXt2YXIgZz0wLGs9ZC5nZXRDaGlsZENvdW50KGUpO2M9Zj9iOmM7Yj10aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRTdGF0ZShlKTtudWxsIT1iJiYoYy09Zj9iLng6Yi55KTtjLz10aGlzLmdyYXBoLnZpZXcuc2NhbGU7Zm9yKGI9MDtiPGs7YisrKXt2YXIgbD1kLmdldENoaWxkQXQoZSxiKTtpZihsIT1hJiYobD1kLmdldEdlb21ldHJ5KGwpLG51bGwhPWwpKXtsPWY/bC54K2wud2lkdGgvMjpsLnkrbC5oZWlnaHQvMjtpZihnPD1jJiZsPmMpYnJlYWs7Zz1sfX1mPWUuZ2V0SW5kZXgoYSk7Zj1NYXRoLm1heCgwLGItKGI+Zj8xOjApKTtkLmFkZChlLGEsZil9fTsKbXhTdGFja0xheW91dC5wcm90b3R5cGUuZ2V0UGFyZW50U2l6ZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdyYXBoLmdldE1vZGVsKCksYz1iLmdldEdlb21ldHJ5KGEpO251bGwhPXRoaXMuZ3JhcGguY29udGFpbmVyJiYobnVsbD09YyYmYi5pc0xheWVyKGEpfHxhPT10aGlzLmdyYXBoLmdldFZpZXcoKS5jdXJyZW50Um9vdCkmJihjPW5ldyBteFJlY3RhbmdsZSgwLDAsdGhpcy5ncmFwaC5jb250YWluZXIub2Zmc2V0V2lkdGgtMSx0aGlzLmdyYXBoLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQtMSkpO3JldHVybiBjfTsKbXhTdGFja0xheW91dC5wcm90b3R5cGUuZ2V0TGF5b3V0Q2VsbHM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxjPWIuZ2V0Q2hpbGRDb3VudChhKSxkPVtdLGU9MDtlPGM7ZSsrKXt2YXIgZj1iLmdldENoaWxkQXQoYSxlKTshdGhpcy5pc1ZlcnRleElnbm9yZWQoZikmJnRoaXMuaXNWZXJ0ZXhNb3ZhYmxlKGYpJiZkLnB1c2goZil9dGhpcy5hbGxvd0dhcHMmJmQuc29ydChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGEpLGQ9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoYik7cmV0dXJuIGMueT09ZC55PzA6Yy55PmQueT4wPzE6LTF9KSk7cmV0dXJuIGR9OwpteFN0YWNrTGF5b3V0LnByb3RvdHlwZS5zbmFwPWZ1bmN0aW9uKGEpe2lmKG51bGwhPXRoaXMuZ3JpZFNpemUmJjA8dGhpcy5ncmlkU2l6ZSYmKGE9TWF0aC5tYXgoYSx0aGlzLmdyaWRTaXplKSwxPGEvdGhpcy5ncmlkU2l6ZSkpe3ZhciBiPWEldGhpcy5ncmlkU2l6ZTthKz1iPnRoaXMuZ3JpZFNpemUvMj90aGlzLmdyaWRTaXplLWI6LWJ9cmV0dXJuIGF9OwpteFN0YWNrTGF5b3V0LnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe3ZhciBiPXRoaXMuZ2V0UGFyZW50U2l6ZShhKSxjPXRoaXMuaXNIb3Jpem9udGFsKCksZD10aGlzLmdyYXBoLmdldE1vZGVsKCksZT1udWxsO251bGwhPWImJihlPWM/Yi5oZWlnaHQtdGhpcy5tYXJnaW5Ub3AtdGhpcy5tYXJnaW5Cb3R0b206Yi53aWR0aC10aGlzLm1hcmdpbkxlZnQtdGhpcy5tYXJnaW5SaWdodCk7dmFyIGU9ZS0yKnRoaXMuYm9yZGVyLGY9dGhpcy54MCt0aGlzLmJvcmRlcit0aGlzLm1hcmdpbkxlZnQsZz10aGlzLnkwK3RoaXMuYm9yZGVyK3RoaXMubWFyZ2luVG9wO2lmKHRoaXMuZ3JhcGguaXNTd2ltbGFuZShhKSl7dmFyIGs9dGhpcy5ncmFwaC5nZXRDZWxsU3R5bGUoYSksbD1teFV0aWxzLmdldE51bWJlcihrLG14Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRSxteENvbnN0YW50cy5ERUZBVUxUX1NUQVJUU0laRSksaz0xPT1teFV0aWxzLmdldFZhbHVlKGssbXhDb25zdGFudHMuU1RZTEVfSE9SSVpPTlRBTCwKITApO251bGwhPWImJihsPWs/TWF0aC5taW4obCxiLmhlaWdodCk6TWF0aC5taW4obCxiLndpZHRoKSk7Yz09ayYmKGUtPWwpO2s/Zys9bDpmKz1sfWQuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBsPTAsaz1udWxsLG09MCxuPW51bGwscD10aGlzLmdldExheW91dENlbGxzKGEpLHE9MDtxPHAubGVuZ3RoO3ErKyl7dmFyIHI9cFtxXSx0PWQuZ2V0R2VvbWV0cnkocik7aWYobnVsbCE9dCl7dD10LmNsb25lKCk7bnVsbCE9dGhpcy53cmFwJiZudWxsIT1rJiYoYyYmay54K2sud2lkdGgrdC53aWR0aCsyKnRoaXMuc3BhY2luZz50aGlzLndyYXB8fCFjJiZrLnkray5oZWlnaHQrdC5oZWlnaHQrMip0aGlzLnNwYWNpbmc+dGhpcy53cmFwKSYmKGs9bnVsbCxjP2crPWwrdGhpcy5zcGFjaW5nOmYrPWwrdGhpcy5zcGFjaW5nLGw9MCk7dmFyIGw9TWF0aC5tYXgobCxjP3QuaGVpZ2h0OnQud2lkdGgpLHU9MDtpZighdGhpcy5ib3JkZXJDb2xsYXBzZSl2YXIgeD10aGlzLmdyYXBoLmdldENlbGxTdHlsZShyKSwKdT1teFV0aWxzLmdldE51bWJlcih4LG14Q29uc3RhbnRzLlNUWUxFX1NUUk9LRVdJRFRILDEpO2lmKG51bGwhPWspe3ZhciB5PW0rdGhpcy5zcGFjaW5nK01hdGguZmxvb3IodS8yKTtjP3QueD10aGlzLnNuYXAoKHRoaXMuYWxsb3dHYXBzP01hdGgubWF4KHksdC54KTp5KS10aGlzLm1hcmdpbkxlZnQpK3RoaXMubWFyZ2luTGVmdDp0Lnk9dGhpcy5zbmFwKCh0aGlzLmFsbG93R2Fwcz9NYXRoLm1heCh5LHQueSk6eSktdGhpcy5tYXJnaW5Ub3ApK3RoaXMubWFyZ2luVG9wfWVsc2UgdGhpcy5rZWVwRmlyc3RMb2NhdGlvbnx8KGM/dC54PXRoaXMuYWxsb3dHYXBzJiZ0Lng+Zj9NYXRoLm1heCh0aGlzLnNuYXAodC54LXRoaXMubWFyZ2luTGVmdCkrdGhpcy5tYXJnaW5MZWZ0LGYpOmY6dC55PXRoaXMuYWxsb3dHYXBzJiZ0Lnk+Zz9NYXRoLm1heCh0aGlzLnNuYXAodC55LXRoaXMubWFyZ2luVG9wKSt0aGlzLm1hcmdpblRvcCxnKTpnKTtjP3QueT1nOnQueD1mO3RoaXMuZmlsbCYmbnVsbCE9CmUmJihjP3QuaGVpZ2h0PWU6dC53aWR0aD1lKTtjP3Qud2lkdGg9dGhpcy5zbmFwKHQud2lkdGgpOnQuaGVpZ2h0PXRoaXMuc25hcCh0LmhlaWdodCk7dGhpcy5zZXRDaGlsZEdlb21ldHJ5KHIsdCk7bj1yO2s9dDttPWM/ay54K2sud2lkdGgrTWF0aC5mbG9vcih1LzIpOmsueStrLmhlaWdodCtNYXRoLmZsb29yKHUvMil9fXRoaXMucmVzaXplUGFyZW50JiZudWxsIT1iJiZudWxsIT1rJiYhdGhpcy5ncmFwaC5pc0NlbGxDb2xsYXBzZWQoYSk/dGhpcy51cGRhdGVQYXJlbnRHZW9tZXRyeShhLGIsayk6dGhpcy5yZXNpemVMYXN0JiZudWxsIT1iJiZudWxsIT1rJiZudWxsIT1uJiYoYz9rLndpZHRoPWIud2lkdGgtay54LXRoaXMuc3BhY2luZy10aGlzLm1hcmdpblJpZ2h0LXRoaXMubWFyZ2luTGVmdDprLmhlaWdodD1iLmhlaWdodC1rLnktdGhpcy5zcGFjaW5nLXRoaXMubWFyZ2luQm90dG9tLHRoaXMuc2V0Q2hpbGRHZW9tZXRyeShuLGspKX1maW5hbGx5e2QuZW5kVXBkYXRlKCl9fX07Cm14U3RhY2tMYXlvdXQucHJvdG90eXBlLnNldENoaWxkR2VvbWV0cnk9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShhKTtudWxsIT1jJiZiLng9PWMueCYmYi55PT1jLnkmJmIud2lkdGg9PWMud2lkdGgmJmIuaGVpZ2h0PT1jLmhlaWdodHx8dGhpcy5ncmFwaC5nZXRNb2RlbCgpLnNldEdlb21ldHJ5KGEsYil9OwpteFN0YWNrTGF5b3V0LnByb3RvdHlwZS51cGRhdGVQYXJlbnRHZW9tZXRyeT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5pc0hvcml6b250YWwoKSxlPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxmPWIuY2xvbmUoKTtkPyhjPWMueCtjLndpZHRoK3RoaXMubWFyZ2luUmlnaHQrdGhpcy5ib3JkZXIsZi53aWR0aD10aGlzLnJlc2l6ZVBhcmVudE1heD9NYXRoLm1heChmLndpZHRoLGMpOmMpOihjPWMueStjLmhlaWdodCt0aGlzLm1hcmdpbkJvdHRvbSt0aGlzLmJvcmRlcixmLmhlaWdodD10aGlzLnJlc2l6ZVBhcmVudE1heD9NYXRoLm1heChmLmhlaWdodCxjKTpjKTtiLng9PWYueCYmYi55PT1mLnkmJmIud2lkdGg9PWYud2lkdGgmJmIuaGVpZ2h0PT1mLmhlaWdodHx8ZS5zZXRHZW9tZXRyeShhLGYpfTsKZnVuY3Rpb24gbXhQYXJ0aXRpb25MYXlvdXQoYSxiLGMsZCl7bXhHcmFwaExheW91dC5jYWxsKHRoaXMsYSk7dGhpcy5ob3Jpem9udGFsPW51bGwhPWI/YjohMDt0aGlzLnNwYWNpbmc9Y3x8MDt0aGlzLmJvcmRlcj1kfHwwfW14UGFydGl0aW9uTGF5b3V0LnByb3RvdHlwZT1uZXcgbXhHcmFwaExheW91dDtteFBhcnRpdGlvbkxheW91dC5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhQYXJ0aXRpb25MYXlvdXQ7bXhQYXJ0aXRpb25MYXlvdXQucHJvdG90eXBlLmhvcml6b250YWw9bnVsbDtteFBhcnRpdGlvbkxheW91dC5wcm90b3R5cGUuc3BhY2luZz1udWxsO214UGFydGl0aW9uTGF5b3V0LnByb3RvdHlwZS5ib3JkZXI9bnVsbDtteFBhcnRpdGlvbkxheW91dC5wcm90b3R5cGUucmVzaXplVmVydGljZXM9ITA7bXhQYXJ0aXRpb25MYXlvdXQucHJvdG90eXBlLmlzSG9yaXpvbnRhbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhvcml6b250YWx9OwpteFBhcnRpdGlvbkxheW91dC5wcm90b3R5cGUubW92ZUNlbGw9ZnVuY3Rpb24oYSxiLGMpe2M9dGhpcy5ncmFwaC5nZXRNb2RlbCgpO3ZhciBkPWMuZ2V0UGFyZW50KGEpO2lmKG51bGwhPWEmJm51bGwhPWQpe3ZhciBlLGY9MCxnPWMuZ2V0Q2hpbGRDb3VudChkKTtmb3IoZT0wO2U8ZztlKyspe3ZhciBrPWMuZ2V0Q2hpbGRBdChkLGUpLGs9dGhpcy5nZXRWZXJ0ZXhCb3VuZHMoayk7aWYobnVsbCE9ayl7az1rLngray53aWR0aC8yO2lmKGY8YiYmaz5iKWJyZWFrO2Y9a319Yj1kLmdldEluZGV4KGEpO2I9TWF0aC5tYXgoMCxlLShlPmI/MTowKSk7Yy5hZGQoZCxhLGIpfX07Cm14UGFydGl0aW9uTGF5b3V0LnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuaXNIb3Jpem9udGFsKCksYz10aGlzLmdyYXBoLmdldE1vZGVsKCksZD1jLmdldEdlb21ldHJ5KGEpO251bGwhPXRoaXMuZ3JhcGguY29udGFpbmVyJiYobnVsbD09ZCYmYy5pc0xheWVyKGEpfHxhPT10aGlzLmdyYXBoLmdldFZpZXcoKS5jdXJyZW50Um9vdCkmJihkPW5ldyBteFJlY3RhbmdsZSgwLDAsdGhpcy5ncmFwaC5jb250YWluZXIub2Zmc2V0V2lkdGgtMSx0aGlzLmdyYXBoLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQtMSkpO2lmKG51bGwhPWQpe2Zvcih2YXIgZT1bXSxmPWMuZ2V0Q2hpbGRDb3VudChhKSxnPTA7ZzxmO2crKyl7dmFyIGs9Yy5nZXRDaGlsZEF0KGEsZyk7IXRoaXMuaXNWZXJ0ZXhJZ25vcmVkKGspJiZ0aGlzLmlzVmVydGV4TW92YWJsZShrKSYmZS5wdXNoKGspfWY9ZS5sZW5ndGg7aWYoMDxmKXt2YXIgbD10aGlzLmJvcmRlcixtPXRoaXMuYm9yZGVyLG49Yj8KZC5oZWlnaHQ6ZC53aWR0aCxuPW4tMip0aGlzLmJvcmRlcjthPXRoaXMuZ3JhcGguaXNTd2ltbGFuZShhKT90aGlzLmdyYXBoLmdldFN0YXJ0U2l6ZShhKTpuZXcgbXhSZWN0YW5nbGU7bi09Yj9hLmhlaWdodDphLndpZHRoO2wrPWEud2lkdGg7bSs9YS5oZWlnaHQ7YT10aGlzLmJvcmRlcisoZi0xKSp0aGlzLnNwYWNpbmc7ZD1iPyhkLndpZHRoLWwtYSkvZjooZC5oZWlnaHQtbS1hKS9mO2lmKDA8ZCl7Yy5iZWdpblVwZGF0ZSgpO3RyeXtmb3IoZz0wO2c8ZjtnKyspe3ZhciBrPWVbZ10scD1jLmdldEdlb21ldHJ5KGspO251bGwhPXAmJihwPXAuY2xvbmUoKSxwLng9bCxwLnk9bSxiPyh0aGlzLnJlc2l6ZVZlcnRpY2VzJiYocC53aWR0aD1kLHAuaGVpZ2h0PW4pLGwrPWQrdGhpcy5zcGFjaW5nKToodGhpcy5yZXNpemVWZXJ0aWNlcyYmKHAuaGVpZ2h0PWQscC53aWR0aD1uKSxtKz1kK3RoaXMuc3BhY2luZyksYy5zZXRHZW9tZXRyeShrLHApKX19ZmluYWxseXtjLmVuZFVwZGF0ZSgpfX19fX07CmZ1bmN0aW9uIG14Q29tcGFjdFRyZWVMYXlvdXQoYSxiLGMpe214R3JhcGhMYXlvdXQuY2FsbCh0aGlzLGEpO3RoaXMuaG9yaXpvbnRhbD1udWxsIT1iP2I6ITA7dGhpcy5pbnZlcnQ9bnVsbCE9Yz9jOiExfW14Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlPW5ldyBteEdyYXBoTGF5b3V0O214Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14Q29tcGFjdFRyZWVMYXlvdXQ7bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUuaG9yaXpvbnRhbD1udWxsO214Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLmludmVydD1udWxsO214Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLnJlc2l6ZVBhcmVudD0hMDtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5tYWludGFpblBhcmVudExvY2F0aW9uPSExO214Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLmdyb3VwUGFkZGluZz0xMDsKbXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUuZ3JvdXBQYWRkaW5nVG9wPTA7bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUuZ3JvdXBQYWRkaW5nUmlnaHQ9MDtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5ncm91cFBhZGRpbmdCb3R0b209MDtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5ncm91cFBhZGRpbmdMZWZ0PTA7bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUucGFyZW50c0NoYW5nZWQ9bnVsbDtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5tb3ZlVHJlZT0hMTtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS52aXNpdGVkPW51bGw7bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUubGV2ZWxEaXN0YW5jZT0xMDtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5ub2RlRGlzdGFuY2U9MjA7bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUucmVzZXRFZGdlcz0hMDsKbXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUucHJlZkhvekVkZ2VTZXA9NTtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5wcmVmVmVydEVkZ2VPZmY9NDtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5taW5FZGdlSmV0dHk9ODtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5jaGFubmVsQnVmZmVyPTQ7bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUuZWRnZVJvdXRpbmc9ITA7bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUuc29ydEVkZ2VzPSExO214Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLmFsaWduUmFua3M9ITE7bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUubWF4UmFua0hlaWdodD1udWxsO214Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLnJvb3Q9bnVsbDtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5ub2RlPW51bGw7Cm14Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLmlzVmVydGV4SWdub3JlZD1mdW5jdGlvbihhKXtyZXR1cm4gbXhHcmFwaExheW91dC5wcm90b3R5cGUuaXNWZXJ0ZXhJZ25vcmVkLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8MD09dGhpcy5ncmFwaC5nZXRDb25uZWN0aW9ucyhhKS5sZW5ndGh9O214Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLmlzSG9yaXpvbnRhbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhvcml6b250YWx9OwpteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGEsYil7dGhpcy5wYXJlbnQ9YTt2YXIgYz10aGlzLmdyYXBoLmdldE1vZGVsKCk7aWYobnVsbD09YilpZigwPHRoaXMuZ3JhcGguZ2V0RWRnZXMoYSxjLmdldFBhcmVudChhKSx0aGlzLmludmVydCwhdGhpcy5pbnZlcnQsITEpLmxlbmd0aCl0aGlzLnJvb3Q9YTtlbHNle3ZhciBkPXRoaXMuZ3JhcGguZmluZFRyZWVSb290cyhhLCEwLHRoaXMuaW52ZXJ0KTtpZigwPGQubGVuZ3RoKWZvcih2YXIgZT0wO2U8ZC5sZW5ndGg7ZSsrKWlmKCF0aGlzLmlzVmVydGV4SWdub3JlZChkW2VdKSYmMDx0aGlzLmdyYXBoLmdldEVkZ2VzKGRbZV0sbnVsbCx0aGlzLmludmVydCwhdGhpcy5pbnZlcnQsITEpLmxlbmd0aCl7dGhpcy5yb290PWRbZV07YnJlYWt9fWVsc2UgdGhpcy5yb290PWI7aWYobnVsbCE9dGhpcy5yb290KXt0aGlzLnBhcmVudHNDaGFuZ2VkPXRoaXMucmVzaXplUGFyZW50P3t9Om51bGw7dGhpcy5wYXJlbnRZPQp0aGlzLnBhcmVudFg9bnVsbDtpZihhIT10aGlzLnJvb3QmJm51bGwhPWMuaXNWZXJ0ZXgoYSkmJnRoaXMubWFpbnRhaW5QYXJlbnRMb2NhdGlvbil7dmFyIGY9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoYSk7bnVsbCE9ZiYmKHRoaXMucGFyZW50WD1mLngsdGhpcy5wYXJlbnRZPWYueSl9Yy5iZWdpblVwZGF0ZSgpO3RyeXtpZih0aGlzLnZpc2l0ZWQ9e30sdGhpcy5ub2RlPXRoaXMuZGZzKHRoaXMucm9vdCxhKSx0aGlzLmFsaWduUmFua3MmJih0aGlzLm1heFJhbmtIZWlnaHQ9W10sdGhpcy5maW5kUmFua0hlaWdodHModGhpcy5ub2RlLDApLHRoaXMuc2V0Q2VsbEhlaWdodHModGhpcy5ub2RlLDApKSxudWxsIT10aGlzLm5vZGUpe3RoaXMubGF5b3V0KHRoaXMubm9kZSk7dmFyIGc9dGhpcy5ncmFwaC5ncmlkU2l6ZSxkPWc7aWYoIXRoaXMubW92ZVRyZWUpe3ZhciBrPXRoaXMuZ2V0VmVydGV4Qm91bmRzKHRoaXMucm9vdCk7bnVsbCE9ayYmKGc9ay54LGQ9ay55KX1rPW51bGw7Cms9dGhpcy5pc0hvcml6b250YWwoKT90aGlzLmhvcml6b250YWxMYXlvdXQodGhpcy5ub2RlLGcsZCk6dGhpcy52ZXJ0aWNhbExheW91dCh0aGlzLm5vZGUsbnVsbCxnLGQpO2lmKG51bGwhPWspe3ZhciBsPWU9MDswPmsueCYmKGU9TWF0aC5hYnMoZy1rLngpKTswPmsueSYmKGw9TWF0aC5hYnMoZC1rLnkpKTswPT1lJiYwPT1sfHx0aGlzLm1vdmVOb2RlKHRoaXMubm9kZSxlLGwpO3RoaXMucmVzaXplUGFyZW50JiZ0aGlzLmFkanVzdFBhcmVudHMoKTt0aGlzLmVkZ2VSb3V0aW5nJiZ0aGlzLmxvY2FsRWRnZVByb2Nlc3NpbmcodGhpcy5ub2RlKX1udWxsIT10aGlzLnBhcmVudFgmJm51bGwhPXRoaXMucGFyZW50WSYmKGY9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoYSksbnVsbCE9ZiYmKGY9Zi5jbG9uZSgpLGYueD10aGlzLnBhcmVudFgsZi55PXRoaXMucGFyZW50WSxjLnNldEdlb21ldHJ5KGEsZikpKX19ZmluYWxseXtjLmVuZFVwZGF0ZSgpfX19OwpteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5tb3ZlTm9kZT1mdW5jdGlvbihhLGIsYyl7YS54Kz1iO2EueSs9Yzt0aGlzLmFwcGx5KGEpO2ZvcihhPWEuY2hpbGQ7bnVsbCE9YTspdGhpcy5tb3ZlTm9kZShhLGIsYyksYT1hLm5leHR9OwpteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5zb3J0T3V0Z29pbmdFZGdlcz1mdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBteERpY3Rpb25hcnk7Yi5zb3J0KGZ1bmN0aW9uKGIsZSl7dmFyIGQ9Yi5nZXRUZXJtaW5hbChiLmdldFRlcm1pbmFsKCExKT09YSksZz1jLmdldChkKTtudWxsPT1nJiYoZz1teENlbGxQYXRoLmNyZWF0ZShkKS5zcGxpdChteENlbGxQYXRoLlBBVEhfU0VQQVJBVE9SKSxjLnB1dChkLGcpKTt2YXIgZD1lLmdldFRlcm1pbmFsKGUuZ2V0VGVybWluYWwoITEpPT1hKSxrPWMuZ2V0KGQpO251bGw9PWsmJihrPW14Q2VsbFBhdGguY3JlYXRlKGQpLnNwbGl0KG14Q2VsbFBhdGguUEFUSF9TRVBBUkFUT1IpLGMucHV0KGQsaykpO3JldHVybiBteENlbGxQYXRoLmNvbXBhcmUoZyxrKX0pfTsKbXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUuZmluZFJhbmtIZWlnaHRzPWZ1bmN0aW9uKGEsYil7aWYobnVsbD09dGhpcy5tYXhSYW5rSGVpZ2h0W2JdfHx0aGlzLm1heFJhbmtIZWlnaHRbYl08YS5oZWlnaHQpdGhpcy5tYXhSYW5rSGVpZ2h0W2JdPWEuaGVpZ2h0O2Zvcih2YXIgYz1hLmNoaWxkO251bGwhPWM7KXRoaXMuZmluZFJhbmtIZWlnaHRzKGMsYisxKSxjPWMubmV4dH07bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUuc2V0Q2VsbEhlaWdodHM9ZnVuY3Rpb24oYSxiKXtudWxsIT10aGlzLm1heFJhbmtIZWlnaHRbYl0mJnRoaXMubWF4UmFua0hlaWdodFtiXT5hLmhlaWdodCYmKGEuaGVpZ2h0PXRoaXMubWF4UmFua0hlaWdodFtiXSk7Zm9yKHZhciBjPWEuY2hpbGQ7bnVsbCE9YzspdGhpcy5zZXRDZWxsSGVpZ2h0cyhjLGIrMSksYz1jLm5leHR9OwpteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5kZnM9ZnVuY3Rpb24oYSxiKXt2YXIgYz1teENlbGxQYXRoLmNyZWF0ZShhKSxkPW51bGw7aWYobnVsbCE9YSYmbnVsbD09dGhpcy52aXNpdGVkW2NdJiYhdGhpcy5pc1ZlcnRleElnbm9yZWQoYSkpe3RoaXMudmlzaXRlZFtjXT1hO3ZhciBkPXRoaXMuY3JlYXRlTm9kZShhKSxjPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxlPW51bGwsZj10aGlzLmdyYXBoLmdldEVkZ2VzKGEsYix0aGlzLmludmVydCwhdGhpcy5pbnZlcnQsITEsITApLGc9dGhpcy5ncmFwaC5nZXRWaWV3KCk7dGhpcy5zb3J0RWRnZXMmJnRoaXMuc29ydE91dGdvaW5nRWRnZXMoYSxmKTtmb3IodmFyIGs9MDtrPGYubGVuZ3RoO2srKyl7dmFyIGw9ZltrXTtpZighdGhpcy5pc0VkZ2VJZ25vcmVkKGwpKXt0aGlzLnJlc2V0RWRnZXMmJnRoaXMuc2V0RWRnZVBvaW50cyhsLG51bGwpO3RoaXMuZWRnZVJvdXRpbmcmJih0aGlzLnNldEVkZ2VTdHlsZUVuYWJsZWQobCwhMSksCnRoaXMuc2V0RWRnZVBvaW50cyhsLG51bGwpKTt2YXIgbT1nLmdldFN0YXRlKGwpLGw9bnVsbCE9bT9tLmdldFZpc2libGVUZXJtaW5hbCh0aGlzLmludmVydCk6Zy5nZXRWaXNpYmxlVGVybWluYWwobCx0aGlzLmludmVydCksbT10aGlzLmRmcyhsLGIpO251bGwhPW0mJm51bGwhPWMuZ2V0R2VvbWV0cnkobCkmJihudWxsPT1lP2QuY2hpbGQ9bTplLm5leHQ9bSxlPW0pfX19cmV0dXJuIGR9O214Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLmxheW91dD1mdW5jdGlvbihhKXtpZihudWxsIT1hKXtmb3IodmFyIGI9YS5jaGlsZDtudWxsIT1iOyl0aGlzLmxheW91dChiKSxiPWIubmV4dDtudWxsIT1hLmNoaWxkP3RoaXMuYXR0YWNoUGFyZW50KGEsdGhpcy5qb2luKGEpKTp0aGlzLmxheW91dExlYWYoYSl9fTsKbXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUuaG9yaXpvbnRhbExheW91dD1mdW5jdGlvbihhLGIsYyxkKXthLngrPWIrYS5vZmZzZXRYO2EueSs9YythLm9mZnNldFk7ZD10aGlzLmFwcGx5KGEsZCk7Yj1hLmNoaWxkO2lmKG51bGwhPWIpe2Q9dGhpcy5ob3Jpem9udGFsTGF5b3V0KGIsYS54LGEueSxkKTtjPWEueStiLm9mZnNldFk7Zm9yKHZhciBlPWIubmV4dDtudWxsIT1lOylkPXRoaXMuaG9yaXpvbnRhbExheW91dChlLGEueCtiLm9mZnNldFgsYyxkKSxjKz1lLm9mZnNldFksZT1lLm5leHR9cmV0dXJuIGR9OwpteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS52ZXJ0aWNhbExheW91dD1mdW5jdGlvbihhLGIsYyxkLGUpe2EueCs9YythLm9mZnNldFk7YS55Kz1kK2Eub2Zmc2V0WDtlPXRoaXMuYXBwbHkoYSxlKTtiPWEuY2hpbGQ7aWYobnVsbCE9Yilmb3IoZT10aGlzLnZlcnRpY2FsTGF5b3V0KGIsYSxhLngsYS55LGUpLGM9YS54K2Iub2Zmc2V0WSxkPWIubmV4dDtudWxsIT1kOyllPXRoaXMudmVydGljYWxMYXlvdXQoZCxhLGMsYS55K2Iub2Zmc2V0WCxlKSxjKz1kLm9mZnNldFksZD1kLm5leHQ7cmV0dXJuIGV9OwpteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5hdHRhY2hQYXJlbnQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLm5vZGVEaXN0YW5jZSt0aGlzLmxldmVsRGlzdGFuY2UsZD0oYi1hLndpZHRoKS8yLXRoaXMubm9kZURpc3RhbmNlLGU9ZCthLndpZHRoKzIqdGhpcy5ub2RlRGlzdGFuY2UtYjthLmNoaWxkLm9mZnNldFg9YythLmhlaWdodDthLmNoaWxkLm9mZnNldFk9ZTthLmNvbnRvdXIudXBwZXJIZWFkPXRoaXMuY3JlYXRlTGluZShhLmhlaWdodCwwLHRoaXMuY3JlYXRlTGluZShjLGUsYS5jb250b3VyLnVwcGVySGVhZCkpO2EuY29udG91ci5sb3dlckhlYWQ9dGhpcy5jcmVhdGVMaW5lKGEuaGVpZ2h0LDAsdGhpcy5jcmVhdGVMaW5lKGMsZCxhLmNvbnRvdXIubG93ZXJIZWFkKSl9OwpteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5sYXlvdXRMZWFmPWZ1bmN0aW9uKGEpe3ZhciBiPTIqdGhpcy5ub2RlRGlzdGFuY2U7YS5jb250b3VyLnVwcGVyVGFpbD10aGlzLmNyZWF0ZUxpbmUoYS5oZWlnaHQrYiwwKTthLmNvbnRvdXIudXBwZXJIZWFkPWEuY29udG91ci51cHBlclRhaWw7YS5jb250b3VyLmxvd2VyVGFpbD10aGlzLmNyZWF0ZUxpbmUoMCwtYS53aWR0aC1iKTthLmNvbnRvdXIubG93ZXJIZWFkPXRoaXMuY3JlYXRlTGluZShhLmhlaWdodCtiLDAsYS5jb250b3VyLmxvd2VyVGFpbCl9OwpteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5qb2luPWZ1bmN0aW9uKGEpe3ZhciBiPTIqdGhpcy5ub2RlRGlzdGFuY2UsYz1hLmNoaWxkO2EuY29udG91cj1jLmNvbnRvdXI7Zm9yKHZhciBkPWMud2lkdGgrYixlPWQsYz1jLm5leHQ7bnVsbCE9Yzspe3ZhciBmPXRoaXMubWVyZ2UoYS5jb250b3VyLGMuY29udG91cik7Yy5vZmZzZXRZPWYrZDtjLm9mZnNldFg9MDtkPWMud2lkdGgrYjtlKz1mK2Q7Yz1jLm5leHR9cmV0dXJuIGV9OwpteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5tZXJnZT1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wLGQ9MCxlPTAsZj1hLmxvd2VySGVhZCxnPWIudXBwZXJIZWFkO251bGwhPWcmJm51bGwhPWY7KXt2YXIgaz10aGlzLm9mZnNldChjLGQsZy5keCxnLmR5LGYuZHgsZi5keSksZD1kK2ssZT1lK2s7YytnLmR4PD1mLmR4PyhjKz1nLmR4LGQrPWcuZHksZz1nLm5leHQpOihjLT1mLmR4LGQtPWYuZHksZj1mLm5leHQpfW51bGwhPWc/KGM9dGhpcy5icmlkZ2UoYS51cHBlclRhaWwsMCwwLGcsYyxkKSxhLnVwcGVyVGFpbD1udWxsIT1jLm5leHQ/Yi51cHBlclRhaWw6YyxhLmxvd2VyVGFpbD1iLmxvd2VyVGFpbCk6KGM9dGhpcy5icmlkZ2UoYi5sb3dlclRhaWwsYyxkLGYsMCwwKSxudWxsPT1jLm5leHQmJihhLmxvd2VyVGFpbD1jKSk7YS5sb3dlckhlYWQ9Yi5sb3dlckhlYWQ7cmV0dXJuIGV9OwpteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5vZmZzZXQ9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2lmKGU8PWF8fDA+PWErYylyZXR1cm4gMDthPTA8ZSpkLWMqZj8wPmE/YSpkL2MtYjowPGE/YSpmL2UtYjotYjplPGErYz9mLShiKyhlLWEpKmQvYyk6ZT5hK2M/KGMrYSkqZi9lLShiK2QpOmYtKGIrZCk7cmV0dXJuIDA8YT9hOjB9O214Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLmJyaWRnZT1mdW5jdGlvbihhLGIsYyxkLGUsZil7Yj1lK2QuZHgtYjswPT1kLmR4P2U9ZC5keTooZT1iKmQuZHksZS89ZC5keCk7Yj10aGlzLmNyZWF0ZUxpbmUoYixlLGQubmV4dCk7YS5uZXh0PXRoaXMuY3JlYXRlTGluZSgwLGYrZC5keS1lLWMsYik7cmV0dXJuIGJ9OwpteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5jcmVhdGVOb2RlPWZ1bmN0aW9uKGEpe3ZhciBiPXt9O2IuY2VsbD1hO2IueD0wO2IueT0wO2Iud2lkdGg9MDtiLmhlaWdodD0wO2E9dGhpcy5nZXRWZXJ0ZXhCb3VuZHMoYSk7bnVsbCE9YSYmKHRoaXMuaXNIb3Jpem9udGFsKCk/KGIud2lkdGg9YS5oZWlnaHQsYi5oZWlnaHQ9YS53aWR0aCk6KGIud2lkdGg9YS53aWR0aCxiLmhlaWdodD1hLmhlaWdodCkpO2Iub2Zmc2V0WD0wO2Iub2Zmc2V0WT0wO2IuY29udG91cj17fTtyZXR1cm4gYn07Cm14Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGQ9YS5jZWxsLGU9Yy5nZXRHZW9tZXRyeShkKTtudWxsIT1kJiZudWxsIT1lJiYodGhpcy5pc1ZlcnRleE1vdmFibGUoZCkmJihlPXRoaXMuc2V0VmVydGV4TG9jYXRpb24oZCxhLngsYS55KSx0aGlzLnJlc2l6ZVBhcmVudCYmKGM9Yy5nZXRQYXJlbnQoZCksZD1teENlbGxQYXRoLmNyZWF0ZShjKSxudWxsPT10aGlzLnBhcmVudHNDaGFuZ2VkW2RdJiYodGhpcy5wYXJlbnRzQ2hhbmdlZFtkXT1jKSkpLGI9bnVsbD09Yj9uZXcgbXhSZWN0YW5nbGUoZS54LGUueSxlLndpZHRoLGUuaGVpZ2h0KTpuZXcgbXhSZWN0YW5nbGUoTWF0aC5taW4oYi54LGUueCksTWF0aC5taW4oYi55LGUueSksTWF0aC5tYXgoYi54K2Iud2lkdGgsZS54K2Uud2lkdGgpLE1hdGgubWF4KGIueStiLmhlaWdodCxlLnkrZS5oZWlnaHQpKSk7cmV0dXJuIGJ9OwpteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5jcmVhdGVMaW5lPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD17fTtkLmR4PWE7ZC5keT1iO2QubmV4dD1jO3JldHVybiBkfTtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5hZGp1c3RQYXJlbnRzPWZ1bmN0aW9uKCl7dmFyIGE9W10sYjtmb3IoYiBpbiB0aGlzLnBhcmVudHNDaGFuZ2VkKWEucHVzaCh0aGlzLnBhcmVudHNDaGFuZ2VkW2JdKTt0aGlzLmFycmFuZ2VHcm91cHMobXhVdGlscy5zb3J0Q2VsbHMoYSwhMCksdGhpcy5ncm91cFBhZGRpbmcsdGhpcy5ncm91cFBhZGRpbmdUb3AsdGhpcy5ncm91cFBhZGRpbmdSaWdodCx0aGlzLmdyb3VwUGFkZGluZ0JvdHRvbSx0aGlzLmdyb3VwUGFkZGluZ0xlZnQpfTsKbXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUubG9jYWxFZGdlUHJvY2Vzc2luZz1mdW5jdGlvbihhKXt0aGlzLnByb2Nlc3NOb2RlT3V0Z29pbmcoYSk7Zm9yKGE9YS5jaGlsZDtudWxsIT1hOyl0aGlzLmxvY2FsRWRnZVByb2Nlc3NpbmcoYSksYT1hLm5leHR9OwpteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5wcm9jZXNzTm9kZU91dGdvaW5nPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1hLmNoaWxkLGM9YS5jZWxsLGQ9MCxlPVtdO251bGwhPWI7KXtkKys7dmFyIGY9Yi54O3RoaXMuaG9yaXpvbnRhbCYmKGY9Yi55KTtlLnB1c2gobmV3IFdlaWdodGVkQ2VsbFNvcnRlcihiLGYpKTtiPWIubmV4dH1lLnNvcnQoV2VpZ2h0ZWRDZWxsU29ydGVyLnByb3RvdHlwZS5jb21wYXJlKTt2YXIgZj1hLndpZHRoLGc9KGQrMSkqdGhpcy5wcmVmSG96RWRnZVNlcDtmPmcrMip0aGlzLnByZWZIb3pFZGdlU2VwJiYoZi09Mip0aGlzLnByZWZIb3pFZGdlU2VwKTthPWYvZDtiPWEvMjtmPmcrMip0aGlzLnByZWZIb3pFZGdlU2VwJiYoYis9dGhpcy5wcmVmSG96RWRnZVNlcCk7Zm9yKHZhciBmPXRoaXMubWluRWRnZUpldHR5LXRoaXMucHJlZlZlcnRFZGdlT2ZmLGc9dGhpcy5nZXRWZXJ0ZXhCb3VuZHMoYyksaz0wO2s8ZS5sZW5ndGg7aysrKXtmb3IodmFyIGw9CmVba10uY2VsbC5jZWxsLG09dGhpcy5nZXRWZXJ0ZXhCb3VuZHMobCksbD10aGlzLmdyYXBoLmdldEVkZ2VzQmV0d2VlbihjLGwsITEpLG49W10scCxxLHI9MDtyPGwubGVuZ3RoO3IrKyl0aGlzLmhvcml6b250YWw/KHA9Zy54K2cud2lkdGgscT1nLnkrYixuLnB1c2gobmV3IG14UG9pbnQocCxxKSkscD1nLngrZy53aWR0aCtmLG4ucHVzaChuZXcgbXhQb2ludChwLHEpKSxxPW0ueSttLmhlaWdodC8yKToocD1nLngrYixxPWcueStnLmhlaWdodCxuLnB1c2gobmV3IG14UG9pbnQocCxxKSkscT1nLnkrZy5oZWlnaHQrZixuLnB1c2gobmV3IG14UG9pbnQocCxxKSkscD1tLngrbS53aWR0aC8yKSxuLnB1c2gobmV3IG14UG9pbnQocCxxKSksdGhpcy5zZXRFZGdlUG9pbnRzKGxbcl0sbik7azxkLzI/Zis9dGhpcy5wcmVmVmVydEVkZ2VPZmY6az5kLzImJihmLT10aGlzLnByZWZWZXJ0RWRnZU9mZik7Yis9YX19OwpmdW5jdGlvbiBteFJhZGlhbFRyZWVMYXlvdXQoYSl7bXhDb21wYWN0VHJlZUxheW91dC5jYWxsKHRoaXMsYSwhMSl9bXhVdGlscy5leHRlbmQobXhSYWRpYWxUcmVlTGF5b3V0LG14Q29tcGFjdFRyZWVMYXlvdXQpO214UmFkaWFsVHJlZUxheW91dC5wcm90b3R5cGUuYW5nbGVPZmZzZXQ9LjU7bXhSYWRpYWxUcmVlTGF5b3V0LnByb3RvdHlwZS5yb290eD0wO214UmFkaWFsVHJlZUxheW91dC5wcm90b3R5cGUucm9vdHk9MDtteFJhZGlhbFRyZWVMYXlvdXQucHJvdG90eXBlLmxldmVsRGlzdGFuY2U9MTIwO214UmFkaWFsVHJlZUxheW91dC5wcm90b3R5cGUubm9kZURpc3RhbmNlPTEwO214UmFkaWFsVHJlZUxheW91dC5wcm90b3R5cGUuYXV0b1JhZGl1cz0hMTtteFJhZGlhbFRyZWVMYXlvdXQucHJvdG90eXBlLnNvcnRFZGdlcz0hMTtteFJhZGlhbFRyZWVMYXlvdXQucHJvdG90eXBlLnJvd01pblg9W107bXhSYWRpYWxUcmVlTGF5b3V0LnByb3RvdHlwZS5yb3dNYXhYPVtdOwpteFJhZGlhbFRyZWVMYXlvdXQucHJvdG90eXBlLnJvd01pbkNlblg9W107bXhSYWRpYWxUcmVlTGF5b3V0LnByb3RvdHlwZS5yb3dNYXhDZW5YPVtdO214UmFkaWFsVHJlZUxheW91dC5wcm90b3R5cGUucm93UmFkaT1bXTtteFJhZGlhbFRyZWVMYXlvdXQucHJvdG90eXBlLnJvdz1bXTtteFJhZGlhbFRyZWVMYXlvdXQucHJvdG90eXBlLmlzVmVydGV4SWdub3JlZD1mdW5jdGlvbihhKXtyZXR1cm4gbXhHcmFwaExheW91dC5wcm90b3R5cGUuaXNWZXJ0ZXhJZ25vcmVkLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8MD09dGhpcy5ncmFwaC5nZXRDb25uZWN0aW9ucyhhKS5sZW5ndGh9OwpteFJhZGlhbFRyZWVMYXlvdXQucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oYSxiKXt0aGlzLnBhcmVudD1hO3RoaXMuZWRnZVJvdXRpbmc9dGhpcy51c2VCb3VuZGluZ0JveD0hMTtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5leGVjdXRlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgYz1udWxsLGQ9dGhpcy5nZXRWZXJ0ZXhCb3VuZHModGhpcy5yb290KTt0aGlzLmNlbnRlclg9ZC54K2Qud2lkdGgvMjt0aGlzLmNlbnRlclk9ZC55K2QuaGVpZ2h0LzI7Zm9yKHZhciBlIGluIHRoaXMudmlzaXRlZCl7dmFyIGY9dGhpcy5nZXRWZXJ0ZXhCb3VuZHModGhpcy52aXNpdGVkW2VdKSxjPW51bGwhPWM/YzpmLmNsb25lKCk7Yy5hZGQoZil9dGhpcy5jYWxjUm93RGltcyhbdGhpcy5ub2RlXSwwKTtmb3IodmFyIGc9MCxrPTAsYz0wO2M8dGhpcy5yb3cubGVuZ3RoO2MrKyllPSh0aGlzLnJvd01heFhbY10tdGhpcy5jZW50ZXJYLXRoaXMubm9kZURpc3RhbmNlKS90aGlzLnJvd1JhZGlbY10sCmc9TWF0aC5tYXgoZywodGhpcy5jZW50ZXJYLXRoaXMucm93TWluWFtjXS10aGlzLm5vZGVEaXN0YW5jZSkvdGhpcy5yb3dSYWRpW2NdKSxrPU1hdGgubWF4KGssZSk7Zm9yKGM9MDtjPHRoaXMucm93Lmxlbmd0aDtjKyspe3ZhciBsPXRoaXMuY2VudGVyWC10aGlzLm5vZGVEaXN0YW5jZS1nKnRoaXMucm93UmFkaVtjXSxtPXRoaXMuY2VudGVyWCt0aGlzLm5vZGVEaXN0YW5jZStrKnRoaXMucm93UmFkaVtjXS1sO2ZvcihlPTA7ZTx0aGlzLnJvd1tjXS5sZW5ndGg7ZSsrKWY9dGhpcy5yb3dbY10sZD1mW2VdLGY9dGhpcy5nZXRWZXJ0ZXhCb3VuZHMoZC5jZWxsKSxkLnRoZXRhPShmLngrZi53aWR0aC8yLWwpL20qTWF0aC5QSSoyfWZvcihjPXRoaXMucm93Lmxlbmd0aC0yOzA8PWM7Yy0tKWZvcihmPXRoaXMucm93W2NdLGU9MDtlPGYubGVuZ3RoO2UrKyl7ZD1mW2VdO2c9ZC5jaGlsZDtmb3IobD1rPTA7bnVsbCE9ZzspbCs9Zy50aGV0YSxrKyssZz1nLm5leHQ7MDxrJiYoZz1sL2ssZz4KZC50aGV0YSYmZTxmLmxlbmd0aC0xP2QudGhldGE9TWF0aC5taW4oZyxmW2UrMV0udGhldGEtTWF0aC5QSS8xMCk6ZzxkLnRoZXRhJiYwPGUmJihkLnRoZXRhPU1hdGgubWF4KGcsZltlLTFdLnRoZXRhK01hdGguUEkvMTApKSl9Zm9yKGM9MDtjPHRoaXMucm93Lmxlbmd0aDtjKyspZm9yKGU9MDtlPHRoaXMucm93W2NdLmxlbmd0aDtlKyspZj10aGlzLnJvd1tjXSxkPWZbZV0sZj10aGlzLmdldFZlcnRleEJvdW5kcyhkLmNlbGwpLHRoaXMuc2V0VmVydGV4TG9jYXRpb24oZC5jZWxsLHRoaXMuY2VudGVyWC1mLndpZHRoLzIrdGhpcy5yb3dSYWRpW2NdKk1hdGguY29zKGQudGhldGEpLHRoaXMuY2VudGVyWS1mLmhlaWdodC8yK3RoaXMucm93UmFkaVtjXSpNYXRoLnNpbihkLnRoZXRhKSl9OwpteFJhZGlhbFRyZWVMYXlvdXQucHJvdG90eXBlLmNhbGNSb3dEaW1zPWZ1bmN0aW9uKGEsYil7aWYobnVsbCE9YSYmMCE9YS5sZW5ndGgpe3RoaXMucm93TWluWFtiXT10aGlzLmNlbnRlclg7dGhpcy5yb3dNYXhYW2JdPXRoaXMuY2VudGVyWDt0aGlzLnJvd01pbkNlblhbYl09dGhpcy5jZW50ZXJYO3RoaXMucm93TWF4Q2VuWFtiXT10aGlzLmNlbnRlclg7dGhpcy5yb3dbYl09W107Zm9yKHZhciBjPSExLGQ9MDtkPGEubGVuZ3RoO2QrKylmb3IodmFyIGU9bnVsbCE9YVtkXT9hW2RdLmNoaWxkOm51bGw7bnVsbCE9ZTspe3ZhciBmPXRoaXMuZ2V0VmVydGV4Qm91bmRzKGUuY2VsbCk7dGhpcy5yb3dNaW5YW2JdPU1hdGgubWluKGYueCx0aGlzLnJvd01pblhbYl0pO3RoaXMucm93TWF4WFtiXT1NYXRoLm1heChmLngrZi53aWR0aCx0aGlzLnJvd01heFhbYl0pO3RoaXMucm93TWluQ2VuWFtiXT1NYXRoLm1pbihmLngrZi53aWR0aC8yLHRoaXMucm93TWluQ2VuWFtiXSk7dGhpcy5yb3dNYXhDZW5YW2JdPQpNYXRoLm1heChmLngrZi53aWR0aC8yLHRoaXMucm93TWF4Q2VuWFtiXSk7dGhpcy5yb3dSYWRpW2JdPWYueS10aGlzLmdldFZlcnRleEJvdW5kcyh0aGlzLnJvb3QpLnk7bnVsbCE9ZS5jaGlsZCYmKGM9ITApO3RoaXMucm93W2JdLnB1c2goZSk7ZT1lLm5leHR9YyYmdGhpcy5jYWxjUm93RGltcyh0aGlzLnJvd1tiXSxiKzEpfX07ZnVuY3Rpb24gbXhGYXN0T3JnYW5pY0xheW91dChhKXtteEdyYXBoTGF5b3V0LmNhbGwodGhpcyxhKX1teEZhc3RPcmdhbmljTGF5b3V0LnByb3RvdHlwZT1uZXcgbXhHcmFwaExheW91dDtteEZhc3RPcmdhbmljTGF5b3V0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1teEZhc3RPcmdhbmljTGF5b3V0O214RmFzdE9yZ2FuaWNMYXlvdXQucHJvdG90eXBlLnVzZUlucHV0T3JpZ2luPSEwO214RmFzdE9yZ2FuaWNMYXlvdXQucHJvdG90eXBlLnJlc2V0RWRnZXM9ITA7bXhGYXN0T3JnYW5pY0xheW91dC5wcm90b3R5cGUuZGlzYWJsZUVkZ2VTdHlsZT0hMDsKbXhGYXN0T3JnYW5pY0xheW91dC5wcm90b3R5cGUuZm9yY2VDb25zdGFudD01MDtteEZhc3RPcmdhbmljTGF5b3V0LnByb3RvdHlwZS5mb3JjZUNvbnN0YW50U3F1YXJlZD0wO214RmFzdE9yZ2FuaWNMYXlvdXQucHJvdG90eXBlLm1pbkRpc3RhbmNlTGltaXQ9MjtteEZhc3RPcmdhbmljTGF5b3V0LnByb3RvdHlwZS5tYXhEaXN0YW5jZUxpbWl0PTUwMDtteEZhc3RPcmdhbmljTGF5b3V0LnByb3RvdHlwZS5taW5EaXN0YW5jZUxpbWl0U3F1YXJlZD00O214RmFzdE9yZ2FuaWNMYXlvdXQucHJvdG90eXBlLmluaXRpYWxUZW1wPTIwMDtteEZhc3RPcmdhbmljTGF5b3V0LnByb3RvdHlwZS50ZW1wZXJhdHVyZT0wO214RmFzdE9yZ2FuaWNMYXlvdXQucHJvdG90eXBlLm1heEl0ZXJhdGlvbnM9MDtteEZhc3RPcmdhbmljTGF5b3V0LnByb3RvdHlwZS5pdGVyYXRpb249MDtteEZhc3RPcmdhbmljTGF5b3V0LnByb3RvdHlwZS5hbGxvd2VkVG9SdW49ITA7Cm14RmFzdE9yZ2FuaWNMYXlvdXQucHJvdG90eXBlLmlzVmVydGV4SWdub3JlZD1mdW5jdGlvbihhKXtyZXR1cm4gbXhHcmFwaExheW91dC5wcm90b3R5cGUuaXNWZXJ0ZXhJZ25vcmVkLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8MD09dGhpcy5ncmFwaC5nZXRDb25uZWN0aW9ucyhhKS5sZW5ndGh9OwpteEZhc3RPcmdhbmljTGF5b3V0LnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKTt0aGlzLnZlcnRleEFycmF5PVtdO2Zvcih2YXIgYz10aGlzLmdyYXBoLmdldENoaWxkVmVydGljZXMoYSksZD0wO2Q8Yy5sZW5ndGg7ZCsrKXRoaXMuaXNWZXJ0ZXhJZ25vcmVkKGNbZF0pfHx0aGlzLnZlcnRleEFycmF5LnB1c2goY1tkXSk7dmFyIGU9dGhpcy51c2VJbnB1dE9yaWdpbj90aGlzLmdyYXBoLmdldEJvdW5kaW5nQm94RnJvbUdlb21ldHJ5KHRoaXMudmVydGV4QXJyYXkpOm51bGwsZj10aGlzLnZlcnRleEFycmF5Lmxlbmd0aDt0aGlzLmluZGljZXM9W107dGhpcy5kaXNwWD1bXTt0aGlzLmRpc3BZPVtdO3RoaXMuY2VsbExvY2F0aW9uPVtdO3RoaXMuaXNNb3ZlYWJsZT1bXTt0aGlzLm5laWdoYm91cnM9W107dGhpcy5yYWRpdXM9W107dGhpcy5yYWRpdXNTcXVhcmVkPVtdOy4wMDE+dGhpcy5mb3JjZUNvbnN0YW50JiYodGhpcy5mb3JjZUNvbnN0YW50PQouMDAxKTt0aGlzLmZvcmNlQ29uc3RhbnRTcXVhcmVkPXRoaXMuZm9yY2VDb25zdGFudCp0aGlzLmZvcmNlQ29uc3RhbnQ7Zm9yKGQ9MDtkPHRoaXMudmVydGV4QXJyYXkubGVuZ3RoO2QrKyl7dmFyIGc9dGhpcy52ZXJ0ZXhBcnJheVtkXTt0aGlzLmNlbGxMb2NhdGlvbltkXT1bXTt2YXIgaz1teE9iamVjdElkZW50aXR5LmdldChnKTt0aGlzLmluZGljZXNba109ZDt2YXIgbD10aGlzLmdldFZlcnRleEJvdW5kcyhnKSxtPWwud2lkdGgsbj1sLmhlaWdodCxwPWwueCxxPWwueTt0aGlzLmNlbGxMb2NhdGlvbltkXVswXT1wK20vMjt0aGlzLmNlbGxMb2NhdGlvbltkXVsxXT1xK24vMjt0aGlzLnJhZGl1c1tkXT1NYXRoLm1pbihtLG4pO3RoaXMucmFkaXVzU3F1YXJlZFtkXT10aGlzLnJhZGl1c1tkXSp0aGlzLnJhZGl1c1tkXX1iLmJlZ2luVXBkYXRlKCk7dHJ5e2ZvcihkPTA7ZDxmO2QrKyl7dGhpcy5kaXNwWFtkXT0wO3RoaXMuZGlzcFlbZF09MDt0aGlzLmlzTW92ZWFibGVbZF09dGhpcy5pc1ZlcnRleE1vdmFibGUodGhpcy52ZXJ0ZXhBcnJheVtkXSk7CnZhciByPXRoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvbnModGhpcy52ZXJ0ZXhBcnJheVtkXSxhKSxjPXRoaXMuZ3JhcGguZ2V0T3Bwb3NpdGVzKHIsdGhpcy52ZXJ0ZXhBcnJheVtkXSk7dGhpcy5uZWlnaGJvdXJzW2RdPVtdO2ZvcihtPTA7bTxjLmxlbmd0aDttKyspe3RoaXMucmVzZXRFZGdlcyYmdGhpcy5ncmFwaC5yZXNldEVkZ2UoclttXSk7dGhpcy5kaXNhYmxlRWRnZVN0eWxlJiZ0aGlzLnNldEVkZ2VTdHlsZUVuYWJsZWQoclttXSwhMSk7dmFyIGs9bXhPYmplY3RJZGVudGl0eS5nZXQoY1ttXSksdD10aGlzLmluZGljZXNba107dGhpcy5uZWlnaGJvdXJzW2RdW21dPW51bGwhPXQ/dDpkfX10aGlzLnRlbXBlcmF0dXJlPXRoaXMuaW5pdGlhbFRlbXA7MD09dGhpcy5tYXhJdGVyYXRpb25zJiYodGhpcy5tYXhJdGVyYXRpb25zPTIwKk1hdGguc3FydChmKSk7Zm9yKHRoaXMuaXRlcmF0aW9uPTA7dGhpcy5pdGVyYXRpb248dGhpcy5tYXhJdGVyYXRpb25zO3RoaXMuaXRlcmF0aW9uKyspe2lmKCF0aGlzLmFsbG93ZWRUb1J1bilyZXR1cm47CnRoaXMuY2FsY1JlcHVsc2lvbigpO3RoaXMuY2FsY0F0dHJhY3Rpb24oKTt0aGlzLmNhbGNQb3NpdGlvbnMoKTt0aGlzLnJlZHVjZVRlbXBlcmF0dXJlKCl9YT1jPW51bGw7Zm9yKGQ9MDtkPHRoaXMudmVydGV4QXJyYXkubGVuZ3RoO2QrKylnPXRoaXMudmVydGV4QXJyYXlbZF0sdGhpcy5pc1ZlcnRleE1vdmFibGUoZykmJihsPXRoaXMuZ2V0VmVydGV4Qm91bmRzKGcpLG51bGwhPWwmJih0aGlzLmNlbGxMb2NhdGlvbltkXVswXS09bC53aWR0aC8yLHRoaXMuY2VsbExvY2F0aW9uW2RdWzFdLT1sLmhlaWdodC8yLHA9dGhpcy5ncmFwaC5zbmFwKE1hdGgucm91bmQodGhpcy5jZWxsTG9jYXRpb25bZF1bMF0pKSxxPXRoaXMuZ3JhcGguc25hcChNYXRoLnJvdW5kKHRoaXMuY2VsbExvY2F0aW9uW2RdWzFdKSksdGhpcy5zZXRWZXJ0ZXhMb2NhdGlvbihnLHAscSksYz1udWxsPT1jP3A6TWF0aC5taW4oYyxwKSxhPW51bGw9PWE/cTpNYXRoLm1pbihhLHEpKSk7ZD0tKGN8fDApKzE7Zz0tKGF8fAowKSsxO251bGwhPWUmJihkKz1lLngsZys9ZS55KTt0aGlzLmdyYXBoLm1vdmVDZWxscyh0aGlzLnZlcnRleEFycmF5LGQsZyl9ZmluYWxseXtiLmVuZFVwZGF0ZSgpfX07bXhGYXN0T3JnYW5pY0xheW91dC5wcm90b3R5cGUuY2FsY1Bvc2l0aW9ucz1mdW5jdGlvbigpe2Zvcih2YXIgYT0wO2E8dGhpcy52ZXJ0ZXhBcnJheS5sZW5ndGg7YSsrKWlmKHRoaXMuaXNNb3ZlYWJsZVthXSl7dmFyIGI9TWF0aC5zcXJ0KHRoaXMuZGlzcFhbYV0qdGhpcy5kaXNwWFthXSt0aGlzLmRpc3BZW2FdKnRoaXMuZGlzcFlbYV0pOy4wMDE+YiYmKGI9LjAwMSk7dmFyIGM9dGhpcy5kaXNwWFthXS9iKk1hdGgubWluKGIsdGhpcy50ZW1wZXJhdHVyZSksYj10aGlzLmRpc3BZW2FdL2IqTWF0aC5taW4oYix0aGlzLnRlbXBlcmF0dXJlKTt0aGlzLmRpc3BYW2FdPTA7dGhpcy5kaXNwWVthXT0wO3RoaXMuY2VsbExvY2F0aW9uW2FdWzBdKz1jO3RoaXMuY2VsbExvY2F0aW9uW2FdWzFdKz1ifX07Cm14RmFzdE9yZ2FuaWNMYXlvdXQucHJvdG90eXBlLmNhbGNBdHRyYWN0aW9uPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPTA7YTx0aGlzLnZlcnRleEFycmF5Lmxlbmd0aDthKyspZm9yKHZhciBiPTA7Yjx0aGlzLm5laWdoYm91cnNbYV0ubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5uZWlnaGJvdXJzW2FdW2JdO2lmKGEhPWMmJnRoaXMuaXNNb3ZlYWJsZVthXSYmdGhpcy5pc01vdmVhYmxlW2NdKXt2YXIgZD10aGlzLmNlbGxMb2NhdGlvblthXVswXS10aGlzLmNlbGxMb2NhdGlvbltjXVswXSxlPXRoaXMuY2VsbExvY2F0aW9uW2FdWzFdLXRoaXMuY2VsbExvY2F0aW9uW2NdWzFdLGY9ZCpkK2UqZS10aGlzLnJhZGl1c1NxdWFyZWRbYV0tdGhpcy5yYWRpdXNTcXVhcmVkW2NdO2Y8dGhpcy5taW5EaXN0YW5jZUxpbWl0U3F1YXJlZCYmKGY9dGhpcy5taW5EaXN0YW5jZUxpbWl0U3F1YXJlZCk7dmFyIGc9TWF0aC5zcXJ0KGYpLGY9Zi90aGlzLmZvcmNlQ29uc3RhbnQsZD1kL2cqZixlPWUvZypmOwp0aGlzLmRpc3BYW2FdLT1kO3RoaXMuZGlzcFlbYV0tPWU7dGhpcy5kaXNwWFtjXSs9ZDt0aGlzLmRpc3BZW2NdKz1lfX19OwpteEZhc3RPcmdhbmljTGF5b3V0LnByb3RvdHlwZS5jYWxjUmVwdWxzaW9uPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMudmVydGV4QXJyYXkubGVuZ3RoLGI9MDtiPGE7YisrKWZvcih2YXIgYz1iO2M8YTtjKyspe2lmKCF0aGlzLmFsbG93ZWRUb1J1bilyZXR1cm47aWYoYyE9YiYmdGhpcy5pc01vdmVhYmxlW2JdJiZ0aGlzLmlzTW92ZWFibGVbY10pe3ZhciBkPXRoaXMuY2VsbExvY2F0aW9uW2JdWzBdLXRoaXMuY2VsbExvY2F0aW9uW2NdWzBdLGU9dGhpcy5jZWxsTG9jYXRpb25bYl1bMV0tdGhpcy5jZWxsTG9jYXRpb25bY11bMV07MD09ZCYmKGQ9LjAxK01hdGgucmFuZG9tKCkpOzA9PWUmJihlPS4wMStNYXRoLnJhbmRvbSgpKTt2YXIgZj1NYXRoLnNxcnQoZCpkK2UqZSksZz1mLXRoaXMucmFkaXVzW2JdLXRoaXMucmFkaXVzW2NdO2c+dGhpcy5tYXhEaXN0YW5jZUxpbWl0fHwoZzx0aGlzLm1pbkRpc3RhbmNlTGltaXQmJihnPXRoaXMubWluRGlzdGFuY2VMaW1pdCksZz10aGlzLmZvcmNlQ29uc3RhbnRTcXVhcmVkLwpnLGQ9ZC9mKmcsZT1lL2YqZyx0aGlzLmRpc3BYW2JdKz1kLHRoaXMuZGlzcFlbYl0rPWUsdGhpcy5kaXNwWFtjXS09ZCx0aGlzLmRpc3BZW2NdLT1lKX19fTtteEZhc3RPcmdhbmljTGF5b3V0LnByb3RvdHlwZS5yZWR1Y2VUZW1wZXJhdHVyZT1mdW5jdGlvbigpe3RoaXMudGVtcGVyYXR1cmU9dGhpcy5pbml0aWFsVGVtcCooMS10aGlzLml0ZXJhdGlvbi90aGlzLm1heEl0ZXJhdGlvbnMpfTtmdW5jdGlvbiBteENpcmNsZUxheW91dChhLGIpe214R3JhcGhMYXlvdXQuY2FsbCh0aGlzLGEpO3RoaXMucmFkaXVzPW51bGwhPWI/YjoxMDB9bXhDaXJjbGVMYXlvdXQucHJvdG90eXBlPW5ldyBteEdyYXBoTGF5b3V0O214Q2lyY2xlTGF5b3V0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1teENpcmNsZUxheW91dDtteENpcmNsZUxheW91dC5wcm90b3R5cGUucmFkaXVzPW51bGw7bXhDaXJjbGVMYXlvdXQucHJvdG90eXBlLm1vdmVDaXJjbGU9ITE7Cm14Q2lyY2xlTGF5b3V0LnByb3RvdHlwZS54MD0wO214Q2lyY2xlTGF5b3V0LnByb3RvdHlwZS55MD0wO214Q2lyY2xlTGF5b3V0LnByb3RvdHlwZS5yZXNldEVkZ2VzPSEwO214Q2lyY2xlTGF5b3V0LnByb3RvdHlwZS5kaXNhYmxlRWRnZVN0eWxlPSEwOwpteENpcmNsZUxheW91dC5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdyYXBoLmdldE1vZGVsKCk7Yi5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGM9MCxkPW51bGwsZT1udWxsLGY9W10sZz1iLmdldENoaWxkQ291bnQoYSksaz0wO2s8ZztrKyspe3ZhciBsPWIuZ2V0Q2hpbGRBdChhLGspO2lmKHRoaXMuaXNWZXJ0ZXhJZ25vcmVkKGwpKXRoaXMuaXNFZGdlSWdub3JlZChsKXx8KHRoaXMucmVzZXRFZGdlcyYmdGhpcy5ncmFwaC5yZXNldEVkZ2UobCksdGhpcy5kaXNhYmxlRWRnZVN0eWxlJiZ0aGlzLnNldEVkZ2VTdHlsZUVuYWJsZWQobCwhMSkpO2Vsc2V7Zi5wdXNoKGwpO3ZhciBtPXRoaXMuZ2V0VmVydGV4Qm91bmRzKGwpLGQ9bnVsbD09ZD9tLnk6TWF0aC5taW4oZCxtLnkpLGU9bnVsbD09ZT9tLng6TWF0aC5taW4oZSxtLngpLGM9TWF0aC5tYXgoYyxNYXRoLm1heChtLndpZHRoLG0uaGVpZ2h0KSl9fXZhciBuPXRoaXMuZ2V0UmFkaXVzKGYubGVuZ3RoLApjKTt0aGlzLm1vdmVDaXJjbGUmJihlPXRoaXMueDAsZD10aGlzLnkwKTt0aGlzLmNpcmNsZShmLG4sZSxkKX1maW5hbGx5e2IuZW5kVXBkYXRlKCl9fTtteENpcmNsZUxheW91dC5wcm90b3R5cGUuZ2V0UmFkaXVzPWZ1bmN0aW9uKGEsYil7cmV0dXJuIE1hdGgubWF4KGEqYi9NYXRoLlBJLHRoaXMucmFkaXVzKX07bXhDaXJjbGVMYXlvdXQucHJvdG90eXBlLmNpcmNsZT1mdW5jdGlvbihhLGIsYyxkKXtmb3IodmFyIGU9YS5sZW5ndGgsZj0yKk1hdGguUEkvZSxnPTA7ZzxlO2crKyl0aGlzLmlzVmVydGV4TW92YWJsZShhW2ddKSYmdGhpcy5zZXRWZXJ0ZXhMb2NhdGlvbihhW2ddLE1hdGgucm91bmQoYytiK2IqTWF0aC5zaW4oZypmKSksTWF0aC5yb3VuZChkK2IrYipNYXRoLmNvcyhnKmYpKSl9O2Z1bmN0aW9uIG14UGFyYWxsZWxFZGdlTGF5b3V0KGEpe214R3JhcGhMYXlvdXQuY2FsbCh0aGlzLGEpfW14UGFyYWxsZWxFZGdlTGF5b3V0LnByb3RvdHlwZT1uZXcgbXhHcmFwaExheW91dDsKbXhQYXJhbGxlbEVkZ2VMYXlvdXQucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14UGFyYWxsZWxFZGdlTGF5b3V0O214UGFyYWxsZWxFZGdlTGF5b3V0LnByb3RvdHlwZS5zcGFjaW5nPTIwO214UGFyYWxsZWxFZGdlTGF5b3V0LnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGEpe2E9dGhpcy5maW5kUGFyYWxsZWxzKGEpO3RoaXMuZ3JhcGgubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBiIGluIGEpe3ZhciBjPWFbYl07MTxjLmxlbmd0aCYmdGhpcy5sYXlvdXQoYyl9fWZpbmFsbHl7dGhpcy5ncmFwaC5tb2RlbC5lbmRVcGRhdGUoKX19OwpteFBhcmFsbGVsRWRnZUxheW91dC5wcm90b3R5cGUuZmluZFBhcmFsbGVscz1mdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGM9W10sZD1iLmdldENoaWxkQ291bnQoYSksZT0wO2U8ZDtlKyspe3ZhciBmPWIuZ2V0Q2hpbGRBdChhLGUpO2lmKCF0aGlzLmlzRWRnZUlnbm9yZWQoZikpe3ZhciBnPXRoaXMuZ2V0RWRnZUlkKGYpO251bGwhPWcmJihudWxsPT1jW2ddJiYoY1tnXT1bXSksY1tnXS5wdXNoKGYpKX19cmV0dXJuIGN9O214UGFyYWxsZWxFZGdlTGF5b3V0LnByb3RvdHlwZS5nZXRFZGdlSWQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5ncmFwaC5nZXRWaWV3KCksYz1iLmdldFZpc2libGVUZXJtaW5hbChhLCEwKTthPWIuZ2V0VmlzaWJsZVRlcm1pbmFsKGEsITEpO3JldHVybiBudWxsIT1jJiZudWxsIT1hPyhjPW14T2JqZWN0SWRlbnRpdHkuZ2V0KGMpLGE9bXhPYmplY3RJZGVudGl0eS5nZXQoYSksYz5hP2ErIi0iK2M6YysiLSIrYSk6bnVsbH07Cm14UGFyYWxsZWxFZGdlTGF5b3V0LnByb3RvdHlwZS5sYXlvdXQ9ZnVuY3Rpb24oYSl7dmFyIGI9YVswXSxjPXRoaXMuZ3JhcGguZ2V0VmlldygpLGQ9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGU9ZC5nZXRHZW9tZXRyeShjLmdldFZpc2libGVUZXJtaW5hbChiLCEwKSksZD1kLmdldEdlb21ldHJ5KGMuZ2V0VmlzaWJsZVRlcm1pbmFsKGIsITEpKTtpZihlPT1kKWZvcih2YXIgYj1lLngrZS53aWR0aCt0aGlzLnNwYWNpbmcsYz1lLnkrZS5oZWlnaHQvMixmPTA7ZjxhLmxlbmd0aDtmKyspdGhpcy5yb3V0ZShhW2ZdLGIsYyksYis9dGhpcy5zcGFjaW5nO2Vsc2UgaWYobnVsbCE9ZSYmbnVsbCE9ZCl7dmFyIGI9ZS54K2Uud2lkdGgvMixjPWUueStlLmhlaWdodC8yLGY9ZC54K2Qud2lkdGgvMi1iLGc9ZC55K2QuaGVpZ2h0LzItYyxkPU1hdGguc3FydChmKmYrZypnKTtpZigwPGQpZm9yKGU9Zyp0aGlzLnNwYWNpbmcvZCxkPWYqdGhpcy5zcGFjaW5nL2QsYj1iK2YvMitlKihhLmxlbmd0aC0KMSkvMixjPWMrZy8yLWQqKGEubGVuZ3RoLTEpLzIsZj0wO2Y8YS5sZW5ndGg7ZisrKXRoaXMucm91dGUoYVtmXSxiLGMpLGItPWUsYys9ZH19O214UGFyYWxsZWxFZGdlTGF5b3V0LnByb3RvdHlwZS5yb3V0ZT1mdW5jdGlvbihhLGIsYyl7dGhpcy5ncmFwaC5pc0NlbGxNb3ZhYmxlKGEpJiZ0aGlzLnNldEVkZ2VQb2ludHMoYSxbbmV3IG14UG9pbnQoYixjKV0pfTtmdW5jdGlvbiBteENvbXBvc2l0ZUxheW91dChhLGIsYyl7bXhHcmFwaExheW91dC5jYWxsKHRoaXMsYSk7dGhpcy5sYXlvdXRzPWI7dGhpcy5tYXN0ZXI9Y31teENvbXBvc2l0ZUxheW91dC5wcm90b3R5cGU9bmV3IG14R3JhcGhMYXlvdXQ7bXhDb21wb3NpdGVMYXlvdXQucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14Q29tcG9zaXRlTGF5b3V0O214Q29tcG9zaXRlTGF5b3V0LnByb3RvdHlwZS5sYXlvdXRzPW51bGw7bXhDb21wb3NpdGVMYXlvdXQucHJvdG90eXBlLm1hc3Rlcj1udWxsOwpteENvbXBvc2l0ZUxheW91dC5wcm90b3R5cGUubW92ZUNlbGw9ZnVuY3Rpb24oYSxiLGMpe251bGwhPXRoaXMubWFzdGVyP3RoaXMubWFzdGVyLm1vdmVDZWxsLmFwcGx5KHRoaXMubWFzdGVyLGFyZ3VtZW50cyk6dGhpcy5sYXlvdXRzWzBdLm1vdmVDZWxsLmFwcGx5KHRoaXMubGF5b3V0c1swXSxhcmd1bWVudHMpfTtteENvbXBvc2l0ZUxheW91dC5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdyYXBoLmdldE1vZGVsKCk7Yi5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGM9MDtjPHRoaXMubGF5b3V0cy5sZW5ndGg7YysrKXRoaXMubGF5b3V0c1tjXS5leGVjdXRlLmFwcGx5KHRoaXMubGF5b3V0c1tjXSxhcmd1bWVudHMpfWZpbmFsbHl7Yi5lbmRVcGRhdGUoKX19O2Z1bmN0aW9uIG14RWRnZUxhYmVsTGF5b3V0KGEsYil7bXhHcmFwaExheW91dC5jYWxsKHRoaXMsYSl9bXhFZGdlTGFiZWxMYXlvdXQucHJvdG90eXBlPW5ldyBteEdyYXBoTGF5b3V0OwpteEVkZ2VMYWJlbExheW91dC5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhFZGdlTGFiZWxMYXlvdXQ7bXhFZGdlTGFiZWxMYXlvdXQucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXRoaXMuZ3JhcGgudmlldyxjPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxkPVtdLGU9W10sZj1jLmdldENoaWxkQ291bnQoYSksZz0wO2c8ZjtnKyspe3ZhciBrPWMuZ2V0Q2hpbGRBdChhLGcpLGw9Yi5nZXRTdGF0ZShrKTtudWxsIT1sJiYodGhpcy5pc1ZlcnRleElnbm9yZWQoayk/dGhpcy5pc0VkZ2VJZ25vcmVkKGspfHxkLnB1c2gobCk6ZS5wdXNoKGwpKX10aGlzLnBsYWNlTGFiZWxzKGUsZCl9OwpteEVkZ2VMYWJlbExheW91dC5wcm90b3R5cGUucGxhY2VMYWJlbHM9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdyYXBoLmdldE1vZGVsKCk7Yy5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGQ9MDtkPGIubGVuZ3RoO2QrKyl7dmFyIGU9YltkXTtpZihudWxsIT1lJiZudWxsIT1lLnRleHQmJm51bGwhPWUudGV4dC5ib3VuZGluZ0JveClmb3IodmFyIGY9MDtmPGEubGVuZ3RoO2YrKyl7dmFyIGc9YVtmXTtudWxsIT1nJiZ0aGlzLmF2b2lkKGUsZyl9fX1maW5hbGx5e2MuZW5kVXBkYXRlKCl9fTsKbXhFZGdlTGFiZWxMYXlvdXQucHJvdG90eXBlLmF2b2lkPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGQ9YS50ZXh0LmJvdW5kaW5nQm94O2lmKG14VXRpbHMuaW50ZXJzZWN0cyhkLGIpKXt2YXIgZT0tZC55LWQuaGVpZ2h0K2IueSxmPS1kLnkrYi55K2IuaGVpZ2h0LGU9TWF0aC5hYnMoZSk8TWF0aC5hYnMoZik/ZTpmLGY9LWQueC1kLndpZHRoK2IueCxkPS1kLngrYi54K2Iud2lkdGgsZD1NYXRoLmFicyhmKTxNYXRoLmFicyhkKT9mOmQ7TWF0aC5hYnMoZCk8TWF0aC5hYnMoZSk/ZT0wOmQ9MDtmPWMuZ2V0R2VvbWV0cnkoYS5jZWxsKTtudWxsIT1mJiYoZj1mLmNsb25lKCksbnVsbCE9Zi5vZmZzZXQ/KGYub2Zmc2V0LngrPWQsZi5vZmZzZXQueSs9ZSk6Zi5vZmZzZXQ9bmV3IG14UG9pbnQoZCxlKSxjLnNldEdlb21ldHJ5KGEuY2VsbCxmKSl9fTsKZnVuY3Rpb24gbXhHcmFwaEFic3RyYWN0SGllcmFyY2h5Q2VsbCgpe3RoaXMueD1bXTt0aGlzLnk9W107dGhpcy50ZW1wPVtdfW14R3JhcGhBYnN0cmFjdEhpZXJhcmNoeUNlbGwucHJvdG90eXBlLm1heFJhbms9LTE7bXhHcmFwaEFic3RyYWN0SGllcmFyY2h5Q2VsbC5wcm90b3R5cGUubWluUmFuaz0tMTtteEdyYXBoQWJzdHJhY3RIaWVyYXJjaHlDZWxsLnByb3RvdHlwZS54PW51bGw7bXhHcmFwaEFic3RyYWN0SGllcmFyY2h5Q2VsbC5wcm90b3R5cGUueT1udWxsO214R3JhcGhBYnN0cmFjdEhpZXJhcmNoeUNlbGwucHJvdG90eXBlLndpZHRoPTA7bXhHcmFwaEFic3RyYWN0SGllcmFyY2h5Q2VsbC5wcm90b3R5cGUuaGVpZ2h0PTA7bXhHcmFwaEFic3RyYWN0SGllcmFyY2h5Q2VsbC5wcm90b3R5cGUubmV4dExheWVyQ29ubmVjdGVkQ2VsbHM9bnVsbDtteEdyYXBoQWJzdHJhY3RIaWVyYXJjaHlDZWxsLnByb3RvdHlwZS5wcmV2aW91c0xheWVyQ29ubmVjdGVkQ2VsbHM9bnVsbDsKbXhHcmFwaEFic3RyYWN0SGllcmFyY2h5Q2VsbC5wcm90b3R5cGUudGVtcD1udWxsO214R3JhcGhBYnN0cmFjdEhpZXJhcmNoeUNlbGwucHJvdG90eXBlLmdldE5leHRMYXllckNvbm5lY3RlZENlbGxzPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsfTtteEdyYXBoQWJzdHJhY3RIaWVyYXJjaHlDZWxsLnByb3RvdHlwZS5nZXRQcmV2aW91c0xheWVyQ29ubmVjdGVkQ2VsbHM9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGx9O214R3JhcGhBYnN0cmFjdEhpZXJhcmNoeUNlbGwucHJvdG90eXBlLmlzRWRnZT1mdW5jdGlvbigpe3JldHVybiExfTtteEdyYXBoQWJzdHJhY3RIaWVyYXJjaHlDZWxsLnByb3RvdHlwZS5pc1ZlcnRleD1mdW5jdGlvbigpe3JldHVybiExfTtteEdyYXBoQWJzdHJhY3RIaWVyYXJjaHlDZWxsLnByb3RvdHlwZS5nZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsfTsKbXhHcmFwaEFic3RyYWN0SGllcmFyY2h5Q2VsbC5wcm90b3R5cGUuc2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZT1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsfTtteEdyYXBoQWJzdHJhY3RIaWVyYXJjaHlDZWxsLnByb3RvdHlwZS5zZXRYPWZ1bmN0aW9uKGEsYil7dGhpcy5pc1ZlcnRleCgpP3RoaXMueFswXT1iOnRoaXMuaXNFZGdlKCkmJih0aGlzLnhbYS10aGlzLm1pblJhbmstMV09Yil9O214R3JhcGhBYnN0cmFjdEhpZXJhcmNoeUNlbGwucHJvdG90eXBlLmdldFg9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuaXNWZXJ0ZXgoKT90aGlzLnhbMF06dGhpcy5pc0VkZ2UoKT90aGlzLnhbYS10aGlzLm1pblJhbmstMV06MH07bXhHcmFwaEFic3RyYWN0SGllcmFyY2h5Q2VsbC5wcm90b3R5cGUuc2V0WT1mdW5jdGlvbihhLGIpe3RoaXMuaXNWZXJ0ZXgoKT90aGlzLnlbMF09Yjp0aGlzLmlzRWRnZSgpJiYodGhpcy55W2EtdGhpcy5taW5SYW5rLTFdPWIpfTsKZnVuY3Rpb24gbXhHcmFwaEhpZXJhcmNoeU5vZGUoYSl7bXhHcmFwaEFic3RyYWN0SGllcmFyY2h5Q2VsbC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy5jZWxsPWE7dGhpcy5pZD1teE9iamVjdElkZW50aXR5LmdldChhKTt0aGlzLmNvbm5lY3RzQXNUYXJnZXQ9W107dGhpcy5jb25uZWN0c0FzU291cmNlPVtdfW14R3JhcGhIaWVyYXJjaHlOb2RlLnByb3RvdHlwZT1uZXcgbXhHcmFwaEFic3RyYWN0SGllcmFyY2h5Q2VsbDtteEdyYXBoSGllcmFyY2h5Tm9kZS5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhHcmFwaEhpZXJhcmNoeU5vZGU7bXhHcmFwaEhpZXJhcmNoeU5vZGUucHJvdG90eXBlLmNlbGw9bnVsbDtteEdyYXBoSGllcmFyY2h5Tm9kZS5wcm90b3R5cGUuaWQ9bnVsbDtteEdyYXBoSGllcmFyY2h5Tm9kZS5wcm90b3R5cGUuY29ubmVjdHNBc1RhcmdldD1udWxsO214R3JhcGhIaWVyYXJjaHlOb2RlLnByb3RvdHlwZS5jb25uZWN0c0FzU291cmNlPW51bGw7Cm14R3JhcGhIaWVyYXJjaHlOb2RlLnByb3RvdHlwZS5oYXNoQ29kZT0hMTtteEdyYXBoSGllcmFyY2h5Tm9kZS5wcm90b3R5cGUuZ2V0UmFua1ZhbHVlPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLm1heFJhbmt9O214R3JhcGhIaWVyYXJjaHlOb2RlLnByb3RvdHlwZS5nZXROZXh0TGF5ZXJDb25uZWN0ZWRDZWxscz1mdW5jdGlvbihhKXtpZihudWxsPT10aGlzLm5leHRMYXllckNvbm5lY3RlZENlbGxzKXt0aGlzLm5leHRMYXllckNvbm5lY3RlZENlbGxzPVtdO3RoaXMubmV4dExheWVyQ29ubmVjdGVkQ2VsbHNbMF09W107Zm9yKHZhciBiPTA7Yjx0aGlzLmNvbm5lY3RzQXNUYXJnZXQubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5jb25uZWN0c0FzVGFyZ2V0W2JdOy0xPT1jLm1heFJhbmt8fGMubWF4UmFuaz09YSsxP3RoaXMubmV4dExheWVyQ29ubmVjdGVkQ2VsbHNbMF0ucHVzaChjLnNvdXJjZSk6dGhpcy5uZXh0TGF5ZXJDb25uZWN0ZWRDZWxsc1swXS5wdXNoKGMpfX1yZXR1cm4gdGhpcy5uZXh0TGF5ZXJDb25uZWN0ZWRDZWxsc1swXX07Cm14R3JhcGhIaWVyYXJjaHlOb2RlLnByb3RvdHlwZS5nZXRQcmV2aW91c0xheWVyQ29ubmVjdGVkQ2VsbHM9ZnVuY3Rpb24oYSl7aWYobnVsbD09dGhpcy5wcmV2aW91c0xheWVyQ29ubmVjdGVkQ2VsbHMpe3RoaXMucHJldmlvdXNMYXllckNvbm5lY3RlZENlbGxzPVtdO3RoaXMucHJldmlvdXNMYXllckNvbm5lY3RlZENlbGxzWzBdPVtdO2Zvcih2YXIgYj0wO2I8dGhpcy5jb25uZWN0c0FzU291cmNlLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuY29ubmVjdHNBc1NvdXJjZVtiXTstMT09Yy5taW5SYW5rfHxjLm1pblJhbms9PWEtMT90aGlzLnByZXZpb3VzTGF5ZXJDb25uZWN0ZWRDZWxsc1swXS5wdXNoKGMudGFyZ2V0KTp0aGlzLnByZXZpb3VzTGF5ZXJDb25uZWN0ZWRDZWxsc1swXS5wdXNoKGMpfX1yZXR1cm4gdGhpcy5wcmV2aW91c0xheWVyQ29ubmVjdGVkQ2VsbHNbMF19O214R3JhcGhIaWVyYXJjaHlOb2RlLnByb3RvdHlwZS5pc1ZlcnRleD1mdW5jdGlvbigpe3JldHVybiEwfTsKbXhHcmFwaEhpZXJhcmNoeU5vZGUucHJvdG90eXBlLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMudGVtcFswXX07bXhHcmFwaEhpZXJhcmNoeU5vZGUucHJvdG90eXBlLnNldEdlbmVyYWxQdXJwb3NlVmFyaWFibGU9ZnVuY3Rpb24oYSxiKXt0aGlzLnRlbXBbMF09Yn07bXhHcmFwaEhpZXJhcmNoeU5vZGUucHJvdG90eXBlLmlzQW5jZXN0b3I9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSYmbnVsbCE9dGhpcy5oYXNoQ29kZSYmbnVsbCE9YS5oYXNoQ29kZSYmdGhpcy5oYXNoQ29kZS5sZW5ndGg8YS5oYXNoQ29kZS5sZW5ndGgpe2lmKHRoaXMuaGFzaENvZGU9PWEuaGFzaENvZGUpcmV0dXJuITA7aWYobnVsbD09dGhpcy5oYXNoQ29kZXx8bnVsbD09dGhpcy5oYXNoQ29kZSlyZXR1cm4hMTtmb3IodmFyIGI9MDtiPHRoaXMuaGFzaENvZGUubGVuZ3RoO2IrKylpZih0aGlzLmhhc2hDb2RlW2JdIT1hLmhhc2hDb2RlW2JdKXJldHVybiExO3JldHVybiEwfXJldHVybiExfTsKbXhHcmFwaEhpZXJhcmNoeU5vZGUucHJvdG90eXBlLmdldENvcmVDZWxsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbH07ZnVuY3Rpb24gbXhHcmFwaEhpZXJhcmNoeUVkZ2UoYSl7bXhHcmFwaEFic3RyYWN0SGllcmFyY2h5Q2VsbC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy5lZGdlcz1hO3RoaXMuaWRzPVtdO2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXRoaXMuaWRzLnB1c2gobXhPYmplY3RJZGVudGl0eS5nZXQoYVtiXSkpfW14R3JhcGhIaWVyYXJjaHlFZGdlLnByb3RvdHlwZT1uZXcgbXhHcmFwaEFic3RyYWN0SGllcmFyY2h5Q2VsbDtteEdyYXBoSGllcmFyY2h5RWRnZS5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhHcmFwaEhpZXJhcmNoeUVkZ2U7bXhHcmFwaEhpZXJhcmNoeUVkZ2UucHJvdG90eXBlLmVkZ2VzPW51bGw7bXhHcmFwaEhpZXJhcmNoeUVkZ2UucHJvdG90eXBlLmlkcz1udWxsO214R3JhcGhIaWVyYXJjaHlFZGdlLnByb3RvdHlwZS5zb3VyY2U9bnVsbDsKbXhHcmFwaEhpZXJhcmNoeUVkZ2UucHJvdG90eXBlLnRhcmdldD1udWxsO214R3JhcGhIaWVyYXJjaHlFZGdlLnByb3RvdHlwZS5pc1JldmVyc2VkPSExO214R3JhcGhIaWVyYXJjaHlFZGdlLnByb3RvdHlwZS5pbnZlcnQ9ZnVuY3Rpb24oYSl7YT10aGlzLnNvdXJjZTt0aGlzLnNvdXJjZT10aGlzLnRhcmdldDt0aGlzLnRhcmdldD1hO3RoaXMuaXNSZXZlcnNlZD0hdGhpcy5pc1JldmVyc2VkfTsKbXhHcmFwaEhpZXJhcmNoeUVkZ2UucHJvdG90eXBlLmdldE5leHRMYXllckNvbm5lY3RlZENlbGxzPWZ1bmN0aW9uKGEpe2lmKG51bGw9PXRoaXMubmV4dExheWVyQ29ubmVjdGVkQ2VsbHMpe3RoaXMubmV4dExheWVyQ29ubmVjdGVkQ2VsbHM9W107Zm9yKHZhciBiPTA7Yjx0aGlzLnRlbXAubGVuZ3RoO2IrKyl0aGlzLm5leHRMYXllckNvbm5lY3RlZENlbGxzW2JdPVtdLGI9PXRoaXMudGVtcC5sZW5ndGgtMT90aGlzLm5leHRMYXllckNvbm5lY3RlZENlbGxzW2JdLnB1c2godGhpcy5zb3VyY2UpOnRoaXMubmV4dExheWVyQ29ubmVjdGVkQ2VsbHNbYl0ucHVzaCh0aGlzKX1yZXR1cm4gdGhpcy5uZXh0TGF5ZXJDb25uZWN0ZWRDZWxsc1thLXRoaXMubWluUmFuay0xXX07Cm14R3JhcGhIaWVyYXJjaHlFZGdlLnByb3RvdHlwZS5nZXRQcmV2aW91c0xheWVyQ29ubmVjdGVkQ2VsbHM9ZnVuY3Rpb24oYSl7aWYobnVsbD09dGhpcy5wcmV2aW91c0xheWVyQ29ubmVjdGVkQ2VsbHMpe3RoaXMucHJldmlvdXNMYXllckNvbm5lY3RlZENlbGxzPVtdO2Zvcih2YXIgYj0wO2I8dGhpcy50ZW1wLmxlbmd0aDtiKyspdGhpcy5wcmV2aW91c0xheWVyQ29ubmVjdGVkQ2VsbHNbYl09W10sMD09Yj90aGlzLnByZXZpb3VzTGF5ZXJDb25uZWN0ZWRDZWxsc1tiXS5wdXNoKHRoaXMudGFyZ2V0KTp0aGlzLnByZXZpb3VzTGF5ZXJDb25uZWN0ZWRDZWxsc1tiXS5wdXNoKHRoaXMpfXJldHVybiB0aGlzLnByZXZpb3VzTGF5ZXJDb25uZWN0ZWRDZWxsc1thLXRoaXMubWluUmFuay0xXX07bXhHcmFwaEhpZXJhcmNoeUVkZ2UucHJvdG90eXBlLmlzRWRnZT1mdW5jdGlvbigpe3JldHVybiEwfTsKbXhHcmFwaEhpZXJhcmNoeUVkZ2UucHJvdG90eXBlLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMudGVtcFthLXRoaXMubWluUmFuay0xXX07bXhHcmFwaEhpZXJhcmNoeUVkZ2UucHJvdG90eXBlLnNldEdlbmVyYWxQdXJwb3NlVmFyaWFibGU9ZnVuY3Rpb24oYSxiKXt0aGlzLnRlbXBbYS10aGlzLm1pblJhbmstMV09Yn07bXhHcmFwaEhpZXJhcmNoeUVkZ2UucHJvdG90eXBlLmdldENvcmVDZWxsPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuZWRnZXMmJjA8dGhpcy5lZGdlcy5sZW5ndGg/dGhpcy5lZGdlc1swXTpudWxsfTsKZnVuY3Rpb24gbXhHcmFwaEhpZXJhcmNoeU1vZGVsKGEsYixjLGQsZSl7YS5nZXRHcmFwaCgpO3RoaXMudGlnaHRlblRvU291cmNlPWU7dGhpcy5yb290cz1jO3RoaXMucGFyZW50PWQ7dGhpcy52ZXJ0ZXhNYXBwZXI9bmV3IG14RGljdGlvbmFyeTt0aGlzLmVkZ2VNYXBwZXI9bmV3IG14RGljdGlvbmFyeTt0aGlzLm1heFJhbms9MDtjPVtdO251bGw9PWImJihiPXRoaXMuZ3JhcGguZ2V0Q2hpbGRWZXJ0aWNlcyhkKSk7dGhpcy5tYXhSYW5rPXRoaXMuU09VUkNFU0NBTlNUQVJUUkFOSzt0aGlzLmNyZWF0ZUludGVybmFsQ2VsbHMoYSxiLGMpO2ZvcihkPTA7ZDxiLmxlbmd0aDtkKyspe2U9Y1tkXS5jb25uZWN0c0FzU291cmNlO2Zvcih2YXIgZj0wO2Y8ZS5sZW5ndGg7ZisrKXt2YXIgZz1lW2ZdLGs9Zy5lZGdlcztpZihudWxsIT1rJiYwPGsubGVuZ3RoKXt2YXIgaz1rWzBdLGw9YS5nZXRWaXNpYmxlVGVybWluYWwoaywhMSksbD10aGlzLnZlcnRleE1hcHBlci5nZXQobCk7Y1tkXT09CmwmJihsPWEuZ2V0VmlzaWJsZVRlcm1pbmFsKGssITApLGw9dGhpcy52ZXJ0ZXhNYXBwZXIuZ2V0KGwpKTtudWxsIT1sJiZjW2RdIT1sJiYoZy50YXJnZXQ9bCwwPT1sLmNvbm5lY3RzQXNUYXJnZXQubGVuZ3RoJiYobC5jb25uZWN0c0FzVGFyZ2V0PVtdKSwwPm14VXRpbHMuaW5kZXhPZihsLmNvbm5lY3RzQXNUYXJnZXQsZykmJmwuY29ubmVjdHNBc1RhcmdldC5wdXNoKGcpKX19Y1tkXS50ZW1wWzBdPTF9fW14R3JhcGhIaWVyYXJjaHlNb2RlbC5wcm90b3R5cGUubWF4UmFuaz1udWxsO214R3JhcGhIaWVyYXJjaHlNb2RlbC5wcm90b3R5cGUudmVydGV4TWFwcGVyPW51bGw7bXhHcmFwaEhpZXJhcmNoeU1vZGVsLnByb3RvdHlwZS5lZGdlTWFwcGVyPW51bGw7bXhHcmFwaEhpZXJhcmNoeU1vZGVsLnByb3RvdHlwZS5yYW5rcz1udWxsO214R3JhcGhIaWVyYXJjaHlNb2RlbC5wcm90b3R5cGUucm9vdHM9bnVsbDtteEdyYXBoSGllcmFyY2h5TW9kZWwucHJvdG90eXBlLnBhcmVudD1udWxsOwpteEdyYXBoSGllcmFyY2h5TW9kZWwucHJvdG90eXBlLmRmc0NvdW50PTA7bXhHcmFwaEhpZXJhcmNoeU1vZGVsLnByb3RvdHlwZS5TT1VSQ0VTQ0FOU1RBUlRSQU5LPTFFODtteEdyYXBoSGllcmFyY2h5TW9kZWwucHJvdG90eXBlLnRpZ2h0ZW5Ub1NvdXJjZT0hMTsKbXhHcmFwaEhpZXJhcmNoeU1vZGVsLnByb3RvdHlwZS5jcmVhdGVJbnRlcm5hbENlbGxzPWZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9YS5nZXRHcmFwaCgpLGU9MDtlPGIubGVuZ3RoO2UrKyl7Y1tlXT1uZXcgbXhHcmFwaEhpZXJhcmNoeU5vZGUoYltlXSk7dGhpcy52ZXJ0ZXhNYXBwZXIucHV0KGJbZV0sY1tlXSk7dmFyIGY9YS5nZXRFZGdlcyhiW2VdKTtjW2VdLmNvbm5lY3RzQXNTb3VyY2U9W107Zm9yKHZhciBnPTA7ZzxmLmxlbmd0aDtnKyspe3ZhciBrPWEuZ2V0VmlzaWJsZVRlcm1pbmFsKGZbZ10sITEpO2lmKGshPWJbZV0mJmEuZ3JhcGgubW9kZWwuaXNWZXJ0ZXgoaykmJiFhLmlzVmVydGV4SWdub3JlZChrKSl7dmFyIGw9YS5nZXRFZGdlc0JldHdlZW4oYltlXSxrLCExKSxrPWEuZ2V0RWRnZXNCZXR3ZWVuKGJbZV0saywhMCk7aWYobnVsbCE9bCYmMDxsLmxlbmd0aCYmbnVsbD09dGhpcy5lZGdlTWFwcGVyLmdldChsWzBdKSYmMiprLmxlbmd0aD49bC5sZW5ndGgpe2Zvcih2YXIgaz0KbmV3IG14R3JhcGhIaWVyYXJjaHlFZGdlKGwpLG09MDttPGwubGVuZ3RoO20rKyl7dmFyIG49bFttXTt0aGlzLmVkZ2VNYXBwZXIucHV0KG4sayk7ZC5yZXNldEVkZ2Uobik7YS5kaXNhYmxlRWRnZVN0eWxlJiYoYS5zZXRFZGdlU3R5bGVFbmFibGVkKG4sITEpLGEuc2V0T3J0aG9nb25hbEVkZ2UobiwhMCkpfWsuc291cmNlPWNbZV07MD5teFV0aWxzLmluZGV4T2YoY1tlXS5jb25uZWN0c0FzU291cmNlLGspJiZjW2VdLmNvbm5lY3RzQXNTb3VyY2UucHVzaChrKX19fWNbZV0udGVtcFswXT0wfX07Cm14R3JhcGhIaWVyYXJjaHlNb2RlbC5wcm90b3R5cGUuaW5pdGlhbFJhbms9ZnVuY3Rpb24oKXt2YXIgYT1bXTtpZihudWxsIT10aGlzLnJvb3RzKWZvcih2YXIgYj0wO2I8dGhpcy5yb290cy5sZW5ndGg7YisrKXt2YXIgYz10aGlzLnZlcnRleE1hcHBlci5nZXQodGhpcy5yb290c1tiXSk7bnVsbCE9YyYmYS5wdXNoKGMpfWZvcih2YXIgZD10aGlzLnZlcnRleE1hcHBlci5nZXRWYWx1ZXMoKSxiPTA7YjxkLmxlbmd0aDtiKyspZFtiXS50ZW1wWzBdPS0xO2Zvcih2YXIgZT1hLnNsaWNlKCk7MDxhLmxlbmd0aDspe3ZhciBjPWFbMF0sZixnO2Y9Yy5jb25uZWN0c0FzVGFyZ2V0O2c9Yy5jb25uZWN0c0FzU291cmNlO2Zvcih2YXIgaz0hMCxsPXRoaXMuU09VUkNFU0NBTlNUQVJUUkFOSyxiPTA7YjxmLmxlbmd0aDtiKyspe3ZhciBtPWZbYl07aWYoNTI3MDYyMD09bS50ZW1wWzBdKW09bS5zb3VyY2UsbD1NYXRoLm1pbihsLG0udGVtcFswXS0xKTtlbHNle2s9ITE7YnJlYWt9fWlmKGspe2MudGVtcFswXT0KbDt0aGlzLm1heFJhbms9TWF0aC5taW4odGhpcy5tYXhSYW5rLGwpO2lmKG51bGwhPWcpZm9yKGI9MDtiPGcubGVuZ3RoO2IrKyltPWdbYl0sbS50ZW1wWzBdPTUyNzA2MjAsbT1tLnRhcmdldCwtMT09bS50ZW1wWzBdJiYoYS5wdXNoKG0pLG0udGVtcFswXT0tMik7YS5zaGlmdCgpfWVsc2UgaWYoYj1hLnNoaWZ0KCksYS5wdXNoKGMpLGI9PWMmJjE9PWEubGVuZ3RoKWJyZWFrfWZvcihiPTA7YjxkLmxlbmd0aDtiKyspZFtiXS50ZW1wWzBdLT10aGlzLm1heFJhbms7Zm9yKGI9MDtiPGUubGVuZ3RoO2IrKylmb3IoYz1lW2JdLGE9MCxmPWMuY29ubmVjdHNBc1NvdXJjZSxkPTA7ZDxmLmxlbmd0aDtkKyspbT1mW2RdLG09bS50YXJnZXQsYy50ZW1wWzBdPU1hdGgubWF4KGEsbS50ZW1wWzBdKzEpLGE9Yy50ZW1wWzBdO3RoaXMubWF4UmFuaz10aGlzLlNPVVJDRVNDQU5TVEFSVFJBTkstdGhpcy5tYXhSYW5rfTsKbXhHcmFwaEhpZXJhcmNoeU1vZGVsLnByb3RvdHlwZS5maXhSYW5rcz1mdW5jdGlvbigpe3ZhciBhPVtdO3RoaXMucmFua3M9W107Zm9yKHZhciBiPTA7Yjx0aGlzLm1heFJhbmsrMTtiKyspYVtiXT1bXSx0aGlzLnJhbmtzW2JdPWFbYl07dmFyIGM9bnVsbDtpZihudWxsIT10aGlzLnJvb3RzKWZvcih2YXIgZD10aGlzLnJvb3RzLGM9W10sYj0wO2I8ZC5sZW5ndGg7YisrKXt2YXIgZT10aGlzLnZlcnRleE1hcHBlci5nZXQoZFtiXSk7Y1tiXT1lfXRoaXMudmlzaXQoZnVuY3Rpb24oYixjLGQsZSxtKXswPT1tJiYwPmMubWF4UmFuayYmMD5jLm1pblJhbmsmJihhW2MudGVtcFswXV0ucHVzaChjKSxjLm1heFJhbms9Yy50ZW1wWzBdLGMubWluUmFuaz1jLnRlbXBbMF0sYy50ZW1wWzBdPWFbYy5tYXhSYW5rXS5sZW5ndGgtMSk7aWYobnVsbCE9YiYmbnVsbCE9ZCYmMTxiLm1heFJhbmstYy5tYXhSYW5rKWZvcihkLm1heFJhbms9Yi5tYXhSYW5rLGQubWluUmFuaz1jLm1heFJhbmssZC50ZW1wPQpbXSxkLng9W10sZC55PVtdLGI9ZC5taW5SYW5rKzE7YjxkLm1heFJhbms7YisrKWFbYl0ucHVzaChkKSxkLnNldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoYixhW2JdLmxlbmd0aC0xKX0sYywhMSxudWxsKX07bXhHcmFwaEhpZXJhcmNoeU1vZGVsLnByb3RvdHlwZS52aXNpdD1mdW5jdGlvbihhLGIsYyxkKXtpZihudWxsIT1iKXtmb3IodmFyIGU9MDtlPGIubGVuZ3RoO2UrKyl7dmFyIGY9YltlXTtudWxsIT1mJiYobnVsbD09ZCYmKGQ9e30pLGM/KGYuaGFzaENvZGU9W10sZi5oYXNoQ29kZVswXT10aGlzLmRmc0NvdW50LGYuaGFzaENvZGVbMV09ZSx0aGlzLmV4dGVuZGVkRGZzKG51bGwsZixudWxsLGEsZCxmLmhhc2hDb2RlLGUsMCkpOnRoaXMuZGZzKG51bGwsZixudWxsLGEsZCwwKSl9dGhpcy5kZnNDb3VudCsrfX07Cm14R3JhcGhIaWVyYXJjaHlNb2RlbC5wcm90b3R5cGUuZGZzPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtpZihudWxsIT1iKXt2YXIgZz1iLmlkO2lmKG51bGw9PWVbZ10pZm9yKGVbZ109YixkKGEsYixjLGYsMCksYT1iLmNvbm5lY3RzQXNTb3VyY2Uuc2xpY2UoKSxjPTA7YzxhLmxlbmd0aDtjKyspZz1hW2NdLHRoaXMuZGZzKGIsZy50YXJnZXQsZyxkLGUsZisxKTtlbHNlIGQoYSxiLGMsZiwxKX19OwpteEdyYXBoSGllcmFyY2h5TW9kZWwucHJvdG90eXBlLmV4dGVuZGVkRGZzPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayl7aWYobnVsbCE9YilpZihudWxsPT1hfHxudWxsIT1iLmhhc2hDb2RlJiZiLmhhc2hDb2RlWzBdPT1hLmhhc2hDb2RlWzBdfHwoZj1hLmhhc2hDb2RlLmxlbmd0aCsxLGIuaGFzaENvZGU9YS5oYXNoQ29kZS5zbGljZSgpLGIuaGFzaENvZGVbZi0xXT1nKSxnPWIuaWQsbnVsbD09ZVtnXSlmb3IoZVtnXT1iLGQoYSxiLGMsaywwKSxhPWIuY29ubmVjdHNBc1NvdXJjZS5zbGljZSgpLGM9MDtjPGEubGVuZ3RoO2MrKylnPWFbY10sdGhpcy5leHRlbmRlZERmcyhiLGcudGFyZ2V0LGcsZCxlLGIuaGFzaENvZGUsYyxrKzEpO2Vsc2UgZChhLGIsYyxrLDEpfTsKZnVuY3Rpb24gbXhTd2ltbGFuZU1vZGVsKGEsYixjLGQsZSl7YS5nZXRHcmFwaCgpO3RoaXMudGlnaHRlblRvU291cmNlPWU7dGhpcy5yb290cz1jO3RoaXMucGFyZW50PWQ7dGhpcy52ZXJ0ZXhNYXBwZXI9bmV3IG14RGljdGlvbmFyeTt0aGlzLmVkZ2VNYXBwZXI9bmV3IG14RGljdGlvbmFyeTt0aGlzLm1heFJhbms9MDtjPVtdO251bGw9PWImJihiPXRoaXMuZ3JhcGguZ2V0Q2hpbGRWZXJ0aWNlcyhkKSk7dGhpcy5tYXhSYW5rPXRoaXMuU09VUkNFU0NBTlNUQVJUUkFOSzt0aGlzLmNyZWF0ZUludGVybmFsQ2VsbHMoYSxiLGMpO2ZvcihkPTA7ZDxiLmxlbmd0aDtkKyspe2U9Y1tkXS5jb25uZWN0c0FzU291cmNlO2Zvcih2YXIgZj0wO2Y8ZS5sZW5ndGg7ZisrKXt2YXIgZz1lW2ZdLGs9Zy5lZGdlcztpZihudWxsIT1rJiYwPGsubGVuZ3RoKXt2YXIgaz1rWzBdLGw9YS5nZXRWaXNpYmxlVGVybWluYWwoaywhMSksbD10aGlzLnZlcnRleE1hcHBlci5nZXQobCk7Y1tkXT09bCYmKGw9CmEuZ2V0VmlzaWJsZVRlcm1pbmFsKGssITApLGw9dGhpcy52ZXJ0ZXhNYXBwZXIuZ2V0KGwpKTtudWxsIT1sJiZjW2RdIT1sJiYoZy50YXJnZXQ9bCwwPT1sLmNvbm5lY3RzQXNUYXJnZXQubGVuZ3RoJiYobC5jb25uZWN0c0FzVGFyZ2V0PVtdKSwwPm14VXRpbHMuaW5kZXhPZihsLmNvbm5lY3RzQXNUYXJnZXQsZykmJmwuY29ubmVjdHNBc1RhcmdldC5wdXNoKGcpKX19Y1tkXS50ZW1wWzBdPTF9fW14U3dpbWxhbmVNb2RlbC5wcm90b3R5cGUubWF4UmFuaz1udWxsO214U3dpbWxhbmVNb2RlbC5wcm90b3R5cGUudmVydGV4TWFwcGVyPW51bGw7bXhTd2ltbGFuZU1vZGVsLnByb3RvdHlwZS5lZGdlTWFwcGVyPW51bGw7bXhTd2ltbGFuZU1vZGVsLnByb3RvdHlwZS5yYW5rcz1udWxsO214U3dpbWxhbmVNb2RlbC5wcm90b3R5cGUucm9vdHM9bnVsbDtteFN3aW1sYW5lTW9kZWwucHJvdG90eXBlLnBhcmVudD1udWxsO214U3dpbWxhbmVNb2RlbC5wcm90b3R5cGUuZGZzQ291bnQ9MDsKbXhTd2ltbGFuZU1vZGVsLnByb3RvdHlwZS5TT1VSQ0VTQ0FOU1RBUlRSQU5LPTFFODtteFN3aW1sYW5lTW9kZWwucHJvdG90eXBlLnRpZ2h0ZW5Ub1NvdXJjZT0hMTtteFN3aW1sYW5lTW9kZWwucHJvdG90eXBlLnJhbmtzUGVyR3JvdXA9bnVsbDsKbXhTd2ltbGFuZU1vZGVsLnByb3RvdHlwZS5jcmVhdGVJbnRlcm5hbENlbGxzPWZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9YS5nZXRHcmFwaCgpLGU9YS5zd2ltbGFuZXMsZj0wO2Y8Yi5sZW5ndGg7ZisrKXtjW2ZdPW5ldyBteEdyYXBoSGllcmFyY2h5Tm9kZShiW2ZdKTt0aGlzLnZlcnRleE1hcHBlci5wdXQoYltmXSxjW2ZdKTtjW2ZdLnN3aW1sYW5lSW5kZXg9LTE7Zm9yKHZhciBnPTA7ZzxlLmxlbmd0aDtnKyspaWYoZC5tb2RlbC5nZXRQYXJlbnQoYltmXSk9PWVbZ10pe2NbZl0uc3dpbWxhbmVJbmRleD1nO2JyZWFrfWc9YS5nZXRFZGdlcyhiW2ZdKTtjW2ZdLmNvbm5lY3RzQXNTb3VyY2U9W107Zm9yKHZhciBrPTA7azxnLmxlbmd0aDtrKyspe3ZhciBsPWEuZ2V0VmlzaWJsZVRlcm1pbmFsKGdba10sITEpO2lmKGwhPWJbZl0mJmEuZ3JhcGgubW9kZWwuaXNWZXJ0ZXgobCkmJiFhLmlzVmVydGV4SWdub3JlZChsKSl7dmFyIG09YS5nZXRFZGdlc0JldHdlZW4oYltmXSxsLCExKSwKbD1hLmdldEVkZ2VzQmV0d2VlbihiW2ZdLGwsITApO2lmKG51bGwhPW0mJjA8bS5sZW5ndGgmJm51bGw9PXRoaXMuZWRnZU1hcHBlci5nZXQobVswXSkmJjIqbC5sZW5ndGg+PW0ubGVuZ3RoKXtmb3IodmFyIGw9bmV3IG14R3JhcGhIaWVyYXJjaHlFZGdlKG0pLG49MDtuPG0ubGVuZ3RoO24rKyl7dmFyIHA9bVtuXTt0aGlzLmVkZ2VNYXBwZXIucHV0KHAsbCk7ZC5yZXNldEVkZ2UocCk7YS5kaXNhYmxlRWRnZVN0eWxlJiYoYS5zZXRFZGdlU3R5bGVFbmFibGVkKHAsITEpLGEuc2V0T3J0aG9nb25hbEVkZ2UocCwhMCkpfWwuc291cmNlPWNbZl07MD5teFV0aWxzLmluZGV4T2YoY1tmXS5jb25uZWN0c0FzU291cmNlLGwpJiZjW2ZdLmNvbm5lY3RzQXNTb3VyY2UucHVzaChsKX19fWNbZl0udGVtcFswXT0wfX07Cm14U3dpbWxhbmVNb2RlbC5wcm90b3R5cGUuaW5pdGlhbFJhbms9ZnVuY3Rpb24oKXt0aGlzLnJhbmtzUGVyR3JvdXA9W107dmFyIGE9W10sYj17fTtpZihudWxsIT10aGlzLnJvb3RzKWZvcih2YXIgYz0wO2M8dGhpcy5yb290cy5sZW5ndGg7YysrKXt2YXIgZD10aGlzLnZlcnRleE1hcHBlci5nZXQodGhpcy5yb290c1tjXSk7dGhpcy5tYXhDaGFpbkRmcyhudWxsLGQsbnVsbCxiLDApO251bGwhPWQmJmEucHVzaChkKX1kPVtdO2I9W107Zm9yKGM9dGhpcy5yYW5rc1Blckdyb3VwLmxlbmd0aC0xOzA8PWM7Yy0tKWRbY109Yz09dGhpcy5yYW5rc1Blckdyb3VwLmxlbmd0aC0xPzA6YltjKzFdKzEsYltjXT1kW2NdK3RoaXMucmFua3NQZXJHcm91cFtjXTt0aGlzLm1heFJhbms9YlswXTtkPXRoaXMudmVydGV4TWFwcGVyLmdldFZhbHVlcygpO2ZvcihjPTA7YzxkLmxlbmd0aDtjKyspZFtjXS50ZW1wWzBdPS0xO2ZvcihhLnNsaWNlKCk7MDxhLmxlbmd0aDspe3ZhciBkPWFbMF0sZSxmOwplPWQuY29ubmVjdHNBc1RhcmdldDtmPWQuY29ubmVjdHNBc1NvdXJjZTtmb3IodmFyIGc9ITAsaz1iWzBdLGM9MDtjPGUubGVuZ3RoO2MrKyl7dmFyIGw9ZVtjXTtpZig1MjcwNjIwPT1sLnRlbXBbMF0pbD1sLnNvdXJjZSxrPU1hdGgubWluKGssbC50ZW1wWzBdLTEpO2Vsc2V7Zz0hMTticmVha319aWYoZyl7az5iW2Quc3dpbWxhbmVJbmRleF0mJihrPWJbZC5zd2ltbGFuZUluZGV4XSk7ZC50ZW1wWzBdPWs7aWYobnVsbCE9Zilmb3IoYz0wO2M8Zi5sZW5ndGg7YysrKWw9ZltjXSxsLnRlbXBbMF09NTI3MDYyMCxsPWwudGFyZ2V0LC0xPT1sLnRlbXBbMF0mJihhLnB1c2gobCksbC50ZW1wWzBdPS0yKTthLnNoaWZ0KCl9ZWxzZSBpZihjPWEuc2hpZnQoKSxhLnB1c2goZCksYz09ZCYmMT09YS5sZW5ndGgpYnJlYWt9fTsKbXhTd2ltbGFuZU1vZGVsLnByb3RvdHlwZS5tYXhDaGFpbkRmcz1mdW5jdGlvbihhLGIsYyxkLGUpe2lmKG51bGwhPWImJihhPW14Q2VsbFBhdGguY3JlYXRlKGIuY2VsbCksbnVsbD09ZFthXSkpe2RbYV09YjthPWIuc3dpbWxhbmVJbmRleDtpZihudWxsPT10aGlzLnJhbmtzUGVyR3JvdXBbYV18fHRoaXMucmFua3NQZXJHcm91cFthXTxlKXRoaXMucmFua3NQZXJHcm91cFthXT1lO2E9Yi5jb25uZWN0c0FzU291cmNlLnNsaWNlKCk7Zm9yKGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGY9YVtjXSxnPWYudGFyZ2V0O2Iuc3dpbWxhbmVJbmRleDxnLnN3aW1sYW5lSW5kZXg/dGhpcy5tYXhDaGFpbkRmcyhiLGcsZixteFV0aWxzLmNsb25lKGQsbnVsbCwhMCksMCk6Yi5zd2ltbGFuZUluZGV4PT1nLnN3aW1sYW5lSW5kZXgmJnRoaXMubWF4Q2hhaW5EZnMoYixnLGYsbXhVdGlscy5jbG9uZShkLG51bGwsITApLGUrMSl9fX07Cm14U3dpbWxhbmVNb2RlbC5wcm90b3R5cGUuZml4UmFua3M9ZnVuY3Rpb24oKXt2YXIgYT1bXTt0aGlzLnJhbmtzPVtdO2Zvcih2YXIgYj0wO2I8dGhpcy5tYXhSYW5rKzE7YisrKWFbYl09W10sdGhpcy5yYW5rc1tiXT1hW2JdO3ZhciBjPW51bGw7aWYobnVsbCE9dGhpcy5yb290cylmb3IodmFyIGQ9dGhpcy5yb290cyxjPVtdLGI9MDtiPGQubGVuZ3RoO2IrKyl7dmFyIGU9dGhpcy52ZXJ0ZXhNYXBwZXIuZ2V0KGRbYl0pO2NbYl09ZX10aGlzLnZpc2l0KGZ1bmN0aW9uKGIsYyxkLGUsbSl7MD09bSYmMD5jLm1heFJhbmsmJjA+Yy5taW5SYW5rJiYoYVtjLnRlbXBbMF1dLnB1c2goYyksYy5tYXhSYW5rPWMudGVtcFswXSxjLm1pblJhbms9Yy50ZW1wWzBdLGMudGVtcFswXT1hW2MubWF4UmFua10ubGVuZ3RoLTEpO2lmKG51bGwhPWImJm51bGwhPWQmJjE8Yi5tYXhSYW5rLWMubWF4UmFuaylmb3IoZC5tYXhSYW5rPWIubWF4UmFuayxkLm1pblJhbms9Yy5tYXhSYW5rLGQudGVtcD1bXSwKZC54PVtdLGQueT1bXSxiPWQubWluUmFuaysxO2I8ZC5tYXhSYW5rO2IrKylhW2JdLnB1c2goZCksZC5zZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGIsYVtiXS5sZW5ndGgtMSl9LGMsITEsbnVsbCl9O214U3dpbWxhbmVNb2RlbC5wcm90b3R5cGUudmlzaXQ9ZnVuY3Rpb24oYSxiLGMsZCl7aWYobnVsbCE9Yil7Zm9yKHZhciBlPTA7ZTxiLmxlbmd0aDtlKyspe3ZhciBmPWJbZV07bnVsbCE9ZiYmKG51bGw9PWQmJihkPXt9KSxjPyhmLmhhc2hDb2RlPVtdLGYuaGFzaENvZGVbMF09dGhpcy5kZnNDb3VudCxmLmhhc2hDb2RlWzFdPWUsdGhpcy5leHRlbmRlZERmcyhudWxsLGYsbnVsbCxhLGQsZi5oYXNoQ29kZSxlLDApKTp0aGlzLmRmcyhudWxsLGYsbnVsbCxhLGQsMCkpfXRoaXMuZGZzQ291bnQrK319OwpteFN3aW1sYW5lTW9kZWwucHJvdG90eXBlLmRmcz1mdW5jdGlvbihhLGIsYyxkLGUsZil7aWYobnVsbCE9Yil7dmFyIGc9Yi5pZDtpZihudWxsPT1lW2ddKWZvcihlW2ddPWIsZChhLGIsYyxmLDApLGE9Yi5jb25uZWN0c0FzU291cmNlLnNsaWNlKCksYz0wO2M8YS5sZW5ndGg7YysrKWc9YVtjXSx0aGlzLmRmcyhiLGcudGFyZ2V0LGcsZCxlLGYrMSk7ZWxzZSBkKGEsYixjLGYsMSl9fTsKbXhTd2ltbGFuZU1vZGVsLnByb3RvdHlwZS5leHRlbmRlZERmcz1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGspe2lmKG51bGwhPWIpaWYobnVsbD09YXx8bnVsbCE9Yi5oYXNoQ29kZSYmYi5oYXNoQ29kZVswXT09YS5oYXNoQ29kZVswXXx8KGY9YS5oYXNoQ29kZS5sZW5ndGgrMSxiLmhhc2hDb2RlPWEuaGFzaENvZGUuc2xpY2UoKSxiLmhhc2hDb2RlW2YtMV09ZyksZz1iLmlkLG51bGw9PWVbZ10pe2VbZ109YjtkKGEsYixjLGssMCk7YT1iLmNvbm5lY3RzQXNTb3VyY2Uuc2xpY2UoKTtjPWIuY29ubmVjdHNBc1RhcmdldC5zbGljZSgpO2ZvcihnPTA7ZzxhLmxlbmd0aDtnKyspe2Y9YVtnXTt2YXIgbD1mLnRhcmdldDtiLnN3aW1sYW5lSW5kZXg8PWwuc3dpbWxhbmVJbmRleCYmdGhpcy5leHRlbmRlZERmcyhiLGwsZixkLGUsYi5oYXNoQ29kZSxnLGsrMSl9Zm9yKGc9MDtnPGMubGVuZ3RoO2crKylmPWNbZ10sbD1mLnNvdXJjZSxiLnN3aW1sYW5lSW5kZXg8bC5zd2ltbGFuZUluZGV4JiYKdGhpcy5leHRlbmRlZERmcyhiLGwsZixkLGUsYi5oYXNoQ29kZSxnLGsrMSl9ZWxzZSBkKGEsYixjLGssMSl9O2Z1bmN0aW9uIG14SGllcmFyY2hpY2FsTGF5b3V0U3RhZ2UoKXt9bXhIaWVyYXJjaGljYWxMYXlvdXRTdGFnZS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihhKXt9O2Z1bmN0aW9uIG14TWVkaWFuSHlicmlkQ3Jvc3NpbmdSZWR1Y3Rpb24oYSl7dGhpcy5sYXlvdXQ9YX1teE1lZGlhbkh5YnJpZENyb3NzaW5nUmVkdWN0aW9uLnByb3RvdHlwZT1uZXcgbXhIaWVyYXJjaGljYWxMYXlvdXRTdGFnZTtteE1lZGlhbkh5YnJpZENyb3NzaW5nUmVkdWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1teE1lZGlhbkh5YnJpZENyb3NzaW5nUmVkdWN0aW9uO214TWVkaWFuSHlicmlkQ3Jvc3NpbmdSZWR1Y3Rpb24ucHJvdG90eXBlLmxheW91dD1udWxsO214TWVkaWFuSHlicmlkQ3Jvc3NpbmdSZWR1Y3Rpb24ucHJvdG90eXBlLm1heEl0ZXJhdGlvbnM9MjQ7Cm14TWVkaWFuSHlicmlkQ3Jvc3NpbmdSZWR1Y3Rpb24ucHJvdG90eXBlLm5lc3RlZEJlc3RSYW5rcz1udWxsO214TWVkaWFuSHlicmlkQ3Jvc3NpbmdSZWR1Y3Rpb24ucHJvdG90eXBlLmN1cnJlbnRCZXN0Q3Jvc3NpbmdzPTA7bXhNZWRpYW5IeWJyaWRDcm9zc2luZ1JlZHVjdGlvbi5wcm90b3R5cGUuaXRlcmF0aW9uc1dpdGhvdXRJbXByb3ZlbWVudD0wO214TWVkaWFuSHlicmlkQ3Jvc3NpbmdSZWR1Y3Rpb24ucHJvdG90eXBlLm1heE5vSW1wcm92ZW1lbnRJdGVyYXRpb25zPTI7Cm14TWVkaWFuSHlicmlkQ3Jvc3NpbmdSZWR1Y3Rpb24ucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oYSl7YT10aGlzLmxheW91dC5nZXRNb2RlbCgpO3RoaXMubmVzdGVkQmVzdFJhbmtzPVtdO2Zvcih2YXIgYj0wO2I8YS5yYW5rcy5sZW5ndGg7YisrKXRoaXMubmVzdGVkQmVzdFJhbmtzW2JdPWEucmFua3NbYl0uc2xpY2UoKTtmb3IodmFyIGM9MCxkPXRoaXMuY2FsY3VsYXRlQ3Jvc3NpbmdzKGEpLGI9MDtiPHRoaXMubWF4SXRlcmF0aW9ucyYmYzx0aGlzLm1heE5vSW1wcm92ZW1lbnRJdGVyYXRpb25zO2IrKyl7dGhpcy53ZWlnaHRlZE1lZGlhbihiLGEpO3RoaXMudHJhbnNwb3NlKGIsYSk7dmFyIGU9dGhpcy5jYWxjdWxhdGVDcm9zc2luZ3MoYSk7aWYoZTxkKWZvcihkPWUsZT1jPTA7ZTx0aGlzLm5lc3RlZEJlc3RSYW5rcy5sZW5ndGg7ZSsrKWZvcih2YXIgZj1hLnJhbmtzW2VdLGc9MDtnPGYubGVuZ3RoO2crKyl7dmFyIGs9ZltnXTt0aGlzLm5lc3RlZEJlc3RSYW5rc1tlXVtrLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoZSldPQprfWVsc2UgZm9yKGMrKyxlPTA7ZTx0aGlzLm5lc3RlZEJlc3RSYW5rcy5sZW5ndGg7ZSsrKWZvcihmPWEucmFua3NbZV0sZz0wO2c8Zi5sZW5ndGg7ZysrKWs9ZltnXSxrLnNldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoZSxnKTtpZigwPT1kKWJyZWFrfWM9W107ZD1bXTtmb3IoYj0wO2I8YS5tYXhSYW5rKzE7YisrKWRbYl09W10sY1tiXT1kW2JdO2ZvcihiPTA7Yjx0aGlzLm5lc3RlZEJlc3RSYW5rcy5sZW5ndGg7YisrKWZvcihlPTA7ZTx0aGlzLm5lc3RlZEJlc3RSYW5rc1tiXS5sZW5ndGg7ZSsrKWRbYl0ucHVzaCh0aGlzLm5lc3RlZEJlc3RSYW5rc1tiXVtlXSk7YS5yYW5rcz1jfTtteE1lZGlhbkh5YnJpZENyb3NzaW5nUmVkdWN0aW9uLnByb3RvdHlwZS5jYWxjdWxhdGVDcm9zc2luZ3M9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPWEucmFua3MubGVuZ3RoLGM9MCxkPTE7ZDxiO2QrKyljKz10aGlzLmNhbGN1bGF0ZVJhbmtDcm9zc2luZyhkLGEpO3JldHVybiBjfTsKbXhNZWRpYW5IeWJyaWRDcm9zc2luZ1JlZHVjdGlvbi5wcm90b3R5cGUuY2FsY3VsYXRlUmFua0Nyb3NzaW5nPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTAsZD1iLnJhbmtzW2FdLGU9Yi5yYW5rc1thLTFdLGY9W10sZz0wO2c8ZC5sZW5ndGg7ZysrKXtmb3IodmFyIGs9ZFtnXSxsPWsuZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShhKSxrPWsuZ2V0UHJldmlvdXNMYXllckNvbm5lY3RlZENlbGxzKGEpLG09W10sbj0wO248ay5sZW5ndGg7bisrKXt2YXIgcD1rW25dLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoYS0xKTttLnB1c2gocCl9bS5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEtYn0pO2ZbbF09bX1kPVtdO2ZvcihnPTA7ZzxmLmxlbmd0aDtnKyspZD1kLmNvbmNhdChmW2ddKTtmb3IoZj0xO2Y8ZS5sZW5ndGg7KWY8PD0xO2w9MipmLTE7LS1mO2U9W107Zm9yKGc9MDtnPGw7KytnKWVbZ109MDtmb3IoZz0wO2c8ZC5sZW5ndGg7ZysrKWZvcihsPWRbZ10rZiwrK2VbbF07MDwKbDspbCUyJiYoYys9ZVtsKzFdKSxsPWwtMT4+MSwrK2VbbF07cmV0dXJuIGN9OwpteE1lZGlhbkh5YnJpZENyb3NzaW5nUmVkdWN0aW9uLnByb3RvdHlwZS50cmFuc3Bvc2U9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9ITAsZD0wO2MmJjEwPmQrKzspZm9yKHZhciBlPTE9PWElMiYmMT09ZCUyLGM9ITEsZj0wO2Y8Yi5yYW5rcy5sZW5ndGg7ZisrKXtmb3IodmFyIGc9Yi5yYW5rc1tmXSxrPVtdLGw9MDtsPGcubGVuZ3RoO2wrKyl7dmFyIG09Z1tsXSxuPW0uZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShmKTswPm4mJihuPWwpO2tbbl09bX1mb3IodmFyIHA9bnVsbCxxPW51bGwscix0LHU9bnVsbCx4PW51bGwseSxCPW51bGwsbD0wO2w8Zy5sZW5ndGgtMTtsKyspe2lmKDA9PWwpe3k9a1tsXTttPXkuZ2V0TmV4dExheWVyQ29ubmVjdGVkQ2VsbHMoZik7bj15LmdldFByZXZpb3VzTGF5ZXJDb25uZWN0ZWRDZWxscyhmKTtyPVtdO3Q9W107Zm9yKHZhciBBPTA7QTxtLmxlbmd0aDtBKyspcltBXT1tW0FdLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoZisxKTtmb3IoQT0KMDtBPG4ubGVuZ3RoO0ErKyl0W0FdPW5bQV0uZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShmLTEpfWVsc2UgbT1wLG49cSxyPXUsdD14LHk9QjtCPWtbbCsxXTtwPUIuZ2V0TmV4dExheWVyQ29ubmVjdGVkQ2VsbHMoZik7cT1CLmdldFByZXZpb3VzTGF5ZXJDb25uZWN0ZWRDZWxscyhmKTt1PVtdO3g9W107Zm9yKEE9MDtBPHAubGVuZ3RoO0ErKyl1W0FdPXBbQV0uZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShmKzEpO2ZvcihBPTA7QTxxLmxlbmd0aDtBKyspeFtBXT1xW0FdLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoZi0xKTtmb3IodmFyIHo9MCxDPTAsQT0wO0E8ci5sZW5ndGg7QSsrKWZvcih2YXIgdj0wO3Y8dS5sZW5ndGg7disrKXJbQV0+dVt2XSYmeisrLHJbQV08dVt2XSYmQysrO2ZvcihBPTA7QTx0Lmxlbmd0aDtBKyspZm9yKHY9MDt2PHgubGVuZ3RoO3YrKyl0W0FdPnhbdl0mJnorKyx0W0FdPHhbdl0mJkMrKztpZihDPHp8fEM9PXomJmUpcD15LmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoZiksCnkuc2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShmLEIuZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShmKSksQi5zZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGYscCkscD1tLHE9bix1PXIseD10LEI9eSxlfHwoYz0hMCl9fX07bXhNZWRpYW5IeWJyaWRDcm9zc2luZ1JlZHVjdGlvbi5wcm90b3R5cGUud2VpZ2h0ZWRNZWRpYW49ZnVuY3Rpb24oYSxiKXt2YXIgYz0wPT1hJTI7aWYoYylmb3IodmFyIGQ9Yi5tYXhSYW5rLTE7MDw9ZDtkLS0pdGhpcy5tZWRpYW5SYW5rKGQsYyk7ZWxzZSBmb3IoZD0xO2Q8Yi5tYXhSYW5rO2QrKyl0aGlzLm1lZGlhblJhbmsoZCxjKX07Cm14TWVkaWFuSHlicmlkQ3Jvc3NpbmdSZWR1Y3Rpb24ucHJvdG90eXBlLm1lZGlhblJhbms9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9dGhpcy5uZXN0ZWRCZXN0UmFua3NbYV0ubGVuZ3RoLGQ9W10sZT1bXSxmPTA7ZjxjO2YrKyl7dmFyIGc9dGhpcy5uZXN0ZWRCZXN0UmFua3NbYV1bZl0saz1uZXcgTWVkaWFuQ2VsbFNvcnRlcjtrLmNlbGw9Zzt2YXIgbDtsPWI/Zy5nZXROZXh0TGF5ZXJDb25uZWN0ZWRDZWxscyhhKTpnLmdldFByZXZpb3VzTGF5ZXJDb25uZWN0ZWRDZWxscyhhKTt2YXIgbTttPWI/YSsxOmEtMTtudWxsIT1sJiYwIT1sLmxlbmd0aD8oay5tZWRpYW5WYWx1ZT10aGlzLm1lZGlhblZhbHVlKGwsbSksZC5wdXNoKGspKTplW2cuZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShhKV09ITB9ZC5zb3J0KE1lZGlhbkNlbGxTb3J0ZXIucHJvdG90eXBlLmNvbXBhcmUpO2ZvcihmPTA7ZjxjO2YrKyludWxsPT1lW2ZdJiYoZz1kLnNoaWZ0KCkuY2VsbCxnLnNldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoYSwKZikpfTtteE1lZGlhbkh5YnJpZENyb3NzaW5nUmVkdWN0aW9uLnByb3RvdHlwZS5tZWRpYW5WYWx1ZT1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1bXSxkPTAsZT0wO2U8YS5sZW5ndGg7ZSsrKXt2YXIgZj1hW2VdO2NbZCsrXT1mLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoYil9Yy5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEtYn0pO2lmKDE9PWQlMilyZXR1cm4gY1tNYXRoLmZsb29yKGQvMildO2lmKDI9PWQpcmV0dXJuKGNbMF0rY1sxXSkvMjtlPWQvMjtmPWNbZS0xXS1jWzBdO2Q9Y1tkLTFdLWNbZV07cmV0dXJuKGNbZS0xXSpkK2NbZV0qZikvKGYrZCl9O2Z1bmN0aW9uIE1lZGlhbkNlbGxTb3J0ZXIoKXt9TWVkaWFuQ2VsbFNvcnRlci5wcm90b3R5cGUubWVkaWFuVmFsdWU9MDtNZWRpYW5DZWxsU29ydGVyLnByb3RvdHlwZS5jZWxsPSExOwpNZWRpYW5DZWxsU29ydGVyLnByb3RvdHlwZS5jb21wYXJlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG51bGwhPWEmJm51bGwhPWI/Yi5tZWRpYW5WYWx1ZT5hLm1lZGlhblZhbHVlPy0xOmIubWVkaWFuVmFsdWU8YS5tZWRpYW5WYWx1ZT8xOjA6MH07ZnVuY3Rpb24gbXhNaW5pbXVtQ3ljbGVSZW1vdmVyKGEpe3RoaXMubGF5b3V0PWF9bXhNaW5pbXVtQ3ljbGVSZW1vdmVyLnByb3RvdHlwZT1uZXcgbXhIaWVyYXJjaGljYWxMYXlvdXRTdGFnZTtteE1pbmltdW1DeWNsZVJlbW92ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14TWluaW11bUN5Y2xlUmVtb3ZlcjtteE1pbmltdW1DeWNsZVJlbW92ZXIucHJvdG90eXBlLmxheW91dD1udWxsOwpteE1pbmltdW1DeWNsZVJlbW92ZXIucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oYSl7YT10aGlzLmxheW91dC5nZXRNb2RlbCgpO2Zvcih2YXIgYj17fSxjPWEudmVydGV4TWFwcGVyLmdldFZhbHVlcygpLGQ9e30sZT0wO2U8Yy5sZW5ndGg7ZSsrKWRbY1tlXS5pZF09Y1tlXTtjPW51bGw7aWYobnVsbCE9YS5yb290cylmb3IodmFyIGY9YS5yb290cyxjPVtdLGU9MDtlPGYubGVuZ3RoO2UrKyljW2VdPWEudmVydGV4TWFwcGVyLmdldChmW2VdKTthLnZpc2l0KGZ1bmN0aW9uKGEsYyxlLGYsbil7Yy5pc0FuY2VzdG9yKGEpJiYoZS5pbnZlcnQoKSxteFV0aWxzLnJlbW92ZShlLGEuY29ubmVjdHNBc1NvdXJjZSksYS5jb25uZWN0c0FzVGFyZ2V0LnB1c2goZSksbXhVdGlscy5yZW1vdmUoZSxjLmNvbm5lY3RzQXNUYXJnZXQpLGMuY29ubmVjdHNBc1NvdXJjZS5wdXNoKGUpKTtiW2MuaWRdPWM7ZGVsZXRlIGRbYy5pZF19LGMsITAsbnVsbCk7ZT1teFV0aWxzLmNsb25lKGIsbnVsbCwKITApO2EudmlzaXQoZnVuY3Rpb24oYSxjLGUsZixuKXtjLmlzQW5jZXN0b3IoYSkmJihlLmludmVydCgpLG14VXRpbHMucmVtb3ZlKGUsYS5jb25uZWN0c0FzU291cmNlKSxjLmNvbm5lY3RzQXNTb3VyY2UucHVzaChlKSxhLmNvbm5lY3RzQXNUYXJnZXQucHVzaChlKSxteFV0aWxzLnJlbW92ZShlLGMuY29ubmVjdHNBc1RhcmdldCkpO2JbYy5pZF09YztkZWxldGUgZFtjLmlkXX0sZCwhMCxlKX07ZnVuY3Rpb24gbXhDb29yZGluYXRlQXNzaWdubWVudChhLGIsYyxkLGUsZil7dGhpcy5sYXlvdXQ9YTt0aGlzLmludHJhQ2VsbFNwYWNpbmc9Yjt0aGlzLmludGVyUmFua0NlbGxTcGFjaW5nPWM7dGhpcy5vcmllbnRhdGlvbj1kO3RoaXMuaW5pdGlhbFg9ZTt0aGlzLnBhcmFsbGVsRWRnZVNwYWNpbmc9Zn1teENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZT1uZXcgbXhIaWVyYXJjaGljYWxMYXlvdXRTdGFnZTsKbXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhDb29yZGluYXRlQXNzaWdubWVudDtteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5sYXlvdXQ9bnVsbDtteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5pbnRyYUNlbGxTcGFjaW5nPTMwO214Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLmludGVyUmFua0NlbGxTcGFjaW5nPTEwMDtteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5wYXJhbGxlbEVkZ2VTcGFjaW5nPTEwO214Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLm1heEl0ZXJhdGlvbnM9ODtteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5wcmVmSG96RWRnZVNlcD01O214Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLnByZWZWZXJ0RWRnZU9mZj0yO214Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLm1pbkVkZ2VKZXR0eT0xMjsKbXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGUuY2hhbm5lbEJ1ZmZlcj00O214Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLmpldHR5UG9zaXRpb25zPW51bGw7bXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGUub3JpZW50YXRpb249bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIO214Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLmluaXRpYWxYPW51bGw7bXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGUubGltaXRYPW51bGw7bXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGUuY3VycmVudFhEZWx0YT1udWxsO214Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLndpZGVzdFJhbms9bnVsbDtteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5yYW5rVG9wWT1udWxsO214Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLnJhbmtCb3R0b21ZPW51bGw7Cm14Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLndpZGVzdFJhbmtWYWx1ZT1udWxsO214Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLnJhbmtXaWR0aHM9bnVsbDtteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5yYW5rWT1udWxsO214Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLmZpbmVUdW5pbmc9ITA7bXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGUubmV4dExheWVyQ29ubmVjdGVkQ2FjaGU9bnVsbDtteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5wcmV2aW91c0xheWVyQ29ubmVjdGVkQ2FjaGU9bnVsbDtteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5ncm91cFBhZGRpbmc9MTA7Cm14Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLnByaW50U3RhdHVzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5sYXlvdXQuZ2V0TW9kZWwoKTtteExvZy5zaG93KCk7bXhMb2cud3JpdGVsbigiPT09PT09Q29vcmQgYXNzaWdubWVudCBkZWJ1Zz09PT09PT0iKTtmb3IodmFyIGI9MDtiPGEucmFua3MubGVuZ3RoO2IrKyl7bXhMb2cud3JpdGUoIlJhbmsgIixiLCIgOiAiKTtmb3IodmFyIGM9YS5yYW5rc1tiXSxkPTA7ZDxjLmxlbmd0aDtkKyspbXhMb2cud3JpdGUoY1tkXS5nZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGIpLCIgICIpO214TG9nLndyaXRlbG4oKX1teExvZy53cml0ZWxuKCI9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0iKX07Cm14Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oYSl7dGhpcy5qZXR0eVBvc2l0aW9ucz17fTthPXRoaXMubGF5b3V0LmdldE1vZGVsKCk7dGhpcy5jdXJyZW50WERlbHRhPTA7dGhpcy5pbml0aWFsQ29vcmRzKHRoaXMubGF5b3V0LmdldEdyYXBoKCksYSk7dGhpcy5maW5lVHVuaW5nJiZ0aGlzLm1pbk5vZGUoYSk7dmFyIGI9MUU4O2lmKHRoaXMuZmluZVR1bmluZylmb3IodmFyIGM9MDtjPHRoaXMubWF4SXRlcmF0aW9ucztjKyspezAhPWMmJih0aGlzLm1lZGlhblBvcyhjLGEpLHRoaXMubWluTm9kZShhKSk7aWYodGhpcy5jdXJyZW50WERlbHRhPGIpe2Zvcih2YXIgZD0wO2Q8YS5yYW5rcy5sZW5ndGg7ZCsrKWZvcih2YXIgZT1hLnJhbmtzW2RdLGY9MDtmPGUubGVuZ3RoO2YrKyl7dmFyIGc9ZVtmXTtnLnNldFgoZCxnLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoZCkpfWI9dGhpcy5jdXJyZW50WERlbHRhfWVsc2UgZm9yKGQ9MDtkPGEucmFua3MubGVuZ3RoO2QrKylmb3IoZT0KYS5yYW5rc1tkXSxmPTA7ZjxlLmxlbmd0aDtmKyspZz1lW2ZdLGcuc2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShkLGcuZ2V0WChkKSk7dGhpcy5taW5QYXRoKHRoaXMubGF5b3V0LmdldEdyYXBoKCksYSk7dGhpcy5jdXJyZW50WERlbHRhPTB9dGhpcy5zZXRDZWxsTG9jYXRpb25zKHRoaXMubGF5b3V0LmdldEdyYXBoKCksYSl9OwpteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5taW5Ob2RlPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1bXSxjPW5ldyBteERpY3Rpb25hcnksZD1bXSxlPTA7ZTw9YS5tYXhSYW5rO2UrKyl7ZFtlXT1hLnJhbmtzW2VdO2Zvcih2YXIgZj0wO2Y8ZFtlXS5sZW5ndGg7ZisrKXt2YXIgZz1kW2VdW2ZdLGs9bmV3IFdlaWdodGVkQ2VsbFNvcnRlcihnLGUpO2sucmFua0luZGV4PWY7ay52aXNpdGVkPSEwO2IucHVzaChrKTtjLnB1dChnLGspfX1hPTEwKmIubGVuZ3RoO2ZvcihmPTA7MDxiLmxlbmd0aCYmZjw9YTspe3ZhciBnPWIuc2hpZnQoKSxlPWcuY2VsbCxsPWcud2VpZ2h0ZWRWYWx1ZSxtPXBhcnNlSW50KGcucmFua0luZGV4KSxrPWUuZ2V0TmV4dExheWVyQ29ubmVjdGVkQ2VsbHMobCksbj1lLmdldFByZXZpb3VzTGF5ZXJDb25uZWN0ZWRDZWxscyhsKSxwPWsubGVuZ3RoLHE9bi5sZW5ndGgscj10aGlzLm1lZGlhblhWYWx1ZShrLGwrMSksdD10aGlzLm1lZGlhblhWYWx1ZShuLApsLTEpLHU9cCtxLHg9ZS5nZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGwpLHk9eDswPHUmJih5PShyKnArdCpxKS91KTtwPSExO3k8eC0xPzA9PW0/KGUuc2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShsLHkpLHA9ITApOihtPWRbbF1bbS0xXSx4PW0uZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShsKSx4PXgrbS53aWR0aC8yK3RoaXMuaW50cmFDZWxsU3BhY2luZytlLndpZHRoLzIseDx5PyhlLnNldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUobCx5KSxwPSEwKTp4PGUuZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShsKS0xJiYoZS5zZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGwseCkscD0hMCkpOnk+eCsxJiYobT09ZFtsXS5sZW5ndGgtMT8oZS5zZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGwseSkscD0hMCk6KG09ZFtsXVttKzFdLHg9bS5nZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGwpLHg9eC1tLndpZHRoLzItdGhpcy5pbnRyYUNlbGxTcGFjaW5nLWUud2lkdGgvMix4Pnk/KGUuc2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShsLAp5KSxwPSEwKTp4PmUuZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShsKSsxJiYoZS5zZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGwseCkscD0hMCkpKTtpZihwKXtmb3IoZT0wO2U8ay5sZW5ndGg7ZSsrKWw9a1tlXSxsPWMuZ2V0KGwpLG51bGwhPWwmJjA9PWwudmlzaXRlZCYmKGwudmlzaXRlZD0hMCxiLnB1c2gobCkpO2ZvcihlPTA7ZTxuLmxlbmd0aDtlKyspbD1uW2VdLGw9Yy5nZXQobCksbnVsbCE9bCYmMD09bC52aXNpdGVkJiYobC52aXNpdGVkPSEwLGIucHVzaChsKSl9Zy52aXNpdGVkPSExO2YrK319O214Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLm1lZGlhblBvcz1mdW5jdGlvbihhLGIpe2lmKDA9PWElMilmb3IodmFyIGM9Yi5tYXhSYW5rOzA8YztjLS0pdGhpcy5yYW5rTWVkaWFuUG9zaXRpb24oYy0xLGIsYyk7ZWxzZSBmb3IoYz0wO2M8Yi5tYXhSYW5rLTE7YysrKXRoaXMucmFua01lZGlhblBvc2l0aW9uKGMrMSxiLGMpfTsKbXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGUucmFua01lZGlhblBvc2l0aW9uPWZ1bmN0aW9uKGEsYixjKXtiPWIucmFua3NbYV07Zm9yKHZhciBkPVtdLGU9e30sZj0wO2Y8Yi5sZW5ndGg7ZisrKXt2YXIgZz1iW2ZdO2RbZl09bmV3IFdlaWdodGVkQ2VsbFNvcnRlcjtkW2ZdLmNlbGw9ZztkW2ZdLnJhbmtJbmRleD1mO2VbZy5pZF09ZFtmXTt2YXIgaztrPWM8YT9nLmdldFByZXZpb3VzTGF5ZXJDb25uZWN0ZWRDZWxscyhhKTpnLmdldE5leHRMYXllckNvbm5lY3RlZENlbGxzKGEpO2RbZl0ud2VpZ2h0ZWRWYWx1ZT10aGlzLmNhbGN1bGF0ZWRXZWlnaHRlZFZhbHVlKGcsayl9ZC5zb3J0KFdlaWdodGVkQ2VsbFNvcnRlci5wcm90b3R5cGUuY29tcGFyZSk7Zm9yKGY9MDtmPGQubGVuZ3RoO2YrKyl7dmFyIGwsZz1kW2ZdLmNlbGw7bD0wO2s9YzxhP2cuZ2V0UHJldmlvdXNMYXllckNvbm5lY3RlZENlbGxzKGEpLnNsaWNlKCk6Zy5nZXROZXh0TGF5ZXJDb25uZWN0ZWRDZWxscyhhKS5zbGljZSgpOwpudWxsIT1rJiYobD1rLmxlbmd0aCxsPTA8bD90aGlzLm1lZGlhblhWYWx1ZShrLGMpOmcuZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShhKSk7dmFyIG09MDtrPS0xRTg7Zm9yKHZhciBuPWRbZl0ucmFua0luZGV4LTE7MDw9bjspe3ZhciBwPWVbYltuXS5pZF07aWYobnVsbCE9cCl7dmFyIHE9cC5jZWxsO3AudmlzaXRlZD8oaz1xLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoYSkrcS53aWR0aC8yK3RoaXMuaW50cmFDZWxsU3BhY2luZyttK2cud2lkdGgvMixuPS0xKToobSs9cS53aWR0aCt0aGlzLmludHJhQ2VsbFNwYWNpbmcsbi0tKX19bT0wO3E9MUU4O2ZvcihuPWRbZl0ucmFua0luZGV4KzE7bjxkLmxlbmd0aDspaWYocD1lW2Jbbl0uaWRdLG51bGwhPXApe3ZhciByPXAuY2VsbDtwLnZpc2l0ZWQ/KHE9ci5nZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGEpLXIud2lkdGgvMi10aGlzLmludHJhQ2VsbFNwYWNpbmctbS1nLndpZHRoLzIsbj1kLmxlbmd0aCk6KG0rPXIud2lkdGgrCnRoaXMuaW50cmFDZWxsU3BhY2luZyxuKyspfWw+PWsmJmw8PXE/Zy5zZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGEsbCk6bDxrPyhnLnNldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoYSxrKSx0aGlzLmN1cnJlbnRYRGVsdGErPWstbCk6bD5xJiYoZy5zZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGEscSksdGhpcy5jdXJyZW50WERlbHRhKz1sLXEpO2RbZl0udmlzaXRlZD0hMH19O214Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLmNhbGN1bGF0ZWRXZWlnaHRlZFZhbHVlPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTAsZD0wO2Q8Yi5sZW5ndGg7ZCsrKXt2YXIgZT1iW2RdO2EuaXNWZXJ0ZXgoKSYmZS5pc1ZlcnRleCgpP2MrKzpjPWEuaXNFZGdlKCkmJmUuaXNFZGdlKCk/Yys4OmMrMn1yZXR1cm4gY307Cm14Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLm1lZGlhblhWYWx1ZT1mdW5jdGlvbihhLGIpe2lmKDA9PWEubGVuZ3RoKXJldHVybiAwO2Zvcih2YXIgYz1bXSxkPTA7ZDxhLmxlbmd0aDtkKyspY1tkXT1hW2RdLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoYik7Yy5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEtYn0pO2lmKDE9PWEubGVuZ3RoJTIpcmV0dXJuIGNbTWF0aC5mbG9vcihhLmxlbmd0aC8yKV07ZD1hLmxlbmd0aC8yO3JldHVybihjW2QtMV0rY1tkXSkvMn07Cm14Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLmluaXRpYWxDb29yZHM9ZnVuY3Rpb24oYSxiKXt0aGlzLmNhbGN1bGF0ZVdpZGVzdFJhbmsoYSxiKTtmb3IodmFyIGM9dGhpcy53aWRlc3RSYW5rOzA8PWM7Yy0tKWM8Yi5tYXhSYW5rJiZ0aGlzLnJhbmtDb29yZGluYXRlcyhjLGEsYik7Zm9yKGM9dGhpcy53aWRlc3RSYW5rKzE7Yzw9Yi5tYXhSYW5rO2MrKykwPGMmJnRoaXMucmFua0Nvb3JkaW5hdGVzKGMsYSxiKX07Cm14Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLnJhbmtDb29yZGluYXRlcz1mdW5jdGlvbihhLGIsYyl7Yj1jLnJhbmtzW2FdO2M9dGhpcy5pbml0aWFsWCsodGhpcy53aWRlc3RSYW5rVmFsdWUtdGhpcy5yYW5rV2lkdGhzW2FdKS8yO2Zvcih2YXIgZD0hMSxlPTA7ZTxiLmxlbmd0aDtlKyspe3ZhciBmPWJbZV07aWYoZi5pc1ZlcnRleCgpKXt2YXIgZz10aGlzLmxheW91dC5nZXRWZXJ0ZXhCb3VuZHMoZi5jZWxsKTtudWxsIT1nP3RoaXMub3JpZW50YXRpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSHx8dGhpcy5vcmllbnRhdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIPyhmLndpZHRoPWcud2lkdGgsZi5oZWlnaHQ9Zy5oZWlnaHQpOihmLndpZHRoPWcuaGVpZ2h0LGYuaGVpZ2h0PWcud2lkdGgpOmQ9ITB9ZWxzZSBmLmlzRWRnZSgpJiYoZz0xLG51bGwhPWYuZWRnZXM/Zz1mLmVkZ2VzLmxlbmd0aDpteExvZy53YXJuKCJlZGdlLmVkZ2VzIGlzIG51bGwiKSwKZi53aWR0aD0oZy0xKSp0aGlzLnBhcmFsbGVsRWRnZVNwYWNpbmcpO2MrPWYud2lkdGgvMjtmLnNldFgoYSxjKTtmLnNldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoYSxjKTtjKz1mLndpZHRoLzI7Yys9dGhpcy5pbnRyYUNlbGxTcGFjaW5nfTE9PWQmJm14TG9nLndhcm4oIkF0IGxlYXN0IG9uZSBjZWxsIGhhcyBubyBib3VuZHMiKX07Cm14Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLmNhbGN1bGF0ZVdpZGVzdFJhbms9ZnVuY3Rpb24oYSxiKXt2YXIgYz0tdGhpcy5pbnRlclJhbmtDZWxsU3BhY2luZyxkPTA7dGhpcy5yYW5rV2lkdGhzPVtdO3RoaXMucmFua1k9W107Zm9yKHZhciBlPWIubWF4UmFuazswPD1lO2UtLSl7Zm9yKHZhciBmPTAsZz1iLnJhbmtzW2VdLGs9dGhpcy5pbml0aWFsWCxsPSExLG09MDttPGcubGVuZ3RoO20rKyl7dmFyIG49Z1ttXTtpZihuLmlzVmVydGV4KCkpe3ZhciBwPXRoaXMubGF5b3V0LmdldFZlcnRleEJvdW5kcyhuLmNlbGwpO251bGwhPXA/dGhpcy5vcmllbnRhdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIfHx0aGlzLm9yaWVudGF0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEg/KG4ud2lkdGg9cC53aWR0aCxuLmhlaWdodD1wLmhlaWdodCk6KG4ud2lkdGg9cC5oZWlnaHQsbi5oZWlnaHQ9cC53aWR0aCk6bD0hMDtmPU1hdGgubWF4KGYsbi5oZWlnaHQpfWVsc2Ugbi5pc0VkZ2UoKSYmCihwPTEsbnVsbCE9bi5lZGdlcz9wPW4uZWRnZXMubGVuZ3RoOm14TG9nLndhcm4oImVkZ2UuZWRnZXMgaXMgbnVsbCIpLG4ud2lkdGg9KHAtMSkqdGhpcy5wYXJhbGxlbEVkZ2VTcGFjaW5nKTtrKz1uLndpZHRoLzI7bi5zZXRYKGUsayk7bi5zZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGUsayk7ays9bi53aWR0aC8yO2srPXRoaXMuaW50cmFDZWxsU3BhY2luZztrPnRoaXMud2lkZXN0UmFua1ZhbHVlJiYodGhpcy53aWRlc3RSYW5rVmFsdWU9ayx0aGlzLndpZGVzdFJhbms9ZSk7dGhpcy5yYW5rV2lkdGhzW2VdPWt9MT09bCYmbXhMb2cud2FybigiQXQgbGVhc3Qgb25lIGNlbGwgaGFzIG5vIGJvdW5kcyIpO3RoaXMucmFua1lbZV09YztrPWYvMitkLzIrdGhpcy5pbnRlclJhbmtDZWxsU3BhY2luZztkPWY7Yz10aGlzLm9yaWVudGF0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEh8fHRoaXMub3JpZW50YXRpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUP2MrazpjLQprO2ZvcihtPTA7bTxnLmxlbmd0aDttKyspZ1ttXS5zZXRZKGUsYyl9fTsKbXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGUubWluUGF0aD1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1iLmVkZ2VNYXBwZXIuZ2V0VmFsdWVzKCksZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1jW2RdO2lmKCEoMT5lLm1heFJhbmstZS5taW5SYW5rLTEpKXtmb3IodmFyIGY9ZS5nZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGUubWluUmFuaysxKSxnPSEwLGs9MCxsPWUubWluUmFuaysyO2w8ZS5tYXhSYW5rO2wrKyl7dmFyIG09ZS5nZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGwpO2YhPW0/KGc9ITEsZj1tKTprKyt9aWYoIWcpe2Zvcih2YXIgZz1mPTAsbT1bXSxuPVtdLHA9ZS5nZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGUubWluUmFuaysxKSxsPWUubWluUmFuaysxO2w8ZS5tYXhSYW5rLTE7bCsrKXt2YXIgcT1lLmdldFgobCsxKTtwPT1xPyhtW2wtZS5taW5SYW5rLTFdPXAsZisrKTp0aGlzLnJlcG9zaXRpb25WYWxpZChiLGUsbCsxLHApPyhtW2wtZS5taW5SYW5rLQoxXT1wLGYrKyk6cD1tW2wtZS5taW5SYW5rLTFdPXF9cD1lLmdldFgobCk7Zm9yKGw9ZS5tYXhSYW5rLTE7bD5lLm1pblJhbmsrMTtsLS0pcT1lLmdldFgobC0xKSxwPT1xPyhuW2wtZS5taW5SYW5rLTJdPXAsZysrKTp0aGlzLnJlcG9zaXRpb25WYWxpZChiLGUsbC0xLHApPyhuW2wtZS5taW5SYW5rLTJdPXAsZysrKToobltsLWUubWluUmFuay0yXT1lLmdldFgobC0xKSxwPXEpO2lmKGc+a3x8Zj5rKWlmKGc+PWYpZm9yKGw9ZS5tYXhSYW5rLTI7bD5lLm1pblJhbms7bC0tKWUuc2V0WChsLG5bbC1lLm1pblJhbmstMV0pO2Vsc2UgaWYoZj5nKWZvcihsPWUubWluUmFuaysyO2w8ZS5tYXhSYW5rO2wrKyllLnNldFgobCxtW2wtZS5taW5SYW5rLTJdKX19fX07Cm14Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLnJlcG9zaXRpb25WYWxpZD1mdW5jdGlvbihhLGIsYyxkKXthPWEucmFua3NbY107Zm9yKHZhciBlPS0xLGY9MDtmPGEubGVuZ3RoO2YrKylpZihiPT1hW2ZdKXtlPWY7YnJlYWt9aWYoMD5lKXJldHVybiExO2Y9Yi5nZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGMpO2lmKGQ8Zil7aWYoMD09ZSlyZXR1cm4hMDthPWFbZS0xXTtjPWEuZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShjKTtjPWMrYS53aWR0aC8yK3RoaXMuaW50cmFDZWxsU3BhY2luZytiLndpZHRoLzI7aWYoIShjPD1kKSlyZXR1cm4hMX1lbHNlIGlmKGQ+Zil7aWYoZT09YS5sZW5ndGgtMSlyZXR1cm4hMDthPWFbZSsxXTtjPWEuZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShjKTtjPWMtYS53aWR0aC8yLXRoaXMuaW50cmFDZWxsU3BhY2luZy1iLndpZHRoLzI7aWYoIShjPj1kKSlyZXR1cm4hMX1yZXR1cm4hMH07Cm14Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLnNldENlbGxMb2NhdGlvbnM9ZnVuY3Rpb24oYSxiKXt0aGlzLnJhbmtUb3BZPVtdO3RoaXMucmFua0JvdHRvbVk9W107Zm9yKHZhciBjPTA7YzxiLnJhbmtzLmxlbmd0aDtjKyspdGhpcy5yYW5rVG9wWVtjXT1OdW1iZXIuTUFYX1ZBTFVFLHRoaXMucmFua0JvdHRvbVlbY109LU51bWJlci5NQVhfVkFMVUU7Zm9yKHZhciBkPWIudmVydGV4TWFwcGVyLmdldFZhbHVlcygpLGM9MDtjPGQubGVuZ3RoO2MrKyl0aGlzLnNldFZlcnRleExvY2F0aW9uKGRbY10pO3RoaXMubGF5b3V0LmVkZ2VTdHlsZSE9bXhIaWVyYXJjaGljYWxFZGdlU3R5bGUuT1JUSE9HT05BTCYmdGhpcy5sYXlvdXQuZWRnZVN0eWxlIT1teEhpZXJhcmNoaWNhbEVkZ2VTdHlsZS5QT0xZTElORSYmdGhpcy5sYXlvdXQuZWRnZVN0eWxlIT1teEhpZXJhcmNoaWNhbEVkZ2VTdHlsZS5DVVJWRXx8dGhpcy5sb2NhbEVkZ2VQcm9jZXNzaW5nKGIpO2Q9Yi5lZGdlTWFwcGVyLmdldFZhbHVlcygpOwpmb3IoYz0wO2M8ZC5sZW5ndGg7YysrKXRoaXMuc2V0RWRnZVBvc2l0aW9uKGRbY10pfTsKbXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGUubG9jYWxFZGdlUHJvY2Vzc2luZz1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPGEucmFua3MubGVuZ3RoO2IrKylmb3IodmFyIGM9YS5yYW5rc1tiXSxkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF07aWYoZS5pc1ZlcnRleCgpKWZvcih2YXIgZj1lLmdldFByZXZpb3VzTGF5ZXJDb25uZWN0ZWRDZWxscyhiKSxnPWItMSxrPTA7Mj5rO2srKyl7aWYoLTE8ZyYmZzxhLnJhbmtzLmxlbmd0aCYmbnVsbCE9ZiYmMDxmLmxlbmd0aCl7Zm9yKHZhciBsPVtdLG09MDttPGYubGVuZ3RoO20rKyl7dmFyIG49bmV3IFdlaWdodGVkQ2VsbFNvcnRlcihmW21dLGZbbV0uZ2V0WChnKSk7bC5wdXNoKG4pfWwuc29ydChXZWlnaHRlZENlbGxTb3J0ZXIucHJvdG90eXBlLmNvbXBhcmUpO2Zvcih2YXIgbj1lLnhbMF0tZS53aWR0aC8yLHA9bitlLndpZHRoLHE9Zj0wLGc9W10sbT0wO208bC5sZW5ndGg7bSsrKXt2YXIgcj1sW21dLmNlbGwsCnQ7aWYoci5pc1ZlcnRleCgpKXt0PTA9PWs/ZS5jb25uZWN0c0FzU291cmNlOmUuY29ubmVjdHNBc1RhcmdldDtmb3IodmFyIHU9MDt1PHQubGVuZ3RoO3UrKylpZih0W3VdLnNvdXJjZT09cnx8dFt1XS50YXJnZXQ9PXIpZis9dFt1XS5lZGdlcy5sZW5ndGgscSsrLGcucHVzaCh0W3VdKX1lbHNlIGYrPXIuZWRnZXMubGVuZ3RoLHErKyxnLnB1c2gocil9ZS53aWR0aD4oZisxKSp0aGlzLnByZWZIb3pFZGdlU2VwKzIqdGhpcy5wcmVmSG96RWRnZVNlcCYmKG4rPXRoaXMucHJlZkhvekVkZ2VTZXAscC09dGhpcy5wcmVmSG96RWRnZVNlcCk7bD0ocC1uKS9mO24rPWwvMjtwPXRoaXMubWluRWRnZUpldHR5LXRoaXMucHJlZlZlcnRFZGdlT2ZmO2ZvcihtPTA7bTxnLmxlbmd0aDttKyspZm9yKHE9Z1ttXS5lZGdlcy5sZW5ndGgscj10aGlzLmpldHR5UG9zaXRpb25zW2dbbV0uaWRzWzBdXSxudWxsPT1yJiYocj1bXSx0aGlzLmpldHR5UG9zaXRpb25zW2dbbV0uaWRzWzBdXT1yKSxtPGYvMj8KcCs9dGhpcy5wcmVmVmVydEVkZ2VPZmY6bT5mLzImJihwLT10aGlzLnByZWZWZXJ0RWRnZU9mZiksdD0wO3Q8cTt0Kyspcls0KnQrMiprXT1uLG4rPWwscls0KnQrMiprKzFdPXB9Zj1lLmdldE5leHRMYXllckNvbm5lY3RlZENlbGxzKGIpO2c9YisxfX19OwpteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5zZXRFZGdlUG9zaXRpb249ZnVuY3Rpb24oYSl7dmFyIGI9MDtpZigxMDEyMDchPWEudGVtcFswXSl7dmFyIGM9YS5tYXhSYW5rLGQ9YS5taW5SYW5rO2M9PWQmJihjPWEuc291cmNlLm1heFJhbmssZD1hLnRhcmdldC5taW5SYW5rKTtmb3IodmFyIGU9MCxmPXRoaXMuamV0dHlQb3NpdGlvbnNbYS5pZHNbMF1dLGc9YS5pc1JldmVyc2VkP2EudGFyZ2V0LmNlbGw6YS5zb3VyY2UuY2VsbCxrPXRoaXMubGF5b3V0LmdyYXBoLGw9dGhpcy5vcmllbnRhdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1R8fHRoaXMub3JpZW50YXRpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSCxtPTA7bTxhLmVkZ2VzLmxlbmd0aDttKyspe3ZhciBuPWEuZWRnZXNbbV0scD10aGlzLmxheW91dC5nZXRWaXNpYmxlVGVybWluYWwobiwhMCkscT1bXSxyPWEuaXNSZXZlcnNlZDtwIT1nJiYocj0hcik7aWYobnVsbCE9Zil7dmFyIHQ9cj8KMjowLHU9cj9sP3RoaXMucmFua0JvdHRvbVlbZF06dGhpcy5yYW5rVG9wWVtkXTpsP3RoaXMucmFua1RvcFlbY106dGhpcy5yYW5rQm90dG9tWVtjXSx4PWZbNCplKzErdF07ciE9bCYmKHg9LXgpO3ZhciB1PXUreCx0PWZbNCplK3RdLHk9ay5tb2RlbC5nZXRUZXJtaW5hbChuLCEwKTt0aGlzLmxheW91dC5pc1BvcnQoeSkmJmsubW9kZWwuZ2V0UGFyZW50KHkpPT1wJiYodD1rLnZpZXcuZ2V0U3RhdGUoeSksdD1udWxsIT10P3QueDpwLmdlb21ldHJ5LngrYS5zb3VyY2Uud2lkdGgqeS5nZW9tZXRyeS54KTt0aGlzLm9yaWVudGF0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEh8fHRoaXMub3JpZW50YXRpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSD8ocS5wdXNoKG5ldyBteFBvaW50KHQsdSkpLHRoaXMubGF5b3V0LmVkZ2VTdHlsZT09bXhIaWVyYXJjaGljYWxFZGdlU3R5bGUuQ1VSVkUmJnEucHVzaChuZXcgbXhQb2ludCh0LHUreCkpKToocS5wdXNoKG5ldyBteFBvaW50KHUsCnQpKSx0aGlzLmxheW91dC5lZGdlU3R5bGU9PW14SGllcmFyY2hpY2FsRWRnZVN0eWxlLkNVUlZFJiZxLnB1c2gobmV3IG14UG9pbnQodSt4LHQpKSl9dD1hLngubGVuZ3RoLTE7dT14PS0xO3A9YS5tYXhSYW5rLTE7Zm9yKHImJih0PTAseD1hLngubGVuZ3RoLHU9MSxwPWEubWluUmFuaysxKTthLm1heFJhbmshPWEubWluUmFuayYmdCE9eDt0Kz11KXt2YXIgeT1hLnhbdF0rYixCPSh0aGlzLnJhbmtUb3BZW3BdK3RoaXMucmFua0JvdHRvbVlbcCsxXSkvMixBPSh0aGlzLnJhbmtUb3BZW3AtMV0rdGhpcy5yYW5rQm90dG9tWVtwXSkvMjtpZihyKXZhciB6PUIsQj1BLEE9ejt0aGlzLm9yaWVudGF0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEh8fHRoaXMub3JpZW50YXRpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSD8ocS5wdXNoKG5ldyBteFBvaW50KHksQikpLHEucHVzaChuZXcgbXhQb2ludCh5LEEpKSk6KHEucHVzaChuZXcgbXhQb2ludChCLHkpKSxxLnB1c2gobmV3IG14UG9pbnQoQSwKeSkpKTt0aGlzLmxpbWl0WD1NYXRoLm1heCh0aGlzLmxpbWl0WCx5KTtwKz11fW51bGwhPWYmJih0PXI/MjowLHU9cj9sP3RoaXMucmFua1RvcFlbY106dGhpcy5yYW5rQm90dG9tWVtjXTpsP3RoaXMucmFua0JvdHRvbVlbZF06dGhpcy5yYW5rVG9wWVtkXSx4PWZbNCplKzMtdF0sciE9bCYmKHg9LXgpLHUtPXgsdD1mWzQqZSsyLXRdLHI9ay5tb2RlbC5nZXRUZXJtaW5hbChuLCExKSxwPXRoaXMubGF5b3V0LmdldFZpc2libGVUZXJtaW5hbChuLCExKSx0aGlzLmxheW91dC5pc1BvcnQocikmJmsubW9kZWwuZ2V0UGFyZW50KHIpPT1wJiYodD1rLnZpZXcuZ2V0U3RhdGUociksdD1udWxsIT10P3QueDpwLmdlb21ldHJ5LngrYS50YXJnZXQud2lkdGgqci5nZW9tZXRyeS54KSx0aGlzLm9yaWVudGF0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEh8fHRoaXMub3JpZW50YXRpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSD8odGhpcy5sYXlvdXQuZWRnZVN0eWxlPT1teEhpZXJhcmNoaWNhbEVkZ2VTdHlsZS5DVVJWRSYmCnEucHVzaChuZXcgbXhQb2ludCh0LHUteCkpLHEucHVzaChuZXcgbXhQb2ludCh0LHUpKSk6KHRoaXMubGF5b3V0LmVkZ2VTdHlsZT09bXhIaWVyYXJjaGljYWxFZGdlU3R5bGUuQ1VSVkUmJnEucHVzaChuZXcgbXhQb2ludCh1LXgsdCkpLHEucHVzaChuZXcgbXhQb2ludCh1LHQpKSkpO2EuaXNSZXZlcnNlZCYmdGhpcy5wcm9jZXNzUmV2ZXJzZWRFZGdlKGEsbik7dGhpcy5sYXlvdXQuc2V0RWRnZVBvaW50cyhuLHEpO2I9MD09Yj90aGlzLnBhcmFsbGVsRWRnZVNwYWNpbmc6MDxiPy1iOi1iK3RoaXMucGFyYWxsZWxFZGdlU3BhY2luZztlKyt9YS50ZW1wWzBdPTEwMTIwN319OwpteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5zZXRWZXJ0ZXhMb2NhdGlvbj1mdW5jdGlvbihhKXt2YXIgYj1hLmNlbGwsYz1hLnhbMF0tYS53aWR0aC8yLGQ9YS55WzBdLWEuaGVpZ2h0LzI7dGhpcy5yYW5rVG9wWVthLm1pblJhbmtdPU1hdGgubWluKHRoaXMucmFua1RvcFlbYS5taW5SYW5rXSxkKTt0aGlzLnJhbmtCb3R0b21ZW2EubWluUmFua109TWF0aC5tYXgodGhpcy5yYW5rQm90dG9tWVthLm1pblJhbmtdLGQrYS5oZWlnaHQpO3RoaXMub3JpZW50YXRpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSHx8dGhpcy5vcmllbnRhdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIP3RoaXMubGF5b3V0LnNldFZlcnRleExvY2F0aW9uKGIsYyxkKTp0aGlzLmxheW91dC5zZXRWZXJ0ZXhMb2NhdGlvbihiLGQsYyk7dGhpcy5saW1pdFg9TWF0aC5tYXgodGhpcy5saW1pdFgsYythLndpZHRoKX07Cm14Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLnByb2Nlc3NSZXZlcnNlZEVkZ2U9ZnVuY3Rpb24oYSxiKXt9O2Z1bmN0aW9uIG14U3dpbWxhbmVPcmRlcmluZyhhKXt0aGlzLmxheW91dD1hfW14U3dpbWxhbmVPcmRlcmluZy5wcm90b3R5cGU9bmV3IG14SGllcmFyY2hpY2FsTGF5b3V0U3RhZ2U7bXhTd2ltbGFuZU9yZGVyaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1teFN3aW1sYW5lT3JkZXJpbmc7bXhTd2ltbGFuZU9yZGVyaW5nLnByb3RvdHlwZS5sYXlvdXQ9bnVsbDsKbXhTd2ltbGFuZU9yZGVyaW5nLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGEpe2E9dGhpcy5sYXlvdXQuZ2V0TW9kZWwoKTt2YXIgYj1teFV0aWxzLmNsb25lKGEudmVydGV4TWFwcGVyLG51bGwsITApLGM9bnVsbDtpZihudWxsIT1hLnJvb3RzKWZvcih2YXIgZD1hLnJvb3RzLGM9W10sZT0wO2U8ZC5sZW5ndGg7ZSsrKWNbZV09YS52ZXJ0ZXhNYXBwZXIuZ2V0KGRbZV0pO2EudmlzaXQoZnVuY3Rpb24oYSxjLGQsZSxtKXtlPW51bGwhPWEmJmEuc3dpbWxhbmVJbmRleD09Yy5zd2ltbGFuZUluZGV4JiZjLmlzQW5jZXN0b3IoYSk7bT1udWxsIT1hJiZudWxsIT1kJiZhLnN3aW1sYW5lSW5kZXg8Yy5zd2ltbGFuZUluZGV4JiZkLnNvdXJjZT09YztlPyhkLmludmVydCgpLG14VXRpbHMucmVtb3ZlKGQsYS5jb25uZWN0c0FzU291cmNlKSxjLmNvbm5lY3RzQXNTb3VyY2UucHVzaChkKSxhLmNvbm5lY3RzQXNUYXJnZXQucHVzaChkKSxteFV0aWxzLnJlbW92ZShkLGMuY29ubmVjdHNBc1RhcmdldCkpOgptJiYoZC5pbnZlcnQoKSxteFV0aWxzLnJlbW92ZShkLGEuY29ubmVjdHNBc1RhcmdldCksYy5jb25uZWN0c0FzVGFyZ2V0LnB1c2goZCksYS5jb25uZWN0c0FzU291cmNlLnB1c2goZCksbXhVdGlscy5yZW1vdmUoZCxjLmNvbm5lY3RzQXNTb3VyY2UpKTthPW14Q2VsbFBhdGguY3JlYXRlKGMuY2VsbCk7ZGVsZXRlIGJbYV19LGMsITAsbnVsbCl9O2Z1bmN0aW9uIG14SGllcmFyY2hpY2FsTGF5b3V0KGEsYixjKXtteEdyYXBoTGF5b3V0LmNhbGwodGhpcyxhKTt0aGlzLm9yaWVudGF0aW9uPW51bGwhPWI/YjpteENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEg7dGhpcy5kZXRlcm1pbmlzdGljPW51bGwhPWM/YzohMH12YXIgbXhIaWVyYXJjaGljYWxFZGdlU3R5bGU9e09SVEhPR09OQUw6MSxQT0xZTElORToyLFNUUkFJR0hUOjMsQ1VSVkU6NH07bXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlPW5ldyBteEdyYXBoTGF5b3V0OwpteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhIaWVyYXJjaGljYWxMYXlvdXQ7bXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLnJvb3RzPW51bGw7bXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLnJlc2l6ZVBhcmVudD0hMTtteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUubWFpbnRhaW5QYXJlbnRMb2NhdGlvbj0hMTtteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUubW92ZVBhcmVudD0hMTtteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUucGFyZW50Qm9yZGVyPTA7bXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLmludHJhQ2VsbFNwYWNpbmc9MzA7bXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLmludGVyUmFua0NlbGxTcGFjaW5nPTEwMDtteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUuaW50ZXJIaWVyYXJjaHlTcGFjaW5nPTYwOwpteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUucGFyYWxsZWxFZGdlU3BhY2luZz0xMDtteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUub3JpZW50YXRpb249bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIO214SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5maW5lVHVuaW5nPSEwO214SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS50aWdodGVuVG9Tb3VyY2U9ITA7bXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLmRpc2FibGVFZGdlU3R5bGU9ITA7bXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLnRyYXZlcnNlQW5jZXN0b3JzPSEwO214SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5tb2RlbD1udWxsO214SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5lZGdlc0NhY2hlPW51bGw7bXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLmVkZ2VTb3VyY2VUZXJtQ2FjaGU9bnVsbDsKbXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLmVkZ2VzVGFyZ2V0VGVybUNhY2hlPW51bGw7bXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLmVkZ2VTdHlsZT1teEhpZXJhcmNoaWNhbEVkZ2VTdHlsZS5QT0xZTElORTtteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUuZ2V0TW9kZWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tb2RlbH07Cm14SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGEsYil7dGhpcy5wYXJlbnQ9YTt2YXIgYz10aGlzLmdyYXBoLm1vZGVsO3RoaXMuZWRnZXNDYWNoZT1uZXcgbXhEaWN0aW9uYXJ5O3RoaXMuZWRnZVNvdXJjZVRlcm1DYWNoZT1uZXcgbXhEaWN0aW9uYXJ5O3RoaXMuZWRnZXNUYXJnZXRUZXJtQ2FjaGU9bmV3IG14RGljdGlvbmFyeTtudWxsPT1ifHxiIGluc3RhbmNlb2YgQXJyYXl8fChiPVtiXSk7aWYobnVsbCE9Ynx8bnVsbCE9YSl7dGhpcy5wYXJlbnRZPXRoaXMucGFyZW50WD1udWxsO2lmKGEhPXRoaXMucm9vdCYmbnVsbCE9Yy5pc1ZlcnRleChhKSYmdGhpcy5tYWludGFpblBhcmVudExvY2F0aW9uKXt2YXIgZD10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShhKTtudWxsIT1kJiYodGhpcy5wYXJlbnRYPWQueCx0aGlzLnBhcmVudFk9ZC55KX1pZihudWxsIT1iKXtmb3IodmFyIGU9W10sZj0wO2Y8Yi5sZW5ndGg7ZisrKShudWxsIT1hP2MuaXNBbmNlc3RvcihhLApiW2ZdKToxKSYmYy5pc1ZlcnRleChiW2ZdKSYmZS5wdXNoKGJbZl0pO3RoaXMucm9vdHM9ZX1jLmJlZ2luVXBkYXRlKCk7dHJ5e3RoaXMucnVuKGEpLHRoaXMucmVzaXplUGFyZW50JiYhdGhpcy5ncmFwaC5pc0NlbGxDb2xsYXBzZWQoYSkmJnRoaXMuZ3JhcGgudXBkYXRlR3JvdXBCb3VuZHMoW2FdLHRoaXMucGFyZW50Qm9yZGVyLHRoaXMubW92ZVBhcmVudCksbnVsbCE9dGhpcy5wYXJlbnRYJiZudWxsIT10aGlzLnBhcmVudFkmJihkPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGEpLG51bGwhPWQmJihkPWQuY2xvbmUoKSxkLng9dGhpcy5wYXJlbnRYLGQueT10aGlzLnBhcmVudFksYy5zZXRHZW9tZXRyeShhLGQpKSl9ZmluYWxseXtjLmVuZFVwZGF0ZSgpfX19OwpteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUuZmluZFJvb3RzPWZ1bmN0aW9uKGEsYil7dmFyIGM9W107aWYobnVsbCE9YSYmbnVsbCE9Yil7dmFyIGQ9dGhpcy5ncmFwaC5tb2RlbCxlPW51bGwsZj0tMUU1LGc7Zm9yKGcgaW4gYil7dmFyIGs9YltnXTtpZihkLmlzVmVydGV4KGspJiZ0aGlzLmdyYXBoLmlzQ2VsbFZpc2libGUoaykpe2Zvcih2YXIgbD10aGlzLmdldEVkZ2VzKGspLG09MCxuPTAscD0wO3A8bC5sZW5ndGg7cCsrKXRoaXMuZ2V0VmlzaWJsZVRlcm1pbmFsKGxbcF0sITApPT1rP20rKzpuKys7MD09biYmMDxtJiZjLnB1c2goayk7bD1tLW47bD5mJiYoZj1sLGU9ayl9fTA9PWMubGVuZ3RoJiZudWxsIT1lJiZjLnB1c2goZSl9cmV0dXJuIGN9OwpteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUuZ2V0RWRnZXM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5lZGdlc0NhY2hlLmdldChhKTtpZihudWxsIT1iKXJldHVybiBiO2Zvcih2YXIgYz10aGlzLmdyYXBoLm1vZGVsLGI9W10sZD10aGlzLmdyYXBoLmlzQ2VsbENvbGxhcHNlZChhKSxlPWMuZ2V0Q2hpbGRDb3VudChhKSxmPTA7ZjxlO2YrKyl7dmFyIGc9Yy5nZXRDaGlsZEF0KGEsZik7aWYodGhpcy5pc1BvcnQoZykpYj1iLmNvbmNhdChjLmdldEVkZ2VzKGcsITAsITApKTtlbHNlIGlmKGR8fCF0aGlzLmdyYXBoLmlzQ2VsbFZpc2libGUoZykpYj1iLmNvbmNhdChjLmdldEVkZ2VzKGcsITAsITApKX1iPWIuY29uY2F0KGMuZ2V0RWRnZXMoYSwhMCwhMCkpO2M9W107Zm9yKGY9MDtmPGIubGVuZ3RoO2YrKylkPXRoaXMuZ2V0VmlzaWJsZVRlcm1pbmFsKGJbZl0sITApLGU9dGhpcy5nZXRWaXNpYmxlVGVybWluYWwoYltmXSwhMSksKGQ9PWV8fGQhPWUmJihlPT1hJiYobnVsbD09CnRoaXMucGFyZW50fHx0aGlzLmlzQW5jZXN0b3IodGhpcy5wYXJlbnQsZCx0aGlzLnRyYXZlcnNlQW5jZXN0b3JzKSl8fGQ9PWEmJihudWxsPT10aGlzLnBhcmVudHx8dGhpcy5pc0FuY2VzdG9yKHRoaXMucGFyZW50LGUsdGhpcy50cmF2ZXJzZUFuY2VzdG9ycykpKSkmJmMucHVzaChiW2ZdKTt0aGlzLmVkZ2VzQ2FjaGUucHV0KGEsYyk7cmV0dXJuIGN9OwpteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUuZ2V0VmlzaWJsZVRlcm1pbmFsPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5lZGdlc1RhcmdldFRlcm1DYWNoZTtiJiYoYz10aGlzLmVkZ2VTb3VyY2VUZXJtQ2FjaGUpO3ZhciBkPWMuZ2V0KGEpO2lmKG51bGwhPWQpcmV0dXJuIGQ7dmFyIGQ9dGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKGEpLGU9bnVsbCE9ZD9kLmdldFZpc2libGVUZXJtaW5hbChiKTp0aGlzLmdyYXBoLnZpZXcuZ2V0VmlzaWJsZVRlcm1pbmFsKGEsYik7bnVsbD09ZSYmKGU9bnVsbCE9ZD9kLmdldFZpc2libGVUZXJtaW5hbChiKTp0aGlzLmdyYXBoLnZpZXcuZ2V0VmlzaWJsZVRlcm1pbmFsKGEsYikpO251bGwhPWUmJih0aGlzLmlzUG9ydChlKSYmKGU9dGhpcy5ncmFwaC5tb2RlbC5nZXRQYXJlbnQoZSkpLGMucHV0KGEsZSkpO3JldHVybiBlfTsKbXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLnJ1bj1mdW5jdGlvbihhKXt2YXIgYj1bXSxjPVtdO2lmKG51bGw9PXRoaXMucm9vdHMmJm51bGwhPWEpe3ZhciBkPXt9O3RoaXMuZmlsdGVyRGVzY2VuZGFudHMoYSxkKTt0aGlzLnJvb3RzPVtdO3ZhciBlPSEwLGY7Zm9yKGYgaW4gZClpZihudWxsIT1kW2ZdKXtlPSExO2JyZWFrfWZvcig7IWU7KXtmb3IodmFyIGc9dGhpcy5maW5kUm9vdHMoYSxkKSxlPTA7ZTxnLmxlbmd0aDtlKyspe3ZhciBrPXt9O2IucHVzaChrKTt0aGlzLnRyYXZlcnNlKGdbZV0sITAsbnVsbCxjLGssYixkKX1mb3IoZT0wO2U8Zy5sZW5ndGg7ZSsrKXRoaXMucm9vdHMucHVzaChnW2VdKTtlPSEwO2ZvcihmIGluIGQpaWYobnVsbCE9ZFtmXSl7ZT0hMTticmVha319fWVsc2UgZm9yKGU9MDtlPHRoaXMucm9vdHMubGVuZ3RoO2UrKylrPXt9LGIucHVzaChrKSx0aGlzLnRyYXZlcnNlKHRoaXMucm9vdHNbZV0sITAsbnVsbCxjLGssYixudWxsKTtmb3IoZT1jPQowO2U8Yi5sZW5ndGg7ZSsrKXtrPWJbZV07ZD1bXTtmb3IoZiBpbiBrKWQucHVzaChrW2ZdKTt0aGlzLm1vZGVsPW5ldyBteEdyYXBoSGllcmFyY2h5TW9kZWwodGhpcyxkLHRoaXMucm9vdHMsYSx0aGlzLnRpZ2h0ZW5Ub1NvdXJjZSk7dGhpcy5jeWNsZVN0YWdlKGEpO3RoaXMubGF5ZXJpbmdTdGFnZSgpO3RoaXMuY3Jvc3NpbmdTdGFnZShhKTtjPXRoaXMucGxhY2VtZW50U3RhZ2UoYyxhKX19OwpteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUuZmlsdGVyRGVzY2VuZGFudHM9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdyYXBoLm1vZGVsO2MuaXNWZXJ0ZXgoYSkmJmEhPXRoaXMucGFyZW50JiZ0aGlzLmdyYXBoLmlzQ2VsbFZpc2libGUoYSkmJihiW214T2JqZWN0SWRlbnRpdHkuZ2V0KGEpXT1hKTtpZih0aGlzLnRyYXZlcnNlQW5jZXN0b3JzfHxhPT10aGlzLnBhcmVudCYmdGhpcy5ncmFwaC5pc0NlbGxWaXNpYmxlKGEpKWZvcih2YXIgZD1jLmdldENoaWxkQ291bnQoYSksZT0wO2U8ZDtlKyspe3ZhciBmPWMuZ2V0Q2hpbGRBdChhLGUpO3RoaXMuaXNQb3J0KGYpfHx0aGlzLmZpbHRlckRlc2NlbmRhbnRzKGYsYil9fTtteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUuaXNQb3J0PWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiZudWxsIT1hLmdlb21ldHJ5P2EuZ2VvbWV0cnkucmVsYXRpdmU6ITF9OwpteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUuZ2V0RWRnZXNCZXR3ZWVuPWZ1bmN0aW9uKGEsYixjKXtjPW51bGwhPWM/YzohMTtmb3IodmFyIGQ9dGhpcy5nZXRFZGdlcyhhKSxlPVtdLGY9MDtmPGQubGVuZ3RoO2YrKyl7dmFyIGc9dGhpcy5nZXRWaXNpYmxlVGVybWluYWwoZFtmXSwhMCksaz10aGlzLmdldFZpc2libGVUZXJtaW5hbChkW2ZdLCExKTsoZz09YSYmaz09Ynx8IWMmJmc9PWImJms9PWEpJiZlLnB1c2goZFtmXSl9cmV0dXJuIGV9OwpteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUudHJhdmVyc2U9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyl7aWYobnVsbCE9YSYmbnVsbCE9ZCl7dmFyIGs9bXhPYmplY3RJZGVudGl0eS5nZXQoYSk7aWYobnVsbD09ZFtrXSYmKG51bGw9PWd8fG51bGwhPWdba10pKXtudWxsPT1lW2tdJiYoZVtrXT1hKTtudWxsPT1kW2tdJiYoZFtrXT1hKTtudWxsIT09ZyYmZGVsZXRlIGdba107dmFyIGw9dGhpcy5nZXRFZGdlcyhhKSxrPVtdO2ZvcihjPTA7YzxsLmxlbmd0aDtjKyspa1tjXT10aGlzLmdldFZpc2libGVUZXJtaW5hbChsW2NdLCEwKT09YTtmb3IoYz0wO2M8bC5sZW5ndGg7YysrKWlmKCFifHxrW2NdKXthPXRoaXMuZ2V0VmlzaWJsZVRlcm1pbmFsKGxbY10sIWtbY10pO2Zvcih2YXIgbT0xLG49MDtuPGwubGVuZ3RoO24rKylpZihuIT1jKXt2YXIgcD1rW25dO3RoaXMuZ2V0VmlzaWJsZVRlcm1pbmFsKGxbbl0sIXApPT1hJiYocD9tKys6bS0tKX0wPD1tJiYoZT10aGlzLnRyYXZlcnNlKGEsCmIsbFtjXSxkLGUsZixnKSl9fWVsc2UgaWYobnVsbD09ZVtrXSlmb3IoYz0wO2M8Zi5sZW5ndGg7YysrKWlmKGI9ZltjXSxudWxsIT1iW2tdKXtmb3IobCBpbiBiKWVbbF09YltsXTtmLnNwbGljZShjLDEpO2JyZWFrfX1yZXR1cm4gZX07bXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLmN5Y2xlU3RhZ2U9ZnVuY3Rpb24oYSl7KG5ldyBteE1pbmltdW1DeWNsZVJlbW92ZXIodGhpcykpLmV4ZWN1dGUoYSl9O214SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5sYXllcmluZ1N0YWdlPWZ1bmN0aW9uKCl7dGhpcy5tb2RlbC5pbml0aWFsUmFuaygpO3RoaXMubW9kZWwuZml4UmFua3MoKX07bXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLmNyb3NzaW5nU3RhZ2U9ZnVuY3Rpb24oYSl7KG5ldyBteE1lZGlhbkh5YnJpZENyb3NzaW5nUmVkdWN0aW9uKHRoaXMpKS5leGVjdXRlKGEpfTsKbXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLnBsYWNlbWVudFN0YWdlPWZ1bmN0aW9uKGEsYil7dmFyIGM9bmV3IG14Q29vcmRpbmF0ZUFzc2lnbm1lbnQodGhpcyx0aGlzLmludHJhQ2VsbFNwYWNpbmcsdGhpcy5pbnRlclJhbmtDZWxsU3BhY2luZyx0aGlzLm9yaWVudGF0aW9uLGEsdGhpcy5wYXJhbGxlbEVkZ2VTcGFjaW5nKTtjLmZpbmVUdW5pbmc9dGhpcy5maW5lVHVuaW5nO2MuZXhlY3V0ZShiKTtyZXR1cm4gYy5saW1pdFgrdGhpcy5pbnRlckhpZXJhcmNoeVNwYWNpbmd9O2Z1bmN0aW9uIG14U3dpbWxhbmVMYXlvdXQoYSxiLGMpe214R3JhcGhMYXlvdXQuY2FsbCh0aGlzLGEpO3RoaXMub3JpZW50YXRpb249bnVsbCE9Yj9iOm14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSDt0aGlzLmRldGVybWluaXN0aWM9bnVsbCE9Yz9jOiEwfW14U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlPW5ldyBteEdyYXBoTGF5b3V0OwpteFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1teFN3aW1sYW5lTGF5b3V0O214U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLnJvb3RzPW51bGw7bXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUuc3dpbWxhbmVzPW51bGw7bXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUuZHVtbXlWZXJ0ZXhXaWR0aD01MDtteFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZS5yZXNpemVQYXJlbnQ9ITE7bXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUubWFpbnRhaW5QYXJlbnRMb2NhdGlvbj0hMTtteFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZS5tb3ZlUGFyZW50PSExO214U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLnBhcmVudEJvcmRlcj0zMDtteFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZS5pbnRyYUNlbGxTcGFjaW5nPTMwO214U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLmludGVyUmFua0NlbGxTcGFjaW5nPTEwMDsKbXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUuaW50ZXJIaWVyYXJjaHlTcGFjaW5nPTYwO214U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLnBhcmFsbGVsRWRnZVNwYWNpbmc9MTA7bXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUub3JpZW50YXRpb249bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIO214U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLmZpbmVUdW5pbmc9ITA7bXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUudGlnaHRlblRvU291cmNlPSEwO214U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLmRpc2FibGVFZGdlU3R5bGU9ITA7bXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUudHJhdmVyc2VBbmNlc3RvcnM9ITA7bXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUubW9kZWw9bnVsbDtteFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZS5lZGdlc0NhY2hlPW51bGw7bXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLmVkZ2VTb3VyY2VUZXJtQ2FjaGU9bnVsbDsKbXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLmVkZ2VzVGFyZ2V0VGVybUNhY2hlPW51bGw7bXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLmVkZ2VTdHlsZT1teEhpZXJhcmNoaWNhbEVkZ2VTdHlsZS5QT0xZTElORTtteFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZS5nZXRNb2RlbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1vZGVsfTsKbXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihhLGIpe3RoaXMucGFyZW50PWE7dmFyIGM9dGhpcy5ncmFwaC5tb2RlbDt0aGlzLmVkZ2VzQ2FjaGU9bmV3IG14RGljdGlvbmFyeTt0aGlzLmVkZ2VTb3VyY2VUZXJtQ2FjaGU9bmV3IG14RGljdGlvbmFyeTt0aGlzLmVkZ2VzVGFyZ2V0VGVybUNhY2hlPW5ldyBteERpY3Rpb25hcnk7aWYoIShudWxsPT1ifHwxPmIubGVuZ3RoKSl7bnVsbD09YSYmKGE9Yy5nZXRQYXJlbnQoYlswXSkpO3RoaXMucGFyZW50WT10aGlzLnBhcmVudFg9bnVsbDtpZihhIT10aGlzLnJvb3QmJm51bGwhPWMuaXNWZXJ0ZXgoYSkmJnRoaXMubWFpbnRhaW5QYXJlbnRMb2NhdGlvbil7dmFyIGQ9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoYSk7bnVsbCE9ZCYmKHRoaXMucGFyZW50WD1kLngsdGhpcy5wYXJlbnRZPWQueSl9dGhpcy5zd2ltbGFuZXM9Yjtmb3IodmFyIGU9W10sZj0wO2Y8Yi5sZW5ndGg7ZisrKXt2YXIgZz10aGlzLmdyYXBoLmdldENoaWxkQ2VsbHMoYltmXSk7CmlmKG51bGw9PWd8fDA9PWcubGVuZ3RoKWc9dGhpcy5ncmFwaC5pbnNlcnRWZXJ0ZXgoYltmXSxudWxsLG51bGwsMCwwLHRoaXMuZHVtbXlWZXJ0ZXhXaWR0aCwwKSxlLnB1c2goZyl9Yy5iZWdpblVwZGF0ZSgpO3RyeXt0aGlzLnJ1bihhKSx0aGlzLnJlc2l6ZVBhcmVudCYmIXRoaXMuZ3JhcGguaXNDZWxsQ29sbGFwc2VkKGEpJiZ0aGlzLmdyYXBoLnVwZGF0ZUdyb3VwQm91bmRzKFthXSx0aGlzLnBhcmVudEJvcmRlcix0aGlzLm1vdmVQYXJlbnQpLG51bGwhPXRoaXMucGFyZW50WCYmbnVsbCE9dGhpcy5wYXJlbnRZJiYoZD10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShhKSxudWxsIT1kJiYoZD1kLmNsb25lKCksZC54PXRoaXMucGFyZW50WCxkLnk9dGhpcy5wYXJlbnRZLGMuc2V0R2VvbWV0cnkoYSxkKSkpLHRoaXMuZ3JhcGgucmVtb3ZlQ2VsbHMoZSl9ZmluYWxseXtjLmVuZFVwZGF0ZSgpfX19OwpteFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZS51cGRhdGVHcm91cEJvdW5kcz1mdW5jdGlvbigpe3ZhciBhPVtdLGI9dGhpcy5tb2RlbCxjO2ZvcihjIGluIGIuZWRnZU1hcHBlcilmb3IodmFyIGQ9Yi5lZGdlTWFwcGVyW2NdLGU9MDtlPGQuZWRnZXMubGVuZ3RoO2UrKylhLnB1c2goZC5lZGdlc1tlXSk7YT10aGlzLmdyYXBoLmdldEJvdW5kaW5nQm94RnJvbUdlb21ldHJ5KGEsITApO2I9W107Zm9yKGU9MDtlPHRoaXMuc3dpbWxhbmVzLmxlbmd0aDtlKyspe3ZhciBmPXRoaXMuc3dpbWxhbmVzW2VdO2M9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoZik7aWYobnVsbCE9Yyl7dmFyIGc9dGhpcy5ncmFwaC5nZXRDaGlsZENlbGxzKGYpLGQ9dGhpcy5ncmFwaC5pc1N3aW1sYW5lKGYpP3RoaXMuZ3JhcGguZ2V0U3RhcnRTaXplKGYpOm5ldyBteFJlY3RhbmdsZSxmPXRoaXMuZ3JhcGguZ2V0Qm91bmRpbmdCb3hGcm9tR2VvbWV0cnkoZyk7YltlXT1mO2Q9Zi55K2MueS1kLmhlaWdodC0KdGhpcy5wYXJlbnRCb3JkZXI7Yz1mLnkrYy55K2YuaGVpZ2h0O251bGw9PWE/YT1uZXcgbXhSZWN0YW5nbGUoMCxkLDAsYy1kKTooYS55PU1hdGgubWluKGEueSxkKSxhLmhlaWdodD1NYXRoLm1heChhLnkrYS5oZWlnaHQsYyktYS55KX19Zm9yKGU9MDtlPHRoaXMuc3dpbWxhbmVzLmxlbmd0aDtlKyspaWYoZj10aGlzLnN3aW1sYW5lc1tlXSxjPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGYpLG51bGwhPWMpe3ZhciBnPXRoaXMuZ3JhcGguZ2V0Q2hpbGRDZWxscyhmKSxkPXRoaXMuZ3JhcGguaXNTd2ltbGFuZShmKT90aGlzLmdyYXBoLmdldFN0YXJ0U2l6ZShmKTpuZXcgbXhSZWN0YW5nbGUsaz1jLmNsb25lKCksbD1kLndpZHRoKygwPT1lP3RoaXMucGFyZW50Qm9yZGVyOnRoaXMuaW50ZXJSYW5rQ2VsbFNwYWNpbmcvMiksbT1iW2VdLngtbCxuPWEueS10aGlzLnBhcmVudEJvcmRlcjtrLngrPW07ay55PW47ay53aWR0aD1iW2VdLndpZHRoK2wrdGhpcy5pbnRlclJhbmtDZWxsU3BhY2luZy8KMjtrLmhlaWdodD1hLmhlaWdodCtkLmhlaWdodCsyKnRoaXMucGFyZW50Qm9yZGVyO3RoaXMuZ3JhcGgubW9kZWwuc2V0R2VvbWV0cnkoZixrKTt0aGlzLmdyYXBoLm1vdmVDZWxscyhnLC1tLGMueS1uKX19OwpteFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZS5maW5kUm9vdHM9ZnVuY3Rpb24oYSxiKXt2YXIgYz1bXTtpZihudWxsIT1hJiZudWxsIT1iKXt2YXIgZD10aGlzLmdyYXBoLm1vZGVsLGU9bnVsbCxmPS0xRTUsZztmb3IoZyBpbiBiKXt2YXIgaz1iW2ddO2lmKG51bGwhPWsmJmQuaXNWZXJ0ZXgoaykmJnRoaXMuZ3JhcGguaXNDZWxsVmlzaWJsZShrKSYmZC5pc0FuY2VzdG9yKGEsaykpe2Zvcih2YXIgbD10aGlzLmdldEVkZ2VzKGspLG09MCxuPTAscD0wO3A8bC5sZW5ndGg7cCsrKXt2YXIgcT10aGlzLmdldFZpc2libGVUZXJtaW5hbChsW3BdLCEwKTtxPT1rPyhxPXRoaXMuZ2V0VmlzaWJsZVRlcm1pbmFsKGxbcF0sITEpLGQuaXNBbmNlc3RvcihhLHEpJiZtKyspOmQuaXNBbmNlc3RvcihhLHEpJiZuKyt9MD09biYmMDxtJiZjLnB1c2goayk7bD1tLW47bD5mJiYoZj1sLGU9ayl9fTA9PWMubGVuZ3RoJiZudWxsIT1lJiZjLnB1c2goZSl9cmV0dXJuIGN9OwpteFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZS5nZXRFZGdlcz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmVkZ2VzQ2FjaGUuZ2V0KGEpO2lmKG51bGwhPWIpcmV0dXJuIGI7Zm9yKHZhciBjPXRoaXMuZ3JhcGgubW9kZWwsYj1bXSxkPXRoaXMuZ3JhcGguaXNDZWxsQ29sbGFwc2VkKGEpLGU9Yy5nZXRDaGlsZENvdW50KGEpLGY9MDtmPGU7ZisrKXt2YXIgZz1jLmdldENoaWxkQXQoYSxmKTtpZih0aGlzLmlzUG9ydChnKSliPWIuY29uY2F0KGMuZ2V0RWRnZXMoZywhMCwhMCkpO2Vsc2UgaWYoZHx8IXRoaXMuZ3JhcGguaXNDZWxsVmlzaWJsZShnKSliPWIuY29uY2F0KGMuZ2V0RWRnZXMoZywhMCwhMCkpfWI9Yi5jb25jYXQoYy5nZXRFZGdlcyhhLCEwLCEwKSk7Yz1bXTtmb3IoZj0wO2Y8Yi5sZW5ndGg7ZisrKWQ9dGhpcy5nZXRWaXNpYmxlVGVybWluYWwoYltmXSwhMCksZT10aGlzLmdldFZpc2libGVUZXJtaW5hbChiW2ZdLCExKSwoZD09ZXx8ZCE9ZSYmKGU9PWEmJihudWxsPT10aGlzLnBhcmVudHx8CnRoaXMuZ3JhcGguaXNWYWxpZEFuY2VzdG9yKGQsdGhpcy5wYXJlbnQsdGhpcy50cmF2ZXJzZUFuY2VzdG9ycykpfHxkPT1hJiYobnVsbD09dGhpcy5wYXJlbnR8fHRoaXMuZ3JhcGguaXNWYWxpZEFuY2VzdG9yKGUsdGhpcy5wYXJlbnQsdGhpcy50cmF2ZXJzZUFuY2VzdG9ycykpKSkmJmMucHVzaChiW2ZdKTt0aGlzLmVkZ2VzQ2FjaGUucHV0KGEsYyk7cmV0dXJuIGN9OwpteFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZS5nZXRWaXNpYmxlVGVybWluYWw9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmVkZ2VzVGFyZ2V0VGVybUNhY2hlO2ImJihjPXRoaXMuZWRnZVNvdXJjZVRlcm1DYWNoZSk7dmFyIGQ9Yy5nZXQoYSk7aWYobnVsbCE9ZClyZXR1cm4gZDt2YXIgZD10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUoYSksZT1udWxsIT1kP2QuZ2V0VmlzaWJsZVRlcm1pbmFsKGIpOnRoaXMuZ3JhcGgudmlldy5nZXRWaXNpYmxlVGVybWluYWwoYSxiKTtudWxsPT1lJiYoZT1udWxsIT1kP2QuZ2V0VmlzaWJsZVRlcm1pbmFsKGIpOnRoaXMuZ3JhcGgudmlldy5nZXRWaXNpYmxlVGVybWluYWwoYSxiKSk7bnVsbCE9ZSYmKHRoaXMuaXNQb3J0KGUpJiYoZT10aGlzLmdyYXBoLm1vZGVsLmdldFBhcmVudChlKSksYy5wdXQoYSxlKSk7cmV0dXJuIGV9OwpteFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oYSl7dmFyIGI9W10sYz17fTtpZihudWxsIT10aGlzLnN3aW1sYW5lcyYmMDx0aGlzLnN3aW1sYW5lcy5sZW5ndGgmJm51bGwhPWEpe2Zvcih2YXIgZD17fSxlPTA7ZTx0aGlzLnN3aW1sYW5lcy5sZW5ndGg7ZSsrKXRoaXMuZmlsdGVyRGVzY2VuZGFudHModGhpcy5zd2ltbGFuZXNbZV0sZCk7dGhpcy5yb290cz1bXTt2YXIgZT0hMCxmO2ZvcihmIGluIGQpaWYobnVsbCE9ZFtmXSl7ZT0hMTticmVha31mb3IodmFyIGc9MDshZSYmZzx0aGlzLnN3aW1sYW5lcy5sZW5ndGg7KXt2YXIgaz10aGlzLmZpbmRSb290cyh0aGlzLnN3aW1sYW5lc1tnXSxkKTtpZigwPT1rLmxlbmd0aClnKys7ZWxzZXtmb3IoZT0wO2U8ay5sZW5ndGg7ZSsrKXt2YXIgbD17fTtiLnB1c2gobCk7dGhpcy50cmF2ZXJzZShrW2VdLCEwLG51bGwsYyxsLGIsZCxnKX1mb3IoZT0wO2U8ay5sZW5ndGg7ZSsrKXRoaXMucm9vdHMucHVzaChrW2VdKTsKZT0hMDtmb3IoZiBpbiBkKWlmKG51bGwhPWRbZl0pe2U9ITE7YnJlYWt9fX19ZWxzZSBmb3IoZT0wO2U8dGhpcy5yb290cy5sZW5ndGg7ZSsrKWw9e30sYi5wdXNoKGwpLHRoaXMudHJhdmVyc2UodGhpcy5yb290c1tlXSwhMCxudWxsLGMsbCxiLG51bGwpO2I9W107Zm9yKGYgaW4gYyliLnB1c2goY1tmXSk7dGhpcy5tb2RlbD1uZXcgbXhTd2ltbGFuZU1vZGVsKHRoaXMsYix0aGlzLnJvb3RzLGEsdGhpcy50aWdodGVuVG9Tb3VyY2UpO3RoaXMuY3ljbGVTdGFnZShhKTt0aGlzLmxheWVyaW5nU3RhZ2UoKTt0aGlzLmNyb3NzaW5nU3RhZ2UoYSk7dGhpcy5wbGFjZW1lbnRTdGFnZSgwLGEpfTsKbXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUuZmlsdGVyRGVzY2VuZGFudHM9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdyYXBoLm1vZGVsO2MuaXNWZXJ0ZXgoYSkmJmEhPXRoaXMucGFyZW50JiZjLmdldFBhcmVudChhKSE9dGhpcy5wYXJlbnQmJnRoaXMuZ3JhcGguaXNDZWxsVmlzaWJsZShhKSYmKGJbbXhPYmplY3RJZGVudGl0eS5nZXQoYSldPWEpO2lmKHRoaXMudHJhdmVyc2VBbmNlc3RvcnN8fGE9PXRoaXMucGFyZW50JiZ0aGlzLmdyYXBoLmlzQ2VsbFZpc2libGUoYSkpZm9yKHZhciBkPWMuZ2V0Q2hpbGRDb3VudChhKSxlPTA7ZTxkO2UrKyl7dmFyIGY9Yy5nZXRDaGlsZEF0KGEsZSk7dGhpcy5pc1BvcnQoZil8fHRoaXMuZmlsdGVyRGVzY2VuZGFudHMoZixiKX19O214U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLmlzUG9ydD1mdW5jdGlvbihhKXtyZXR1cm4gYS5nZW9tZXRyeS5yZWxhdGl2ZT8hMDohMX07Cm14U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLmdldEVkZ2VzQmV0d2Vlbj1mdW5jdGlvbihhLGIsYyl7Yz1udWxsIT1jP2M6ITE7Zm9yKHZhciBkPXRoaXMuZ2V0RWRnZXMoYSksZT1bXSxmPTA7ZjxkLmxlbmd0aDtmKyspe3ZhciBnPXRoaXMuZ2V0VmlzaWJsZVRlcm1pbmFsKGRbZl0sITApLGs9dGhpcy5nZXRWaXNpYmxlVGVybWluYWwoZFtmXSwhMSk7KGc9PWEmJms9PWJ8fCFjJiZnPT1iJiZrPT1hKSYmZS5wdXNoKGRbZl0pfXJldHVybiBlfTsKbXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUudHJhdmVyc2U9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxrKXtpZihudWxsIT1hJiZudWxsIT1kKXt2YXIgbD1teE9iamVjdElkZW50aXR5LmdldChhKTtpZihudWxsPT1kW2xdJiYobnVsbD09Z3x8bnVsbCE9Z1tsXSkpe251bGw9PWVbbF0mJihlW2xdPWEpO251bGw9PWRbbF0mJihkW2xdPWEpO251bGwhPT1nJiZkZWxldGUgZ1tsXTt2YXIgbT10aGlzLmdldEVkZ2VzKGEpLGw9dGhpcy5ncmFwaC5tb2RlbDtmb3IoYz0wO2M8bS5sZW5ndGg7YysrKXt2YXIgbj10aGlzLmdldFZpc2libGVUZXJtaW5hbChtW2NdLCEwKSxwPW49PWE7cCYmKG49dGhpcy5nZXRWaXNpYmxlVGVybWluYWwobVtjXSwhMSkpO3ZhciBxO2ZvcihxPTA7cTx0aGlzLnN3aW1sYW5lcy5sZW5ndGgmJiFsLmlzQW5jZXN0b3IodGhpcy5zd2ltbGFuZXNbcV0sbik7cSsrKTtxPj10aGlzLnN3aW1sYW5lcy5sZW5ndGh8fCEocT5rfHwoIWJ8fHApJiZxPT1rKXx8KGU9dGhpcy50cmF2ZXJzZShuLApiLG1bY10sZCxlLGYsZyxxKSl9fWVsc2UgaWYobnVsbD09ZVtsXSlmb3IoYz0wO2M8Zi5sZW5ndGg7YysrKWlmKGE9ZltjXSxudWxsIT1hW2xdKXtmb3IobSBpbiBhKWVbbV09YVttXTtmLnNwbGljZShjLDEpO2JyZWFrfX1yZXR1cm4gZX07bXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUuY3ljbGVTdGFnZT1mdW5jdGlvbihhKXsobmV3IG14U3dpbWxhbmVPcmRlcmluZyh0aGlzKSkuZXhlY3V0ZShhKX07bXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUubGF5ZXJpbmdTdGFnZT1mdW5jdGlvbigpe3RoaXMubW9kZWwuaW5pdGlhbFJhbmsoKTt0aGlzLm1vZGVsLmZpeFJhbmtzKCl9O214U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLmNyb3NzaW5nU3RhZ2U9ZnVuY3Rpb24oYSl7KG5ldyBteE1lZGlhbkh5YnJpZENyb3NzaW5nUmVkdWN0aW9uKHRoaXMpKS5leGVjdXRlKGEpfTsKbXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUucGxhY2VtZW50U3RhZ2U9ZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgbXhDb29yZGluYXRlQXNzaWdubWVudCh0aGlzLHRoaXMuaW50cmFDZWxsU3BhY2luZyx0aGlzLmludGVyUmFua0NlbGxTcGFjaW5nLHRoaXMub3JpZW50YXRpb24sYSx0aGlzLnBhcmFsbGVsRWRnZVNwYWNpbmcpO2MuZmluZVR1bmluZz10aGlzLmZpbmVUdW5pbmc7Yy5leGVjdXRlKGIpO3JldHVybiBjLmxpbWl0WCt0aGlzLmludGVySGllcmFyY2h5U3BhY2luZ307ZnVuY3Rpb24gbXhHcmFwaE1vZGVsKGEpe3RoaXMuY3VycmVudEVkaXQ9dGhpcy5jcmVhdGVVbmRvYWJsZUVkaXQoKTtudWxsIT1hP3RoaXMuc2V0Um9vdChhKTp0aGlzLmNsZWFyKCl9bXhHcmFwaE1vZGVsLnByb3RvdHlwZT1uZXcgbXhFdmVudFNvdXJjZTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14R3JhcGhNb2RlbDtteEdyYXBoTW9kZWwucHJvdG90eXBlLnJvb3Q9bnVsbDsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS5jZWxscz1udWxsO214R3JhcGhNb2RlbC5wcm90b3R5cGUubWFpbnRhaW5FZGdlUGFyZW50PSEwO214R3JhcGhNb2RlbC5wcm90b3R5cGUuaWdub3JlUmVsYXRpdmVFZGdlUGFyZW50PSEwO214R3JhcGhNb2RlbC5wcm90b3R5cGUuY3JlYXRlSWRzPSEwO214R3JhcGhNb2RlbC5wcm90b3R5cGUucHJlZml4PSIiO214R3JhcGhNb2RlbC5wcm90b3R5cGUucG9zdGZpeD0iIjtteEdyYXBoTW9kZWwucHJvdG90eXBlLm5leHRJZD0wO214R3JhcGhNb2RlbC5wcm90b3R5cGUuY3VycmVudEVkaXQ9bnVsbDtteEdyYXBoTW9kZWwucHJvdG90eXBlLnVwZGF0ZUxldmVsPTA7bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5lbmRpbmdVcGRhdGU9ITE7bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMuc2V0Um9vdCh0aGlzLmNyZWF0ZVJvb3QoKSl9O214R3JhcGhNb2RlbC5wcm90b3R5cGUuaXNDcmVhdGVJZHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jcmVhdGVJZHN9OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLnNldENyZWF0ZUlkcz1mdW5jdGlvbihhKXt0aGlzLmNyZWF0ZUlkcz1hfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmNyZWF0ZVJvb3Q9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhDZWxsO2EuaW5zZXJ0KG5ldyBteENlbGwpO3JldHVybiBhfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmdldENlbGw9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPXRoaXMuY2VsbHM/dGhpcy5jZWxsc1thXTpudWxsfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmZpbHRlckNlbGxzPWZ1bmN0aW9uKGEsYil7dmFyIGM9bnVsbDtpZihudWxsIT1hKWZvcih2YXIgYz1bXSxkPTA7ZDxhLmxlbmd0aDtkKyspYihhW2RdKSYmYy5wdXNoKGFbZF0pO3JldHVybiBjfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmdldERlc2NlbmRhbnRzPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmZpbHRlckRlc2NlbmRhbnRzKG51bGwsYSl9OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLmZpbHRlckRlc2NlbmRhbnRzPWZ1bmN0aW9uKGEsYil7dmFyIGM9W107Yj1ifHx0aGlzLmdldFJvb3QoKTsobnVsbD09YXx8YShiKSkmJmMucHVzaChiKTtmb3IodmFyIGQ9dGhpcy5nZXRDaGlsZENvdW50KGIpLGU9MDtlPGQ7ZSsrKXZhciBmPXRoaXMuZ2V0Q2hpbGRBdChiLGUpLGM9Yy5jb25jYXQodGhpcy5maWx0ZXJEZXNjZW5kYW50cyhhLGYpKTtyZXR1cm4gY307bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZXRSb290PWZ1bmN0aW9uKGEpe3ZhciBiPWF8fHRoaXMucm9vdDtpZihudWxsIT1hKWZvcig7bnVsbCE9YTspYj1hLGE9dGhpcy5nZXRQYXJlbnQoYSk7cmV0dXJuIGJ9O214R3JhcGhNb2RlbC5wcm90b3R5cGUuc2V0Um9vdD1mdW5jdGlvbihhKXt0aGlzLmV4ZWN1dGUobmV3IG14Um9vdENoYW5nZSh0aGlzLGEpKTtyZXR1cm4gYX07Cm14R3JhcGhNb2RlbC5wcm90b3R5cGUucm9vdENoYW5nZWQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5yb290O3RoaXMucm9vdD1hO3RoaXMubmV4dElkPTA7dGhpcy5jZWxscz1udWxsO3RoaXMuY2VsbEFkZGVkKGEpO3JldHVybiBifTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmlzUm9vdD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YSYmdGhpcy5yb290PT1hfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmlzTGF5ZXI9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuaXNSb290KHRoaXMuZ2V0UGFyZW50KGEpKX07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5pc0FuY2VzdG9yPWZ1bmN0aW9uKGEsYil7Zm9yKDtudWxsIT1iJiZiIT1hOyliPXRoaXMuZ2V0UGFyZW50KGIpO3JldHVybiBiPT1hfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmNvbnRhaW5zPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmlzQW5jZXN0b3IodGhpcy5yb290LGEpfTsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZXRQYXJlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/YS5nZXRQYXJlbnQoKTpudWxsfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmFkZD1mdW5jdGlvbihhLGIsYyl7aWYoYiE9YSYmbnVsbCE9YSYmbnVsbCE9Yil7bnVsbD09YyYmKGM9dGhpcy5nZXRDaGlsZENvdW50KGEpKTt2YXIgZD1hIT10aGlzLmdldFBhcmVudChiKTt0aGlzLmV4ZWN1dGUobmV3IG14Q2hpbGRDaGFuZ2UodGhpcyxhLGIsYykpO3RoaXMubWFpbnRhaW5FZGdlUGFyZW50JiZkJiZ0aGlzLnVwZGF0ZUVkZ2VQYXJlbnRzKGIpfXJldHVybiBifTsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS5jZWxsQWRkZWQ9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSl7bnVsbD09YS5nZXRJZCgpJiZ0aGlzLmNyZWF0ZUlkcyYmYS5zZXRJZCh0aGlzLmNyZWF0ZUlkKGEpKTtpZihudWxsIT1hLmdldElkKCkpe3ZhciBiPXRoaXMuZ2V0Q2VsbChhLmdldElkKCkpO2lmKGIhPWEpe2Zvcig7bnVsbCE9YjspYS5zZXRJZCh0aGlzLmNyZWF0ZUlkKGEpKSxiPXRoaXMuZ2V0Q2VsbChhLmdldElkKCkpO251bGw9PXRoaXMuY2VsbHMmJih0aGlzLmNlbGxzPXt9KTt0aGlzLmNlbGxzW2EuZ2V0SWQoKV09YX19bXhVdGlscy5pc051bWVyaWMoYS5nZXRJZCgpKSYmKHRoaXMubmV4dElkPU1hdGgubWF4KHRoaXMubmV4dElkLGEuZ2V0SWQoKSkpO2Zvcih2YXIgYj10aGlzLmdldENoaWxkQ291bnQoYSksYz0wO2M8YjtjKyspdGhpcy5jZWxsQWRkZWQodGhpcy5nZXRDaGlsZEF0KGEsYykpfX07Cm14R3JhcGhNb2RlbC5wcm90b3R5cGUuY3JlYXRlSWQ9ZnVuY3Rpb24oYSl7YT10aGlzLm5leHRJZDt0aGlzLm5leHRJZCsrO3JldHVybiB0aGlzLnByZWZpeCthK3RoaXMucG9zdGZpeH07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS51cGRhdGVFZGdlUGFyZW50cz1mdW5jdGlvbihhLGIpe2I9Ynx8dGhpcy5nZXRSb290KGEpO2Zvcih2YXIgYz10aGlzLmdldENoaWxkQ291bnQoYSksZD0wO2Q8YztkKyspe3ZhciBlPXRoaXMuZ2V0Q2hpbGRBdChhLGQpO3RoaXMudXBkYXRlRWRnZVBhcmVudHMoZSxiKX1lPXRoaXMuZ2V0RWRnZUNvdW50KGEpO2M9W107Zm9yKGQ9MDtkPGU7ZCsrKWMucHVzaCh0aGlzLmdldEVkZ2VBdChhLGQpKTtmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCsrKWU9Y1tkXSx0aGlzLmlzQW5jZXN0b3IoYixlKSYmdGhpcy51cGRhdGVFZGdlUGFyZW50KGUsYil9OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLnVwZGF0ZUVkZ2VQYXJlbnQ9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9dGhpcy5nZXRUZXJtaW5hbChhLCEwKSxkPXRoaXMuZ2V0VGVybWluYWwoYSwhMSk7bnVsbCE9YyYmIXRoaXMuaXNFZGdlKGMpJiZudWxsIT1jLmdlb21ldHJ5JiZjLmdlb21ldHJ5LnJlbGF0aXZlOyljPXRoaXMuZ2V0UGFyZW50KGMpO2Zvcig7bnVsbCE9ZCYmdGhpcy5pZ25vcmVSZWxhdGl2ZUVkZ2VQYXJlbnQmJiF0aGlzLmlzRWRnZShkKSYmbnVsbCE9ZC5nZW9tZXRyeSYmZC5nZW9tZXRyeS5yZWxhdGl2ZTspZD10aGlzLmdldFBhcmVudChkKTtpZih0aGlzLmlzQW5jZXN0b3IoYixjKSYmdGhpcy5pc0FuY2VzdG9yKGIsZCkmJihjPWM9PWQ/dGhpcy5nZXRQYXJlbnQoYyk6dGhpcy5nZXROZWFyZXN0Q29tbW9uQW5jZXN0b3IoYyxkKSxudWxsIT1jJiYodGhpcy5nZXRQYXJlbnQoYykhPXRoaXMucm9vdHx8dGhpcy5pc0FuY2VzdG9yKGMsYSkpJiZ0aGlzLmdldFBhcmVudChhKSE9CmMpKXtkPXRoaXMuZ2V0R2VvbWV0cnkoYSk7aWYobnVsbCE9ZCl7dmFyIGU9dGhpcy5nZXRPcmlnaW4odGhpcy5nZXRQYXJlbnQoYSkpLGY9dGhpcy5nZXRPcmlnaW4oYyksZz1mLngtZS54LGU9Zi55LWUueSxkPWQuY2xvbmUoKTtkLnRyYW5zbGF0ZSgtZywtZSk7dGhpcy5zZXRHZW9tZXRyeShhLGQpfXRoaXMuYWRkKGMsYSx0aGlzLmdldENoaWxkQ291bnQoYykpfX07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZXRPcmlnaW49ZnVuY3Rpb24oYSl7dmFyIGI7bnVsbCE9YT8oYj10aGlzLmdldE9yaWdpbih0aGlzLmdldFBhcmVudChhKSksdGhpcy5pc0VkZ2UoYSl8fChhPXRoaXMuZ2V0R2VvbWV0cnkoYSksbnVsbCE9YSYmKGIueCs9YS54LGIueSs9YS55KSkpOmI9bmV3IG14UG9pbnQ7cmV0dXJuIGJ9OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLmdldE5lYXJlc3RDb21tb25BbmNlc3Rvcj1mdW5jdGlvbihhLGIpe2lmKG51bGwhPWEmJm51bGwhPWIpe3ZhciBjPW14Q2VsbFBhdGguY3JlYXRlKGIpO2lmKG51bGwhPWMmJjA8Yy5sZW5ndGgpe3ZhciBkPWEsZT1teENlbGxQYXRoLmNyZWF0ZShkKTtpZihjLmxlbmd0aDxlLmxlbmd0aCl2YXIgZD1iLGY9ZSxlPWMsYz1mO2Zvcig7bnVsbCE9ZDspe2Y9dGhpcy5nZXRQYXJlbnQoZCk7aWYoMD09Yy5pbmRleE9mKGUrbXhDZWxsUGF0aC5QQVRIX1NFUEFSQVRPUikmJm51bGwhPWYpcmV0dXJuIGQ7ZT1teENlbGxQYXRoLmdldFBhcmVudFBhdGgoZSk7ZD1mfX19cmV0dXJuIG51bGx9O214R3JhcGhNb2RlbC5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKGEpe2E9PXRoaXMucm9vdD90aGlzLnNldFJvb3QobnVsbCk6bnVsbCE9dGhpcy5nZXRQYXJlbnQoYSkmJnRoaXMuZXhlY3V0ZShuZXcgbXhDaGlsZENoYW5nZSh0aGlzLG51bGwsYSkpO3JldHVybiBhfTsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS5jZWxsUmVtb3ZlZD1mdW5jdGlvbihhKXtpZihudWxsIT1hJiZudWxsIT10aGlzLmNlbGxzKXtmb3IodmFyIGI9dGhpcy5nZXRDaGlsZENvdW50KGEpLTE7MDw9YjtiLS0pdGhpcy5jZWxsUmVtb3ZlZCh0aGlzLmdldENoaWxkQXQoYSxiKSk7bnVsbCE9dGhpcy5jZWxscyYmbnVsbCE9YS5nZXRJZCgpJiZkZWxldGUgdGhpcy5jZWxsc1thLmdldElkKCldfX07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5wYXJlbnRGb3JDZWxsQ2hhbmdlZD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5nZXRQYXJlbnQoYSk7bnVsbCE9Yj9iPT1kJiZkLmdldEluZGV4KGEpPT1jfHxiLmluc2VydChhLGMpOm51bGwhPWQmJihjPWQuZ2V0SW5kZXgoYSksZC5yZW1vdmUoYykpO2I9dGhpcy5jb250YWlucyhiKTtjPXRoaXMuY29udGFpbnMoZCk7YiYmIWM/dGhpcy5jZWxsQWRkZWQoYSk6YyYmIWImJnRoaXMuY2VsbFJlbW92ZWQoYSk7cmV0dXJuIGR9OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLmdldENoaWxkQ291bnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/YS5nZXRDaGlsZENvdW50KCk6MH07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZXRDaGlsZEF0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIG51bGwhPWE/YS5nZXRDaGlsZEF0KGIpOm51bGx9O214R3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0Q2hpbGRyZW49ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/YS5jaGlsZHJlbjpudWxsfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmdldENoaWxkVmVydGljZXM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZ2V0Q2hpbGRDZWxscyhhLCEwLCExKX07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZXRDaGlsZEVkZ2VzPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdldENoaWxkQ2VsbHMoYSwhMSwhMCl9OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLmdldENoaWxkQ2VsbHM9ZnVuY3Rpb24oYSxiLGMpe2I9bnVsbCE9Yj9iOiExO2M9bnVsbCE9Yz9jOiExO2Zvcih2YXIgZD10aGlzLmdldENoaWxkQ291bnQoYSksZT1bXSxmPTA7ZjxkO2YrKyl7dmFyIGc9dGhpcy5nZXRDaGlsZEF0KGEsZik7KCFjJiYhYnx8YyYmdGhpcy5pc0VkZ2UoZyl8fGImJnRoaXMuaXNWZXJ0ZXgoZykpJiZlLnB1c2goZyl9cmV0dXJuIGV9O214R3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0VGVybWluYWw9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbnVsbCE9YT9hLmdldFRlcm1pbmFsKGIpOm51bGx9OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLnNldFRlcm1pbmFsPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1iIT10aGlzLmdldFRlcm1pbmFsKGEsYyk7dGhpcy5leGVjdXRlKG5ldyBteFRlcm1pbmFsQ2hhbmdlKHRoaXMsYSxiLGMpKTt0aGlzLm1haW50YWluRWRnZVBhcmVudCYmZCYmdGhpcy51cGRhdGVFZGdlUGFyZW50KGEsdGhpcy5nZXRSb290KCkpO3JldHVybiBifTtteEdyYXBoTW9kZWwucHJvdG90eXBlLnNldFRlcm1pbmFscz1mdW5jdGlvbihhLGIsYyl7dGhpcy5iZWdpblVwZGF0ZSgpO3RyeXt0aGlzLnNldFRlcm1pbmFsKGEsYiwhMCksdGhpcy5zZXRUZXJtaW5hbChhLGMsITEpfWZpbmFsbHl7dGhpcy5lbmRVcGRhdGUoKX19OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLnRlcm1pbmFsRm9yQ2VsbENoYW5nZWQ9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuZ2V0VGVybWluYWwoYSxjKTtudWxsIT1iP2IuaW5zZXJ0RWRnZShhLGMpOm51bGwhPWQmJmQucmVtb3ZlRWRnZShhLGMpO3JldHVybiBkfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmdldEVkZ2VDb3VudD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YT9hLmdldEVkZ2VDb3VudCgpOjB9O214R3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0RWRnZUF0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIG51bGwhPWE/YS5nZXRFZGdlQXQoYik6bnVsbH07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZXREaXJlY3RlZEVkZ2VDb3VudD1mdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPTAsZT10aGlzLmdldEVkZ2VDb3VudChhKSxmPTA7ZjxlO2YrKyl7dmFyIGc9dGhpcy5nZXRFZGdlQXQoYSxmKTtnIT1jJiZ0aGlzLmdldFRlcm1pbmFsKGcsYik9PWEmJmQrK31yZXR1cm4gZH07Cm14R3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0Q29ubmVjdGlvbnM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZ2V0RWRnZXMoYSwhMCwhMCwhMSl9O214R3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0SW5jb21pbmdFZGdlcz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5nZXRFZGdlcyhhLCEwLCExLCExKX07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZXRPdXRnb2luZ0VkZ2VzPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdldEVkZ2VzKGEsITEsITAsITEpfTsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZXRFZGdlcz1mdW5jdGlvbihhLGIsYyxkKXtiPW51bGwhPWI/YjohMDtjPW51bGwhPWM/YzohMDtkPW51bGwhPWQ/ZDohMDtmb3IodmFyIGU9dGhpcy5nZXRFZGdlQ291bnQoYSksZj1bXSxnPTA7ZzxlO2crKyl7dmFyIGs9dGhpcy5nZXRFZGdlQXQoYSxnKSxsPXRoaXMuZ2V0VGVybWluYWwoaywhMCksbT10aGlzLmdldFRlcm1pbmFsKGssITEpOyhkJiZsPT1tfHxsIT1tJiYoYiYmbT09YXx8YyYmbD09YSkpJiZmLnB1c2goayl9cmV0dXJuIGZ9OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLmdldEVkZ2VzQmV0d2Vlbj1mdW5jdGlvbihhLGIsYyl7Yz1udWxsIT1jP2M6ITE7dmFyIGQ9dGhpcy5nZXRFZGdlQ291bnQoYSksZT10aGlzLmdldEVkZ2VDb3VudChiKSxmPWEsZz1kO2U8ZCYmKGc9ZSxmPWIpO2Q9W107Zm9yKGU9MDtlPGc7ZSsrKXt2YXIgaz10aGlzLmdldEVkZ2VBdChmLGUpLGw9dGhpcy5nZXRUZXJtaW5hbChrLCEwKSxtPXRoaXMuZ2V0VGVybWluYWwoaywhMSksbj1tPT1hJiZsPT1iOyhsPT1hJiZtPT1ifHwhYyYmbikmJmQucHVzaChrKX1yZXR1cm4gZH07Cm14R3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0T3Bwb3NpdGVzPWZ1bmN0aW9uKGEsYixjLGQpe2M9bnVsbCE9Yz9jOiEwO2Q9bnVsbCE9ZD9kOiEwO3ZhciBlPVtdO2lmKG51bGwhPWEpZm9yKHZhciBmPTA7ZjxhLmxlbmd0aDtmKyspe3ZhciBnPXRoaXMuZ2V0VGVybWluYWwoYVtmXSwhMCksaz10aGlzLmdldFRlcm1pbmFsKGFbZl0sITEpO2c9PWImJm51bGwhPWsmJmshPWImJmQ/ZS5wdXNoKGspOms9PWImJm51bGwhPWcmJmchPWImJmMmJmUucHVzaChnKX1yZXR1cm4gZX07Cm14R3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0VG9wbW9zdENlbGxzPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1uZXcgbXhEaWN0aW9uYXJ5LGM9W10sZD0wO2Q8YS5sZW5ndGg7ZCsrKWIucHV0KGFbZF0sITApO2ZvcihkPTA7ZDxhLmxlbmd0aDtkKyspe2Zvcih2YXIgZT1hW2RdLGY9ITAsZz10aGlzLmdldFBhcmVudChlKTtudWxsIT1nOyl7aWYoYi5nZXQoZykpe2Y9ITE7YnJlYWt9Zz10aGlzLmdldFBhcmVudChnKX1mJiZjLnB1c2goZSl9cmV0dXJuIGN9O214R3JhcGhNb2RlbC5wcm90b3R5cGUuaXNWZXJ0ZXg9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/YS5pc1ZlcnRleCgpOiExfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmlzRWRnZT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YT9hLmlzRWRnZSgpOiExfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmlzQ29ubmVjdGFibGU9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/YS5pc0Nvbm5lY3RhYmxlKCk6ITF9OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLmdldFZhbHVlPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hP2EuZ2V0VmFsdWUoKTpudWxsfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLnNldFZhbHVlPWZ1bmN0aW9uKGEsYil7dGhpcy5leGVjdXRlKG5ldyBteFZhbHVlQ2hhbmdlKHRoaXMsYSxiKSk7cmV0dXJuIGJ9O214R3JhcGhNb2RlbC5wcm90b3R5cGUudmFsdWVGb3JDZWxsQ2hhbmdlZD1mdW5jdGlvbihhLGIpe3JldHVybiBhLnZhbHVlQ2hhbmdlZChiKX07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZXRHZW9tZXRyeT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YT9hLmdldEdlb21ldHJ5KCk6bnVsbH07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5zZXRHZW9tZXRyeT1mdW5jdGlvbihhLGIpe2IhPXRoaXMuZ2V0R2VvbWV0cnkoYSkmJnRoaXMuZXhlY3V0ZShuZXcgbXhHZW9tZXRyeUNoYW5nZSh0aGlzLGEsYikpO3JldHVybiBifTsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZW9tZXRyeUZvckNlbGxDaGFuZ2VkPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5nZXRHZW9tZXRyeShhKTthLnNldEdlb21ldHJ5KGIpO3JldHVybiBjfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmdldFN0eWxlPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hP2EuZ2V0U3R5bGUoKTpudWxsfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLnNldFN0eWxlPWZ1bmN0aW9uKGEsYil7YiE9dGhpcy5nZXRTdHlsZShhKSYmdGhpcy5leGVjdXRlKG5ldyBteFN0eWxlQ2hhbmdlKHRoaXMsYSxiKSk7cmV0dXJuIGJ9O214R3JhcGhNb2RlbC5wcm90b3R5cGUuc3R5bGVGb3JDZWxsQ2hhbmdlZD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ2V0U3R5bGUoYSk7YS5zZXRTdHlsZShiKTtyZXR1cm4gY307bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5pc0NvbGxhcHNlZD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YT9hLmlzQ29sbGFwc2VkKCk6ITF9OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLnNldENvbGxhcHNlZD1mdW5jdGlvbihhLGIpe2IhPXRoaXMuaXNDb2xsYXBzZWQoYSkmJnRoaXMuZXhlY3V0ZShuZXcgbXhDb2xsYXBzZUNoYW5nZSh0aGlzLGEsYikpO3JldHVybiBifTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmNvbGxhcHNlZFN0YXRlRm9yQ2VsbENoYW5nZWQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmlzQ29sbGFwc2VkKGEpO2Euc2V0Q29sbGFwc2VkKGIpO3JldHVybiBjfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmlzVmlzaWJsZT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YT9hLmlzVmlzaWJsZSgpOiExfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLnNldFZpc2libGU9ZnVuY3Rpb24oYSxiKXtiIT10aGlzLmlzVmlzaWJsZShhKSYmdGhpcy5leGVjdXRlKG5ldyBteFZpc2libGVDaGFuZ2UodGhpcyxhLGIpKTtyZXR1cm4gYn07Cm14R3JhcGhNb2RlbC5wcm90b3R5cGUudmlzaWJsZVN0YXRlRm9yQ2VsbENoYW5nZWQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmlzVmlzaWJsZShhKTthLnNldFZpc2libGUoYik7cmV0dXJuIGN9O214R3JhcGhNb2RlbC5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihhKXthLmV4ZWN1dGUoKTt0aGlzLmJlZ2luVXBkYXRlKCk7dGhpcy5jdXJyZW50RWRpdC5hZGQoYSk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5FWEVDVVRFLCJjaGFuZ2UiLGEpKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkVYRUNVVEVELCJjaGFuZ2UiLGEpKTt0aGlzLmVuZFVwZGF0ZSgpfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmJlZ2luVXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy51cGRhdGVMZXZlbCsrO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuQkVHSU5fVVBEQVRFKSk7MT09dGhpcy51cGRhdGVMZXZlbCYmdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5TVEFSVF9FRElUKSl9OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLmVuZFVwZGF0ZT1mdW5jdGlvbigpe3RoaXMudXBkYXRlTGV2ZWwtLTswPT10aGlzLnVwZGF0ZUxldmVsJiZ0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkVORF9FRElUKSk7aWYoIXRoaXMuZW5kaW5nVXBkYXRlKXt0aGlzLmVuZGluZ1VwZGF0ZT0wPT10aGlzLnVwZGF0ZUxldmVsO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuRU5EX1VQREFURSwiZWRpdCIsdGhpcy5jdXJyZW50RWRpdCkpO3RyeXtpZih0aGlzLmVuZGluZ1VwZGF0ZSYmIXRoaXMuY3VycmVudEVkaXQuaXNFbXB0eSgpKXt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkJFRk9SRV9VTkRPLCJlZGl0Iix0aGlzLmN1cnJlbnRFZGl0KSk7dmFyIGE9dGhpcy5jdXJyZW50RWRpdDt0aGlzLmN1cnJlbnRFZGl0PXRoaXMuY3JlYXRlVW5kb2FibGVFZGl0KCk7YS5ub3RpZnkoKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlVORE8sCiJlZGl0IixhKSl9fWZpbmFsbHl7dGhpcy5lbmRpbmdVcGRhdGU9ITF9fX07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5jcmVhdGVVbmRvYWJsZUVkaXQ9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IG14VW5kb2FibGVFZGl0KHRoaXMsbnVsbCE9YT9hOiEwKTtiLm5vdGlmeT1mdW5jdGlvbigpe2Iuc291cmNlLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkNIQU5HRSwiZWRpdCIsYiwiY2hhbmdlcyIsYi5jaGFuZ2VzKSk7Yi5zb3VyY2UuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuTk9USUZZLCJlZGl0IixiLCJjaGFuZ2VzIixiLmNoYW5nZXMpKX07cmV0dXJuIGJ9OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLm1lcmdlQ2hpbGRyZW49ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbCE9Yz9jOiEwO3RoaXMuYmVnaW5VcGRhdGUoKTt0cnl7dmFyIGQ9e307dGhpcy5tZXJnZUNoaWxkcmVuSW1wbChhLGIsYyxkKTtmb3IodmFyIGUgaW4gZCl7dmFyIGY9ZFtlXSxnPXRoaXMuZ2V0VGVybWluYWwoZiwhMCk7bnVsbCE9ZyYmKGc9ZFtteENlbGxQYXRoLmNyZWF0ZShnKV0sdGhpcy5zZXRUZXJtaW5hbChmLGcsITApKTtnPXRoaXMuZ2V0VGVybWluYWwoZiwhMSk7bnVsbCE9ZyYmKGc9ZFtteENlbGxQYXRoLmNyZWF0ZShnKV0sdGhpcy5zZXRUZXJtaW5hbChmLGcsITEpKX19ZmluYWxseXt0aGlzLmVuZFVwZGF0ZSgpfX07Cm14R3JhcGhNb2RlbC5wcm90b3R5cGUubWVyZ2VDaGlsZHJlbkltcGw9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGU9YS5nZXRDaGlsZENvdW50KCksZj0wO2Y8ZTtmKyspe3ZhciBnPWEuZ2V0Q2hpbGRBdChmKTtpZigiZnVuY3Rpb24iPT10eXBlb2YgZy5nZXRJZCl7dmFyIGs9Zy5nZXRJZCgpLGw9bnVsbD09a3x8dGhpcy5pc0VkZ2UoZykmJmM/bnVsbDp0aGlzLmdldENlbGwoayk7aWYobnVsbD09bCl7dmFyIG09Zy5jbG9uZSgpO20uc2V0SWQoayk7bS5zZXRUZXJtaW5hbChnLmdldFRlcm1pbmFsKCEwKSwhMCk7bS5zZXRUZXJtaW5hbChnLmdldFRlcm1pbmFsKCExKSwhMSk7bD1iLmluc2VydChtKTt0aGlzLmNlbGxBZGRlZChsKX1kW214Q2VsbFBhdGguY3JlYXRlKGcpXT1sO3RoaXMubWVyZ2VDaGlsZHJlbkltcGwoZyxsLGMsZCl9fX1maW5hbGx5e3RoaXMuZW5kVXBkYXRlKCl9fTsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZXRQYXJlbnRzPWZ1bmN0aW9uKGEpe3ZhciBiPVtdO2lmKG51bGwhPWEpZm9yKHZhciBjPW5ldyBteERpY3Rpb25hcnksZD0wO2Q8YS5sZW5ndGg7ZCsrKXt2YXIgZT10aGlzLmdldFBhcmVudChhW2RdKTtudWxsPT1lfHxjLmdldChlKXx8KGMucHV0KGUsITApLGIucHVzaChlKSl9cmV0dXJuIGJ9O214R3JhcGhNb2RlbC5wcm90b3R5cGUuY2xvbmVDZWxsPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG51bGwhPWE/dGhpcy5jbG9uZUNlbGxzKFthXSxiKVswXTpudWxsfTsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS5jbG9uZUNlbGxzPWZ1bmN0aW9uKGEsYixjKXtiPW51bGwhPWI/YjohMDtjPW51bGwhPWM/Yzp7fTtmb3IodmFyIGQ9W10sZT0wO2U8YS5sZW5ndGg7ZSsrKW51bGwhPWFbZV0/ZC5wdXNoKHRoaXMuY2xvbmVDZWxsSW1wbChhW2VdLGMsYikpOmQucHVzaChudWxsKTtmb3IoZT0wO2U8ZC5sZW5ndGg7ZSsrKW51bGwhPWRbZV0mJnRoaXMucmVzdG9yZUNsb25lKGRbZV0sYVtlXSxjKTtyZXR1cm4gZH07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5jbG9uZUNlbGxJbXBsPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1teE9iamVjdElkZW50aXR5LmdldChhKSxlPWJbZF07aWYobnVsbD09ZSYmKGU9dGhpcy5jZWxsQ2xvbmVkKGEpLGJbZF09ZSxjKSlmb3IoYz10aGlzLmdldENoaWxkQ291bnQoYSksZD0wO2Q8YztkKyspe3ZhciBmPXRoaXMuY2xvbmVDZWxsSW1wbCh0aGlzLmdldENoaWxkQXQoYSxkKSxiLCEwKTtlLmluc2VydChmKX1yZXR1cm4gZX07Cm14R3JhcGhNb2RlbC5wcm90b3R5cGUuY2VsbENsb25lZD1mdW5jdGlvbihhKXtyZXR1cm4gYS5jbG9uZSgpfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLnJlc3RvcmVDbG9uZT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5nZXRUZXJtaW5hbChiLCEwKTtudWxsIT1kJiYoZD1jW214T2JqZWN0SWRlbnRpdHkuZ2V0KGQpXSxudWxsIT1kJiZkLmluc2VydEVkZ2UoYSwhMCkpO2Q9dGhpcy5nZXRUZXJtaW5hbChiLCExKTtudWxsIT1kJiYoZD1jW214T2JqZWN0SWRlbnRpdHkuZ2V0KGQpXSxudWxsIT1kJiZkLmluc2VydEVkZ2UoYSwhMSkpO2Zvcih2YXIgZD10aGlzLmdldENoaWxkQ291bnQoYSksZT0wO2U8ZDtlKyspdGhpcy5yZXN0b3JlQ2xvbmUodGhpcy5nZXRDaGlsZEF0KGEsZSksdGhpcy5nZXRDaGlsZEF0KGIsZSksYyl9O2Z1bmN0aW9uIG14Um9vdENoYW5nZShhLGIpe3RoaXMubW9kZWw9YTt0aGlzLnByZXZpb3VzPXRoaXMucm9vdD1ifQpteFJvb3RDaGFuZ2UucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXt0aGlzLnJvb3Q9dGhpcy5wcmV2aW91czt0aGlzLnByZXZpb3VzPXRoaXMubW9kZWwucm9vdENoYW5nZWQodGhpcy5wcmV2aW91cyl9O2Z1bmN0aW9uIG14Q2hpbGRDaGFuZ2UoYSxiLGMsZCl7dGhpcy5tb2RlbD1hO3RoaXMucHJldmlvdXM9dGhpcy5wYXJlbnQ9Yjt0aGlzLmNoaWxkPWM7dGhpcy5wcmV2aW91c0luZGV4PXRoaXMuaW5kZXg9ZH0KbXhDaGlsZENoYW5nZS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe2lmKG51bGwhPXRoaXMuY2hpbGQpe3ZhciBhPXRoaXMubW9kZWwuZ2V0UGFyZW50KHRoaXMuY2hpbGQpLGI9bnVsbCE9YT9hLmdldEluZGV4KHRoaXMuY2hpbGQpOjA7bnVsbD09dGhpcy5wcmV2aW91cyYmdGhpcy5jb25uZWN0KHRoaXMuY2hpbGQsITEpO2E9dGhpcy5tb2RlbC5wYXJlbnRGb3JDZWxsQ2hhbmdlZCh0aGlzLmNoaWxkLHRoaXMucHJldmlvdXMsdGhpcy5wcmV2aW91c0luZGV4KTtudWxsIT10aGlzLnByZXZpb3VzJiZ0aGlzLmNvbm5lY3QodGhpcy5jaGlsZCwhMCk7dGhpcy5wYXJlbnQ9dGhpcy5wcmV2aW91czt0aGlzLnByZXZpb3VzPWE7dGhpcy5pbmRleD10aGlzLnByZXZpb3VzSW5kZXg7dGhpcy5wcmV2aW91c0luZGV4PWJ9fTsKbXhDaGlsZENoYW5nZS5wcm90b3R5cGUuY29ubmVjdD1mdW5jdGlvbihhLGIpe2I9bnVsbCE9Yj9iOiEwO3ZhciBjPWEuZ2V0VGVybWluYWwoITApLGQ9YS5nZXRUZXJtaW5hbCghMSk7bnVsbCE9YyYmKGI/dGhpcy5tb2RlbC50ZXJtaW5hbEZvckNlbGxDaGFuZ2VkKGEsYywhMCk6dGhpcy5tb2RlbC50ZXJtaW5hbEZvckNlbGxDaGFuZ2VkKGEsbnVsbCwhMCkpO251bGwhPWQmJihiP3RoaXMubW9kZWwudGVybWluYWxGb3JDZWxsQ2hhbmdlZChhLGQsITEpOnRoaXMubW9kZWwudGVybWluYWxGb3JDZWxsQ2hhbmdlZChhLG51bGwsITEpKTthLnNldFRlcm1pbmFsKGMsITApO2Euc2V0VGVybWluYWwoZCwhMSk7Yz10aGlzLm1vZGVsLmdldENoaWxkQ291bnQoYSk7Zm9yKGQ9MDtkPGM7ZCsrKXRoaXMuY29ubmVjdCh0aGlzLm1vZGVsLmdldENoaWxkQXQoYSxkKSxiKX07CmZ1bmN0aW9uIG14VGVybWluYWxDaGFuZ2UoYSxiLGMsZCl7dGhpcy5tb2RlbD1hO3RoaXMuY2VsbD1iO3RoaXMucHJldmlvdXM9dGhpcy50ZXJtaW5hbD1jO3RoaXMuc291cmNlPWR9bXhUZXJtaW5hbENoYW5nZS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe251bGwhPXRoaXMuY2VsbCYmKHRoaXMudGVybWluYWw9dGhpcy5wcmV2aW91cyx0aGlzLnByZXZpb3VzPXRoaXMubW9kZWwudGVybWluYWxGb3JDZWxsQ2hhbmdlZCh0aGlzLmNlbGwsdGhpcy5wcmV2aW91cyx0aGlzLnNvdXJjZSkpfTtmdW5jdGlvbiBteFZhbHVlQ2hhbmdlKGEsYixjKXt0aGlzLm1vZGVsPWE7dGhpcy5jZWxsPWI7dGhpcy5wcmV2aW91cz10aGlzLnZhbHVlPWN9Cm14VmFsdWVDaGFuZ2UucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmNlbGwmJih0aGlzLnZhbHVlPXRoaXMucHJldmlvdXMsdGhpcy5wcmV2aW91cz10aGlzLm1vZGVsLnZhbHVlRm9yQ2VsbENoYW5nZWQodGhpcy5jZWxsLHRoaXMucHJldmlvdXMpKX07ZnVuY3Rpb24gbXhTdHlsZUNoYW5nZShhLGIsYyl7dGhpcy5tb2RlbD1hO3RoaXMuY2VsbD1iO3RoaXMucHJldmlvdXM9dGhpcy5zdHlsZT1jfW14U3R5bGVDaGFuZ2UucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmNlbGwmJih0aGlzLnN0eWxlPXRoaXMucHJldmlvdXMsdGhpcy5wcmV2aW91cz10aGlzLm1vZGVsLnN0eWxlRm9yQ2VsbENoYW5nZWQodGhpcy5jZWxsLHRoaXMucHJldmlvdXMpKX07ZnVuY3Rpb24gbXhHZW9tZXRyeUNoYW5nZShhLGIsYyl7dGhpcy5tb2RlbD1hO3RoaXMuY2VsbD1iO3RoaXMucHJldmlvdXM9dGhpcy5nZW9tZXRyeT1jfQpteEdlb21ldHJ5Q2hhbmdlLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5jZWxsJiYodGhpcy5nZW9tZXRyeT10aGlzLnByZXZpb3VzLHRoaXMucHJldmlvdXM9dGhpcy5tb2RlbC5nZW9tZXRyeUZvckNlbGxDaGFuZ2VkKHRoaXMuY2VsbCx0aGlzLnByZXZpb3VzKSl9O2Z1bmN0aW9uIG14Q29sbGFwc2VDaGFuZ2UoYSxiLGMpe3RoaXMubW9kZWw9YTt0aGlzLmNlbGw9Yjt0aGlzLnByZXZpb3VzPXRoaXMuY29sbGFwc2VkPWN9bXhDb2xsYXBzZUNoYW5nZS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe251bGwhPXRoaXMuY2VsbCYmKHRoaXMuY29sbGFwc2VkPXRoaXMucHJldmlvdXMsdGhpcy5wcmV2aW91cz10aGlzLm1vZGVsLmNvbGxhcHNlZFN0YXRlRm9yQ2VsbENoYW5nZWQodGhpcy5jZWxsLHRoaXMucHJldmlvdXMpKX07CmZ1bmN0aW9uIG14VmlzaWJsZUNoYW5nZShhLGIsYyl7dGhpcy5tb2RlbD1hO3RoaXMuY2VsbD1iO3RoaXMucHJldmlvdXM9dGhpcy52aXNpYmxlPWN9bXhWaXNpYmxlQ2hhbmdlLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5jZWxsJiYodGhpcy52aXNpYmxlPXRoaXMucHJldmlvdXMsdGhpcy5wcmV2aW91cz10aGlzLm1vZGVsLnZpc2libGVTdGF0ZUZvckNlbGxDaGFuZ2VkKHRoaXMuY2VsbCx0aGlzLnByZXZpb3VzKSl9O2Z1bmN0aW9uIG14Q2VsbEF0dHJpYnV0ZUNoYW5nZShhLGIsYyl7dGhpcy5jZWxsPWE7dGhpcy5hdHRyaWJ1dGU9Yjt0aGlzLnByZXZpb3VzPXRoaXMudmFsdWU9Y30KbXhDZWxsQXR0cmlidXRlQ2hhbmdlLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKCl7aWYobnVsbCE9dGhpcy5jZWxsKXt2YXIgYT10aGlzLmNlbGwuZ2V0QXR0cmlidXRlKHRoaXMuYXR0cmlidXRlKTtudWxsPT10aGlzLnByZXZpb3VzP3RoaXMuY2VsbC52YWx1ZS5yZW1vdmVBdHRyaWJ1dGUodGhpcy5hdHRyaWJ1dGUpOnRoaXMuY2VsbC5zZXRBdHRyaWJ1dGUodGhpcy5hdHRyaWJ1dGUsdGhpcy5wcmV2aW91cyk7dGhpcy5wcmV2aW91cz1hfX07ZnVuY3Rpb24gbXhDZWxsKGEsYixjKXt0aGlzLnZhbHVlPWE7dGhpcy5zZXRHZW9tZXRyeShiKTt0aGlzLnNldFN0eWxlKGMpO2lmKG51bGwhPXRoaXMub25Jbml0KXRoaXMub25Jbml0KCl9bXhDZWxsLnByb3RvdHlwZS5pZD1udWxsO214Q2VsbC5wcm90b3R5cGUudmFsdWU9bnVsbDtteENlbGwucHJvdG90eXBlLmdlb21ldHJ5PW51bGw7bXhDZWxsLnByb3RvdHlwZS5zdHlsZT1udWxsO214Q2VsbC5wcm90b3R5cGUudmVydGV4PSExOwpteENlbGwucHJvdG90eXBlLmVkZ2U9ITE7bXhDZWxsLnByb3RvdHlwZS5jb25uZWN0YWJsZT0hMDtteENlbGwucHJvdG90eXBlLnZpc2libGU9ITA7bXhDZWxsLnByb3RvdHlwZS5jb2xsYXBzZWQ9ITE7bXhDZWxsLnByb3RvdHlwZS5wYXJlbnQ9bnVsbDtteENlbGwucHJvdG90eXBlLnNvdXJjZT1udWxsO214Q2VsbC5wcm90b3R5cGUudGFyZ2V0PW51bGw7bXhDZWxsLnByb3RvdHlwZS5jaGlsZHJlbj1udWxsO214Q2VsbC5wcm90b3R5cGUuZWRnZXM9bnVsbDtteENlbGwucHJvdG90eXBlLm14VHJhbnNpZW50PSJpZCB2YWx1ZSBwYXJlbnQgc291cmNlIHRhcmdldCBjaGlsZHJlbiBlZGdlcyIuc3BsaXQoIiAiKTtteENlbGwucHJvdG90eXBlLmdldElkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaWR9O214Q2VsbC5wcm90b3R5cGUuc2V0SWQ9ZnVuY3Rpb24oYSl7dGhpcy5pZD1hfTtteENlbGwucHJvdG90eXBlLmdldFZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWV9OwpteENlbGwucHJvdG90eXBlLnNldFZhbHVlPWZ1bmN0aW9uKGEpe3RoaXMudmFsdWU9YX07bXhDZWxsLnByb3RvdHlwZS52YWx1ZUNoYW5nZWQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5nZXRWYWx1ZSgpO3RoaXMuc2V0VmFsdWUoYSk7cmV0dXJuIGJ9O214Q2VsbC5wcm90b3R5cGUuZ2V0R2VvbWV0cnk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZW9tZXRyeX07bXhDZWxsLnByb3RvdHlwZS5zZXRHZW9tZXRyeT1mdW5jdGlvbihhKXt0aGlzLmdlb21ldHJ5PWF9O214Q2VsbC5wcm90b3R5cGUuZ2V0U3R5bGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdHlsZX07bXhDZWxsLnByb3RvdHlwZS5zZXRTdHlsZT1mdW5jdGlvbihhKXt0aGlzLnN0eWxlPWF9O214Q2VsbC5wcm90b3R5cGUuaXNWZXJ0ZXg9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9dGhpcy52ZXJ0ZXh9O214Q2VsbC5wcm90b3R5cGUuc2V0VmVydGV4PWZ1bmN0aW9uKGEpe3RoaXMudmVydGV4PWF9OwpteENlbGwucHJvdG90eXBlLmlzRWRnZT1mdW5jdGlvbigpe3JldHVybiAwIT10aGlzLmVkZ2V9O214Q2VsbC5wcm90b3R5cGUuc2V0RWRnZT1mdW5jdGlvbihhKXt0aGlzLmVkZ2U9YX07bXhDZWxsLnByb3RvdHlwZS5pc0Nvbm5lY3RhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPXRoaXMuY29ubmVjdGFibGV9O214Q2VsbC5wcm90b3R5cGUuc2V0Q29ubmVjdGFibGU9ZnVuY3Rpb24oYSl7dGhpcy5jb25uZWN0YWJsZT1hfTtteENlbGwucHJvdG90eXBlLmlzVmlzaWJsZT1mdW5jdGlvbigpe3JldHVybiAwIT10aGlzLnZpc2libGV9O214Q2VsbC5wcm90b3R5cGUuc2V0VmlzaWJsZT1mdW5jdGlvbihhKXt0aGlzLnZpc2libGU9YX07bXhDZWxsLnByb3RvdHlwZS5pc0NvbGxhcHNlZD1mdW5jdGlvbigpe3JldHVybiAwIT10aGlzLmNvbGxhcHNlZH07bXhDZWxsLnByb3RvdHlwZS5zZXRDb2xsYXBzZWQ9ZnVuY3Rpb24oYSl7dGhpcy5jb2xsYXBzZWQ9YX07Cm14Q2VsbC5wcm90b3R5cGUuZ2V0UGFyZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyZW50fTtteENlbGwucHJvdG90eXBlLnNldFBhcmVudD1mdW5jdGlvbihhKXt0aGlzLnBhcmVudD1hfTtteENlbGwucHJvdG90eXBlLmdldFRlcm1pbmFsPWZ1bmN0aW9uKGEpe3JldHVybiBhP3RoaXMuc291cmNlOnRoaXMudGFyZ2V0fTtteENlbGwucHJvdG90eXBlLnNldFRlcm1pbmFsPWZ1bmN0aW9uKGEsYil7Yj90aGlzLnNvdXJjZT1hOnRoaXMudGFyZ2V0PWE7cmV0dXJuIGF9O214Q2VsbC5wcm90b3R5cGUuZ2V0Q2hpbGRDb3VudD1mdW5jdGlvbigpe3JldHVybiBudWxsPT10aGlzLmNoaWxkcmVuPzA6dGhpcy5jaGlsZHJlbi5sZW5ndGh9O214Q2VsbC5wcm90b3R5cGUuZ2V0SW5kZXg9ZnVuY3Rpb24oYSl7cmV0dXJuIG14VXRpbHMuaW5kZXhPZih0aGlzLmNoaWxkcmVuLGEpfTsKbXhDZWxsLnByb3RvdHlwZS5nZXRDaGlsZEF0PWZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT10aGlzLmNoaWxkcmVuP251bGw6dGhpcy5jaGlsZHJlblthXX07bXhDZWxsLnByb3RvdHlwZS5pbnNlcnQ9ZnVuY3Rpb24oYSxiKXtudWxsIT1hJiYobnVsbD09YiYmKGI9dGhpcy5nZXRDaGlsZENvdW50KCksYS5nZXRQYXJlbnQoKT09dGhpcyYmYi0tKSxhLnJlbW92ZUZyb21QYXJlbnQoKSxhLnNldFBhcmVudCh0aGlzKSxudWxsPT10aGlzLmNoaWxkcmVuPyh0aGlzLmNoaWxkcmVuPVtdLHRoaXMuY2hpbGRyZW4ucHVzaChhKSk6dGhpcy5jaGlsZHJlbi5zcGxpY2UoYiwwLGEpKTtyZXR1cm4gYX07bXhDZWxsLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbDtudWxsIT10aGlzLmNoaWxkcmVuJiYwPD1hJiYoYj10aGlzLmdldENoaWxkQXQoYSksbnVsbCE9YiYmKHRoaXMuY2hpbGRyZW4uc3BsaWNlKGEsMSksYi5zZXRQYXJlbnQobnVsbCkpKTtyZXR1cm4gYn07Cm14Q2VsbC5wcm90b3R5cGUucmVtb3ZlRnJvbVBhcmVudD1mdW5jdGlvbigpe2lmKG51bGwhPXRoaXMucGFyZW50KXt2YXIgYT10aGlzLnBhcmVudC5nZXRJbmRleCh0aGlzKTt0aGlzLnBhcmVudC5yZW1vdmUoYSl9fTtteENlbGwucHJvdG90eXBlLmdldEVkZ2VDb3VudD1mdW5jdGlvbigpe3JldHVybiBudWxsPT10aGlzLmVkZ2VzPzA6dGhpcy5lZGdlcy5sZW5ndGh9O214Q2VsbC5wcm90b3R5cGUuZ2V0RWRnZUluZGV4PWZ1bmN0aW9uKGEpe3JldHVybiBteFV0aWxzLmluZGV4T2YodGhpcy5lZGdlcyxhKX07bXhDZWxsLnByb3RvdHlwZS5nZXRFZGdlQXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PXRoaXMuZWRnZXM/bnVsbDp0aGlzLmVkZ2VzW2FdfTsKbXhDZWxsLnByb3RvdHlwZS5pbnNlcnRFZGdlPWZ1bmN0aW9uKGEsYil7bnVsbCE9YSYmKGEucmVtb3ZlRnJvbVRlcm1pbmFsKGIpLGEuc2V0VGVybWluYWwodGhpcyxiKSxudWxsPT10aGlzLmVkZ2VzfHxhLmdldFRlcm1pbmFsKCFiKSE9dGhpc3x8MD5teFV0aWxzLmluZGV4T2YodGhpcy5lZGdlcyxhKSkmJihudWxsPT10aGlzLmVkZ2VzJiYodGhpcy5lZGdlcz1bXSksdGhpcy5lZGdlcy5wdXNoKGEpKTtyZXR1cm4gYX07bXhDZWxsLnByb3RvdHlwZS5yZW1vdmVFZGdlPWZ1bmN0aW9uKGEsYil7aWYobnVsbCE9YSl7aWYoYS5nZXRUZXJtaW5hbCghYikhPXRoaXMmJm51bGwhPXRoaXMuZWRnZXMpe3ZhciBjPXRoaXMuZ2V0RWRnZUluZGV4KGEpOzA8PWMmJnRoaXMuZWRnZXMuc3BsaWNlKGMsMSl9YS5zZXRUZXJtaW5hbChudWxsLGIpfXJldHVybiBhfTsKbXhDZWxsLnByb3RvdHlwZS5yZW1vdmVGcm9tVGVybWluYWw9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5nZXRUZXJtaW5hbChhKTtudWxsIT1iJiZiLnJlbW92ZUVkZ2UodGhpcyxhKX07bXhDZWxsLnByb3RvdHlwZS5oYXNBdHRyaWJ1dGU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5nZXRWYWx1ZSgpO3JldHVybiBudWxsIT1iJiZiLm5vZGVUeXBlPT1teENvbnN0YW50cy5OT0RFVFlQRV9FTEVNRU5UJiZiLmhhc0F0dHJpYnV0ZT9iLmhhc0F0dHJpYnV0ZShhKTpudWxsIT1iLmdldEF0dHJpYnV0ZShhKX07bXhDZWxsLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGU9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdldFZhbHVlKCksYz1udWxsIT1jJiZjLm5vZGVUeXBlPT1teENvbnN0YW50cy5OT0RFVFlQRV9FTEVNRU5UP2MuZ2V0QXR0cmlidXRlKGEpOm51bGw7cmV0dXJuIG51bGwhPWM/YzpifTsKbXhDZWxsLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGU9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdldFZhbHVlKCk7bnVsbCE9YyYmYy5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVCYmYy5zZXRBdHRyaWJ1dGUoYSxiKX07bXhDZWxsLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBhPW14VXRpbHMuY2xvbmUodGhpcyx0aGlzLm14VHJhbnNpZW50KTthLnNldFZhbHVlKHRoaXMuY2xvbmVWYWx1ZSgpKTtyZXR1cm4gYX07bXhDZWxsLnByb3RvdHlwZS5jbG9uZVZhbHVlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRWYWx1ZSgpO251bGwhPWEmJigiZnVuY3Rpb24iPT10eXBlb2YgYS5jbG9uZT9hPWEuY2xvbmUoKTppc05hTihhLm5vZGVUeXBlKXx8KGE9YS5jbG9uZU5vZGUoITApKSk7cmV0dXJuIGF9O2Z1bmN0aW9uIG14R2VvbWV0cnkoYSxiLGMsZCl7bXhSZWN0YW5nbGUuY2FsbCh0aGlzLGEsYixjLGQpfW14R2VvbWV0cnkucHJvdG90eXBlPW5ldyBteFJlY3RhbmdsZTsKbXhHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhHZW9tZXRyeTtteEdlb21ldHJ5LnByb3RvdHlwZS5UUkFOU0xBVEVfQ09OVFJPTF9QT0lOVFM9ITA7bXhHZW9tZXRyeS5wcm90b3R5cGUuYWx0ZXJuYXRlQm91bmRzPW51bGw7bXhHZW9tZXRyeS5wcm90b3R5cGUuc291cmNlUG9pbnQ9bnVsbDtteEdlb21ldHJ5LnByb3RvdHlwZS50YXJnZXRQb2ludD1udWxsO214R2VvbWV0cnkucHJvdG90eXBlLnBvaW50cz1udWxsO214R2VvbWV0cnkucHJvdG90eXBlLm9mZnNldD1udWxsO214R2VvbWV0cnkucHJvdG90eXBlLnJlbGF0aXZlPSExOwpteEdlb21ldHJ5LnByb3RvdHlwZS5zd2FwPWZ1bmN0aW9uKCl7aWYobnVsbCE9dGhpcy5hbHRlcm5hdGVCb3VuZHMpe3ZhciBhPW5ldyBteFJlY3RhbmdsZSh0aGlzLngsdGhpcy55LHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpO3RoaXMueD10aGlzLmFsdGVybmF0ZUJvdW5kcy54O3RoaXMueT10aGlzLmFsdGVybmF0ZUJvdW5kcy55O3RoaXMud2lkdGg9dGhpcy5hbHRlcm5hdGVCb3VuZHMud2lkdGg7dGhpcy5oZWlnaHQ9dGhpcy5hbHRlcm5hdGVCb3VuZHMuaGVpZ2h0O3RoaXMuYWx0ZXJuYXRlQm91bmRzPWF9fTtteEdlb21ldHJ5LnByb3RvdHlwZS5nZXRUZXJtaW5hbFBvaW50PWZ1bmN0aW9uKGEpe3JldHVybiBhP3RoaXMuc291cmNlUG9pbnQ6dGhpcy50YXJnZXRQb2ludH07bXhHZW9tZXRyeS5wcm90b3R5cGUuc2V0VGVybWluYWxQb2ludD1mdW5jdGlvbihhLGIpe2I/dGhpcy5zb3VyY2VQb2ludD1hOnRoaXMudGFyZ2V0UG9pbnQ9YTtyZXR1cm4gYX07Cm14R2VvbWV0cnkucHJvdG90eXBlLnJvdGF0ZT1mdW5jdGlvbihhLGIpe3ZhciBjPW14VXRpbHMudG9SYWRpYW5zKGEpLGQ9TWF0aC5jb3MoYyksYz1NYXRoLnNpbihjKTtpZighdGhpcy5yZWxhdGl2ZSl7dmFyIGU9bmV3IG14UG9pbnQodGhpcy5nZXRDZW50ZXJYKCksdGhpcy5nZXRDZW50ZXJZKCkpLGU9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQoZSxkLGMsYik7dGhpcy54PU1hdGgucm91bmQoZS54LXRoaXMud2lkdGgvMik7dGhpcy55PU1hdGgucm91bmQoZS55LXRoaXMuaGVpZ2h0LzIpfW51bGwhPXRoaXMuc291cmNlUG9pbnQmJihlPW14VXRpbHMuZ2V0Um90YXRlZFBvaW50KHRoaXMuc291cmNlUG9pbnQsZCxjLGIpLHRoaXMuc291cmNlUG9pbnQueD1NYXRoLnJvdW5kKGUueCksdGhpcy5zb3VyY2VQb2ludC55PU1hdGgucm91bmQoZS55KSk7bnVsbCE9dGhpcy50YXJnZXRQb2ludCYmKGU9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQodGhpcy50YXJnZXRQb2ludCxkLGMsYiksdGhpcy50YXJnZXRQb2ludC54PQpNYXRoLnJvdW5kKGUueCksdGhpcy50YXJnZXRQb2ludC55PU1hdGgucm91bmQoZS55KSk7aWYobnVsbCE9dGhpcy5wb2ludHMpZm9yKHZhciBmPTA7Zjx0aGlzLnBvaW50cy5sZW5ndGg7ZisrKW51bGwhPXRoaXMucG9pbnRzW2ZdJiYoZT1teFV0aWxzLmdldFJvdGF0ZWRQb2ludCh0aGlzLnBvaW50c1tmXSxkLGMsYiksdGhpcy5wb2ludHNbZl0ueD1NYXRoLnJvdW5kKGUueCksdGhpcy5wb2ludHNbZl0ueT1NYXRoLnJvdW5kKGUueSkpfTsKbXhHZW9tZXRyeS5wcm90b3R5cGUudHJhbnNsYXRlPWZ1bmN0aW9uKGEsYil7YT1wYXJzZUZsb2F0KGEpO2I9cGFyc2VGbG9hdChiKTt0aGlzLnJlbGF0aXZlfHwodGhpcy54PXBhcnNlRmxvYXQodGhpcy54KSthLHRoaXMueT1wYXJzZUZsb2F0KHRoaXMueSkrYik7bnVsbCE9dGhpcy5zb3VyY2VQb2ludCYmKHRoaXMuc291cmNlUG9pbnQueD1wYXJzZUZsb2F0KHRoaXMuc291cmNlUG9pbnQueCkrYSx0aGlzLnNvdXJjZVBvaW50Lnk9cGFyc2VGbG9hdCh0aGlzLnNvdXJjZVBvaW50LnkpK2IpO251bGwhPXRoaXMudGFyZ2V0UG9pbnQmJih0aGlzLnRhcmdldFBvaW50Lng9cGFyc2VGbG9hdCh0aGlzLnRhcmdldFBvaW50LngpK2EsdGhpcy50YXJnZXRQb2ludC55PXBhcnNlRmxvYXQodGhpcy50YXJnZXRQb2ludC55KStiKTtpZih0aGlzLlRSQU5TTEFURV9DT05UUk9MX1BPSU5UUyYmbnVsbCE9dGhpcy5wb2ludHMpZm9yKHZhciBjPTA7Yzx0aGlzLnBvaW50cy5sZW5ndGg7YysrKW51bGwhPQp0aGlzLnBvaW50c1tjXSYmKHRoaXMucG9pbnRzW2NdLng9cGFyc2VGbG9hdCh0aGlzLnBvaW50c1tjXS54KSthLHRoaXMucG9pbnRzW2NdLnk9cGFyc2VGbG9hdCh0aGlzLnBvaW50c1tjXS55KStiKX07Cm14R2VvbWV0cnkucHJvdG90eXBlLnNjYWxlPWZ1bmN0aW9uKGEsYixjKXthPXBhcnNlRmxvYXQoYSk7Yj1wYXJzZUZsb2F0KGIpO251bGwhPXRoaXMuc291cmNlUG9pbnQmJih0aGlzLnNvdXJjZVBvaW50Lng9cGFyc2VGbG9hdCh0aGlzLnNvdXJjZVBvaW50LngpKmEsdGhpcy5zb3VyY2VQb2ludC55PXBhcnNlRmxvYXQodGhpcy5zb3VyY2VQb2ludC55KSpiKTtudWxsIT10aGlzLnRhcmdldFBvaW50JiYodGhpcy50YXJnZXRQb2ludC54PXBhcnNlRmxvYXQodGhpcy50YXJnZXRQb2ludC54KSphLHRoaXMudGFyZ2V0UG9pbnQueT1wYXJzZUZsb2F0KHRoaXMudGFyZ2V0UG9pbnQueSkqYik7aWYobnVsbCE9dGhpcy5wb2ludHMpZm9yKHZhciBkPTA7ZDx0aGlzLnBvaW50cy5sZW5ndGg7ZCsrKW51bGwhPXRoaXMucG9pbnRzW2RdJiYodGhpcy5wb2ludHNbZF0ueD1wYXJzZUZsb2F0KHRoaXMucG9pbnRzW2RdLngpKmEsdGhpcy5wb2ludHNbZF0ueT1wYXJzZUZsb2F0KHRoaXMucG9pbnRzW2RdLnkpKgpiKTt0aGlzLnJlbGF0aXZlfHwodGhpcy54PXBhcnNlRmxvYXQodGhpcy54KSphLHRoaXMueT1wYXJzZUZsb2F0KHRoaXMueSkqYixjJiYoYj1hPU1hdGgubWluKGEsYikpLHRoaXMud2lkdGg9cGFyc2VGbG9hdCh0aGlzLndpZHRoKSphLHRoaXMuaGVpZ2h0PXBhcnNlRmxvYXQodGhpcy5oZWlnaHQpKmIpfTsKbXhHZW9tZXRyeS5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uKGEpe3JldHVybiBteFJlY3RhbmdsZS5wcm90b3R5cGUuZXF1YWxzLmFwcGx5KHRoaXMsYXJndW1lbnRzKSYmdGhpcy5yZWxhdGl2ZT09YS5yZWxhdGl2ZSYmKG51bGw9PXRoaXMuc291cmNlUG9pbnQmJm51bGw9PWEuc291cmNlUG9pbnR8fG51bGwhPXRoaXMuc291cmNlUG9pbnQmJnRoaXMuc291cmNlUG9pbnQuZXF1YWxzKGEuc291cmNlUG9pbnQpKSYmKG51bGw9PXRoaXMudGFyZ2V0UG9pbnQmJm51bGw9PWEudGFyZ2V0UG9pbnR8fG51bGwhPXRoaXMudGFyZ2V0UG9pbnQmJnRoaXMudGFyZ2V0UG9pbnQuZXF1YWxzKGEudGFyZ2V0UG9pbnQpKSYmKG51bGw9PXRoaXMucG9pbnRzJiZudWxsPT1hLnBvaW50c3x8bnVsbCE9dGhpcy5wb2ludHMmJm14VXRpbHMuZXF1YWxQb2ludHModGhpcy5wb2ludHMsYS5wb2ludHMpKSYmKG51bGw9PXRoaXMuYWx0ZXJuYXRlQm91bmRzJiZudWxsPT1hLmFsdGVybmF0ZUJvdW5kc3x8Cm51bGwhPXRoaXMuYWx0ZXJuYXRlQm91bmRzJiZ0aGlzLmFsdGVybmF0ZUJvdW5kcy5lcXVhbHMoYS5hbHRlcm5hdGVCb3VuZHMpKSYmKG51bGw9PXRoaXMub2Zmc2V0JiZudWxsPT1hLm9mZnNldHx8bnVsbCE9dGhpcy5vZmZzZXQmJnRoaXMub2Zmc2V0LmVxdWFscyhhLm9mZnNldCkpfTsKdmFyIG14Q2VsbFBhdGg9e1BBVEhfU0VQQVJBVE9SOiIuIixjcmVhdGU6ZnVuY3Rpb24oYSl7dmFyIGI9IiI7aWYobnVsbCE9YSlmb3IodmFyIGM9YS5nZXRQYXJlbnQoKTtudWxsIT1jOyliPWMuZ2V0SW5kZXgoYSkrbXhDZWxsUGF0aC5QQVRIX1NFUEFSQVRPUitiLGE9YyxjPWEuZ2V0UGFyZW50KCk7YT1iLmxlbmd0aDsxPGEmJihiPWIuc3Vic3RyaW5nKDAsYS0xKSk7cmV0dXJuIGJ9LGdldFBhcmVudFBhdGg6ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSl7dmFyIGI9YS5sYXN0SW5kZXhPZihteENlbGxQYXRoLlBBVEhfU0VQQVJBVE9SKTtpZigwPD1iKXJldHVybiBhLnN1YnN0cmluZygwLGIpO2lmKDA8YS5sZW5ndGgpcmV0dXJuIiJ9cmV0dXJuIG51bGx9LHJlc29sdmU6ZnVuY3Rpb24oYSxiKXt2YXIgYz1hO2lmKG51bGwhPWIpZm9yKHZhciBkPWIuc3BsaXQobXhDZWxsUGF0aC5QQVRIX1NFUEFSQVRPUiksZT0wO2U8ZC5sZW5ndGg7ZSsrKWM9Yy5nZXRDaGlsZEF0KHBhcnNlSW50KGRbZV0pKTsKcmV0dXJuIGN9LGNvbXBhcmU6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9TWF0aC5taW4oYS5sZW5ndGgsYi5sZW5ndGgpLGQ9MCxlPTA7ZTxjO2UrKylpZihhW2VdIT1iW2VdKXswPT1hW2VdLmxlbmd0aHx8MD09YltlXS5sZW5ndGg/ZD1hW2VdPT1iW2VdPzA6YVtlXT5iW2VdPzE6LTE6KGM9cGFyc2VJbnQoYVtlXSksZT1wYXJzZUludChiW2VdKSxkPWM9PWU/MDpjPmU/MTotMSk7YnJlYWt9MD09ZCYmKGM9YS5sZW5ndGgsZT1iLmxlbmd0aCxjIT1lJiYoZD1jPmU/MTotMSkpO3JldHVybiBkfX0sbXhQZXJpbWV0ZXI9e1JlY3RhbmdsZVBlcmltZXRlcjpmdW5jdGlvbihhLGIsYyxkKXtiPWEuZ2V0Q2VudGVyWCgpO3ZhciBlPWEuZ2V0Q2VudGVyWSgpLGY9TWF0aC5hdGFuMihjLnktZSxjLngtYiksZz1uZXcgbXhQb2ludCgwLDApLGs9TWF0aC5QSSxsPU1hdGguUEkvMi1mLG09TWF0aC5hdGFuMihhLmhlaWdodCxhLndpZHRoKTtmPC1rK218fGY+ay1tPyhnLng9YS54LGcueT1lLWEud2lkdGgqCk1hdGgudGFuKGYpLzIpOmY8LW0/KGcueT1hLnksZy54PWItYS5oZWlnaHQqTWF0aC50YW4obCkvMik6ZjxtPyhnLng9YS54K2Eud2lkdGgsZy55PWUrYS53aWR0aCpNYXRoLnRhbihmKS8yKTooZy55PWEueSthLmhlaWdodCxnLng9YithLmhlaWdodCpNYXRoLnRhbihsKS8yKTtkJiYoYy54Pj1hLngmJmMueDw9YS54K2Eud2lkdGg/Zy54PWMueDpjLnk+PWEueSYmYy55PD1hLnkrYS5oZWlnaHQmJihnLnk9Yy55KSxjLng8YS54P2cueD1hLng6Yy54PmEueCthLndpZHRoJiYoZy54PWEueCthLndpZHRoKSxjLnk8YS55P2cueT1hLnk6Yy55PmEueSthLmhlaWdodCYmKGcueT1hLnkrYS5oZWlnaHQpKTtyZXR1cm4gZ30sRWxsaXBzZVBlcmltZXRlcjpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1hLngsZj1hLnksZz1hLndpZHRoLzIsaz1hLmhlaWdodC8yLGw9ZStnLG09ZitrO2I9Yy54O2M9Yy55O3ZhciBuPXBhcnNlSW50KGItbCkscD1wYXJzZUludChjLW0pO2lmKDA9PW4mJjAhPXApcmV0dXJuIG5ldyBteFBvaW50KGwsCm0raypwL01hdGguYWJzKHApKTtpZigwPT1uJiYwPT1wKXJldHVybiBuZXcgbXhQb2ludChiLGMpO2lmKGQpe2lmKGM+PWYmJmM8PWYrYS5oZWlnaHQpcmV0dXJuIGE9Yy1tLGE9TWF0aC5zcXJ0KGcqZyooMS1hKmEvKGsqaykpKXx8MCxiPD1lJiYoYT0tYSksbmV3IG14UG9pbnQobCthLGMpO2lmKGI+PWUmJmI8PWUrYS53aWR0aClyZXR1cm4gYT1iLWwsYT1NYXRoLnNxcnQoayprKigxLWEqYS8oZypnKSkpfHwwLGM8PWYmJihhPS1hKSxuZXcgbXhQb2ludChiLG0rYSl9ZT1wL247bS09ZSpsO2Y9ZypnKmUqZStrKms7YT0tMipsKmY7az1NYXRoLnNxcnQoYSphLTQqZiooZypnKmUqZSpsKmwrayprKmwqbC1nKmcqayprKSk7Zz0oLWEraykvKDIqZik7bD0oLWEtaykvKDIqZik7az1lKmcrbTttPWUqbCttO01hdGguc3FydChNYXRoLnBvdyhnLWIsMikrTWF0aC5wb3coay1jLDIpKTxNYXRoLnNxcnQoTWF0aC5wb3cobC1iLDIpK01hdGgucG93KG0tYywyKSk/KGI9ZyxjPWspOihiPWwsYz0KbSk7cmV0dXJuIG5ldyBteFBvaW50KGIsYyl9LFJob21idXNQZXJpbWV0ZXI6ZnVuY3Rpb24oYSxiLGMsZCl7Yj1hLng7dmFyIGU9YS55LGY9YS53aWR0aDthPWEuaGVpZ2h0O3ZhciBnPWIrZi8yLGs9ZSthLzIsbD1jLng7Yz1jLnk7aWYoZz09bClyZXR1cm4gaz5jP25ldyBteFBvaW50KGcsZSk6bmV3IG14UG9pbnQoZyxlK2EpO2lmKGs9PWMpcmV0dXJuIGc+bD9uZXcgbXhQb2ludChiLGspOm5ldyBteFBvaW50KGIrZixrKTt2YXIgbT1nLG49aztkJiYobD49YiYmbDw9YitmP209bDpjPj1lJiZjPD1lK2EmJihuPWMpKTtyZXR1cm4gbDxnP2M8az9teFV0aWxzLmludGVyc2VjdGlvbihsLGMsbSxuLGcsZSxiLGspOm14VXRpbHMuaW50ZXJzZWN0aW9uKGwsYyxtLG4sZyxlK2EsYixrKTpjPGs/bXhVdGlscy5pbnRlcnNlY3Rpb24obCxjLG0sbixnLGUsYitmLGspOm14VXRpbHMuaW50ZXJzZWN0aW9uKGwsYyxtLG4sZyxlK2EsYitmLGspfSxUcmlhbmdsZVBlcmltZXRlcjpmdW5jdGlvbihhLApiLGMsZCl7Yj1udWxsIT1iP2Iuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRElSRUNUSU9OXTpudWxsO3ZhciBlPWI9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSHx8Yj09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRILGY9YS54LGc9YS55LGs9YS53aWR0aCxsPWEuaGVpZ2h0O2E9ZitrLzI7dmFyIG09ZytsLzIsbj1uZXcgbXhQb2ludChmLGcpLHA9bmV3IG14UG9pbnQoZitrLG0pLHE9bmV3IG14UG9pbnQoZixnK2wpO2I9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSD8obj1xLHA9bmV3IG14UG9pbnQoYSxnKSxxPW5ldyBteFBvaW50KGYrayxnK2wpKTpiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEg/KHA9bmV3IG14UG9pbnQoYSxnK2wpLHE9bmV3IG14UG9pbnQoZitrLGcpKTpiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVCYmKG49bmV3IG14UG9pbnQoZitrLGcpLHA9bmV3IG14UG9pbnQoZixtKSxxPW5ldyBteFBvaW50KGYrayxnK2wpKTt2YXIgcj1jLngtCmEsdD1jLnktbSxyPWU/TWF0aC5hdGFuMihyLHQpOk1hdGguYXRhbjIodCxyKSx0PWU/TWF0aC5hdGFuMihrLGwpOk1hdGguYXRhbjIobCxrKTsoYj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIfHxiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVD9yPi10JiZyPHQ6cjwtTWF0aC5QSSt0fHxyPk1hdGguUEktdCk/Yz1kJiYoZSYmYy54Pj1uLngmJmMueDw9cS54fHwhZSYmYy55Pj1uLnkmJmMueTw9cS55KT9lP25ldyBteFBvaW50KGMueCxuLnkpOm5ldyBteFBvaW50KG4ueCxjLnkpOmI9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSD9uZXcgbXhQb2ludChmK2svMitsKk1hdGgudGFuKHIpLzIsZytsKTpiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEg/bmV3IG14UG9pbnQoZitrLzItbCpNYXRoLnRhbihyKS8yLGcpOmI9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUP25ldyBteFBvaW50KGYrayxnK2wvMitrKk1hdGgudGFuKHIpLzIpOm5ldyBteFBvaW50KGYsZysKbC8yLWsqTWF0aC50YW4ocikvMik6KGQmJihkPW5ldyBteFBvaW50KGEsbSksYy55Pj1nJiZjLnk8PWcrbD8oZC54PWU/YTpiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVD9mK2s6ZixkLnk9Yy55KTpjLng+PWYmJmMueDw9ZitrJiYoZC54PWMueCxkLnk9ZT9iPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEg/ZytsOmc6bSksYT1kLngsbT1kLnkpLGM9ZSYmYy54PD1mK2svMnx8IWUmJmMueTw9ZytsLzI/bXhVdGlscy5pbnRlcnNlY3Rpb24oYy54LGMueSxhLG0sbi54LG4ueSxwLngscC55KTpteFV0aWxzLmludGVyc2VjdGlvbihjLngsYy55LGEsbSxwLngscC55LHEueCxxLnkpKTtudWxsPT1jJiYoYz1uZXcgbXhQb2ludChhLG0pKTtyZXR1cm4gY30sSGV4YWdvblBlcmltZXRlcjpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1hLngsZj1hLnksZz1hLndpZHRoLGs9YS5oZWlnaHQsbD1hLmdldENlbnRlclgoKTthPWEuZ2V0Q2VudGVyWSgpO3ZhciBtPWMueCxuPWMueSxwPS1NYXRoLmF0YW4yKG4tCmEsbS1sKSxxPU1hdGguUEkscj1NYXRoLlBJLzI7bmV3IG14UG9pbnQobCxhKTtiPW51bGwhPWI/bXhVdGlscy5nZXRWYWx1ZShiLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0RJUkVDVElPTixteENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVCk6bXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1Q7dmFyIHQ9Yj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIfHxiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEg7Yj1uZXcgbXhQb2ludDt2YXIgdT1uZXcgbXhQb2ludDtpZihtPGUmJm48Znx8bTxlJiZuPmYra3x8bT5lK2cmJm48Znx8bT5lK2cmJm4+ZitrKWQ9ITE7aWYoZCl7aWYodCl7aWYobT09bCl7aWYobjw9ZilyZXR1cm4gbmV3IG14UG9pbnQobCxmKTtpZihuPj1mK2spcmV0dXJuIG5ldyBteFBvaW50KGwsZitrKX1lbHNlIGlmKG08ZSl7aWYobj09ZitrLzQpcmV0dXJuIG5ldyBteFBvaW50KGUsZitrLzQpO2lmKG49PWYrMyprLzQpcmV0dXJuIG5ldyBteFBvaW50KGUsZiszKgprLzQpfWVsc2UgaWYobT5lK2cpe2lmKG49PWYray80KXJldHVybiBuZXcgbXhQb2ludChlK2csZitrLzQpO2lmKG49PWYrMyprLzQpcmV0dXJuIG5ldyBteFBvaW50KGUrZyxmKzMqay80KX1lbHNlIGlmKG09PWUpe2lmKG48YSlyZXR1cm4gbmV3IG14UG9pbnQoZSxmK2svNCk7aWYobj5hKXJldHVybiBuZXcgbXhQb2ludChlLGYrMyprLzQpfWVsc2UgaWYobT09ZStnKXtpZihuPGEpcmV0dXJuIG5ldyBteFBvaW50KGUrZyxmK2svNCk7aWYobj5hKXJldHVybiBuZXcgbXhQb2ludChlK2csZiszKmsvNCl9aWYobj09ZilyZXR1cm4gbmV3IG14UG9pbnQobCxmKTtpZihuPT1mK2spcmV0dXJuIG5ldyBteFBvaW50KGwsZitrKTttPGw/bj5mK2svNCYmbjxmKzMqay80PyhiPW5ldyBteFBvaW50KGUsZiksdT1uZXcgbXhQb2ludChlLGYraykpOm48ZitrLzQ/KGI9bmV3IG14UG9pbnQoZS1NYXRoLmZsb29yKC41KmcpLGYrTWF0aC5mbG9vciguNSprKSksdT1uZXcgbXhQb2ludChlK2csZi0KTWF0aC5mbG9vciguMjUqaykpKTpuPmYrMyprLzQmJihiPW5ldyBteFBvaW50KGUtTWF0aC5mbG9vciguNSpnKSxmK01hdGguZmxvb3IoLjUqaykpLHU9bmV3IG14UG9pbnQoZStnLGYrTWF0aC5mbG9vcigxLjI1KmspKSk6bT5sJiYobj5mK2svNCYmbjxmKzMqay80PyhiPW5ldyBteFBvaW50KGUrZyxmKSx1PW5ldyBteFBvaW50KGUrZyxmK2spKTpuPGYray80PyhiPW5ldyBteFBvaW50KGUsZi1NYXRoLmZsb29yKC4yNSprKSksdT1uZXcgbXhQb2ludChlK01hdGguZmxvb3IoMS41KmcpLGYrTWF0aC5mbG9vciguNSprKSkpOm4+ZiszKmsvNCYmKGI9bmV3IG14UG9pbnQoZStNYXRoLmZsb29yKDEuNSpnKSxmK01hdGguZmxvb3IoLjUqaykpLHU9bmV3IG14UG9pbnQoZSxmK01hdGguZmxvb3IoMS4yNSprKSkpKX1lbHNle2lmKG49PWEpe2lmKG08PWUpcmV0dXJuIG5ldyBteFBvaW50KGUsZitrLzIpO2lmKG0+PWUrZylyZXR1cm4gbmV3IG14UG9pbnQoZStnLGYray8yKX1lbHNlIGlmKG48CmYpe2lmKG09PWUrZy80KXJldHVybiBuZXcgbXhQb2ludChlK2cvNCxmKTtpZihtPT1lKzMqZy80KXJldHVybiBuZXcgbXhQb2ludChlKzMqZy80LGYpfWVsc2UgaWYobj5mK2spe2lmKG09PWUrZy80KXJldHVybiBuZXcgbXhQb2ludChlK2cvNCxmK2spO2lmKG09PWUrMypnLzQpcmV0dXJuIG5ldyBteFBvaW50KGUrMypnLzQsZitrKX1lbHNlIGlmKG49PWYpe2lmKG08bClyZXR1cm4gbmV3IG14UG9pbnQoZStnLzQsZik7aWYobT5sKXJldHVybiBuZXcgbXhQb2ludChlKzMqZy80LGYpfWVsc2UgaWYobj09ZitrKXtpZihtPGwpcmV0dXJuIG5ldyBteFBvaW50KGUrZy80LGYrayk7aWYobj5hKXJldHVybiBuZXcgbXhQb2ludChlKzMqZy80LGYrayl9aWYobT09ZSlyZXR1cm4gbmV3IG14UG9pbnQoZSxhKTtpZihtPT1lK2cpcmV0dXJuIG5ldyBteFBvaW50KGUrZyxhKTtuPGE/bT5lK2cvNCYmbTxlKzMqZy80PyhiPW5ldyBteFBvaW50KGUsZiksdT1uZXcgbXhQb2ludChlK2csZikpOgptPGUrZy80PyhiPW5ldyBteFBvaW50KGUtTWF0aC5mbG9vciguMjUqZyksZitrKSx1PW5ldyBteFBvaW50KGUrTWF0aC5mbG9vciguNSpnKSxmLU1hdGguZmxvb3IoLjUqaykpKTptPmUrMypnLzQmJihiPW5ldyBteFBvaW50KGUrTWF0aC5mbG9vciguNSpnKSxmLU1hdGguZmxvb3IoLjUqaykpLHU9bmV3IG14UG9pbnQoZStNYXRoLmZsb29yKDEuMjUqZyksZitrKSk6bj5hJiYobT5lK2cvNCYmbTxlKzMqZy80PyhiPW5ldyBteFBvaW50KGUsZitrKSx1PW5ldyBteFBvaW50KGUrZyxmK2spKTptPGUrZy80PyhiPW5ldyBteFBvaW50KGUtTWF0aC5mbG9vciguMjUqZyksZiksdT1uZXcgbXhQb2ludChlK01hdGguZmxvb3IoLjUqZyksZitNYXRoLmZsb29yKDEuNSprKSkpOm0+ZSszKmcvNCYmKGI9bmV3IG14UG9pbnQoZStNYXRoLmZsb29yKC41KmcpLGYrTWF0aC5mbG9vcigxLjUqaykpLHU9bmV3IG14UG9pbnQoZStNYXRoLmZsb29yKDEuMjUqZyksZikpKX1kPWw7cD1hO20+PWUmJm08PQplK2c/KGQ9bSxwPW48YT9mK2s6Zik6bj49ZiYmbjw9ZitrJiYocD1uLGQ9bTxsP2UrZzplKTtjPW14VXRpbHMuaW50ZXJzZWN0aW9uKGQscCxjLngsYy55LGIueCxiLnksdS54LHUueSl9ZWxzZXtpZih0KXttPU1hdGguYXRhbjIoay80LGcvMik7aWYocD09bSlyZXR1cm4gbmV3IG14UG9pbnQoZStnLGYrTWF0aC5mbG9vciguMjUqaykpO2lmKHA9PXIpcmV0dXJuIG5ldyBteFBvaW50KGUrTWF0aC5mbG9vciguNSpnKSxmKTtpZihwPT1xLW0pcmV0dXJuIG5ldyBteFBvaW50KGUsZitNYXRoLmZsb29yKC4yNSprKSk7aWYocD09LW0pcmV0dXJuIG5ldyBteFBvaW50KGUrZyxmK01hdGguZmxvb3IoLjc1KmspKTtpZihwPT0tcilyZXR1cm4gbmV3IG14UG9pbnQoZStNYXRoLmZsb29yKC41KmcpLGYrayk7aWYocD09LXErbSlyZXR1cm4gbmV3IG14UG9pbnQoZSxmK01hdGguZmxvb3IoLjc1KmspKTtwPG0mJnA+LW0/KGI9bmV3IG14UG9pbnQoZStnLGYpLHU9bmV3IG14UG9pbnQoZStnLGYrCmspKTpwPm0mJnA8cj8oYj1uZXcgbXhQb2ludChlLGYtTWF0aC5mbG9vciguMjUqaykpLHU9bmV3IG14UG9pbnQoZStNYXRoLmZsb29yKDEuNSpnKSxmK01hdGguZmxvb3IoLjUqaykpKTpwPnImJnA8cS1tPyhiPW5ldyBteFBvaW50KGUtTWF0aC5mbG9vciguNSpnKSxmK01hdGguZmxvb3IoLjUqaykpLHU9bmV3IG14UG9pbnQoZStnLGYtTWF0aC5mbG9vciguMjUqaykpKTpwPnEtbSYmcDw9cXx8cDwtcSttJiZwPj0tcT8oYj1uZXcgbXhQb2ludChlLGYpLHU9bmV3IG14UG9pbnQoZSxmK2spKTpwPC1tJiZwPi1yPyhiPW5ldyBteFBvaW50KGUrTWF0aC5mbG9vcigxLjUqZyksZitNYXRoLmZsb29yKC41KmspKSx1PW5ldyBteFBvaW50KGUsZitNYXRoLmZsb29yKDEuMjUqaykpKTpwPC1yJiZwPi1xK20mJihiPW5ldyBteFBvaW50KGUtTWF0aC5mbG9vciguNSpnKSxmK01hdGguZmxvb3IoLjUqaykpLHU9bmV3IG14UG9pbnQoZStnLGYrTWF0aC5mbG9vcigxLjI1KmspKSl9ZWxzZXttPQpNYXRoLmF0YW4yKGsvMixnLzQpO2lmKHA9PW0pcmV0dXJuIG5ldyBteFBvaW50KGUrTWF0aC5mbG9vciguNzUqZyksZik7aWYocD09cS1tKXJldHVybiBuZXcgbXhQb2ludChlK01hdGguZmxvb3IoLjI1KmcpLGYpO2lmKHA9PXF8fHA9PS1xKXJldHVybiBuZXcgbXhQb2ludChlLGYrTWF0aC5mbG9vciguNSprKSk7aWYoMD09cClyZXR1cm4gbmV3IG14UG9pbnQoZStnLGYrTWF0aC5mbG9vciguNSprKSk7aWYocD09LW0pcmV0dXJuIG5ldyBteFBvaW50KGUrTWF0aC5mbG9vciguNzUqZyksZitrKTtpZihwPT0tcSttKXJldHVybiBuZXcgbXhQb2ludChlK01hdGguZmxvb3IoLjI1KmcpLGYrayk7MDxwJiZwPG0/KGI9bmV3IG14UG9pbnQoZStNYXRoLmZsb29yKC41KmcpLGYtTWF0aC5mbG9vciguNSprKSksdT1uZXcgbXhQb2ludChlK01hdGguZmxvb3IoMS4yNSpnKSxmK2spKTpwPm0mJnA8cS1tPyhiPW5ldyBteFBvaW50KGUsZiksdT1uZXcgbXhQb2ludChlK2csZikpOnA+cS1tJiYKcDxxPyhiPW5ldyBteFBvaW50KGUtTWF0aC5mbG9vciguMjUqZyksZitrKSx1PW5ldyBteFBvaW50KGUrTWF0aC5mbG9vciguNSpnKSxmLU1hdGguZmxvb3IoLjUqaykpKTowPnAmJnA+LW0/KGI9bmV3IG14UG9pbnQoZStNYXRoLmZsb29yKC41KmcpLGYrTWF0aC5mbG9vcigxLjUqaykpLHU9bmV3IG14UG9pbnQoZStNYXRoLmZsb29yKDEuMjUqZyksZikpOnA8LW0mJnA+LXErbT8oYj1uZXcgbXhQb2ludChlLGYrayksdT1uZXcgbXhQb2ludChlK2csZitrKSk6cDwtcSttJiZwPi1xJiYoYj1uZXcgbXhQb2ludChlLU1hdGguZmxvb3IoLjI1KmcpLGYpLHU9bmV3IG14UG9pbnQoZStNYXRoLmZsb29yKC41KmcpLGYrTWF0aC5mbG9vcigxLjUqaykpKX1jPW14VXRpbHMuaW50ZXJzZWN0aW9uKGwsYSxjLngsYy55LGIueCxiLnksdS54LHUueSl9cmV0dXJuIG51bGw9PWM/bmV3IG14UG9pbnQobCxhKTpjfX07CmZ1bmN0aW9uIG14UHJpbnRQcmV2aWV3KGEsYixjLGQsZSxmLGcsayxsKXt0aGlzLmdyYXBoPWE7dGhpcy5zY2FsZT1udWxsIT1iP2I6MS9hLnBhZ2VTY2FsZTt0aGlzLmJvcmRlcj1udWxsIT1kP2Q6MDt0aGlzLnBhZ2VGb3JtYXQ9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShudWxsIT1jP2M6YS5wYWdlRm9ybWF0KTt0aGlzLnRpdGxlPW51bGwhPWs/azoiUHJpbnRlci1mcmllbmRseSB2ZXJzaW9uIjt0aGlzLngwPW51bGwhPWU/ZTowO3RoaXMueTA9bnVsbCE9Zj9mOjA7dGhpcy5ib3JkZXJDb2xvcj1nO3RoaXMucGFnZVNlbGVjdG9yPW51bGwhPWw/bDohMH1teFByaW50UHJldmlldy5wcm90b3R5cGUuZ3JhcGg9bnVsbDtteFByaW50UHJldmlldy5wcm90b3R5cGUucGFnZUZvcm1hdD1udWxsO214UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5zY2FsZT1udWxsO214UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5ib3JkZXI9MDsKbXhQcmludFByZXZpZXcucHJvdG90eXBlLm1hcmdpblRvcD0wO214UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5tYXJnaW5Cb3R0b209MDtteFByaW50UHJldmlldy5wcm90b3R5cGUueDA9MDtteFByaW50UHJldmlldy5wcm90b3R5cGUueTA9MDtteFByaW50UHJldmlldy5wcm90b3R5cGUuYXV0b09yaWdpbj0hMDtteFByaW50UHJldmlldy5wcm90b3R5cGUucHJpbnRPdmVybGF5cz0hMTtteFByaW50UHJldmlldy5wcm90b3R5cGUucHJpbnRDb250cm9scz0hMTtteFByaW50UHJldmlldy5wcm90b3R5cGUucHJpbnRCYWNrZ3JvdW5kSW1hZ2U9ITE7bXhQcmludFByZXZpZXcucHJvdG90eXBlLmJhY2tncm91bmRDb2xvcj0iI2ZmZmZmZiI7bXhQcmludFByZXZpZXcucHJvdG90eXBlLmJvcmRlckNvbG9yPW51bGw7bXhQcmludFByZXZpZXcucHJvdG90eXBlLnRpdGxlPW51bGw7bXhQcmludFByZXZpZXcucHJvdG90eXBlLnBhZ2VTZWxlY3Rvcj1udWxsOwpteFByaW50UHJldmlldy5wcm90b3R5cGUud25kPW51bGw7bXhQcmludFByZXZpZXcucHJvdG90eXBlLnRhcmdldFdpbmRvdz1udWxsO214UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5wYWdlQ291bnQ9MDtteFByaW50UHJldmlldy5wcm90b3R5cGUuY2xpcHBpbmc9ITA7bXhQcmludFByZXZpZXcucHJvdG90eXBlLmdldFdpbmRvdz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnduZH07Cm14UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5nZXREb2N0eXBlPWZ1bmN0aW9uKCl7dmFyIGE9IiI7NT09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlP2E9JzxtZXRhIGh0dHAtZXF1aXY9IlgtVUEtQ29tcGF0aWJsZSIgY29udGVudD0iSUU9NSI+Jzo4PT1kb2N1bWVudC5kb2N1bWVudE1vZGU/YT0nPG1ldGEgaHR0cC1lcXVpdj0iWC1VQS1Db21wYXRpYmxlIiBjb250ZW50PSJJRT04Ij4nOjg8ZG9jdW1lbnQuZG9jdW1lbnRNb2RlJiYoYT0nXHgzYyEtLVtpZiBJRV0+PG1ldGEgaHR0cC1lcXVpdj0iWC1VQS1Db21wYXRpYmxlIiBjb250ZW50PSJJRT1lZGdlIj48IVtlbmRpZl0tLVx4M2UnKTtyZXR1cm4gYX07bXhQcmludFByZXZpZXcucHJvdG90eXBlLmFwcGVuZEdyYXBoPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt0aGlzLmdyYXBoPWE7dGhpcy5zY2FsZT1udWxsIT1iP2I6MS9hLnBhZ2VTY2FsZTt0aGlzLngwPWM7dGhpcy55MD1kO3RoaXMub3BlbihudWxsLG51bGwsZSxmKX07Cm14UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMuZ3JhcGguY2VsbFJlbmRlcmVyLmluaXRpYWxpemVPdmVybGF5LGY9bnVsbDt0cnl7dGhpcy5wcmludE92ZXJsYXlzJiYodGhpcy5ncmFwaC5jZWxsUmVuZGVyZXIuaW5pdGlhbGl6ZU92ZXJsYXk9ZnVuY3Rpb24oYSxiKXtiLmluaXQoYS52aWV3LmdldERyYXdQYW5lKCkpfSk7dGhpcy5wcmludENvbnRyb2xzJiYodGhpcy5ncmFwaC5jZWxsUmVuZGVyZXIuaW5pdENvbnRyb2w9ZnVuY3Rpb24oYSxiLGMsZCl7Yi5kaWFsZWN0PWEudmlldy5ncmFwaC5kaWFsZWN0O2IuaW5pdChhLnZpZXcuZ2V0RHJhd1BhbmUoKSl9KTt0aGlzLnduZD1udWxsIT1iP2I6dGhpcy53bmQ7dmFyIGc9ITE7bnVsbD09dGhpcy53bmQmJihnPSEwLHRoaXMud25kPXdpbmRvdy5vcGVuKCkpO3ZhciBrPXRoaXMud25kLmRvY3VtZW50O2lmKGcpe3ZhciBsPXRoaXMuZ2V0RG9jdHlwZSgpO251bGwhPWwmJjA8bC5sZW5ndGgmJgprLndyaXRlbG4obCk7bXhDbGllbnQuSVNfVk1MP2sud3JpdGVsbignPGh0bWwgeG1sbnM6dj0idXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwiIHhtbG5zOm89InVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206b2ZmaWNlOm9mZmljZSI+Jyk6KCJDU1MxQ29tcGF0Ij09PWRvY3VtZW50LmNvbXBhdE1vZGUmJmsud3JpdGVsbigiPCFET0NUWVBFIGh0bWw+Iiksay53cml0ZWxuKCI8aHRtbD4iKSk7ay53cml0ZWxuKCI8aGVhZD4iKTt0aGlzLndyaXRlSGVhZChrLGEpO2sud3JpdGVsbigiPC9oZWFkPiIpO2sud3JpdGVsbignPGJvZHkgY2xhc3M9Im14UGFnZSI+Jyl9dmFyIG09dGhpcy5ncmFwaC5nZXRHcmFwaEJvdW5kcygpLmNsb25lKCksbj10aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRTY2FsZSgpLHA9bi90aGlzLnNjYWxlLHE9dGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0VHJhbnNsYXRlKCk7dGhpcy5hdXRvT3JpZ2lufHwodGhpcy54MC09cS54KnRoaXMuc2NhbGUsdGhpcy55MC09CnEueSp0aGlzLnNjYWxlLG0ud2lkdGgrPW0ueCxtLmhlaWdodCs9bS55LG0ueD0wLHRoaXMuYm9yZGVyPW0ueT0wKTt2YXIgcj10aGlzLnBhZ2VGb3JtYXQud2lkdGgtMip0aGlzLmJvcmRlcix0PXRoaXMucGFnZUZvcm1hdC5oZWlnaHQtMip0aGlzLmJvcmRlcjt0aGlzLnBhZ2VGb3JtYXQuaGVpZ2h0Kz10aGlzLm1hcmdpblRvcCt0aGlzLm1hcmdpbkJvdHRvbTttLndpZHRoLz1wO20uaGVpZ2h0Lz1wO3ZhciB1PU1hdGgubWF4KDEsTWF0aC5jZWlsKChtLndpZHRoK3RoaXMueDApL3IpKSx4PU1hdGgubWF4KDEsTWF0aC5jZWlsKChtLmhlaWdodCt0aGlzLnkwKS90KSk7dGhpcy5wYWdlQ291bnQ9dSp4O3ZhciB5PW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7aWYodGhpcy5wYWdlU2VsZWN0b3ImJigxPHh8fDE8dSkpe3ZhciBhPXRoaXMuY3JlYXRlUGFnZVNlbGVjdG9yKHgsdSk7ay5ib2R5LmFwcGVuZENoaWxkKGEpO2lmKG14Q2xpZW50LklTX0lFJiZudWxsPT1rLmRvY3VtZW50TW9kZXx8CjU9PWsuZG9jdW1lbnRNb2RlfHw4PT1rLmRvY3VtZW50TW9kZXx8Nz09ay5kb2N1bWVudE1vZGUpe2Euc3R5bGUucG9zaXRpb249ImFic29sdXRlIjt2YXIgYj1mdW5jdGlvbigpe2Euc3R5bGUudG9wPShrLmJvZHkuc2Nyb2xsVG9wfHxrLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApKzEwKyJweCJ9O214RXZlbnQuYWRkTGlzdGVuZXIodGhpcy53bmQsInNjcm9sbCIsZnVuY3Rpb24oYSl7YigpfSk7bXhFdmVudC5hZGRMaXN0ZW5lcih0aGlzLnduZCwicmVzaXplIixmdW5jdGlvbihhKXtiKCl9KX19fSksQj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIpe251bGwhPXRoaXMuYm9yZGVyQ29sb3ImJihhLnN0eWxlLmJvcmRlckNvbG9yPXRoaXMuYm9yZGVyQ29sb3IsYS5zdHlsZS5ib3JkZXJTdHlsZT0ic29saWQiLGEuc3R5bGUuYm9yZGVyV2lkdGg9IjFweCIpO2Euc3R5bGUuYmFja2dyb3VuZD10aGlzLmJhY2tncm91bmRDb2xvcjtpZihjfHxiKWEuc3R5bGUucGFnZUJyZWFrQWZ0ZXI9CiJhbHdheXMiO2lmKGcmJihteENsaWVudC5JU19JRXx8MTE8PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8bXhDbGllbnQuSVNfRURHRSkpay53cml0ZWxuKGEub3V0ZXJIVE1MKSxhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSk7ZWxzZSBpZihteENsaWVudC5JU19JRXx8MTE8PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8bXhDbGllbnQuSVNfRURHRSl7dmFyIGQ9ay5jcmVhdGVFbGVtZW50KCJkaXYiKTtkLmlubmVySFRNTD1hLm91dGVySFRNTDtkPWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpWzBdO2suYm9keS5hcHBlbmRDaGlsZChkKTthLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSl9ZWxzZSBhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSksay5ib2R5LmFwcGVuZENoaWxkKGEpOyhjfHxiKSYmdGhpcy5hZGRQYWdlQnJlYWsoayl9KSxBPXRoaXMuZ2V0Q292ZXJQYWdlcyh0aGlzLnBhZ2VGb3JtYXQud2lkdGgsdGhpcy5wYWdlRm9ybWF0LmhlaWdodCk7aWYobnVsbCE9QSlmb3IodmFyIHo9CjA7ejxBLmxlbmd0aDt6KyspQihBW3pdLCEwKTtmb3IodmFyIEM9dGhpcy5nZXRBcHBlbmRpY2VzKHRoaXMucGFnZUZvcm1hdC53aWR0aCx0aGlzLnBhZ2VGb3JtYXQuaGVpZ2h0KSx6PTA7ejx4O3orKyl7dmFyIHY9eip0L3RoaXMuc2NhbGUtdGhpcy55MC90aGlzLnNjYWxlKyhtLnktcS55Km4pL247Zm9yKGE9MDthPHU7YSsrKXtpZihudWxsPT10aGlzLnduZClyZXR1cm4gbnVsbDt2YXIgRD1hKnIvdGhpcy5zY2FsZS10aGlzLngwL3RoaXMuc2NhbGUrKG0ueC1xLngqbikvbixHPXoqdSthKzEsSj1uZXcgbXhSZWN0YW5nbGUoRCx2LHIsdCksZj10aGlzLnJlbmRlclBhZ2UodGhpcy5wYWdlRm9ybWF0LndpZHRoLHRoaXMucGFnZUZvcm1hdC5oZWlnaHQsMCwwLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuYWRkR3JhcGhGcmFnbWVudCgtRCwtdix0aGlzLnNjYWxlLEcsYSxKKTt0aGlzLnByaW50QmFja2dyb3VuZEltYWdlJiZ0aGlzLmluc2VydEJhY2tncm91bmRJbWFnZShhLAotRCwtdil9KSxHKTtmLnNldEF0dHJpYnV0ZSgiaWQiLCJteFBhZ2UtIitHKTtCKGYsbnVsbCE9Q3x8ejx4LTF8fGE8dS0xKX19aWYobnVsbCE9Qylmb3Ioej0wO3o8Qy5sZW5ndGg7eisrKUIoQ1t6XSx6PEMubGVuZ3RoLTEpO2cmJiFkJiYodGhpcy5jbG9zZURvY3VtZW50KCkseSgpKTt0aGlzLnduZC5mb2N1cygpfWNhdGNoKEUpe251bGwhPWYmJm51bGwhPWYucGFyZW50Tm9kZSYmZi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGYpfWZpbmFsbHl7dGhpcy5ncmFwaC5jZWxsUmVuZGVyZXIuaW5pdGlhbGl6ZU92ZXJsYXk9ZX1yZXR1cm4gdGhpcy53bmR9O214UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5hZGRQYWdlQnJlYWs9ZnVuY3Rpb24oYSl7dmFyIGI9YS5jcmVhdGVFbGVtZW50KCJociIpO2IuY2xhc3NOYW1lPSJteFBhZ2VCcmVhayI7YS5ib2R5LmFwcGVuZENoaWxkKGIpfTsKbXhQcmludFByZXZpZXcucHJvdG90eXBlLmNsb3NlRG9jdW1lbnQ9ZnVuY3Rpb24oKXt0cnl7aWYobnVsbCE9dGhpcy53bmQmJm51bGwhPXRoaXMud25kLmRvY3VtZW50KXt2YXIgYT10aGlzLnduZC5kb2N1bWVudDt0aGlzLndyaXRlUG9zdGZpeChhKTthLndyaXRlbG4oIjwvYm9keT4iKTthLndyaXRlbG4oIjwvaHRtbD4iKTthLmNsb3NlKCk7bXhFdmVudC5yZWxlYXNlKGEuYm9keSl9fWNhdGNoKGIpe319OwpteFByaW50UHJldmlldy5wcm90b3R5cGUud3JpdGVIZWFkPWZ1bmN0aW9uKGEsYil7bnVsbCE9dGhpcy50aXRsZSYmYS53cml0ZWxuKCI8dGl0bGU+Iit0aGlzLnRpdGxlKyI8L3RpdGxlPiIpO214Q2xpZW50LklTX1ZNTCYmYS53cml0ZWxuKCc8c3R5bGUgdHlwZT0idGV4dC9jc3MiPnZcXDoqe2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpfW9cXDoqe2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpfTwvc3R5bGU+Jyk7bXhDbGllbnQubGluaygic3R5bGVzaGVldCIsbXhDbGllbnQuYmFzZVBhdGgrIi9jc3MvY29tbW9uLmNzcyIsYSk7YS53cml0ZWxuKCc8c3R5bGUgdHlwZT0idGV4dC9jc3MiPicpO2Eud3JpdGVsbigiQG1lZGlhIHByaW50IHsiKTthLndyaXRlbG4oIiAgKiB7IC13ZWJraXQtcHJpbnQtY29sb3ItYWRqdXN0OiBleGFjdDsgfSIpO2Eud3JpdGVsbigiICB0YWJsZS5teFBhZ2VTZWxlY3RvciB7IGRpc3BsYXk6IG5vbmU7IH0iKTthLndyaXRlbG4oIiAgaHIubXhQYWdlQnJlYWsgeyBkaXNwbGF5OiBub25lOyB9Iik7CmEud3JpdGVsbigifSIpO2Eud3JpdGVsbigiQG1lZGlhIHNjcmVlbiB7Iik7YS53cml0ZWxuKCIgIHRhYmxlLm14UGFnZVNlbGVjdG9yIHsgcG9zaXRpb246IGZpeGVkOyByaWdodDogMTBweDsgdG9wOiAxMHB4O2ZvbnQtZmFtaWx5OiBBcmlhbDsgZm9udC1zaXplOjEwcHQ7IGJvcmRlcjogc29saWQgMXB4IGRhcmtncmF5O2JhY2tncm91bmQ6IHdoaXRlOyBib3JkZXItY29sbGFwc2U6Y29sbGFwc2U7IH0iKTthLndyaXRlbG4oIiAgdGFibGUubXhQYWdlU2VsZWN0b3IgdGQgeyBib3JkZXI6IHNvbGlkIDFweCBncmF5OyBwYWRkaW5nOjRweDsgfSIpO2Eud3JpdGVsbigiICBib2R5Lm14UGFnZSB7IGJhY2tncm91bmQ6IGdyYXk7IH0iKTthLndyaXRlbG4oIn0iKTtudWxsIT1iJiZhLndyaXRlbG4oYik7YS53cml0ZWxuKCI8L3N0eWxlPiIpfTtteFByaW50UHJldmlldy5wcm90b3R5cGUud3JpdGVQb3N0Zml4PWZ1bmN0aW9uKGEpe307Cm14UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5jcmVhdGVQYWdlU2VsZWN0b3I9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLnduZC5kb2N1bWVudCxkPWMuY3JlYXRlRWxlbWVudCgidGFibGUiKTtkLmNsYXNzTmFtZT0ibXhQYWdlU2VsZWN0b3IiO2Quc2V0QXR0cmlidXRlKCJib3JkZXIiLCIwIik7Zm9yKHZhciBlPWMuY3JlYXRlRWxlbWVudCgidGJvZHkiKSxmPTA7ZjxhO2YrKyl7Zm9yKHZhciBnPWMuY3JlYXRlRWxlbWVudCgidHIiKSxrPTA7azxiO2srKyl7dmFyIGw9ZipiK2srMSxtPWMuY3JlYXRlRWxlbWVudCgidGQiKSxuPWMuY3JlYXRlRWxlbWVudCgiYSIpO24uc2V0QXR0cmlidXRlKCJocmVmIiwiI214UGFnZS0iK2wpOyFteENsaWVudC5JU19OU3x8bXhDbGllbnQuSVNfU0Z8fG14Q2xpZW50LklTX0dDfHxuLnNldEF0dHJpYnV0ZSgib25jbGljayIsInZhciBwYWdlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ214UGFnZS0iK2wrIicpO3BhZ2Uuc2Nyb2xsSW50b1ZpZXcodHJ1ZSk7ZXZlbnQucHJldmVudERlZmF1bHQoKTsiKTsKbXhVdGlscy53cml0ZShuLGwsYyk7bS5hcHBlbmRDaGlsZChuKTtnLmFwcGVuZENoaWxkKG0pfWUuYXBwZW5kQ2hpbGQoZyl9ZC5hcHBlbmRDaGlsZChlKTtyZXR1cm4gZH07Cm14UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5yZW5kZXJQYWdlPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtmPXRoaXMud25kLmRvY3VtZW50O3ZhciBnPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLGs9bnVsbDt0cnl7aWYoMCE9Y3x8MCE9ZCl7Zy5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiO2cuc3R5bGUud2lkdGg9YSsicHgiO2cuc3R5bGUuaGVpZ2h0PWIrInB4IjtnLnN0eWxlLnBhZ2VCcmVha0luc2lkZT0iYXZvaWQiO3ZhciBsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2wuc3R5bGUucG9zaXRpb249InJlbGF0aXZlIjtsLnN0eWxlLnRvcD10aGlzLmJvcmRlcisicHgiO2wuc3R5bGUubGVmdD10aGlzLmJvcmRlcisicHgiO2wuc3R5bGUud2lkdGg9YS0yKnRoaXMuYm9yZGVyKyJweCI7bC5zdHlsZS5oZWlnaHQ9Yi0yKnRoaXMuYm9yZGVyKyJweCI7bC5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjt2YXIgbT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTttLnN0eWxlLnBvc2l0aW9uPQoicmVsYXRpdmUiO20uc3R5bGUubWFyZ2luTGVmdD1jKyJweCI7bS5zdHlsZS5tYXJnaW5Ub3A9ZCsicHgiOzg9PWYuZG9jdW1lbnRNb2RlJiYobC5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiLG0uc3R5bGUucG9zaXRpb249ImFic29sdXRlIik7MTA9PWYuZG9jdW1lbnRNb2RlJiYobS5zdHlsZS53aWR0aD0iMTAwJSIsbS5zdHlsZS5oZWlnaHQ9IjEwMCUiKTtsLmFwcGVuZENoaWxkKG0pO2cuYXBwZW5kQ2hpbGQobCk7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChnKTtrPW19ZWxzZSBnLnN0eWxlLndpZHRoPWErInB4IixnLnN0eWxlLmhlaWdodD1iKyJweCIsZy5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIixnLnN0eWxlLnBhZ2VCcmVha0luc2lkZT0iYXZvaWQiLDg9PWYuZG9jdW1lbnRNb2RlJiYoZy5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiKSxsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLGwuc3R5bGUud2lkdGg9YS0yKnRoaXMuYm9yZGVyKyJweCIsbC5zdHlsZS5oZWlnaHQ9CmItMip0aGlzLmJvcmRlcisicHgiLGwuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiIsIW14Q2xpZW50LklTX0lFfHxudWxsIT1mLmRvY3VtZW50TW9kZSYmNSE9Zi5kb2N1bWVudE1vZGUmJjghPWYuZG9jdW1lbnRNb2RlJiY3IT1mLmRvY3VtZW50TW9kZT8obC5zdHlsZS50b3A9dGhpcy5ib3JkZXIrInB4IixsLnN0eWxlLmxlZnQ9dGhpcy5ib3JkZXIrInB4Iik6KGwuc3R5bGUubWFyZ2luVG9wPXRoaXMuYm9yZGVyKyJweCIsbC5zdHlsZS5tYXJnaW5MZWZ0PXRoaXMuYm9yZGVyKyJweCIpLHRoaXMuZ3JhcGguZGlhbGVjdD09bXhDb25zdGFudHMuRElBTEVDVF9WTUwmJihsLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSIpLGcuYXBwZW5kQ2hpbGQobCksZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChnKSxrPWx9Y2F0Y2gobil7dGhyb3cgZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGcpLG47fWUoayk7cmV0dXJuIGd9OwpteFByaW50UHJldmlldy5wcm90b3R5cGUuZ2V0Um9vdD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ3JhcGgudmlldy5jdXJyZW50Um9vdDtudWxsPT1hJiYoYT10aGlzLmdyYXBoLmdldE1vZGVsKCkuZ2V0Um9vdCgpKTtyZXR1cm4gYX07Cm14UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5hZGRHcmFwaEZyYWdtZW50PWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgZz10aGlzLmdyYXBoLmdldFZpZXcoKTtkPXRoaXMuZ3JhcGguY29udGFpbmVyO3RoaXMuZ3JhcGguY29udGFpbmVyPWU7dmFyIGs9Zy5nZXRDYW52YXMoKSxsPWcuZ2V0QmFja2dyb3VuZFBhbmUoKSxtPWcuZ2V0RHJhd1BhbmUoKSxuPWcuZ2V0T3ZlcmxheVBhbmUoKSxwPWM7aWYodGhpcy5ncmFwaC5kaWFsZWN0PT1teENvbnN0YW50cy5ESUFMRUNUX1NWRyl7aWYoZy5jcmVhdGVTdmcoKSwhbXhDbGllbnQuTk9fRk8pe3ZhciBxPWcuZ2V0RHJhd1BhbmUoKS5wYXJlbnROb2RlO3EuZ2V0QXR0cmlidXRlKCJ0cmFuc2Zvcm0iKTtxLnNldEF0dHJpYnV0ZSgidHJhbnNmb3JtT3JpZ2luIiwiMCAwIik7cS5zZXRBdHRyaWJ1dGUoInRyYW5zZm9ybSIsInNjYWxlKCIrYysiLCIrYysiKXRyYW5zbGF0ZSgiK2ErIiwiK2IrIikiKTtjPTE7Yj1hPTB9fWVsc2UgdGhpcy5ncmFwaC5kaWFsZWN0PT0KbXhDb25zdGFudHMuRElBTEVDVF9WTUw/Zy5jcmVhdGVWbWwoKTpnLmNyZWF0ZUh0bWwoKTtxPWcuaXNFdmVudHNFbmFibGVkKCk7Zy5zZXRFdmVudHNFbmFibGVkKCExKTt2YXIgcj10aGlzLmdyYXBoLmlzRW5hYmxlZCgpO3RoaXMuZ3JhcGguc2V0RW5hYmxlZCghMSk7dmFyIHQ9Zy5nZXRUcmFuc2xhdGUoKTtnLnRyYW5zbGF0ZT1uZXcgbXhQb2ludChhLGIpO3ZhciB1PXRoaXMuZ3JhcGguY2VsbFJlbmRlcmVyLnJlZHJhdyx4PWcuc3RhdGVzO2E9Zy5zY2FsZTtpZih0aGlzLmNsaXBwaW5nKXt2YXIgeT1uZXcgbXhSZWN0YW5nbGUoKGYueCt0LngpKmEsKGYueSt0LnkpKmEsZi53aWR0aCphL3AsZi5oZWlnaHQqYS9wKTt0aGlzLmdyYXBoLmNlbGxSZW5kZXJlci5yZWRyYXc9ZnVuY3Rpb24oYSxiLGMpe2lmKG51bGwhPWEpe3ZhciBkPXguZ2V0KGEuY2VsbCk7aWYobnVsbCE9ZCYmKGQ9Zy5nZXRCb3VuZGluZ0JveChkLCExKSxudWxsIT1kJiYwPGQud2lkdGgmJjA8ZC5oZWlnaHQmJgohbXhVdGlscy5pbnRlcnNlY3RzKHksZCkpKXJldHVybn11LmFwcGx5KHRoaXMsYXJndW1lbnRzKX19YT1udWxsO3RyeXt2YXIgQj1bdGhpcy5nZXRSb290KCldO2E9bmV3IG14VGVtcG9yYXJ5Q2VsbFN0YXRlcyhnLGMsQixudWxsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdldExpbmtGb3JDZWxsU3RhdGUoYSl9KSl9ZmluYWxseXtpZihteENsaWVudC5JU19JRSlnLm92ZXJsYXlQYW5lLmlubmVySFRNTD0iIixnLmNhbnZhcy5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIixnLmNhbnZhcy5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiLGcuY2FudmFzLnN0eWxlLnRvcD10aGlzLm1hcmdpblRvcCsicHgiLGcuY2FudmFzLnN0eWxlLndpZHRoPWYud2lkdGgrInB4IixnLmNhbnZhcy5zdHlsZS5oZWlnaHQ9Zi5oZWlnaHQrInB4IjtlbHNlIGZvcihjPWUuZmlyc3RDaGlsZDtudWxsIT1jOylCPWMubmV4dFNpYmxpbmcsYj1jLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksCiJzdmciPT1iPyhjLnN0eWxlLm92ZXJmbG93PSJoaWRkZW4iLGMuc3R5bGUucG9zaXRpb249InJlbGF0aXZlIixjLnN0eWxlLnRvcD10aGlzLm1hcmdpblRvcCsicHgiLGMuc2V0QXR0cmlidXRlKCJ3aWR0aCIsZi53aWR0aCksYy5zZXRBdHRyaWJ1dGUoImhlaWdodCIsZi5oZWlnaHQpLGMuc3R5bGUud2lkdGg9IiIsYy5zdHlsZS5oZWlnaHQ9IiIpOiJkZWZhdWx0IiE9Yy5zdHlsZS5jdXJzb3ImJiJkaXYiIT1iJiZjLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYyksYz1CO3RoaXMucHJpbnRCYWNrZ3JvdW5kSW1hZ2UmJihlPWUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoInN2ZyIpLDA8ZS5sZW5ndGgmJihlWzBdLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSIpKTtnLm92ZXJsYXlQYW5lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZy5vdmVybGF5UGFuZSk7dGhpcy5ncmFwaC5zZXRFbmFibGVkKHIpO3RoaXMuZ3JhcGguY29udGFpbmVyPWQ7dGhpcy5ncmFwaC5jZWxsUmVuZGVyZXIucmVkcmF3PQp1O2cuY2FudmFzPWs7Zy5iYWNrZ3JvdW5kUGFuZT1sO2cuZHJhd1BhbmU9bTtnLm92ZXJsYXlQYW5lPW47Zy50cmFuc2xhdGU9dDthLmRlc3Ryb3koKTtnLnNldEV2ZW50c0VuYWJsZWQocSl9fTtteFByaW50UHJldmlldy5wcm90b3R5cGUuZ2V0TGlua0ZvckNlbGxTdGF0ZT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5ncmFwaC5nZXRMaW5rRm9yQ2VsbChhLmNlbGwpfTsKbXhQcmludFByZXZpZXcucHJvdG90eXBlLmluc2VydEJhY2tncm91bmRJbWFnZT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5ncmFwaC5iYWNrZ3JvdW5kSW1hZ2U7aWYobnVsbCE9ZCl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIik7ZS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO2Uuc3R5bGUubWFyZ2luTGVmdD1NYXRoLnJvdW5kKGIqdGhpcy5zY2FsZSkrInB4IjtlLnN0eWxlLm1hcmdpblRvcD1NYXRoLnJvdW5kKGMqdGhpcy5zY2FsZSkrInB4IjtlLnNldEF0dHJpYnV0ZSgid2lkdGgiLE1hdGgucm91bmQodGhpcy5zY2FsZSpkLndpZHRoKSk7ZS5zZXRBdHRyaWJ1dGUoImhlaWdodCIsTWF0aC5yb3VuZCh0aGlzLnNjYWxlKmQuaGVpZ2h0KSk7ZS5zcmM9ZC5zcmM7YS5pbnNlcnRCZWZvcmUoZSxhLmZpcnN0Q2hpbGQpfX07bXhQcmludFByZXZpZXcucHJvdG90eXBlLmdldENvdmVyUGFnZXM9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07Cm14UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5nZXRBcHBlbmRpY2VzPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O214UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5wcmludD1mdW5jdGlvbihhKXthPXRoaXMub3BlbihhKTtudWxsIT1hJiZhLnByaW50KCl9O214UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5jbG9zZT1mdW5jdGlvbigpe251bGwhPXRoaXMud25kJiYodGhpcy53bmQuY2xvc2UoKSx0aGlzLnduZD1udWxsKX07ZnVuY3Rpb24gbXhTdHlsZXNoZWV0KCl7dGhpcy5zdHlsZXM9e307dGhpcy5wdXREZWZhdWx0VmVydGV4U3R5bGUodGhpcy5jcmVhdGVEZWZhdWx0VmVydGV4U3R5bGUoKSk7dGhpcy5wdXREZWZhdWx0RWRnZVN0eWxlKHRoaXMuY3JlYXRlRGVmYXVsdEVkZ2VTdHlsZSgpKX0KbXhTdHlsZXNoZWV0LnByb3RvdHlwZS5jcmVhdGVEZWZhdWx0VmVydGV4U3R5bGU9ZnVuY3Rpb24oKXt2YXIgYT17fTthW214Q29uc3RhbnRzLlNUWUxFX1NIQVBFXT1teENvbnN0YW50cy5TSEFQRV9SRUNUQU5HTEU7YVtteENvbnN0YW50cy5TVFlMRV9QRVJJTUVURVJdPW14UGVyaW1ldGVyLlJlY3RhbmdsZVBlcmltZXRlcjthW214Q29uc3RhbnRzLlNUWUxFX1ZFUlRJQ0FMX0FMSUdOXT1teENvbnN0YW50cy5BTElHTl9NSURETEU7YVtteENvbnN0YW50cy5TVFlMRV9BTElHTl09bXhDb25zdGFudHMuQUxJR05fQ0VOVEVSO2FbbXhDb25zdGFudHMuU1RZTEVfRklMTENPTE9SXT0iI0MzRDlGRiI7YVtteENvbnN0YW50cy5TVFlMRV9TVFJPS0VDT0xPUl09IiM2NDgyQjkiO2FbbXhDb25zdGFudHMuU1RZTEVfRk9OVENPTE9SXT0iIzc3NDQwMCI7cmV0dXJuIGF9OwpteFN0eWxlc2hlZXQucHJvdG90eXBlLmNyZWF0ZURlZmF1bHRFZGdlU3R5bGU9ZnVuY3Rpb24oKXt2YXIgYT17fTthW214Q29uc3RhbnRzLlNUWUxFX1NIQVBFXT1teENvbnN0YW50cy5TSEFQRV9DT05ORUNUT1I7YVtteENvbnN0YW50cy5TVFlMRV9FTkRBUlJPV109bXhDb25zdGFudHMuQVJST1dfQ0xBU1NJQzthW214Q29uc3RhbnRzLlNUWUxFX1ZFUlRJQ0FMX0FMSUdOXT1teENvbnN0YW50cy5BTElHTl9NSURETEU7YVtteENvbnN0YW50cy5TVFlMRV9BTElHTl09bXhDb25zdGFudHMuQUxJR05fQ0VOVEVSO2FbbXhDb25zdGFudHMuU1RZTEVfU1RST0tFQ09MT1JdPSIjNjQ4MkI5IjthW214Q29uc3RhbnRzLlNUWUxFX0ZPTlRDT0xPUl09IiM0NDYyOTkiO3JldHVybiBhfTtteFN0eWxlc2hlZXQucHJvdG90eXBlLnB1dERlZmF1bHRWZXJ0ZXhTdHlsZT1mdW5jdGlvbihhKXt0aGlzLnB1dENlbGxTdHlsZSgiZGVmYXVsdFZlcnRleCIsYSl9OwpteFN0eWxlc2hlZXQucHJvdG90eXBlLnB1dERlZmF1bHRFZGdlU3R5bGU9ZnVuY3Rpb24oYSl7dGhpcy5wdXRDZWxsU3R5bGUoImRlZmF1bHRFZGdlIixhKX07bXhTdHlsZXNoZWV0LnByb3RvdHlwZS5nZXREZWZhdWx0VmVydGV4U3R5bGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdHlsZXMuZGVmYXVsdFZlcnRleH07bXhTdHlsZXNoZWV0LnByb3RvdHlwZS5nZXREZWZhdWx0RWRnZVN0eWxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3R5bGVzLmRlZmF1bHRFZGdlfTtteFN0eWxlc2hlZXQucHJvdG90eXBlLnB1dENlbGxTdHlsZT1mdW5jdGlvbihhLGIpe3RoaXMuc3R5bGVzW2FdPWJ9OwpteFN0eWxlc2hlZXQucHJvdG90eXBlLmdldENlbGxTdHlsZT1mdW5jdGlvbihhLGIpe3ZhciBjPWI7aWYobnVsbCE9YSYmMDxhLmxlbmd0aClmb3IodmFyIGQ9YS5zcGxpdCgiOyIpLGM9bnVsbCE9YyYmIjsiIT1hLmNoYXJBdCgwKT9teFV0aWxzLmNsb25lKGMpOnt9LGU9MDtlPGQubGVuZ3RoO2UrKyl7dmFyIGY9ZFtlXSxnPWYuaW5kZXhPZigiPSIpO2lmKDA8PWcpe3ZhciBrPWYuc3Vic3RyaW5nKDAsZyksZj1mLnN1YnN0cmluZyhnKzEpO2Y9PW14Q29uc3RhbnRzLk5PTkU/ZGVsZXRlIGNba106bXhVdGlscy5pc051bWVyaWMoZik/Y1trXT1wYXJzZUZsb2F0KGYpOmNba109Zn1lbHNlIGlmKGY9dGhpcy5zdHlsZXNbZl0sbnVsbCE9Zilmb3IoayBpbiBmKWNba109ZltrXX1yZXR1cm4gY307CmZ1bmN0aW9uIG14Q2VsbFN0YXRlKGEsYixjKXt0aGlzLnZpZXc9YTt0aGlzLmNlbGw9Yjt0aGlzLnN0eWxlPW51bGwhPWM/Yzp7fTt0aGlzLm9yaWdpbj1uZXcgbXhQb2ludDt0aGlzLmFic29sdXRlT2Zmc2V0PW5ldyBteFBvaW50fW14Q2VsbFN0YXRlLnByb3RvdHlwZT1uZXcgbXhSZWN0YW5nbGU7bXhDZWxsU3RhdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14Q2VsbFN0YXRlO214Q2VsbFN0YXRlLnByb3RvdHlwZS52aWV3PW51bGw7bXhDZWxsU3RhdGUucHJvdG90eXBlLmNlbGw9bnVsbDtteENlbGxTdGF0ZS5wcm90b3R5cGUuc3R5bGU9bnVsbDtteENlbGxTdGF0ZS5wcm90b3R5cGUuaW52YWxpZFN0eWxlPSExO214Q2VsbFN0YXRlLnByb3RvdHlwZS5pbnZhbGlkPSEwO214Q2VsbFN0YXRlLnByb3RvdHlwZS5vcmlnaW49bnVsbDtteENlbGxTdGF0ZS5wcm90b3R5cGUuYWJzb2x1dGVQb2ludHM9bnVsbDtteENlbGxTdGF0ZS5wcm90b3R5cGUuYWJzb2x1dGVPZmZzZXQ9bnVsbDsKbXhDZWxsU3RhdGUucHJvdG90eXBlLnZpc2libGVTb3VyY2VTdGF0ZT1udWxsO214Q2VsbFN0YXRlLnByb3RvdHlwZS52aXNpYmxlVGFyZ2V0U3RhdGU9bnVsbDtteENlbGxTdGF0ZS5wcm90b3R5cGUudGVybWluYWxEaXN0YW5jZT0wO214Q2VsbFN0YXRlLnByb3RvdHlwZS5sZW5ndGg9MDtteENlbGxTdGF0ZS5wcm90b3R5cGUuc2VnbWVudHM9bnVsbDtteENlbGxTdGF0ZS5wcm90b3R5cGUuc2hhcGU9bnVsbDtteENlbGxTdGF0ZS5wcm90b3R5cGUudGV4dD1udWxsO214Q2VsbFN0YXRlLnByb3RvdHlwZS51bnNjYWxlZFdpZHRoPW51bGw7bXhDZWxsU3RhdGUucHJvdG90eXBlLnVuc2NhbGVkSGVpZ2h0PW51bGw7Cm14Q2VsbFN0YXRlLnByb3RvdHlwZS5nZXRQZXJpbWV0ZXJCb3VuZHM9ZnVuY3Rpb24oYSxiKXthPWF8fDA7Yj1udWxsIT1iP2I6bmV3IG14UmVjdGFuZ2xlKHRoaXMueCx0aGlzLnksdGhpcy53aWR0aCx0aGlzLmhlaWdodCk7aWYobnVsbCE9dGhpcy5zaGFwZSYmbnVsbCE9dGhpcy5zaGFwZS5zdGVuY2lsJiYiZml4ZWQiPT10aGlzLnNoYXBlLnN0ZW5jaWwuYXNwZWN0KXt2YXIgYz10aGlzLnNoYXBlLnN0ZW5jaWwuY29tcHV0ZUFzcGVjdCh0aGlzLnN0eWxlLGIueCxiLnksYi53aWR0aCxiLmhlaWdodCk7Yi54PWMueDtiLnk9Yy55O2Iud2lkdGg9dGhpcy5zaGFwZS5zdGVuY2lsLncwKmMud2lkdGg7Yi5oZWlnaHQ9dGhpcy5zaGFwZS5zdGVuY2lsLmgwKmMuaGVpZ2h0fTAhPWEmJmIuZ3JvdyhhKTtyZXR1cm4gYn07Cm14Q2VsbFN0YXRlLnByb3RvdHlwZS5zZXRBYnNvbHV0ZVRlcm1pbmFsUG9pbnQ9ZnVuY3Rpb24oYSxiKXtiPyhudWxsPT10aGlzLmFic29sdXRlUG9pbnRzJiYodGhpcy5hYnNvbHV0ZVBvaW50cz1bXSksMD09dGhpcy5hYnNvbHV0ZVBvaW50cy5sZW5ndGg/dGhpcy5hYnNvbHV0ZVBvaW50cy5wdXNoKGEpOnRoaXMuYWJzb2x1dGVQb2ludHNbMF09YSk6bnVsbD09dGhpcy5hYnNvbHV0ZVBvaW50cz8odGhpcy5hYnNvbHV0ZVBvaW50cz1bXSx0aGlzLmFic29sdXRlUG9pbnRzLnB1c2gobnVsbCksdGhpcy5hYnNvbHV0ZVBvaW50cy5wdXNoKGEpKToxPT10aGlzLmFic29sdXRlUG9pbnRzLmxlbmd0aD90aGlzLmFic29sdXRlUG9pbnRzLnB1c2goYSk6dGhpcy5hYnNvbHV0ZVBvaW50c1t0aGlzLmFic29sdXRlUG9pbnRzLmxlbmd0aC0xXT1hfTsKbXhDZWxsU3RhdGUucHJvdG90eXBlLnNldEN1cnNvcj1mdW5jdGlvbihhKXtudWxsIT10aGlzLnNoYXBlJiZ0aGlzLnNoYXBlLnNldEN1cnNvcihhKTtudWxsIT10aGlzLnRleHQmJnRoaXMudGV4dC5zZXRDdXJzb3IoYSl9O214Q2VsbFN0YXRlLnByb3RvdHlwZS5nZXRWaXNpYmxlVGVybWluYWw9ZnVuY3Rpb24oYSl7YT10aGlzLmdldFZpc2libGVUZXJtaW5hbFN0YXRlKGEpO3JldHVybiBudWxsIT1hP2EuY2VsbDpudWxsfTtteENlbGxTdGF0ZS5wcm90b3R5cGUuZ2V0VmlzaWJsZVRlcm1pbmFsU3RhdGU9ZnVuY3Rpb24oYSl7cmV0dXJuIGE/dGhpcy52aXNpYmxlU291cmNlU3RhdGU6dGhpcy52aXNpYmxlVGFyZ2V0U3RhdGV9O214Q2VsbFN0YXRlLnByb3RvdHlwZS5zZXRWaXNpYmxlVGVybWluYWxTdGF0ZT1mdW5jdGlvbihhLGIpe2I/dGhpcy52aXNpYmxlU291cmNlU3RhdGU9YTp0aGlzLnZpc2libGVUYXJnZXRTdGF0ZT1hfTsKbXhDZWxsU3RhdGUucHJvdG90eXBlLmdldENlbGxCb3VuZHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsQm91bmRzfTtteENlbGxTdGF0ZS5wcm90b3R5cGUuZ2V0UGFpbnRCb3VuZHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYWludEJvdW5kc307bXhDZWxsU3RhdGUucHJvdG90eXBlLnVwZGF0ZUNhY2hlZEJvdW5kcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMudmlldy50cmFuc2xhdGUsYj10aGlzLnZpZXcuc2NhbGU7dGhpcy5jZWxsQm91bmRzPW5ldyBteFJlY3RhbmdsZSh0aGlzLngvYi1hLngsdGhpcy55L2ItYS55LHRoaXMud2lkdGgvYix0aGlzLmhlaWdodC9iKTt0aGlzLnBhaW50Qm91bmRzPW14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUodGhpcy5jZWxsQm91bmRzKTtudWxsIT10aGlzLnNoYXBlJiZ0aGlzLnNoYXBlLmlzUGFpbnRCb3VuZHNJbnZlcnRlZCgpJiZ0aGlzLnBhaW50Qm91bmRzLnJvdGF0ZTkwKCl9OwpteENlbGxTdGF0ZS5wcm90b3R5cGUuc2V0U3RhdGU9ZnVuY3Rpb24oYSl7dGhpcy52aWV3PWEudmlldzt0aGlzLmNlbGw9YS5jZWxsO3RoaXMuc3R5bGU9YS5zdHlsZTt0aGlzLmFic29sdXRlUG9pbnRzPWEuYWJzb2x1dGVQb2ludHM7dGhpcy5vcmlnaW49YS5vcmlnaW47dGhpcy5hYnNvbHV0ZU9mZnNldD1hLmFic29sdXRlT2Zmc2V0O3RoaXMuYm91bmRpbmdCb3g9YS5ib3VuZGluZ0JveDt0aGlzLnRlcm1pbmFsRGlzdGFuY2U9YS50ZXJtaW5hbERpc3RhbmNlO3RoaXMuc2VnbWVudHM9YS5zZWdtZW50czt0aGlzLmxlbmd0aD1hLmxlbmd0aDt0aGlzLng9YS54O3RoaXMueT1hLnk7dGhpcy53aWR0aD1hLndpZHRoO3RoaXMuaGVpZ2h0PWEuaGVpZ2h0O3RoaXMudW5zY2FsZWRXaWR0aD1hLnVuc2NhbGVkV2lkdGg7dGhpcy51bnNjYWxlZEhlaWdodD1hLnVuc2NhbGVkSGVpZ2h0fTsKbXhDZWxsU3RhdGUucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14Q2VsbFN0YXRlKHRoaXMudmlldyx0aGlzLmNlbGwsdGhpcy5zdHlsZSk7aWYobnVsbCE9dGhpcy5hYnNvbHV0ZVBvaW50cyl7YS5hYnNvbHV0ZVBvaW50cz1bXTtmb3IodmFyIGI9MDtiPHRoaXMuYWJzb2x1dGVQb2ludHMubGVuZ3RoO2IrKylhLmFic29sdXRlUG9pbnRzW2JdPXRoaXMuYWJzb2x1dGVQb2ludHNbYl0uY2xvbmUoKX1udWxsIT10aGlzLm9yaWdpbiYmKGEub3JpZ2luPXRoaXMub3JpZ2luLmNsb25lKCkpO251bGwhPXRoaXMuYWJzb2x1dGVPZmZzZXQmJihhLmFic29sdXRlT2Zmc2V0PXRoaXMuYWJzb2x1dGVPZmZzZXQuY2xvbmUoKSk7bnVsbCE9dGhpcy5ib3VuZGluZ0JveCYmKGEuYm91bmRpbmdCb3g9dGhpcy5ib3VuZGluZ0JveC5jbG9uZSgpKTthLnRlcm1pbmFsRGlzdGFuY2U9dGhpcy50ZXJtaW5hbERpc3RhbmNlO2Euc2VnbWVudHM9dGhpcy5zZWdtZW50czthLmxlbmd0aD0KdGhpcy5sZW5ndGg7YS54PXRoaXMueDthLnk9dGhpcy55O2Eud2lkdGg9dGhpcy53aWR0aDthLmhlaWdodD10aGlzLmhlaWdodDthLnVuc2NhbGVkV2lkdGg9dGhpcy51bnNjYWxlZFdpZHRoO2EudW5zY2FsZWRIZWlnaHQ9dGhpcy51bnNjYWxlZEhlaWdodDtyZXR1cm4gYX07bXhDZWxsU3RhdGUucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLnZpZXcuZ3JhcGguY2VsbFJlbmRlcmVyLmRlc3Ryb3kodGhpcyl9O2Z1bmN0aW9uIG14R3JhcGhTZWxlY3Rpb25Nb2RlbChhKXt0aGlzLmdyYXBoPWE7dGhpcy5jZWxscz1bXX1teEdyYXBoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlPW5ldyBteEV2ZW50U291cmNlO214R3JhcGhTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhHcmFwaFNlbGVjdGlvbk1vZGVsO214R3JhcGhTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuZG9uZVJlc291cmNlPSJub25lIiE9bXhDbGllbnQubGFuZ3VhZ2U/ImRvbmUiOiIiOwpteEdyYXBoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLnVwZGF0aW5nU2VsZWN0aW9uUmVzb3VyY2U9Im5vbmUiIT1teENsaWVudC5sYW5ndWFnZT8idXBkYXRpbmdTZWxlY3Rpb24iOiIiO214R3JhcGhTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuZ3JhcGg9bnVsbDtteEdyYXBoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLnNpbmdsZVNlbGVjdGlvbj0hMTtteEdyYXBoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmlzU2luZ2xlU2VsZWN0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2luZ2xlU2VsZWN0aW9ufTtteEdyYXBoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLnNldFNpbmdsZVNlbGVjdGlvbj1mdW5jdGlvbihhKXt0aGlzLnNpbmdsZVNlbGVjdGlvbj1hfTtteEdyYXBoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmlzU2VsZWN0ZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/MDw9bXhVdGlscy5pbmRleE9mKHRoaXMuY2VsbHMsYSk6ITF9OwpteEdyYXBoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09dGhpcy5jZWxscy5sZW5ndGh9O214R3JhcGhTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLmNoYW5nZVNlbGVjdGlvbihudWxsLHRoaXMuY2VsbHMpfTtteEdyYXBoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLnNldENlbGw9ZnVuY3Rpb24oYSl7bnVsbCE9YSYmdGhpcy5zZXRDZWxscyhbYV0pfTtteEdyYXBoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLnNldENlbGxzPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe3RoaXMuc2luZ2xlU2VsZWN0aW9uJiYoYT1bdGhpcy5nZXRGaXJzdFNlbGVjdGFibGVDZWxsKGEpXSk7Zm9yKHZhciBiPVtdLGM9MDtjPGEubGVuZ3RoO2MrKyl0aGlzLmdyYXBoLmlzQ2VsbFNlbGVjdGFibGUoYVtjXSkmJmIucHVzaChhW2NdKTt0aGlzLmNoYW5nZVNlbGVjdGlvbihiLHRoaXMuY2VsbHMpfX07Cm14R3JhcGhTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuZ2V0Rmlyc3RTZWxlY3RhYmxlQ2VsbD1mdW5jdGlvbihhKXtpZihudWxsIT1hKWZvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKWlmKHRoaXMuZ3JhcGguaXNDZWxsU2VsZWN0YWJsZShhW2JdKSlyZXR1cm4gYVtiXTtyZXR1cm4gbnVsbH07bXhHcmFwaFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5hZGRDZWxsPWZ1bmN0aW9uKGEpe251bGwhPWEmJnRoaXMuYWRkQ2VsbHMoW2FdKX07Cm14R3JhcGhTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuYWRkQ2VsbHM9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSl7dmFyIGI9bnVsbDt0aGlzLnNpbmdsZVNlbGVjdGlvbiYmKGI9dGhpcy5jZWxscyxhPVt0aGlzLmdldEZpcnN0U2VsZWN0YWJsZUNlbGwoYSldKTtmb3IodmFyIGM9W10sZD0wO2Q8YS5sZW5ndGg7ZCsrKSF0aGlzLmlzU2VsZWN0ZWQoYVtkXSkmJnRoaXMuZ3JhcGguaXNDZWxsU2VsZWN0YWJsZShhW2RdKSYmYy5wdXNoKGFbZF0pO3RoaXMuY2hhbmdlU2VsZWN0aW9uKGMsYil9fTtteEdyYXBoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLnJlbW92ZUNlbGw9ZnVuY3Rpb24oYSl7bnVsbCE9YSYmdGhpcy5yZW1vdmVDZWxscyhbYV0pfTsKbXhHcmFwaFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5yZW1vdmVDZWxscz1mdW5jdGlvbihhKXtpZihudWxsIT1hKXtmb3IodmFyIGI9W10sYz0wO2M8YS5sZW5ndGg7YysrKXRoaXMuaXNTZWxlY3RlZChhW2NdKSYmYi5wdXNoKGFbY10pO3RoaXMuY2hhbmdlU2VsZWN0aW9uKG51bGwsYil9fTtteEdyYXBoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmNoYW5nZVNlbGVjdGlvbj1mdW5jdGlvbihhLGIpe2lmKG51bGwhPWEmJjA8YS5sZW5ndGgmJm51bGwhPWFbMF18fG51bGwhPWImJjA8Yi5sZW5ndGgmJm51bGwhPWJbMF0pe3ZhciBjPW5ldyBteFNlbGVjdGlvbkNoYW5nZSh0aGlzLGEsYik7Yy5leGVjdXRlKCk7dmFyIGQ9bmV3IG14VW5kb2FibGVFZGl0KHRoaXMsITEpO2QuYWRkKGMpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuVU5ETywiZWRpdCIsZCkpfX07Cm14R3JhcGhTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuY2VsbEFkZGVkPWZ1bmN0aW9uKGEpe251bGw9PWF8fHRoaXMuaXNTZWxlY3RlZChhKXx8dGhpcy5jZWxscy5wdXNoKGEpfTtteEdyYXBoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmNlbGxSZW1vdmVkPWZ1bmN0aW9uKGEpe251bGwhPWEmJihhPW14VXRpbHMuaW5kZXhPZih0aGlzLmNlbGxzLGEpLDA8PWEmJnRoaXMuY2VsbHMuc3BsaWNlKGEsMSkpfTtmdW5jdGlvbiBteFNlbGVjdGlvbkNoYW5nZShhLGIsYyl7dGhpcy5zZWxlY3Rpb25Nb2RlbD1hO3RoaXMuYWRkZWQ9bnVsbCE9Yj9iLnNsaWNlKCk6bnVsbDt0aGlzLnJlbW92ZWQ9bnVsbCE9Yz9jLnNsaWNlKCk6bnVsbH0KbXhTZWxlY3Rpb25DaGFuZ2UucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXt2YXIgYT1teExvZy5lbnRlcigibXhTZWxlY3Rpb25DaGFuZ2UuZXhlY3V0ZSIpO3dpbmRvdy5zdGF0dXM9bXhSZXNvdXJjZXMuZ2V0KHRoaXMuc2VsZWN0aW9uTW9kZWwudXBkYXRpbmdTZWxlY3Rpb25SZXNvdXJjZSl8fHRoaXMuc2VsZWN0aW9uTW9kZWwudXBkYXRpbmdTZWxlY3Rpb25SZXNvdXJjZTtpZihudWxsIT10aGlzLnJlbW92ZWQpZm9yKHZhciBiPTA7Yjx0aGlzLnJlbW92ZWQubGVuZ3RoO2IrKyl0aGlzLnNlbGVjdGlvbk1vZGVsLmNlbGxSZW1vdmVkKHRoaXMucmVtb3ZlZFtiXSk7aWYobnVsbCE9dGhpcy5hZGRlZClmb3IoYj0wO2I8dGhpcy5hZGRlZC5sZW5ndGg7YisrKXRoaXMuc2VsZWN0aW9uTW9kZWwuY2VsbEFkZGVkKHRoaXMuYWRkZWRbYl0pO2I9dGhpcy5hZGRlZDt0aGlzLmFkZGVkPXRoaXMucmVtb3ZlZDt0aGlzLnJlbW92ZWQ9Yjt3aW5kb3cuc3RhdHVzPW14UmVzb3VyY2VzLmdldCh0aGlzLnNlbGVjdGlvbk1vZGVsLmRvbmVSZXNvdXJjZSl8fAp0aGlzLnNlbGVjdGlvbk1vZGVsLmRvbmVSZXNvdXJjZTtteExvZy5sZWF2ZSgibXhTZWxlY3Rpb25DaGFuZ2UuZXhlY3V0ZSIsYSk7dGhpcy5zZWxlY3Rpb25Nb2RlbC5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5DSEFOR0UsImFkZGVkIix0aGlzLmFkZGVkLCJyZW1vdmVkIix0aGlzLnJlbW92ZWQpKX07CmZ1bmN0aW9uIG14Q2VsbEVkaXRvcihhKXt0aGlzLmdyYXBoPWE7dGhpcy56b29tSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuZ3JhcGguaXNFZGl0aW5nKCkmJnRoaXMucmVzaXplKCl9KTt0aGlzLmdyYXBoLnZpZXcuYWRkTGlzdGVuZXIobXhFdmVudC5TQ0FMRSx0aGlzLnpvb21IYW5kbGVyKTt0aGlzLmdyYXBoLnZpZXcuYWRkTGlzdGVuZXIobXhFdmVudC5TQ0FMRV9BTkRfVFJBTlNMQVRFLHRoaXMuem9vbUhhbmRsZXIpO3RoaXMuY2hhbmdlSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsIT10aGlzLmVkaXRpbmdDZWxsJiZudWxsPT10aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRTdGF0ZSh0aGlzLmVkaXRpbmdDZWxsKSYmdGhpcy5zdG9wRWRpdGluZyghMCl9KTt0aGlzLmdyYXBoLmdldE1vZGVsKCkuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsdGhpcy5jaGFuZ2VIYW5kbGVyKX0KbXhDZWxsRWRpdG9yLnByb3RvdHlwZS5ncmFwaD1udWxsO214Q2VsbEVkaXRvci5wcm90b3R5cGUudGV4dGFyZWE9bnVsbDtteENlbGxFZGl0b3IucHJvdG90eXBlLmVkaXRpbmdDZWxsPW51bGw7bXhDZWxsRWRpdG9yLnByb3RvdHlwZS50cmlnZ2VyPW51bGw7bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5tb2RpZmllZD0hMTtteENlbGxFZGl0b3IucHJvdG90eXBlLmF1dG9TaXplPSEwO214Q2VsbEVkaXRvci5wcm90b3R5cGUuc2VsZWN0VGV4dD0hMDtteENlbGxFZGl0b3IucHJvdG90eXBlLmVtcHR5TGFiZWxUZXh0PW14Q2xpZW50LklTX0ZGPyI8YnI+IjoiIjtteENlbGxFZGl0b3IucHJvdG90eXBlLmVzY2FwZUNhbmNlbHNFZGl0aW5nPSEwO214Q2VsbEVkaXRvci5wcm90b3R5cGUudGV4dE5vZGU9IiI7bXhDZWxsRWRpdG9yLnByb3RvdHlwZS56SW5kZXg9NTtteENlbGxFZGl0b3IucHJvdG90eXBlLm1pblJlc2l6ZT1uZXcgbXhSZWN0YW5nbGUoMCwyMCk7Cm14Q2VsbEVkaXRvci5wcm90b3R5cGUud29yZFdyYXBQYWRkaW5nPW14Q2xpZW50LklTX1FVSVJLUz8yOm14Q2xpZW50LklTX0lFMTE/MDoxO214Q2VsbEVkaXRvci5wcm90b3R5cGUuYmx1ckVuYWJsZWQ9ITE7bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5pbml0aWFsVmFsdWU9bnVsbDtteENlbGxFZGl0b3IucHJvdG90eXBlLmFsaWduPW51bGw7bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7dGhpcy50ZXh0YXJlYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTt0aGlzLnRleHRhcmVhLmNsYXNzTmFtZT0ibXhDZWxsRWRpdG9yIG14UGxhaW5UZXh0RWRpdG9yIjt0aGlzLnRleHRhcmVhLmNvbnRlbnRFZGl0YWJsZT0hMDtteENsaWVudC5JU19HQyYmKHRoaXMudGV4dGFyZWEuc3R5bGUubWluSGVpZ2h0PSIxZW0iKTt0aGlzLnRleHRhcmVhLnN0eWxlLnBvc2l0aW9uPXRoaXMuaXNMZWdhY3lFZGl0b3IoKT8iYWJzb2x1dGUiOiJyZWxhdGl2ZSI7dGhpcy5pbnN0YWxsTGlzdGVuZXJzKHRoaXMudGV4dGFyZWEpfTsKbXhDZWxsRWRpdG9yLnByb3RvdHlwZS5hcHBseVZhbHVlPWZ1bmN0aW9uKGEsYil7dGhpcy5ncmFwaC5sYWJlbENoYW5nZWQoYS5jZWxsLGIsdGhpcy50cmlnZ2VyKX07bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5zZXRBbGlnbj1mdW5jdGlvbihhKXtudWxsIT10aGlzLnRleHRhcmVhJiYodGhpcy50ZXh0YXJlYS5zdHlsZS50ZXh0QWxpZ249YSk7dGhpcy5hbGlnbj1hO3RoaXMucmVzaXplKCl9OwpteENlbGxFZGl0b3IucHJvdG90eXBlLmdldEluaXRpYWxWYWx1ZT1mdW5jdGlvbihhLGIpe3ZhciBjPW14VXRpbHMuaHRtbEVudGl0aWVzKHRoaXMuZ3JhcGguZ2V0RWRpdGluZ1ZhbHVlKGEuY2VsbCxiKSwhMSk7bXhDbGllbnQuSVNfUVVJUktTfHw4PT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fDk9PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8MTA9PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8KGM9bXhVdGlscy5yZXBsYWNlVHJhaWxpbmdOZXdsaW5lcyhjLCI8ZGl2Pjxicj48L2Rpdj4iKSk7cmV0dXJuIGMucmVwbGFjZSgvXG4vZywiPGJyPiIpfTtteENlbGxFZGl0b3IucHJvdG90eXBlLmdldEN1cnJlbnRWYWx1ZT1mdW5jdGlvbihhKXtyZXR1cm4gbXhVdGlscy5leHRyYWN0VGV4dFdpdGhXaGl0ZXNwYWNlKHRoaXMudGV4dGFyZWEuY2hpbGROb2Rlcyl9OwpteENlbGxFZGl0b3IucHJvdG90eXBlLmlzQ2FuY2VsRWRpdGluZ0tleUV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmVzY2FwZUNhbmNlbHNFZGl0aW5nfHxteEV2ZW50LmlzU2hpZnREb3duKGEpfHxteEV2ZW50LmlzQ29udHJvbERvd24oYSl8fG14RXZlbnQuaXNNZXRhRG93bihhKX07Cm14Q2VsbEVkaXRvci5wcm90b3R5cGUuaW5zdGFsbExpc3RlbmVycz1mdW5jdGlvbihhKXtteEV2ZW50LmFkZExpc3RlbmVyKGEsImRyYWdzdGFydCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5ncmFwaC5zdG9wRWRpdGluZyghMSk7bXhFdmVudC5jb25zdW1lKGEpfSkpO214RXZlbnQuYWRkTGlzdGVuZXIoYSwiYmx1ciIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5ibHVyRW5hYmxlZCYmdGhpcy5mb2N1c0xvc3QoYSl9KSk7bXhFdmVudC5hZGRMaXN0ZW5lcihhLCJrZXlkb3duIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtteEV2ZW50LmlzQ29uc3VtZWQoYSl8fCh0aGlzLmlzU3RvcEVkaXRpbmdFdmVudChhKT8odGhpcy5ncmFwaC5zdG9wRWRpdGluZyghMSksbXhFdmVudC5jb25zdW1lKGEpKToyNz09YS5rZXlDb2RlJiYodGhpcy5ncmFwaC5zdG9wRWRpdGluZyh0aGlzLmlzQ2FuY2VsRWRpdGluZ0tleUV2ZW50KGEpKSxteEV2ZW50LmNvbnN1bWUoYSkpKX0pKTsKdmFyIGI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7bnVsbCE9dGhpcy5lZGl0aW5nQ2VsbCYmdGhpcy5jbGVhck9uQ2hhbmdlJiZhLmlubmVySFRNTD09dGhpcy5nZXRFbXB0eUxhYmVsVGV4dCgpJiYoIW14Q2xpZW50LklTX0ZGfHw4IT1iLmtleUNvZGUmJjQ2IT1iLmtleUNvZGUpJiYodGhpcy5jbGVhck9uQ2hhbmdlPSExLGEuaW5uZXJIVE1MPSIiKX0pO214RXZlbnQuYWRkTGlzdGVuZXIoYSwia2V5cHJlc3MiLGIpO214RXZlbnQuYWRkTGlzdGVuZXIoYSwicGFzdGUiLGIpO2I9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bnVsbCE9dGhpcy5lZGl0aW5nQ2VsbCYmKDA9PXRoaXMudGV4dGFyZWEuaW5uZXJIVE1MLmxlbmd0aHx8Ijxicj4iPT10aGlzLnRleHRhcmVhLmlubmVySFRNTD8odGhpcy50ZXh0YXJlYS5pbm5lckhUTUw9dGhpcy5nZXRFbXB0eUxhYmVsVGV4dCgpLHRoaXMuY2xlYXJPbkNoYW5nZT0wPHRoaXMudGV4dGFyZWEuaW5uZXJIVE1MLmxlbmd0aCk6CnRoaXMuY2xlYXJPbkNoYW5nZT0hMSl9KTtteEV2ZW50LmFkZExpc3RlbmVyKGEsbXhDbGllbnQuSVNfSUUxMXx8bXhDbGllbnQuSVNfSUU/ImtleXVwIjoiaW5wdXQiLGIpO214RXZlbnQuYWRkTGlzdGVuZXIoYSwiY3V0IixiKTtteEV2ZW50LmFkZExpc3RlbmVyKGEsInBhc3RlIixiKTt2YXIgYj1teENsaWVudC5JU19JRTExfHxteENsaWVudC5JU19JRT8ia2V5ZG93biI6ImlucHV0IixjPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe251bGwhPXRoaXMuZWRpdGluZ0NlbGwmJnRoaXMuYXV0b1NpemUmJiFteEV2ZW50LmlzQ29uc3VtZWQoYSkmJihudWxsIT10aGlzLnJlc2l6ZVRocmVhZCYmd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRocmVhZCksdGhpcy5yZXNpemVUaHJlYWQ9d2luZG93LnNldFRpbWVvdXQobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnJlc2l6ZVRocmVhZD1udWxsO3RoaXMucmVzaXplKCl9KSwwKSl9KTtteEV2ZW50LmFkZExpc3RlbmVyKGEsCmIsYyk7bXhFdmVudC5hZGRMaXN0ZW5lcih3aW5kb3csInJlc2l6ZSIsYyk7OTw9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlPyhteEV2ZW50LmFkZExpc3RlbmVyKGEsIkRPTU5vZGVSZW1vdmVkIixjKSxteEV2ZW50LmFkZExpc3RlbmVyKGEsIkRPTU5vZGVJbnNlcnRlZCIsYykpOihteEV2ZW50LmFkZExpc3RlbmVyKGEsImN1dCIsYyksbXhFdmVudC5hZGRMaXN0ZW5lcihhLCJwYXN0ZSIsYykpfTtteENlbGxFZGl0b3IucHJvdG90eXBlLmlzU3RvcEVkaXRpbmdFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gMTEzPT1hLmtleUNvZGV8fHRoaXMuZ3JhcGguaXNFbnRlclN0b3BzQ2VsbEVkaXRpbmcoKSYmMTM9PWEua2V5Q29kZSYmIW14RXZlbnQuaXNDb250cm9sRG93bihhKSYmIW14RXZlbnQuaXNTaGlmdERvd24oYSl9O214Q2VsbEVkaXRvci5wcm90b3R5cGUuaXNFdmVudFNvdXJjZT1mdW5jdGlvbihhKXtyZXR1cm4gbXhFdmVudC5nZXRTb3VyY2UoYSk9PXRoaXMudGV4dGFyZWF9OwpteENlbGxFZGl0b3IucHJvdG90eXBlLnJlc2l6ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ3JhcGguZ2V0VmlldygpLmdldFN0YXRlKHRoaXMuZWRpdGluZ0NlbGwpO2lmKG51bGw9PWEpdGhpcy5zdG9wRWRpdGluZyghMCk7ZWxzZSBpZihudWxsIT10aGlzLnRleHRhcmVhKXt2YXIgYj10aGlzLmdyYXBoLmdldE1vZGVsKCkuaXNFZGdlKGEuY2VsbCksYz10aGlzLmdyYXBoLmdldFZpZXcoKS5zY2FsZSxkPW51bGw7aWYodGhpcy5hdXRvU2l6ZSYmImZpbGwiIT1hLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX09WRVJGTE9XXSl7dmFyIGU9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0xBQkVMX1dJRFRILG51bGwpLGQ9bnVsbCE9YS50ZXh0JiZudWxsPT10aGlzLmFsaWduP2EudGV4dC5tYXJnaW46bnVsbDtudWxsPT1kJiYoZD1teFV0aWxzLmdldEFsaWdubWVudEFzUG9pbnQodGhpcy5hbGlnbnx8bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FMSUdOLApteENvbnN0YW50cy5BTElHTl9DRU5URVIpLG14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9WRVJUSUNBTF9BTElHTixteENvbnN0YW50cy5BTElHTl9NSURETEUpKSk7aWYoYil0aGlzLmJvdW5kcz1uZXcgbXhSZWN0YW5nbGUoYS5hYnNvbHV0ZU9mZnNldC54LGEuYWJzb2x1dGVPZmZzZXQueSwwLDApLG51bGwhPWUmJihlPShwYXJzZUZsb2F0KGUpKzIpKmMsdGhpcy5ib3VuZHMud2lkdGg9ZSx0aGlzLmJvdW5kcy54Kz1kLngqZSk7ZWxzZXt2YXIgYj1teFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlKGEpLGY9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0xBQkVMX1BPU0lUSU9OLG14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUiksZz1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfVkVSVElDQUxfTEFCRUxfUE9TSVRJT04sbXhDb25zdGFudHMuQUxJR05fTUlERExFKSxiPW51bGwhPWEuc2hhcGUmJmY9PQpteENvbnN0YW50cy5BTElHTl9DRU5URVImJmc9PW14Q29uc3RhbnRzLkFMSUdOX01JRERMRT9hLnNoYXBlLmdldExhYmVsQm91bmRzKGIpOmI7bnVsbCE9ZSYmKGIud2lkdGg9cGFyc2VGbG9hdChlKSpjKTtpZighYS52aWV3LmdyYXBoLmNlbGxSZW5kZXJlci5sZWdhY3lTcGFjaW5nfHwid2lkdGgiIT1hLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX09WRVJGTE9XXSl2YXIgZj1wYXJzZUludChhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkddfHwyKSpjLGs9KHBhcnNlSW50KGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lOR19UT1BdfHwwKStteFRleHQucHJvdG90eXBlLmJhc2VTcGFjaW5nVG9wKSpjK2YsbD0ocGFyc2VJbnQoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HX1JJR0hUXXx8MCkrbXhUZXh0LnByb3RvdHlwZS5iYXNlU3BhY2luZ1JpZ2h0KSpjK2YsbT0ocGFyc2VJbnQoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HX0JPVFRPTV18fAowKStteFRleHQucHJvdG90eXBlLmJhc2VTcGFjaW5nQm90dG9tKSpjK2Ysbj0ocGFyc2VJbnQoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HX0xFRlRdfHwwKStteFRleHQucHJvdG90eXBlLmJhc2VTcGFjaW5nTGVmdCkqYytmLGY9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0xBQkVMX1BPU0lUSU9OLG14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUiksZz1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfVkVSVElDQUxfTEFCRUxfUE9TSVRJT04sbXhDb25zdGFudHMuQUxJR05fTUlERExFKSxiPW5ldyBteFJlY3RhbmdsZShiLngrbixiLnkrayxiLndpZHRoLShmPT1teENvbnN0YW50cy5BTElHTl9DRU5URVImJm51bGw9PWU/bitsOjApLGIuaGVpZ2h0LShnPT1teENvbnN0YW50cy5BTElHTl9NSURETEU/ayttOjApKTt0aGlzLmJvdW5kcz1uZXcgbXhSZWN0YW5nbGUoYi54K2EuYWJzb2x1dGVPZmZzZXQueCxiLnkrCmEuYWJzb2x1dGVPZmZzZXQueSxiLndpZHRoLGIuaGVpZ2h0KX10aGlzLmdyYXBoLmlzV3JhcHBpbmcoYS5jZWxsKSYmKDI8PXRoaXMuYm91bmRzLndpZHRofHwyPD10aGlzLmJvdW5kcy5oZWlnaHQpJiZ0aGlzLnRleHRhcmVhLmlubmVySFRNTCE9dGhpcy5nZXRFbXB0eUxhYmVsVGV4dCgpPyh0aGlzLnRleHRhcmVhLnN0eWxlLndvcmRXcmFwPW14Q29uc3RhbnRzLldPUkRfV1JBUCx0aGlzLnRleHRhcmVhLnN0eWxlLndoaXRlU3BhY2U9Im5vcm1hbCIsZT1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLndpZHRoL2MpK3RoaXMud29yZFdyYXBQYWRkaW5nLCJyZWxhdGl2ZSIhPXRoaXMudGV4dGFyZWEuc3R5bGUucG9zaXRpb24/KHRoaXMudGV4dGFyZWEuc3R5bGUud2lkdGg9ZSsicHgiLHRoaXMudGV4dGFyZWEuc2Nyb2xsV2lkdGg+ZSYmKHRoaXMudGV4dGFyZWEuc3R5bGUud2lkdGg9dGhpcy50ZXh0YXJlYS5zY3JvbGxXaWR0aCsicHgiKSk6dGhpcy50ZXh0YXJlYS5zdHlsZS5tYXhXaWR0aD0KZSsicHgiKToodGhpcy50ZXh0YXJlYS5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiLHRoaXMudGV4dGFyZWEuc3R5bGUud2lkdGg9IiIpOzg9PWRvY3VtZW50LmRvY3VtZW50TW9kZSYmKHRoaXMudGV4dGFyZWEuc3R5bGUuem9vbT0iMSIsdGhpcy50ZXh0YXJlYS5zdHlsZS5oZWlnaHQ9ImF1dG8iKTthPXRoaXMudGV4dGFyZWEuc2Nyb2xsV2lkdGg7ZT10aGlzLnRleHRhcmVhLnNjcm9sbEhlaWdodDs4PT1kb2N1bWVudC5kb2N1bWVudE1vZGU/KHRoaXMudGV4dGFyZWEuc3R5bGUubGVmdD1NYXRoLm1heCgwLE1hdGguY2VpbCgodGhpcy5ib3VuZHMueC1kLngqKHRoaXMuYm91bmRzLndpZHRoLShhKzEpKmMpK2EqKGMtMSkqMCsyKihkLngrLjUpKS9jKSkrInB4Iix0aGlzLnRleHRhcmVhLnN0eWxlLnRvcD1NYXRoLm1heCgwLE1hdGguY2VpbCgodGhpcy5ib3VuZHMueS1kLnkqKHRoaXMuYm91bmRzLmhlaWdodC0oZSsuNSkqYykrZSooYy0xKSowKzEqTWF0aC5hYnMoZC55Ky41KSkvCmMpKSsicHgiLHRoaXMudGV4dGFyZWEuc3R5bGUud2lkdGg9TWF0aC5yb3VuZChhKmMpKyJweCIsdGhpcy50ZXh0YXJlYS5zdHlsZS5oZWlnaHQ9TWF0aC5yb3VuZChlKmMpKyJweCIpOm14Q2xpZW50LklTX1FVSVJLUz8odGhpcy50ZXh0YXJlYS5zdHlsZS5sZWZ0PU1hdGgubWF4KDAsTWF0aC5jZWlsKHRoaXMuYm91bmRzLngtZC54Kih0aGlzLmJvdW5kcy53aWR0aC0oYSsxKSpjKSthKihjLTEpKjArMiooZC54Ky41KSkpKyJweCIsdGhpcy50ZXh0YXJlYS5zdHlsZS50b3A9TWF0aC5tYXgoMCxNYXRoLmNlaWwodGhpcy5ib3VuZHMueS1kLnkqKHRoaXMuYm91bmRzLmhlaWdodC0oZSsuNSkqYykrZSooYy0xKSowKzEqTWF0aC5hYnMoZC55Ky41KSkpKyJweCIpOih0aGlzLnRleHRhcmVhLnN0eWxlLmxlZnQ9TWF0aC5tYXgoMCxNYXRoLnJvdW5kKHRoaXMuYm91bmRzLngtZC54Kih0aGlzLmJvdW5kcy53aWR0aC0yKSkrMSkrInB4Iix0aGlzLnRleHRhcmVhLnN0eWxlLnRvcD1NYXRoLm1heCgwLApNYXRoLnJvdW5kKHRoaXMuYm91bmRzLnktZC55Kih0aGlzLmJvdW5kcy5oZWlnaHQtNCkrKC0xPT1kLnk/MzowKSkrMSkrInB4Iil9ZWxzZSB0aGlzLmJvdW5kcz10aGlzLmdldEVkaXRvckJvdW5kcyhhKSx0aGlzLnRleHRhcmVhLnN0eWxlLndpZHRoPU1hdGgucm91bmQodGhpcy5ib3VuZHMud2lkdGgvYykrInB4Iix0aGlzLnRleHRhcmVhLnN0eWxlLmhlaWdodD1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLmhlaWdodC9jKSsicHgiLDg9PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8bXhDbGllbnQuSVNfUVVJUktTPyh0aGlzLnRleHRhcmVhLnN0eWxlLmxlZnQ9TWF0aC5yb3VuZCh0aGlzLmJvdW5kcy54KSsicHgiLHRoaXMudGV4dGFyZWEuc3R5bGUudG9wPU1hdGgucm91bmQodGhpcy5ib3VuZHMueSkrInB4Iik6KHRoaXMudGV4dGFyZWEuc3R5bGUubGVmdD1NYXRoLm1heCgwLE1hdGgucm91bmQodGhpcy5ib3VuZHMueCsxKSkrInB4Iix0aGlzLnRleHRhcmVhLnN0eWxlLnRvcD1NYXRoLm1heCgwLApNYXRoLnJvdW5kKHRoaXMuYm91bmRzLnkrMSkpKyJweCIpLHRoaXMuZ3JhcGguaXNXcmFwcGluZyhhLmNlbGwpJiYoMjw9dGhpcy5ib3VuZHMud2lkdGh8fDI8PXRoaXMuYm91bmRzLmhlaWdodCkmJnRoaXMudGV4dGFyZWEuaW5uZXJIVE1MIT10aGlzLmdldEVtcHR5TGFiZWxUZXh0KCk/KHRoaXMudGV4dGFyZWEuc3R5bGUud29yZFdyYXA9bXhDb25zdGFudHMuV09SRF9XUkFQLHRoaXMudGV4dGFyZWEuc3R5bGUud2hpdGVTcGFjZT0ibm9ybWFsIiwiZmlsbCIhPWEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfT1ZFUkZMT1ddJiYodGhpcy50ZXh0YXJlYS5zdHlsZS53aWR0aD1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLndpZHRoL2MpK3RoaXMud29yZFdyYXBQYWRkaW5nKyJweCIpKToodGhpcy50ZXh0YXJlYS5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiLCJmaWxsIiE9YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9PVkVSRkxPV10mJih0aGlzLnRleHRhcmVhLnN0eWxlLndpZHRoPSIiKSk7Cm14Q2xpZW50LklTX1ZNTD90aGlzLnRleHRhcmVhLnN0eWxlLnpvb209YzoobXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKHRoaXMudGV4dGFyZWEuc3R5bGUsInRyYW5zZm9ybU9yaWdpbiIsIjBweCAwcHgiKSxteFV0aWxzLnNldFByZWZpeGVkU3R5bGUodGhpcy50ZXh0YXJlYS5zdHlsZSwidHJhbnNmb3JtIiwic2NhbGUoIitjKyIsIitjKyIpIisobnVsbD09ZD8iIjoiIHRyYW5zbGF0ZSgiKzEwMCpkLngrIiUsIisxMDAqZC55KyIlKSIpKSl9fTtteENlbGxFZGl0b3IucHJvdG90eXBlLmZvY3VzTG9zdD1mdW5jdGlvbigpe3RoaXMuc3RvcEVkaXRpbmcoIXRoaXMuZ3JhcGguaXNJbnZva2VzU3RvcENlbGxFZGl0aW5nKCkpfTtteENlbGxFZGl0b3IucHJvdG90eXBlLmdldEJhY2tncm91bmRDb2xvcj1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbH07Cm14Q2VsbEVkaXRvci5wcm90b3R5cGUuaXNMZWdhY3lFZGl0b3I9ZnVuY3Rpb24oKXtpZihteENsaWVudC5JU19WTUwpcmV0dXJuITA7dmFyIGE9ITE7aWYobXhDbGllbnQuSVNfU1ZHKXt2YXIgYj10aGlzLmdyYXBoLnZpZXcuZ2V0RHJhd1BhbmUoKS5vd25lclNWR0VsZW1lbnQ7bnVsbCE9YiYmKGI9bXhVdGlscy5nZXRDdXJyZW50U3R5bGUoYiksbnVsbCE9YiYmKGE9ImFic29sdXRlIj09Yi5wb3NpdGlvbikpfXJldHVybiFhfTsKbXhDZWxsRWRpdG9yLnByb3RvdHlwZS5zdGFydEVkaXRpbmc9ZnVuY3Rpb24oYSxiKXt0aGlzLnN0b3BFZGl0aW5nKCEwKTt0aGlzLmFsaWduPW51bGw7bnVsbD09dGhpcy50ZXh0YXJlYSYmdGhpcy5pbml0KCk7bnVsbCE9dGhpcy5ncmFwaC50b29sdGlwSGFuZGxlciYmdGhpcy5ncmFwaC50b29sdGlwSGFuZGxlci5oaWRlVG9vbHRpcCgpO3ZhciBjPXRoaXMuZ3JhcGguZ2V0VmlldygpLmdldFN0YXRlKGEpO2lmKG51bGwhPWMpe3RoaXMuZ3JhcGguZ2V0VmlldygpO3ZhciBkPW14VXRpbHMuZ2V0VmFsdWUoYy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GT05UU0laRSxteENvbnN0YW50cy5ERUZBVUxUX0ZPTlRTSVpFKSxlPW14VXRpbHMuZ2V0VmFsdWUoYy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GT05URkFNSUxZLG14Q29uc3RhbnRzLkRFRkFVTFRfRk9OVEZBTUlMWSksZj1teFV0aWxzLmdldFZhbHVlKGMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRk9OVENPTE9SLCJibGFjayIpLApnPW14VXRpbHMuZ2V0VmFsdWUoYy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BTElHTixteENvbnN0YW50cy5BTElHTl9MRUZUKSxrPShteFV0aWxzLmdldFZhbHVlKGMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRk9OVFNUWUxFLDApJm14Q29uc3RhbnRzLkZPTlRfQk9MRCk9PW14Q29uc3RhbnRzLkZPTlRfQk9MRCxsPShteFV0aWxzLmdldFZhbHVlKGMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRk9OVFNUWUxFLDApJm14Q29uc3RhbnRzLkZPTlRfSVRBTElDKT09bXhDb25zdGFudHMuRk9OVF9JVEFMSUMsbT1bXTsobXhVdGlscy5nZXRWYWx1ZShjLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRTVFlMRSwwKSZteENvbnN0YW50cy5GT05UX1VOREVSTElORSk9PW14Q29uc3RhbnRzLkZPTlRfVU5ERVJMSU5FJiZtLnB1c2goInVuZGVybGluZSIpOyhteFV0aWxzLmdldFZhbHVlKGMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRk9OVFNUWUxFLDApJm14Q29uc3RhbnRzLkZPTlRfU1RSSUtFVEhST1VHSCk9PQpteENvbnN0YW50cy5GT05UX1NUUklLRVRIUk9VR0gmJm0ucHVzaCgibGluZS10aHJvdWdoIik7dGhpcy50ZXh0YXJlYS5zdHlsZS5saW5lSGVpZ2h0PW14Q29uc3RhbnRzLkFCU09MVVRFX0xJTkVfSEVJR0hUP01hdGgucm91bmQoZCpteENvbnN0YW50cy5MSU5FX0hFSUdIVCkrInB4IjpteENvbnN0YW50cy5MSU5FX0hFSUdIVDt0aGlzLnRleHRhcmVhLnN0eWxlLmJhY2tncm91bmRDb2xvcj10aGlzLmdldEJhY2tncm91bmRDb2xvcihjKTt0aGlzLnRleHRhcmVhLnN0eWxlLnRleHREZWNvcmF0aW9uPW0uam9pbigiICIpO3RoaXMudGV4dGFyZWEuc3R5bGUuZm9udFdlaWdodD1rPyJib2xkIjoibm9ybWFsIjt0aGlzLnRleHRhcmVhLnN0eWxlLmZvbnRTdHlsZT1sPyJpdGFsaWMiOiIiO3RoaXMudGV4dGFyZWEuc3R5bGUuZm9udFNpemU9TWF0aC5yb3VuZChkKSsicHgiO3RoaXMudGV4dGFyZWEuc3R5bGUuekluZGV4PXRoaXMuekluZGV4O3RoaXMudGV4dGFyZWEuc3R5bGUuZm9udEZhbWlseT0KZTt0aGlzLnRleHRhcmVhLnN0eWxlLnRleHRBbGlnbj1nO3RoaXMudGV4dGFyZWEuc3R5bGUub3V0bGluZT0ibm9uZSI7dGhpcy50ZXh0YXJlYS5zdHlsZS5jb2xvcj1mO2Q9dGhpcy50ZXh0RGlyZWN0aW9uPW14VXRpbHMuZ2V0VmFsdWUoYy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9URVhUX0RJUkVDVElPTixteENvbnN0YW50cy5ERUZBVUxUX1RFWFRfRElSRUNUSU9OKTtkPT1teENvbnN0YW50cy5URVhUX0RJUkVDVElPTl9BVVRPJiYobnVsbD09Y3x8bnVsbD09Yy50ZXh0fHxjLnRleHQuZGlhbGVjdD09bXhDb25zdGFudHMuRElBTEVDVF9TVFJJQ1RIVE1MfHxteFV0aWxzLmlzTm9kZShjLnRleHQudmFsdWUpfHwoZD1jLnRleHQuZ2V0QXV0b0RpcmVjdGlvbigpKSk7ZD09bXhDb25zdGFudHMuVEVYVF9ESVJFQ1RJT05fTFRSfHxkPT1teENvbnN0YW50cy5URVhUX0RJUkVDVElPTl9SVEw/dGhpcy50ZXh0YXJlYS5zZXRBdHRyaWJ1dGUoImRpciIsZCk6dGhpcy50ZXh0YXJlYS5yZW1vdmVBdHRyaWJ1dGUoImRpciIpOwp0aGlzLnRleHRhcmVhLmlubmVySFRNTD10aGlzLmdldEluaXRpYWxWYWx1ZShjLGIpfHwiIjt0aGlzLmluaXRpYWxWYWx1ZT10aGlzLnRleHRhcmVhLmlubmVySFRNTDswPT10aGlzLnRleHRhcmVhLmlubmVySFRNTC5sZW5ndGh8fCI8YnI+Ij09dGhpcy50ZXh0YXJlYS5pbm5lckhUTUw/KHRoaXMudGV4dGFyZWEuaW5uZXJIVE1MPXRoaXMuZ2V0RW1wdHlMYWJlbFRleHQoKSx0aGlzLmNsZWFyT25DaGFuZ2U9ITApOnRoaXMuY2xlYXJPbkNoYW5nZT10aGlzLnRleHRhcmVhLmlubmVySFRNTD09dGhpcy5nZXRFbXB0eUxhYmVsVGV4dCgpO3RoaXMuZ3JhcGguY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMudGV4dGFyZWEpO3RoaXMuZWRpdGluZ0NlbGw9YTt0aGlzLnRyaWdnZXI9Yjt0aGlzLnRleHROb2RlPW51bGw7bnVsbCE9Yy50ZXh0JiZ0aGlzLmlzSGlkZUxhYmVsKGMpJiYodGhpcy50ZXh0Tm9kZT1jLnRleHQubm9kZSx0aGlzLnRleHROb2RlLnN0eWxlLnZpc2liaWxpdHk9ImhpZGRlbiIpOwp0aGlzLmF1dG9TaXplJiYodGhpcy5ncmFwaC5tb2RlbC5pc0VkZ2UoYy5jZWxsKXx8ImZpbGwiIT1jLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX09WRVJGTE9XXSkmJndpbmRvdy5zZXRUaW1lb3V0KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5yZXNpemUoKX0pLDApO3RoaXMucmVzaXplKCk7dHJ5e3RoaXMudGV4dGFyZWEuZm9jdXMoKSx0aGlzLmlzU2VsZWN0VGV4dCgpJiYwPHRoaXMudGV4dGFyZWEuaW5uZXJIVE1MLmxlbmd0aCYmKHRoaXMudGV4dGFyZWEuaW5uZXJIVE1MIT10aGlzLmdldEVtcHR5TGFiZWxUZXh0KCl8fCF0aGlzLmNsZWFyT25DaGFuZ2UpJiZkb2N1bWVudC5leGVjQ29tbWFuZCgic2VsZWN0QWxsIiwhMSxudWxsKX1jYXRjaChuKXt9fX07bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5pc1NlbGVjdFRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWxlY3RUZXh0fTsKbXhDZWxsRWRpdG9yLnByb3RvdHlwZS5jbGVhclNlbGVjdGlvbj1mdW5jdGlvbigpe3ZhciBhPW51bGw7d2luZG93LmdldFNlbGVjdGlvbj9hPXdpbmRvdy5nZXRTZWxlY3Rpb24oKTpkb2N1bWVudC5zZWxlY3Rpb24mJihhPWRvY3VtZW50LnNlbGVjdGlvbik7bnVsbCE9YSYmKGEuZW1wdHk/YS5lbXB0eSgpOmEucmVtb3ZlQWxsUmFuZ2VzJiZhLnJlbW92ZUFsbFJhbmdlcygpKX07Cm14Q2VsbEVkaXRvci5wcm90b3R5cGUuc3RvcEVkaXRpbmc9ZnVuY3Rpb24oYSl7aWYobnVsbCE9dGhpcy5lZGl0aW5nQ2VsbCl7bnVsbCE9dGhpcy50ZXh0Tm9kZSYmKHRoaXMudGV4dE5vZGUuc3R5bGUudmlzaWJpbGl0eT0idmlzaWJsZSIsdGhpcy50ZXh0Tm9kZT1udWxsKTthPWE/bnVsbDp0aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUodGhpcy5lZGl0aW5nQ2VsbCk7dmFyIGI9dGhpcy5pbml0aWFsVmFsdWU7dGhpcy5ib3VuZHM9dGhpcy50cmlnZ2VyPXRoaXMuZWRpdGluZ0NlbGw9dGhpcy5pbml0aWFsVmFsdWU9bnVsbDt0aGlzLnRleHRhcmVhLmJsdXIoKTt0aGlzLmNsZWFyU2VsZWN0aW9uKCk7bnVsbCE9dGhpcy50ZXh0YXJlYS5wYXJlbnROb2RlJiZ0aGlzLnRleHRhcmVhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy50ZXh0YXJlYSk7dGhpcy5jbGVhck9uQ2hhbmdlJiZ0aGlzLnRleHRhcmVhLmlubmVySFRNTD09dGhpcy5nZXRFbXB0eUxhYmVsVGV4dCgpJiYodGhpcy50ZXh0YXJlYS5pbm5lckhUTUw9CiIiLHRoaXMuY2xlYXJPbkNoYW5nZT0hMSk7aWYobnVsbCE9YSYmKHRoaXMudGV4dGFyZWEuaW5uZXJIVE1MIT1ifHxudWxsIT10aGlzLmFsaWduKSl7dGhpcy5wcmVwYXJlVGV4dGFyZWEoKTtiPXRoaXMuZ2V0Q3VycmVudFZhbHVlKGEpO3RoaXMuZ3JhcGguZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtudWxsIT1iJiZ0aGlzLmFwcGx5VmFsdWUoYSxiKSxudWxsIT10aGlzLmFsaWduJiZ0aGlzLmdyYXBoLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfQUxJR04sdGhpcy5hbGlnbixbYS5jZWxsXSl9ZmluYWxseXt0aGlzLmdyYXBoLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9fW14RXZlbnQucmVsZWFzZSh0aGlzLnRleHRhcmVhKTt0aGlzLmFsaWduPXRoaXMudGV4dGFyZWE9bnVsbH19OwpteENlbGxFZGl0b3IucHJvdG90eXBlLnByZXBhcmVUZXh0YXJlYT1mdW5jdGlvbigpe251bGwhPXRoaXMudGV4dGFyZWEubGFzdENoaWxkJiYiQlIiPT10aGlzLnRleHRhcmVhLmxhc3RDaGlsZC5ub2RlTmFtZSYmdGhpcy50ZXh0YXJlYS5yZW1vdmVDaGlsZCh0aGlzLnRleHRhcmVhLmxhc3RDaGlsZCl9O214Q2VsbEVkaXRvci5wcm90b3R5cGUuaXNIaWRlTGFiZWw9ZnVuY3Rpb24oYSl7cmV0dXJuITB9O214Q2VsbEVkaXRvci5wcm90b3R5cGUuZ2V0TWluaW11bVNpemU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5ncmFwaC5nZXRWaWV3KCkuc2NhbGU7cmV0dXJuIG5ldyBteFJlY3RhbmdsZSgwLDAsbnVsbD09YS50ZXh0PzMwOmEudGV4dC5zaXplKmIrMjAsImxlZnQiPT10aGlzLnRleHRhcmVhLnN0eWxlLnRleHRBbGlnbj8xMjA6NDApfTsKbXhDZWxsRWRpdG9yLnByb3RvdHlwZS5nZXRFZGl0b3JCb3VuZHM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmlzRWRnZShhLmNlbGwpLGM9dGhpcy5ncmFwaC5nZXRWaWV3KCkuc2NhbGUsZD10aGlzLmdldE1pbmltdW1TaXplKGEpLGU9ZC53aWR0aCxkPWQuaGVpZ2h0O2lmKCFiJiZhLnZpZXcuZ3JhcGguY2VsbFJlbmRlcmVyLmxlZ2FjeVNwYWNpbmcmJiJmaWxsIj09YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9PVkVSRkxPV10pYz1hLnNoYXBlLmdldExhYmVsQm91bmRzKG14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUoYSkpO2Vsc2V7dmFyIGY9cGFyc2VJbnQoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HXXx8MCkqYyxnPShwYXJzZUludChhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkdfVE9QXXx8MCkrbXhUZXh0LnByb3RvdHlwZS5iYXNlU3BhY2luZ1RvcCkqYytmLGs9KHBhcnNlSW50KGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lOR19SSUdIVF18fAowKStteFRleHQucHJvdG90eXBlLmJhc2VTcGFjaW5nUmlnaHQpKmMrZixsPShwYXJzZUludChhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkdfQk9UVE9NXXx8MCkrbXhUZXh0LnByb3RvdHlwZS5iYXNlU3BhY2luZ0JvdHRvbSkqYytmLGY9KHBhcnNlSW50KGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lOR19MRUZUXXx8MCkrbXhUZXh0LnByb3RvdHlwZS5iYXNlU3BhY2luZ0xlZnQpKmMrZixjPW5ldyBteFJlY3RhbmdsZShhLngsYS55LE1hdGgubWF4KGUsYS53aWR0aC1mLWspLE1hdGgubWF4KGQsYS5oZWlnaHQtZy1sKSksaz1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfTEFCRUxfUE9TSVRJT04sbXhDb25zdGFudHMuQUxJR05fQ0VOVEVSKSxsPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9WRVJUSUNBTF9MQUJFTF9QT1NJVElPTixteENvbnN0YW50cy5BTElHTl9NSURETEUpLGM9bnVsbCE9YS5zaGFwZSYmCms9PW14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUiYmbD09bXhDb25zdGFudHMuQUxJR05fTUlERExFP2Euc2hhcGUuZ2V0TGFiZWxCb3VuZHMoYyk6YztiPyhjLng9YS5hYnNvbHV0ZU9mZnNldC54LGMueT1hLmFic29sdXRlT2Zmc2V0LnksbnVsbCE9YS50ZXh0JiZudWxsIT1hLnRleHQuYm91bmRpbmdCb3gmJigwPGEudGV4dC5ib3VuZGluZ0JveC54JiYoYy54PWEudGV4dC5ib3VuZGluZ0JveC54KSwwPGEudGV4dC5ib3VuZGluZ0JveC55JiYoYy55PWEudGV4dC5ib3VuZGluZ0JveC55KSkpOm51bGwhPWEudGV4dCYmbnVsbCE9YS50ZXh0LmJvdW5kaW5nQm94JiYoYy54PU1hdGgubWluKGMueCxhLnRleHQuYm91bmRpbmdCb3gueCksYy55PU1hdGgubWluKGMueSxhLnRleHQuYm91bmRpbmdCb3gueSkpO2MueCs9ZjtjLnkrPWc7bnVsbCE9YS50ZXh0JiZudWxsIT1hLnRleHQuYm91bmRpbmdCb3gmJihiPyhjLndpZHRoPU1hdGgubWF4KGUsYS50ZXh0LmJvdW5kaW5nQm94LndpZHRoKSwKYy5oZWlnaHQ9TWF0aC5tYXgoZCxhLnRleHQuYm91bmRpbmdCb3guaGVpZ2h0KSk6KGMud2lkdGg9TWF0aC5tYXgoYy53aWR0aCxhLnRleHQuYm91bmRpbmdCb3gud2lkdGgpLGMuaGVpZ2h0PU1hdGgubWF4KGMuaGVpZ2h0LGEudGV4dC5ib3VuZGluZ0JveC5oZWlnaHQpKSk7dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmlzVmVydGV4KGEuY2VsbCkmJihiPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9MQUJFTF9QT1NJVElPTixteENvbnN0YW50cy5BTElHTl9DRU5URVIpLGI9PW14Q29uc3RhbnRzLkFMSUdOX0xFRlQ/Yy54LT1hLndpZHRoOmI9PW14Q29uc3RhbnRzLkFMSUdOX1JJR0hUJiYoYy54Kz1hLndpZHRoKSxiPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9WRVJUSUNBTF9MQUJFTF9QT1NJVElPTixteENvbnN0YW50cy5BTElHTl9NSURETEUpLGI9PW14Q29uc3RhbnRzLkFMSUdOX1RPUD9jLnktPWEuaGVpZ2h0OmI9PQpteENvbnN0YW50cy5BTElHTl9CT1RUT00mJihjLnkrPWEuaGVpZ2h0KSl9cmV0dXJuIG5ldyBteFJlY3RhbmdsZShNYXRoLnJvdW5kKGMueCksTWF0aC5yb3VuZChjLnkpLE1hdGgucm91bmQoYy53aWR0aCksTWF0aC5yb3VuZChjLmhlaWdodCkpfTtteENlbGxFZGl0b3IucHJvdG90eXBlLmdldEVtcHR5TGFiZWxUZXh0PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmVtcHR5TGFiZWxUZXh0fTtteENlbGxFZGl0b3IucHJvdG90eXBlLmdldEVkaXRpbmdDZWxsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRpdGluZ0NlbGx9OwpteENlbGxFZGl0b3IucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXtudWxsIT10aGlzLnRleHRhcmVhJiYobXhFdmVudC5yZWxlYXNlKHRoaXMudGV4dGFyZWEpLG51bGwhPXRoaXMudGV4dGFyZWEucGFyZW50Tm9kZSYmdGhpcy50ZXh0YXJlYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMudGV4dGFyZWEpLHRoaXMudGV4dGFyZWE9bnVsbCk7bnVsbCE9dGhpcy5jaGFuZ2VIYW5kbGVyJiYodGhpcy5ncmFwaC5nZXRNb2RlbCgpLnJlbW92ZUxpc3RlbmVyKHRoaXMuY2hhbmdlSGFuZGxlciksdGhpcy5jaGFuZ2VIYW5kbGVyPW51bGwpO3RoaXMuem9vbUhhbmRsZXImJih0aGlzLmdyYXBoLnZpZXcucmVtb3ZlTGlzdGVuZXIodGhpcy56b29tSGFuZGxlciksdGhpcy56b29tSGFuZGxlcj1udWxsKX07ZnVuY3Rpb24gbXhDZWxsUmVuZGVyZXIoKXt9bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcz17fTsKbXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmRlZmF1bHRFZGdlU2hhcGU9bXhDb25uZWN0b3I7bXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmRlZmF1bHRWZXJ0ZXhTaGFwZT1teFJlY3RhbmdsZVNoYXBlO214Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5kZWZhdWx0VGV4dFNoYXBlPW14VGV4dDtteENlbGxSZW5kZXJlci5wcm90b3R5cGUubGVnYWN5Q29udHJvbFBvc2l0aW9uPSEwO214Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5sZWdhY3lTcGFjaW5nPSEwO214Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5hbnRpQWxpYXM9ITA7bXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLm1pblN2Z1N0cm9rZVdpZHRoPTE7bXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmZvcmNlQ29udHJvbENsaWNrSGFuZGxlcj0hMTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlPWZ1bmN0aW9uKGEsYil7bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlc1thXT1ifTsKbXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZShteENvbnN0YW50cy5TSEFQRV9SRUNUQU5HTEUsbXhSZWN0YW5nbGVTaGFwZSk7bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZShteENvbnN0YW50cy5TSEFQRV9FTExJUFNFLG14RWxsaXBzZSk7bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZShteENvbnN0YW50cy5TSEFQRV9SSE9NQlVTLG14UmhvbWJ1cyk7bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZShteENvbnN0YW50cy5TSEFQRV9DWUxJTkRFUixteEN5bGluZGVyKTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKG14Q29uc3RhbnRzLlNIQVBFX0NPTk5FQ1RPUixteENvbm5lY3Rvcik7bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZShteENvbnN0YW50cy5TSEFQRV9BQ1RPUixteEFjdG9yKTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKG14Q29uc3RhbnRzLlNIQVBFX1RSSUFOR0xFLG14VHJpYW5nbGUpOwpteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKG14Q29uc3RhbnRzLlNIQVBFX0hFWEFHT04sbXhIZXhhZ29uKTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKG14Q29uc3RhbnRzLlNIQVBFX0NMT1VELG14Q2xvdWQpO214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUobXhDb25zdGFudHMuU0hBUEVfTElORSxteExpbmUpO214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUobXhDb25zdGFudHMuU0hBUEVfQVJST1csbXhBcnJvdyk7bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZShteENvbnN0YW50cy5TSEFQRV9BUlJPV19DT05ORUNUT1IsbXhBcnJvd0Nvbm5lY3Rvcik7bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZShteENvbnN0YW50cy5TSEFQRV9ET1VCTEVfRUxMSVBTRSxteERvdWJsZUVsbGlwc2UpO214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUobXhDb25zdGFudHMuU0hBUEVfU1dJTUxBTkUsbXhTd2ltbGFuZSk7Cm14Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUobXhDb25zdGFudHMuU0hBUEVfSU1BR0UsbXhJbWFnZVNoYXBlKTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKG14Q29uc3RhbnRzLlNIQVBFX0xBQkVMLG14TGFiZWwpO214Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5pbml0aWFsaXplU2hhcGU9ZnVuY3Rpb24oYSl7YS5zaGFwZS5kaWFsZWN0PWEudmlldy5ncmFwaC5kaWFsZWN0O3RoaXMuY29uZmlndXJlU2hhcGUoYSk7YS5zaGFwZS5pbml0KGEudmlldy5nZXREcmF3UGFuZSgpKX07bXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVNoYXBlPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7bnVsbCE9YS5zdHlsZSYmKGI9bXhTdGVuY2lsUmVnaXN0cnkuZ2V0U3RlbmNpbChhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NIQVBFXSksYj1udWxsIT1iP25ldyBteFNoYXBlKGIpOm5ldyAodGhpcy5nZXRTaGFwZUNvbnN0cnVjdG9yKGEpKSk7cmV0dXJuIGJ9OwpteENlbGxSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlSW5kaWNhdG9yU2hhcGU9ZnVuY3Rpb24oYSl7YS5zaGFwZS5pbmRpY2F0b3JTaGFwZT10aGlzLmdldFNoYXBlKGEudmlldy5ncmFwaC5nZXRJbmRpY2F0b3JTaGFwZShhKSl9O214Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTaGFwZT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YT9teENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzW2FdOm51bGx9O214Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTaGFwZUNvbnN0cnVjdG9yPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ2V0U2hhcGUoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TSEFQRV0pO251bGw9PWImJihiPWEudmlldy5ncmFwaC5nZXRNb2RlbCgpLmlzRWRnZShhLmNlbGwpP3RoaXMuZGVmYXVsdEVkZ2VTaGFwZTp0aGlzLmRlZmF1bHRWZXJ0ZXhTaGFwZSk7cmV0dXJuIGJ9OwpteENlbGxSZW5kZXJlci5wcm90b3R5cGUuY29uZmlndXJlU2hhcGU9ZnVuY3Rpb24oYSl7YS5zaGFwZS5hcHBseShhKTthLnNoYXBlLmltYWdlPWEudmlldy5ncmFwaC5nZXRJbWFnZShhKTthLnNoYXBlLmluZGljYXRvckNvbG9yPWEudmlldy5ncmFwaC5nZXRJbmRpY2F0b3JDb2xvcihhKTthLnNoYXBlLmluZGljYXRvclN0cm9rZUNvbG9yPWEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfSU5ESUNBVE9SX1NUUk9LRUNPTE9SXTthLnNoYXBlLmluZGljYXRvckdyYWRpZW50Q29sb3I9YS52aWV3LmdyYXBoLmdldEluZGljYXRvckdyYWRpZW50Q29sb3IoYSk7YS5zaGFwZS5pbmRpY2F0b3JEaXJlY3Rpb249YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9JTkRJQ0FUT1JfRElSRUNUSU9OXTthLnNoYXBlLmluZGljYXRvckltYWdlPWEudmlldy5ncmFwaC5nZXRJbmRpY2F0b3JJbWFnZShhKTt0aGlzLnBvc3RDb25maWd1cmVTaGFwZShhKX07Cm14Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5wb3N0Q29uZmlndXJlU2hhcGU9ZnVuY3Rpb24oYSl7bnVsbCE9YS5zaGFwZSYmKHRoaXMucmVzb2x2ZUNvbG9yKGEsImluZGljYXRvckdyYWRpZW50Q29sb3IiLG14Q29uc3RhbnRzLlNUWUxFX0dSQURJRU5UQ09MT1IpLHRoaXMucmVzb2x2ZUNvbG9yKGEsImluZGljYXRvckNvbG9yIixteENvbnN0YW50cy5TVFlMRV9GSUxMQ09MT1IpLHRoaXMucmVzb2x2ZUNvbG9yKGEsImdyYWRpZW50IixteENvbnN0YW50cy5TVFlMRV9HUkFESUVOVENPTE9SKSx0aGlzLnJlc29sdmVDb2xvcihhLCJzdHJva2UiLG14Q29uc3RhbnRzLlNUWUxFX1NUUk9LRUNPTE9SKSx0aGlzLnJlc29sdmVDb2xvcihhLCJmaWxsIixteENvbnN0YW50cy5TVFlMRV9GSUxMQ09MT1IpKX07Cm14Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5jaGVja1BsYWNlaG9sZGVyU3R5bGVzPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEuc3R5bGUpZm9yKHZhciBiPVsiaW5oZXJpdCIsInN3aW1sYW5lIiwiaW5kaWNhdGVkIl0sYz1bbXhDb25zdGFudHMuU1RZTEVfRklMTENPTE9SLG14Q29uc3RhbnRzLlNUWUxFX1NUUk9LRUNPTE9SLG14Q29uc3RhbnRzLlNUWUxFX0dSQURJRU5UQ09MT1IsbXhDb25zdGFudHMuU1RZTEVfRk9OVENPTE9SXSxkPTA7ZDxjLmxlbmd0aDtkKyspaWYoMDw9bXhVdGlscy5pbmRleE9mKGIsYS5zdHlsZVtjW2RdXSkpcmV0dXJuITA7cmV0dXJuITF9OwpteENlbGxSZW5kZXJlci5wcm90b3R5cGUucmVzb2x2ZUNvbG9yPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1jPT1teENvbnN0YW50cy5TVFlMRV9GT05UQ09MT1I/YS50ZXh0OmEuc2hhcGU7aWYobnVsbCE9ZCl7dmFyIGU9YS52aWV3LmdyYXBoLGY9ZFtiXSxnPW51bGw7ImluaGVyaXQiPT1mP2c9ZS5tb2RlbC5nZXRQYXJlbnQoYS5jZWxsKToic3dpbWxhbmUiPT1mPyhkW2JdPWM9PW14Q29uc3RhbnRzLlNUWUxFX1NUUk9LRUNPTE9SfHxjPT1teENvbnN0YW50cy5TVFlMRV9GT05UQ09MT1I/IiMwMDAwMDAiOiIjZmZmZmZmIixnPW51bGwhPWUubW9kZWwuZ2V0VGVybWluYWwoYS5jZWxsLCExKT9lLm1vZGVsLmdldFRlcm1pbmFsKGEuY2VsbCwhMSk6YS5jZWxsLGc9ZS5nZXRTd2ltbGFuZShnKSxjPWUuc3dpbWxhbmVJbmRpY2F0b3JDb2xvckF0dHJpYnV0ZSk6ImluZGljYXRlZCI9PWYmJm51bGwhPWEuc2hhcGUmJihkW2JdPWEuc2hhcGUuaW5kaWNhdG9yQ29sb3IpO251bGwhPWcmJihhPQplLmdldFZpZXcoKS5nZXRTdGF0ZShnKSxkW2JdPW51bGwsbnVsbCE9YSYmKGU9Yz09bXhDb25zdGFudHMuU1RZTEVfRk9OVENPTE9SP2EudGV4dDphLnNoYXBlLGRbYl09bnVsbCE9ZSYmImluZGljYXRvckNvbG9yIiE9Yj9lW2JdOmEuc3R5bGVbY10pKX19O214Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRMYWJlbFZhbHVlPWZ1bmN0aW9uKGEpe3JldHVybiBhLnZpZXcuZ3JhcGguZ2V0TGFiZWwoYS5jZWxsKX07Cm14Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVMYWJlbD1mdW5jdGlvbihhLGIpe3ZhciBjPWEudmlldy5ncmFwaDtjLmdldE1vZGVsKCkuaXNFZGdlKGEuY2VsbCk7aWYoMDxhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0ZPTlRTSVpFXXx8bnVsbD09YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9GT05UU0laRV0pe3ZhciBkPWMuaXNIdG1sTGFiZWwoYS5jZWxsKXx8bnVsbCE9YiYmbXhVdGlscy5pc05vZGUoYik7YS50ZXh0PW5ldyB0aGlzLmRlZmF1bHRUZXh0U2hhcGUoYixuZXcgbXhSZWN0YW5nbGUsYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9BTElHTl18fG14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUixjLmdldFZlcnRpY2FsQWxpZ24oYSksYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9GT05UQ09MT1JdLGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRk9OVEZBTUlMWV0sYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9GT05UU0laRV0sYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9GT05UU1RZTEVdLAphLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkddLGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lOR19UT1BdLGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lOR19SSUdIVF0sYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HX0JPVFRPTV0sYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HX0xFRlRdLGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfSE9SSVpPTlRBTF0sYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9MQUJFTF9CQUNLR1JPVU5EQ09MT1JdLGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfTEFCRUxfQk9SREVSQ09MT1JdLGMuaXNXcmFwcGluZyhhLmNlbGwpJiZjLmlzSHRtbExhYmVsKGEuY2VsbCksYy5pc0xhYmVsQ2xpcHBlZChhLmNlbGwpLGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfT1ZFUkZMT1ddLGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfTEFCRUxfUEFERElOR10sbXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1RFWFRfRElSRUNUSU9OLApteENvbnN0YW50cy5ERUZBVUxUX1RFWFRfRElSRUNUSU9OKSk7YS50ZXh0Lm9wYWNpdHk9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1RFWFRfT1BBQ0lUWSwxMDApO2EudGV4dC5kaWFsZWN0PWQ/bXhDb25zdGFudHMuRElBTEVDVF9TVFJJQ1RIVE1MOmEudmlldy5ncmFwaC5kaWFsZWN0O2EudGV4dC5zdHlsZT1hLnN0eWxlO2EudGV4dC5zdGF0ZT1hO3RoaXMuaW5pdGlhbGl6ZUxhYmVsKGEsYS50ZXh0KTt2YXIgZT0hMSxmPWZ1bmN0aW9uKGIpe3ZhciBkPWE7aWYobXhDbGllbnQuSVNfVE9VQ0h8fGUpZD1teEV2ZW50LmdldENsaWVudFgoYiksYj1teEV2ZW50LmdldENsaWVudFkoYiksYj1teFV0aWxzLmNvbnZlcnRQb2ludChjLmNvbnRhaW5lcixkLGIpLGQ9Yy52aWV3LmdldFN0YXRlKGMuZ2V0Q2VsbEF0KGIueCxiLnkpKTtyZXR1cm4gZH07bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKGEudGV4dC5ub2RlLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3RoaXMuaXNMYWJlbEV2ZW50KGEsCmIpJiYoYy5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX0RPV04sbmV3IG14TW91c2VFdmVudChiLGEpKSxlPWMuZGlhbGVjdCE9bXhDb25zdGFudHMuRElBTEVDVF9TVkcmJiJJTUciPT1teEV2ZW50LmdldFNvdXJjZShiKS5ub2RlTmFtZSl9KSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXt0aGlzLmlzTGFiZWxFdmVudChhLGIpJiZjLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfTU9WRSxuZXcgbXhNb3VzZUV2ZW50KGIsZihiKSkpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7dGhpcy5pc0xhYmVsRXZlbnQoYSxiKSYmKGMuZmlyZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9VUCxuZXcgbXhNb3VzZUV2ZW50KGIsZihiKSkpLGU9ITEpfSkpO2MubmF0aXZlRGJsQ2xpY2tFbmFibGVkJiZteEV2ZW50LmFkZExpc3RlbmVyKGEudGV4dC5ub2RlLCJkYmxjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7dGhpcy5pc0xhYmVsRXZlbnQoYSwKYikmJihjLmRibENsaWNrKGIsYS5jZWxsKSxteEV2ZW50LmNvbnN1bWUoYikpfSkpfX07bXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmluaXRpYWxpemVMYWJlbD1mdW5jdGlvbihhLGIpe214Q2xpZW50LklTX1NWRyYmbXhDbGllbnQuTk9fRk8mJmIuZGlhbGVjdCE9bXhDb25zdGFudHMuRElBTEVDVF9TVkc/Yi5pbml0KGEudmlldy5ncmFwaC5jb250YWluZXIpOmIuaW5pdChhLnZpZXcuZ2V0RHJhd1BhbmUoKSl9OwpteENlbGxSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQ2VsbE92ZXJsYXlzPWZ1bmN0aW9uKGEpe3ZhciBiPWEudmlldy5ncmFwaC5nZXRDZWxsT3ZlcmxheXMoYS5jZWxsKSxjPW51bGw7aWYobnVsbCE9Yilmb3IodmFyIGM9bmV3IG14RGljdGlvbmFyeSxkPTA7ZDxiLmxlbmd0aDtkKyspe3ZhciBlPW51bGwhPWEub3ZlcmxheXM/YS5vdmVybGF5cy5yZW1vdmUoYltkXSk6bnVsbDtudWxsPT1lJiYoZT1uZXcgbXhJbWFnZVNoYXBlKG5ldyBteFJlY3RhbmdsZSxiW2RdLmltYWdlLnNyYyksZS5kaWFsZWN0PWEudmlldy5ncmFwaC5kaWFsZWN0LGUucHJlc2VydmVJbWFnZUFzcGVjdD0hMSxlLm92ZXJsYXk9YltkXSx0aGlzLmluaXRpYWxpemVPdmVybGF5KGEsZSksdGhpcy5pbnN0YWxsQ2VsbE92ZXJsYXlMaXN0ZW5lcnMoYSxiW2RdLGUpLG51bGwhPWJbZF0uY3Vyc29yJiYoZS5ub2RlLnN0eWxlLmN1cnNvcj1iW2RdLmN1cnNvcikpO2MucHV0KGJbZF0sZSl9bnVsbCE9YS5vdmVybGF5cyYmCmEub3ZlcmxheXMudmlzaXQoZnVuY3Rpb24oYSxiKXtiLmRlc3Ryb3koKX0pO2Eub3ZlcmxheXM9Y307bXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmluaXRpYWxpemVPdmVybGF5PWZ1bmN0aW9uKGEsYil7Yi5pbml0KGEudmlldy5nZXRPdmVybGF5UGFuZSgpKX07Cm14Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5pbnN0YWxsQ2VsbE92ZXJsYXlMaXN0ZW5lcnM9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWEudmlldy5ncmFwaDtteEV2ZW50LmFkZExpc3RlbmVyKGMubm9kZSwiY2xpY2siLGZ1bmN0aW9uKGMpe2QuaXNFZGl0aW5nKCkmJmQuc3RvcEVkaXRpbmcoIWQuaXNJbnZva2VzU3RvcENlbGxFZGl0aW5nKCkpO2IuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuQ0xJQ0ssImV2ZW50IixjLCJjZWxsIixhLmNlbGwpKX0pO214RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyhjLm5vZGUsZnVuY3Rpb24oYSl7bXhFdmVudC5jb25zdW1lKGEpfSxmdW5jdGlvbihiKXtkLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfTU9WRSxuZXcgbXhNb3VzZUV2ZW50KGIsYSkpfSk7bXhDbGllbnQuSVNfVE9VQ0gmJm14RXZlbnQuYWRkTGlzdGVuZXIoYy5ub2RlLCJ0b3VjaGVuZCIsZnVuY3Rpb24oYyl7Yi5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5DTElDSywKImV2ZW50IixjLCJjZWxsIixhLmNlbGwpKX0pfTtteENlbGxSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQ29udHJvbD1mdW5jdGlvbihhKXt2YXIgYj1hLnZpZXcuZ3JhcGgsYz1iLmdldEZvbGRpbmdJbWFnZShhKTtpZihiLmZvbGRpbmdFbmFibGVkJiZudWxsIT1jKXtpZihudWxsPT1hLmNvbnRyb2wpe3ZhciBkPW5ldyBteFJlY3RhbmdsZSgwLDAsYy53aWR0aCxjLmhlaWdodCk7YS5jb250cm9sPW5ldyBteEltYWdlU2hhcGUoZCxjLnNyYyk7YS5jb250cm9sLnByZXNlcnZlSW1hZ2VBc3BlY3Q9ITE7YS5jb250cm9sLmRpYWxlY3Q9Yi5kaWFsZWN0O3RoaXMuaW5pdENvbnRyb2woYSxhLmNvbnRyb2wsITAsdGhpcy5jcmVhdGVDb250cm9sQ2xpY2tIYW5kbGVyKGEpKX19ZWxzZSBudWxsIT1hLmNvbnRyb2wmJihhLmNvbnRyb2wuZGVzdHJveSgpLGEuY29udHJvbD1udWxsKX07Cm14Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDb250cm9sQ2xpY2tIYW5kbGVyPWZ1bmN0aW9uKGEpe3ZhciBiPWEudmlldy5ncmFwaDtyZXR1cm4gbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYyl7aWYodGhpcy5mb3JjZUNvbnRyb2xDbGlja0hhbmRsZXJ8fGIuaXNFbmFibGVkKCkpe3ZhciBkPSFiLmlzQ2VsbENvbGxhcHNlZChhLmNlbGwpO2IuZm9sZENlbGxzKGQsITEsW2EuY2VsbF0sbnVsbCxjKTtteEV2ZW50LmNvbnN1bWUoYyl9fSl9OwpteENlbGxSZW5kZXJlci5wcm90b3R5cGUuaW5pdENvbnRyb2w9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9YS52aWV3LmdyYXBoO2UuaXNIdG1sTGFiZWwoYS5jZWxsKSYmbXhDbGllbnQuTk9fRk8mJmUuZGlhbGVjdD09bXhDb25zdGFudHMuRElBTEVDVF9TVkc/KGIuZGlhbGVjdD1teENvbnN0YW50cy5ESUFMRUNUX1BSRUZFUkhUTUwsYi5pbml0KGUuY29udGFpbmVyKSxiLm5vZGUuc3R5bGUuekluZGV4PTEpOmIuaW5pdChhLnZpZXcuZ2V0T3ZlcmxheVBhbmUoKSk7Yj1iLmlubmVyTm9kZXx8Yi5ub2RlO251bGw9PWR8fG14Q2xpZW50LklTX0lPU3x8KGUuaXNFbmFibGVkKCkmJihiLnN0eWxlLmN1cnNvcj0icG9pbnRlciIpLG14RXZlbnQuYWRkTGlzdGVuZXIoYiwiY2xpY2siLGQpKTtpZihjKXt2YXIgZj1udWxsO214RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyhiLGZ1bmN0aW9uKGIpe2Y9bmV3IG14UG9pbnQobXhFdmVudC5nZXRDbGllbnRYKGIpLG14RXZlbnQuZ2V0Q2xpZW50WShiKSk7CmUuZmlyZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9ET1dOLG5ldyBteE1vdXNlRXZlbnQoYixhKSk7bXhFdmVudC5jb25zdW1lKGIpfSxmdW5jdGlvbihiKXtlLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfTU9WRSxuZXcgbXhNb3VzZUV2ZW50KGIsYSkpfSxmdW5jdGlvbihiKXtlLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfVVAsbmV3IG14TW91c2VFdmVudChiLGEpKTtteEV2ZW50LmNvbnN1bWUoYil9KTtudWxsIT1kJiZteENsaWVudC5JU19JT1MmJmIuYWRkRXZlbnRMaXN0ZW5lcigidG91Y2hlbmQiLGZ1bmN0aW9uKGEpe2lmKG51bGwhPWYpe3ZhciBiPWUudG9sZXJhbmNlO01hdGguYWJzKGYueC1teEV2ZW50LmdldENsaWVudFgoYSkpPGImJk1hdGguYWJzKGYueS1teEV2ZW50LmdldENsaWVudFkoYSkpPGImJihkLmNhbGwoZCxhKSxteEV2ZW50LmNvbnN1bWUoYSkpfX0sITApfXJldHVybiBifTsKbXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmlzU2hhcGVFdmVudD1mdW5jdGlvbihhLGIpe3JldHVybiEwfTtteENlbGxSZW5kZXJlci5wcm90b3R5cGUuaXNMYWJlbEV2ZW50PWZ1bmN0aW9uKGEsYil7cmV0dXJuITB9OwpteENlbGxSZW5kZXJlci5wcm90b3R5cGUuaW5zdGFsbExpc3RlbmVycz1mdW5jdGlvbihhKXt2YXIgYj1hLnZpZXcuZ3JhcGgsYz1mdW5jdGlvbihjKXt2YXIgZD1hO2lmKGIuZGlhbGVjdCE9bXhDb25zdGFudHMuRElBTEVDVF9TVkcmJiJJTUciPT1teEV2ZW50LmdldFNvdXJjZShjKS5ub2RlTmFtZXx8bXhDbGllbnQuSVNfVE9VQ0gpZD1teEV2ZW50LmdldENsaWVudFgoYyksYz1teEV2ZW50LmdldENsaWVudFkoYyksYz1teFV0aWxzLmNvbnZlcnRQb2ludChiLmNvbnRhaW5lcixkLGMpLGQ9Yi52aWV3LmdldFN0YXRlKGIuZ2V0Q2VsbEF0KGMueCxjLnkpKTtyZXR1cm4gZH07bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKGEuc2hhcGUubm9kZSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihjKXt0aGlzLmlzU2hhcGVFdmVudChhLGMpJiZiLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfRE9XTixuZXcgbXhNb3VzZUV2ZW50KGMsYSkpfSksbXhVdGlscy5iaW5kKHRoaXMsCmZ1bmN0aW9uKGQpe3RoaXMuaXNTaGFwZUV2ZW50KGEsZCkmJmIuZmlyZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9NT1ZFLG5ldyBteE1vdXNlRXZlbnQoZCxjKGQpKSl9KSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihkKXt0aGlzLmlzU2hhcGVFdmVudChhLGQpJiZiLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfVVAsbmV3IG14TW91c2VFdmVudChkLGMoZCkpKX0pKTtiLm5hdGl2ZURibENsaWNrRW5hYmxlZCYmbXhFdmVudC5hZGRMaXN0ZW5lcihhLnNoYXBlLm5vZGUsImRibGNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihjKXt0aGlzLmlzU2hhcGVFdmVudChhLGMpJiYoYi5kYmxDbGljayhjLGEuY2VsbCksbXhFdmVudC5jb25zdW1lKGMpKX0pKX07Cm14Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5yZWRyYXdMYWJlbD1mdW5jdGlvbihhLGIpe3ZhciBjPWEudmlldy5ncmFwaCxkPXRoaXMuZ2V0TGFiZWxWYWx1ZShhKSxlPWMuaXNXcmFwcGluZyhhLmNlbGwpLGY9Yy5pc0xhYmVsQ2xpcHBlZChhLmNlbGwpLGc9YS52aWV3LmdyYXBoLmlzSHRtbExhYmVsKGEuY2VsbCl8fG51bGwhPWQmJm14VXRpbHMuaXNOb2RlKGQpP214Q29uc3RhbnRzLkRJQUxFQ1RfU1RSSUNUSFRNTDphLnZpZXcuZ3JhcGguZGlhbGVjdCxrPWEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfT1ZFUkZMT1ddfHwidmlzaWJsZSI7bnVsbD09YS50ZXh0fHxhLnRleHQud3JhcD09ZSYmYS50ZXh0LmNsaXBwZWQ9PWYmJmEudGV4dC5vdmVyZmxvdz09ayYmYS50ZXh0LmRpYWxlY3Q9PWd8fChhLnRleHQuZGVzdHJveSgpLGEudGV4dD1udWxsKTtudWxsPT1hLnRleHQmJm51bGwhPWQmJihteFV0aWxzLmlzTm9kZShkKXx8MDxkLmxlbmd0aCk/dGhpcy5jcmVhdGVMYWJlbChhLApkKTpudWxsPT1hLnRleHR8fG51bGwhPWQmJjAhPWQubGVuZ3RofHwoYS50ZXh0LmRlc3Ryb3koKSxhLnRleHQ9bnVsbCk7aWYobnVsbCE9YS50ZXh0KXtiJiYobnVsbCE9YS50ZXh0Lmxhc3RWYWx1ZSYmdGhpcy5pc1RleHRTaGFwZUludmFsaWQoYSxhLnRleHQpJiYoYS50ZXh0Lmxhc3RWYWx1ZT1udWxsKSxhLnRleHQucmVzZXRTdHlsZXMoKSxhLnRleHQuYXBwbHkoYSksYS50ZXh0LnZhbGlnbj1jLmdldFZlcnRpY2FsQWxpZ24oYSkpO3ZhciBjPXRoaXMuZ2V0TGFiZWxCb3VuZHMoYSksbD10aGlzLmdldFRleHRTY2FsZShhKTt0aGlzLnJlc29sdmVDb2xvcihhLCJjb2xvciIsbXhDb25zdGFudHMuU1RZTEVfRk9OVENPTE9SKTtpZihifHxhLnRleHQudmFsdWUhPWR8fGEudGV4dC5pc1dyYXBwaW5nIT1lfHxhLnRleHQub3ZlcmZsb3chPWt8fGEudGV4dC5pc0NsaXBwaW5nIT1mfHxhLnRleHQuc2NhbGUhPWx8fGEudGV4dC5kaWFsZWN0IT1nfHxudWxsPT1hLnRleHQuYm91bmRzfHwKIWEudGV4dC5ib3VuZHMuZXF1YWxzKGMpKWEudGV4dC5kaWFsZWN0PWcsYS50ZXh0LnZhbHVlPWQsYS50ZXh0LmJvdW5kcz1jLGEudGV4dC5zY2FsZT1sLGEudGV4dC53cmFwPWUsYS50ZXh0LmNsaXBwZWQ9ZixhLnRleHQub3ZlcmZsb3c9ayxkPWEudGV4dC5ub2RlLnN0eWxlLnZpc2liaWxpdHksdGhpcy5yZWRyYXdMYWJlbFNoYXBlKGEudGV4dCksYS50ZXh0Lm5vZGUuc3R5bGUudmlzaWJpbGl0eT1kfX07Cm14Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5pc1RleHRTaGFwZUludmFsaWQ9ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGMsZSxmKXtyZXR1cm4ic3BhY2luZ1RvcCI9PWV8fCJzcGFjaW5nUmlnaHQiPT1lfHwic3BhY2luZ0JvdHRvbSI9PWV8fCJzcGFjaW5nTGVmdCI9PWU/cGFyc2VGbG9hdChiW2NdKS1wYXJzZUZsb2F0KGIuc3BhY2luZykhPShhLnN0eWxlW2VdfHxmKTpiW2NdIT0oYS5zdHlsZVtlXXx8Zil9cmV0dXJuIGMoImZvbnRTdHlsZSIsbXhDb25zdGFudHMuU1RZTEVfRk9OVFNUWUxFLG14Q29uc3RhbnRzLkRFRkFVTFRfRk9OVFNUWUxFKXx8YygiZmFtaWx5IixteENvbnN0YW50cy5TVFlMRV9GT05URkFNSUxZLG14Q29uc3RhbnRzLkRFRkFVTFRfRk9OVEZBTUlMWSl8fGMoInNpemUiLG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRTSVpFLG14Q29uc3RhbnRzLkRFRkFVTFRfRk9OVFNJWkUpfHxjKCJjb2xvciIsbXhDb25zdGFudHMuU1RZTEVfRk9OVENPTE9SLCJibGFjayIpfHwKYygiYWxpZ24iLG14Q29uc3RhbnRzLlNUWUxFX0FMSUdOLCIiKXx8YygidmFsaWduIixteENvbnN0YW50cy5TVFlMRV9WRVJUSUNBTF9BTElHTiwiIil8fGMoInNwYWNpbmciLG14Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkcsMil8fGMoInNwYWNpbmdUb3AiLG14Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkdfVE9QLDApfHxjKCJzcGFjaW5nUmlnaHQiLG14Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkdfUklHSFQsMCl8fGMoInNwYWNpbmdCb3R0b20iLG14Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkdfQk9UVE9NLDApfHxjKCJzcGFjaW5nTGVmdCIsbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lOR19MRUZULDApfHxjKCJob3Jpem9udGFsIixteENvbnN0YW50cy5TVFlMRV9IT1JJWk9OVEFMLCEwKXx8YygiYmFja2dyb3VuZCIsbXhDb25zdGFudHMuU1RZTEVfTEFCRUxfQkFDS0dST1VORENPTE9SKXx8YygiYm9yZGVyIixteENvbnN0YW50cy5TVFlMRV9MQUJFTF9CT1JERVJDT0xPUil8fGMoIm9wYWNpdHkiLApteENvbnN0YW50cy5TVFlMRV9URVhUX09QQUNJVFksMTAwKXx8YygidGV4dERpcmVjdGlvbiIsbXhDb25zdGFudHMuU1RZTEVfVEVYVF9ESVJFQ1RJT04sbXhDb25zdGFudHMuREVGQVVMVF9URVhUX0RJUkVDVElPTil9O214Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5yZWRyYXdMYWJlbFNoYXBlPWZ1bmN0aW9uKGEpe2EucmVkcmF3KCl9O214Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRUZXh0U2NhbGU9ZnVuY3Rpb24oYSl7cmV0dXJuIGEudmlldy5zY2FsZX07Cm14Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRMYWJlbEJvdW5kcz1mdW5jdGlvbihhKXt2YXIgYj1hLnZpZXcuZ3JhcGgsYz1hLnZpZXcuc2NhbGUsZD1iLmdldE1vZGVsKCkuaXNFZGdlKGEuY2VsbCksZT1uZXcgbXhSZWN0YW5nbGUoYS5hYnNvbHV0ZU9mZnNldC54LGEuYWJzb2x1dGVPZmZzZXQueSk7aWYoZCl7dmFyIGY9YS50ZXh0LmdldFNwYWNpbmcoKTtlLngrPWYueCpjO2UueSs9Zi55KmM7Yj1iLmdldENlbGxHZW9tZXRyeShhLmNlbGwpO251bGwhPWImJihlLndpZHRoPU1hdGgubWF4KDAsYi53aWR0aCpjKSxlLmhlaWdodD1NYXRoLm1heCgwLGIuaGVpZ2h0KmMpKX1lbHNlIGEudGV4dC5pc1BhaW50Qm91bmRzSW52ZXJ0ZWQoKSYmKGI9ZS54LGUueD1lLnksZS55PWIpLGUueCs9YS54LGUueSs9YS55LGUud2lkdGg9TWF0aC5tYXgoMSxhLndpZHRoKSxlLmhlaWdodD1NYXRoLm1heCgxLGEuaGVpZ2h0KTthLnRleHQuaXNQYWludEJvdW5kc0ludmVydGVkKCkmJihiPShhLndpZHRoLQphLmhlaWdodCkvMixlLngrPWIsZS55LT1iLGI9ZS53aWR0aCxlLndpZHRoPWUuaGVpZ2h0LGUuaGVpZ2h0PWIpO251bGwhPWEuc2hhcGUmJihiPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9MQUJFTF9QT1NJVElPTixteENvbnN0YW50cy5BTElHTl9DRU5URVIpLGY9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1ZFUlRJQ0FMX0xBQkVMX1BPU0lUSU9OLG14Q29uc3RhbnRzLkFMSUdOX01JRERMRSksYj09bXhDb25zdGFudHMuQUxJR05fQ0VOVEVSJiZmPT1teENvbnN0YW50cy5BTElHTl9NSURETEUmJihlPWEuc2hhcGUuZ2V0TGFiZWxCb3VuZHMoZSkpKTtiPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9MQUJFTF9XSURUSCxudWxsKTtudWxsIT1iJiYoZS53aWR0aD1wYXJzZUZsb2F0KGIpKmMpO2R8fHRoaXMucm90YXRlTGFiZWxCb3VuZHMoYSxlKTtyZXR1cm4gZX07Cm14Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5yb3RhdGVMYWJlbEJvdW5kcz1mdW5jdGlvbihhLGIpe2IueS09YS50ZXh0Lm1hcmdpbi55KmIuaGVpZ2h0O2IueC09YS50ZXh0Lm1hcmdpbi54KmIud2lkdGg7aWYoIXRoaXMubGVnYWN5U3BhY2luZ3x8ImZpbGwiIT1hLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX09WRVJGTE9XXSYmIndpZHRoIiE9YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9PVkVSRkxPV10pe3ZhciBjPWEudmlldy5zY2FsZSxkPWEudGV4dC5nZXRTcGFjaW5nKCk7Yi54Kz1kLngqYztiLnkrPWQueSpjO3ZhciBkPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9MQUJFTF9QT1NJVElPTixteENvbnN0YW50cy5BTElHTl9DRU5URVIpLGU9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1ZFUlRJQ0FMX0xBQkVMX1BPU0lUSU9OLG14Q29uc3RhbnRzLkFMSUdOX01JRERMRSksZj1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsCm14Q29uc3RhbnRzLlNUWUxFX0xBQkVMX1dJRFRILG51bGwpO2Iud2lkdGg9TWF0aC5tYXgoMCxiLndpZHRoLShkPT1teENvbnN0YW50cy5BTElHTl9DRU5URVImJm51bGw9PWY/YS50ZXh0LnNwYWNpbmdMZWZ0KmMrYS50ZXh0LnNwYWNpbmdSaWdodCpjOjApKTtiLmhlaWdodD1NYXRoLm1heCgwLGIuaGVpZ2h0LShlPT1teENvbnN0YW50cy5BTElHTl9NSURETEU/YS50ZXh0LnNwYWNpbmdUb3AqYythLnRleHQuc3BhY2luZ0JvdHRvbSpjOjApKX1lPWEudGV4dC5nZXRUZXh0Um90YXRpb24oKTswIT1lJiZudWxsIT1hJiZhLnZpZXcuZ3JhcGgubW9kZWwuaXNWZXJ0ZXgoYS5jZWxsKSYmKGM9YS5nZXRDZW50ZXJYKCksZD1hLmdldENlbnRlclkoKSxiLnghPWN8fGIueSE9ZCkmJihlKj1NYXRoLlBJLzE4MCxjPW14VXRpbHMuZ2V0Um90YXRlZFBvaW50KG5ldyBteFBvaW50KGIueCxiLnkpLE1hdGguY29zKGUpLE1hdGguc2luKGUpLG5ldyBteFBvaW50KGMsZCkpLGIueD1jLngsYi55PQpjLnkpfTsKbXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLnJlZHJhd0NlbGxPdmVybGF5cz1mdW5jdGlvbihhLGIpe3RoaXMuY3JlYXRlQ2VsbE92ZXJsYXlzKGEpO2lmKG51bGwhPWEub3ZlcmxheXMpe3ZhciBjPW14VXRpbHMubW9kKG14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTiwwKSw5MCksZD1teFV0aWxzLnRvUmFkaWFucyhjKSxlPU1hdGguY29zKGQpLGY9TWF0aC5zaW4oZCk7YS5vdmVybGF5cy52aXNpdChmdW5jdGlvbihkLGspe3ZhciBnPWsub3ZlcmxheS5nZXRCb3VuZHMoYSk7aWYoIWEudmlldy5ncmFwaC5nZXRNb2RlbCgpLmlzRWRnZShhLmNlbGwpJiZudWxsIT1hLnNoYXBlJiYwIT1jKXt2YXIgbT1nLmdldENlbnRlclgoKSxuPWcuZ2V0Q2VudGVyWSgpLG49bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQobmV3IG14UG9pbnQobSxuKSxlLGYsbmV3IG14UG9pbnQoYS5nZXRDZW50ZXJYKCksYS5nZXRDZW50ZXJZKCkpKSxtPW4ueCxuPW4ueTtnLng9Ck1hdGgucm91bmQobS1nLndpZHRoLzIpO2cueT1NYXRoLnJvdW5kKG4tZy5oZWlnaHQvMil9aWYoYnx8bnVsbD09ay5ib3VuZHN8fGsuc2NhbGUhPWEudmlldy5zY2FsZXx8IWsuYm91bmRzLmVxdWFscyhnKSlrLmJvdW5kcz1nLGsuc2NhbGU9YS52aWV3LnNjYWxlLGsucmVkcmF3KCl9KX19OwpteENlbGxSZW5kZXJlci5wcm90b3R5cGUucmVkcmF3Q29udHJvbD1mdW5jdGlvbihhLGIpe3ZhciBjPWEudmlldy5ncmFwaC5nZXRGb2xkaW5nSW1hZ2UoYSk7aWYobnVsbCE9YS5jb250cm9sJiZudWxsIT1jKXt2YXIgYz10aGlzLmdldENvbnRyb2xCb3VuZHMoYSxjLndpZHRoLGMuaGVpZ2h0KSxkPXRoaXMubGVnYWN5Q29udHJvbFBvc2l0aW9uP214VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTiwwKTphLnNoYXBlLmdldFRleHRSb3RhdGlvbigpLGU9YS52aWV3LnNjYWxlO2lmKGJ8fGEuY29udHJvbC5zY2FsZSE9ZXx8IWEuY29udHJvbC5ib3VuZHMuZXF1YWxzKGMpfHxhLmNvbnRyb2wucm90YXRpb24hPWQpYS5jb250cm9sLnJvdGF0aW9uPWQsYS5jb250cm9sLmJvdW5kcz1jLGEuY29udHJvbC5zY2FsZT1lLGEuY29udHJvbC5yZWRyYXcoKX19OwpteENlbGxSZW5kZXJlci5wcm90b3R5cGUuZ2V0Q29udHJvbEJvdW5kcz1mdW5jdGlvbihhLGIsYyl7aWYobnVsbCE9YS5jb250cm9sKXt2YXIgZD1hLnZpZXcuc2NhbGUsZT1hLmdldENlbnRlclgoKSxmPWEuZ2V0Q2VudGVyWSgpO2lmKCFhLnZpZXcuZ3JhcGguZ2V0TW9kZWwoKS5pc0VkZ2UoYS5jZWxsKSYmKGU9YS54K2IqZCxmPWEueStjKmQsbnVsbCE9YS5zaGFwZSkpe3ZhciBnPWEuc2hhcGUuZ2V0U2hhcGVSb3RhdGlvbigpO2lmKHRoaXMubGVnYWN5Q29udHJvbFBvc2l0aW9uKWc9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OLDApO2Vsc2UgaWYoYS5zaGFwZS5pc1BhaW50Qm91bmRzSW52ZXJ0ZWQoKSl2YXIgaz0oYS53aWR0aC1hLmhlaWdodCkvMixlPWUrayxmPWYtazswIT1nJiYoaz1teFV0aWxzLnRvUmFkaWFucyhnKSxnPU1hdGguY29zKGspLGs9TWF0aC5zaW4oayksZj1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChuZXcgbXhQb2ludChlLApmKSxnLGssbmV3IG14UG9pbnQoYS5nZXRDZW50ZXJYKCksYS5nZXRDZW50ZXJZKCkpKSxlPWYueCxmPWYueSl9cmV0dXJuIGEudmlldy5ncmFwaC5nZXRNb2RlbCgpLmlzRWRnZShhLmNlbGwpLG5ldyBteFJlY3RhbmdsZShNYXRoLnJvdW5kKGUtYi8yKmQpLE1hdGgucm91bmQoZi1jLzIqZCksTWF0aC5yb3VuZChiKmQpLE1hdGgucm91bmQoYypkKSl9cmV0dXJuIG51bGx9OwpteENlbGxSZW5kZXJlci5wcm90b3R5cGUuaW5zZXJ0U3RhdGVBZnRlcj1mdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPXRoaXMuZ2V0U2hhcGVzRm9yU3RhdGUoYSksZT0wO2U8ZC5sZW5ndGg7ZSsrKWlmKG51bGwhPWRbZV0mJm51bGwhPWRbZV0ubm9kZSl7dmFyIGY9ZFtlXS5ub2RlLnBhcmVudE5vZGUhPWEudmlldy5nZXREcmF3UGFuZSgpJiZkW2VdLm5vZGUucGFyZW50Tm9kZSE9YS52aWV3LmdldE92ZXJsYXlQYW5lKCksZz1mP2M6YjtpZihudWxsIT1nJiZnLm5leHRTaWJsaW5nIT1kW2VdLm5vZGUpbnVsbD09Zy5uZXh0U2libGluZz9nLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZFtlXS5ub2RlKTpnLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGRbZV0ubm9kZSxnLm5leHRTaWJsaW5nKTtlbHNlIGlmKG51bGw9PWcpaWYoZFtlXS5ub2RlLnBhcmVudE5vZGU9PWEudmlldy5ncmFwaC5jb250YWluZXIpe2ZvcihnPWEudmlldy5jYW52YXM7bnVsbCE9ZyYmZy5wYXJlbnROb2RlIT0KYS52aWV3LmdyYXBoLmNvbnRhaW5lcjspZz1nLnBhcmVudE5vZGU7bnVsbCE9ZyYmbnVsbCE9Zy5uZXh0U2libGluZz9nLm5leHRTaWJsaW5nIT1kW2VdLm5vZGUmJmRbZV0ubm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkW2VdLm5vZGUsZy5uZXh0U2libGluZyk6ZFtlXS5ub2RlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZFtlXS5ub2RlKX1lbHNlIG51bGwhPWRbZV0ubm9kZS5wYXJlbnROb2RlJiZudWxsIT1kW2VdLm5vZGUucGFyZW50Tm9kZS5maXJzdENoaWxkJiZkW2VdLm5vZGUucGFyZW50Tm9kZS5maXJzdENoaWxkIT1kW2VdLm5vZGUmJmRbZV0ubm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkW2VdLm5vZGUsZFtlXS5ub2RlLnBhcmVudE5vZGUuZmlyc3RDaGlsZCk7Zj9jPWRbZV0ubm9kZTpiPWRbZV0ubm9kZX1yZXR1cm5bYixjXX07Cm14Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTaGFwZXNGb3JTdGF0ZT1mdW5jdGlvbihhKXtyZXR1cm5bYS5zaGFwZSxhLnRleHQsYS5jb250cm9sXX07bXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLnJlZHJhdz1mdW5jdGlvbihhLGIsYyl7Yj10aGlzLnJlZHJhd1NoYXBlKGEsYixjKTtudWxsPT1hLnNoYXBlfHxudWxsIT1jJiYhY3x8KHRoaXMucmVkcmF3TGFiZWwoYSxiKSx0aGlzLnJlZHJhd0NlbGxPdmVybGF5cyhhLGIpLHRoaXMucmVkcmF3Q29udHJvbChhLGIpKX07Cm14Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5yZWRyYXdTaGFwZT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YS52aWV3LmdyYXBoLm1vZGVsLGU9ITE7bnVsbCE9YS5zaGFwZSYmbnVsbCE9YS5zaGFwZS5zdHlsZSYmbnVsbCE9YS5zdHlsZSYmYS5zaGFwZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TSEFQRV0hPWEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU0hBUEVdJiYoYS5zaGFwZS5kZXN0cm95KCksYS5zaGFwZT1udWxsKTtudWxsPT1hLnNoYXBlJiZudWxsIT1hLnZpZXcuZ3JhcGguY29udGFpbmVyJiZhLmNlbGwhPWEudmlldy5jdXJyZW50Um9vdCYmKGQuaXNWZXJ0ZXgoYS5jZWxsKXx8ZC5pc0VkZ2UoYS5jZWxsKSk/KGEuc2hhcGU9dGhpcy5jcmVhdGVTaGFwZShhKSxudWxsIT1hLnNoYXBlJiYoYS5zaGFwZS5taW5TdmdTdHJva2VXaWR0aD10aGlzLm1pblN2Z1N0cm9rZVdpZHRoLGEuc2hhcGUuYW50aUFsaWFzPXRoaXMuYW50aUFsaWFzLHRoaXMuY3JlYXRlSW5kaWNhdG9yU2hhcGUoYSksCnRoaXMuaW5pdGlhbGl6ZVNoYXBlKGEpLHRoaXMuY3JlYXRlQ2VsbE92ZXJsYXlzKGEpLHRoaXMuaW5zdGFsbExpc3RlbmVycyhhKSxhLnZpZXcuZ3JhcGguc2VsZWN0aW9uQ2VsbHNIYW5kbGVyLnVwZGF0ZUhhbmRsZXIoYSkpKTpifHxudWxsPT1hLnNoYXBlfHxteFV0aWxzLmVxdWFsRW50cmllcyhhLnNoYXBlLnN0eWxlLGEuc3R5bGUpJiYhdGhpcy5jaGVja1BsYWNlaG9sZGVyU3R5bGVzKGEpfHwoYS5zaGFwZS5yZXNldFN0eWxlcygpLHRoaXMuY29uZmlndXJlU2hhcGUoYSksYS52aWV3LmdyYXBoLnNlbGVjdGlvbkNlbGxzSGFuZGxlci51cGRhdGVIYW5kbGVyKGEpLGI9ITApO251bGwhPWEuc2hhcGUmJmEuc2hhcGUuaW5kaWNhdG9yU2hhcGUhPXRoaXMuZ2V0U2hhcGUoYS52aWV3LmdyYXBoLmdldEluZGljYXRvclNoYXBlKGEpKSYmKG51bGwhPWEuc2hhcGUuaW5kaWNhdG9yJiYoYS5zaGFwZS5pbmRpY2F0b3IuZGVzdHJveSgpLGEuc2hhcGUuaW5kaWNhdG9yPW51bGwpLHRoaXMuY3JlYXRlSW5kaWNhdG9yU2hhcGUoYSksCm51bGwhPWEuc2hhcGUuaW5kaWNhdG9yU2hhcGUmJihhLnNoYXBlLmluZGljYXRvcj1uZXcgYS5zaGFwZS5pbmRpY2F0b3JTaGFwZSxhLnNoYXBlLmluZGljYXRvci5kaWFsZWN0PWEuc2hhcGUuZGlhbGVjdCxhLnNoYXBlLmluZGljYXRvci5pbml0KGEubm9kZSksYj0hMCkpO251bGwhPWEuc2hhcGUmJih0aGlzLmNyZWF0ZUNvbnRyb2woYSksYnx8dGhpcy5pc1NoYXBlSW52YWxpZChhLGEuc2hhcGUpKSYmKG51bGwhPWEuYWJzb2x1dGVQb2ludHM/KGEuc2hhcGUucG9pbnRzPWEuYWJzb2x1dGVQb2ludHMuc2xpY2UoKSxhLnNoYXBlLmJvdW5kcz1udWxsKTooYS5zaGFwZS5wb2ludHM9bnVsbCxhLnNoYXBlLmJvdW5kcz1uZXcgbXhSZWN0YW5nbGUoYS54LGEueSxhLndpZHRoLGEuaGVpZ2h0KSksYS5zaGFwZS5zY2FsZT1hLnZpZXcuc2NhbGUsbnVsbD09Y3x8Yz90aGlzLmRvUmVkcmF3U2hhcGUoYSk6YS5zaGFwZS51cGRhdGVCb3VuZGluZ0JveCgpLGU9ITApO3JldHVybiBlfTsKbXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmRvUmVkcmF3U2hhcGU9ZnVuY3Rpb24oYSl7YS5zaGFwZS5yZWRyYXcoKX07bXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmlzU2hhcGVJbnZhbGlkPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG51bGw9PWIuYm91bmRzfHxiLnNjYWxlIT1hLnZpZXcuc2NhbGV8fG51bGw9PWEuYWJzb2x1dGVQb2ludHMmJiFiLmJvdW5kcy5lcXVhbHMoYSl8fG51bGwhPWEuYWJzb2x1dGVQb2ludHMmJiFteFV0aWxzLmVxdWFsUG9pbnRzKGIucG9pbnRzLGEuYWJzb2x1dGVQb2ludHMpfTsKbXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oYSl7bnVsbCE9YS5zaGFwZSYmKG51bGwhPWEudGV4dCYmKGEudGV4dC5kZXN0cm95KCksYS50ZXh0PW51bGwpLG51bGwhPWEub3ZlcmxheXMmJihhLm92ZXJsYXlzLnZpc2l0KGZ1bmN0aW9uKGEsYyl7Yy5kZXN0cm95KCl9KSxhLm92ZXJsYXlzPW51bGwpLG51bGwhPWEuY29udHJvbCYmKGEuY29udHJvbC5kZXN0cm95KCksYS5jb250cm9sPW51bGwpLGEuc2hhcGUuZGVzdHJveSgpLGEuc2hhcGU9bnVsbCl9Owp2YXIgbXhFZGdlU3R5bGU9e0VudGl0eVJlbGF0aW9uOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9YS52aWV3LGc9Zi5ncmFwaDtkPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TRUdNRU5ULG14Q29uc3RhbnRzLkVOVElUWV9TRUdNRU5UKSpmLnNjYWxlO3ZhciBrPWEuYWJzb2x1dGVQb2ludHMsbD1rWzBdLG09a1trLmxlbmd0aC0xXSxrPSExO2lmKG51bGwhPWwpYj1uZXcgbXhDZWxsU3RhdGUsYi54PWwueCxiLnk9bC55O2Vsc2UgaWYobnVsbCE9Yil7dmFyIG49bXhVdGlscy5nZXRQb3J0Q29uc3RyYWludHMoYixhLCEwLG14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX05PTkUpO24hPW14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX05PTkUmJm4hPW14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX1dFU1QrbXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfRUFTVD9rPW49PW14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX1dFU1Q6KGw9Zy5nZXRDZWxsR2VvbWV0cnkoYi5jZWxsKSwKbC5yZWxhdGl2ZT9rPS41Pj1sLng6bnVsbCE9YyYmKGs9Yy54K2Mud2lkdGg8Yi54KSl9ZWxzZSByZXR1cm47bD0hMDtudWxsIT1tPyhjPW5ldyBteENlbGxTdGF0ZSxjLng9bS54LGMueT1tLnkpOm51bGwhPWMmJihuPW14VXRpbHMuZ2V0UG9ydENvbnN0cmFpbnRzKGMsYSwhMSxteENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19OT05FKSxuIT1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19OT05FJiZuIT1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19XRVNUK214Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX0VBU1Q/bD1uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19XRVNUOihhPWcuZ2V0Q2VsbEdlb21ldHJ5KGMuY2VsbCksYS5yZWxhdGl2ZT9sPS41Pj1hLng6bnVsbCE9YiYmKGw9Yi54K2Iud2lkdGg8Yy54KSkpO251bGwhPWImJm51bGwhPWMmJihhPWs/Yi54OmIueCtiLndpZHRoLGI9Zi5nZXRSb3V0aW5nQ2VudGVyWShiKSxnPWw/Yy54OmMueCtjLndpZHRoLGM9Zi5nZXRSb3V0aW5nQ2VudGVyWShjKSwKZj1uZXcgbXhQb2ludChhKyhrPy1kOmQpLGIpLG09bmV3IG14UG9pbnQoZysobD8tZDpkKSxjKSxrPT1sPyhkPWs/TWF0aC5taW4oYSxnKS1kOk1hdGgubWF4KGEsZykrZCxlLnB1c2gobmV3IG14UG9pbnQoZCxiKSksZS5wdXNoKG5ldyBteFBvaW50KGQsYykpKTooZi54PG0ueD09az8oZD1iKyhjLWIpLzIsZS5wdXNoKGYpLGUucHVzaChuZXcgbXhQb2ludChmLngsZCkpLGUucHVzaChuZXcgbXhQb2ludChtLngsZCkpKTplLnB1c2goZiksZS5wdXNoKG0pKSl9LExvb3A6ZnVuY3Rpb24oYSxiLGMsZCxlKXtjPWEuYWJzb2x1dGVQb2ludHM7dmFyIGY9Y1tjLmxlbmd0aC0xXTtpZihudWxsIT1jWzBdJiZudWxsIT1mKXtpZihudWxsIT1kJiYwPGQubGVuZ3RoKWZvcihiPTA7YjxkLmxlbmd0aDtiKyspYz1kW2JdLGM9YS52aWV3LnRyYW5zZm9ybUNvbnRyb2xQb2ludChhLGMpLGUucHVzaChuZXcgbXhQb2ludChjLngsYy55KSl9ZWxzZSBpZihudWxsIT1iKXt2YXIgZj1hLnZpZXcsZz1mLmdyYXBoOwpjPW51bGwhPWQmJjA8ZC5sZW5ndGg/ZFswXTpudWxsO251bGwhPWMmJihjPWYudHJhbnNmb3JtQ29udHJvbFBvaW50KGEsYyksbXhVdGlscy5jb250YWlucyhiLGMueCxjLnkpJiYoYz1udWxsKSk7dmFyIGs9ZD0wLGw9MCxtPTAsZz1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU0VHTUVOVCxnLmdyaWRTaXplKSpmLnNjYWxlO2E9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0RJUkVDVElPTixteENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVCk7YT09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIfHxhPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEg/KGQ9Zi5nZXRSb3V0aW5nQ2VudGVyWChiKSxrPWcpOihsPWYuZ2V0Um91dGluZ0NlbnRlclkoYiksbT1nKTtudWxsPT1jfHxjLng8Yi54fHxjLng+Yi54K2Iud2lkdGg/bnVsbCE9Yz8oZD1jLngsbT1NYXRoLm1heChNYXRoLmFicyhsLWMueSksbSkpOmE9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSD8KbD1iLnktMiprOmE9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSD9sPWIueStiLmhlaWdodCsyKms6ZD1hPT1teENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVD9iLngtMiptOmIueCtiLndpZHRoKzIqbTpudWxsIT1jJiYoZD1mLmdldFJvdXRpbmdDZW50ZXJYKGIpLGs9TWF0aC5tYXgoTWF0aC5hYnMoZC1jLngpLG0pLGw9Yy55LG09MCk7ZS5wdXNoKG5ldyBteFBvaW50KGQtayxsLW0pKTtlLnB1c2gobmV3IG14UG9pbnQoZCtrLGwrbSkpfX0sRWxib3dDb25uZWN0b3I6ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1udWxsIT1kJiYwPGQubGVuZ3RoP2RbMF06bnVsbCxnPSExLGs9ITE7aWYobnVsbCE9YiYmbnVsbCE9YylpZihudWxsIT1mKXZhciBsPU1hdGgubWluKGIueCxjLngpLG09TWF0aC5tYXgoYi54K2Iud2lkdGgsYy54K2Mud2lkdGgpLGs9TWF0aC5taW4oYi55LGMueSksbj1NYXRoLm1heChiLnkrYi5oZWlnaHQsYy55K2MuaGVpZ2h0KSxmPWEudmlldy50cmFuc2Zvcm1Db250cm9sUG9pbnQoYSwKZiksZz1mLnk8a3x8Zi55Pm4saz1mLng8bHx8Zi54Pm07ZWxzZSBsPU1hdGgubWF4KGIueCxjLngpLG09TWF0aC5taW4oYi54K2Iud2lkdGgsYy54K2Mud2lkdGgpLChnPWw9PW0pfHwoaz1NYXRoLm1heChiLnksYy55KSxuPU1hdGgubWluKGIueStiLmhlaWdodCxjLnkrYy5oZWlnaHQpLGs9az09bik7a3x8IWcmJmEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRUxCT1ddIT1teENvbnN0YW50cy5FTEJPV19WRVJUSUNBTD9teEVkZ2VTdHlsZS5TaWRlVG9TaWRlKGEsYixjLGQsZSk6bXhFZGdlU3R5bGUuVG9wVG9Cb3R0b20oYSxiLGMsZCxlKX0sU2lkZVRvU2lkZTpmdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPWEudmlldztkPW51bGwhPWQmJjA8ZC5sZW5ndGg/ZFswXTpudWxsO3ZhciBnPWEuYWJzb2x1dGVQb2ludHMsaz1nWzBdLGc9Z1tnLmxlbmd0aC0xXTtudWxsIT1kJiYoZD1mLnRyYW5zZm9ybUNvbnRyb2xQb2ludChhLGQpKTtudWxsIT1rJiYoYj1uZXcgbXhDZWxsU3RhdGUsCmIueD1rLngsYi55PWsueSk7bnVsbCE9ZyYmKGM9bmV3IG14Q2VsbFN0YXRlLGMueD1nLngsYy55PWcueSk7bnVsbCE9YiYmbnVsbCE9YyYmKGE9TWF0aC5tYXgoYi54LGMueCksaz1NYXRoLm1pbihiLngrYi53aWR0aCxjLngrYy53aWR0aCksYT1udWxsIT1kP2QueDpNYXRoLnJvdW5kKGsrKGEtaykvMiksaz1mLmdldFJvdXRpbmdDZW50ZXJZKGIpLGY9Zi5nZXRSb3V0aW5nQ2VudGVyWShjKSxudWxsIT1kJiYoZC55Pj1iLnkmJmQueTw9Yi55K2IuaGVpZ2h0JiYoaz1kLnkpLGQueT49Yy55JiZkLnk8PWMueStjLmhlaWdodCYmKGY9ZC55KSksbXhVdGlscy5jb250YWlucyhjLGEsayl8fG14VXRpbHMuY29udGFpbnMoYixhLGspfHxlLnB1c2gobmV3IG14UG9pbnQoYSxrKSksbXhVdGlscy5jb250YWlucyhjLGEsZil8fG14VXRpbHMuY29udGFpbnMoYixhLGYpfHxlLnB1c2gobmV3IG14UG9pbnQoYSxmKSksMT09ZS5sZW5ndGgmJihudWxsIT1kP214VXRpbHMuY29udGFpbnMoYyxhLApkLnkpfHxteFV0aWxzLmNvbnRhaW5zKGIsYSxkLnkpfHxlLnB1c2gobmV3IG14UG9pbnQoYSxkLnkpKTooZj1NYXRoLm1heChiLnksYy55KSxlLnB1c2gobmV3IG14UG9pbnQoYSxmKyhNYXRoLm1pbihiLnkrYi5oZWlnaHQsYy55K2MuaGVpZ2h0KS1mKS8yKSkpKSl9LFRvcFRvQm90dG9tOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9YS52aWV3O2Q9bnVsbCE9ZCYmMDxkLmxlbmd0aD9kWzBdOm51bGw7dmFyIGc9YS5hYnNvbHV0ZVBvaW50cyxrPWdbMF0sZz1nW2cubGVuZ3RoLTFdO251bGwhPWQmJihkPWYudHJhbnNmb3JtQ29udHJvbFBvaW50KGEsZCkpO251bGwhPWsmJihiPW5ldyBteENlbGxTdGF0ZSxiLng9ay54LGIueT1rLnkpO251bGwhPWcmJihjPW5ldyBteENlbGxTdGF0ZSxjLng9Zy54LGMueT1nLnkpO251bGwhPWImJm51bGwhPWMmJihrPU1hdGgubWF4KGIueSxjLnkpLGc9TWF0aC5taW4oYi55K2IuaGVpZ2h0LGMueStjLmhlaWdodCksYT1mLmdldFJvdXRpbmdDZW50ZXJYKGIpLApudWxsIT1kJiZkLng+PWIueCYmZC54PD1iLngrYi53aWR0aCYmKGE9ZC54KSxrPW51bGwhPWQ/ZC55Ok1hdGgucm91bmQoZysoay1nKS8yKSxteFV0aWxzLmNvbnRhaW5zKGMsYSxrKXx8bXhVdGlscy5jb250YWlucyhiLGEsayl8fGUucHVzaChuZXcgbXhQb2ludChhLGspKSxhPW51bGwhPWQmJmQueD49Yy54JiZkLng8PWMueCtjLndpZHRoP2QueDpmLmdldFJvdXRpbmdDZW50ZXJYKGMpLG14VXRpbHMuY29udGFpbnMoYyxhLGspfHxteFV0aWxzLmNvbnRhaW5zKGIsYSxrKXx8ZS5wdXNoKG5ldyBteFBvaW50KGEsaykpLDE9PWUubGVuZ3RoJiYobnVsbCE9ZCYmMT09ZS5sZW5ndGg/bXhVdGlscy5jb250YWlucyhjLGQueCxrKXx8bXhVdGlscy5jb250YWlucyhiLGQueCxrKXx8ZS5wdXNoKG5ldyBteFBvaW50KGQueCxrKSk6KGY9TWF0aC5tYXgoYi54LGMueCksZS5wdXNoKG5ldyBteFBvaW50KGYrKE1hdGgubWluKGIueCtiLndpZHRoLGMueCtjLndpZHRoKS1mKS8yLGspKSkpKX0sClNlZ21lbnRDb25uZWN0b3I6ZnVuY3Rpb24oYSxiLGMsZCxlKXtmdW5jdGlvbiBmKGIpe2IueD1NYXRoLnJvdW5kKGIueCphLnZpZXcuc2NhbGUqMTApLzEwO2IueT1NYXRoLnJvdW5kKGIueSphLnZpZXcuc2NhbGUqMTApLzEwO2lmKG51bGw9PWt8fDE8PU1hdGguYWJzKGsueC1iLngpfHxNYXRoLmFicyhrLnktYi55KT49TWF0aC5tYXgoMSxhLnZpZXcuc2NhbGUpKWUucHVzaChiKSxrPWI7cmV0dXJuIGt9dmFyIGc9bXhFZGdlU3R5bGUuc2NhbGVQb2ludEFycmF5KGEuYWJzb2x1dGVQb2ludHMsYS52aWV3LnNjYWxlKTtiPW14RWRnZVN0eWxlLnNjYWxlQ2VsbFN0YXRlKGIsYS52aWV3LnNjYWxlKTtjPW14RWRnZVN0eWxlLnNjYWxlQ2VsbFN0YXRlKGMsYS52aWV3LnNjYWxlKTt2YXIgaz0wPGUubGVuZ3RoP2VbMF06bnVsbCxsPSEwLG09bnVsbCxuPWdbMF07bnVsbD09biYmbnVsbCE9Yj9uPW5ldyBteFBvaW50KGEudmlldy5nZXRSb3V0aW5nQ2VudGVyWChiKSxhLnZpZXcuZ2V0Um91dGluZ0NlbnRlclkoYikpOgpudWxsIT1uJiYobj1uLmNsb25lKCkpO3ZhciBwPWcubGVuZ3RoLTE7aWYobnVsbCE9ZCYmMDxkLmxlbmd0aCl7Zm9yKHZhciBxPVtdLHI9MDtyPGQubGVuZ3RoO3IrKyl7dmFyIHQ9YS52aWV3LnRyYW5zZm9ybUNvbnRyb2xQb2ludChhLGRbcl0sITApO251bGwhPXQmJnEucHVzaCh0KX1pZigwPT1xLmxlbmd0aClyZXR1cm47bnVsbCE9biYmbnVsbCE9cVswXSYmKDE+TWF0aC5hYnMocVswXS54LW4ueCkmJihxWzBdLng9bi54KSwxPk1hdGguYWJzKHFbMF0ueS1uLnkpJiYocVswXS55PW4ueSkpO3Q9Z1twXTtudWxsIT10JiZudWxsIT1xW3EubGVuZ3RoLTFdJiYoMT5NYXRoLmFicyhxW3EubGVuZ3RoLTFdLngtdC54KSYmKHFbcS5sZW5ndGgtMV0ueD10LngpLDE+TWF0aC5hYnMocVtxLmxlbmd0aC0xXS55LXQueSkmJihxW3EubGVuZ3RoLTFdLnk9dC55KSk7dmFyIG09cVswXSx1PWI7ZD1nWzBdO3ZhciB4PSExLHk9ITEseD1tO251bGwhPWQmJih1PW51bGwpO2ZvcihyPTA7Mj5yO3IrKyl7dmFyIEI9Cm51bGwhPWQmJmQueD09eC54LEE9bnVsbCE9ZCYmZC55PT14Lnksej1udWxsIT11JiZ4Lnk+PXUueSYmeC55PD11LnkrdS5oZWlnaHQsdT1udWxsIT11JiZ4Lng+PXUueCYmeC54PD11LngrdS53aWR0aCx4PUF8fG51bGw9PWQmJnoseT1CfHxudWxsPT1kJiZ1O2lmKDAhPXJ8fCEoeCYmeXx8QiYmQSkpe2lmKG51bGwhPWQmJiFBJiYhQiYmKHp8fHUpKXtsPXo/ITE6ITA7YnJlYWt9aWYoeXx8eCl7bD14OzE9PXImJihsPTA9PXEubGVuZ3RoJTI/eDp5KTticmVha319dT1jO2Q9Z1twXTtudWxsIT1kJiYodT1udWxsKTt4PXFbcS5sZW5ndGgtMV07QiYmQSYmKHE9cS5zbGljZSgxKSl9bCYmKG51bGwhPWdbMF0mJmdbMF0ueSE9bS55fHxudWxsPT1nWzBdJiZudWxsIT1iJiYobS55PGIueXx8bS55PmIueStiLmhlaWdodCkpP2YobmV3IG14UG9pbnQobi54LG0ueSkpOiFsJiYobnVsbCE9Z1swXSYmZ1swXS54IT1tLnh8fG51bGw9PWdbMF0mJm51bGwhPWImJihtLng8Yi54fHxtLng+Yi54KwpiLndpZHRoKSkmJmYobmV3IG14UG9pbnQobS54LG4ueSkpO2w/bi55PW0ueTpuLng9bS54O2ZvcihyPTA7cjxxLmxlbmd0aDtyKyspbD0hbCxtPXFbcl0sbD9uLnk9bS55Om4ueD1tLngsZihuLmNsb25lKCkpfWVsc2UgbT1uLGw9ITA7bj1nW3BdO251bGw9PW4mJm51bGwhPWMmJihuPW5ldyBteFBvaW50KGEudmlldy5nZXRSb3V0aW5nQ2VudGVyWChjKSxhLnZpZXcuZ2V0Um91dGluZ0NlbnRlclkoYykpKTtudWxsIT1uJiZudWxsIT1tJiYobCYmKG51bGwhPWdbcF0mJmdbcF0ueSE9bS55fHxudWxsPT1nW3BdJiZudWxsIT1jJiYobS55PGMueXx8bS55PmMueStjLmhlaWdodCkpP2YobmV3IG14UG9pbnQobi54LG0ueSkpOiFsJiYobnVsbCE9Z1twXSYmZ1twXS54IT1tLnh8fG51bGw9PWdbcF0mJm51bGwhPWMmJihtLng8Yy54fHxtLng+Yy54K2Mud2lkdGgpKSYmZihuZXcgbXhQb2ludChtLngsbi55KSkpO2lmKG51bGw9PWdbMF0mJm51bGwhPWIpZm9yKDsxPGUubGVuZ3RoJiZudWxsIT0KZVsxXSYmbXhVdGlscy5jb250YWlucyhiLGVbMV0ueCxlWzFdLnkpOyllLnNwbGljZSgxLDEpO2lmKG51bGw9PWdbcF0mJm51bGwhPWMpZm9yKDsxPGUubGVuZ3RoJiZudWxsIT1lW2UubGVuZ3RoLTFdJiZteFV0aWxzLmNvbnRhaW5zKGMsZVtlLmxlbmd0aC0xXS54LGVbZS5sZW5ndGgtMV0ueSk7KWUuc3BsaWNlKGUubGVuZ3RoLTEsMSk7bnVsbCE9dCYmbnVsbCE9ZVtlLmxlbmd0aC0xXSYmMT49TWF0aC5hYnModC54LWVbZS5sZW5ndGgtMV0ueCkmJjE+PU1hdGguYWJzKHQueS1lW2UubGVuZ3RoLTFdLnkpJiYoZS5zcGxpY2UoZS5sZW5ndGgtMSwxKSxudWxsIT1lW2UubGVuZ3RoLTFdJiYoMT5NYXRoLmFicyhlW2UubGVuZ3RoLTFdLngtdC54KSYmKGVbZS5sZW5ndGgtMV0ueD10LngpLDE+TWF0aC5hYnMoZVtlLmxlbmd0aC0xXS55LXQueSkmJihlW2UubGVuZ3RoLTFdLnk9dC55KSkpfSxvcnRoQnVmZmVyOjEwLG9ydGhQb2ludHNGYWxsYmFjazohMCxkaXJWZWN0b3JzOltbLTEsCjBdLFswLC0xXSxbMSwwXSxbMCwxXSxbLTEsMF0sWzAsLTFdLFsxLDBdXSx3YXlQb2ludHMxOltbMCwwXSxbMCwwXSxbMCwwXSxbMCwwXSxbMCwwXSxbMCwwXSxbMCwwXSxbMCwwXSxbMCwwXSxbMCwwXSxbMCwwXSxbMCwwXV0scm91dGVQYXR0ZXJuczpbW1s1MTMsMjMwOCwyMDgxLDI1NjJdLFs1MTMsMTA5MCw1MTQsMjE4NCwyMTE0LDI1NjFdLFs1MTMsMTA5MCw1MTQsMjU2NCwyMTg0LDI1NjJdLFs1MTMsMjMwOCwyNTYxLDEwOTAsNTE0LDI1NjgsMjMwOF1dLFtbNTE0LDEwNTcsNTEzLDIzMDgsMjA4MSwyNTYyXSxbNTE0LDIxODQsMjExNCwyNTYxXSxbNTE0LDIxODQsMjU2MiwxMDU3LDUxMywyNTY0LDIxODRdLFs1MTQsMTA1Nyw1MTMsMjU2OCwyMzA4LDI1NjFdXSxbWzEwOTAsNTE0LDEwNTcsNTEzLDIzMDgsMjA4MSwyNTYyXSxbMjExNCwyNTYxXSxbMTA5MCwyNTYyLDEwNTcsNTEzLDI1NjQsMjE4NF0sWzEwOTAsNTE0LDEwNTcsNTEzLDIzMDgsMjU2MSwyNTY4XV0sW1syMDgxLAoyNTYyXSxbMTA1Nyw1MTMsMTA5MCw1MTQsMjE4NCwyMTE0LDI1NjFdLFsxMDU3LDUxMywxMDkwLDUxNCwyMTg0LDI1NjIsMjU2NF0sWzEwNTcsMjU2MSwxMDkwLDUxNCwyNTY4LDIzMDhdXV0saW5saW5lUm91dGVQYXR0ZXJuczpbW251bGwsWzIxMTQsMjU2OF0sbnVsbCxudWxsXSxbbnVsbCxbNTE0LDIwODEsMjExNCwyNTY4XSxudWxsLG51bGxdLFtudWxsLFsyMTE0LDI1NjFdLG51bGwsbnVsbF0sW1syMDgxLDI1NjJdLFsxMDU3LDIxMTQsMjU2OF0sWzIxODQsMjU2Ml0sbnVsbF1dLHZlcnRleFNlcGVyYXRpb25zOltdLGxpbWl0czpbWzAsMCwwLDAsMCwwLDAsMCwwXSxbMCwwLDAsMCwwLDAsMCwwLDBdXSxMRUZUX01BU0s6MzIsVE9QX01BU0s6NjQsUklHSFRfTUFTSzoxMjgsQk9UVE9NX01BU0s6MjU2LExFRlQ6MSxUT1A6MixSSUdIVDo0LEJPVFRPTTo4LFNJREVfTUFTSzo0ODAsQ0VOVEVSX01BU0s6NTEyLFNPVVJDRV9NQVNLOjEwMjQsVEFSR0VUX01BU0s6MjA0OCxWRVJURVhfTUFTSzozMDcyLApnZXRKZXR0eVNpemU6ZnVuY3Rpb24oYSxiKXt2YXIgYz1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsYj9teENvbnN0YW50cy5TVFlMRV9TT1VSQ0VfSkVUVFlfU0laRTpteENvbnN0YW50cy5TVFlMRV9UQVJHRVRfSkVUVFlfU0laRSxteFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfSkVUVFlfU0laRSxteEVkZ2VTdHlsZS5vcnRoQnVmZmVyKSk7ImF1dG8iPT1jJiYobXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLGI/bXhDb25zdGFudHMuU1RZTEVfU1RBUlRBUlJPVzpteENvbnN0YW50cy5TVFlMRV9FTkRBUlJPVyxteENvbnN0YW50cy5OT05FKSE9bXhDb25zdGFudHMuTk9ORT8oYz1teFV0aWxzLmdldE51bWJlcihhLnN0eWxlLGI/bXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFOm14Q29uc3RhbnRzLlNUWUxFX0VORFNJWkUsbXhDb25zdGFudHMuREVGQVVMVF9NQVJLRVJTSVpFKSxjPU1hdGgubWF4KDIsTWF0aC5jZWlsKChjK214RWRnZVN0eWxlLm9ydGhCdWZmZXIpLwpteEVkZ2VTdHlsZS5vcnRoQnVmZmVyKSkqbXhFZGdlU3R5bGUub3J0aEJ1ZmZlcik6Yz0yKm14RWRnZVN0eWxlLm9ydGhCdWZmZXIpO3JldHVybiBjfSxzY2FsZVBvaW50QXJyYXk6ZnVuY3Rpb24oYSxiKXt2YXIgYz1bXTtpZihudWxsIT1hKWZvcih2YXIgZD0wO2Q8YS5sZW5ndGg7ZCsrKWlmKG51bGwhPWFbZF0pe3ZhciBlPW5ldyBteFBvaW50KE1hdGgucm91bmQoYVtkXS54L2IqMTApLzEwLE1hdGgucm91bmQoYVtkXS55L2IqMTApLzEwKTtjW2RdPWV9ZWxzZSBjW2RdPW51bGw7ZWxzZSBjPW51bGw7cmV0dXJuIGN9LHNjYWxlQ2VsbFN0YXRlOmZ1bmN0aW9uKGEsYil7dmFyIGM7bnVsbCE9YT8oYz1hLmNsb25lKCksYy5zZXRSZWN0KE1hdGgucm91bmQoYS54L2IqMTApLzEwLE1hdGgucm91bmQoYS55L2IqMTApLzEwLE1hdGgucm91bmQoYS53aWR0aC9iKjEwKS8xMCxNYXRoLnJvdW5kKGEuaGVpZ2h0L2IqMTApLzEwKSk6Yz1udWxsO3JldHVybiBjfSxPcnRoQ29ubmVjdG9yOmZ1bmN0aW9uKGEsCmIsYyxkLGUpe3ZhciBmPWEudmlldy5ncmFwaCxnPW51bGw9PWw/ITE6Zi5nZXRNb2RlbCgpLmlzRWRnZShsLmNlbGwpLGs9bnVsbD09bT8hMTpmLmdldE1vZGVsKCkuaXNFZGdlKG0uY2VsbCksZj1teEVkZ2VTdHlsZS5zY2FsZVBvaW50QXJyYXkoYS5hYnNvbHV0ZVBvaW50cyxhLnZpZXcuc2NhbGUpLGw9bXhFZGdlU3R5bGUuc2NhbGVDZWxsU3RhdGUoYixhLnZpZXcuc2NhbGUpLG09bXhFZGdlU3R5bGUuc2NhbGVDZWxsU3RhdGUoYyxhLnZpZXcuc2NhbGUpLG49ZlswXSxwPWZbZi5sZW5ndGgtMV0scT1udWxsIT1sP2wueDpuLngscj1udWxsIT1sP2wueTpuLnksdD1udWxsIT1sP2wud2lkdGg6MCx1PW51bGwhPWw/bC5oZWlnaHQ6MCx4PW51bGwhPW0/bS54OnAueCx5PW51bGwhPW0/bS55OnAueSxCPW51bGwhPW0/bS53aWR0aDowLEE9bnVsbCE9bT9tLmhlaWdodDowLGY9bXhFZGdlU3R5bGUuZ2V0SmV0dHlTaXplKGEsITApLHo9bXhFZGdlU3R5bGUuZ2V0SmV0dHlTaXplKGEsITEpOwpudWxsIT1sJiZtPT1sJiYoZj16PU1hdGgubWF4KGYseikpO3ZhciBDPXorZix2PSExO2lmKG51bGwhPW4mJm51bGwhPXApdmFyIHY9cC54LW4ueCxEPXAueS1uLnksdj12KnYrRCpEPEMqQztpZih2fHxteEVkZ2VTdHlsZS5vcnRoUG9pbnRzRmFsbGJhY2smJm51bGwhPWQmJjA8ZC5sZW5ndGh8fGd8fGspbXhFZGdlU3R5bGUuU2VnbWVudENvbm5lY3RvcihhLGIsYyxkLGUpO2Vsc2V7Yz1bbXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfQUxMLG14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX0FMTF07bnVsbCE9bCYmKGNbMF09bXhVdGlscy5nZXRQb3J0Q29uc3RyYWludHMobCxhLCEwLG14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX0FMTCksYj1teFV0aWxzLmdldFZhbHVlKGwuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT04sMCksMCE9YiYmKGI9bXhVdGlscy5nZXRCb3VuZGluZ0JveChuZXcgbXhSZWN0YW5nbGUocSxyLHQsdSksYikscT1iLngscj1iLnksdD1iLndpZHRoLAp1PWIuaGVpZ2h0KSk7bnVsbCE9bSYmKGNbMV09bXhVdGlscy5nZXRQb3J0Q29uc3RyYWludHMobSxhLCExLG14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX0FMTCksYj1teFV0aWxzLmdldFZhbHVlKG0uc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT04sMCksMCE9YiYmKGI9bXhVdGlscy5nZXRCb3VuZGluZ0JveChuZXcgbXhSZWN0YW5nbGUoeCx5LEIsQSksYikseD1iLngseT1iLnksQj1iLndpZHRoLEE9Yi5oZWlnaHQpKTtiPVswLDBdO3E9W1txLHIsdCx1XSxbeCx5LEIsQV1dO3o9W2Ysel07Zm9yKHY9MDsyPnY7disrKW14RWRnZVN0eWxlLmxpbWl0c1t2XVsxXT1xW3ZdWzBdLXpbdl0sbXhFZGdlU3R5bGUubGltaXRzW3ZdWzJdPXFbdl1bMV0telt2XSxteEVkZ2VTdHlsZS5saW1pdHNbdl1bNF09cVt2XVswXStxW3ZdWzJdK3pbdl0sbXhFZGdlU3R5bGUubGltaXRzW3ZdWzhdPXFbdl1bMV0rcVt2XVszXSt6W3ZdO3o9cVswXVsxXStxWzBdWzNdLzI7cj1xWzFdWzFdK3FbMV1bM10vCjI7dj1xWzBdWzBdK3FbMF1bMl0vMi0ocVsxXVswXStxWzFdWzJdLzIpO0Q9ei1yO3o9MDswPnY/ej0wPkQ/MjoxOjA+PUQmJih6PTMsMD09diYmKHo9MikpO3I9bnVsbDtudWxsIT1sJiYocj1uKTtsPVtbLjUsLjVdLFsuNSwuNV1dO2Zvcih2PTA7Mj52O3YrKyludWxsIT1yJiYobFt2XVswXT0oci54LXFbdl1bMF0pL3Fbdl1bMl0sMT49TWF0aC5hYnMoci54LXFbdl1bMF0pP2Jbdl09bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfV0VTVDoxPj1NYXRoLmFicyhyLngtcVt2XVswXS1xW3ZdWzJdKSYmKGJbdl09bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfRUFTVCksbFt2XVsxXT0oci55LXFbdl1bMV0pL3Fbdl1bM10sMT49TWF0aC5hYnMoci55LXFbdl1bMV0pP2Jbdl09bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfTk9SVEg6MT49TWF0aC5hYnMoci55LXFbdl1bMV0tcVt2XVszXSkmJihiW3ZdPW14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX1NPVVRIKSkscj1udWxsLG51bGwhPQptJiYocj1wKTt2PXFbMF1bMV0tKHFbMV1bMV0rcVsxXVszXSk7cD1xWzBdWzBdLShxWzFdWzBdK3FbMV1bMl0pO3I9cVsxXVsxXS0ocVswXVsxXStxWzBdWzNdKTt0PXFbMV1bMF0tKHFbMF1bMF0rcVswXVsyXSk7bXhFZGdlU3R5bGUudmVydGV4U2VwZXJhdGlvbnNbMV09TWF0aC5tYXgocC1DLDApO214RWRnZVN0eWxlLnZlcnRleFNlcGVyYXRpb25zWzJdPU1hdGgubWF4KHYtQywwKTtteEVkZ2VTdHlsZS52ZXJ0ZXhTZXBlcmF0aW9uc1s0XT1NYXRoLm1heChyLUMsMCk7bXhFZGdlU3R5bGUudmVydGV4U2VwZXJhdGlvbnNbM109TWF0aC5tYXgodC1DLDApO0M9W107bT1bXTtuPVtdO21bMF09cD49dD9teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19XRVNUOm14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX0VBU1Q7blswXT12Pj1yP214Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX05PUlRIOm14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX1NPVVRIO21bMV09bXhVdGlscy5yZXZlcnNlUG9ydENvbnN0cmFpbnRzKG1bMF0pOwpuWzFdPW14VXRpbHMucmV2ZXJzZVBvcnRDb25zdHJhaW50cyhuWzBdKTtwPXA+PXQ/cDp0O3I9dj49cj92OnI7dD1bWzAsMF0sWzAsMF1dO3U9ITE7Zm9yKHY9MDsyPnY7disrKTA9PWJbdl0mJigwPT0obVt2XSZjW3ZdKSYmKG1bdl09bXhVdGlscy5yZXZlcnNlUG9ydENvbnN0cmFpbnRzKG1bdl0pKSwwPT0oblt2XSZjW3ZdKSYmKG5bdl09bXhVdGlscy5yZXZlcnNlUG9ydENvbnN0cmFpbnRzKG5bdl0pKSx0W3ZdWzBdPW5bdl0sdFt2XVsxXT1tW3ZdKTswPHImJjA8cCYmKDA8KG1bMF0mY1swXSkmJjA8KG5bMV0mY1sxXSk/KHRbMF1bMF09bVswXSx0WzBdWzFdPW5bMF0sdFsxXVswXT1uWzFdLHRbMV1bMV09bVsxXSx1PSEwKTowPChuWzBdJmNbMF0pJiYwPChtWzFdJmNbMV0pJiYodFswXVswXT1uWzBdLHRbMF1bMV09bVswXSx0WzFdWzBdPW1bMV0sdFsxXVsxXT1uWzFdLHU9ITApKTswPHImJiF1JiYodFswXVswXT1uWzBdLHRbMF1bMV09bVswXSx0WzFdWzBdPW5bMV0sdFsxXVsxXT0KbVsxXSx1PSEwKTswPHAmJiF1JiYodFswXVswXT1tWzBdLHRbMF1bMV09blswXSx0WzFdWzBdPW1bMV0sdFsxXVsxXT1uWzFdKTtmb3Iodj0wOzI+djt2KyspMD09Ylt2XSYmKDA9PSh0W3ZdWzBdJmNbdl0pJiYodFt2XVswXT10W3ZdWzFdKSxDW3ZdPXRbdl1bMF0mY1t2XSxDW3ZdfD0odFt2XVsxXSZjW3ZdKTw8OCxDW3ZdfD0odFsxLXZdW3ZdJmNbdl0pPDwxNixDW3ZdfD0odFsxLXZdWzEtdl0mY1t2XSk8PDI0LDA9PShDW3ZdJjE1KSYmKENbdl08PD04KSwwPT0oQ1t2XSYzODQwKSYmKENbdl09Q1t2XSYxNXxDW3ZdPj44KSwwPT0oQ1t2XSY5ODMwNDApJiYoQ1t2XT1DW3ZdJjY1NTM1fChDW3ZdJjI1MTY1ODI0MCk+PjgpLGJbdl09Q1t2XSYxNSxjW3ZdPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19XRVNUfHxjW3ZdPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19OT1JUSHx8Y1t2XT09bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfRUFTVHx8Y1t2XT09bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfU09VVEgpJiYKKGJbdl09Y1t2XSk7Yz1iWzBdPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19FQVNUPzM6YlswXTtDPWJbMV09PW14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX0VBU1Q/MzpiWzFdO2MtPXo7Qy09ejsxPmMmJihjKz00KTsxPkMmJihDKz00KTtjPW14RWRnZVN0eWxlLnJvdXRlUGF0dGVybnNbYy0xXVtDLTFdO214RWRnZVN0eWxlLndheVBvaW50czFbMF1bMF09cVswXVswXTtteEVkZ2VTdHlsZS53YXlQb2ludHMxWzBdWzFdPXFbMF1bMV07c3dpdGNoKGJbMF0pe2Nhc2UgbXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfV0VTVDpteEVkZ2VTdHlsZS53YXlQb2ludHMxWzBdWzBdLT1mO214RWRnZVN0eWxlLndheVBvaW50czFbMF1bMV0rPWxbMF1bMV0qcVswXVszXTticmVhaztjYXNlIG14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX1NPVVRIOm14RWRnZVN0eWxlLndheVBvaW50czFbMF1bMF0rPWxbMF1bMF0qcVswXVsyXTtteEVkZ2VTdHlsZS53YXlQb2ludHMxWzBdWzFdKz1xWzBdWzNdKwpmO2JyZWFrO2Nhc2UgbXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfRUFTVDpteEVkZ2VTdHlsZS53YXlQb2ludHMxWzBdWzBdKz1xWzBdWzJdK2Y7bXhFZGdlU3R5bGUud2F5UG9pbnRzMVswXVsxXSs9bFswXVsxXSpxWzBdWzNdO2JyZWFrO2Nhc2UgbXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfTk9SVEg6bXhFZGdlU3R5bGUud2F5UG9pbnRzMVswXVswXSs9bFswXVswXSpxWzBdWzJdLG14RWRnZVN0eWxlLndheVBvaW50czFbMF1bMV0tPWZ9Zj0wO209Qz0wPChiWzBdJihteENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19FQVNUfG14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX1dFU1QpKT8wOjE7Zm9yKHY9MDt2PGMubGVuZ3RoO3YrKyluPWNbdl0mMTUsdT1uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19FQVNUPzM6bix1Kz16LDQ8dSYmKHUtPTQpLHA9bXhFZGdlU3R5bGUuZGlyVmVjdG9yc1t1LTFdLG49MDx1JTI/MDoxLG4hPUMmJihmKyssbXhFZGdlU3R5bGUud2F5UG9pbnRzMVtmXVswXT0KbXhFZGdlU3R5bGUud2F5UG9pbnRzMVtmLTFdWzBdLG14RWRnZVN0eWxlLndheVBvaW50czFbZl1bMV09bXhFZGdlU3R5bGUud2F5UG9pbnRzMVtmLTFdWzFdKSx4PTA8KGNbdl0mbXhFZGdlU3R5bGUuVEFSR0VUX01BU0spLHk9MDwoY1t2XSZteEVkZ2VTdHlsZS5TT1VSQ0VfTUFTSykscj0oY1t2XSZteEVkZ2VTdHlsZS5TSURFX01BU0spPj41LHI8PD16LDE1PHImJihyPj49NCksdD0wPChjW3ZdJm14RWRnZVN0eWxlLkNFTlRFUl9NQVNLKSwoeXx8eCkmJjk+cj8odT15PzA6MSxyPXQmJjA9PW4/cVt1XVswXStsW3VdWzBdKnFbdV1bMl06dD9xW3VdWzFdK2xbdV1bMV0qcVt1XVszXTpteEVkZ2VTdHlsZS5saW1pdHNbdV1bcl0sMD09bj8ocj0oci1teEVkZ2VTdHlsZS53YXlQb2ludHMxW2ZdWzBdKSpwWzBdLDA8ciYmKG14RWRnZVN0eWxlLndheVBvaW50czFbZl1bMF0rPXBbMF0qcikpOihyPShyLW14RWRnZVN0eWxlLndheVBvaW50czFbZl1bMV0pKnBbMV0sMDxyJiYobXhFZGdlU3R5bGUud2F5UG9pbnRzMVtmXVsxXSs9CnBbMV0qcikpKTp0JiYobXhFZGdlU3R5bGUud2F5UG9pbnRzMVtmXVswXSs9cFswXSpNYXRoLmFicyhteEVkZ2VTdHlsZS52ZXJ0ZXhTZXBlcmF0aW9uc1t1XS8yKSxteEVkZ2VTdHlsZS53YXlQb2ludHMxW2ZdWzFdKz1wWzFdKk1hdGguYWJzKG14RWRnZVN0eWxlLnZlcnRleFNlcGVyYXRpb25zW3VdLzIpKSwwPGYmJm14RWRnZVN0eWxlLndheVBvaW50czFbZl1bbl09PW14RWRnZVN0eWxlLndheVBvaW50czFbZi0xXVtuXT9mLS06Qz1uO2Zvcih2PTA7djw9ZiYmKHYhPWZ8fCgoMDwoYlsxXSYobXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfRUFTVHxteENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19XRVNUKSk/MDoxKT09bT8wOjEpPT0oZisxKSUyKTt2KyspZS5wdXNoKG5ldyBteFBvaW50KE1hdGgucm91bmQobXhFZGdlU3R5bGUud2F5UG9pbnRzMVt2XVswXSphLnZpZXcuc2NhbGUqMTApLzEwLE1hdGgucm91bmQobXhFZGdlU3R5bGUud2F5UG9pbnRzMVt2XVsxXSphLnZpZXcuc2NhbGUqCjEwKS8xMCkpO2ZvcihhPTE7YTxlLmxlbmd0aDspbnVsbD09ZVthLTFdfHxudWxsPT1lW2FdfHxlW2EtMV0ueCE9ZVthXS54fHxlW2EtMV0ueSE9ZVthXS55P2ErKzplLnNwbGljZShhLDEpfX0sZ2V0Um91dGVQYXR0ZXJuOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWFbMF09PW14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX0VBU1Q/MzphWzBdO2E9YVsxXT09bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfRUFTVD8zOmFbMV07ZS09YjthLT1iOzE+ZSYmKGUrPTQpOzE+YSYmKGErPTQpO2I9cm91dGVQYXR0ZXJuc1tlLTFdW2EtMV07MCE9YyYmMCE9ZHx8bnVsbD09aW5saW5lUm91dGVQYXR0ZXJuc1tlLTFdW2EtMV18fChiPWlubGluZVJvdXRlUGF0dGVybnNbZS0xXVthLTFdKTtyZXR1cm4gYn19LG14U3R5bGVSZWdpc3RyeT17dmFsdWVzOltdLHB1dFZhbHVlOmZ1bmN0aW9uKGEsYil7bXhTdHlsZVJlZ2lzdHJ5LnZhbHVlc1thXT1ifSxnZXRWYWx1ZTpmdW5jdGlvbihhKXtyZXR1cm4gbXhTdHlsZVJlZ2lzdHJ5LnZhbHVlc1thXX0sCmdldE5hbWU6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiIGluIG14U3R5bGVSZWdpc3RyeS52YWx1ZXMpaWYobXhTdHlsZVJlZ2lzdHJ5LnZhbHVlc1tiXT09YSlyZXR1cm4gYjtyZXR1cm4gbnVsbH19O214U3R5bGVSZWdpc3RyeS5wdXRWYWx1ZShteENvbnN0YW50cy5FREdFU1RZTEVfRUxCT1csbXhFZGdlU3R5bGUuRWxib3dDb25uZWN0b3IpO214U3R5bGVSZWdpc3RyeS5wdXRWYWx1ZShteENvbnN0YW50cy5FREdFU1RZTEVfRU5USVRZX1JFTEFUSU9OLG14RWRnZVN0eWxlLkVudGl0eVJlbGF0aW9uKTtteFN0eWxlUmVnaXN0cnkucHV0VmFsdWUobXhDb25zdGFudHMuRURHRVNUWUxFX0xPT1AsbXhFZGdlU3R5bGUuTG9vcCk7bXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKG14Q29uc3RhbnRzLkVER0VTVFlMRV9TSURFVE9TSURFLG14RWRnZVN0eWxlLlNpZGVUb1NpZGUpO214U3R5bGVSZWdpc3RyeS5wdXRWYWx1ZShteENvbnN0YW50cy5FREdFU1RZTEVfVE9QVE9CT1RUT00sbXhFZGdlU3R5bGUuVG9wVG9Cb3R0b20pOwpteFN0eWxlUmVnaXN0cnkucHV0VmFsdWUobXhDb25zdGFudHMuRURHRVNUWUxFX09SVEhPR09OQUwsbXhFZGdlU3R5bGUuT3J0aENvbm5lY3Rvcik7bXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKG14Q29uc3RhbnRzLkVER0VTVFlMRV9TRUdNRU5ULG14RWRnZVN0eWxlLlNlZ21lbnRDb25uZWN0b3IpO214U3R5bGVSZWdpc3RyeS5wdXRWYWx1ZShteENvbnN0YW50cy5QRVJJTUVURVJfRUxMSVBTRSxteFBlcmltZXRlci5FbGxpcHNlUGVyaW1ldGVyKTtteFN0eWxlUmVnaXN0cnkucHV0VmFsdWUobXhDb25zdGFudHMuUEVSSU1FVEVSX1JFQ1RBTkdMRSxteFBlcmltZXRlci5SZWN0YW5nbGVQZXJpbWV0ZXIpO214U3R5bGVSZWdpc3RyeS5wdXRWYWx1ZShteENvbnN0YW50cy5QRVJJTUVURVJfUkhPTUJVUyxteFBlcmltZXRlci5SaG9tYnVzUGVyaW1ldGVyKTtteFN0eWxlUmVnaXN0cnkucHV0VmFsdWUobXhDb25zdGFudHMuUEVSSU1FVEVSX1RSSUFOR0xFLG14UGVyaW1ldGVyLlRyaWFuZ2xlUGVyaW1ldGVyKTsKbXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKG14Q29uc3RhbnRzLlBFUklNRVRFUl9IRVhBR09OLG14UGVyaW1ldGVyLkhleGFnb25QZXJpbWV0ZXIpO2Z1bmN0aW9uIG14R3JhcGhWaWV3KGEpe3RoaXMuZ3JhcGg9YTt0aGlzLnRyYW5zbGF0ZT1uZXcgbXhQb2ludDt0aGlzLmdyYXBoQm91bmRzPW5ldyBteFJlY3RhbmdsZTt0aGlzLnN0YXRlcz1uZXcgbXhEaWN0aW9uYXJ5fW14R3JhcGhWaWV3LnByb3RvdHlwZT1uZXcgbXhFdmVudFNvdXJjZTtteEdyYXBoVmlldy5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhHcmFwaFZpZXc7bXhHcmFwaFZpZXcucHJvdG90eXBlLkVNUFRZX1BPSU5UPW5ldyBteFBvaW50O214R3JhcGhWaWV3LnByb3RvdHlwZS5kb25lUmVzb3VyY2U9Im5vbmUiIT1teENsaWVudC5sYW5ndWFnZT8iZG9uZSI6IiI7Cm14R3JhcGhWaWV3LnByb3RvdHlwZS51cGRhdGluZ0RvY3VtZW50UmVzb3VyY2U9Im5vbmUiIT1teENsaWVudC5sYW5ndWFnZT8idXBkYXRpbmdEb2N1bWVudCI6IiI7bXhHcmFwaFZpZXcucHJvdG90eXBlLmFsbG93RXZhbD0hMTtteEdyYXBoVmlldy5wcm90b3R5cGUuY2FwdHVyZURvY3VtZW50R2VzdHVyZT0hMDtteEdyYXBoVmlldy5wcm90b3R5cGUub3B0aW1pemVWbWxSZWZsb3dzPSEwO214R3JhcGhWaWV3LnByb3RvdHlwZS5yZW5kZXJpbmc9ITA7bXhHcmFwaFZpZXcucHJvdG90eXBlLmdyYXBoPW51bGw7bXhHcmFwaFZpZXcucHJvdG90eXBlLmN1cnJlbnRSb290PW51bGw7bXhHcmFwaFZpZXcucHJvdG90eXBlLmdyYXBoQm91bmRzPW51bGw7bXhHcmFwaFZpZXcucHJvdG90eXBlLnNjYWxlPTE7bXhHcmFwaFZpZXcucHJvdG90eXBlLnRyYW5zbGF0ZT1udWxsO214R3JhcGhWaWV3LnByb3RvdHlwZS5zdGF0ZXM9bnVsbDsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnVwZGF0ZVN0eWxlPSExO214R3JhcGhWaWV3LnByb3RvdHlwZS5sYXN0Tm9kZT1udWxsO214R3JhcGhWaWV3LnByb3RvdHlwZS5sYXN0SHRtbE5vZGU9bnVsbDtteEdyYXBoVmlldy5wcm90b3R5cGUubGFzdEZvcmVncm91bmROb2RlPW51bGw7bXhHcmFwaFZpZXcucHJvdG90eXBlLmxhc3RGb3JlZ3JvdW5kSHRtbE5vZGU9bnVsbDtteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0R3JhcGhCb3VuZHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmFwaEJvdW5kc307bXhHcmFwaFZpZXcucHJvdG90eXBlLnNldEdyYXBoQm91bmRzPWZ1bmN0aW9uKGEpe3RoaXMuZ3JhcGhCb3VuZHM9YX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5nZXRCb3VuZHM9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbDtpZihudWxsIT1hJiYwPGEubGVuZ3RoKWZvcih2YXIgYz10aGlzLmdyYXBoLmdldE1vZGVsKCksZD0wO2Q8YS5sZW5ndGg7ZCsrKWlmKGMuaXNWZXJ0ZXgoYVtkXSl8fGMuaXNFZGdlKGFbZF0pKXt2YXIgZT10aGlzLmdldFN0YXRlKGFbZF0pO251bGwhPWUmJihudWxsPT1iP2I9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShlKTpiLmFkZChlKSl9cmV0dXJuIGJ9O214R3JhcGhWaWV3LnByb3RvdHlwZS5zZXRDdXJyZW50Um9vdD1mdW5jdGlvbihhKXtpZih0aGlzLmN1cnJlbnRSb290IT1hKXt2YXIgYj1uZXcgbXhDdXJyZW50Um9vdENoYW5nZSh0aGlzLGEpO2IuZXhlY3V0ZSgpO3ZhciBjPW5ldyBteFVuZG9hYmxlRWRpdCh0aGlzLCEwKTtjLmFkZChiKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlVORE8sImVkaXQiLGMpKTt0aGlzLmdyYXBoLnNpemVEaWRDaGFuZ2UoKX1yZXR1cm4gYX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5zY2FsZUFuZFRyYW5zbGF0ZT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5zY2FsZSxlPW5ldyBteFBvaW50KHRoaXMudHJhbnNsYXRlLngsdGhpcy50cmFuc2xhdGUueSk7aWYodGhpcy5zY2FsZSE9YXx8dGhpcy50cmFuc2xhdGUueCE9Ynx8dGhpcy50cmFuc2xhdGUueSE9Yyl0aGlzLnNjYWxlPWEsdGhpcy50cmFuc2xhdGUueD1iLHRoaXMudHJhbnNsYXRlLnk9Yyx0aGlzLmlzRXZlbnRzRW5hYmxlZCgpJiZ0aGlzLnZpZXdTdGF0ZUNoYW5nZWQoKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlNDQUxFX0FORF9UUkFOU0xBVEUsInNjYWxlIixhLCJwcmV2aW91c1NjYWxlIixkLCJ0cmFuc2xhdGUiLHRoaXMudHJhbnNsYXRlLCJwcmV2aW91c1RyYW5zbGF0ZSIsZSkpfTtteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0U2NhbGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zY2FsZX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5zZXRTY2FsZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLnNjYWxlO3RoaXMuc2NhbGUhPWEmJih0aGlzLnNjYWxlPWEsdGhpcy5pc0V2ZW50c0VuYWJsZWQoKSYmdGhpcy52aWV3U3RhdGVDaGFuZ2VkKCkpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuU0NBTEUsInNjYWxlIixhLCJwcmV2aW91c1NjYWxlIixiKSl9O214R3JhcGhWaWV3LnByb3RvdHlwZS5nZXRUcmFuc2xhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFuc2xhdGV9OwpteEdyYXBoVmlldy5wcm90b3R5cGUuc2V0VHJhbnNsYXRlPWZ1bmN0aW9uKGEsYil7dmFyIGM9bmV3IG14UG9pbnQodGhpcy50cmFuc2xhdGUueCx0aGlzLnRyYW5zbGF0ZS55KTtpZih0aGlzLnRyYW5zbGF0ZS54IT1hfHx0aGlzLnRyYW5zbGF0ZS55IT1iKXRoaXMudHJhbnNsYXRlLng9YSx0aGlzLnRyYW5zbGF0ZS55PWIsdGhpcy5pc0V2ZW50c0VuYWJsZWQoKSYmdGhpcy52aWV3U3RhdGVDaGFuZ2VkKCk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5UUkFOU0xBVEUsInRyYW5zbGF0ZSIsdGhpcy50cmFuc2xhdGUsInByZXZpb3VzVHJhbnNsYXRlIixjKSl9O214R3JhcGhWaWV3LnByb3RvdHlwZS52aWV3U3RhdGVDaGFuZ2VkPWZ1bmN0aW9uKCl7dGhpcy5yZXZhbGlkYXRlKCk7dGhpcy5ncmFwaC5zaXplRGlkQ2hhbmdlKCl9OwpteEdyYXBoVmlldy5wcm90b3R5cGUucmVmcmVzaD1mdW5jdGlvbigpe251bGwhPXRoaXMuY3VycmVudFJvb3QmJnRoaXMuY2xlYXIoKTt0aGlzLnJldmFsaWRhdGUoKX07bXhHcmFwaFZpZXcucHJvdG90eXBlLnJldmFsaWRhdGU9ZnVuY3Rpb24oKXt0aGlzLmludmFsaWRhdGUoKTt0aGlzLnZhbGlkYXRlKCl9O214R3JhcGhWaWV3LnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5ncmFwaC5nZXRNb2RlbCgpO2E9YXx8ZC5nZXRSb290KCk7Yj1udWxsIT1iP2I6ITE7Yz1udWxsIT1jP2M6ITA7dGhpcy5yZW1vdmVTdGF0ZShhKTtpZihjJiYoYnx8YSE9dGhpcy5jdXJyZW50Um9vdCkpe2M9ZC5nZXRDaGlsZENvdW50KGEpO2Zvcih2YXIgZT0wO2U8YztlKyspdGhpcy5jbGVhcihkLmdldENoaWxkQXQoYSxlKSxiKX1lbHNlIHRoaXMuaW52YWxpZGF0ZShhKX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5pbnZhbGlkYXRlPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLmdyYXBoLmdldE1vZGVsKCk7YT1hfHxkLmdldFJvb3QoKTtiPW51bGwhPWI/YjohMDtjPW51bGwhPWM/YzohMDt2YXIgZT10aGlzLmdldFN0YXRlKGEpO251bGwhPWUmJihlLmludmFsaWQ9ITApO2lmKCFhLmludmFsaWRhdGluZyl7YS5pbnZhbGlkYXRpbmc9ITA7aWYoYilmb3IodmFyIGY9ZC5nZXRDaGlsZENvdW50KGEpLGU9MDtlPGY7ZSsrKXt2YXIgZz1kLmdldENoaWxkQXQoYSxlKTt0aGlzLmludmFsaWRhdGUoZyxiLGMpfWlmKGMpZm9yKGY9ZC5nZXRFZGdlQ291bnQoYSksZT0wO2U8ZjtlKyspdGhpcy5pbnZhbGlkYXRlKGQuZ2V0RWRnZUF0KGEsZSksYixjKTtkZWxldGUgYS5pbnZhbGlkYXRpbmd9fTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnZhbGlkYXRlPWZ1bmN0aW9uKGEpe3ZhciBiPW14TG9nLmVudGVyKCJteEdyYXBoVmlldy52YWxpZGF0ZSIpO3dpbmRvdy5zdGF0dXM9bXhSZXNvdXJjZXMuZ2V0KHRoaXMudXBkYXRpbmdEb2N1bWVudFJlc291cmNlKXx8dGhpcy51cGRhdGluZ0RvY3VtZW50UmVzb3VyY2U7dGhpcy5yZXNldFZhbGlkYXRpb25TdGF0ZSgpO3ZhciBjPW51bGw7dGhpcy5vcHRpbWl6ZVZtbFJlZmxvd3MmJm51bGwhPXRoaXMuY2FudmFzJiZudWxsPT10aGlzLnRleHREaXYmJig4PT1kb2N1bWVudC5kb2N1bWVudE1vZGUmJiFteENsaWVudC5JU19FTXx8bXhDbGllbnQuSVNfUVVJUktTKSYmKHRoaXMucGxhY2Vob2xkZXI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2IiksdGhpcy5wbGFjZWhvbGRlci5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiLHRoaXMucGxhY2Vob2xkZXIuc3R5bGUud2lkdGg9dGhpcy5jYW52YXMuY2xpZW50V2lkdGgrInB4Iix0aGlzLnBsYWNlaG9sZGVyLnN0eWxlLmhlaWdodD0KdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0KyJweCIsdGhpcy5jYW52YXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLnBsYWNlaG9sZGVyKSxjPXRoaXMuZHJhd1BhbmUuc3R5bGUuZGlzcGxheSx0aGlzLmNhbnZhcy5zdHlsZS5kaXNwbGF5PSJub25lIix0aGlzLnRleHREaXY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2IiksdGhpcy50ZXh0RGl2LnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSIsdGhpcy50ZXh0RGl2LnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCIsdGhpcy50ZXh0RGl2LnN0eWxlLnZpc2liaWxpdHk9ImhpZGRlbiIsdGhpcy50ZXh0RGl2LnN0eWxlLmRpc3BsYXk9bXhDbGllbnQuSVNfUVVJUktTPyJpbmxpbmUiOiJpbmxpbmUtYmxvY2siLHRoaXMudGV4dERpdi5zdHlsZS56b29tPSIxIixkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMudGV4dERpdikpO2E9dGhpcy5nZXRCb3VuZGluZ0JveCh0aGlzLnZhbGlkYXRlQ2VsbFN0YXRlKHRoaXMudmFsaWRhdGVDZWxsKGF8fAoobnVsbCE9dGhpcy5jdXJyZW50Um9vdD90aGlzLmN1cnJlbnRSb290OnRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5nZXRSb290KCkpKSkpO3RoaXMuc2V0R3JhcGhCb3VuZHMobnVsbCE9YT9hOnRoaXMuZ2V0RW1wdHlCb3VuZHMoKSk7dGhpcy52YWxpZGF0ZUJhY2tncm91bmQoKTtudWxsIT1jJiYodGhpcy5jYW52YXMuc3R5bGUuZGlzcGxheT1jLHRoaXMudGV4dERpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMudGV4dERpdiksbnVsbCE9dGhpcy5wbGFjZWhvbGRlciYmdGhpcy5wbGFjZWhvbGRlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucGxhY2Vob2xkZXIpLHRoaXMudGV4dERpdj1udWxsKTt0aGlzLnJlc2V0VmFsaWRhdGlvblN0YXRlKCk7d2luZG93LnN0YXR1cz1teFJlc291cmNlcy5nZXQodGhpcy5kb25lUmVzb3VyY2UpfHx0aGlzLmRvbmVSZXNvdXJjZTtteExvZy5sZWF2ZSgibXhHcmFwaFZpZXcudmFsaWRhdGUiLGIpfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLmdldEVtcHR5Qm91bmRzPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBteFJlY3RhbmdsZSh0aGlzLnRyYW5zbGF0ZS54KnRoaXMuc2NhbGUsdGhpcy50cmFuc2xhdGUueSp0aGlzLnNjYWxlKX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveD1mdW5jdGlvbihhLGIpe2I9bnVsbCE9Yj9iOiEwO3ZhciBjPW51bGw7aWYobnVsbCE9YSYmKG51bGwhPWEuc2hhcGUmJm51bGwhPWEuc2hhcGUuYm91bmRpbmdCb3gmJihjPWEuc2hhcGUuYm91bmRpbmdCb3guY2xvbmUoKSksbnVsbCE9YS50ZXh0JiZudWxsIT1hLnRleHQuYm91bmRpbmdCb3gmJihudWxsIT1jP2MuYWRkKGEudGV4dC5ib3VuZGluZ0JveCk6Yz1hLnRleHQuYm91bmRpbmdCb3guY2xvbmUoKSksYikpZm9yKHZhciBkPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxlPWQuZ2V0Q2hpbGRDb3VudChhLmNlbGwpLGY9MDtmPGU7ZisrKXt2YXIgZz10aGlzLmdldEJvdW5kaW5nQm94KHRoaXMuZ2V0U3RhdGUoZC5nZXRDaGlsZEF0KGEuY2VsbCxmKSkpO251bGwhPWcmJihudWxsPT1jP2M9ZzpjLmFkZChnKSl9cmV0dXJuIGN9OwpteEdyYXBoVmlldy5wcm90b3R5cGUuY3JlYXRlQmFja2dyb3VuZFBhZ2VTaGFwZT1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlU2hhcGUoYSwid2hpdGUiLCJibGFjayIpfTtteEdyYXBoVmlldy5wcm90b3R5cGUudmFsaWRhdGVCYWNrZ3JvdW5kPWZ1bmN0aW9uKCl7dGhpcy52YWxpZGF0ZUJhY2tncm91bmRJbWFnZSgpO3RoaXMudmFsaWRhdGVCYWNrZ3JvdW5kUGFnZSgpfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnZhbGlkYXRlQmFja2dyb3VuZEltYWdlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5ncmFwaC5nZXRCYWNrZ3JvdW5kSW1hZ2UoKTtpZihudWxsIT1hKXtpZihudWxsPT10aGlzLmJhY2tncm91bmRJbWFnZXx8dGhpcy5iYWNrZ3JvdW5kSW1hZ2UuaW1hZ2UhPWEuc3JjKXtudWxsIT10aGlzLmJhY2tncm91bmRJbWFnZSYmdGhpcy5iYWNrZ3JvdW5kSW1hZ2UuZGVzdHJveSgpO3ZhciBiPW5ldyBteFJlY3RhbmdsZSgwLDAsMSwxKTt0aGlzLmJhY2tncm91bmRJbWFnZT1uZXcgbXhJbWFnZVNoYXBlKGIsYS5zcmMpO3RoaXMuYmFja2dyb3VuZEltYWdlLmRpYWxlY3Q9dGhpcy5ncmFwaC5kaWFsZWN0O3RoaXMuYmFja2dyb3VuZEltYWdlLmluaXQodGhpcy5iYWNrZ3JvdW5kUGFuZSk7dGhpcy5iYWNrZ3JvdW5kSW1hZ2UucmVkcmF3KCk7OCE9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHxteENsaWVudC5JU19FTXx8bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKHRoaXMuYmFja2dyb3VuZEltYWdlLm5vZGUsCm14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuZ3JhcGguZmlyZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9ET1dOLG5ldyBteE1vdXNlRXZlbnQoYSkpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5ncmFwaC5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX01PVkUsbmV3IG14TW91c2VFdmVudChhKSl9KSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmdyYXBoLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfVVAsbmV3IG14TW91c2VFdmVudChhKSl9KSl9dGhpcy5yZWRyYXdCYWNrZ3JvdW5kSW1hZ2UodGhpcy5iYWNrZ3JvdW5kSW1hZ2UsYSl9ZWxzZSBudWxsIT10aGlzLmJhY2tncm91bmRJbWFnZSYmKHRoaXMuYmFja2dyb3VuZEltYWdlLmRlc3Ryb3koKSx0aGlzLmJhY2tncm91bmRJbWFnZT1udWxsKX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS52YWxpZGF0ZUJhY2tncm91bmRQYWdlPWZ1bmN0aW9uKCl7aWYodGhpcy5ncmFwaC5wYWdlVmlzaWJsZSl7dmFyIGE9dGhpcy5nZXRCYWNrZ3JvdW5kUGFnZUJvdW5kcygpO251bGw9PXRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZT8odGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlPXRoaXMuY3JlYXRlQmFja2dyb3VuZFBhZ2VTaGFwZShhKSx0aGlzLmJhY2tncm91bmRQYWdlU2hhcGUuc2NhbGU9dGhpcy5zY2FsZSx0aGlzLmJhY2tncm91bmRQYWdlU2hhcGUuaXNTaGFkb3c9ITAsdGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlLmRpYWxlY3Q9dGhpcy5ncmFwaC5kaWFsZWN0LHRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZS5pbml0KHRoaXMuYmFja2dyb3VuZFBhbmUpLHRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZS5yZWRyYXcoKSx0aGlzLmdyYXBoLm5hdGl2ZURibENsaWNrRW5hYmxlZCYmbXhFdmVudC5hZGRMaXN0ZW5lcih0aGlzLmJhY2tncm91bmRQYWdlU2hhcGUubm9kZSwKImRibGNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmdyYXBoLmRibENsaWNrKGEpfSkpLG14RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyh0aGlzLmJhY2tncm91bmRQYWdlU2hhcGUubm9kZSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmdyYXBoLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfRE9XTixuZXcgbXhNb3VzZUV2ZW50KGEpKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe251bGwhPXRoaXMuZ3JhcGgudG9vbHRpcEhhbmRsZXImJnRoaXMuZ3JhcGgudG9vbHRpcEhhbmRsZXIuaXNIaWRlT25Ib3ZlcigpJiZ0aGlzLmdyYXBoLnRvb2x0aXBIYW5kbGVyLmhpZGUoKTt0aGlzLmdyYXBoLmlzTW91c2VEb3duJiYhbXhFdmVudC5pc0NvbnN1bWVkKGEpJiZ0aGlzLmdyYXBoLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfTU9WRSxuZXcgbXhNb3VzZUV2ZW50KGEpKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuZ3JhcGguZmlyZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9VUCwKbmV3IG14TW91c2VFdmVudChhKSl9KSkpOih0aGlzLmJhY2tncm91bmRQYWdlU2hhcGUuc2NhbGU9dGhpcy5zY2FsZSx0aGlzLmJhY2tncm91bmRQYWdlU2hhcGUuYm91bmRzPWEsdGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlLnJlZHJhdygpKX1lbHNlIG51bGwhPXRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZSYmKHRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZS5kZXN0cm95KCksdGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlPW51bGwpfTtteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0QmFja2dyb3VuZFBhZ2VCb3VuZHM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoLnBhZ2VGb3JtYXQsYj10aGlzLnNjYWxlKnRoaXMuZ3JhcGgucGFnZVNjYWxlO3JldHVybiBuZXcgbXhSZWN0YW5nbGUodGhpcy5zY2FsZSp0aGlzLnRyYW5zbGF0ZS54LHRoaXMuc2NhbGUqdGhpcy50cmFuc2xhdGUueSxhLndpZHRoKmIsYS5oZWlnaHQqYil9OwpteEdyYXBoVmlldy5wcm90b3R5cGUucmVkcmF3QmFja2dyb3VuZEltYWdlPWZ1bmN0aW9uKGEsYil7YS5zY2FsZT10aGlzLnNjYWxlO2EuYm91bmRzLng9dGhpcy5zY2FsZSp0aGlzLnRyYW5zbGF0ZS54O2EuYm91bmRzLnk9dGhpcy5zY2FsZSp0aGlzLnRyYW5zbGF0ZS55O2EuYm91bmRzLndpZHRoPXRoaXMuc2NhbGUqYi53aWR0aDthLmJvdW5kcy5oZWlnaHQ9dGhpcy5zY2FsZSpiLmhlaWdodDthLnJlZHJhdygpfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnZhbGlkYXRlQ2VsbD1mdW5jdGlvbihhLGIpe2lmKG51bGwhPWEpaWYoYj0obnVsbCE9Yj9iOiEwKSYmdGhpcy5ncmFwaC5pc0NlbGxWaXNpYmxlKGEpLG51bGw9PXRoaXMuZ2V0U3RhdGUoYSxiKXx8Yilmb3IodmFyIGM9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGQ9Yy5nZXRDaGlsZENvdW50KGEpLGU9MDtlPGQ7ZSsrKXRoaXMudmFsaWRhdGVDZWxsKGMuZ2V0Q2hpbGRBdChhLGUpLGImJighdGhpcy5pc0NlbGxDb2xsYXBzZWQoYSl8fGE9PXRoaXMuY3VycmVudFJvb3QpKTtlbHNlIHRoaXMucmVtb3ZlU3RhdGUoYSk7cmV0dXJuIGF9OwpteEdyYXBoVmlldy5wcm90b3R5cGUudmFsaWRhdGVDZWxsU3RhdGU9ZnVuY3Rpb24oYSxiKXtiPW51bGwhPWI/YjohMDt2YXIgYz1udWxsO2lmKG51bGwhPWEmJihjPXRoaXMuZ2V0U3RhdGUoYSksbnVsbCE9Yykpe3ZhciBkPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKTtpZihjLmludmFsaWQpe2MuaW52YWxpZD0hMTtpZihudWxsPT1jLnN0eWxlfHxjLmludmFsaWRTdHlsZSljLnN0eWxlPXRoaXMuZ3JhcGguZ2V0Q2VsbFN0eWxlKGMuY2VsbCksYy5pbnZhbGlkU3R5bGU9ITE7YSE9dGhpcy5jdXJyZW50Um9vdCYmdGhpcy52YWxpZGF0ZUNlbGxTdGF0ZShkLmdldFBhcmVudChhKSwhMSk7Yy5zZXRWaXNpYmxlVGVybWluYWxTdGF0ZSh0aGlzLnZhbGlkYXRlQ2VsbFN0YXRlKHRoaXMuZ2V0VmlzaWJsZVRlcm1pbmFsKGEsITApLCExKSwhMCk7Yy5zZXRWaXNpYmxlVGVybWluYWxTdGF0ZSh0aGlzLnZhbGlkYXRlQ2VsbFN0YXRlKHRoaXMuZ2V0VmlzaWJsZVRlcm1pbmFsKGEsITEpLCExKSwKITEpO3RoaXMudXBkYXRlQ2VsbFN0YXRlKGMpO2E9PXRoaXMuY3VycmVudFJvb3R8fGMuaW52YWxpZHx8KHRoaXMuZ3JhcGguY2VsbFJlbmRlcmVyLnJlZHJhdyhjLCExLHRoaXMuaXNSZW5kZXJpbmcoKSksYy51cGRhdGVDYWNoZWRCb3VuZHMoKSl9aWYoYiYmIWMuaW52YWxpZCl7bnVsbCE9Yy5zaGFwZSYmdGhpcy5zdGF0ZVZhbGlkYXRlZChjKTtmb3IodmFyIGU9ZC5nZXRDaGlsZENvdW50KGEpLGY9MDtmPGU7ZisrKXRoaXMudmFsaWRhdGVDZWxsU3RhdGUoZC5nZXRDaGlsZEF0KGEsZikpfX1yZXR1cm4gY307Cm14R3JhcGhWaWV3LnByb3RvdHlwZS51cGRhdGVDZWxsU3RhdGU9ZnVuY3Rpb24oYSl7YS5hYnNvbHV0ZU9mZnNldC54PTA7YS5hYnNvbHV0ZU9mZnNldC55PTA7YS5vcmlnaW4ueD0wO2Eub3JpZ2luLnk9MDthLmxlbmd0aD0wO2lmKGEuY2VsbCE9dGhpcy5jdXJyZW50Um9vdCl7dmFyIGI9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGM9dGhpcy5nZXRTdGF0ZShiLmdldFBhcmVudChhLmNlbGwpKTtudWxsIT1jJiZjLmNlbGwhPXRoaXMuY3VycmVudFJvb3QmJihhLm9yaWdpbi54Kz1jLm9yaWdpbi54LGEub3JpZ2luLnkrPWMub3JpZ2luLnkpO3ZhciBkPXRoaXMuZ3JhcGguZ2V0Q2hpbGRPZmZzZXRGb3JDZWxsKGEuY2VsbCk7bnVsbCE9ZCYmKGEub3JpZ2luLngrPWQueCxhLm9yaWdpbi55Kz1kLnkpO3ZhciBlPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGEuY2VsbCk7bnVsbCE9ZSYmKGIuaXNFZGdlKGEuY2VsbCl8fChkPW51bGwhPWUub2Zmc2V0P2Uub2Zmc2V0OnRoaXMuRU1QVFlfUE9JTlQsCmUucmVsYXRpdmUmJm51bGwhPWM/Yi5pc0VkZ2UoYy5jZWxsKT8oZD10aGlzLmdldFBvaW50KGMsZSksbnVsbCE9ZCYmKGEub3JpZ2luLngrPWQueC90aGlzLnNjYWxlLWMub3JpZ2luLngtdGhpcy50cmFuc2xhdGUueCxhLm9yaWdpbi55Kz1kLnkvdGhpcy5zY2FsZS1jLm9yaWdpbi55LXRoaXMudHJhbnNsYXRlLnkpKTooYS5vcmlnaW4ueCs9ZS54KmMudW5zY2FsZWRXaWR0aCtkLngsYS5vcmlnaW4ueSs9ZS55KmMudW5zY2FsZWRIZWlnaHQrZC55KTooYS5hYnNvbHV0ZU9mZnNldC54PXRoaXMuc2NhbGUqZC54LGEuYWJzb2x1dGVPZmZzZXQueT10aGlzLnNjYWxlKmQueSxhLm9yaWdpbi54Kz1lLngsYS5vcmlnaW4ueSs9ZS55KSksYS54PXRoaXMuc2NhbGUqKHRoaXMudHJhbnNsYXRlLngrYS5vcmlnaW4ueCksYS55PXRoaXMuc2NhbGUqKHRoaXMudHJhbnNsYXRlLnkrYS5vcmlnaW4ueSksYS53aWR0aD10aGlzLnNjYWxlKmUud2lkdGgsYS51bnNjYWxlZFdpZHRoPWUud2lkdGgsYS5oZWlnaHQ9CnRoaXMuc2NhbGUqZS5oZWlnaHQsYS51bnNjYWxlZEhlaWdodD1lLmhlaWdodCxiLmlzVmVydGV4KGEuY2VsbCkmJnRoaXMudXBkYXRlVmVydGV4U3RhdGUoYSxlKSxiLmlzRWRnZShhLmNlbGwpJiZ0aGlzLnVwZGF0ZUVkZ2VTdGF0ZShhLGUpKX1hLnVwZGF0ZUNhY2hlZEJvdW5kcygpfTtteEdyYXBoVmlldy5wcm90b3R5cGUuaXNDZWxsQ29sbGFwc2VkPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdyYXBoLmlzQ2VsbENvbGxhcHNlZChhKX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS51cGRhdGVWZXJ0ZXhTdGF0ZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxkPXRoaXMuZ2V0U3RhdGUoYy5nZXRQYXJlbnQoYS5jZWxsKSk7aWYoYi5yZWxhdGl2ZSYmbnVsbCE9ZCYmIWMuaXNFZGdlKGQuY2VsbCkpe3ZhciBlPW14VXRpbHMudG9SYWRpYW5zKGQuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT05dfHwiMCIpO2lmKDAhPWUpe3ZhciBjPU1hdGguY29zKGUpLGU9TWF0aC5zaW4oZSksZj1uZXcgbXhQb2ludChhLmdldENlbnRlclgoKSxhLmdldENlbnRlclkoKSksZD1uZXcgbXhQb2ludChkLmdldENlbnRlclgoKSxkLmdldENlbnRlclkoKSksZD1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChmLGMsZSxkKTthLng9ZC54LWEud2lkdGgvMjthLnk9ZC55LWEuaGVpZ2h0LzJ9fXRoaXMudXBkYXRlVmVydGV4TGFiZWxPZmZzZXQoYSl9OwpteEdyYXBoVmlldy5wcm90b3R5cGUudXBkYXRlRWRnZVN0YXRlPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZSghMCksZD1hLmdldFZpc2libGVUZXJtaW5hbFN0YXRlKCExKTtudWxsIT10aGlzLmdyYXBoLm1vZGVsLmdldFRlcm1pbmFsKGEuY2VsbCwhMCkmJm51bGw9PWN8fG51bGw9PWMmJm51bGw9PWIuZ2V0VGVybWluYWxQb2ludCghMCl8fG51bGwhPXRoaXMuZ3JhcGgubW9kZWwuZ2V0VGVybWluYWwoYS5jZWxsLCExKSYmbnVsbD09ZHx8bnVsbD09ZCYmbnVsbD09Yi5nZXRUZXJtaW5hbFBvaW50KCExKT90aGlzLmNsZWFyKGEuY2VsbCwhMCk6KHRoaXMudXBkYXRlRml4ZWRUZXJtaW5hbFBvaW50cyhhLGMsZCksdGhpcy51cGRhdGVQb2ludHMoYSxiLnBvaW50cyxjLGQpLHRoaXMudXBkYXRlRmxvYXRpbmdUZXJtaW5hbFBvaW50cyhhLGMsZCksYz1hLmFic29sdXRlUG9pbnRzLGEuY2VsbCE9dGhpcy5jdXJyZW50Um9vdCYmKG51bGw9PWN8fDI+CmMubGVuZ3RofHxudWxsPT1jWzBdfHxudWxsPT1jW2MubGVuZ3RoLTFdKT90aGlzLmNsZWFyKGEuY2VsbCwhMCk6KHRoaXMudXBkYXRlRWRnZUJvdW5kcyhhKSx0aGlzLnVwZGF0ZUVkZ2VMYWJlbE9mZnNldChhKSkpfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnVwZGF0ZVZlcnRleExhYmVsT2Zmc2V0PWZ1bmN0aW9uKGEpe3ZhciBiPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9MQUJFTF9QT1NJVElPTixteENvbnN0YW50cy5BTElHTl9DRU5URVIpO2lmKGI9PW14Q29uc3RhbnRzLkFMSUdOX0xFRlQpYj1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfTEFCRUxfV0lEVEgsbnVsbCksYj1udWxsIT1iP2IqdGhpcy5zY2FsZTphLndpZHRoLGEuYWJzb2x1dGVPZmZzZXQueC09YjtlbHNlIGlmKGI9PW14Q29uc3RhbnRzLkFMSUdOX1JJR0hUKWEuYWJzb2x1dGVPZmZzZXQueCs9YS53aWR0aDtlbHNlIGlmKGI9PW14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUiYmKGI9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0xBQkVMX1dJRFRILG51bGwpLG51bGwhPWIpKXt2YXIgYz1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQUxJR04sCm14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUiksZD0wO2M9PW14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUj9kPS41OmM9PW14Q29uc3RhbnRzLkFMSUdOX1JJR0hUJiYoZD0xKTswIT1kJiYoYS5hYnNvbHV0ZU9mZnNldC54LT0oYip0aGlzLnNjYWxlLWEud2lkdGgpKmQpfWI9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1ZFUlRJQ0FMX0xBQkVMX1BPU0lUSU9OLG14Q29uc3RhbnRzLkFMSUdOX01JRERMRSk7Yj09bXhDb25zdGFudHMuQUxJR05fVE9QP2EuYWJzb2x1dGVPZmZzZXQueS09YS5oZWlnaHQ6Yj09bXhDb25zdGFudHMuQUxJR05fQk9UVE9NJiYoYS5hYnNvbHV0ZU9mZnNldC55Kz1hLmhlaWdodCl9O214R3JhcGhWaWV3LnByb3RvdHlwZS5yZXNldFZhbGlkYXRpb25TdGF0ZT1mdW5jdGlvbigpe3RoaXMubGFzdEZvcmVncm91bmRIdG1sTm9kZT10aGlzLmxhc3RGb3JlZ3JvdW5kTm9kZT10aGlzLmxhc3RIdG1sTm9kZT10aGlzLmxhc3ROb2RlPW51bGx9OwpteEdyYXBoVmlldy5wcm90b3R5cGUuc3RhdGVWYWxpZGF0ZWQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmlzRWRnZShhLmNlbGwpJiZ0aGlzLmdyYXBoLmtlZXBFZGdlc0luRm9yZWdyb3VuZHx8dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmlzVmVydGV4KGEuY2VsbCkmJnRoaXMuZ3JhcGgua2VlcEVkZ2VzSW5CYWNrZ3JvdW5kO2E9dGhpcy5ncmFwaC5jZWxsUmVuZGVyZXIuaW5zZXJ0U3RhdGVBZnRlcihhLGI/dGhpcy5sYXN0Rm9yZWdyb3VuZE5vZGV8fHRoaXMubGFzdE5vZGU6dGhpcy5sYXN0Tm9kZSxiP3RoaXMubGFzdEZvcmVncm91bmRIdG1sTm9kZXx8dGhpcy5sYXN0SHRtbE5vZGU6dGhpcy5sYXN0SHRtbE5vZGUpO2I/KHRoaXMubGFzdEZvcmVncm91bmRIdG1sTm9kZT1hWzFdLHRoaXMubGFzdEZvcmVncm91bmROb2RlPWFbMF0pOih0aGlzLmxhc3RIdG1sTm9kZT1hWzFdLHRoaXMubGFzdE5vZGU9YVswXSl9OwpteEdyYXBoVmlldy5wcm90b3R5cGUudXBkYXRlRml4ZWRUZXJtaW5hbFBvaW50cz1mdW5jdGlvbihhLGIsYyl7dGhpcy51cGRhdGVGaXhlZFRlcm1pbmFsUG9pbnQoYSxiLCEwLHRoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvbkNvbnN0cmFpbnQoYSxiLCEwKSk7dGhpcy51cGRhdGVGaXhlZFRlcm1pbmFsUG9pbnQoYSxjLCExLHRoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvbkNvbnN0cmFpbnQoYSxjLCExKSl9O214R3JhcGhWaWV3LnByb3RvdHlwZS51cGRhdGVGaXhlZFRlcm1pbmFsUG9pbnQ9ZnVuY3Rpb24oYSxiLGMsZCl7YS5zZXRBYnNvbHV0ZVRlcm1pbmFsUG9pbnQodGhpcy5nZXRGaXhlZFRlcm1pbmFsUG9pbnQoYSxiLGMsZCksYyl9OwpteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0Rml4ZWRUZXJtaW5hbFBvaW50PWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPW51bGw7bnVsbCE9ZCYmKGU9dGhpcy5ncmFwaC5nZXRDb25uZWN0aW9uUG9pbnQoYixkLCExKSk7aWYobnVsbD09ZSYmbnVsbD09Yil7Yj10aGlzLnNjYWxlO2Q9dGhpcy50cmFuc2xhdGU7dmFyIGY9YS5vcmlnaW4sZT10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShhLmNlbGwpLmdldFRlcm1pbmFsUG9pbnQoYyk7bnVsbCE9ZSYmKGU9bmV3IG14UG9pbnQoYiooZC54K2UueCtmLngpLGIqKGQueStlLnkrZi55KSkpfXJldHVybiBlfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnVwZGF0ZUJvdW5kc0Zyb21TdGVuY2lsPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7aWYobnVsbCE9YSYmbnVsbCE9YS5zaGFwZSYmbnVsbCE9YS5zaGFwZS5zdGVuY2lsJiYiZml4ZWQiPT1hLnNoYXBlLnN0ZW5jaWwuYXNwZWN0KXt2YXIgYj1teFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlKGEpLGM9YS5zaGFwZS5zdGVuY2lsLmNvbXB1dGVBc3BlY3QoYS5zdHlsZSxhLngsYS55LGEud2lkdGgsYS5oZWlnaHQpO2Euc2V0UmVjdChjLngsYy55LGEuc2hhcGUuc3RlbmNpbC53MCpjLndpZHRoLGEuc2hhcGUuc3RlbmNpbC5oMCpjLmhlaWdodCl9cmV0dXJuIGJ9OwpteEdyYXBoVmlldy5wcm90b3R5cGUudXBkYXRlUG9pbnRzPWZ1bmN0aW9uKGEsYixjLGQpe2lmKG51bGwhPWEpe3ZhciBlPVtdO2UucHVzaChhLmFic29sdXRlUG9pbnRzWzBdKTt2YXIgZj10aGlzLmdldEVkZ2VTdHlsZShhLGIsYyxkKTtpZihudWxsIT1mKXtjPXRoaXMuZ2V0VGVybWluYWxQb3J0KGEsYywhMCk7ZD10aGlzLmdldFRlcm1pbmFsUG9ydChhLGQsITEpO3ZhciBnPXRoaXMudXBkYXRlQm91bmRzRnJvbVN0ZW5jaWwoYyksaz10aGlzLnVwZGF0ZUJvdW5kc0Zyb21TdGVuY2lsKGQpO2YoYSxjLGQsYixlKTtudWxsIT1nJiZjLnNldFJlY3QoZy54LGcueSxnLndpZHRoLGcuaGVpZ2h0KTtudWxsIT1rJiZkLnNldFJlY3Qoay54LGsueSxrLndpZHRoLGsuaGVpZ2h0KX1lbHNlIGlmKG51bGwhPWIpZm9yKGY9MDtmPGIubGVuZ3RoO2YrKyludWxsIT1iW2ZdJiYoYz1teFV0aWxzLmNsb25lKGJbZl0pLGUucHVzaCh0aGlzLnRyYW5zZm9ybUNvbnRyb2xQb2ludChhLGMpKSk7Yj0KYS5hYnNvbHV0ZVBvaW50cztlLnB1c2goYltiLmxlbmd0aC0xXSk7YS5hYnNvbHV0ZVBvaW50cz1lfX07bXhHcmFwaFZpZXcucHJvdG90eXBlLnRyYW5zZm9ybUNvbnRyb2xQb2ludD1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIG51bGwhPWEmJm51bGwhPWI/KGE9YS5vcmlnaW4sYz1jPzE6dGhpcy5zY2FsZSxuZXcgbXhQb2ludChjKihiLngrdGhpcy50cmFuc2xhdGUueCthLngpLGMqKGIueSt0aGlzLnRyYW5zbGF0ZS55K2EueSkpKTpudWxsfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLmlzTG9vcFN0eWxlRW5hYmxlZD1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLmdyYXBoLmdldENvbm5lY3Rpb25Db25zdHJhaW50KGEsYywhMCksZj10aGlzLmdyYXBoLmdldENvbm5lY3Rpb25Db25zdHJhaW50KGEsZCwhMSk7cmV0dXJuIShudWxsPT1ifHwyPmIubGVuZ3RoKXx8bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX09SVEhPR09OQUxfTE9PUCwhMSkmJihudWxsIT1lJiZudWxsIT1lLnBvaW50fHxudWxsIT1mJiZudWxsIT1mLnBvaW50KT8hMTpudWxsIT1jJiZjPT1kfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLmdldEVkZ2VTdHlsZT1mdW5jdGlvbihhLGIsYyxkKXthPXRoaXMuaXNMb29wU3R5bGVFbmFibGVkKGEsYixjLGQpP214VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9MT09QLHRoaXMuZ3JhcGguZGVmYXVsdExvb3BTdHlsZSk6bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX05PRURHRVNUWUxFLCExKT9udWxsOmEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRURHRV07InN0cmluZyI9PXR5cGVvZiBhJiYoYj1teFN0eWxlUmVnaXN0cnkuZ2V0VmFsdWUoYSksbnVsbD09YiYmdGhpcy5pc0FsbG93RXZhbCgpJiYoYj1teFV0aWxzLmV2YWwoYSkpLGE9Yik7cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIGE/YTpudWxsfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnVwZGF0ZUZsb2F0aW5nVGVybWluYWxQb2ludHM9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWEuYWJzb2x1dGVQb2ludHMsZT1kWzBdO251bGw9PWRbZC5sZW5ndGgtMV0mJm51bGwhPWMmJnRoaXMudXBkYXRlRmxvYXRpbmdUZXJtaW5hbFBvaW50KGEsYyxiLCExKTtudWxsPT1lJiZudWxsIT1iJiZ0aGlzLnVwZGF0ZUZsb2F0aW5nVGVybWluYWxQb2ludChhLGIsYywhMCl9O214R3JhcGhWaWV3LnByb3RvdHlwZS51cGRhdGVGbG9hdGluZ1Rlcm1pbmFsUG9pbnQ9ZnVuY3Rpb24oYSxiLGMsZCl7YS5zZXRBYnNvbHV0ZVRlcm1pbmFsUG9pbnQodGhpcy5nZXRGbG9hdGluZ1Rlcm1pbmFsUG9pbnQoYSxiLGMsZCksZCl9OwpteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0RmxvYXRpbmdUZXJtaW5hbFBvaW50PWZ1bmN0aW9uKGEsYixjLGQpe2I9dGhpcy5nZXRUZXJtaW5hbFBvcnQoYSxiLGQpO3ZhciBlPXRoaXMuZ2V0TmV4dFBvaW50KGEsYyxkKSxmPXRoaXMuZ3JhcGguaXNPcnRob2dvbmFsKGEpO2M9bXhVdGlscy50b1JhZGlhbnMoTnVtYmVyKGIuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT05dfHwiMCIpKTt2YXIgZz1uZXcgbXhQb2ludChiLmdldENlbnRlclgoKSxiLmdldENlbnRlclkoKSk7aWYoMCE9Yyl2YXIgaz1NYXRoLmNvcygtYyksbD1NYXRoLnNpbigtYyksZT1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChlLGssbCxnKTtrPXBhcnNlRmxvYXQoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9QRVJJTUVURVJfU1BBQ0lOR118fDApO2srPXBhcnNlRmxvYXQoYS5zdHlsZVtkP214Q29uc3RhbnRzLlNUWUxFX1NPVVJDRV9QRVJJTUVURVJfU1BBQ0lORzpteENvbnN0YW50cy5TVFlMRV9UQVJHRVRfUEVSSU1FVEVSX1NQQUNJTkddfHwKMCk7YT10aGlzLmdldFBlcmltZXRlclBvaW50KGIsZSwwPT1jJiZmLGspOzAhPWMmJihrPU1hdGguY29zKGMpLGw9TWF0aC5zaW4oYyksYT1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChhLGssbCxnKSk7cmV0dXJuIGF9O214R3JhcGhWaWV3LnByb3RvdHlwZS5nZXRUZXJtaW5hbFBvcnQ9ZnVuY3Rpb24oYSxiLGMpe2E9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLGM/bXhDb25zdGFudHMuU1RZTEVfU09VUkNFX1BPUlQ6bXhDb25zdGFudHMuU1RZTEVfVEFSR0VUX1BPUlQpO251bGwhPWEmJihhPXRoaXMuZ2V0U3RhdGUodGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldENlbGwoYSkpLG51bGwhPWEmJihiPWEpKTtyZXR1cm4gYn07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5nZXRQZXJpbWV0ZXJQb2ludD1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1udWxsO2lmKG51bGwhPWEpe3ZhciBmPXRoaXMuZ2V0UGVyaW1ldGVyRnVuY3Rpb24oYSk7aWYobnVsbCE9ZiYmbnVsbCE9YiYmKGQ9dGhpcy5nZXRQZXJpbWV0ZXJCb3VuZHMoYSxkKSwwPGQud2lkdGh8fDA8ZC5oZWlnaHQpKXt2YXIgZT1uZXcgbXhQb2ludChiLngsYi55KSxnPWI9ITE7dGhpcy5ncmFwaC5tb2RlbC5pc1ZlcnRleChhLmNlbGwpJiYoYj0xPT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRkxJUEgsMCksZz0xPT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRkxJUFYsMCksbnVsbCE9YS5zaGFwZSYmbnVsbCE9YS5zaGFwZS5zdGVuY2lsJiYoYj0xPT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsInN0ZW5jaWxGbGlwSCIsMCl8fGIsZz0xPT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsInN0ZW5jaWxGbGlwViIsCjApfHxnKSxiJiYoZS54PTIqZC5nZXRDZW50ZXJYKCktZS54KSxnJiYoZS55PTIqZC5nZXRDZW50ZXJZKCktZS55KSk7ZT1mKGQsYSxlLGMpO251bGwhPWUmJihiJiYoZS54PTIqZC5nZXRDZW50ZXJYKCktZS54KSxnJiYoZS55PTIqZC5nZXRDZW50ZXJZKCktZS55KSl9bnVsbD09ZSYmKGU9dGhpcy5nZXRQb2ludChhKSl9cmV0dXJuIGV9O214R3JhcGhWaWV3LnByb3RvdHlwZS5nZXRSb3V0aW5nQ2VudGVyWD1mdW5jdGlvbihhKXt2YXIgYj1udWxsIT1hLnN0eWxlP3BhcnNlRmxvYXQoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1VUSU5HX0NFTlRFUl9YXSl8fDA6MDtyZXR1cm4gYS5nZXRDZW50ZXJYKCkrYiphLndpZHRofTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLmdldFJvdXRpbmdDZW50ZXJZPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGwhPWEuc3R5bGU/cGFyc2VGbG9hdChhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1JPVVRJTkdfQ0VOVEVSX1ldKXx8MDowO3JldHVybiBhLmdldENlbnRlclkoKStiKmEuaGVpZ2h0fTtteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0UGVyaW1ldGVyQm91bmRzPWZ1bmN0aW9uKGEsYil7Yj1udWxsIT1iP2I6MDtudWxsIT1hJiYoYis9cGFyc2VGbG9hdChhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1BFUklNRVRFUl9TUEFDSU5HXXx8MCkpO3JldHVybiBhLmdldFBlcmltZXRlckJvdW5kcyhiKnRoaXMuc2NhbGUpfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLmdldFBlcmltZXRlckZ1bmN0aW9uPWZ1bmN0aW9uKGEpe2E9YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9QRVJJTUVURVJdO2lmKCJzdHJpbmciPT10eXBlb2YgYSl7dmFyIGI9bXhTdHlsZVJlZ2lzdHJ5LmdldFZhbHVlKGEpO251bGw9PWImJnRoaXMuaXNBbGxvd0V2YWwoKSYmKGI9bXhVdGlscy5ldmFsKGEpKTthPWJ9cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIGE/YTpudWxsfTtteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0TmV4dFBvaW50PWZ1bmN0aW9uKGEsYixjKXthPWEuYWJzb2x1dGVQb2ludHM7dmFyIGQ9bnVsbDtudWxsIT1hJiYyPD1hLmxlbmd0aCYmKGQ9YS5sZW5ndGgsZD1hW2M/TWF0aC5taW4oMSxkLTEpOk1hdGgubWF4KDAsZC0yKV0pO251bGw9PWQmJm51bGwhPWImJihkPW5ldyBteFBvaW50KGIuZ2V0Q2VudGVyWCgpLGIuZ2V0Q2VudGVyWSgpKSk7cmV0dXJuIGR9OwpteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0VmlzaWJsZVRlcm1pbmFsPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxkPWMuZ2V0VGVybWluYWwoYSxiKSxlPWQ7bnVsbCE9ZCYmZCE9dGhpcy5jdXJyZW50Um9vdDspe2lmKCF0aGlzLmdyYXBoLmlzQ2VsbFZpc2libGUoZSl8fHRoaXMuaXNDZWxsQ29sbGFwc2VkKGQpKWU9ZDtkPWMuZ2V0UGFyZW50KGQpfW51bGw9PWV8fGMuY29udGFpbnMoZSkmJmMuZ2V0UGFyZW50KGUpIT1jLmdldFJvb3QoKSYmZSE9dGhpcy5jdXJyZW50Um9vdHx8KGU9bnVsbCk7cmV0dXJuIGV9OwpteEdyYXBoVmlldy5wcm90b3R5cGUudXBkYXRlRWRnZUJvdW5kcz1mdW5jdGlvbihhKXt2YXIgYj1hLmFic29sdXRlUG9pbnRzLGM9YlswXSxkPWJbYi5sZW5ndGgtMV07aWYoYy54IT1kLnh8fGMueSE9ZC55KXt2YXIgZT1kLngtYy54LGY9ZC55LWMueTthLnRlcm1pbmFsRGlzdGFuY2U9TWF0aC5zcXJ0KGUqZStmKmYpfWVsc2UgYS50ZXJtaW5hbERpc3RhbmNlPTA7dmFyIGQ9MCxnPVtdLGY9YztpZihudWxsIT1mKXtmb3IodmFyIGM9Zi54LGs9Zi55LGw9YyxtPWssbj0xO248Yi5sZW5ndGg7bisrKXt2YXIgcD1iW25dO251bGwhPXAmJihlPWYueC1wLngsZj1mLnktcC55LGU9TWF0aC5zcXJ0KGUqZStmKmYpLGcucHVzaChlKSxkKz1lLGY9cCxjPU1hdGgubWluKGYueCxjKSxrPU1hdGgubWluKGYueSxrKSxsPU1hdGgubWF4KGYueCxsKSxtPU1hdGgubWF4KGYueSxtKSl9YS5sZW5ndGg9ZDthLnNlZ21lbnRzPWc7YS54PWM7YS55PWs7YS53aWR0aD1NYXRoLm1heCgxLGwtYyk7YS5oZWlnaHQ9Ck1hdGgubWF4KDEsbS1rKX19OwpteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0UG9pbnQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmdldENlbnRlclgoKSxkPWEuZ2V0Q2VudGVyWSgpO2lmKG51bGw9PWEuc2VnbWVudHN8fG51bGwhPWImJiFiLnJlbGF0aXZlKW51bGwhPWImJihtPWIub2Zmc2V0LG51bGwhPW0mJihjKz1tLngsZCs9bS55KSk7ZWxzZXtmb3IodmFyIGU9YS5hYnNvbHV0ZVBvaW50cy5sZW5ndGgsZj1NYXRoLnJvdW5kKCgobnVsbCE9Yj9iLngvMjowKSsuNSkqYS5sZW5ndGgpLGc9YS5zZWdtZW50c1swXSxrPTAsbD0xO2Y+PU1hdGgucm91bmQoaytnKSYmbDxlLTE7KWsrPWcsZz1hLnNlZ21lbnRzW2wrK107ZT0wPT1nPzA6KGYtaykvZztmPWEuYWJzb2x1dGVQb2ludHNbbC0xXTtsPWEuYWJzb2x1dGVQb2ludHNbbF07aWYobnVsbCE9ZiYmbnVsbCE9bCl7az1jPWQ9MDtpZihudWxsIT1iKXt2YXIgZD1iLnksbT1iLm9mZnNldDtudWxsIT1tJiYoYz1tLngsaz1tLnkpfW09bC54LWYueDtsPWwueS1mLnk7Yz0KZi54K20qZSsoKDA9PWc/MDpsL2cpKmQrYykqdGhpcy5zY2FsZTtkPWYueStsKmUtKCgwPT1nPzA6bS9nKSpkLWspKnRoaXMuc2NhbGV9fXJldHVybiBuZXcgbXhQb2ludChjLGQpfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLmdldFJlbGF0aXZlUG9pbnQ9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5nZXRHZW9tZXRyeShhLmNlbGwpO2lmKG51bGwhPWQpe3ZhciBlPWEuYWJzb2x1dGVQb2ludHMubGVuZ3RoO2lmKGQucmVsYXRpdmUmJjE8ZSl7Zm9yKHZhciBkPWEubGVuZ3RoLGY9YS5zZWdtZW50cyxnPWEuYWJzb2x1dGVQb2ludHNbMF0saz1hLmFic29sdXRlUG9pbnRzWzFdLGw9bXhVdGlscy5wdFNlZ0Rpc3RTcShnLngsZy55LGsueCxrLnksYixjKSxtPTAsbj0wLHA9MCxxPTI7cTxlO3ErKyluKz1mW3EtMl0saz1hLmFic29sdXRlUG9pbnRzW3FdLGc9bXhVdGlscy5wdFNlZ0Rpc3RTcShnLngsZy55LGsueCxrLnksYixjKSxnPD1sJiYobD1nLG09cS0xLHA9biksZz1rO2U9ZlttXTtnPWEuYWJzb2x1dGVQb2ludHNbbV07az1hLmFic29sdXRlUG9pbnRzW20rMV07bD1rLng7Zj1rLnk7YT1nLngtbDttPWcueS1mO2Y9KGEtKGItbCkpKgphKyhtLShjLWYpKSptO2E9TWF0aC5zcXJ0KDA+PWY/MDpmKmYvKGEqYSttKm0pKTthPmUmJihhPWUpO2U9TWF0aC5zcXJ0KG14VXRpbHMucHRTZWdEaXN0U3EoZy54LGcueSxrLngsay55LGIsYykpOy0xPT1teFV0aWxzLnJlbGF0aXZlQ2N3KGcueCxnLnksay54LGsueSxiLGMpJiYoZT0tZSk7cmV0dXJuIG5ldyBteFBvaW50KChkLzItcC1hKS9kKi0yLGUvdGhpcy5zY2FsZSl9fXJldHVybiBuZXcgbXhQb2ludH07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS51cGRhdGVFZGdlTGFiZWxPZmZzZXQ9ZnVuY3Rpb24oYSl7dmFyIGI9YS5hYnNvbHV0ZVBvaW50czthLmFic29sdXRlT2Zmc2V0Lng9YS5nZXRDZW50ZXJYKCk7YS5hYnNvbHV0ZU9mZnNldC55PWEuZ2V0Q2VudGVyWSgpO2lmKG51bGwhPWImJjA8Yi5sZW5ndGgmJm51bGwhPWEuc2VnbWVudHMpe3ZhciBjPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGEuY2VsbCk7aWYoYy5yZWxhdGl2ZSl7dmFyIGQ9dGhpcy5nZXRQb2ludChhLGMpO251bGwhPWQmJihhLmFic29sdXRlT2Zmc2V0PWQpfWVsc2V7dmFyIGQ9YlswXSxlPWJbYi5sZW5ndGgtMV07aWYobnVsbCE9ZCYmbnVsbCE9ZSl7dmFyIGI9ZS54LWQueCxmPWUueS1kLnksZz1lPTAsYz1jLm9mZnNldDtudWxsIT1jJiYoZT1jLngsZz1jLnkpO2M9ZC55K2YvMitnKnRoaXMuc2NhbGU7YS5hYnNvbHV0ZU9mZnNldC54PWQueCtiLzIrZSp0aGlzLnNjYWxlO2EuYWJzb2x1dGVPZmZzZXQueT1jfX19fTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLmdldFN0YXRlPWZ1bmN0aW9uKGEsYil7Yj1ifHwhMTt2YXIgYz1udWxsO251bGwhPWEmJihjPXRoaXMuc3RhdGVzLmdldChhKSxiJiYobnVsbD09Y3x8dGhpcy51cGRhdGVTdHlsZSkmJnRoaXMuZ3JhcGguaXNDZWxsVmlzaWJsZShhKSYmKG51bGw9PWM/KGM9dGhpcy5jcmVhdGVTdGF0ZShhKSx0aGlzLnN0YXRlcy5wdXQoYSxjKSk6Yy5zdHlsZT10aGlzLmdyYXBoLmdldENlbGxTdHlsZShhKSkpO3JldHVybiBjfTtteEdyYXBoVmlldy5wcm90b3R5cGUuaXNSZW5kZXJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZW5kZXJpbmd9O214R3JhcGhWaWV3LnByb3RvdHlwZS5zZXRSZW5kZXJpbmc9ZnVuY3Rpb24oYSl7dGhpcy5yZW5kZXJpbmc9YX07bXhHcmFwaFZpZXcucHJvdG90eXBlLmlzQWxsb3dFdmFsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWxsb3dFdmFsfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnNldEFsbG93RXZhbD1mdW5jdGlvbihhKXt0aGlzLmFsbG93RXZhbD1hfTtteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0U3RhdGVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdGVzfTtteEdyYXBoVmlldy5wcm90b3R5cGUuc2V0U3RhdGVzPWZ1bmN0aW9uKGEpe3RoaXMuc3RhdGVzPWF9O214R3JhcGhWaWV3LnByb3RvdHlwZS5nZXRDZWxsU3RhdGVzPWZ1bmN0aW9uKGEpe2lmKG51bGw9PWEpcmV0dXJuIHRoaXMuc3RhdGVzO2Zvcih2YXIgYj1bXSxjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBkPXRoaXMuZ2V0U3RhdGUoYVtjXSk7bnVsbCE9ZCYmYi5wdXNoKGQpfXJldHVybiBifTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnJlbW92ZVN0YXRlPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7bnVsbCE9YSYmKGI9dGhpcy5zdGF0ZXMucmVtb3ZlKGEpLG51bGwhPWImJih0aGlzLmdyYXBoLmNlbGxSZW5kZXJlci5kZXN0cm95KGIpLGIuaW52YWxpZD0hMCxiLmRlc3Ryb3koKSkpO3JldHVybiBifTtteEdyYXBoVmlldy5wcm90b3R5cGUuY3JlYXRlU3RhdGU9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBteENlbGxTdGF0ZSh0aGlzLGEsdGhpcy5ncmFwaC5nZXRDZWxsU3R5bGUoYSkpfTtteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0Q2FudmFzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2FudmFzfTtteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0QmFja2dyb3VuZFBhbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYWNrZ3JvdW5kUGFuZX07bXhHcmFwaFZpZXcucHJvdG90eXBlLmdldERyYXdQYW5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZHJhd1BhbmV9OwpteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0T3ZlcmxheVBhbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vdmVybGF5UGFuZX07bXhHcmFwaFZpZXcucHJvdG90eXBlLmdldERlY29yYXRvclBhbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWNvcmF0b3JQYW5lfTtteEdyYXBoVmlldy5wcm90b3R5cGUuaXNDb250YWluZXJFdmVudD1mdW5jdGlvbihhKXthPW14RXZlbnQuZ2V0U291cmNlKGEpO3JldHVybiBhPT10aGlzLmdyYXBoLmNvbnRhaW5lcnx8YS5wYXJlbnROb2RlPT10aGlzLmJhY2tncm91bmRQYW5lfHxudWxsIT1hLnBhcmVudE5vZGUmJmEucGFyZW50Tm9kZS5wYXJlbnROb2RlPT10aGlzLmJhY2tncm91bmRQYW5lfHxhPT10aGlzLmNhbnZhcy5wYXJlbnROb2RlfHxhPT10aGlzLmNhbnZhc3x8YT09dGhpcy5iYWNrZ3JvdW5kUGFuZXx8YT09dGhpcy5kcmF3UGFuZXx8YT09dGhpcy5vdmVybGF5UGFuZXx8YT09dGhpcy5kZWNvcmF0b3JQYW5lfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLmlzU2Nyb2xsRXZlbnQ9ZnVuY3Rpb24oYSl7dmFyIGI9bXhVdGlscy5nZXRPZmZzZXQodGhpcy5ncmFwaC5jb250YWluZXIpO2E9bmV3IG14UG9pbnQoYS5jbGllbnRYLWIueCxhLmNsaWVudFktYi55KTt2YXIgYj10aGlzLmdyYXBoLmNvbnRhaW5lci5vZmZzZXRXaWR0aCxjPXRoaXMuZ3JhcGguY29udGFpbmVyLmNsaWVudFdpZHRoO2lmKGI+YyYmYS54PmMrMiYmYS54PD1iKXJldHVybiEwO2I9dGhpcy5ncmFwaC5jb250YWluZXIub2Zmc2V0SGVpZ2h0O2M9dGhpcy5ncmFwaC5jb250YWluZXIuY2xpZW50SGVpZ2h0O3JldHVybiBiPmMmJmEueT5jKzImJmEueTw9Yj8hMDohMX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7dGhpcy5pbnN0YWxsTGlzdGVuZXJzKCk7dmFyIGE9dGhpcy5ncmFwaDthLmRpYWxlY3Q9PW14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHP3RoaXMuY3JlYXRlU3ZnKCk6YS5kaWFsZWN0PT1teENvbnN0YW50cy5ESUFMRUNUX1ZNTD90aGlzLmNyZWF0ZVZtbCgpOnRoaXMuY3JlYXRlSHRtbCgpfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLmluc3RhbGxMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoLGI9YS5jb250YWluZXI7aWYobnVsbCE9Yil7bXhDbGllbnQuSVNfVE9VQ0gmJihteEV2ZW50LmFkZExpc3RlbmVyKGIsImdlc3R1cmVzdGFydCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7YS5maXJlR2VzdHVyZUV2ZW50KGIpO214RXZlbnQuY29uc3VtZShiKX0pKSxteEV2ZW50LmFkZExpc3RlbmVyKGIsImdlc3R1cmVjaGFuZ2UiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe2EuZmlyZUdlc3R1cmVFdmVudChiKTtteEV2ZW50LmNvbnN1bWUoYil9KSksbXhFdmVudC5hZGRMaXN0ZW5lcihiLCJnZXN0dXJlZW5kIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXthLmZpcmVHZXN0dXJlRXZlbnQoYik7bXhFdmVudC5jb25zdW1lKGIpfSkpKTtteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnMoYixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXshdGhpcy5pc0NvbnRhaW5lckV2ZW50KGIpfHwKKG14Q2xpZW50LklTX0lFfHxteENsaWVudC5JU19JRTExfHxteENsaWVudC5JU19HQ3x8bXhDbGllbnQuSVNfT1B8fG14Q2xpZW50LklTX1NGKSYmdGhpcy5pc1Njcm9sbEV2ZW50KGIpfHxhLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfRE9XTixuZXcgbXhNb3VzZUV2ZW50KGIpKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3RoaXMuaXNDb250YWluZXJFdmVudChiKSYmYS5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX01PVkUsbmV3IG14TW91c2VFdmVudChiKSl9KSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXt0aGlzLmlzQ29udGFpbmVyRXZlbnQoYikmJmEuZmlyZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9VUCxuZXcgbXhNb3VzZUV2ZW50KGIpKX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKGIsImRibGNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXt0aGlzLmlzQ29udGFpbmVyRXZlbnQoYikmJmEuZGJsQ2xpY2soYil9KSk7CnZhciBjPWZ1bmN0aW9uKGMpe3ZhciBkPW51bGw7bXhDbGllbnQuSVNfVE9VQ0gmJihkPW14RXZlbnQuZ2V0Q2xpZW50WChjKSxjPW14RXZlbnQuZ2V0Q2xpZW50WShjKSxjPW14VXRpbHMuY29udmVydFBvaW50KGIsZCxjKSxkPWEudmlldy5nZXRTdGF0ZShhLmdldENlbGxBdChjLngsYy55KSkpO3JldHVybiBkfTthLmFkZE1vdXNlTGlzdGVuZXIoe21vdXNlRG93bjpmdW5jdGlvbihiLGMpe2EucG9wdXBNZW51SGFuZGxlci5oaWRlTWVudSgpfSxtb3VzZU1vdmU6ZnVuY3Rpb24oKXt9LG1vdXNlVXA6ZnVuY3Rpb24oKXt9fSk7dGhpcy5tb3ZlSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXtudWxsIT1hLnRvb2x0aXBIYW5kbGVyJiZhLnRvb2x0aXBIYW5kbGVyLmlzSGlkZU9uSG92ZXIoKSYmYS50b29sdGlwSGFuZGxlci5oaWRlKCk7dGhpcy5jYXB0dXJlRG9jdW1lbnRHZXN0dXJlJiZhLmlzTW91c2VEb3duJiZudWxsIT1hLmNvbnRhaW5lciYmIXRoaXMuaXNDb250YWluZXJFdmVudChiKSYmCiJub25lIiE9YS5jb250YWluZXIuc3R5bGUuZGlzcGxheSYmImhpZGRlbiIhPWEuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkmJiFteEV2ZW50LmlzQ29uc3VtZWQoYikmJmEuZmlyZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9NT1ZFLG5ldyBteE1vdXNlRXZlbnQoYixjKGIpKSl9KTt0aGlzLmVuZEhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7dGhpcy5jYXB0dXJlRG9jdW1lbnRHZXN0dXJlJiZhLmlzTW91c2VEb3duJiZudWxsIT1hLmNvbnRhaW5lciYmIXRoaXMuaXNDb250YWluZXJFdmVudChiKSYmIm5vbmUiIT1hLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5JiYiaGlkZGVuIiE9YS5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSYmYS5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX1VQLG5ldyBteE1vdXNlRXZlbnQoYikpfSk7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKGRvY3VtZW50LG51bGwsdGhpcy5tb3ZlSGFuZGxlcix0aGlzLmVuZEhhbmRsZXIpfX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5jcmVhdGVIdG1sPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5ncmFwaC5jb250YWluZXI7bnVsbCE9YSYmKHRoaXMuY2FudmFzPXRoaXMuY3JlYXRlSHRtbFBhbmUoIjEwMCUiLCIxMDAlIiksdGhpcy5jYW52YXMuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiIsdGhpcy5iYWNrZ3JvdW5kUGFuZT10aGlzLmNyZWF0ZUh0bWxQYW5lKCIxcHgiLCIxcHgiKSx0aGlzLmRyYXdQYW5lPXRoaXMuY3JlYXRlSHRtbFBhbmUoIjFweCIsIjFweCIpLHRoaXMub3ZlcmxheVBhbmU9dGhpcy5jcmVhdGVIdG1sUGFuZSgiMXB4IiwiMXB4IiksdGhpcy5kZWNvcmF0b3JQYW5lPXRoaXMuY3JlYXRlSHRtbFBhbmUoIjFweCIsIjFweCIpLHRoaXMuY2FudmFzLmFwcGVuZENoaWxkKHRoaXMuYmFja2dyb3VuZFBhbmUpLHRoaXMuY2FudmFzLmFwcGVuZENoaWxkKHRoaXMuZHJhd1BhbmUpLHRoaXMuY2FudmFzLmFwcGVuZENoaWxkKHRoaXMub3ZlcmxheVBhbmUpLHRoaXMuY2FudmFzLmFwcGVuZENoaWxkKHRoaXMuZGVjb3JhdG9yUGFuZSksCmEuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpLHRoaXMudXBkYXRlQ29udGFpbmVyU3R5bGUoYSksbXhDbGllbnQuSVNfUVVJUktTJiYoYT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXthPXRoaXMuZ2V0R3JhcGhCb3VuZHMoKTt0aGlzLnVwZGF0ZUh0bWxDYW52YXNTaXplKGEueCthLndpZHRoK3RoaXMuZ3JhcGguYm9yZGVyLGEueSthLmhlaWdodCt0aGlzLmdyYXBoLmJvcmRlcil9KSxteEV2ZW50LmFkZExpc3RlbmVyKHdpbmRvdywicmVzaXplIixhKSkpfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnVwZGF0ZUh0bWxDYW52YXNTaXplPWZ1bmN0aW9uKGEsYil7aWYobnVsbCE9dGhpcy5ncmFwaC5jb250YWluZXIpe3ZhciBjPXRoaXMuZ3JhcGguY29udGFpbmVyLm9mZnNldEhlaWdodDt0aGlzLmNhbnZhcy5zdHlsZS53aWR0aD10aGlzLmdyYXBoLmNvbnRhaW5lci5vZmZzZXRXaWR0aDxhP2ErInB4IjoiMTAwJSI7dGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0PWM8Yj9iKyJweCI6IjEwMCUifX07bXhHcmFwaFZpZXcucHJvdG90eXBlLmNyZWF0ZUh0bWxQYW5lPWZ1bmN0aW9uKGEsYil7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiRElWIik7bnVsbCE9YSYmbnVsbCE9Yj8oYy5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiLGMuc3R5bGUubGVmdD0iMHB4IixjLnN0eWxlLnRvcD0iMHB4IixjLnN0eWxlLndpZHRoPWEsYy5zdHlsZS5oZWlnaHQ9Yik6Yy5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiO3JldHVybiBjfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLmNyZWF0ZVZtbD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ3JhcGguY29udGFpbmVyO2lmKG51bGwhPWEpe3ZhciBiPWEub2Zmc2V0V2lkdGgsYz1hLm9mZnNldEhlaWdodDt0aGlzLmNhbnZhcz10aGlzLmNyZWF0ZVZtbFBhbmUoYixjKTt0aGlzLmNhbnZhcy5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjt0aGlzLmJhY2tncm91bmRQYW5lPXRoaXMuY3JlYXRlVm1sUGFuZShiLGMpO3RoaXMuZHJhd1BhbmU9dGhpcy5jcmVhdGVWbWxQYW5lKGIsYyk7dGhpcy5vdmVybGF5UGFuZT10aGlzLmNyZWF0ZVZtbFBhbmUoYixjKTt0aGlzLmRlY29yYXRvclBhbmU9dGhpcy5jcmVhdGVWbWxQYW5lKGIsYyk7dGhpcy5jYW52YXMuYXBwZW5kQ2hpbGQodGhpcy5iYWNrZ3JvdW5kUGFuZSk7dGhpcy5jYW52YXMuYXBwZW5kQ2hpbGQodGhpcy5kcmF3UGFuZSk7dGhpcy5jYW52YXMuYXBwZW5kQ2hpbGQodGhpcy5vdmVybGF5UGFuZSk7dGhpcy5jYW52YXMuYXBwZW5kQ2hpbGQodGhpcy5kZWNvcmF0b3JQYW5lKTsKYS5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyl9fTtteEdyYXBoVmlldy5wcm90b3R5cGUuY3JlYXRlVm1sUGFuZT1mdW5jdGlvbihhLGIpe3ZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobXhDbGllbnQuVk1MX1BSRUZJWCsiOmdyb3VwIik7Yy5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO2Muc3R5bGUubGVmdD0iMHB4IjtjLnN0eWxlLnRvcD0iMHB4IjtjLnN0eWxlLndpZHRoPWErInB4IjtjLnN0eWxlLmhlaWdodD1iKyJweCI7Yy5zZXRBdHRyaWJ1dGUoImNvb3Jkc2l6ZSIsYSsiLCIrYik7Yy5zZXRBdHRyaWJ1dGUoImNvb3Jkb3JpZ2luIiwiMCwwIik7cmV0dXJuIGN9OwpteEdyYXBoVmlldy5wcm90b3R5cGUuY3JlYXRlU3ZnPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5ncmFwaC5jb250YWluZXI7dGhpcy5jYW52YXM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG14Q29uc3RhbnRzLk5TX1NWRywiZyIpO3RoaXMuYmFja2dyb3VuZFBhbmU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG14Q29uc3RhbnRzLk5TX1NWRywiZyIpO3RoaXMuY2FudmFzLmFwcGVuZENoaWxkKHRoaXMuYmFja2dyb3VuZFBhbmUpO3RoaXMuZHJhd1BhbmU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG14Q29uc3RhbnRzLk5TX1NWRywiZyIpO3RoaXMuY2FudmFzLmFwcGVuZENoaWxkKHRoaXMuZHJhd1BhbmUpO3RoaXMub3ZlcmxheVBhbmU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG14Q29uc3RhbnRzLk5TX1NWRywiZyIpO3RoaXMuY2FudmFzLmFwcGVuZENoaWxkKHRoaXMub3ZlcmxheVBhbmUpO3RoaXMuZGVjb3JhdG9yUGFuZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobXhDb25zdGFudHMuTlNfU1ZHLAoiZyIpO3RoaXMuY2FudmFzLmFwcGVuZENoaWxkKHRoaXMuZGVjb3JhdG9yUGFuZSk7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG14Q29uc3RhbnRzLk5TX1NWRywic3ZnIik7Yi5zdHlsZS5sZWZ0PSIwcHgiO2Iuc3R5bGUudG9wPSIwcHgiO2Iuc3R5bGUud2lkdGg9IjEwMCUiO2Iuc3R5bGUuaGVpZ2h0PSIxMDAlIjtiLnN0eWxlLmRpc3BsYXk9ImJsb2NrIjtiLmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtpZihteENsaWVudC5JU19JRXx8bXhDbGllbnQuSVNfSUUxMSliLnN0eWxlLm92ZXJmbG93PSJoaWRkZW4iO251bGwhPWEmJihhLmFwcGVuZENoaWxkKGIpLHRoaXMudXBkYXRlQ29udGFpbmVyU3R5bGUoYSkpfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnVwZGF0ZUNvbnRhaW5lclN0eWxlPWZ1bmN0aW9uKGEpe3ZhciBiPW14VXRpbHMuZ2V0Q3VycmVudFN0eWxlKGEpO251bGwhPWImJiJzdGF0aWMiPT1iLnBvc2l0aW9uJiYoYS5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiKTtteENsaWVudC5JU19QT0lOVEVSJiYoYS5zdHlsZS50b3VjaEFjdGlvbj0ibm9uZSIpfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt2YXIgYT1udWxsIT10aGlzLmNhbnZhcz90aGlzLmNhbnZhcy5vd25lclNWR0VsZW1lbnQ6bnVsbDtudWxsPT1hJiYoYT10aGlzLmNhbnZhcyk7bnVsbCE9YSYmbnVsbCE9YS5wYXJlbnROb2RlJiYodGhpcy5jbGVhcih0aGlzLmN1cnJlbnRSb290LCEwKSxteEV2ZW50LnJlbW92ZUdlc3R1cmVMaXN0ZW5lcnMoZG9jdW1lbnQsbnVsbCx0aGlzLm1vdmVIYW5kbGVyLHRoaXMuZW5kSGFuZGxlciksbXhFdmVudC5yZWxlYXNlKHRoaXMuZ3JhcGguY29udGFpbmVyKSxhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSksdGhpcy5kZWNvcmF0b3JQYW5lPXRoaXMub3ZlcmxheVBhbmU9dGhpcy5kcmF3UGFuZT10aGlzLmJhY2tncm91bmRQYW5lPXRoaXMuY2FudmFzPXRoaXMuZW5kSGFuZGxlcj10aGlzLm1vdmVIYW5kbGVyPW51bGwpfTsKZnVuY3Rpb24gbXhDdXJyZW50Um9vdENoYW5nZShhLGIpe3RoaXMudmlldz1hO3RoaXMucHJldmlvdXM9dGhpcy5yb290PWI7dGhpcy5pc1VwPW51bGw9PWI7aWYoIXRoaXMuaXNVcClmb3IodmFyIGM9dGhpcy52aWV3LmN1cnJlbnRSb290LGQ9dGhpcy52aWV3LmdyYXBoLmdldE1vZGVsKCk7bnVsbCE9Yzspe2lmKGM9PWIpe3RoaXMuaXNVcD0hMDticmVha31jPWQuZ2V0UGFyZW50KGMpfX0KbXhDdXJyZW50Um9vdENoYW5nZS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMudmlldy5jdXJyZW50Um9vdDt0aGlzLnZpZXcuY3VycmVudFJvb3Q9dGhpcy5wcmV2aW91czt0aGlzLnByZXZpb3VzPWE7YT10aGlzLnZpZXcuZ3JhcGguZ2V0VHJhbnNsYXRlRm9yUm9vdCh0aGlzLnZpZXcuY3VycmVudFJvb3QpO251bGwhPWEmJih0aGlzLnZpZXcudHJhbnNsYXRlPW5ldyBteFBvaW50KC1hLngsLWEueSkpO3RoaXMuaXNVcD8odGhpcy52aWV3LmNsZWFyKHRoaXMudmlldy5jdXJyZW50Um9vdCwhMCksdGhpcy52aWV3LnZhbGlkYXRlKCkpOnRoaXMudmlldy5yZWZyZXNoKCk7dGhpcy52aWV3LmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCh0aGlzLmlzVXA/bXhFdmVudC5VUDpteEV2ZW50LkRPV04sInJvb3QiLHRoaXMudmlldy5jdXJyZW50Um9vdCwicHJldmlvdXMiLHRoaXMucHJldmlvdXMpKTt0aGlzLmlzVXA9IXRoaXMuaXNVcH07CmZ1bmN0aW9uIG14R3JhcGgoYSxiLGMsZCl7dGhpcy5tb3VzZUxpc3RlbmVycz1udWxsO3RoaXMucmVuZGVySGludD1jO3RoaXMuZGlhbGVjdD1teENsaWVudC5JU19TVkc/bXhDb25zdGFudHMuRElBTEVDVF9TVkc6Yz09bXhDb25zdGFudHMuUkVOREVSSU5HX0hJTlRfRVhBQ1QmJm14Q2xpZW50LklTX1ZNTD9teENvbnN0YW50cy5ESUFMRUNUX1ZNTDpjPT1teENvbnN0YW50cy5SRU5ERVJJTkdfSElOVF9GQVNURVNUP214Q29uc3RhbnRzLkRJQUxFQ1RfU1RSSUNUSFRNTDpjPT1teENvbnN0YW50cy5SRU5ERVJJTkdfSElOVF9GQVNURVI/bXhDb25zdGFudHMuRElBTEVDVF9QUkVGRVJIVE1MOm14Q29uc3RhbnRzLkRJQUxFQ1RfTUlYRURIVE1MO3RoaXMubW9kZWw9bnVsbCE9Yj9iOm5ldyBteEdyYXBoTW9kZWw7dGhpcy5tdWx0aXBsaWNpdGllcz1bXTt0aGlzLmltYWdlQnVuZGxlcz1bXTt0aGlzLmNlbGxSZW5kZXJlcj10aGlzLmNyZWF0ZUNlbGxSZW5kZXJlcigpO3RoaXMuc2V0U2VsZWN0aW9uTW9kZWwodGhpcy5jcmVhdGVTZWxlY3Rpb25Nb2RlbCgpKTsKdGhpcy5zZXRTdHlsZXNoZWV0KG51bGwhPWQ/ZDp0aGlzLmNyZWF0ZVN0eWxlc2hlZXQoKSk7dGhpcy52aWV3PXRoaXMuY3JlYXRlR3JhcGhWaWV3KCk7dGhpcy5ncmFwaE1vZGVsQ2hhbmdlTGlzdGVuZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiKXt0aGlzLmdyYXBoTW9kZWxDaGFuZ2VkKGIuZ2V0UHJvcGVydHkoImVkaXQiKS5jaGFuZ2VzKX0pO3RoaXMubW9kZWwuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsdGhpcy5ncmFwaE1vZGVsQ2hhbmdlTGlzdGVuZXIpO3RoaXMuY3JlYXRlSGFuZGxlcnMoKTtudWxsIT1hJiZ0aGlzLmluaXQoYSk7dGhpcy52aWV3LnJldmFsaWRhdGUoKX1teExvYWRSZXNvdXJjZXM/bXhSZXNvdXJjZXMuYWRkKG14Q2xpZW50LmJhc2VQYXRoKyIvcmVzb3VyY2VzL2dyYXBoIik6bXhDbGllbnQuZGVmYXVsdEJ1bmRsZXMucHVzaChteENsaWVudC5iYXNlUGF0aCsiL3Jlc291cmNlcy9ncmFwaCIpO214R3JhcGgucHJvdG90eXBlPW5ldyBteEV2ZW50U291cmNlOwpteEdyYXBoLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1teEdyYXBoO214R3JhcGgucHJvdG90eXBlLm1vdXNlTGlzdGVuZXJzPW51bGw7bXhHcmFwaC5wcm90b3R5cGUuaXNNb3VzZURvd249ITE7bXhHcmFwaC5wcm90b3R5cGUubW9kZWw9bnVsbDtteEdyYXBoLnByb3RvdHlwZS52aWV3PW51bGw7bXhHcmFwaC5wcm90b3R5cGUuc3R5bGVzaGVldD1udWxsO214R3JhcGgucHJvdG90eXBlLnNlbGVjdGlvbk1vZGVsPW51bGw7bXhHcmFwaC5wcm90b3R5cGUuY2VsbEVkaXRvcj1udWxsO214R3JhcGgucHJvdG90eXBlLmNlbGxSZW5kZXJlcj1udWxsO214R3JhcGgucHJvdG90eXBlLm11bHRpcGxpY2l0aWVzPW51bGw7bXhHcmFwaC5wcm90b3R5cGUucmVuZGVySGludD1udWxsO214R3JhcGgucHJvdG90eXBlLmRpYWxlY3Q9bnVsbDtteEdyYXBoLnByb3RvdHlwZS5ncmlkU2l6ZT0xMDtteEdyYXBoLnByb3RvdHlwZS5ncmlkRW5hYmxlZD0hMDsKbXhHcmFwaC5wcm90b3R5cGUucG9ydHNFbmFibGVkPSEwO214R3JhcGgucHJvdG90eXBlLm5hdGl2ZURibENsaWNrRW5hYmxlZD0hMDtteEdyYXBoLnByb3RvdHlwZS5kb3VibGVUYXBFbmFibGVkPSEwO214R3JhcGgucHJvdG90eXBlLmRvdWJsZVRhcFRpbWVvdXQ9NTAwO214R3JhcGgucHJvdG90eXBlLmRvdWJsZVRhcFRvbGVyYW5jZT0yNTtteEdyYXBoLnByb3RvdHlwZS5sYXN0VG91Y2hZPTA7bXhHcmFwaC5wcm90b3R5cGUubGFzdFRvdWNoWT0wO214R3JhcGgucHJvdG90eXBlLmxhc3RUb3VjaFRpbWU9MDtteEdyYXBoLnByb3RvdHlwZS50YXBBbmRIb2xkRW5hYmxlZD0hMDtteEdyYXBoLnByb3RvdHlwZS50YXBBbmRIb2xkRGVsYXk9NTAwO214R3JhcGgucHJvdG90eXBlLnRhcEFuZEhvbGRJblByb2dyZXNzPSExO214R3JhcGgucHJvdG90eXBlLnRhcEFuZEhvbGRWYWxpZD0hMTtteEdyYXBoLnByb3RvdHlwZS5pbml0aWFsVG91Y2hYPTA7Cm14R3JhcGgucHJvdG90eXBlLmluaXRpYWxUb3VjaFk9MDtteEdyYXBoLnByb3RvdHlwZS50b2xlcmFuY2U9NDtteEdyYXBoLnByb3RvdHlwZS5kZWZhdWx0T3ZlcmxhcD0uNTtteEdyYXBoLnByb3RvdHlwZS5kZWZhdWx0UGFyZW50PW51bGw7bXhHcmFwaC5wcm90b3R5cGUuYWx0ZXJuYXRlRWRnZVN0eWxlPW51bGw7bXhHcmFwaC5wcm90b3R5cGUuYmFja2dyb3VuZEltYWdlPW51bGw7bXhHcmFwaC5wcm90b3R5cGUucGFnZVZpc2libGU9ITE7bXhHcmFwaC5wcm90b3R5cGUucGFnZUJyZWFrc1Zpc2libGU9ITE7bXhHcmFwaC5wcm90b3R5cGUucGFnZUJyZWFrQ29sb3I9ImdyYXkiO214R3JhcGgucHJvdG90eXBlLnBhZ2VCcmVha0Rhc2hlZD0hMDtteEdyYXBoLnByb3RvdHlwZS5taW5QYWdlQnJlYWtEaXN0PTIwO214R3JhcGgucHJvdG90eXBlLnByZWZlclBhZ2VTaXplPSExO214R3JhcGgucHJvdG90eXBlLnBhZ2VGb3JtYXQ9bXhDb25zdGFudHMuUEFHRV9GT1JNQVRfQTRfUE9SVFJBSVQ7Cm14R3JhcGgucHJvdG90eXBlLnBhZ2VTY2FsZT0xLjU7bXhHcmFwaC5wcm90b3R5cGUuZW5hYmxlZD0hMDtteEdyYXBoLnByb3RvdHlwZS5lc2NhcGVFbmFibGVkPSEwO214R3JhcGgucHJvdG90eXBlLmludm9rZXNTdG9wQ2VsbEVkaXRpbmc9ITA7bXhHcmFwaC5wcm90b3R5cGUuZW50ZXJTdG9wc0NlbGxFZGl0aW5nPSExO214R3JhcGgucHJvdG90eXBlLnVzZVNjcm9sbGJhcnNGb3JQYW5uaW5nPSEwO214R3JhcGgucHJvdG90eXBlLmV4cG9ydEVuYWJsZWQ9ITA7bXhHcmFwaC5wcm90b3R5cGUuaW1wb3J0RW5hYmxlZD0hMDtteEdyYXBoLnByb3RvdHlwZS5jZWxsc0xvY2tlZD0hMTtteEdyYXBoLnByb3RvdHlwZS5jZWxsc0Nsb25lYWJsZT0hMDtteEdyYXBoLnByb3RvdHlwZS5mb2xkaW5nRW5hYmxlZD0hMDtteEdyYXBoLnByb3RvdHlwZS5jZWxsc0VkaXRhYmxlPSEwO214R3JhcGgucHJvdG90eXBlLmNlbGxzRGVsZXRhYmxlPSEwOwpteEdyYXBoLnByb3RvdHlwZS5jZWxsc01vdmFibGU9ITA7bXhHcmFwaC5wcm90b3R5cGUuZWRnZUxhYmVsc01vdmFibGU9ITA7bXhHcmFwaC5wcm90b3R5cGUudmVydGV4TGFiZWxzTW92YWJsZT0hMTtteEdyYXBoLnByb3RvdHlwZS5kcm9wRW5hYmxlZD0hMTtteEdyYXBoLnByb3RvdHlwZS5zcGxpdEVuYWJsZWQ9ITA7bXhHcmFwaC5wcm90b3R5cGUuY2VsbHNSZXNpemFibGU9ITA7bXhHcmFwaC5wcm90b3R5cGUuY2VsbHNCZW5kYWJsZT0hMDtteEdyYXBoLnByb3RvdHlwZS5jZWxsc1NlbGVjdGFibGU9ITA7bXhHcmFwaC5wcm90b3R5cGUuY2VsbHNEaXNjb25uZWN0YWJsZT0hMDtteEdyYXBoLnByb3RvdHlwZS5hdXRvU2l6ZUNlbGxzPSExO214R3JhcGgucHJvdG90eXBlLmF1dG9TaXplQ2VsbHNPbkFkZD0hMTtteEdyYXBoLnByb3RvdHlwZS5hdXRvU2Nyb2xsPSEwO214R3JhcGgucHJvdG90eXBlLmlnbm9yZVNjcm9sbGJhcnM9ITE7Cm14R3JhcGgucHJvdG90eXBlLnRyYW5zbGF0ZVRvU2Nyb2xsUG9zaXRpb249ITE7bXhHcmFwaC5wcm90b3R5cGUudGltZXJBdXRvU2Nyb2xsPSExO214R3JhcGgucHJvdG90eXBlLmFsbG93QXV0b1Bhbm5pbmc9ITE7bXhHcmFwaC5wcm90b3R5cGUuYXV0b0V4dGVuZD0hMDtteEdyYXBoLnByb3RvdHlwZS5tYXhpbXVtR3JhcGhCb3VuZHM9bnVsbDtteEdyYXBoLnByb3RvdHlwZS5taW5pbXVtR3JhcGhTaXplPW51bGw7bXhHcmFwaC5wcm90b3R5cGUubWluaW11bUNvbnRhaW5lclNpemU9bnVsbDtteEdyYXBoLnByb3RvdHlwZS5tYXhpbXVtQ29udGFpbmVyU2l6ZT1udWxsO214R3JhcGgucHJvdG90eXBlLnJlc2l6ZUNvbnRhaW5lcj0hMTtteEdyYXBoLnByb3RvdHlwZS5ib3JkZXI9MDtteEdyYXBoLnByb3RvdHlwZS5rZWVwRWRnZXNJbkZvcmVncm91bmQ9ITE7bXhHcmFwaC5wcm90b3R5cGUua2VlcEVkZ2VzSW5CYWNrZ3JvdW5kPSExOwpteEdyYXBoLnByb3RvdHlwZS5hbGxvd05lZ2F0aXZlQ29vcmRpbmF0ZXM9ITA7bXhHcmFwaC5wcm90b3R5cGUuY29uc3RyYWluQ2hpbGRyZW49ITA7bXhHcmFwaC5wcm90b3R5cGUuY29uc3RyYWluUmVsYXRpdmVDaGlsZHJlbj0hMTtteEdyYXBoLnByb3RvdHlwZS5leHRlbmRQYXJlbnRzPSEwO214R3JhcGgucHJvdG90eXBlLmV4dGVuZFBhcmVudHNPbkFkZD0hMDtteEdyYXBoLnByb3RvdHlwZS5leHRlbmRQYXJlbnRzT25Nb3ZlPSExO214R3JhcGgucHJvdG90eXBlLnJlY3Vyc2l2ZVJlc2l6ZT0hMTtteEdyYXBoLnByb3RvdHlwZS5jb2xsYXBzZVRvUHJlZmVycmVkU2l6ZT0hMDtteEdyYXBoLnByb3RvdHlwZS56b29tRmFjdG9yPTEuMjtteEdyYXBoLnByb3RvdHlwZS5rZWVwU2VsZWN0aW9uVmlzaWJsZU9uWm9vbT0hMTtteEdyYXBoLnByb3RvdHlwZS5jZW50ZXJab29tPSEwO214R3JhcGgucHJvdG90eXBlLnJlc2V0Vmlld09uUm9vdENoYW5nZT0hMDsKbXhHcmFwaC5wcm90b3R5cGUucmVzZXRFZGdlc09uUmVzaXplPSExO214R3JhcGgucHJvdG90eXBlLnJlc2V0RWRnZXNPbk1vdmU9ITE7bXhHcmFwaC5wcm90b3R5cGUucmVzZXRFZGdlc09uQ29ubmVjdD0hMDtteEdyYXBoLnByb3RvdHlwZS5hbGxvd0xvb3BzPSExO214R3JhcGgucHJvdG90eXBlLmRlZmF1bHRMb29wU3R5bGU9bXhFZGdlU3R5bGUuTG9vcDtteEdyYXBoLnByb3RvdHlwZS5tdWx0aWdyYXBoPSEwO214R3JhcGgucHJvdG90eXBlLmNvbm5lY3RhYmxlRWRnZXM9ITE7bXhHcmFwaC5wcm90b3R5cGUuYWxsb3dEYW5nbGluZ0VkZ2VzPSEwO214R3JhcGgucHJvdG90eXBlLmNsb25lSW52YWxpZEVkZ2VzPSExO214R3JhcGgucHJvdG90eXBlLmRpc2Nvbm5lY3RPbk1vdmU9ITA7bXhHcmFwaC5wcm90b3R5cGUubGFiZWxzVmlzaWJsZT0hMDtteEdyYXBoLnByb3RvdHlwZS5odG1sTGFiZWxzPSExO214R3JhcGgucHJvdG90eXBlLnN3aW1sYW5lU2VsZWN0aW9uRW5hYmxlZD0hMDsKbXhHcmFwaC5wcm90b3R5cGUuc3dpbWxhbmVOZXN0aW5nPSEwO214R3JhcGgucHJvdG90eXBlLnN3aW1sYW5lSW5kaWNhdG9yQ29sb3JBdHRyaWJ1dGU9bXhDb25zdGFudHMuU1RZTEVfRklMTENPTE9SO214R3JhcGgucHJvdG90eXBlLmltYWdlQnVuZGxlcz1udWxsO214R3JhcGgucHJvdG90eXBlLm1pbkZpdFNjYWxlPS4xO214R3JhcGgucHJvdG90eXBlLm1heEZpdFNjYWxlPTg7bXhHcmFwaC5wcm90b3R5cGUucGFuRHg9MDtteEdyYXBoLnByb3RvdHlwZS5wYW5EeT0wO214R3JhcGgucHJvdG90eXBlLmNvbGxhcHNlZEltYWdlPW5ldyBteEltYWdlKG14Q2xpZW50LmltYWdlQmFzZVBhdGgrIi9jb2xsYXBzZWQuZ2lmIiw5LDkpO214R3JhcGgucHJvdG90eXBlLmV4cGFuZGVkSW1hZ2U9bmV3IG14SW1hZ2UobXhDbGllbnQuaW1hZ2VCYXNlUGF0aCsiL2V4cGFuZGVkLmdpZiIsOSw5KTsKbXhHcmFwaC5wcm90b3R5cGUud2FybmluZ0ltYWdlPW5ldyBteEltYWdlKG14Q2xpZW50LmltYWdlQmFzZVBhdGgrIi93YXJuaW5nIisobXhDbGllbnQuSVNfTUFDPyIucG5nIjoiLmdpZiIpLDE2LDE2KTtteEdyYXBoLnByb3RvdHlwZS5hbHJlYWR5Q29ubmVjdGVkUmVzb3VyY2U9Im5vbmUiIT1teENsaWVudC5sYW5ndWFnZT8iYWxyZWFkeUNvbm5lY3RlZCI6IiI7bXhHcmFwaC5wcm90b3R5cGUuY29udGFpbnNWYWxpZGF0aW9uRXJyb3JzUmVzb3VyY2U9Im5vbmUiIT1teENsaWVudC5sYW5ndWFnZT8iY29udGFpbnNWYWxpZGF0aW9uRXJyb3JzIjoiIjtteEdyYXBoLnByb3RvdHlwZS5jb2xsYXBzZUV4cGFuZFJlc291cmNlPSJub25lIiE9bXhDbGllbnQubGFuZ3VhZ2U/ImNvbGxhcHNlLWV4cGFuZCI6IiI7Cm14R3JhcGgucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oYSl7dGhpcy5jb250YWluZXI9YTt0aGlzLmNlbGxFZGl0b3I9dGhpcy5jcmVhdGVDZWxsRWRpdG9yKCk7dGhpcy52aWV3LmluaXQoKTt0aGlzLnNpemVEaWRDaGFuZ2UoKTtteEV2ZW50LmFkZExpc3RlbmVyKGEsIm1vdXNlbGVhdmUiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bnVsbCE9dGhpcy50b29sdGlwSGFuZGxlciYmdGhpcy50b29sdGlwSGFuZGxlci5oaWRlKCl9KSk7bXhDbGllbnQuSVNfSUUmJihteEV2ZW50LmFkZExpc3RlbmVyKHdpbmRvdywidW5sb2FkIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuZGVzdHJveSgpfSkpLG14RXZlbnQuYWRkTGlzdGVuZXIoYSwic2VsZWN0c3RhcnQiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmlzRWRpdGluZygpfHwhdGhpcy5pc01vdXNlRG93biYmIW14RXZlbnQuaXNTaGlmdERvd24oYSl9KSkpOzg9PWRvY3VtZW50LmRvY3VtZW50TW9kZSYmCmEuaW5zZXJ0QWRqYWNlbnRIVE1MKCJiZWZvcmVlbmQiLCI8IitteENsaWVudC5WTUxfUFJFRklYKyc6Z3JvdXAgc3R5bGU9IkRJU1BMQVk6IG5vbmU7Ij48LycrbXhDbGllbnQuVk1MX1BSRUZJWCsiOmdyb3VwPiIpfTsKbXhHcmFwaC5wcm90b3R5cGUuY3JlYXRlSGFuZGxlcnM9ZnVuY3Rpb24oKXt0aGlzLnRvb2x0aXBIYW5kbGVyPXRoaXMuY3JlYXRlVG9vbHRpcEhhbmRsZXIoKTt0aGlzLnRvb2x0aXBIYW5kbGVyLnNldEVuYWJsZWQoITEpO3RoaXMuc2VsZWN0aW9uQ2VsbHNIYW5kbGVyPXRoaXMuY3JlYXRlU2VsZWN0aW9uQ2VsbHNIYW5kbGVyKCk7dGhpcy5jb25uZWN0aW9uSGFuZGxlcj10aGlzLmNyZWF0ZUNvbm5lY3Rpb25IYW5kbGVyKCk7dGhpcy5jb25uZWN0aW9uSGFuZGxlci5zZXRFbmFibGVkKCExKTt0aGlzLmdyYXBoSGFuZGxlcj10aGlzLmNyZWF0ZUdyYXBoSGFuZGxlcigpO3RoaXMucGFubmluZ0hhbmRsZXI9dGhpcy5jcmVhdGVQYW5uaW5nSGFuZGxlcigpO3RoaXMucGFubmluZ0hhbmRsZXIucGFubmluZ0VuYWJsZWQ9ITE7dGhpcy5wb3B1cE1lbnVIYW5kbGVyPXRoaXMuY3JlYXRlUG9wdXBNZW51SGFuZGxlcigpfTsKbXhHcmFwaC5wcm90b3R5cGUuY3JlYXRlVG9vbHRpcEhhbmRsZXI9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG14VG9vbHRpcEhhbmRsZXIodGhpcyl9O214R3JhcGgucHJvdG90eXBlLmNyZWF0ZVNlbGVjdGlvbkNlbGxzSGFuZGxlcj1mdW5jdGlvbigpe3JldHVybiBuZXcgbXhTZWxlY3Rpb25DZWxsc0hhbmRsZXIodGhpcyl9O214R3JhcGgucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb25IYW5kbGVyPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBteENvbm5lY3Rpb25IYW5kbGVyKHRoaXMpfTtteEdyYXBoLnByb3RvdHlwZS5jcmVhdGVHcmFwaEhhbmRsZXI9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG14R3JhcGhIYW5kbGVyKHRoaXMpfTtteEdyYXBoLnByb3RvdHlwZS5jcmVhdGVQYW5uaW5nSGFuZGxlcj1mdW5jdGlvbigpe3JldHVybiBuZXcgbXhQYW5uaW5nSGFuZGxlcih0aGlzKX07bXhHcmFwaC5wcm90b3R5cGUuY3JlYXRlUG9wdXBNZW51SGFuZGxlcj1mdW5jdGlvbigpe3JldHVybiBuZXcgbXhQb3B1cE1lbnVIYW5kbGVyKHRoaXMpfTsKbXhHcmFwaC5wcm90b3R5cGUuY3JlYXRlU2VsZWN0aW9uTW9kZWw9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG14R3JhcGhTZWxlY3Rpb25Nb2RlbCh0aGlzKX07bXhHcmFwaC5wcm90b3R5cGUuY3JlYXRlU3R5bGVzaGVldD1mdW5jdGlvbigpe3JldHVybiBuZXcgbXhTdHlsZXNoZWV0fTtteEdyYXBoLnByb3RvdHlwZS5jcmVhdGVHcmFwaFZpZXc9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG14R3JhcGhWaWV3KHRoaXMpfTtteEdyYXBoLnByb3RvdHlwZS5jcmVhdGVDZWxsUmVuZGVyZXI9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG14Q2VsbFJlbmRlcmVyfTtteEdyYXBoLnByb3RvdHlwZS5jcmVhdGVDZWxsRWRpdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBteENlbGxFZGl0b3IodGhpcyl9O214R3JhcGgucHJvdG90eXBlLmdldE1vZGVsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubW9kZWx9O214R3JhcGgucHJvdG90eXBlLmdldFZpZXc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3fTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0U3R5bGVzaGVldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0eWxlc2hlZXR9O214R3JhcGgucHJvdG90eXBlLnNldFN0eWxlc2hlZXQ9ZnVuY3Rpb24oYSl7dGhpcy5zdHlsZXNoZWV0PWF9O214R3JhcGgucHJvdG90eXBlLmdldFNlbGVjdGlvbk1vZGVsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZWx9O214R3JhcGgucHJvdG90eXBlLnNldFNlbGVjdGlvbk1vZGVsPWZ1bmN0aW9uKGEpe3RoaXMuc2VsZWN0aW9uTW9kZWw9YX07Cm14R3JhcGgucHJvdG90eXBlLmdldFNlbGVjdGlvbkNlbGxzRm9yQ2hhbmdlcz1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1uZXcgbXhEaWN0aW9uYXJ5LGQ9W10sZT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtpZighYy5nZXQoYSkmJnRoaXMubW9kZWwuY29udGFpbnMoYSkpaWYodGhpcy5tb2RlbC5pc0VkZ2UoYSl8fHRoaXMubW9kZWwuaXNWZXJ0ZXgoYSkpYy5wdXQoYSwhMCksZC5wdXNoKGEpO2Vsc2UgZm9yKHZhciBiPXRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChhKSxmPTA7ZjxiO2YrKyllKHRoaXMubW9kZWwuZ2V0Q2hpbGRBdChhLGYpKX0pLGY9MDtmPGEubGVuZ3RoO2YrKyl7dmFyIGc9YVtmXTtpZihnLmNvbnN0cnVjdG9yIT1teFJvb3RDaGFuZ2UmJihudWxsPT1ifHwhYihnKSkpe3ZhciBrPW51bGw7ZyBpbnN0YW5jZW9mIG14Q2hpbGRDaGFuZ2U/az1nLmNoaWxkOm51bGwhPWcuY2VsbCYmZy5jZWxsIGluc3RhbmNlb2YgbXhDZWxsJiYoaz1nLmNlbGwpO251bGwhPQprJiZlKGspfX1yZXR1cm4gZH07bXhHcmFwaC5wcm90b3R5cGUuZ3JhcGhNb2RlbENoYW5nZWQ9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspdGhpcy5wcm9jZXNzQ2hhbmdlKGFbYl0pO3RoaXMudXBkYXRlU2VsZWN0aW9uKCk7dGhpcy52aWV3LnZhbGlkYXRlKCk7dGhpcy5zaXplRGlkQ2hhbmdlKCl9OwpteEdyYXBoLnByb3RvdHlwZS51cGRhdGVTZWxlY3Rpb249ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5nZXRTZWxlY3Rpb25DZWxscygpLGI9W10sYz0wO2M8YS5sZW5ndGg7YysrKWlmKHRoaXMubW9kZWwuY29udGFpbnMoYVtjXSkmJnRoaXMuaXNDZWxsVmlzaWJsZShhW2NdKSlmb3IodmFyIGQ9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYVtjXSk7bnVsbCE9ZCYmZCE9dGhpcy52aWV3LmN1cnJlbnRSb290Oyl7aWYodGhpcy5pc0NlbGxDb2xsYXBzZWQoZCl8fCF0aGlzLmlzQ2VsbFZpc2libGUoZCkpe2IucHVzaChhW2NdKTticmVha31kPXRoaXMubW9kZWwuZ2V0UGFyZW50KGQpfWVsc2UgYi5wdXNoKGFbY10pO3RoaXMucmVtb3ZlU2VsZWN0aW9uQ2VsbHMoYil9OwpteEdyYXBoLnByb3RvdHlwZS5wcm9jZXNzQ2hhbmdlPWZ1bmN0aW9uKGEpe2lmKGEgaW5zdGFuY2VvZiBteFJvb3RDaGFuZ2UpdGhpcy5jbGVhclNlbGVjdGlvbigpLHRoaXMuc2V0RGVmYXVsdFBhcmVudChudWxsKSx0aGlzLnJlbW92ZVN0YXRlRm9yQ2VsbChhLnByZXZpb3VzKSx0aGlzLnJlc2V0Vmlld09uUm9vdENoYW5nZSYmKHRoaXMudmlldy5zY2FsZT0xLHRoaXMudmlldy50cmFuc2xhdGUueD0wLHRoaXMudmlldy50cmFuc2xhdGUueT0wKSx0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlJPT1QpKTtlbHNlIGlmKGEgaW5zdGFuY2VvZiBteENoaWxkQ2hhbmdlKXt2YXIgYj10aGlzLm1vZGVsLmdldFBhcmVudChhLmNoaWxkKTt0aGlzLnZpZXcuaW52YWxpZGF0ZShhLmNoaWxkLCEwLCEwKTtpZighdGhpcy5tb2RlbC5jb250YWlucyhiKXx8dGhpcy5pc0NlbGxDb2xsYXBzZWQoYikpdGhpcy52aWV3LmludmFsaWRhdGUoYS5jaGlsZCwhMCwhMCksdGhpcy5yZW1vdmVTdGF0ZUZvckNlbGwoYS5jaGlsZCksCnRoaXMudmlldy5jdXJyZW50Um9vdD09YS5jaGlsZCYmdGhpcy5ob21lKCk7YiE9YS5wcmV2aW91cyYmKG51bGwhPWImJnRoaXMudmlldy5pbnZhbGlkYXRlKGIsITEsITEpLG51bGwhPWEucHJldmlvdXMmJnRoaXMudmlldy5pbnZhbGlkYXRlKGEucHJldmlvdXMsITEsITEpKX1lbHNlIGEgaW5zdGFuY2VvZiBteFRlcm1pbmFsQ2hhbmdlfHxhIGluc3RhbmNlb2YgbXhHZW9tZXRyeUNoYW5nZT8oYSBpbnN0YW5jZW9mIG14VGVybWluYWxDaGFuZ2V8fG51bGw9PWEucHJldmlvdXMmJm51bGwhPWEuZ2VvbWV0cnl8fG51bGwhPWEucHJldmlvdXMmJiFhLnByZXZpb3VzLmVxdWFscyhhLmdlb21ldHJ5KSkmJnRoaXMudmlldy5pbnZhbGlkYXRlKGEuY2VsbCk6YSBpbnN0YW5jZW9mIG14VmFsdWVDaGFuZ2U/dGhpcy52aWV3LmludmFsaWRhdGUoYS5jZWxsLCExLCExKTphIGluc3RhbmNlb2YgbXhTdHlsZUNoYW5nZT8odGhpcy52aWV3LmludmFsaWRhdGUoYS5jZWxsLCEwLCEwKSxhPXRoaXMudmlldy5nZXRTdGF0ZShhLmNlbGwpLApudWxsIT1hJiYoYS5pbnZhbGlkU3R5bGU9ITApKTpudWxsIT1hLmNlbGwmJmEuY2VsbCBpbnN0YW5jZW9mIG14Q2VsbCYmdGhpcy5yZW1vdmVTdGF0ZUZvckNlbGwoYS5jZWxsKX07bXhHcmFwaC5wcm90b3R5cGUucmVtb3ZlU3RhdGVGb3JDZWxsPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj10aGlzLm1vZGVsLmdldENoaWxkQ291bnQoYSksYz0wO2M8YjtjKyspdGhpcy5yZW1vdmVTdGF0ZUZvckNlbGwodGhpcy5tb2RlbC5nZXRDaGlsZEF0KGEsYykpO3RoaXMudmlldy5pbnZhbGlkYXRlKGEsITEsITApO3RoaXMudmlldy5yZW1vdmVTdGF0ZShhKX07Cm14R3JhcGgucHJvdG90eXBlLmFkZENlbGxPdmVybGF5PWZ1bmN0aW9uKGEsYil7bnVsbD09YS5vdmVybGF5cyYmKGEub3ZlcmxheXM9W10pO2Eub3ZlcmxheXMucHVzaChiKTt2YXIgYz10aGlzLnZpZXcuZ2V0U3RhdGUoYSk7bnVsbCE9YyYmdGhpcy5jZWxsUmVuZGVyZXIucmVkcmF3KGMpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuQUREX09WRVJMQVksImNlbGwiLGEsIm92ZXJsYXkiLGIpKTtyZXR1cm4gYn07bXhHcmFwaC5wcm90b3R5cGUuZ2V0Q2VsbE92ZXJsYXlzPWZ1bmN0aW9uKGEpe3JldHVybiBhLm92ZXJsYXlzfTsKbXhHcmFwaC5wcm90b3R5cGUucmVtb3ZlQ2VsbE92ZXJsYXk9ZnVuY3Rpb24oYSxiKXtpZihudWxsPT1iKXRoaXMucmVtb3ZlQ2VsbE92ZXJsYXlzKGEpO2Vsc2V7dmFyIGM9bXhVdGlscy5pbmRleE9mKGEub3ZlcmxheXMsYik7MDw9Yz8oYS5vdmVybGF5cy5zcGxpY2UoYywxKSwwPT1hLm92ZXJsYXlzLmxlbmd0aCYmKGEub3ZlcmxheXM9bnVsbCksYz10aGlzLnZpZXcuZ2V0U3RhdGUoYSksbnVsbCE9YyYmdGhpcy5jZWxsUmVuZGVyZXIucmVkcmF3KGMpLHRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuUkVNT1ZFX09WRVJMQVksImNlbGwiLGEsIm92ZXJsYXkiLGIpKSk6Yj1udWxsfXJldHVybiBifTsKbXhHcmFwaC5wcm90b3R5cGUucmVtb3ZlQ2VsbE92ZXJsYXlzPWZ1bmN0aW9uKGEpe3ZhciBiPWEub3ZlcmxheXM7aWYobnVsbCE9Yil7YS5vdmVybGF5cz1udWxsO3ZhciBjPXRoaXMudmlldy5nZXRTdGF0ZShhKTtudWxsIT1jJiZ0aGlzLmNlbGxSZW5kZXJlci5yZWRyYXcoYyk7Zm9yKGM9MDtjPGIubGVuZ3RoO2MrKyl0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlJFTU9WRV9PVkVSTEFZLCJjZWxsIixhLCJvdmVybGF5IixiW2NdKSl9cmV0dXJuIGJ9O214R3JhcGgucHJvdG90eXBlLmNsZWFyQ2VsbE92ZXJsYXlzPWZ1bmN0aW9uKGEpe2E9bnVsbCE9YT9hOnRoaXMubW9kZWwuZ2V0Um9vdCgpO3RoaXMucmVtb3ZlQ2VsbE92ZXJsYXlzKGEpO2Zvcih2YXIgYj10aGlzLm1vZGVsLmdldENoaWxkQ291bnQoYSksYz0wO2M8YjtjKyspe3ZhciBkPXRoaXMubW9kZWwuZ2V0Q2hpbGRBdChhLGMpO3RoaXMuY2xlYXJDZWxsT3ZlcmxheXMoZCl9fTsKbXhHcmFwaC5wcm90b3R5cGUuc2V0Q2VsbFdhcm5pbmc9ZnVuY3Rpb24oYSxiLGMsZCl7aWYobnVsbCE9YiYmMDxiLmxlbmd0aClyZXR1cm4gYz1udWxsIT1jP2M6dGhpcy53YXJuaW5nSW1hZ2UsYj1uZXcgbXhDZWxsT3ZlcmxheShjLCI8Zm9udCBjb2xvcj1yZWQ+IitiKyI8L2ZvbnQ+IiksZCYmYi5hZGRMaXN0ZW5lcihteEV2ZW50LkNMSUNLLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIsYyl7dGhpcy5pc0VuYWJsZWQoKSYmdGhpcy5zZXRTZWxlY3Rpb25DZWxsKGEpfSkpLHRoaXMuYWRkQ2VsbE92ZXJsYXkoYSxiKTt0aGlzLnJlbW92ZUNlbGxPdmVybGF5cyhhKTtyZXR1cm4gbnVsbH07bXhHcmFwaC5wcm90b3R5cGUuc3RhcnRFZGl0aW5nPWZ1bmN0aW9uKGEpe3RoaXMuc3RhcnRFZGl0aW5nQXRDZWxsKG51bGwsYSl9OwpteEdyYXBoLnByb3RvdHlwZS5zdGFydEVkaXRpbmdBdENlbGw9ZnVuY3Rpb24oYSxiKXtudWxsIT1iJiZteEV2ZW50LmlzTXVsdGlUb3VjaEV2ZW50KGIpfHwobnVsbD09YSYmKGE9dGhpcy5nZXRTZWxlY3Rpb25DZWxsKCksbnVsbD09YXx8dGhpcy5pc0NlbGxFZGl0YWJsZShhKXx8KGE9bnVsbCkpLG51bGwhPWEmJih0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlNUQVJUX0VESVRJTkcsImNlbGwiLGEsImV2ZW50IixiKSksdGhpcy5jZWxsRWRpdG9yLnN0YXJ0RWRpdGluZyhhLGIpLHRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuRURJVElOR19TVEFSVEVELCJjZWxsIixhLCJldmVudCIsYikpKSl9O214R3JhcGgucHJvdG90eXBlLmdldEVkaXRpbmdWYWx1ZT1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmNvbnZlcnRWYWx1ZVRvU3RyaW5nKGEpfTsKbXhHcmFwaC5wcm90b3R5cGUuc3RvcEVkaXRpbmc9ZnVuY3Rpb24oYSl7dGhpcy5jZWxsRWRpdG9yLnN0b3BFZGl0aW5nKGEpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuRURJVElOR19TVE9QUEVELCJjYW5jZWwiLGEpKX07bXhHcmFwaC5wcm90b3R5cGUubGFiZWxDaGFuZ2VkPWZ1bmN0aW9uKGEsYixjKXt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e3ZhciBkPWEudmFsdWU7dGhpcy5jZWxsTGFiZWxDaGFuZ2VkKGEsYix0aGlzLmlzQXV0b1NpemVDZWxsKGEpKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkxBQkVMX0NIQU5HRUQsImNlbGwiLGEsInZhbHVlIixiLCJvbGQiLGQsImV2ZW50IixjKSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfXJldHVybiBhfTsKbXhHcmFwaC5wcm90b3R5cGUuY2VsbExhYmVsQ2hhbmdlZD1mdW5jdGlvbihhLGIsYyl7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt0aGlzLm1vZGVsLnNldFZhbHVlKGEsYiksYyYmdGhpcy5jZWxsU2l6ZVVwZGF0ZWQoYSwhMSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX07bXhHcmFwaC5wcm90b3R5cGUuZXNjYXBlPWZ1bmN0aW9uKGEpe3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuRVNDQVBFLCJldmVudCIsYSkpfTsKbXhHcmFwaC5wcm90b3R5cGUuY2xpY2s9ZnVuY3Rpb24oYSl7dmFyIGI9YS5nZXRFdmVudCgpLGM9YS5nZXRDZWxsKCksZD1uZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkNMSUNLLCJldmVudCIsYiwiY2VsbCIsYyk7YS5pc0NvbnN1bWVkKCkmJmQuY29uc3VtZSgpO3RoaXMuZmlyZUV2ZW50KGQpO2lmKHRoaXMuaXNFbmFibGVkKCkmJiFteEV2ZW50LmlzQ29uc3VtZWQoYikmJiFkLmlzQ29uc3VtZWQoKSl7aWYobnVsbCE9Yyl7aWYodGhpcy5pc1RyYW5zcGFyZW50Q2xpY2tFdmVudChiKSl7dmFyIGU9ITE7YT10aGlzLmdldENlbGxBdChhLmdyYXBoWCxhLmdyYXBoWSxudWxsLG51bGwsbnVsbCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt2YXIgYj10aGlzLmlzQ2VsbFNlbGVjdGVkKGEuY2VsbCk7ZT1lfHxiO3JldHVybiFlfHxifHxhLmNlbGwhPWMmJnRoaXMubW9kZWwuaXNBbmNlc3RvcihhLmNlbGwsYyl9KSk7bnVsbCE9YSYmKGM9YSl9fWVsc2UgaWYodGhpcy5pc1N3aW1sYW5lU2VsZWN0aW9uRW5hYmxlZCgpJiYKKGM9dGhpcy5nZXRTd2ltbGFuZUF0KGEuZ2V0R3JhcGhYKCksYS5nZXRHcmFwaFkoKSksIShudWxsPT1jfHx0aGlzLmlzVG9nZ2xlRXZlbnQoYikmJm14RXZlbnQuaXNBbHREb3duKGIpKSkpe2Q9Yztmb3IoYT1bXTtudWxsIT1kOyl7dmFyIGQ9dGhpcy5tb2RlbC5nZXRQYXJlbnQoZCksZj10aGlzLnZpZXcuZ2V0U3RhdGUoZCk7dGhpcy5pc1N3aW1sYW5lKGQpJiZudWxsIT1mJiZhLnB1c2goZCl9aWYoMDxhLmxlbmd0aClmb3IoYT1hLnJldmVyc2UoKSxhLnNwbGljZSgwLDAsYyksYS5wdXNoKGMpLGQ9MDtkPGEubGVuZ3RoLTE7ZCsrKXRoaXMuaXNDZWxsU2VsZWN0ZWQoYVtkXSkmJihjPWFbdGhpcy5pc1RvZ2dsZUV2ZW50KGIpP2Q6ZCsxXSl9bnVsbCE9Yz90aGlzLnNlbGVjdENlbGxGb3JFdmVudChjLGIpOnRoaXMuaXNUb2dnbGVFdmVudChiKXx8dGhpcy5jbGVhclNlbGVjdGlvbigpfX07Cm14R3JhcGgucHJvdG90eXBlLmlzU2libGluZ1NlbGVjdGVkPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj10aGlzLm1vZGVsLGM9Yi5nZXRQYXJlbnQoYSksZD1iLmdldENoaWxkQ291bnQoYyksZT0wO2U8ZDtlKyspe3ZhciBmPWIuZ2V0Q2hpbGRBdChjLGUpO2lmKGEhPWYmJnRoaXMuaXNDZWxsU2VsZWN0ZWQoZikpcmV0dXJuITB9cmV0dXJuITF9O214R3JhcGgucHJvdG90eXBlLmRibENsaWNrPWZ1bmN0aW9uKGEsYil7dmFyIGM9bmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5ET1VCTEVfQ0xJQ0ssImV2ZW50IixhLCJjZWxsIixiKTt0aGlzLmZpcmVFdmVudChjKTshdGhpcy5pc0VuYWJsZWQoKXx8bXhFdmVudC5pc0NvbnN1bWVkKGEpfHxjLmlzQ29uc3VtZWQoKXx8bnVsbD09Ynx8IXRoaXMuaXNDZWxsRWRpdGFibGUoYil8fHRoaXMuaXNFZGl0aW5nKGIpfHwodGhpcy5zdGFydEVkaXRpbmdBdENlbGwoYixhKSxteEV2ZW50LmNvbnN1bWUoYSkpfTsKbXhHcmFwaC5wcm90b3R5cGUudGFwQW5kSG9sZD1mdW5jdGlvbihhKXt2YXIgYj1hLmdldEV2ZW50KCksYz1uZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlRBUF9BTkRfSE9MRCwiZXZlbnQiLGIsImNlbGwiLGEuZ2V0Q2VsbCgpKTt0aGlzLmZpcmVFdmVudChjKTtjLmlzQ29uc3VtZWQoKSYmKHRoaXMucGFubmluZ0hhbmRsZXIucGFubmluZ1RyaWdnZXI9ITEpO3RoaXMuaXNFbmFibGVkKCkmJiFteEV2ZW50LmlzQ29uc3VtZWQoYikmJiFjLmlzQ29uc3VtZWQoKSYmdGhpcy5jb25uZWN0aW9uSGFuZGxlci5pc0VuYWJsZWQoKSYmKGI9dGhpcy52aWV3LmdldFN0YXRlKHRoaXMuY29ubmVjdGlvbkhhbmRsZXIubWFya2VyLmdldENlbGwoYSkpLG51bGwhPWImJih0aGlzLmNvbm5lY3Rpb25IYW5kbGVyLm1hcmtlci5jdXJyZW50Q29sb3I9dGhpcy5jb25uZWN0aW9uSGFuZGxlci5tYXJrZXIudmFsaWRDb2xvcix0aGlzLmNvbm5lY3Rpb25IYW5kbGVyLm1hcmtlci5tYXJrZWRTdGF0ZT1iLAp0aGlzLmNvbm5lY3Rpb25IYW5kbGVyLm1hcmtlci5tYXJrKCksdGhpcy5jb25uZWN0aW9uSGFuZGxlci5maXJzdD1uZXcgbXhQb2ludChhLmdldEdyYXBoWCgpLGEuZ2V0R3JhcGhZKCkpLHRoaXMuY29ubmVjdGlvbkhhbmRsZXIuZWRnZVN0YXRlPXRoaXMuY29ubmVjdGlvbkhhbmRsZXIuY3JlYXRlRWRnZVN0YXRlKGEpLHRoaXMuY29ubmVjdGlvbkhhbmRsZXIucHJldmlvdXM9Yix0aGlzLmNvbm5lY3Rpb25IYW5kbGVyLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlNUQVJULCJzdGF0ZSIsdGhpcy5jb25uZWN0aW9uSGFuZGxlci5wcmV2aW91cykpKSl9OwpteEdyYXBoLnByb3RvdHlwZS5zY3JvbGxQb2ludFRvVmlzaWJsZT1mdW5jdGlvbihhLGIsYyxkKXtpZih0aGlzLnRpbWVyQXV0b1Njcm9sbHx8IXRoaXMuaWdub3JlU2Nyb2xsYmFycyYmIW14VXRpbHMuaGFzU2Nyb2xsYmFycyh0aGlzLmNvbnRhaW5lcikpdGhpcy5hbGxvd0F1dG9QYW5uaW5nJiYhdGhpcy5wYW5uaW5nSGFuZGxlci5pc0FjdGl2ZSgpJiYobnVsbD09dGhpcy5wYW5uaW5nTWFuYWdlciYmKHRoaXMucGFubmluZ01hbmFnZXI9dGhpcy5jcmVhdGVQYW5uaW5nTWFuYWdlcigpKSx0aGlzLnBhbm5pbmdNYW5hZ2VyLnBhblRvKGErdGhpcy5wYW5EeCxiK3RoaXMucGFuRHkpKTtlbHNle3ZhciBlPXRoaXMuY29udGFpbmVyO2Q9bnVsbCE9ZD9kOjIwO2lmKGE+PWUuc2Nyb2xsTGVmdCYmYj49ZS5zY3JvbGxUb3AmJmE8PWUuc2Nyb2xsTGVmdCtlLmNsaWVudFdpZHRoJiZiPD1lLnNjcm9sbFRvcCtlLmNsaWVudEhlaWdodCl7dmFyIGY9ZS5zY3JvbGxMZWZ0K2UuY2xpZW50V2lkdGgtCmE7aWYoZjxkKXtpZihhPWUuc2Nyb2xsTGVmdCxlLnNjcm9sbExlZnQrPWQtZixjJiZhPT1lLnNjcm9sbExlZnQpe2lmKHRoaXMuZGlhbGVjdD09bXhDb25zdGFudHMuRElBTEVDVF9TVkcpe2E9dGhpcy52aWV3LmdldERyYXdQYW5lKCkub3duZXJTVkdFbGVtZW50O3ZhciBnPXRoaXMuY29udGFpbmVyLnNjcm9sbFdpZHRoK2QtZn1lbHNlIGc9TWF0aC5tYXgoZS5jbGllbnRXaWR0aCxlLnNjcm9sbFdpZHRoKStkLWYsYT10aGlzLnZpZXcuZ2V0Q2FudmFzKCk7YS5zdHlsZS53aWR0aD1nKyJweCI7ZS5zY3JvbGxMZWZ0Kz1kLWZ9fWVsc2UgZj1hLWUuc2Nyb2xsTGVmdCxmPGQmJihlLnNjcm9sbExlZnQtPWQtZik7Zj1lLnNjcm9sbFRvcCtlLmNsaWVudEhlaWdodC1iO2Y8ZD8oYT1lLnNjcm9sbFRvcCxlLnNjcm9sbFRvcCs9ZC1mLGE9PWUuc2Nyb2xsVG9wJiZjJiYodGhpcy5kaWFsZWN0PT1teENvbnN0YW50cy5ESUFMRUNUX1NWRz8oYT10aGlzLnZpZXcuZ2V0RHJhd1BhbmUoKS5vd25lclNWR0VsZW1lbnQsCmI9dGhpcy5jb250YWluZXIuc2Nyb2xsSGVpZ2h0K2QtZik6KGI9TWF0aC5tYXgoZS5jbGllbnRIZWlnaHQsZS5zY3JvbGxIZWlnaHQpK2QtZixhPXRoaXMudmlldy5nZXRDYW52YXMoKSksYS5zdHlsZS5oZWlnaHQ9YisicHgiLGUuc2Nyb2xsVG9wKz1kLWYpKTooZj1iLWUuc2Nyb2xsVG9wLGY8ZCYmKGUuc2Nyb2xsVG9wLT1kLWYpKX19fTtteEdyYXBoLnByb3RvdHlwZS5jcmVhdGVQYW5uaW5nTWFuYWdlcj1mdW5jdGlvbigpe3JldHVybiBuZXcgbXhQYW5uaW5nTWFuYWdlcih0aGlzKX07Cm14R3JhcGgucHJvdG90eXBlLmdldEJvcmRlclNpemVzPWZ1bmN0aW9uKCl7dmFyIGE9bXhVdGlscy5nZXRDdXJyZW50U3R5bGUodGhpcy5jb250YWluZXIpO3JldHVybiBuZXcgbXhSZWN0YW5nbGUobXhVdGlscy5wYXJzZUNzc051bWJlcihhLnBhZGRpbmdMZWZ0KSsoIm5vbmUiIT1hLmJvcmRlckxlZnRTdHlsZT9teFV0aWxzLnBhcnNlQ3NzTnVtYmVyKGEuYm9yZGVyTGVmdFdpZHRoKTowKSxteFV0aWxzLnBhcnNlQ3NzTnVtYmVyKGEucGFkZGluZ1RvcCkrKCJub25lIiE9YS5ib3JkZXJUb3BTdHlsZT9teFV0aWxzLnBhcnNlQ3NzTnVtYmVyKGEuYm9yZGVyVG9wV2lkdGgpOjApLG14VXRpbHMucGFyc2VDc3NOdW1iZXIoYS5wYWRkaW5nUmlnaHQpKygibm9uZSIhPWEuYm9yZGVyUmlnaHRTdHlsZT9teFV0aWxzLnBhcnNlQ3NzTnVtYmVyKGEuYm9yZGVyUmlnaHRXaWR0aCk6MCksbXhVdGlscy5wYXJzZUNzc051bWJlcihhLnBhZGRpbmdCb3R0b20pKygibm9uZSIhPWEuYm9yZGVyQm90dG9tU3R5bGU/Cm14VXRpbHMucGFyc2VDc3NOdW1iZXIoYS5ib3JkZXJCb3R0b21XaWR0aCk6MCkpfTtteEdyYXBoLnByb3RvdHlwZS5nZXRQcmVmZXJyZWRQYWdlU2l6ZT1mdW5jdGlvbihhLGIsYyl7YT10aGlzLnZpZXcudHJhbnNsYXRlO3ZhciBkPXRoaXMucGFnZUZvcm1hdCxlPXRoaXMucGFnZVNjYWxlLGQ9bmV3IG14UmVjdGFuZ2xlKDAsMCxNYXRoLmNlaWwoZC53aWR0aCplKSxNYXRoLmNlaWwoZC5oZWlnaHQqZSkpO3JldHVybiBuZXcgbXhSZWN0YW5nbGUoMCwwLCh0aGlzLnBhZ2VCcmVha3NWaXNpYmxlP01hdGguY2VpbChiL2Qud2lkdGgpOjEpKmQud2lkdGgrMithLngsKHRoaXMucGFnZUJyZWFrc1Zpc2libGU/TWF0aC5jZWlsKGMvZC5oZWlnaHQpOjEpKmQuaGVpZ2h0KzIrYS55KX07Cm14R3JhcGgucHJvdG90eXBlLmZpdD1mdW5jdGlvbihhLGIsYyxkLGUsZixnKXtpZihudWxsIT10aGlzLmNvbnRhaW5lcil7YT1udWxsIT1hP2E6dGhpcy5nZXRCb3JkZXIoKTtiPW51bGwhPWI/YjohMTtjPW51bGwhPWM/YzowO2Q9bnVsbCE9ZD9kOiEwO2U9bnVsbCE9ZT9lOiExO2Y9bnVsbCE9Zj9mOiExO3ZhciBrPXRoaXMuZ2V0Qm9yZGVyU2l6ZXMoKSxsPXRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoLWsueC1rLndpZHRoLTEsbT1udWxsIT1nP2c6dGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0LWsueS1rLmhlaWdodC0xO2c9dGhpcy52aWV3LmdldEdyYXBoQm91bmRzKCk7aWYoMDxnLndpZHRoJiYwPGcuaGVpZ2h0KXtiJiZudWxsIT1nLngmJm51bGwhPWcueSYmKGc9Zy5jbG9uZSgpLGcud2lkdGgrPWcueCxnLmhlaWdodCs9Zy55LGcueD0wLGcueT0wKTt2YXIgaz10aGlzLnZpZXcuc2NhbGUsbj1nLndpZHRoL2sscD1nLmhlaWdodC9rO251bGwhPXRoaXMuYmFja2dyb3VuZEltYWdlJiYKKG49TWF0aC5tYXgobix0aGlzLmJhY2tncm91bmRJbWFnZS53aWR0aC1nLngvaykscD1NYXRoLm1heChwLHRoaXMuYmFja2dyb3VuZEltYWdlLmhlaWdodC1nLnkvaykpO3ZhciBxPShiP2E6MiphKStjKzEsbD1sLXEsbT1tLXE7ZT1lP20vcDpmP2wvbjpNYXRoLm1pbihsL24sbS9wKTtudWxsIT10aGlzLm1pbkZpdFNjYWxlJiYoZT1NYXRoLm1heChlLHRoaXMubWluRml0U2NhbGUpKTtudWxsIT10aGlzLm1heEZpdFNjYWxlJiYoZT1NYXRoLm1pbihlLHRoaXMubWF4Rml0U2NhbGUpKTtpZihkKWI/dGhpcy52aWV3LnNjYWxlIT1lJiZ0aGlzLnZpZXcuc2V0U2NhbGUoZSk6bXhVdGlscy5oYXNTY3JvbGxiYXJzKHRoaXMuY29udGFpbmVyKT8odGhpcy52aWV3LnNldFNjYWxlKGUpLGE9dGhpcy5nZXRHcmFwaEJvdW5kcygpLG51bGwhPWEueCYmKHRoaXMuY29udGFpbmVyLnNjcm9sbExlZnQ9YS54KSxudWxsIT1hLnkmJih0aGlzLmNvbnRhaW5lci5zY3JvbGxUb3A9YS55KSk6dGhpcy52aWV3LnNjYWxlQW5kVHJhbnNsYXRlKGUsCm51bGwhPWcueD9NYXRoLmZsb29yKHRoaXMudmlldy50cmFuc2xhdGUueC1nLngvaythL2UrYy8yKTphLG51bGwhPWcueT9NYXRoLmZsb29yKHRoaXMudmlldy50cmFuc2xhdGUueS1nLnkvaythL2UrYy8yKTphKTtlbHNlIHJldHVybiBlfX1yZXR1cm4gdGhpcy52aWV3LnNjYWxlfTsKbXhHcmFwaC5wcm90b3R5cGUuc2l6ZURpZENoYW5nZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0R3JhcGhCb3VuZHMoKTtpZihudWxsIT10aGlzLmNvbnRhaW5lcil7dmFyIGI9dGhpcy5nZXRCb3JkZXIoKSxjPU1hdGgubWF4KDAsYS54KSthLndpZHRoKzIqYixiPU1hdGgubWF4KDAsYS55KSthLmhlaWdodCsyKmI7bnVsbCE9dGhpcy5taW5pbXVtQ29udGFpbmVyU2l6ZSYmKGM9TWF0aC5tYXgoYyx0aGlzLm1pbmltdW1Db250YWluZXJTaXplLndpZHRoKSxiPU1hdGgubWF4KGIsdGhpcy5taW5pbXVtQ29udGFpbmVyU2l6ZS5oZWlnaHQpKTt0aGlzLnJlc2l6ZUNvbnRhaW5lciYmdGhpcy5kb1Jlc2l6ZUNvbnRhaW5lcihjLGIpO2lmKHRoaXMucHJlZmVyUGFnZVNpemV8fCFteENsaWVudC5JU19JRSYmdGhpcy5wYWdlVmlzaWJsZSl7dmFyIGQ9dGhpcy5nZXRQcmVmZXJyZWRQYWdlU2l6ZShhLE1hdGgubWF4KDEsYyksTWF0aC5tYXgoMSxiKSk7bnVsbCE9ZCYmKGM9ZC53aWR0aCp0aGlzLnZpZXcuc2NhbGUsCmI9ZC5oZWlnaHQqdGhpcy52aWV3LnNjYWxlKX1udWxsIT10aGlzLm1pbmltdW1HcmFwaFNpemUmJihjPU1hdGgubWF4KGMsdGhpcy5taW5pbXVtR3JhcGhTaXplLndpZHRoKnRoaXMudmlldy5zY2FsZSksYj1NYXRoLm1heChiLHRoaXMubWluaW11bUdyYXBoU2l6ZS5oZWlnaHQqdGhpcy52aWV3LnNjYWxlKSk7Yz1NYXRoLmNlaWwoYyk7Yj1NYXRoLmNlaWwoYik7dGhpcy5kaWFsZWN0PT1teENvbnN0YW50cy5ESUFMRUNUX1NWRz8oZD10aGlzLnZpZXcuZ2V0RHJhd1BhbmUoKS5vd25lclNWR0VsZW1lbnQsbnVsbCE9ZCYmKGQuc3R5bGUubWluV2lkdGg9TWF0aC5tYXgoMSxjKSsicHgiLGQuc3R5bGUubWluSGVpZ2h0PU1hdGgubWF4KDEsYikrInB4IixkLnN0eWxlLndpZHRoPSIxMDAlIixkLnN0eWxlLmhlaWdodD0iMTAwJSIpKTpteENsaWVudC5JU19RVUlSS1M/dGhpcy52aWV3LnVwZGF0ZUh0bWxDYW52YXNTaXplKE1hdGgubWF4KDEsYyksTWF0aC5tYXgoMSxiKSk6KHRoaXMudmlldy5jYW52YXMuc3R5bGUubWluV2lkdGg9Ck1hdGgubWF4KDEsYykrInB4Iix0aGlzLnZpZXcuY2FudmFzLnN0eWxlLm1pbkhlaWdodD1NYXRoLm1heCgxLGIpKyJweCIpO3RoaXMudXBkYXRlUGFnZUJyZWFrcyh0aGlzLnBhZ2VCcmVha3NWaXNpYmxlLGMsYil9dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5TSVpFLCJib3VuZHMiLGEpKX07bXhHcmFwaC5wcm90b3R5cGUuZG9SZXNpemVDb250YWluZXI9ZnVuY3Rpb24oYSxiKXtudWxsIT10aGlzLm1heGltdW1Db250YWluZXJTaXplJiYoYT1NYXRoLm1pbih0aGlzLm1heGltdW1Db250YWluZXJTaXplLndpZHRoLGEpLGI9TWF0aC5taW4odGhpcy5tYXhpbXVtQ29udGFpbmVyU2l6ZS5oZWlnaHQsYikpO3RoaXMuY29udGFpbmVyLnN0eWxlLndpZHRoPU1hdGguY2VpbChhKSsicHgiO3RoaXMuY29udGFpbmVyLnN0eWxlLmhlaWdodD1NYXRoLmNlaWwoYikrInB4In07Cm14R3JhcGgucHJvdG90eXBlLnVwZGF0ZVBhZ2VCcmVha3M9ZnVuY3Rpb24oYSxiLGMpe2I9dGhpcy52aWV3LnNjYWxlO2M9dGhpcy52aWV3LnRyYW5zbGF0ZTt2YXIgZD10aGlzLnBhZ2VGb3JtYXQsZT1iKnRoaXMucGFnZVNjYWxlLGY9bmV3IG14UmVjdGFuZ2xlKDAsMCxkLndpZHRoKmUsZC5oZWlnaHQqZSksZD1teFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlKHRoaXMuZ2V0R3JhcGhCb3VuZHMoKSk7ZC53aWR0aD1NYXRoLm1heCgxLGQud2lkdGgpO2QuaGVpZ2h0PU1hdGgubWF4KDEsZC5oZWlnaHQpO2YueD1NYXRoLmZsb29yKChkLngtYy54KmIpL2Yud2lkdGgpKmYud2lkdGgrYy54KmI7Zi55PU1hdGguZmxvb3IoKGQueS1jLnkqYikvZi5oZWlnaHQpKmYuaGVpZ2h0K2MueSpiO2Qud2lkdGg9TWF0aC5jZWlsKChkLndpZHRoKyhkLngtZi54KSkvZi53aWR0aCkqZi53aWR0aDtkLmhlaWdodD1NYXRoLmNlaWwoKGQuaGVpZ2h0KyhkLnktZi55KSkvZi5oZWlnaHQpKmYuaGVpZ2h0Owp2YXIgZz0oYT1hJiZNYXRoLm1pbihmLndpZHRoLGYuaGVpZ2h0KT50aGlzLm1pblBhZ2VCcmVha0Rpc3QpP01hdGguY2VpbChkLmhlaWdodC9mLmhlaWdodCkrMTowLGs9YT9NYXRoLmNlaWwoZC53aWR0aC9mLndpZHRoKSsxOjAsbD0oay0xKSpmLndpZHRoLG09KGctMSkqZi5oZWlnaHQ7bnVsbD09dGhpcy5ob3Jpem9udGFsUGFnZUJyZWFrcyYmMDxnJiYodGhpcy5ob3Jpem9udGFsUGFnZUJyZWFrcz1bXSk7bnVsbD09dGhpcy52ZXJ0aWNhbFBhZ2VCcmVha3MmJjA8ayYmKHRoaXMudmVydGljYWxQYWdlQnJlYWtzPVtdKTthPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe2Zvcih2YXIgYj1hPT10aGlzLmhvcml6b250YWxQYWdlQnJlYWtzP2c6ayxjPTA7Yzw9YjtjKyspe3ZhciBkPWE9PXRoaXMuaG9yaXpvbnRhbFBhZ2VCcmVha3M/W25ldyBteFBvaW50KE1hdGgucm91bmQoZi54KSxNYXRoLnJvdW5kKGYueStjKmYuaGVpZ2h0KSksbmV3IG14UG9pbnQoTWF0aC5yb3VuZChmLngrCmwpLE1hdGgucm91bmQoZi55K2MqZi5oZWlnaHQpKV06W25ldyBteFBvaW50KE1hdGgucm91bmQoZi54K2MqZi53aWR0aCksTWF0aC5yb3VuZChmLnkpKSxuZXcgbXhQb2ludChNYXRoLnJvdW5kKGYueCtjKmYud2lkdGgpLE1hdGgucm91bmQoZi55K20pKV07bnVsbCE9YVtjXT8oYVtjXS5wb2ludHM9ZCxhW2NdLnJlZHJhdygpKTooZD1uZXcgbXhQb2x5bGluZShkLHRoaXMucGFnZUJyZWFrQ29sb3IpLGQuZGlhbGVjdD10aGlzLmRpYWxlY3QsZC5wb2ludGVyRXZlbnRzPSExLGQuaXNEYXNoZWQ9dGhpcy5wYWdlQnJlYWtEYXNoZWQsZC5pbml0KHRoaXMudmlldy5iYWNrZ3JvdW5kUGFuZSksZC5yZWRyYXcoKSxhW2NdPWQpfWZvcihjPWI7YzxhLmxlbmd0aDtjKyspYVtjXS5kZXN0cm95KCk7YS5zcGxpY2UoYixhLmxlbmd0aC1iKX19KTthKHRoaXMuaG9yaXpvbnRhbFBhZ2VCcmVha3MpO2EodGhpcy52ZXJ0aWNhbFBhZ2VCcmVha3MpfTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0Q3VycmVudENlbGxTdHlsZT1mdW5jdGlvbihhLGIpe3ZhciBjPWI/bnVsbDp0aGlzLnZpZXcuZ2V0U3RhdGUoYSk7cmV0dXJuIG51bGwhPWM/Yy5zdHlsZTp0aGlzLmdldENlbGxTdHlsZShhKX07bXhHcmFwaC5wcm90b3R5cGUuZ2V0Q2VsbFN0eWxlPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubW9kZWwuZ2V0U3R5bGUoYSk7YT10aGlzLm1vZGVsLmlzRWRnZShhKT90aGlzLnN0eWxlc2hlZXQuZ2V0RGVmYXVsdEVkZ2VTdHlsZSgpOnRoaXMuc3R5bGVzaGVldC5nZXREZWZhdWx0VmVydGV4U3R5bGUoKTtudWxsIT1iJiYoYT10aGlzLnBvc3RQcm9jZXNzQ2VsbFN0eWxlKHRoaXMuc3R5bGVzaGVldC5nZXRDZWxsU3R5bGUoYixhKSkpO251bGw9PWEmJihhPXt9KTtyZXR1cm4gYX07Cm14R3JhcGgucHJvdG90eXBlLnBvc3RQcm9jZXNzQ2VsbFN0eWxlPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe3ZhciBiPWFbbXhDb25zdGFudHMuU1RZTEVfSU1BR0VdLGM9dGhpcy5nZXRJbWFnZUZyb21CdW5kbGVzKGIpO251bGwhPWM/YVtteENvbnN0YW50cy5TVFlMRV9JTUFHRV09YzpjPWI7bnVsbCE9YyYmImRhdGE6aW1hZ2UvIj09Yy5zdWJzdHJpbmcoMCwxMSkmJigiZGF0YTppbWFnZS9zdmcreG1sLDwiPT1jLnN1YnN0cmluZygwLDIwKT9jPWMuc3Vic3RyaW5nKDAsMTkpK2VuY29kZVVSSUNvbXBvbmVudChjLnN1YnN0cmluZygxOSkpOiJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDIiE9Yy5zdWJzdHJpbmcoMCwyMikmJihiPWMuaW5kZXhPZigiLCIpLDA8YiYmIjtiYXNlNjQsIiE9Yy5zdWJzdHJpbmcoYi03LGIrMSkmJihjPWMuc3Vic3RyaW5nKDAsYikrIjtiYXNlNjQsIitjLnN1YnN0cmluZyhiKzEpKSksYVtteENvbnN0YW50cy5TVFlMRV9JTUFHRV09Yyl9cmV0dXJuIGF9OwpteEdyYXBoLnByb3RvdHlwZS5zZXRDZWxsU3R5bGU9ZnVuY3Rpb24oYSxiKXtiPWJ8fHRoaXMuZ2V0U2VsZWN0aW9uQ2VsbHMoKTtpZihudWxsIT1iKXt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgYz0wO2M8Yi5sZW5ndGg7YysrKXRoaXMubW9kZWwuc2V0U3R5bGUoYltjXSxhKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9fX07bXhHcmFwaC5wcm90b3R5cGUudG9nZ2xlQ2VsbFN0eWxlPWZ1bmN0aW9uKGEsYixjKXtjPWN8fHRoaXMuZ2V0U2VsZWN0aW9uQ2VsbCgpO3JldHVybiB0aGlzLnRvZ2dsZUNlbGxTdHlsZXMoYSxiLFtjXSl9OwpteEdyYXBoLnByb3RvdHlwZS50b2dnbGVDZWxsU3R5bGVzPWZ1bmN0aW9uKGEsYixjKXtiPW51bGwhPWI/YjohMTtjPWN8fHRoaXMuZ2V0U2VsZWN0aW9uQ2VsbHMoKTt2YXIgZD1udWxsO251bGwhPWMmJjA8Yy5sZW5ndGgmJihkPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShjWzBdKSxkPW14VXRpbHMuZ2V0VmFsdWUoZCxhLGIpPzA6MSx0aGlzLnNldENlbGxTdHlsZXMoYSxkLGMpKTtyZXR1cm4gZH07bXhHcmFwaC5wcm90b3R5cGUuc2V0Q2VsbFN0eWxlcz1mdW5jdGlvbihhLGIsYyl7Yz1jfHx0aGlzLmdldFNlbGVjdGlvbkNlbGxzKCk7bXhVdGlscy5zZXRDZWxsU3R5bGVzKHRoaXMubW9kZWwsYyxhLGIpfTtteEdyYXBoLnByb3RvdHlwZS50b2dnbGVDZWxsU3R5bGVGbGFncz1mdW5jdGlvbihhLGIsYyl7dGhpcy5zZXRDZWxsU3R5bGVGbGFncyhhLGIsbnVsbCxjKX07Cm14R3JhcGgucHJvdG90eXBlLnNldENlbGxTdHlsZUZsYWdzPWZ1bmN0aW9uKGEsYixjLGQpe2Q9ZHx8dGhpcy5nZXRTZWxlY3Rpb25DZWxscygpO251bGwhPWQmJjA8ZC5sZW5ndGgmJihudWxsPT1jJiYoYz10aGlzLmdldEN1cnJlbnRDZWxsU3R5bGUoZFswXSksYz0ocGFyc2VJbnQoY1thXXx8MCkmYikhPWIpLG14VXRpbHMuc2V0Q2VsbFN0eWxlRmxhZ3ModGhpcy5tb2RlbCxkLGEsYixjKSl9OwpteEdyYXBoLnByb3RvdHlwZS5hbGlnbkNlbGxzPWZ1bmN0aW9uKGEsYixjKXtudWxsPT1iJiYoYj10aGlzLmdldFNlbGVjdGlvbkNlbGxzKCkpO2lmKG51bGwhPWImJjE8Yi5sZW5ndGgpe2lmKG51bGw9PWMpZm9yKHZhciBkPTA7ZDxiLmxlbmd0aDtkKyspe3ZhciBlPXRoaXMudmlldy5nZXRTdGF0ZShiW2RdKTtpZihudWxsIT1lJiYhdGhpcy5tb2RlbC5pc0VkZ2UoYltkXSkpaWYobnVsbD09YylpZihhPT1teENvbnN0YW50cy5BTElHTl9DRU5URVIpe2M9ZS54K2Uud2lkdGgvMjticmVha31lbHNlIGlmKGE9PW14Q29uc3RhbnRzLkFMSUdOX1JJR0hUKWM9ZS54K2Uud2lkdGg7ZWxzZSBpZihhPT1teENvbnN0YW50cy5BTElHTl9UT1ApYz1lLnk7ZWxzZSBpZihhPT1teENvbnN0YW50cy5BTElHTl9NSURETEUpe2M9ZS55K2UuaGVpZ2h0LzI7YnJlYWt9ZWxzZSBjPWE9PW14Q29uc3RhbnRzLkFMSUdOX0JPVFRPTT9lLnkrZS5oZWlnaHQ6ZS54O2Vsc2UgYz1hPT1teENvbnN0YW50cy5BTElHTl9SSUdIVD8KTWF0aC5tYXgoYyxlLngrZS53aWR0aCk6YT09bXhDb25zdGFudHMuQUxJR05fVE9QP01hdGgubWluKGMsZS55KTphPT1teENvbnN0YW50cy5BTElHTl9CT1RUT00/TWF0aC5tYXgoYyxlLnkrZS5oZWlnaHQpOk1hdGgubWluKGMsZS54KX1pZihudWxsIT1jKXt2YXIgZj10aGlzLnZpZXcuc2NhbGU7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtmb3IoZD0wO2Q8Yi5sZW5ndGg7ZCsrKWlmKGU9dGhpcy52aWV3LmdldFN0YXRlKGJbZF0pLG51bGwhPWUpe3ZhciBnPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KGJbZF0pO251bGw9PWd8fHRoaXMubW9kZWwuaXNFZGdlKGJbZF0pfHwoZz1nLmNsb25lKCksYT09bXhDb25zdGFudHMuQUxJR05fQ0VOVEVSP2cueCs9KGMtZS54LWUud2lkdGgvMikvZjphPT1teENvbnN0YW50cy5BTElHTl9SSUdIVD9nLngrPShjLWUueC1lLndpZHRoKS9mOmE9PW14Q29uc3RhbnRzLkFMSUdOX1RPUD9nLnkrPShjLWUueSkvZjphPT1teENvbnN0YW50cy5BTElHTl9NSURETEU/CmcueSs9KGMtZS55LWUuaGVpZ2h0LzIpL2Y6YT09bXhDb25zdGFudHMuQUxJR05fQk9UVE9NP2cueSs9KGMtZS55LWUuaGVpZ2h0KS9mOmcueCs9KGMtZS54KS9mLHRoaXMucmVzaXplQ2VsbChiW2RdLGcpKX10aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkFMSUdOX0NFTExTLCJhbGlnbiIsYSwiY2VsbHMiLGIpKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9fX1yZXR1cm4gYn07Cm14R3JhcGgucHJvdG90eXBlLmZsaXBFZGdlPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEmJm51bGwhPXRoaXMuYWx0ZXJuYXRlRWRnZVN0eWxlKXt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e3ZhciBiPXRoaXMubW9kZWwuZ2V0U3R5bGUoYSk7bnVsbD09Ynx8MD09Yi5sZW5ndGg/dGhpcy5tb2RlbC5zZXRTdHlsZShhLHRoaXMuYWx0ZXJuYXRlRWRnZVN0eWxlKTp0aGlzLm1vZGVsLnNldFN0eWxlKGEsbnVsbCk7dGhpcy5yZXNldEVkZ2UoYSk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5GTElQX0VER0UsImVkZ2UiLGEpKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9fXJldHVybiBhfTtteEdyYXBoLnByb3RvdHlwZS5hZGRJbWFnZUJ1bmRsZT1mdW5jdGlvbihhKXt0aGlzLmltYWdlQnVuZGxlcy5wdXNoKGEpfTsKbXhHcmFwaC5wcm90b3R5cGUucmVtb3ZlSW1hZ2VCdW5kbGU9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVtdLGM9MDtjPHRoaXMuaW1hZ2VCdW5kbGVzLmxlbmd0aDtjKyspdGhpcy5pbWFnZUJ1bmRsZXNbY10hPWEmJmIucHVzaCh0aGlzLmltYWdlQnVuZGxlc1tjXSk7dGhpcy5pbWFnZUJ1bmRsZXM9Yn07bXhHcmFwaC5wcm90b3R5cGUuZ2V0SW1hZ2VGcm9tQnVuZGxlcz1mdW5jdGlvbihhKXtpZihudWxsIT1hKWZvcih2YXIgYj0wO2I8dGhpcy5pbWFnZUJ1bmRsZXMubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5pbWFnZUJ1bmRsZXNbYl0uZ2V0SW1hZ2UoYSk7aWYobnVsbCE9YylyZXR1cm4gY31yZXR1cm4gbnVsbH07Cm14R3JhcGgucHJvdG90eXBlLm9yZGVyQ2VsbHM9ZnVuY3Rpb24oYSxiKXtudWxsPT1iJiYoYj1teFV0aWxzLnNvcnRDZWxscyh0aGlzLmdldFNlbGVjdGlvbkNlbGxzKCksITApKTt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e3RoaXMuY2VsbHNPcmRlcmVkKGIsYSksdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5PUkRFUl9DRUxMUywiYmFjayIsYSwiY2VsbHMiLGIpKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9cmV0dXJuIGJ9OwpteEdyYXBoLnByb3RvdHlwZS5jZWxsc09yZGVyZWQ9ZnVuY3Rpb24oYSxiKXtpZihudWxsIT1hKXt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKXt2YXIgZD10aGlzLm1vZGVsLmdldFBhcmVudChhW2NdKTtiP3RoaXMubW9kZWwuYWRkKGQsYVtjXSxjKTp0aGlzLm1vZGVsLmFkZChkLGFbY10sdGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGQpLTEpfXRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuQ0VMTFNfT1JERVJFRCwiYmFjayIsYiwiY2VsbHMiLGEpKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9fX07Cm14R3JhcGgucHJvdG90eXBlLmdyb3VwQ2VsbHM9ZnVuY3Rpb24oYSxiLGMpe251bGw9PWMmJihjPW14VXRpbHMuc29ydENlbGxzKHRoaXMuZ2V0U2VsZWN0aW9uQ2VsbHMoKSwhMCkpO2M9dGhpcy5nZXRDZWxsc0Zvckdyb3VwKGMpO251bGw9PWEmJihhPXRoaXMuY3JlYXRlR3JvdXBDZWxsKGMpKTt2YXIgZD10aGlzLmdldEJvdW5kc0Zvckdyb3VwKGEsYyxiKTtpZigwPGMubGVuZ3RoJiZudWxsIT1kKXt2YXIgZT10aGlzLm1vZGVsLmdldFBhcmVudChhKTtudWxsPT1lJiYoZT10aGlzLm1vZGVsLmdldFBhcmVudChjWzBdKSk7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtudWxsPT10aGlzLmdldENlbGxHZW9tZXRyeShhKSYmdGhpcy5tb2RlbC5zZXRHZW9tZXRyeShhLG5ldyBteEdlb21ldHJ5KTt2YXIgZj10aGlzLm1vZGVsLmdldENoaWxkQ291bnQoZSk7dGhpcy5jZWxsc0FkZGVkKFthXSxlLGYsbnVsbCxudWxsLCExLCExLCExKTtmPXRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChhKTsKdGhpcy5jZWxsc0FkZGVkKGMsYSxmLG51bGwsbnVsbCwhMSwhMSwhMSk7dGhpcy5jZWxsc01vdmVkKGMsLWQueCwtZC55LCExLCExLCExKTt0aGlzLmNlbGxzUmVzaXplZChbYV0sW2RdLCExKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkdST1VQX0NFTExTLCJncm91cCIsYSwiYm9yZGVyIixiLCJjZWxscyIsYykpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX19cmV0dXJuIGF9O214R3JhcGgucHJvdG90eXBlLmdldENlbGxzRm9yR3JvdXA9ZnVuY3Rpb24oYSl7dmFyIGI9W107aWYobnVsbCE9YSYmMDxhLmxlbmd0aCl7dmFyIGM9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYVswXSk7Yi5wdXNoKGFbMF0pO2Zvcih2YXIgZD0xO2Q8YS5sZW5ndGg7ZCsrKXRoaXMubW9kZWwuZ2V0UGFyZW50KGFbZF0pPT1jJiZiLnB1c2goYVtkXSl9cmV0dXJuIGJ9OwpteEdyYXBoLnByb3RvdHlwZS5nZXRCb3VuZHNGb3JHcm91cD1mdW5jdGlvbihhLGIsYyl7Yj10aGlzLmdldEJvdW5kaW5nQm94RnJvbUdlb21ldHJ5KGIsITApO251bGwhPWImJih0aGlzLmlzU3dpbWxhbmUoYSkmJihhPXRoaXMuZ2V0U3RhcnRTaXplKGEpLGIueC09YS53aWR0aCxiLnktPWEuaGVpZ2h0LGIud2lkdGgrPWEud2lkdGgsYi5oZWlnaHQrPWEuaGVpZ2h0KSxudWxsIT1jJiYoYi54LT1jLGIueS09YyxiLndpZHRoKz0yKmMsYi5oZWlnaHQrPTIqYykpO3JldHVybiBifTtteEdyYXBoLnByb3RvdHlwZS5jcmVhdGVHcm91cENlbGw9ZnVuY3Rpb24oYSl7YT1uZXcgbXhDZWxsKCIiKTthLnNldFZlcnRleCghMCk7YS5zZXRDb25uZWN0YWJsZSghMSk7cmV0dXJuIGF9OwpteEdyYXBoLnByb3RvdHlwZS51bmdyb3VwQ2VsbHM9ZnVuY3Rpb24oYSl7dmFyIGI9W107aWYobnVsbD09YSl7YT10aGlzLmdldFNlbGVjdGlvbkNlbGxzKCk7Zm9yKHZhciBjPVtdLGQ9MDtkPGEubGVuZ3RoO2QrKykwPHRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChhW2RdKSYmYy5wdXNoKGFbZF0pO2E9Y31pZihudWxsIT1hJiYwPGEubGVuZ3RoKXt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e2ZvcihkPTA7ZDxhLmxlbmd0aDtkKyspe3ZhciBlPXRoaXMubW9kZWwuZ2V0Q2hpbGRyZW4oYVtkXSk7aWYobnVsbCE9ZSYmMDxlLmxlbmd0aCl7dmFyIGU9ZS5zbGljZSgpLGY9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYVtkXSksZz10aGlzLm1vZGVsLmdldENoaWxkQ291bnQoZik7dGhpcy5jZWxsc0FkZGVkKGUsZixnLG51bGwsbnVsbCwhMCk7Yj1iLmNvbmNhdChlKX19dGhpcy5yZW1vdmVDZWxsc0FmdGVyVW5ncm91cChhKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlVOR1JPVVBfQ0VMTFMsCiJjZWxscyIsYSkpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX19cmV0dXJuIGJ9O214R3JhcGgucHJvdG90eXBlLnJlbW92ZUNlbGxzQWZ0ZXJVbmdyb3VwPWZ1bmN0aW9uKGEpe3RoaXMuY2VsbHNSZW1vdmVkKHRoaXMuYWRkQWxsRWRnZXMoYSkpfTtteEdyYXBoLnByb3RvdHlwZS5yZW1vdmVDZWxsc0Zyb21QYXJlbnQ9ZnVuY3Rpb24oYSl7bnVsbD09YSYmKGE9dGhpcy5nZXRTZWxlY3Rpb25DZWxscygpKTt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e3ZhciBiPXRoaXMuZ2V0RGVmYXVsdFBhcmVudCgpLGM9dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGIpO3RoaXMuY2VsbHNBZGRlZChhLGIsYyxudWxsLG51bGwsITApO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuUkVNT1ZFX0NFTExTX0ZST01fUEFSRU5ULCJjZWxscyIsYSkpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX1yZXR1cm4gYX07Cm14R3JhcGgucHJvdG90eXBlLnVwZGF0ZUdyb3VwQm91bmRzPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcpe251bGw9PWEmJihhPXRoaXMuZ2V0U2VsZWN0aW9uQ2VsbHMoKSk7Yj1udWxsIT1iP2I6MDtjPW51bGwhPWM/YzohMTtkPW51bGwhPWQ/ZDowO2U9bnVsbCE9ZT9lOjA7Zj1udWxsIT1mP2Y6MDtnPW51bGwhPWc/ZzowO3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBrPWEubGVuZ3RoLTE7MDw9aztrLS0pe3ZhciBsPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KGFba10pO2lmKG51bGwhPWwpe3ZhciBtPXRoaXMuZ2V0Q2hpbGRDZWxscyhhW2tdKTtpZihudWxsIT1tJiYwPG0ubGVuZ3RoKXt2YXIgbj10aGlzLmdldEJvdW5kaW5nQm94RnJvbUdlb21ldHJ5KG0sITApO2lmKG51bGwhPW4mJjA8bi53aWR0aCYmMDxuLmhlaWdodCl7dmFyIHA9MCxxPTA7aWYodGhpcy5pc1N3aW1sYW5lKGFba10pKXZhciByPXRoaXMuZ2V0U3RhcnRTaXplKGFba10pLHA9ci53aWR0aCxxPQpyLmhlaWdodDtsPWwuY2xvbmUoKTtjJiYobC54PU1hdGgucm91bmQobC54K24ueC1iLXAtZyksbC55PU1hdGgucm91bmQobC55K24ueS1iLXEtZCkpO2wud2lkdGg9TWF0aC5yb3VuZChuLndpZHRoKzIqYitwK2crZSk7bC5oZWlnaHQ9TWF0aC5yb3VuZChuLmhlaWdodCsyKmIrcStkK2YpO3RoaXMubW9kZWwuc2V0R2VvbWV0cnkoYVtrXSxsKTt0aGlzLm1vdmVDZWxscyhtLGIrcC1uLngrZyxiK3Etbi55K2QpfX19fX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9cmV0dXJuIGF9OwpteEdyYXBoLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveD1mdW5jdGlvbihhKXt2YXIgYj1udWxsO2lmKG51bGwhPWEmJjA8YS5sZW5ndGgpZm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspaWYodGhpcy5tb2RlbC5pc1ZlcnRleChhW2NdKXx8dGhpcy5tb2RlbC5pc0VkZ2UoYVtjXSkpe3ZhciBkPXRoaXMudmlldy5nZXRCb3VuZGluZ0JveCh0aGlzLnZpZXcuZ2V0U3RhdGUoYVtjXSksITApO251bGwhPWQmJihudWxsPT1iP2I9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShkKTpiLmFkZChkKSl9cmV0dXJuIGJ9O214R3JhcGgucHJvdG90eXBlLmNsb25lQ2VsbD1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gdGhpcy5jbG9uZUNlbGxzKFthXSxiLGMsZClbMF19OwpteEdyYXBoLnByb3RvdHlwZS5jbG9uZUNlbGxzPWZ1bmN0aW9uKGEsYixjLGQpe2I9bnVsbCE9Yj9iOiEwO3ZhciBlPW51bGw7aWYobnVsbCE9YSl7Zm9yKHZhciBmPW5ldyBteERpY3Rpb25hcnksZT1bXSxnPTA7ZzxhLmxlbmd0aDtnKyspZi5wdXQoYVtnXSwhMCksZS5wdXNoKGFbZ10pO2lmKDA8ZS5sZW5ndGgpZm9yKHZhciBrPXRoaXMudmlldy5zY2FsZSxsPXRoaXMudmlldy50cmFuc2xhdGUsZT10aGlzLm1vZGVsLmNsb25lQ2VsbHMoYSwhMCxjKSxnPTA7ZzxhLmxlbmd0aDtnKyspaWYoIWImJnRoaXMubW9kZWwuaXNFZGdlKGVbZ10pJiZudWxsIT10aGlzLmdldEVkZ2VWYWxpZGF0aW9uRXJyb3IoZVtnXSx0aGlzLm1vZGVsLmdldFRlcm1pbmFsKGVbZ10sITApLHRoaXMubW9kZWwuZ2V0VGVybWluYWwoZVtnXSwhMSkpKWVbZ109bnVsbDtlbHNle3ZhciBtPXRoaXMubW9kZWwuZ2V0R2VvbWV0cnkoZVtnXSk7aWYobnVsbCE9bSl7dmFyIG49dGhpcy52aWV3LmdldFN0YXRlKGFbZ10pLApwPXRoaXMudmlldy5nZXRTdGF0ZSh0aGlzLm1vZGVsLmdldFBhcmVudChhW2ddKSk7aWYobnVsbCE9biYmbnVsbCE9cClpZihjPWQ/MDpwLm9yaWdpbi54LHA9ZD8wOnAub3JpZ2luLnksdGhpcy5tb2RlbC5pc0VkZ2UoZVtnXSkpe2lmKG49bi5hYnNvbHV0ZVBvaW50cyxudWxsIT1uKXtmb3IodmFyIHE9dGhpcy5tb2RlbC5nZXRUZXJtaW5hbChhW2ddLCEwKTtudWxsIT1xJiYhZi5nZXQocSk7KXE9dGhpcy5tb2RlbC5nZXRQYXJlbnQocSk7bnVsbD09cSYmbnVsbCE9blswXSYmbS5zZXRUZXJtaW5hbFBvaW50KG5ldyBteFBvaW50KG5bMF0ueC9rLWwueCxuWzBdLnkvay1sLnkpLCEwKTtmb3IocT10aGlzLm1vZGVsLmdldFRlcm1pbmFsKGFbZ10sITEpO251bGwhPXEmJiFmLmdldChxKTspcT10aGlzLm1vZGVsLmdldFBhcmVudChxKTt2YXIgcj1uLmxlbmd0aC0xO251bGw9PXEmJm51bGwhPW5bcl0mJm0uc2V0VGVybWluYWxQb2ludChuZXcgbXhQb2ludChuW3JdLngvay1sLngsbltyXS55LwprLWwueSksITEpO209bS5wb2ludHM7aWYobnVsbCE9bSlmb3Iobj0wO248bS5sZW5ndGg7bisrKW1bbl0ueCs9YyxtW25dLnkrPXB9fWVsc2UgbS50cmFuc2xhdGUoYyxwKX19ZWxzZSBlPVtdfXJldHVybiBlfTtteEdyYXBoLnByb3RvdHlwZS5pbnNlcnRWZXJ0ZXg9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxrLGwpe2I9dGhpcy5jcmVhdGVWZXJ0ZXgoYSxiLGMsZCxlLGYsZyxrLGwpO3JldHVybiB0aGlzLmFkZENlbGwoYixhKX07bXhHcmFwaC5wcm90b3R5cGUuY3JlYXRlVmVydGV4PWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayxsKXthPW5ldyBteEdlb21ldHJ5KGQsZSxmLGcpO2EucmVsYXRpdmU9bnVsbCE9bD9sOiExO2M9bmV3IG14Q2VsbChjLGEsayk7Yy5zZXRJZChiKTtjLnNldFZlcnRleCghMCk7Yy5zZXRDb25uZWN0YWJsZSghMCk7cmV0dXJuIGN9OwpteEdyYXBoLnByb3RvdHlwZS5pbnNlcnRFZGdlPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtiPXRoaXMuY3JlYXRlRWRnZShhLGIsYyxkLGUsZik7cmV0dXJuIHRoaXMuYWRkRWRnZShiLGEsZCxlKX07bXhHcmFwaC5wcm90b3R5cGUuY3JlYXRlRWRnZT1mdW5jdGlvbihhLGIsYyxkLGUsZil7YT1uZXcgbXhDZWxsKGMsbmV3IG14R2VvbWV0cnksZik7YS5zZXRJZChiKTthLnNldEVkZ2UoITApO2EuZ2VvbWV0cnkucmVsYXRpdmU9ITA7cmV0dXJuIGF9O214R3JhcGgucHJvdG90eXBlLmFkZEVkZ2U9ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gdGhpcy5hZGRDZWxsKGEsYixlLGMsZCl9O214R3JhcGgucHJvdG90eXBlLmFkZENlbGw9ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gdGhpcy5hZGRDZWxscyhbYV0sYixjLGQsZSlbMF19OwpteEdyYXBoLnByb3RvdHlwZS5hZGRDZWxscz1mdW5jdGlvbihhLGIsYyxkLGUsZil7bnVsbD09YiYmKGI9dGhpcy5nZXREZWZhdWx0UGFyZW50KCkpO251bGw9PWMmJihjPXRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChiKSk7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt0aGlzLmNlbGxzQWRkZWQoYSxiLGMsZCxlLG51bGwhPWY/ZjohMSwhMCksdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5BRERfQ0VMTFMsImNlbGxzIixhLCJwYXJlbnQiLGIsImluZGV4IixjLCJzb3VyY2UiLGQsInRhcmdldCIsZSkpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX1yZXR1cm4gYX07Cm14R3JhcGgucHJvdG90eXBlLmNlbGxzQWRkZWQ9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxrKXtpZihudWxsIT1hJiZudWxsIT1iJiZudWxsIT1jKXt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgbD1mP3RoaXMudmlldy5nZXRTdGF0ZShiKTpudWxsLG09bnVsbCE9bD9sLm9yaWdpbjpudWxsLG49bmV3IG14UG9pbnQoMCwwKSxsPTA7bDxhLmxlbmd0aDtsKyspaWYobnVsbD09YVtsXSljLS07ZWxzZXt2YXIgcD10aGlzLm1vZGVsLmdldFBhcmVudChhW2xdKTtpZihudWxsIT1tJiZhW2xdIT1iJiZiIT1wKXt2YXIgcT10aGlzLnZpZXcuZ2V0U3RhdGUocCkscj1udWxsIT1xP3Eub3JpZ2luOm4sdD10aGlzLm1vZGVsLmdldEdlb21ldHJ5KGFbbF0pO2lmKG51bGwhPXQpe3ZhciB1PXIueC1tLngseD1yLnktbS55LHQ9dC5jbG9uZSgpO3QudHJhbnNsYXRlKHUseCk7dC5yZWxhdGl2ZXx8IXRoaXMubW9kZWwuaXNWZXJ0ZXgoYVtsXSl8fHRoaXMuaXNBbGxvd05lZ2F0aXZlQ29vcmRpbmF0ZXMoKXx8Cih0Lng9TWF0aC5tYXgoMCx0LngpLHQueT1NYXRoLm1heCgwLHQueSkpO3RoaXMubW9kZWwuc2V0R2VvbWV0cnkoYVtsXSx0KX19Yj09cCYmYytsPnRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChiKSYmYy0tO3RoaXMubW9kZWwuYWRkKGIsYVtsXSxjK2wpO3RoaXMuYXV0b1NpemVDZWxsc09uQWRkJiZ0aGlzLmF1dG9TaXplQ2VsbChhW2xdLCEwKTsobnVsbD09a3x8aykmJnRoaXMuaXNFeHRlbmRQYXJlbnRzT25BZGQoYVtsXSkmJnRoaXMuaXNFeHRlbmRQYXJlbnQoYVtsXSkmJnRoaXMuZXh0ZW5kUGFyZW50KGFbbF0pOyhudWxsPT1nfHxnKSYmdGhpcy5jb25zdHJhaW5DaGlsZChhW2xdKTtudWxsIT1kJiZ0aGlzLmNlbGxDb25uZWN0ZWQoYVtsXSxkLCEwKTtudWxsIT1lJiZ0aGlzLmNlbGxDb25uZWN0ZWQoYVtsXSxlLCExKX10aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkNFTExTX0FEREVELCJjZWxscyIsYSwicGFyZW50IixiLCJpbmRleCIsYywic291cmNlIiwKZCwidGFyZ2V0IixlLCJhYnNvbHV0ZSIsZikpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX19fTtteEdyYXBoLnByb3RvdHlwZS5hdXRvU2l6ZUNlbGw9ZnVuY3Rpb24oYSxiKXtpZihudWxsIT1iP2I6MSlmb3IodmFyIGM9dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGEpLGQ9MDtkPGM7ZCsrKXRoaXMuYXV0b1NpemVDZWxsKHRoaXMubW9kZWwuZ2V0Q2hpbGRBdChhLGQpKTt0aGlzLmdldE1vZGVsKCkuaXNWZXJ0ZXgoYSkmJnRoaXMuaXNBdXRvU2l6ZUNlbGwoYSkmJnRoaXMudXBkYXRlQ2VsbFNpemUoYSl9OwpteEdyYXBoLnByb3RvdHlwZS5yZW1vdmVDZWxscz1mdW5jdGlvbihhLGIpe2I9bnVsbCE9Yj9iOiEwO251bGw9PWEmJihhPXRoaXMuZ2V0RGVsZXRhYmxlQ2VsbHModGhpcy5nZXRTZWxlY3Rpb25DZWxscygpKSk7aWYoYilhPXRoaXMuZ2V0RGVsZXRhYmxlQ2VsbHModGhpcy5hZGRBbGxFZGdlcyhhKSk7ZWxzZXthPWEuc2xpY2UoKTtmb3IodmFyIGM9dGhpcy5nZXREZWxldGFibGVDZWxscyh0aGlzLmdldEFsbEVkZ2VzKGEpKSxkPW5ldyBteERpY3Rpb25hcnksZT0wO2U8YS5sZW5ndGg7ZSsrKWQucHV0KGFbZV0sITApO2ZvcihlPTA7ZTxjLmxlbmd0aDtlKyspbnVsbCE9dGhpcy52aWV3LmdldFN0YXRlKGNbZV0pfHxkLmdldChjW2VdKXx8KGQucHV0KGNbZV0sITApLGEucHVzaChjW2VdKSl9dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt0aGlzLmNlbGxzUmVtb3ZlZChhKSx0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlJFTU9WRV9DRUxMUywiY2VsbHMiLAphLCJpbmNsdWRlRWRnZXMiLGIpKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9cmV0dXJuIGF9OwpteEdyYXBoLnByb3RvdHlwZS5jZWxsc1JlbW92ZWQ9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSYmMDxhLmxlbmd0aCl7dmFyIGI9dGhpcy52aWV3LnNjYWxlLGM9dGhpcy52aWV3LnRyYW5zbGF0ZTt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgZD1uZXcgbXhEaWN0aW9uYXJ5LGU9MDtlPGEubGVuZ3RoO2UrKylkLnB1dChhW2VdLCEwKTtmb3IoZT0wO2U8YS5sZW5ndGg7ZSsrKXtmb3IodmFyIGY9dGhpcy5nZXRBbGxFZGdlcyhbYVtlXV0pLGc9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oZCxmKXt2YXIgZz10aGlzLm1vZGVsLmdldEdlb21ldHJ5KGQpO2lmKG51bGwhPWcpe2Zvcih2YXIgaz10aGlzLm1vZGVsLmdldFRlcm1pbmFsKGQsZiksbD0hMSxtPWs7bnVsbCE9bTspe2lmKGFbZV09PW0pe2w9ITA7YnJlYWt9bT10aGlzLm1vZGVsLmdldFBhcmVudChtKX1sJiYoZz1nLmNsb25lKCksbD10aGlzLnZpZXcuZ2V0U3RhdGUoZCksbnVsbCE9bCYmbnVsbCE9bC5hYnNvbHV0ZVBvaW50cz8KKGs9bC5hYnNvbHV0ZVBvaW50cyxtPWY/MDprLmxlbmd0aC0xLGcuc2V0VGVybWluYWxQb2ludChuZXcgbXhQb2ludChrW21dLngvYi1jLngtbC5vcmlnaW4ueCxrW21dLnkvYi1jLnktbC5vcmlnaW4ueSksZikpOihrPXRoaXMudmlldy5nZXRTdGF0ZShrKSxudWxsIT1rJiZnLnNldFRlcm1pbmFsUG9pbnQobmV3IG14UG9pbnQoay5nZXRDZW50ZXJYKCkvYi1jLngsay5nZXRDZW50ZXJZKCkvYi1jLnkpLGYpKSx0aGlzLm1vZGVsLnNldEdlb21ldHJ5KGQsZyksdGhpcy5tb2RlbC5zZXRUZXJtaW5hbChkLG51bGwsZikpfX0pLGs9MDtrPGYubGVuZ3RoO2srKylkLmdldChmW2tdKXx8KGQucHV0KGZba10sITApLGcoZltrXSwhMCksZyhmW2tdLCExKSk7dGhpcy5tb2RlbC5yZW1vdmUoYVtlXSl9dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5DRUxMU19SRU1PVkVELCJjZWxscyIsYSkpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX19fTsKbXhHcmFwaC5wcm90b3R5cGUuc3BsaXRFZGdlPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayl7ZD1kfHwwO2U9ZXx8MDtrPW51bGwhPWs/azp0aGlzLm1vZGVsLmdldFBhcmVudChhKTtmPXRoaXMubW9kZWwuZ2V0VGVybWluYWwoYSwhMCk7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtpZihudWxsPT1jKXtjPXRoaXMuY2xvbmVDZWxsKGEpO3ZhciBsPXRoaXMudmlldy5nZXRTdGF0ZShhKSxtPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KGMpO2lmKG51bGwhPW0mJm51bGwhPW0ucG9pbnRzJiZudWxsIT1sKXt2YXIgbj10aGlzLnZpZXcudHJhbnNsYXRlLHA9dGhpcy52aWV3LnNjYWxlLHE9bXhVdGlscy5maW5kTmVhcmVzdFNlZ21lbnQobCwoZCtuLngpKnAsKGUrbi55KSpwKTttLnBvaW50cz1tLnBvaW50cy5zbGljZSgwLHEpO209dGhpcy5nZXRDZWxsR2VvbWV0cnkoYSk7bnVsbCE9bSYmbnVsbCE9bS5wb2ludHMmJihtPW0uY2xvbmUoKSxtLnBvaW50cz1tLnBvaW50cy5zbGljZShxKSwKdGhpcy5tb2RlbC5zZXRHZW9tZXRyeShhLG0pKX19dGhpcy5jZWxsc01vdmVkKGIsZCxlLCExLCExKTt0aGlzLmNlbGxzQWRkZWQoYixrLHRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChrKSxudWxsLG51bGwsITApO3RoaXMuY2VsbHNBZGRlZChbY10sayx0aGlzLm1vZGVsLmdldENoaWxkQ291bnQoayksZixiWzBdLCExKTt0aGlzLmNlbGxDb25uZWN0ZWQoYSxiWzBdLCEwKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlNQTElUX0VER0UsImVkZ2UiLGEsImNlbGxzIixiLCJuZXdFZGdlIixjLCJkeCIsZCwiZHkiLGUpKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9cmV0dXJuIGN9OwpteEdyYXBoLnByb3RvdHlwZS50b2dnbGVDZWxscz1mdW5jdGlvbihhLGIsYyl7bnVsbD09YiYmKGI9dGhpcy5nZXRTZWxlY3Rpb25DZWxscygpKTtjJiYoYj10aGlzLmFkZEFsbEVkZ2VzKGIpKTt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e3RoaXMuY2VsbHNUb2dnbGVkKGIsYSksdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5UT0dHTEVfQ0VMTFMsInNob3ciLGEsImNlbGxzIixiLCJpbmNsdWRlRWRnZXMiLGMpKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9cmV0dXJuIGJ9O214R3JhcGgucHJvdG90eXBlLmNlbGxzVG9nZ2xlZD1mdW5jdGlvbihhLGIpe2lmKG51bGwhPWEmJjA8YS5sZW5ndGgpe3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspdGhpcy5tb2RlbC5zZXRWaXNpYmxlKGFbY10sYil9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX19OwpteEdyYXBoLnByb3RvdHlwZS5mb2xkQ2VsbHM9ZnVuY3Rpb24oYSxiLGMsZCxlKXtiPW51bGwhPWI/YjohMTtudWxsPT1jJiYoYz10aGlzLmdldEZvbGRhYmxlQ2VsbHModGhpcy5nZXRTZWxlY3Rpb25DZWxscygpLGEpKTt0aGlzLnN0b3BFZGl0aW5nKCExKTt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e3RoaXMuY2VsbHNGb2xkZWQoYyxhLGIsZCksdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5GT0xEX0NFTExTLCJjb2xsYXBzZSIsYSwicmVjdXJzZSIsYiwiY2VsbHMiLGMpKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9cmV0dXJuIGN9OwpteEdyYXBoLnByb3RvdHlwZS5jZWxsc0ZvbGRlZD1mdW5jdGlvbihhLGIsYyxkKXtpZihudWxsIT1hJiYwPGEubGVuZ3RoKXt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgZT0wO2U8YS5sZW5ndGg7ZSsrKWlmKCghZHx8dGhpcy5pc0NlbGxGb2xkYWJsZShhW2VdLGIpKSYmYiE9dGhpcy5pc0NlbGxDb2xsYXBzZWQoYVtlXSkpe3RoaXMubW9kZWwuc2V0Q29sbGFwc2VkKGFbZV0sYik7dGhpcy5zd2FwQm91bmRzKGFbZV0sYik7dGhpcy5pc0V4dGVuZFBhcmVudChhW2VdKSYmdGhpcy5leHRlbmRQYXJlbnQoYVtlXSk7aWYoYyl7dmFyIGY9dGhpcy5tb2RlbC5nZXRDaGlsZHJlbihhW2VdKTt0aGlzLmNlbGxzRm9sZGVkKGYsYixjKX10aGlzLmNvbnN0cmFpbkNoaWxkKGFbZV0pfXRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuQ0VMTFNfRk9MREVELCJjZWxscyIsYSwiY29sbGFwc2UiLGIsInJlY3Vyc2UiLGMpKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9fX07Cm14R3JhcGgucHJvdG90eXBlLnN3YXBCb3VuZHM9ZnVuY3Rpb24oYSxiKXtpZihudWxsIT1hKXt2YXIgYz10aGlzLm1vZGVsLmdldEdlb21ldHJ5KGEpO251bGwhPWMmJihjPWMuY2xvbmUoKSx0aGlzLnVwZGF0ZUFsdGVybmF0ZUJvdW5kcyhhLGMsYiksYy5zd2FwKCksdGhpcy5tb2RlbC5zZXRHZW9tZXRyeShhLGMpKX19OwpteEdyYXBoLnByb3RvdHlwZS51cGRhdGVBbHRlcm5hdGVCb3VuZHM9ZnVuY3Rpb24oYSxiLGMpe2lmKG51bGwhPWEmJm51bGwhPWIpe2M9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpO2lmKG51bGw9PWIuYWx0ZXJuYXRlQm91bmRzKXt2YXIgZD1iO3RoaXMuY29sbGFwc2VUb1ByZWZlcnJlZFNpemUmJihhPXRoaXMuZ2V0UHJlZmVycmVkU2l6ZUZvckNlbGwoYSksbnVsbCE9YSYmKGQ9YSxhPW14VXRpbHMuZ2V0VmFsdWUoYyxteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkUpLDA8YSYmKGQuaGVpZ2h0PU1hdGgubWF4KGQuaGVpZ2h0LGEpKSkpO2IuYWx0ZXJuYXRlQm91bmRzPW5ldyBteFJlY3RhbmdsZSgwLDAsZC53aWR0aCxkLmhlaWdodCl9aWYobnVsbCE9Yi5hbHRlcm5hdGVCb3VuZHMpe2IuYWx0ZXJuYXRlQm91bmRzLng9Yi54O2IuYWx0ZXJuYXRlQm91bmRzLnk9Yi55O3ZhciBlPW14VXRpbHMudG9SYWRpYW5zKGNbbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT05dfHwwKTsKMCE9ZSYmKGM9Yi5hbHRlcm5hdGVCb3VuZHMuZ2V0Q2VudGVyWCgpLWIuZ2V0Q2VudGVyWCgpLGQ9Yi5hbHRlcm5hdGVCb3VuZHMuZ2V0Q2VudGVyWSgpLWIuZ2V0Q2VudGVyWSgpLGE9TWF0aC5jb3MoZSksZT1NYXRoLnNpbihlKSxiLmFsdGVybmF0ZUJvdW5kcy54Kz1hKmMtZSpkLWMsYi5hbHRlcm5hdGVCb3VuZHMueSs9ZSpjK2EqZC1kKX19fTtteEdyYXBoLnByb3RvdHlwZS5hZGRBbGxFZGdlcz1mdW5jdGlvbihhKXt2YXIgYj1hLnNsaWNlKCk7cmV0dXJuIG14VXRpbHMucmVtb3ZlRHVwbGljYXRlcyhiLmNvbmNhdCh0aGlzLmdldEFsbEVkZ2VzKGEpKSl9OwpteEdyYXBoLnByb3RvdHlwZS5nZXRBbGxFZGdlcz1mdW5jdGlvbihhKXt2YXIgYj1bXTtpZihudWxsIT1hKWZvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKXtmb3IodmFyIGQ9dGhpcy5tb2RlbC5nZXRFZGdlQ291bnQoYVtjXSksZT0wO2U8ZDtlKyspYi5wdXNoKHRoaXMubW9kZWwuZ2V0RWRnZUF0KGFbY10sZSkpO2Q9dGhpcy5tb2RlbC5nZXRDaGlsZHJlbihhW2NdKTtiPWIuY29uY2F0KHRoaXMuZ2V0QWxsRWRnZXMoZCkpfXJldHVybiBifTtteEdyYXBoLnByb3RvdHlwZS51cGRhdGVDZWxsU2l6ZT1mdW5jdGlvbihhLGIpe2I9bnVsbCE9Yj9iOiExO3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7dGhpcy5jZWxsU2l6ZVVwZGF0ZWQoYSxiKSx0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlVQREFURV9DRUxMX1NJWkUsImNlbGwiLGEsImlnbm9yZUNoaWxkcmVuIixiKSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfXJldHVybiBhfTsKbXhHcmFwaC5wcm90b3R5cGUuY2VsbFNpemVVcGRhdGVkPWZ1bmN0aW9uKGEsYil7aWYobnVsbCE9YSl7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgYz10aGlzLmdldFByZWZlcnJlZFNpemVGb3JDZWxsKGEpLGQ9dGhpcy5tb2RlbC5nZXRHZW9tZXRyeShhKTtpZihudWxsIT1jJiZudWxsIT1kKXt2YXIgZT10aGlzLmlzQ2VsbENvbGxhcHNlZChhKSxkPWQuY2xvbmUoKTtpZih0aGlzLmlzU3dpbWxhbmUoYSkpe3ZhciBmPXRoaXMuZ2V0Q2VsbFN0eWxlKGEpLGc9dGhpcy5tb2RlbC5nZXRTdHlsZShhKTtudWxsPT1nJiYoZz0iIik7bXhVdGlscy5nZXRWYWx1ZShmLG14Q29uc3RhbnRzLlNUWUxFX0hPUklaT05UQUwsITApPyhnPW14VXRpbHMuc2V0U3R5bGUoZyxteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkUsYy5oZWlnaHQrOCksZSYmKGQuaGVpZ2h0PWMuaGVpZ2h0KzgpLGQud2lkdGg9Yy53aWR0aCk6KGc9bXhVdGlscy5zZXRTdHlsZShnLG14Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRSwKYy53aWR0aCs4KSxlJiYoZC53aWR0aD1jLndpZHRoKzgpLGQuaGVpZ2h0PWMuaGVpZ2h0KTt0aGlzLm1vZGVsLnNldFN0eWxlKGEsZyl9ZWxzZXt2YXIgaz10aGlzLnZpZXcuY3JlYXRlU3RhdGUoYSksbD1rLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0FMSUdOXXx8bXhDb25zdGFudHMuQUxJR05fQ0VOVEVSO2w9PW14Q29uc3RhbnRzLkFMSUdOX1JJR0hUP2QueCs9ZC53aWR0aC1jLndpZHRoOmw9PW14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUiYmKGQueCs9TWF0aC5yb3VuZCgoZC53aWR0aC1jLndpZHRoKS8yKSk7dmFyIG09dGhpcy5nZXRWZXJ0aWNhbEFsaWduKGspO209PW14Q29uc3RhbnRzLkFMSUdOX0JPVFRPTT9kLnkrPWQuaGVpZ2h0LWMuaGVpZ2h0Om09PW14Q29uc3RhbnRzLkFMSUdOX01JRERMRSYmKGQueSs9TWF0aC5yb3VuZCgoZC5oZWlnaHQtYy5oZWlnaHQpLzIpKTtkLndpZHRoPWMud2lkdGg7ZC5oZWlnaHQ9Yy5oZWlnaHR9aWYoIWImJiFlKXt2YXIgbj10aGlzLnZpZXcuZ2V0Qm91bmRzKHRoaXMubW9kZWwuZ2V0Q2hpbGRyZW4oYSkpOwppZihudWxsIT1uKXt2YXIgcD10aGlzLnZpZXcudHJhbnNsYXRlLHE9dGhpcy52aWV3LnNjYWxlLHI9KG4ueStuLmhlaWdodCkvcS1kLnktcC55O2Qud2lkdGg9TWF0aC5tYXgoZC53aWR0aCwobi54K24ud2lkdGgpL3EtZC54LXAueCk7ZC5oZWlnaHQ9TWF0aC5tYXgoZC5oZWlnaHQscil9fXRoaXMuY2VsbHNSZXNpemVkKFthXSxbZF0sITEpfX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9fX07Cm14R3JhcGgucHJvdG90eXBlLmdldFByZWZlcnJlZFNpemVGb3JDZWxsPWZ1bmN0aW9uKGEsYil7dmFyIGM9bnVsbDtpZihudWxsIT1hKXt2YXIgZD10aGlzLnZpZXcuY3JlYXRlU3RhdGUoYSksZT1kLnN0eWxlO2lmKCF0aGlzLm1vZGVsLmlzRWRnZShhKSl7dmFyIGY9ZVtteENvbnN0YW50cy5TVFlMRV9GT05UU0laRV18fG14Q29uc3RhbnRzLkRFRkFVTFRfRk9OVFNJWkUsZz0wLGM9MDtudWxsPT10aGlzLmdldEltYWdlKGQpJiZudWxsPT1lW214Q29uc3RhbnRzLlNUWUxFX0lNQUdFXXx8ZVtteENvbnN0YW50cy5TVFlMRV9TSEFQRV0hPW14Q29uc3RhbnRzLlNIQVBFX0xBQkVMfHwoZVtteENvbnN0YW50cy5TVFlMRV9WRVJUSUNBTF9BTElHTl09PW14Q29uc3RhbnRzLkFMSUdOX01JRERMRSYmKGcrPXBhcnNlRmxvYXQoZVtteENvbnN0YW50cy5TVFlMRV9JTUFHRV9XSURUSF0pfHxteExhYmVsLnByb3RvdHlwZS5pbWFnZVNpemUpLGVbbXhDb25zdGFudHMuU1RZTEVfQUxJR05dIT0KbXhDb25zdGFudHMuQUxJR05fQ0VOVEVSJiYoYys9cGFyc2VGbG9hdChlW214Q29uc3RhbnRzLlNUWUxFX0lNQUdFX0hFSUdIVF0pfHxteExhYmVsLnByb3RvdHlwZS5pbWFnZVNpemUpKTt2YXIgZz1nKzIqKGVbbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lOR118fDApLGc9ZysoZVtteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HX0xFRlRdfHwwKSxnPWcrKGVbbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lOR19SSUdIVF18fDApLGM9YysyKihlW214Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkddfHwwKSxjPWMrKGVbbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lOR19UT1BdfHwwKSxjPWMrKGVbbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lOR19CT1RUT01dfHwwKSxrPXRoaXMuZ2V0Rm9sZGluZ0ltYWdlKGQpO251bGwhPWsmJihnKz1rLndpZHRoKzgpO2s9dGhpcy5jZWxsUmVuZGVyZXIuZ2V0TGFiZWxWYWx1ZShkKTtudWxsIT1rJiYwPGsubGVuZ3RoPyh0aGlzLmlzSHRtbExhYmVsKGQuY2VsbCl8fChrPQpteFV0aWxzLmh0bWxFbnRpdGllcyhrLCExKSksaz1rLnJlcGxhY2UoL1xuL2csIjxicj4iKSxmPW14VXRpbHMuZ2V0U2l6ZUZvclN0cmluZyhrLGYsZVtteENvbnN0YW50cy5TVFlMRV9GT05URkFNSUxZXSxiLGVbbXhDb25zdGFudHMuU1RZTEVfRk9OVFNUWUxFXSksZD1mLndpZHRoK2csYz1mLmhlaWdodCtjLG14VXRpbHMuZ2V0VmFsdWUoZSxteENvbnN0YW50cy5TVFlMRV9IT1JJWk9OVEFMLCEwKXx8KGU9YyxjPWQsZD1lKSx0aGlzLmdyaWRFbmFibGVkJiYoZD10aGlzLnNuYXAoZCt0aGlzLmdyaWRTaXplLzIpLGM9dGhpcy5zbmFwKGMrdGhpcy5ncmlkU2l6ZS8yKSksYz1uZXcgbXhSZWN0YW5nbGUoMCwwLGQsYykpOihlPTQqdGhpcy5ncmlkU2l6ZSxjPW5ldyBteFJlY3RhbmdsZSgwLDAsZSxlKSl9fXJldHVybiBjfTtteEdyYXBoLnByb3RvdHlwZS5yZXNpemVDZWxsPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gdGhpcy5yZXNpemVDZWxscyhbYV0sW2JdLGMpWzBdfTsKbXhHcmFwaC5wcm90b3R5cGUucmVzaXplQ2VsbHM9ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbCE9Yz9jOnRoaXMuaXNSZWN1cnNpdmVSZXNpemUoKTt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e3ZhciBkPXRoaXMuY2VsbHNSZXNpemVkKGEsYixjKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlJFU0laRV9DRUxMUywiY2VsbHMiLGEsImJvdW5kcyIsYiwicHJldmlvdXMiLGQpKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9cmV0dXJuIGF9OwpteEdyYXBoLnByb3RvdHlwZS5jZWxsc1Jlc2l6ZWQ9ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbCE9Yz9jOiExO3ZhciBkPVtdO2lmKG51bGwhPWEmJm51bGwhPWImJmEubGVuZ3RoPT1iLmxlbmd0aCl7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGU9MDtlPGEubGVuZ3RoO2UrKylkLnB1c2godGhpcy5jZWxsUmVzaXplZChhW2VdLGJbZV0sITEsYykpLHRoaXMuaXNFeHRlbmRQYXJlbnQoYVtlXSkmJnRoaXMuZXh0ZW5kUGFyZW50KGFbZV0pLHRoaXMuY29uc3RyYWluQ2hpbGQoYVtlXSk7dGhpcy5yZXNldEVkZ2VzT25SZXNpemUmJnRoaXMucmVzZXRFZGdlcyhhKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkNFTExTX1JFU0laRUQsImNlbGxzIixhLCJib3VuZHMiLGIsInByZXZpb3VzIixkKSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX1yZXR1cm4gZH07Cm14R3JhcGgucHJvdG90eXBlLmNlbGxSZXNpemVkPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMubW9kZWwuZ2V0R2VvbWV0cnkoYSk7aWYobnVsbCE9ZSYmKGUueCE9Yi54fHxlLnkhPWIueXx8ZS53aWR0aCE9Yi53aWR0aHx8ZS5oZWlnaHQhPWIuaGVpZ2h0KSl7dmFyIGY9ZS5jbG9uZSgpOyFjJiZmLnJlbGF0aXZlPyhjPWYub2Zmc2V0LG51bGwhPWMmJihjLngrPWIueC1mLngsYy55Kz1iLnktZi55KSk6KGYueD1iLngsZi55PWIueSk7Zi53aWR0aD1iLndpZHRoO2YuaGVpZ2h0PWIuaGVpZ2h0O2YucmVsYXRpdmV8fCF0aGlzLm1vZGVsLmlzVmVydGV4KGEpfHx0aGlzLmlzQWxsb3dOZWdhdGl2ZUNvb3JkaW5hdGVzKCl8fChmLng9TWF0aC5tYXgoMCxmLngpLGYueT1NYXRoLm1heCgwLGYueSkpO3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7ZCYmdGhpcy5yZXNpemVDaGlsZENlbGxzKGEsZiksdGhpcy5tb2RlbC5zZXRHZW9tZXRyeShhLGYpLHRoaXMuY29uc3RyYWluQ2hpbGRDZWxscyhhKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9fXJldHVybiBlfTsKbXhHcmFwaC5wcm90b3R5cGUucmVzaXplQ2hpbGRDZWxscz1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz10aGlzLm1vZGVsLmdldEdlb21ldHJ5KGEpLGQ9Yi53aWR0aC9jLndpZHRoLGM9Yi5oZWlnaHQvYy5oZWlnaHQsZT10aGlzLm1vZGVsLmdldENoaWxkQ291bnQoYSksZj0wO2Y8ZTtmKyspdGhpcy5zY2FsZUNlbGwodGhpcy5tb2RlbC5nZXRDaGlsZEF0KGEsZiksZCxjLCEwKX07bXhHcmFwaC5wcm90b3R5cGUuY29uc3RyYWluQ2hpbGRDZWxscz1mdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGEpLGM9MDtjPGI7YysrKXRoaXMuY29uc3RyYWluQ2hpbGQodGhpcy5tb2RlbC5nZXRDaGlsZEF0KGEsYykpfTsKbXhHcmFwaC5wcm90b3R5cGUuc2NhbGVDZWxsPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMubW9kZWwuZ2V0R2VvbWV0cnkoYSk7aWYobnVsbCE9ZSl7dmFyIGY9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpLGU9ZS5jbG9uZSgpLGc9ZS54LGs9ZS55LGw9ZS53aWR0aCxtPWUuaGVpZ2h0O2Uuc2NhbGUoYixjLCJmaXhlZCI9PWZbbXhDb25zdGFudHMuU1RZTEVfQVNQRUNUXSk7IjEiPT1mW214Q29uc3RhbnRzLlNUWUxFX1JFU0laRV9XSURUSF0/ZS53aWR0aD1sKmI6IjAiPT1mW214Q29uc3RhbnRzLlNUWUxFX1JFU0laRV9XSURUSF0mJihlLndpZHRoPWwpOyIxIj09ZltteENvbnN0YW50cy5TVFlMRV9SRVNJWkVfSEVJR0hUXT9lLmhlaWdodD1tKmM6IjAiPT1mW214Q29uc3RhbnRzLlNUWUxFX1JFU0laRV9IRUlHSFRdJiYoZS5oZWlnaHQ9bSk7dGhpcy5pc0NlbGxNb3ZhYmxlKGEpfHwoZS54PWcsZS55PWspO3RoaXMuaXNDZWxsUmVzaXphYmxlKGEpfHwoZS53aWR0aD1sLAplLmhlaWdodD1tKTt0aGlzLm1vZGVsLmlzVmVydGV4KGEpP3RoaXMuY2VsbFJlc2l6ZWQoYSxlLCEwLGQpOnRoaXMubW9kZWwuc2V0R2VvbWV0cnkoYSxlKX19O214R3JhcGgucHJvdG90eXBlLmV4dGVuZFBhcmVudD1mdW5jdGlvbihhKXtpZihudWxsIT1hKXt2YXIgYj10aGlzLm1vZGVsLmdldFBhcmVudChhKSxjPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KGIpO251bGw9PWJ8fG51bGw9PWN8fHRoaXMuaXNDZWxsQ29sbGFwc2VkKGIpfHwoYT10aGlzLmdldENlbGxHZW9tZXRyeShhKSxudWxsIT1hJiYhYS5yZWxhdGl2ZSYmKGMud2lkdGg8YS54K2Eud2lkdGh8fGMuaGVpZ2h0PGEueSthLmhlaWdodCkmJihjPWMuY2xvbmUoKSxjLndpZHRoPU1hdGgubWF4KGMud2lkdGgsYS54K2Eud2lkdGgpLGMuaGVpZ2h0PU1hdGgubWF4KGMuaGVpZ2h0LGEueSthLmhlaWdodCksdGhpcy5jZWxsc1Jlc2l6ZWQoW2JdLFtjXSwhMSkpKX19OwpteEdyYXBoLnByb3RvdHlwZS5pbXBvcnRDZWxscz1mdW5jdGlvbihhLGIsYyxkLGUsZil7cmV0dXJuIHRoaXMubW92ZUNlbGxzKGEsYixjLCEwLGQsZSxmKX07Cm14R3JhcGgucHJvdG90eXBlLm1vdmVDZWxscz1mdW5jdGlvbihhLGIsYyxkLGUsZixnKXtiPW51bGwhPWI/YjowO2M9bnVsbCE9Yz9jOjA7ZD1udWxsIT1kP2Q6ITE7aWYobnVsbCE9YSYmKDAhPWJ8fDAhPWN8fGR8fG51bGwhPWUpKXthPXRoaXMubW9kZWwuZ2V0VG9wbW9zdENlbGxzKGEpO3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBrPW5ldyBteERpY3Rpb25hcnksbD0wO2w8YS5sZW5ndGg7bCsrKWsucHV0KGFbbF0sITApO2Zvcih2YXIgbT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtmb3IoO251bGwhPWE7KXtpZihrLmdldChhKSlyZXR1cm4hMDthPXRoaXMubW9kZWwuZ2V0UGFyZW50KGEpfXJldHVybiExfSksbj1bXSxsPTA7bDxhLmxlbmd0aDtsKyspe3ZhciBwPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KGFbbF0pLHE9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYVtsXSk7bnVsbCE9cCYmcC5yZWxhdGl2ZSYmdGhpcy5tb2RlbC5pc0VkZ2UocSkmJihtKHRoaXMubW9kZWwuZ2V0VGVybWluYWwocSwKITApKXx8bSh0aGlzLm1vZGVsLmdldFRlcm1pbmFsKHEsITEpKSl8fG4ucHVzaChhW2xdKX1hPW47ZCYmKGE9dGhpcy5jbG9uZUNlbGxzKGEsdGhpcy5pc0Nsb25lSW52YWxpZEVkZ2VzKCksZyksbnVsbD09ZSYmKGU9dGhpcy5nZXREZWZhdWx0UGFyZW50KCkpKTt2YXIgcj10aGlzLmlzQWxsb3dOZWdhdGl2ZUNvb3JkaW5hdGVzKCk7bnVsbCE9ZSYmdGhpcy5zZXRBbGxvd05lZ2F0aXZlQ29vcmRpbmF0ZXMoITApO3RoaXMuY2VsbHNNb3ZlZChhLGIsYywhZCYmdGhpcy5pc0Rpc2Nvbm5lY3RPbk1vdmUoKSYmdGhpcy5pc0FsbG93RGFuZ2xpbmdFZGdlcygpLG51bGw9PWUsdGhpcy5pc0V4dGVuZFBhcmVudHNPbk1vdmUoKSYmbnVsbD09ZSk7dGhpcy5zZXRBbGxvd05lZ2F0aXZlQ29vcmRpbmF0ZXMocik7aWYobnVsbCE9ZSl7dmFyIHQ9dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGUpO3RoaXMuY2VsbHNBZGRlZChhLGUsdCxudWxsLG51bGwsITApfXRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuTU9WRV9DRUxMUywKImNlbGxzIixhLCJkeCIsYiwiZHkiLGMsImNsb25lIixkLCJ0YXJnZXQiLGUsImV2ZW50IixmKSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX1yZXR1cm4gYX07Cm14R3JhcGgucHJvdG90eXBlLmNlbGxzTW92ZWQ9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2lmKG51bGwhPWEmJigwIT1ifHwwIT1jKSl7Zj1udWxsIT1mP2Y6ITE7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtkJiZ0aGlzLmRpc2Nvbm5lY3RHcmFwaChhKTtmb3IodmFyIGc9MDtnPGEubGVuZ3RoO2crKyl0aGlzLnRyYW5zbGF0ZUNlbGwoYVtnXSxiLGMpLGYmJnRoaXMuaXNFeHRlbmRQYXJlbnQoYVtnXSk/dGhpcy5leHRlbmRQYXJlbnQoYVtnXSk6ZSYmdGhpcy5jb25zdHJhaW5DaGlsZChhW2ddKTt0aGlzLnJlc2V0RWRnZXNPbk1vdmUmJnRoaXMucmVzZXRFZGdlcyhhKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkNFTExTX01PVkVELCJjZWxscyIsYSwiZHgiLGIsImR5IixjLCJkaXNjb25uZWN0IixkKSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX19OwpteEdyYXBoLnByb3RvdHlwZS50cmFuc2xhdGVDZWxsPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLm1vZGVsLmdldEdlb21ldHJ5KGEpO2lmKG51bGwhPWQpe2I9cGFyc2VGbG9hdChiKTtjPXBhcnNlRmxvYXQoYyk7ZD1kLmNsb25lKCk7ZC50cmFuc2xhdGUoYixjKTtkLnJlbGF0aXZlfHwhdGhpcy5tb2RlbC5pc1ZlcnRleChhKXx8dGhpcy5pc0FsbG93TmVnYXRpdmVDb29yZGluYXRlcygpfHwoZC54PU1hdGgubWF4KDAscGFyc2VGbG9hdChkLngpKSxkLnk9TWF0aC5tYXgoMCxwYXJzZUZsb2F0KGQueSkpKTtpZihkLnJlbGF0aXZlJiYhdGhpcy5tb2RlbC5pc0VkZ2UoYSkpe3ZhciBlPXRoaXMubW9kZWwuZ2V0UGFyZW50KGEpLGY9MDt0aGlzLm1vZGVsLmlzVmVydGV4KGUpJiYoZT10aGlzLmdldEN1cnJlbnRDZWxsU3R5bGUoZSksZj1teFV0aWxzLmdldFZhbHVlKGUsbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT04sMCkpOzAhPWYmJihmPW14VXRpbHMudG9SYWRpYW5zKC1mKSwKZT1NYXRoLmNvcyhmKSxmPU1hdGguc2luKGYpLGM9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQobmV3IG14UG9pbnQoYixjKSxlLGYsbmV3IG14UG9pbnQoMCwwKSksYj1jLngsYz1jLnkpO251bGw9PWQub2Zmc2V0P2Qub2Zmc2V0PW5ldyBteFBvaW50KGIsYyk6KGQub2Zmc2V0Lng9cGFyc2VGbG9hdChkLm9mZnNldC54KStiLGQub2Zmc2V0Lnk9cGFyc2VGbG9hdChkLm9mZnNldC55KStjKX10aGlzLm1vZGVsLnNldEdlb21ldHJ5KGEsZCl9fTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0Q2VsbENvbnRhaW5tZW50QXJlYT1mdW5jdGlvbihhKXtpZihudWxsIT1hJiYhdGhpcy5tb2RlbC5pc0VkZ2UoYSkpe3ZhciBiPXRoaXMubW9kZWwuZ2V0UGFyZW50KGEpO2lmKG51bGwhPWImJmIhPXRoaXMuZ2V0RGVmYXVsdFBhcmVudCgpKXt2YXIgYz10aGlzLm1vZGVsLmdldEdlb21ldHJ5KGIpO2lmKG51bGwhPWMpe3ZhciBkPWE9MCxlPWMud2lkdGgsYz1jLmhlaWdodDtpZih0aGlzLmlzU3dpbWxhbmUoYikpe3ZhciBmPXRoaXMuZ2V0U3RhcnRTaXplKGIpLGc9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGIpLGI9bXhVdGlscy5nZXRWYWx1ZShnLG14Q29uc3RhbnRzLlNUWUxFX0RJUkVDVElPTixteENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVCksaz0xPT1teFV0aWxzLmdldFZhbHVlKGcsbXhDb25zdGFudHMuU1RZTEVfRkxJUEgsMCksZz0xPT1teFV0aWxzLmdldFZhbHVlKGcsbXhDb25zdGFudHMuU1RZTEVfRkxJUFYsMCk7aWYoYj09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIfHwKYj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIKXt2YXIgbD1mLndpZHRoO2Yud2lkdGg9Zi5oZWlnaHQ7Zi5oZWlnaHQ9bH1pZihiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVCYmIWd8fGI9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSCYmIWt8fGI9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUJiZnfHxiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEgmJmspYT1mLndpZHRoLGQ9Zi5oZWlnaHQ7ZS09Zi53aWR0aDtjLT1mLmhlaWdodH1yZXR1cm4gbmV3IG14UmVjdGFuZ2xlKGEsZCxlLGMpfX19cmV0dXJuIG51bGx9O214R3JhcGgucHJvdG90eXBlLmdldE1heGltdW1HcmFwaEJvdW5kcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1heGltdW1HcmFwaEJvdW5kc307Cm14R3JhcGgucHJvdG90eXBlLmNvbnN0cmFpbkNoaWxkPWZ1bmN0aW9uKGEsYil7aWYobnVsbCE9YSl7dmFyIGM9dGhpcy5nZXRDZWxsR2VvbWV0cnkoYSk7aWYobnVsbCE9YyYmKHRoaXMuaXNDb25zdHJhaW5SZWxhdGl2ZUNoaWxkcmVuKCl8fCFjLnJlbGF0aXZlKSl7dmFyIGQ9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYSk7dGhpcy5nZXRDZWxsR2VvbWV0cnkoZCk7dmFyIGU9dGhpcy5nZXRNYXhpbXVtR3JhcGhCb3VuZHMoKTtudWxsIT1lJiYoZD10aGlzLmdldEJvdW5kaW5nQm94RnJvbUdlb21ldHJ5KFtkXSwhMSksbnVsbCE9ZCYmKGU9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShlKSxlLngtPWQueCxlLnktPWQueSkpO2lmKHRoaXMuaXNDb25zdHJhaW5DaGlsZChhKSYmKGQ9dGhpcy5nZXRDZWxsQ29udGFpbm1lbnRBcmVhKGEpLG51bGwhPWQpKXt2YXIgZj10aGlzLmdldE92ZXJsYXAoYSk7MDxmJiYoZD1teFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlKGQpLGQueC09ZC53aWR0aCoKZixkLnktPWQuaGVpZ2h0KmYsZC53aWR0aCs9MipkLndpZHRoKmYsZC5oZWlnaHQrPTIqZC5oZWlnaHQqZik7bnVsbD09ZT9lPWQ6KGU9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShlKSxlLmludGVyc2VjdChkKSl9aWYobnVsbCE9ZSl7ZD1bYV07aWYoIXRoaXMuaXNDZWxsQ29sbGFwc2VkKGEpKWZvcih2YXIgZj10aGlzLm1vZGVsLmdldERlc2NlbmRhbnRzKGEpLGc9MDtnPGYubGVuZ3RoO2crKyl0aGlzLmlzQ2VsbFZpc2libGUoZltnXSkmJmQucHVzaChmW2ddKTtkPXRoaXMuZ2V0Qm91bmRpbmdCb3hGcm9tR2VvbWV0cnkoZCwhMSk7aWYobnVsbCE9ZCl7Yz1jLmNsb25lKCk7Zj0wO2Mud2lkdGg+ZS53aWR0aCYmKGY9Yy53aWR0aC1lLndpZHRoLGMud2lkdGgtPWYpO2QueCtkLndpZHRoPmUueCtlLndpZHRoJiYoZi09ZC54K2Qud2lkdGgtZS54LWUud2lkdGgtZik7Zz0wO2MuaGVpZ2h0PmUuaGVpZ2h0JiYoZz1jLmhlaWdodC1lLmhlaWdodCxjLmhlaWdodC09Zyk7ZC55K2QuaGVpZ2h0PgplLnkrZS5oZWlnaHQmJihnLT1kLnkrZC5oZWlnaHQtZS55LWUuaGVpZ2h0LWcpO2QueDxlLngmJihmLT1kLngtZS54KTtkLnk8ZS55JiYoZy09ZC55LWUueSk7aWYoMCE9Znx8MCE9ZyljLnJlbGF0aXZlPyhudWxsPT1jLm9mZnNldCYmKGMub2Zmc2V0PW5ldyBteFBvaW50KSxjLm9mZnNldC54Kz1mLGMub2Zmc2V0LnkrPWcpOihjLngrPWYsYy55Kz1nKTt0aGlzLm1vZGVsLnNldEdlb21ldHJ5KGEsYyl9fX19fTsKbXhHcmFwaC5wcm90b3R5cGUucmVzZXRFZGdlcz1mdW5jdGlvbihhKXtpZihudWxsIT1hKXtmb3IodmFyIGI9bmV3IG14RGljdGlvbmFyeSxjPTA7YzxhLmxlbmd0aDtjKyspYi5wdXQoYVtjXSwhMCk7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtmb3IoYz0wO2M8YS5sZW5ndGg7YysrKXt2YXIgZD10aGlzLm1vZGVsLmdldEVkZ2VzKGFbY10pO2lmKG51bGwhPWQpZm9yKHZhciBlPTA7ZTxkLmxlbmd0aDtlKyspe3ZhciBmPXRoaXMudmlldy5nZXRTdGF0ZShkW2VdKSxnPW51bGwhPWY/Zi5nZXRWaXNpYmxlVGVybWluYWwoITApOnRoaXMudmlldy5nZXRWaXNpYmxlVGVybWluYWwoZFtlXSwhMCksaz1udWxsIT1mP2YuZ2V0VmlzaWJsZVRlcm1pbmFsKCExKTp0aGlzLnZpZXcuZ2V0VmlzaWJsZVRlcm1pbmFsKGRbZV0sITEpO2IuZ2V0KGcpJiZiLmdldChrKXx8dGhpcy5yZXNldEVkZ2UoZFtlXSl9dGhpcy5yZXNldEVkZ2VzKHRoaXMubW9kZWwuZ2V0Q2hpbGRyZW4oYVtjXSkpfX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9fX07Cm14R3JhcGgucHJvdG90eXBlLnJlc2V0RWRnZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLm1vZGVsLmdldEdlb21ldHJ5KGEpO251bGwhPWImJm51bGwhPWIucG9pbnRzJiYwPGIucG9pbnRzLmxlbmd0aCYmKGI9Yi5jbG9uZSgpLGIucG9pbnRzPVtdLHRoaXMubW9kZWwuc2V0R2VvbWV0cnkoYSxiKSk7cmV0dXJuIGF9OwpteEdyYXBoLnByb3RvdHlwZS5nZXRPdXRsaW5lQ29uc3RyYWludD1mdW5jdGlvbihhLGIsYyl7aWYobnVsbCE9Yi5zaGFwZSl7Yz10aGlzLnZpZXcuZ2V0UGVyaW1ldGVyQm91bmRzKGIpO3ZhciBkPWIuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRElSRUNUSU9OXTtpZihkPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEh8fGQ9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSCl7Yy54Kz1jLndpZHRoLzItYy5oZWlnaHQvMjtjLnkrPWMuaGVpZ2h0LzItYy53aWR0aC8yO3ZhciBlPWMud2lkdGg7Yy53aWR0aD1jLmhlaWdodDtjLmhlaWdodD1lfXZhciBmPW14VXRpbHMudG9SYWRpYW5zKGIuc2hhcGUuZ2V0U2hhcGVSb3RhdGlvbigpKTtpZigwIT1mKXt2YXIgZT1NYXRoLmNvcygtZiksZj1NYXRoLnNpbigtZiksZz1uZXcgbXhQb2ludChjLmdldENlbnRlclgoKSxjLmdldENlbnRlclkoKSk7YT1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChhLGUsZixnKX12YXIgZz1mPTEsaz0wLGw9CjA7aWYodGhpcy5nZXRNb2RlbCgpLmlzVmVydGV4KGIuY2VsbCkpe3ZhciBtPWIuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRkxJUEhdLG49Yi5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9GTElQVl07bnVsbCE9Yi5zaGFwZSYmbnVsbCE9Yi5zaGFwZS5zdGVuY2lsJiYobT0xPT1teFV0aWxzLmdldFZhbHVlKGIuc3R5bGUsInN0ZW5jaWxGbGlwSCIsMCl8fG0sbj0xPT1teFV0aWxzLmdldFZhbHVlKGIuc3R5bGUsInN0ZW5jaWxGbGlwViIsMCl8fG4pO2lmKGQ9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSHx8ZD09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIKWU9bSxtPW4sbj1lO20mJihmPS0xLGs9LWMud2lkdGgpO24mJihnPS0xLGw9LWMuaGVpZ2h0KX1hPW5ldyBteFBvaW50KChhLngtYy54KSpmLWsrYy54LChhLnktYy55KSpnLWwrYy55KTtyZXR1cm4gbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMD09Yy53aWR0aD8wOk1hdGgucm91bmQoMUUzKgooYS54LWMueCkvYy53aWR0aCkvMUUzLDA9PWMuaGVpZ2h0PzA6TWF0aC5yb3VuZCgxRTMqKGEueS1jLnkpL2MuaGVpZ2h0KS8xRTMpLCExKX1yZXR1cm4gbnVsbH07bXhHcmFwaC5wcm90b3R5cGUuZ2V0QWxsQ29ubmVjdGlvbkNvbnN0cmFpbnRzPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG51bGwhPWEmJm51bGwhPWEuc2hhcGUmJm51bGwhPWEuc2hhcGUuc3RlbmNpbD9hLnNoYXBlLnN0ZW5jaWwuY29uc3RyYWludHM6bnVsbH07Cm14R3JhcGgucHJvdG90eXBlLmdldENvbm5lY3Rpb25Db25zdHJhaW50PWZ1bmN0aW9uKGEsYixjKXtiPW51bGw7dmFyIGQ9YS5zdHlsZVtjP214Q29uc3RhbnRzLlNUWUxFX0VYSVRfWDpteENvbnN0YW50cy5TVFlMRV9FTlRSWV9YXTtpZihudWxsIT1kKXt2YXIgZT1hLnN0eWxlW2M/bXhDb25zdGFudHMuU1RZTEVfRVhJVF9ZOm14Q29uc3RhbnRzLlNUWUxFX0VOVFJZX1ldO251bGwhPWUmJihiPW5ldyBteFBvaW50KHBhcnNlRmxvYXQoZCkscGFyc2VGbG9hdChlKSkpfXZhciBkPSExLGY9ZT0wO251bGwhPWImJihkPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxjP214Q29uc3RhbnRzLlNUWUxFX0VYSVRfUEVSSU1FVEVSOm14Q29uc3RhbnRzLlNUWUxFX0VOVFJZX1BFUklNRVRFUiwhMCksZT1wYXJzZUZsb2F0KGEuc3R5bGVbYz9teENvbnN0YW50cy5TVFlMRV9FWElUX0RYOm14Q29uc3RhbnRzLlNUWUxFX0VOVFJZX0RYXSksZj1wYXJzZUZsb2F0KGEuc3R5bGVbYz9teENvbnN0YW50cy5TVFlMRV9FWElUX0RZOgpteENvbnN0YW50cy5TVFlMRV9FTlRSWV9EWV0pLGU9aXNGaW5pdGUoZSk/ZTowLGY9aXNGaW5pdGUoZik/ZjowKTtyZXR1cm4gbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQoYixkLG51bGwsZSxmKX07Cm14R3JhcGgucHJvdG90eXBlLnNldENvbm5lY3Rpb25Db25zdHJhaW50PWZ1bmN0aW9uKGEsYixjLGQpe2lmKG51bGwhPWQpe3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7bnVsbD09ZHx8bnVsbD09ZC5wb2ludD8odGhpcy5zZXRDZWxsU3R5bGVzKGM/bXhDb25zdGFudHMuU1RZTEVfRVhJVF9YOm14Q29uc3RhbnRzLlNUWUxFX0VOVFJZX1gsbnVsbCxbYV0pLHRoaXMuc2V0Q2VsbFN0eWxlcyhjP214Q29uc3RhbnRzLlNUWUxFX0VYSVRfWTpteENvbnN0YW50cy5TVFlMRV9FTlRSWV9ZLG51bGwsW2FdKSx0aGlzLnNldENlbGxTdHlsZXMoYz9teENvbnN0YW50cy5TVFlMRV9FWElUX0RYOm14Q29uc3RhbnRzLlNUWUxFX0VOVFJZX0RYLG51bGwsW2FdKSx0aGlzLnNldENlbGxTdHlsZXMoYz9teENvbnN0YW50cy5TVFlMRV9FWElUX0RZOm14Q29uc3RhbnRzLlNUWUxFX0VOVFJZX0RZLG51bGwsW2FdKSx0aGlzLnNldENlbGxTdHlsZXMoYz9teENvbnN0YW50cy5TVFlMRV9FWElUX1BFUklNRVRFUjoKbXhDb25zdGFudHMuU1RZTEVfRU5UUllfUEVSSU1FVEVSLG51bGwsW2FdKSk6bnVsbCE9ZC5wb2ludCYmKHRoaXMuc2V0Q2VsbFN0eWxlcyhjP214Q29uc3RhbnRzLlNUWUxFX0VYSVRfWDpteENvbnN0YW50cy5TVFlMRV9FTlRSWV9YLGQucG9pbnQueCxbYV0pLHRoaXMuc2V0Q2VsbFN0eWxlcyhjP214Q29uc3RhbnRzLlNUWUxFX0VYSVRfWTpteENvbnN0YW50cy5TVFlMRV9FTlRSWV9ZLGQucG9pbnQueSxbYV0pLHRoaXMuc2V0Q2VsbFN0eWxlcyhjP214Q29uc3RhbnRzLlNUWUxFX0VYSVRfRFg6bXhDb25zdGFudHMuU1RZTEVfRU5UUllfRFgsZC5keCxbYV0pLHRoaXMuc2V0Q2VsbFN0eWxlcyhjP214Q29uc3RhbnRzLlNUWUxFX0VYSVRfRFk6bXhDb25zdGFudHMuU1RZTEVfRU5UUllfRFksZC5keSxbYV0pLGQucGVyaW1ldGVyP3RoaXMuc2V0Q2VsbFN0eWxlcyhjP214Q29uc3RhbnRzLlNUWUxFX0VYSVRfUEVSSU1FVEVSOm14Q29uc3RhbnRzLlNUWUxFX0VOVFJZX1BFUklNRVRFUiwKbnVsbCxbYV0pOnRoaXMuc2V0Q2VsbFN0eWxlcyhjP214Q29uc3RhbnRzLlNUWUxFX0VYSVRfUEVSSU1FVEVSOm14Q29uc3RhbnRzLlNUWUxFX0VOVFJZX1BFUklNRVRFUiwiMCIsW2FdKSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX19OwpteEdyYXBoLnByb3RvdHlwZS5nZXRDb25uZWN0aW9uUG9pbnQ9ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbCE9Yz9jOiEwO3ZhciBkPW51bGw7aWYobnVsbCE9YSYmbnVsbCE9Yi5wb2ludCl7dmFyIGU9dGhpcy52aWV3LmdldFBlcmltZXRlckJvdW5kcyhhKSxmPW5ldyBteFBvaW50KGUuZ2V0Q2VudGVyWCgpLGUuZ2V0Q2VudGVyWSgpKSxnPWEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRElSRUNUSU9OXSxrPTA7bnVsbCE9ZyYmMT09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FOQ0hPUl9QT0lOVF9ESVJFQ1RJT04sMSkmJihnPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEg/ays9MjcwOmc9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUP2srPTE4MDpnPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEgmJihrKz05MCksZyE9bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIJiZnIT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEh8fGUucm90YXRlOTAoKSk7CnZhciBkPXRoaXMudmlldy5zY2FsZSxkPW5ldyBteFBvaW50KGUueCtiLnBvaW50LngqZS53aWR0aCtiLmR4KmQsZS55K2IucG9pbnQueSplLmhlaWdodCtiLmR5KmQpLGw9YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTl18fDA7aWYoYi5wZXJpbWV0ZXIpMCE9ayYmKGc9ZT0wLDkwPT1rP2c9MToxODA9PWs/ZT0tMToyNzA9PWsmJihnPS0xKSxkPW14VXRpbHMuZ2V0Um90YXRlZFBvaW50KGQsZSxnLGYpKSxkPXRoaXMudmlldy5nZXRQZXJpbWV0ZXJQb2ludChhLGQsITEpO2Vsc2UgaWYobCs9ayx0aGlzLmdldE1vZGVsKCkuaXNWZXJ0ZXgoYS5jZWxsKSl7az0xPT1hLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0ZMSVBIXTtiPTE9PWEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRkxJUFZdO251bGwhPWEuc2hhcGUmJm51bGwhPWEuc2hhcGUuc3RlbmNpbCYmKGs9MT09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLCJzdGVuY2lsRmxpcEgiLDApfHxrLGI9MT09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLAoic3RlbmNpbEZsaXBWIiwwKXx8Yik7aWYoZz09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIfHxnPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEgpYT1rLGs9YixiPWE7ayYmKGQueD0yKmUuZ2V0Q2VudGVyWCgpLWQueCk7YiYmKGQueT0yKmUuZ2V0Q2VudGVyWSgpLWQueSl9MCE9bCYmbnVsbCE9ZCYmKGE9bXhVdGlscy50b1JhZGlhbnMobCksZT1NYXRoLmNvcyhhKSxnPU1hdGguc2luKGEpLGQ9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQoZCxlLGcsZikpfWMmJm51bGwhPWQmJihkLng9TWF0aC5yb3VuZChkLngpLGQueT1NYXRoLnJvdW5kKGQueSkpO3JldHVybiBkfTsKbXhHcmFwaC5wcm90b3R5cGUuY29ubmVjdENlbGw9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgZT10aGlzLm1vZGVsLmdldFRlcm1pbmFsKGEsYyk7dGhpcy5jZWxsQ29ubmVjdGVkKGEsYixjLGQpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuQ09OTkVDVF9DRUxMLCJlZGdlIixhLCJ0ZXJtaW5hbCIsYiwic291cmNlIixjLCJwcmV2aW91cyIsZSkpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX1yZXR1cm4gYX07Cm14R3JhcGgucHJvdG90eXBlLmNlbGxDb25uZWN0ZWQ9ZnVuY3Rpb24oYSxiLGMsZCl7aWYobnVsbCE9YSl7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgZT10aGlzLm1vZGVsLmdldFRlcm1pbmFsKGEsYyk7dGhpcy5zZXRDb25uZWN0aW9uQ29uc3RyYWludChhLGIsYyxkKTt0aGlzLmlzUG9ydHNFbmFibGVkKCkmJihkPW51bGwsdGhpcy5pc1BvcnQoYikmJihkPWIuZ2V0SWQoKSxiPXRoaXMuZ2V0VGVybWluYWxGb3JQb3J0KGIsYykpLHRoaXMuc2V0Q2VsbFN0eWxlcyhjP214Q29uc3RhbnRzLlNUWUxFX1NPVVJDRV9QT1JUOm14Q29uc3RhbnRzLlNUWUxFX1RBUkdFVF9QT1JULGQsW2FdKSk7dGhpcy5tb2RlbC5zZXRUZXJtaW5hbChhLGIsYyk7dGhpcy5yZXNldEVkZ2VzT25Db25uZWN0JiZ0aGlzLnJlc2V0RWRnZShhKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkNFTExfQ09OTkVDVEVELCJlZGdlIixhLCJ0ZXJtaW5hbCIsYiwic291cmNlIiwKYywicHJldmlvdXMiLGUpKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9fX07Cm14R3JhcGgucHJvdG90eXBlLmRpc2Nvbm5lY3RHcmFwaD1mdW5jdGlvbihhKXtpZihudWxsIT1hKXt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgYj10aGlzLnZpZXcuc2NhbGUsYz10aGlzLnZpZXcudHJhbnNsYXRlLGQ9bmV3IG14RGljdGlvbmFyeSxlPTA7ZTxhLmxlbmd0aDtlKyspZC5wdXQoYVtlXSwhMCk7Zm9yKGU9MDtlPGEubGVuZ3RoO2UrKylpZih0aGlzLm1vZGVsLmlzRWRnZShhW2VdKSl7dmFyIGY9dGhpcy5tb2RlbC5nZXRHZW9tZXRyeShhW2VdKTtpZihudWxsIT1mKXt2YXIgZz10aGlzLnZpZXcuZ2V0U3RhdGUoYVtlXSksaz10aGlzLnZpZXcuZ2V0U3RhdGUodGhpcy5tb2RlbC5nZXRQYXJlbnQoYVtlXSkpO2lmKG51bGwhPWcmJm51bGwhPWspe3ZhciBmPWYuY2xvbmUoKSxsPS1rLm9yaWdpbi54LG09LWsub3JpZ2luLnksbj1nLmFic29sdXRlUG9pbnRzLHA9dGhpcy5tb2RlbC5nZXRUZXJtaW5hbChhW2VdLCEwKTtpZihudWxsIT1wJiZ0aGlzLmlzQ2VsbERpc2Nvbm5lY3RhYmxlKGFbZV0sCnAsITApKXtmb3IoO251bGwhPXAmJiFkLmdldChwKTspcD10aGlzLm1vZGVsLmdldFBhcmVudChwKTtudWxsPT1wJiYoZi5zZXRUZXJtaW5hbFBvaW50KG5ldyBteFBvaW50KG5bMF0ueC9iLWMueCtsLG5bMF0ueS9iLWMueSttKSwhMCksdGhpcy5tb2RlbC5zZXRUZXJtaW5hbChhW2VdLG51bGwsITApKX12YXIgcT10aGlzLm1vZGVsLmdldFRlcm1pbmFsKGFbZV0sITEpO2lmKG51bGwhPXEmJnRoaXMuaXNDZWxsRGlzY29ubmVjdGFibGUoYVtlXSxxLCExKSl7Zm9yKDtudWxsIT1xJiYhZC5nZXQocSk7KXE9dGhpcy5tb2RlbC5nZXRQYXJlbnQocSk7aWYobnVsbD09cSl7dmFyIHI9bi5sZW5ndGgtMTtmLnNldFRlcm1pbmFsUG9pbnQobmV3IG14UG9pbnQobltyXS54L2ItYy54K2wsbltyXS55L2ItYy55K20pLCExKTt0aGlzLm1vZGVsLnNldFRlcm1pbmFsKGFbZV0sbnVsbCwhMSl9fXRoaXMubW9kZWwuc2V0R2VvbWV0cnkoYVtlXSxmKX19fX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9fX07Cm14R3JhcGgucHJvdG90eXBlLmdldEN1cnJlbnRSb290PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmlldy5jdXJyZW50Um9vdH07bXhHcmFwaC5wcm90b3R5cGUuZ2V0VHJhbnNsYXRlRm9yUm9vdD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbH07bXhHcmFwaC5wcm90b3R5cGUuaXNQb3J0PWZ1bmN0aW9uKGEpe3JldHVybiExfTtteEdyYXBoLnByb3RvdHlwZS5nZXRUZXJtaW5hbEZvclBvcnQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5tb2RlbC5nZXRQYXJlbnQoYSl9O214R3JhcGgucHJvdG90eXBlLmdldENoaWxkT2Zmc2V0Rm9yQ2VsbD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbH07bXhHcmFwaC5wcm90b3R5cGUuZW50ZXJHcm91cD1mdW5jdGlvbihhKXthPWF8fHRoaXMuZ2V0U2VsZWN0aW9uQ2VsbCgpO251bGwhPWEmJnRoaXMuaXNWYWxpZFJvb3QoYSkmJih0aGlzLnZpZXcuc2V0Q3VycmVudFJvb3QoYSksdGhpcy5jbGVhclNlbGVjdGlvbigpKX07Cm14R3JhcGgucHJvdG90eXBlLmV4aXRHcm91cD1mdW5jdGlvbigpe3ZhciBhPXRoaXMubW9kZWwuZ2V0Um9vdCgpLGI9dGhpcy5nZXRDdXJyZW50Um9vdCgpO2lmKG51bGwhPWIpe2Zvcih2YXIgYz10aGlzLm1vZGVsLmdldFBhcmVudChiKTtjIT1hJiYhdGhpcy5pc1ZhbGlkUm9vdChjKSYmdGhpcy5tb2RlbC5nZXRQYXJlbnQoYykhPWE7KWM9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYyk7Yz09YXx8dGhpcy5tb2RlbC5nZXRQYXJlbnQoYyk9PWE/dGhpcy52aWV3LnNldEN1cnJlbnRSb290KG51bGwpOnRoaXMudmlldy5zZXRDdXJyZW50Um9vdChjKTtudWxsIT10aGlzLnZpZXcuZ2V0U3RhdGUoYikmJnRoaXMuc2V0U2VsZWN0aW9uQ2VsbChiKX19O214R3JhcGgucHJvdG90eXBlLmhvbWU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdldEN1cnJlbnRSb290KCk7bnVsbCE9YSYmKHRoaXMudmlldy5zZXRDdXJyZW50Um9vdChudWxsKSxudWxsIT10aGlzLnZpZXcuZ2V0U3RhdGUoYSkmJnRoaXMuc2V0U2VsZWN0aW9uQ2VsbChhKSl9OwpteEdyYXBoLnByb3RvdHlwZS5pc1ZhbGlkUm9vdD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YX07bXhHcmFwaC5wcm90b3R5cGUuZ2V0R3JhcGhCb3VuZHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3LmdldEdyYXBoQm91bmRzKCl9O214R3JhcGgucHJvdG90eXBlLmdldENlbGxCb3VuZHM9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPVthXTtiJiYoZD1kLmNvbmNhdCh0aGlzLm1vZGVsLmdldEVkZ2VzKGEpKSk7ZD10aGlzLnZpZXcuZ2V0Qm91bmRzKGQpO2lmKGMpe2M9dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGEpO2Zvcih2YXIgZT0wO2U8YztlKyspe3ZhciBmPXRoaXMuZ2V0Q2VsbEJvdW5kcyh0aGlzLm1vZGVsLmdldENoaWxkQXQoYSxlKSxiLCEwKTtudWxsIT1kP2QuYWRkKGYpOmQ9Zn19cmV0dXJuIGR9OwpteEdyYXBoLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveEZyb21HZW9tZXRyeT1mdW5jdGlvbihhLGIpe2I9bnVsbCE9Yj9iOiExO3ZhciBjPW51bGw7aWYobnVsbCE9YSlmb3IodmFyIGQ9MDtkPGEubGVuZ3RoO2QrKylpZihifHx0aGlzLm1vZGVsLmlzVmVydGV4KGFbZF0pKXt2YXIgZT10aGlzLmdldENlbGxHZW9tZXRyeShhW2RdKTtpZihudWxsIT1lKXt2YXIgZj1udWxsO2lmKHRoaXMubW9kZWwuaXNFZGdlKGFbZF0pKXtmPWZ1bmN0aW9uKGEpe251bGwhPWEmJihudWxsPT1nP2c9bmV3IG14UmVjdGFuZ2xlKGEueCxhLnksMCwwKTpnLmFkZChuZXcgbXhSZWN0YW5nbGUoYS54LGEueSwwLDApKSl9O251bGw9PXRoaXMubW9kZWwuZ2V0VGVybWluYWwoYVtkXSwhMCkmJmYoZS5nZXRUZXJtaW5hbFBvaW50KCEwKSk7bnVsbD09dGhpcy5tb2RlbC5nZXRUZXJtaW5hbChhW2RdLCExKSYmZihlLmdldFRlcm1pbmFsUG9pbnQoITEpKTtlPWUucG9pbnRzO2lmKG51bGwhPWUmJjA8ZS5sZW5ndGgpZm9yKHZhciBnPQpuZXcgbXhSZWN0YW5nbGUoZVswXS54LGVbMF0ueSwwLDApLGs9MTtrPGUubGVuZ3RoO2srKylmKGVba10pO2Y9Z31lbHNlIGs9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYVtkXSksZS5yZWxhdGl2ZT90aGlzLm1vZGVsLmlzVmVydGV4KGspJiZrIT10aGlzLnZpZXcuY3VycmVudFJvb3QmJihnPXRoaXMuZ2V0Qm91bmRpbmdCb3hGcm9tR2VvbWV0cnkoW2tdLCExKSxudWxsIT1nJiYoZj1uZXcgbXhSZWN0YW5nbGUoZS54Kmcud2lkdGgsZS55KmcuaGVpZ2h0LGUud2lkdGgsZS5oZWlnaHQpLDA8PW14VXRpbHMuaW5kZXhPZihhLGspJiYoZi54Kz1nLngsZi55Kz1nLnkpKSk6KGY9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShlKSx0aGlzLm1vZGVsLmlzVmVydGV4KGspJiYwPD1teFV0aWxzLmluZGV4T2YoYSxrKSYmKGc9dGhpcy5nZXRCb3VuZGluZ0JveEZyb21HZW9tZXRyeShba10sITEpLG51bGwhPWcmJihmLngrPWcueCxmLnkrPWcueSkpKSxudWxsIT1mJiZudWxsIT1lLm9mZnNldCYmCihmLngrPWUub2Zmc2V0LngsZi55Kz1lLm9mZnNldC55KSxlPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShhW2RdKSxudWxsIT1mJiYoZT1teFV0aWxzLmdldFZhbHVlKGUsbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT04sMCksMCE9ZSYmKGY9bXhVdGlscy5nZXRCb3VuZGluZ0JveChmLGUpKSk7bnVsbCE9ZiYmKG51bGw9PWM/Yz1teFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlKGYpOmMuYWRkKGYpKX19cmV0dXJuIGN9O214R3JhcGgucHJvdG90eXBlLnJlZnJlc2g9ZnVuY3Rpb24oYSl7dGhpcy52aWV3LmNsZWFyKGEsbnVsbD09YSk7dGhpcy52aWV3LnZhbGlkYXRlKCk7dGhpcy5zaXplRGlkQ2hhbmdlKCk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5SRUZSRVNIKSl9O214R3JhcGgucHJvdG90eXBlLnNuYXA9ZnVuY3Rpb24oYSl7dGhpcy5ncmlkRW5hYmxlZCYmKGE9TWF0aC5yb3VuZChhL3RoaXMuZ3JpZFNpemUpKnRoaXMuZ3JpZFNpemUpO3JldHVybiBhfTsKbXhHcmFwaC5wcm90b3R5cGUuc25hcERlbHRhPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9dGhpcy52aWV3LnRyYW5zbGF0ZSxnPXRoaXMudmlldy5zY2FsZTshYyYmdGhpcy5ncmlkRW5hYmxlZD8oYz10aGlzLmdyaWRTaXplKmcqLjUsZHx8KGQ9Yi54LSh0aGlzLnNuYXAoYi54L2ctZi54KStmLngpKmcsYS54PU1hdGguYWJzKGEueC1kKTxjPzA6dGhpcy5zbmFwKGEueC9nKSpnLWQpLGV8fChiPWIueS0odGhpcy5zbmFwKGIueS9nLWYueSkrZi55KSpnLGEueT1NYXRoLmFicyhhLnktYik8Yz8wOnRoaXMuc25hcChhLnkvZykqZy1iKSk6KGM9LjUqZyxkfHwoZD1iLngtKE1hdGgucm91bmQoYi54L2ctZi54KStmLngpKmcsYS54PU1hdGguYWJzKGEueC1kKTxjPzA6TWF0aC5yb3VuZChhLngvZykqZy1kKSxlfHwoYj1iLnktKE1hdGgucm91bmQoYi55L2ctZi55KStmLnkpKmcsYS55PU1hdGguYWJzKGEueS1iKTxjPzA6TWF0aC5yb3VuZChhLnkvZykqZy1iKSk7cmV0dXJuIGF9OwpteEdyYXBoLnByb3RvdHlwZS5wYW5HcmFwaD1mdW5jdGlvbihhLGIpe2lmKHRoaXMudXNlU2Nyb2xsYmFyc0ZvclBhbm5pbmcmJm14VXRpbHMuaGFzU2Nyb2xsYmFycyh0aGlzLmNvbnRhaW5lcikpdGhpcy5jb250YWluZXIuc2Nyb2xsTGVmdD0tYSx0aGlzLmNvbnRhaW5lci5zY3JvbGxUb3A9LWI7ZWxzZXt2YXIgYz10aGlzLnZpZXcuZ2V0Q2FudmFzKCk7aWYodGhpcy5kaWFsZWN0PT1teENvbnN0YW50cy5ESUFMRUNUX1NWRylpZigwPT1hJiYwPT1iKXtpZihteENsaWVudC5JU19JRT9jLnNldEF0dHJpYnV0ZSgidHJhbnNmb3JtIiwidHJhbnNsYXRlKCIrYSsiLCIrYisiKSIpOmMucmVtb3ZlQXR0cmlidXRlKCJ0cmFuc2Zvcm0iKSxudWxsIT10aGlzLnNoaWZ0UHJldmlldzEpe2Zvcih2YXIgZD10aGlzLnNoaWZ0UHJldmlldzEuZmlyc3RDaGlsZDtudWxsIT1kOyl7dmFyIGU9ZC5uZXh0U2libGluZzt0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkKTtkPWV9bnVsbCE9dGhpcy5zaGlmdFByZXZpZXcxLnBhcmVudE5vZGUmJgp0aGlzLnNoaWZ0UHJldmlldzEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNoaWZ0UHJldmlldzEpO3RoaXMuc2hpZnRQcmV2aWV3MT1udWxsO3RoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGMucGFyZW50Tm9kZSk7Zm9yKGQ9dGhpcy5zaGlmdFByZXZpZXcyLmZpcnN0Q2hpbGQ7bnVsbCE9ZDspZT1kLm5leHRTaWJsaW5nLHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGQpLGQ9ZTtudWxsIT10aGlzLnNoaWZ0UHJldmlldzIucGFyZW50Tm9kZSYmdGhpcy5zaGlmdFByZXZpZXcyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zaGlmdFByZXZpZXcyKTt0aGlzLnNoaWZ0UHJldmlldzI9bnVsbH19ZWxzZXtjLnNldEF0dHJpYnV0ZSgidHJhbnNmb3JtIiwidHJhbnNsYXRlKCIrYSsiLCIrYisiKSIpO2lmKG51bGw9PXRoaXMuc2hpZnRQcmV2aWV3MSl7dGhpcy5zaGlmdFByZXZpZXcxPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO3RoaXMuc2hpZnRQcmV2aWV3MS5zdHlsZS5wb3NpdGlvbj0KImFic29sdXRlIjt0aGlzLnNoaWZ0UHJldmlldzEuc3R5bGUub3ZlcmZsb3c9InZpc2libGUiO3RoaXMuc2hpZnRQcmV2aWV3Mj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTt0aGlzLnNoaWZ0UHJldmlldzIuc3R5bGUucG9zaXRpb249ImFic29sdXRlIjt0aGlzLnNoaWZ0UHJldmlldzIuc3R5bGUub3ZlcmZsb3c9InZpc2libGUiO2Zvcih2YXIgZj10aGlzLnNoaWZ0UHJldmlldzEsZD10aGlzLmNvbnRhaW5lci5maXJzdENoaWxkO251bGwhPWQ7KWU9ZC5uZXh0U2libGluZyxkIT1jLnBhcmVudE5vZGU/Zi5hcHBlbmRDaGlsZChkKTpmPXRoaXMuc2hpZnRQcmV2aWV3MixkPWU7bnVsbCE9dGhpcy5zaGlmdFByZXZpZXcxLmZpcnN0Q2hpbGQmJnRoaXMuY29udGFpbmVyLmluc2VydEJlZm9yZSh0aGlzLnNoaWZ0UHJldmlldzEsYy5wYXJlbnROb2RlKTtudWxsIT10aGlzLnNoaWZ0UHJldmlldzIuZmlyc3RDaGlsZCYmdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zaGlmdFByZXZpZXcyKX10aGlzLnNoaWZ0UHJldmlldzEuc3R5bGUubGVmdD0KYSsicHgiO3RoaXMuc2hpZnRQcmV2aWV3MS5zdHlsZS50b3A9YisicHgiO3RoaXMuc2hpZnRQcmV2aWV3Mi5zdHlsZS5sZWZ0PWErInB4Ijt0aGlzLnNoaWZ0UHJldmlldzIuc3R5bGUudG9wPWIrInB4In1lbHNlIGMuc3R5bGUubGVmdD1hKyJweCIsYy5zdHlsZS50b3A9YisicHgiO3RoaXMucGFuRHg9YTt0aGlzLnBhbkR5PWI7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5QQU4pKX19O214R3JhcGgucHJvdG90eXBlLnpvb21Jbj1mdW5jdGlvbigpe3RoaXMuem9vbSh0aGlzLnpvb21GYWN0b3IpfTtteEdyYXBoLnByb3RvdHlwZS56b29tT3V0PWZ1bmN0aW9uKCl7dGhpcy56b29tKDEvdGhpcy56b29tRmFjdG9yKX07Cm14R3JhcGgucHJvdG90eXBlLnpvb21BY3R1YWw9ZnVuY3Rpb24oKXsxPT10aGlzLnZpZXcuc2NhbGU/dGhpcy52aWV3LnNldFRyYW5zbGF0ZSgwLDApOih0aGlzLnZpZXcudHJhbnNsYXRlLng9MCx0aGlzLnZpZXcudHJhbnNsYXRlLnk9MCx0aGlzLnZpZXcuc2V0U2NhbGUoMSkpfTtteEdyYXBoLnByb3RvdHlwZS56b29tVG89ZnVuY3Rpb24oYSxiKXt0aGlzLnpvb20oYS90aGlzLnZpZXcuc2NhbGUsYil9OwpteEdyYXBoLnByb3RvdHlwZS5jZW50ZXI9ZnVuY3Rpb24oYSxiLGMsZCl7YT1udWxsIT1hP2E6ITA7Yj1udWxsIT1iP2I6ITA7Yz1udWxsIT1jP2M6LjU7ZD1udWxsIT1kP2Q6LjU7dmFyIGU9bXhVdGlscy5oYXNTY3JvbGxiYXJzKHRoaXMuY29udGFpbmVyKSxmPTIqdGhpcy5nZXRCb3JkZXIoKSxnPXRoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoLWYsZj10aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQtZixrPXRoaXMuZ2V0R3JhcGhCb3VuZHMoKSxsPXRoaXMudmlldy50cmFuc2xhdGUsbT10aGlzLnZpZXcuc2NhbGUsbj1hP2ctay53aWR0aDowLHA9Yj9mLWsuaGVpZ2h0OjA7ZT8oay54LT1sLngsay55LT1sLnksYT10aGlzLmNvbnRhaW5lci5zY3JvbGxXaWR0aCxiPXRoaXMuY29udGFpbmVyLnNjcm9sbEhlaWdodCxhPmcmJihuPTApLGI+ZiYmKHA9MCksdGhpcy52aWV3LnNldFRyYW5zbGF0ZShNYXRoLmZsb29yKG4vMi1rLngpLE1hdGguZmxvb3IocC8yLWsueSkpLHRoaXMuY29udGFpbmVyLnNjcm9sbExlZnQ9CihhLWcpLzIsdGhpcy5jb250YWluZXIuc2Nyb2xsVG9wPShiLWYpLzIpOnRoaXMudmlldy5zZXRUcmFuc2xhdGUoYT9NYXRoLmZsb29yKGwueC1rLngqbStuKmMvbSk6bC54LGI/TWF0aC5mbG9vcihsLnktay55Km0rcCpkL20pOmwueSl9OwpteEdyYXBoLnByb3RvdHlwZS56b29tPWZ1bmN0aW9uKGEsYil7Yj1udWxsIT1iP2I6dGhpcy5jZW50ZXJab29tO3ZhciBjPU1hdGgucm91bmQodGhpcy52aWV3LnNjYWxlKmEqMTAwKS8xMDAsZD10aGlzLnZpZXcuZ2V0U3RhdGUodGhpcy5nZXRTZWxlY3Rpb25DZWxsKCkpO2E9Yy90aGlzLnZpZXcuc2NhbGU7aWYodGhpcy5rZWVwU2VsZWN0aW9uVmlzaWJsZU9uWm9vbSYmbnVsbCE9ZClkPW5ldyBteFJlY3RhbmdsZShkLngqYSxkLnkqYSxkLndpZHRoKmEsZC5oZWlnaHQqYSksdGhpcy52aWV3LnNjYWxlPWMsdGhpcy5zY3JvbGxSZWN0VG9WaXNpYmxlKGQpfHwodGhpcy52aWV3LnJldmFsaWRhdGUoKSx0aGlzLnZpZXcuc2V0U2NhbGUoYykpO2Vsc2UgaWYoZD1teFV0aWxzLmhhc1Njcm9sbGJhcnModGhpcy5jb250YWluZXIpLGImJiFkKXt2YXIgZD10aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCxlPXRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodDtpZigxPGEpdmFyIGY9KGEtMSkvCigyKmMpLGQ9ZCotZixlPWUqLWY7ZWxzZSBmPSgxL2EtMSkvKDIqdGhpcy52aWV3LnNjYWxlKSxkKj1mLGUqPWY7dGhpcy52aWV3LnNjYWxlQW5kVHJhbnNsYXRlKGMsdGhpcy52aWV3LnRyYW5zbGF0ZS54K2QsdGhpcy52aWV3LnRyYW5zbGF0ZS55K2UpfWVsc2V7dmFyIGY9dGhpcy52aWV3LnRyYW5zbGF0ZS54LGc9dGhpcy52aWV3LnRyYW5zbGF0ZS55LGs9dGhpcy5jb250YWluZXIuc2Nyb2xsTGVmdCxsPXRoaXMuY29udGFpbmVyLnNjcm9sbFRvcDt0aGlzLnZpZXcuc2V0U2NhbGUoYyk7ZCYmKGU9ZD0wLGImJihkPXRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoKihhLTEpLzIsZT10aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQqKGEtMSkvMiksdGhpcy5jb250YWluZXIuc2Nyb2xsTGVmdD0odGhpcy52aWV3LnRyYW5zbGF0ZS54LWYpKnRoaXMudmlldy5zY2FsZStNYXRoLnJvdW5kKGsqYStkKSx0aGlzLmNvbnRhaW5lci5zY3JvbGxUb3A9KHRoaXMudmlldy50cmFuc2xhdGUueS0KZykqdGhpcy52aWV3LnNjYWxlK01hdGgucm91bmQobCphK2UpKX19OwpteEdyYXBoLnByb3RvdHlwZS56b29tVG9SZWN0PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoL2Eud2lkdGgvKHRoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodC9hLmhlaWdodCk7YS54PU1hdGgubWF4KDAsYS54KTthLnk9TWF0aC5tYXgoMCxhLnkpO3ZhciBjPU1hdGgubWluKHRoaXMuY29udGFpbmVyLnNjcm9sbFdpZHRoLGEueCthLndpZHRoKSxkPU1hdGgubWluKHRoaXMuY29udGFpbmVyLnNjcm9sbEhlaWdodCxhLnkrYS5oZWlnaHQpO2Eud2lkdGg9Yy1hLng7YS5oZWlnaHQ9ZC1hLnk7MT5iPyhiPWEuaGVpZ2h0L2IsYz0oYi1hLmhlaWdodCkvMixhLmhlaWdodD1iLGEueS09TWF0aC5taW4oYS55LGMpLGQ9TWF0aC5taW4odGhpcy5jb250YWluZXIuc2Nyb2xsSGVpZ2h0LGEueSthLmhlaWdodCksYS5oZWlnaHQ9ZC1hLnkpOihiKj1hLndpZHRoLGM9KGItYS53aWR0aCkvMixhLndpZHRoPWIsYS54LT1NYXRoLm1pbihhLngsYyksYz1NYXRoLm1pbih0aGlzLmNvbnRhaW5lci5zY3JvbGxXaWR0aCwKYS54K2Eud2lkdGgpLGEud2lkdGg9Yy1hLngpO2I9dGhpcy5jb250YWluZXIuY2xpZW50V2lkdGgvYS53aWR0aDtjPXRoaXMudmlldy5zY2FsZSpiO214VXRpbHMuaGFzU2Nyb2xsYmFycyh0aGlzLmNvbnRhaW5lcik/KHRoaXMudmlldy5zZXRTY2FsZShjKSx0aGlzLmNvbnRhaW5lci5zY3JvbGxMZWZ0PU1hdGgucm91bmQoYS54KmIpLHRoaXMuY29udGFpbmVyLnNjcm9sbFRvcD1NYXRoLnJvdW5kKGEueSpiKSk6dGhpcy52aWV3LnNjYWxlQW5kVHJhbnNsYXRlKGMsdGhpcy52aWV3LnRyYW5zbGF0ZS54LWEueC90aGlzLnZpZXcuc2NhbGUsdGhpcy52aWV3LnRyYW5zbGF0ZS55LWEueS90aGlzLnZpZXcuc2NhbGUpfTsKbXhHcmFwaC5wcm90b3R5cGUuc2Nyb2xsQ2VsbFRvVmlzaWJsZT1mdW5jdGlvbihhLGIpe3ZhciBjPS10aGlzLnZpZXcudHJhbnNsYXRlLngsZD0tdGhpcy52aWV3LnRyYW5zbGF0ZS55LGU9dGhpcy52aWV3LmdldFN0YXRlKGEpO251bGwhPWUmJihjPW5ldyBteFJlY3RhbmdsZShjK2UueCxkK2UueSxlLndpZHRoLGUuaGVpZ2h0KSxiJiZudWxsIT10aGlzLmNvbnRhaW5lciYmKGQ9dGhpcy5jb250YWluZXIuY2xpZW50V2lkdGgsZT10aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQsYy54PWMuZ2V0Q2VudGVyWCgpLWQvMixjLndpZHRoPWQsYy55PWMuZ2V0Q2VudGVyWSgpLWUvMixjLmhlaWdodD1lKSxkPW5ldyBteFBvaW50KHRoaXMudmlldy50cmFuc2xhdGUueCx0aGlzLnZpZXcudHJhbnNsYXRlLnkpLHRoaXMuc2Nyb2xsUmVjdFRvVmlzaWJsZShjKSYmKGM9bmV3IG14UG9pbnQodGhpcy52aWV3LnRyYW5zbGF0ZS54LHRoaXMudmlldy50cmFuc2xhdGUueSksdGhpcy52aWV3LnRyYW5zbGF0ZS54PQpkLngsdGhpcy52aWV3LnRyYW5zbGF0ZS55PWQueSx0aGlzLnZpZXcuc2V0VHJhbnNsYXRlKGMueCxjLnkpKSl9OwpteEdyYXBoLnByb3RvdHlwZS5zY3JvbGxSZWN0VG9WaXNpYmxlPWZ1bmN0aW9uKGEpe3ZhciBiPSExO2lmKG51bGwhPWEpe3ZhciBjPXRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoLGQ9dGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0LGU9TWF0aC5taW4oYyxhLndpZHRoKSxmPU1hdGgubWluKGQsYS5oZWlnaHQpO2lmKG14VXRpbHMuaGFzU2Nyb2xsYmFycyh0aGlzLmNvbnRhaW5lcikpe2M9dGhpcy5jb250YWluZXI7YS54Kz10aGlzLnZpZXcudHJhbnNsYXRlLng7YS55Kz10aGlzLnZpZXcudHJhbnNsYXRlLnk7dmFyIGc9Yy5zY3JvbGxMZWZ0LWEueCxkPU1hdGgubWF4KGctYy5zY3JvbGxMZWZ0LDApOzA8Zz9jLnNjcm9sbExlZnQtPWcrMjooZz1hLngrZS1jLnNjcm9sbExlZnQtYy5jbGllbnRXaWR0aCwwPGcmJihjLnNjcm9sbExlZnQrPWcrMikpO2U9Yy5zY3JvbGxUb3AtYS55O2c9TWF0aC5tYXgoMCxlLWMuc2Nyb2xsVG9wKTswPGU/Yy5zY3JvbGxUb3AtPWUrMjooZT1hLnkrCmYtYy5zY3JvbGxUb3AtYy5jbGllbnRIZWlnaHQsMDxlJiYoYy5zY3JvbGxUb3ArPWUrMikpO3RoaXMudXNlU2Nyb2xsYmFyc0ZvclBhbm5pbmd8fDA9PWQmJjA9PWd8fHRoaXMudmlldy5zZXRUcmFuc2xhdGUoZCxnKX1lbHNle3ZhciBnPS10aGlzLnZpZXcudHJhbnNsYXRlLngsaz0tdGhpcy52aWV3LnRyYW5zbGF0ZS55LGw9dGhpcy52aWV3LnNjYWxlO2EueCtlPmcrYyYmKHRoaXMudmlldy50cmFuc2xhdGUueC09KGEueCtlLWMtZykvbCxiPSEwKTthLnkrZj5rK2QmJih0aGlzLnZpZXcudHJhbnNsYXRlLnktPShhLnkrZi1kLWspL2wsYj0hMCk7YS54PGcmJih0aGlzLnZpZXcudHJhbnNsYXRlLngrPShnLWEueCkvbCxiPSEwKTthLnk8ayYmKHRoaXMudmlldy50cmFuc2xhdGUueSs9KGstYS55KS9sLGI9ITApO2ImJih0aGlzLnZpZXcucmVmcmVzaCgpLG51bGwhPXRoaXMuc2VsZWN0aW9uQ2VsbHNIYW5kbGVyJiZ0aGlzLnNlbGVjdGlvbkNlbGxzSGFuZGxlci5yZWZyZXNoKCkpfX1yZXR1cm4gYn07Cm14R3JhcGgucHJvdG90eXBlLmdldENlbGxHZW9tZXRyeT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5tb2RlbC5nZXRHZW9tZXRyeShhKX07bXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsVmlzaWJsZT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5tb2RlbC5pc1Zpc2libGUoYSl9O214R3JhcGgucHJvdG90eXBlLmlzQ2VsbENvbGxhcHNlZD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5tb2RlbC5pc0NvbGxhcHNlZChhKX07bXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsQ29ubmVjdGFibGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubW9kZWwuaXNDb25uZWN0YWJsZShhKX07Cm14R3JhcGgucHJvdG90eXBlLmlzT3J0aG9nb25hbD1mdW5jdGlvbihhKXt2YXIgYj1hLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX09SVEhPR09OQUxdO2lmKG51bGwhPWIpcmV0dXJuIGI7YT10aGlzLnZpZXcuZ2V0RWRnZVN0eWxlKGEpO3JldHVybiBhPT1teEVkZ2VTdHlsZS5TZWdtZW50Q29ubmVjdG9yfHxhPT1teEVkZ2VTdHlsZS5FbGJvd0Nvbm5lY3Rvcnx8YT09bXhFZGdlU3R5bGUuU2lkZVRvU2lkZXx8YT09bXhFZGdlU3R5bGUuVG9wVG9Cb3R0b218fGE9PW14RWRnZVN0eWxlLkVudGl0eVJlbGF0aW9ufHxhPT1teEVkZ2VTdHlsZS5PcnRoQ29ubmVjdG9yfTtteEdyYXBoLnByb3RvdHlwZS5pc0xvb3A9ZnVuY3Rpb24oYSl7dmFyIGI9YS5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZSghMCk7YT1hLmdldFZpc2libGVUZXJtaW5hbFN0YXRlKCExKTtyZXR1cm4gbnVsbCE9YiYmYj09YX07bXhHcmFwaC5wcm90b3R5cGUuaXNDbG9uZUV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiBteEV2ZW50LmlzQ29udHJvbERvd24oYSl9OwpteEdyYXBoLnByb3RvdHlwZS5pc1RyYW5zcGFyZW50Q2xpY2tFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4hMX07bXhHcmFwaC5wcm90b3R5cGUuaXNUb2dnbGVFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gbXhDbGllbnQuSVNfTUFDP214RXZlbnQuaXNNZXRhRG93bihhKTpteEV2ZW50LmlzQ29udHJvbERvd24oYSl9O214R3JhcGgucHJvdG90eXBlLmlzR3JpZEVuYWJsZWRFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YSYmIW14RXZlbnQuaXNBbHREb3duKGEpfTtteEdyYXBoLnByb3RvdHlwZS5pc0NvbnN0cmFpbmVkRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG14RXZlbnQuaXNTaGlmdERvd24oYSl9O214R3JhcGgucHJvdG90eXBlLmlzSWdub3JlVGVybWluYWxFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4hMX07bXhHcmFwaC5wcm90b3R5cGUudmFsaWRhdGlvbkFsZXJ0PWZ1bmN0aW9uKGEpe214VXRpbHMuYWxlcnQoYSl9OwpteEdyYXBoLnByb3RvdHlwZS5pc0VkZ2VWYWxpZD1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIG51bGw9PXRoaXMuZ2V0RWRnZVZhbGlkYXRpb25FcnJvcihhLGIsYyl9OwpteEdyYXBoLnByb3RvdHlwZS5nZXRFZGdlVmFsaWRhdGlvbkVycm9yPWZ1bmN0aW9uKGEsYixjKXtpZihudWxsIT1hJiYhdGhpcy5pc0FsbG93RGFuZ2xpbmdFZGdlcygpJiYobnVsbD09Ynx8bnVsbD09YykpcmV0dXJuIiI7aWYobnVsbCE9YSYmbnVsbD09dGhpcy5tb2RlbC5nZXRUZXJtaW5hbChhLCEwKSYmbnVsbD09dGhpcy5tb2RlbC5nZXRUZXJtaW5hbChhLCExKSlyZXR1cm4gbnVsbDtpZighdGhpcy5hbGxvd0xvb3BzJiZiPT1jJiZudWxsIT1ifHwhdGhpcy5pc1ZhbGlkQ29ubmVjdGlvbihiLGMpKXJldHVybiIiO2lmKG51bGwhPWImJm51bGwhPWMpe3ZhciBkPSIiO2lmKCF0aGlzLm11bHRpZ3JhcGgpe3ZhciBlPXRoaXMubW9kZWwuZ2V0RWRnZXNCZXR3ZWVuKGIsYywhMCk7aWYoMTxlLmxlbmd0aHx8MT09ZS5sZW5ndGgmJmVbMF0hPWEpZCs9KG14UmVzb3VyY2VzLmdldCh0aGlzLmFscmVhZHlDb25uZWN0ZWRSZXNvdXJjZSl8fHRoaXMuYWxyZWFkeUNvbm5lY3RlZFJlc291cmNlKSsKIlxuIn12YXIgZT10aGlzLm1vZGVsLmdldERpcmVjdGVkRWRnZUNvdW50KGIsITAsYSksZj10aGlzLm1vZGVsLmdldERpcmVjdGVkRWRnZUNvdW50KGMsITEsYSk7aWYobnVsbCE9dGhpcy5tdWx0aXBsaWNpdGllcylmb3IodmFyIGc9MDtnPHRoaXMubXVsdGlwbGljaXRpZXMubGVuZ3RoO2crKyl7dmFyIGs9dGhpcy5tdWx0aXBsaWNpdGllc1tnXS5jaGVjayh0aGlzLGEsYixjLGUsZik7bnVsbCE9ayYmKGQrPWspfWs9dGhpcy52YWxpZGF0ZUVkZ2UoYSxiLGMpO251bGwhPWsmJihkKz1rKTtyZXR1cm4gMDxkLmxlbmd0aD9kOm51bGx9cmV0dXJuIHRoaXMuYWxsb3dEYW5nbGluZ0VkZ2VzP251bGw6IiJ9O214R3JhcGgucHJvdG90eXBlLnZhbGlkYXRlRWRnZT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIG51bGx9OwpteEdyYXBoLnByb3RvdHlwZS52YWxpZGF0ZUdyYXBoPWZ1bmN0aW9uKGEsYil7YT1udWxsIT1hP2E6dGhpcy5tb2RlbC5nZXRSb290KCk7Yj1udWxsIT1iP2I6e307Zm9yKHZhciBjPSEwLGQ9dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGEpLGU9MDtlPGQ7ZSsrKXt2YXIgZj10aGlzLm1vZGVsLmdldENoaWxkQXQoYSxlKSxnPWI7dGhpcy5pc1ZhbGlkUm9vdChmKSYmKGc9e30pO2c9dGhpcy52YWxpZGF0ZUdyYXBoKGYsZyk7bnVsbCE9Zz90aGlzLnNldENlbGxXYXJuaW5nKGYsZy5yZXBsYWNlKC9cbi9nLCI8YnI+IikpOnRoaXMuc2V0Q2VsbFdhcm5pbmcoZixudWxsKTtjPWMmJm51bGw9PWd9ZD0iIjt0aGlzLmlzQ2VsbENvbGxhcHNlZChhKSYmIWMmJihkKz0obXhSZXNvdXJjZXMuZ2V0KHRoaXMuY29udGFpbnNWYWxpZGF0aW9uRXJyb3JzUmVzb3VyY2UpfHx0aGlzLmNvbnRhaW5zVmFsaWRhdGlvbkVycm9yc1Jlc291cmNlKSsiXG4iKTtkPXRoaXMubW9kZWwuaXNFZGdlKGEpP2QrCih0aGlzLmdldEVkZ2VWYWxpZGF0aW9uRXJyb3IoYSx0aGlzLm1vZGVsLmdldFRlcm1pbmFsKGEsITApLHRoaXMubW9kZWwuZ2V0VGVybWluYWwoYSwhMSkpfHwiIik6ZCsodGhpcy5nZXRDZWxsVmFsaWRhdGlvbkVycm9yKGEpfHwiIik7ZT10aGlzLnZhbGlkYXRlQ2VsbChhLGIpO251bGwhPWUmJihkKz1lKTtudWxsPT10aGlzLm1vZGVsLmdldFBhcmVudChhKSYmdGhpcy52aWV3LnZhbGlkYXRlKCk7cmV0dXJuIDA8ZC5sZW5ndGh8fCFjP2Q6bnVsbH07Cm14R3JhcGgucHJvdG90eXBlLmdldENlbGxWYWxpZGF0aW9uRXJyb3I9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5tb2RlbC5nZXREaXJlY3RlZEVkZ2VDb3VudChhLCEwKSxjPXRoaXMubW9kZWwuZ2V0RGlyZWN0ZWRFZGdlQ291bnQoYSwhMSk7YT10aGlzLm1vZGVsLmdldFZhbHVlKGEpO3ZhciBkPSIiO2lmKG51bGwhPXRoaXMubXVsdGlwbGljaXRpZXMpZm9yKHZhciBlPTA7ZTx0aGlzLm11bHRpcGxpY2l0aWVzLmxlbmd0aDtlKyspe3ZhciBmPXRoaXMubXVsdGlwbGljaXRpZXNbZV07Zi5zb3VyY2UmJm14VXRpbHMuaXNOb2RlKGEsZi50eXBlLGYuYXR0cixmLnZhbHVlKSYmKGI+Zi5tYXh8fGI8Zi5taW4pP2QrPWYuY291bnRFcnJvcisiXG4iOiFmLnNvdXJjZSYmbXhVdGlscy5pc05vZGUoYSxmLnR5cGUsZi5hdHRyLGYudmFsdWUpJiYoYz5mLm1heHx8YzxmLm1pbikmJihkKz1mLmNvdW50RXJyb3IrIlxuIil9cmV0dXJuIDA8ZC5sZW5ndGg/ZDpudWxsfTsKbXhHcmFwaC5wcm90b3R5cGUudmFsaWRhdGVDZWxsPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG51bGx9O214R3JhcGgucHJvdG90eXBlLmdldEJhY2tncm91bmRJbWFnZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJhY2tncm91bmRJbWFnZX07bXhHcmFwaC5wcm90b3R5cGUuc2V0QmFja2dyb3VuZEltYWdlPWZ1bmN0aW9uKGEpe3RoaXMuYmFja2dyb3VuZEltYWdlPWF9O214R3JhcGgucHJvdG90eXBlLmdldEZvbGRpbmdJbWFnZT1mdW5jdGlvbihhKXtpZihudWxsIT1hJiZ0aGlzLmZvbGRpbmdFbmFibGVkJiYhdGhpcy5nZXRNb2RlbCgpLmlzRWRnZShhLmNlbGwpKXt2YXIgYj10aGlzLmlzQ2VsbENvbGxhcHNlZChhLmNlbGwpO2lmKHRoaXMuaXNDZWxsRm9sZGFibGUoYS5jZWxsLCFiKSlyZXR1cm4gYj90aGlzLmNvbGxhcHNlZEltYWdlOnRoaXMuZXhwYW5kZWRJbWFnZX1yZXR1cm4gbnVsbH07Cm14R3JhcGgucHJvdG90eXBlLmNvbnZlcnRWYWx1ZVRvU3RyaW5nPWZ1bmN0aW9uKGEpe2E9dGhpcy5tb2RlbC5nZXRWYWx1ZShhKTtpZihudWxsIT1hKXtpZihteFV0aWxzLmlzTm9kZShhKSlyZXR1cm4gYS5ub2RlTmFtZTtpZigiZnVuY3Rpb24iPT10eXBlb2YgYS50b1N0cmluZylyZXR1cm4gYS50b1N0cmluZygpfXJldHVybiIifTtteEdyYXBoLnByb3RvdHlwZS5nZXRMYWJlbD1mdW5jdGlvbihhKXt2YXIgYj0iIjtpZih0aGlzLmxhYmVsc1Zpc2libGUmJm51bGwhPWEpe3ZhciBjPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShhKTtteFV0aWxzLmdldFZhbHVlKGMsbXhDb25zdGFudHMuU1RZTEVfTk9MQUJFTCwhMSl8fChiPXRoaXMuY29udmVydFZhbHVlVG9TdHJpbmcoYSkpfXJldHVybiBifTtteEdyYXBoLnByb3RvdHlwZS5pc0h0bWxMYWJlbD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pc0h0bWxMYWJlbHMoKX07bXhHcmFwaC5wcm90b3R5cGUuaXNIdG1sTGFiZWxzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaHRtbExhYmVsc307Cm14R3JhcGgucHJvdG90eXBlLnNldEh0bWxMYWJlbHM9ZnVuY3Rpb24oYSl7dGhpcy5odG1sTGFiZWxzPWF9O214R3JhcGgucHJvdG90eXBlLmlzV3JhcHBpbmc9ZnVuY3Rpb24oYSl7cmV0dXJuIndyYXAiPT10aGlzLmdldEN1cnJlbnRDZWxsU3R5bGUoYSlbbXhDb25zdGFudHMuU1RZTEVfV0hJVEVfU1BBQ0VdfTtteEdyYXBoLnByb3RvdHlwZS5pc0xhYmVsQ2xpcHBlZD1mdW5jdGlvbihhKXtyZXR1cm4iaGlkZGVuIj09dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpW214Q29uc3RhbnRzLlNUWUxFX09WRVJGTE9XXX07Cm14R3JhcGgucHJvdG90eXBlLmdldFRvb2x0aXA9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9bnVsbDtudWxsIT1hJiYobnVsbD09YS5jb250cm9sfHxiIT1hLmNvbnRyb2wubm9kZSYmYi5wYXJlbnROb2RlIT1hLmNvbnRyb2wubm9kZXx8KGU9dGhpcy5jb2xsYXBzZUV4cGFuZFJlc291cmNlLGU9bXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KGUpfHxlKS5yZXBsYWNlKC9cXG4vZywiPGJyPiIpKSxudWxsPT1lJiZudWxsIT1hLm92ZXJsYXlzJiZhLm92ZXJsYXlzLnZpc2l0KGZ1bmN0aW9uKGEsYyl7bnVsbCE9ZXx8YiE9Yy5ub2RlJiZiLnBhcmVudE5vZGUhPWMubm9kZXx8KGU9Yy5vdmVybGF5LnRvU3RyaW5nKCkpfSksbnVsbD09ZSYmKGM9dGhpcy5zZWxlY3Rpb25DZWxsc0hhbmRsZXIuZ2V0SGFuZGxlcihhLmNlbGwpLG51bGwhPWMmJiJmdW5jdGlvbiI9PXR5cGVvZiBjLmdldFRvb2x0aXBGb3JOb2RlJiYoZT1jLmdldFRvb2x0aXBGb3JOb2RlKGIpKSksbnVsbD09CmUmJihlPXRoaXMuZ2V0VG9vbHRpcEZvckNlbGwoYS5jZWxsKSkpO3JldHVybiBlfTtteEdyYXBoLnByb3RvdHlwZS5nZXRUb29sdGlwRm9yQ2VsbD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YSYmbnVsbCE9YS5nZXRUb29sdGlwP2EuZ2V0VG9vbHRpcCgpOnRoaXMuY29udmVydFZhbHVlVG9TdHJpbmcoYSl9O214R3JhcGgucHJvdG90eXBlLmdldExpbmtGb3JDZWxsPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsfTtteEdyYXBoLnByb3RvdHlwZS5nZXRDdXJzb3JGb3JNb3VzZUV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdldEN1cnNvckZvckNlbGwoYS5nZXRDZWxsKCkpfTtteEdyYXBoLnByb3RvdHlwZS5nZXRDdXJzb3JGb3JDZWxsPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsfTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0U3RhcnRTaXplPWZ1bmN0aW9uKGEsYil7dmFyIGM9bmV3IG14UmVjdGFuZ2xlLGQ9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEsYiksZT1wYXJzZUludChteFV0aWxzLmdldFZhbHVlKGQsbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFLG14Q29uc3RhbnRzLkRFRkFVTFRfU1RBUlRTSVpFKSk7bXhVdGlscy5nZXRWYWx1ZShkLG14Q29uc3RhbnRzLlNUWUxFX0hPUklaT05UQUwsITApP2MuaGVpZ2h0PWU6Yy53aWR0aD1lO3JldHVybiBjfTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0U3dpbWxhbmVEaXJlY3Rpb249ZnVuY3Rpb24oYSl7dmFyIGI9bXhVdGlscy5nZXRWYWx1ZShhLG14Q29uc3RhbnRzLlNUWUxFX0RJUkVDVElPTixteENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVCksYz0xPT1teFV0aWxzLmdldFZhbHVlKGEsbXhDb25zdGFudHMuU1RZTEVfRkxJUEgsMCksZD0xPT1teFV0aWxzLmdldFZhbHVlKGEsbXhDb25zdGFudHMuU1RZTEVfRkxJUFYsMCk7YT1teFV0aWxzLmdldFZhbHVlKGEsbXhDb25zdGFudHMuU1RZTEVfSE9SSVpPTlRBTCwhMCk/MDozO2I9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSD9hLS06Yj09bXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1Q/YSs9MjpiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEgmJihhKz0xKTtiPW14VXRpbHMubW9kKGEsMik7YyYmMT09YiYmKGErPTIpO2QmJjA9PWImJihhKz0yKTtyZXR1cm5bbXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRILG14Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNULApteENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEgsbXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1RdW214VXRpbHMubW9kKGEsNCldfTtteEdyYXBoLnByb3RvdHlwZS5nZXRBY3R1YWxTdGFydFNpemU9ZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgbXhSZWN0YW5nbGU7aWYodGhpcy5pc1N3aW1sYW5lKGEsYikpe3ZhciBkPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShhLGIpLGU9cGFyc2VJbnQobXhVdGlscy5nZXRWYWx1ZShkLG14Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRSxteENvbnN0YW50cy5ERUZBVUxUX1NUQVJUU0laRSkpLGQ9dGhpcy5nZXRTd2ltbGFuZURpcmVjdGlvbihkKTtkPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEg/Yy55PWU6ZD09bXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1Q/Yy54PWU6ZD09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIP2MuaGVpZ2h0PWU6Yy53aWR0aD1lfXJldHVybiBjfTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0SW1hZ2U9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEmJm51bGwhPWEuc3R5bGU/YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9JTUFHRV06bnVsbH07bXhHcmFwaC5wcm90b3R5cGUuaXNUcmFuc3BhcmVudFN0YXRlPWZ1bmN0aW9uKGEpe3ZhciBiPSExO2lmKG51bGwhPWEpdmFyIGI9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1NUUk9LRUNPTE9SLG14Q29uc3RhbnRzLk5PTkUpLGM9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZJTExDT0xPUixteENvbnN0YW50cy5OT05FKSxiPWI9PW14Q29uc3RhbnRzLk5PTkUmJmM9PW14Q29uc3RhbnRzLk5PTkUmJm51bGw9PXRoaXMuZ2V0SW1hZ2UoYSk7cmV0dXJuIGJ9OwpteEdyYXBoLnByb3RvdHlwZS5nZXRWZXJ0aWNhbEFsaWduPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiZudWxsIT1hLnN0eWxlP2Euc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfVkVSVElDQUxfQUxJR05dfHxteENvbnN0YW50cy5BTElHTl9NSURETEU6bnVsbH07bXhHcmFwaC5wcm90b3R5cGUuZ2V0SW5kaWNhdG9yQ29sb3I9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEmJm51bGwhPWEuc3R5bGU/YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9JTkRJQ0FUT1JfQ09MT1JdOm51bGx9O214R3JhcGgucHJvdG90eXBlLmdldEluZGljYXRvckdyYWRpZW50Q29sb3I9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEmJm51bGwhPWEuc3R5bGU/YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9JTkRJQ0FUT1JfR1JBRElFTlRDT0xPUl06bnVsbH07Cm14R3JhcGgucHJvdG90eXBlLmdldEluZGljYXRvclNoYXBlPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiZudWxsIT1hLnN0eWxlP2Euc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfSU5ESUNBVE9SX1NIQVBFXTpudWxsfTtteEdyYXBoLnByb3RvdHlwZS5nZXRJbmRpY2F0b3JJbWFnZT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YSYmbnVsbCE9YS5zdHlsZT9hLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0lORElDQVRPUl9JTUFHRV06bnVsbH07bXhHcmFwaC5wcm90b3R5cGUuZ2V0Qm9yZGVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYm9yZGVyfTtteEdyYXBoLnByb3RvdHlwZS5zZXRCb3JkZXI9ZnVuY3Rpb24oYSl7dGhpcy5ib3JkZXI9YX07Cm14R3JhcGgucHJvdG90eXBlLmlzU3dpbWxhbmU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbnVsbD09YXx8dGhpcy5tb2RlbC5nZXRQYXJlbnQoYSk9PXRoaXMubW9kZWwuZ2V0Um9vdCgpfHx0aGlzLm1vZGVsLmlzRWRnZShhKT8hMTp0aGlzLmdldEN1cnJlbnRDZWxsU3R5bGUoYSxiKVtteENvbnN0YW50cy5TVFlMRV9TSEFQRV09PW14Q29uc3RhbnRzLlNIQVBFX1NXSU1MQU5FfTtteEdyYXBoLnByb3RvdHlwZS5pc1Jlc2l6ZUNvbnRhaW5lcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlc2l6ZUNvbnRhaW5lcn07bXhHcmFwaC5wcm90b3R5cGUuc2V0UmVzaXplQ29udGFpbmVyPWZ1bmN0aW9uKGEpe3RoaXMucmVzaXplQ29udGFpbmVyPWF9O214R3JhcGgucHJvdG90eXBlLmlzRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuYWJsZWR9O214R3JhcGgucHJvdG90eXBlLnNldEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5lbmFibGVkPWF9OwpteEdyYXBoLnByb3RvdHlwZS5pc0VzY2FwZUVuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lc2NhcGVFbmFibGVkfTtteEdyYXBoLnByb3RvdHlwZS5zZXRFc2NhcGVFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuZXNjYXBlRW5hYmxlZD1hfTtteEdyYXBoLnByb3RvdHlwZS5pc0ludm9rZXNTdG9wQ2VsbEVkaXRpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnZva2VzU3RvcENlbGxFZGl0aW5nfTtteEdyYXBoLnByb3RvdHlwZS5zZXRJbnZva2VzU3RvcENlbGxFZGl0aW5nPWZ1bmN0aW9uKGEpe3RoaXMuaW52b2tlc1N0b3BDZWxsRWRpdGluZz1hfTtteEdyYXBoLnByb3RvdHlwZS5pc0VudGVyU3RvcHNDZWxsRWRpdGluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVudGVyU3RvcHNDZWxsRWRpdGluZ307bXhHcmFwaC5wcm90b3R5cGUuc2V0RW50ZXJTdG9wc0NlbGxFZGl0aW5nPWZ1bmN0aW9uKGEpe3RoaXMuZW50ZXJTdG9wc0NlbGxFZGl0aW5nPWF9OwpteEdyYXBoLnByb3RvdHlwZS5pc0NlbGxMb2NrZWQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5tb2RlbC5nZXRHZW9tZXRyeShhKTtyZXR1cm4gdGhpcy5pc0NlbGxzTG9ja2VkKCl8fG51bGwhPWImJnRoaXMubW9kZWwuaXNWZXJ0ZXgoYSkmJmIucmVsYXRpdmV9O214R3JhcGgucHJvdG90eXBlLmlzQ2VsbHNMb2NrZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsc0xvY2tlZH07bXhHcmFwaC5wcm90b3R5cGUuc2V0Q2VsbHNMb2NrZWQ9ZnVuY3Rpb24oYSl7dGhpcy5jZWxsc0xvY2tlZD1hfTtteEdyYXBoLnByb3RvdHlwZS5nZXRDbG9uZWFibGVDZWxscz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5tb2RlbC5maWx0ZXJDZWxscyhhLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmlzQ2VsbENsb25lYWJsZShhKX0pKX07Cm14R3JhcGgucHJvdG90eXBlLmlzQ2VsbENsb25lYWJsZT1mdW5jdGlvbihhKXthPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShhKTtyZXR1cm4gdGhpcy5pc0NlbGxzQ2xvbmVhYmxlKCkmJjAhPWFbbXhDb25zdGFudHMuU1RZTEVfQ0xPTkVBQkxFXX07bXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsc0Nsb25lYWJsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGxzQ2xvbmVhYmxlfTtteEdyYXBoLnByb3RvdHlwZS5zZXRDZWxsc0Nsb25lYWJsZT1mdW5jdGlvbihhKXt0aGlzLmNlbGxzQ2xvbmVhYmxlPWF9O214R3JhcGgucHJvdG90eXBlLmdldEV4cG9ydGFibGVDZWxscz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5tb2RlbC5maWx0ZXJDZWxscyhhLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmNhbkV4cG9ydENlbGwoYSl9KSl9O214R3JhcGgucHJvdG90eXBlLmNhbkV4cG9ydENlbGw9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZXhwb3J0RW5hYmxlZH07Cm14R3JhcGgucHJvdG90eXBlLmdldEltcG9ydGFibGVDZWxscz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5tb2RlbC5maWx0ZXJDZWxscyhhLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmNhbkltcG9ydENlbGwoYSl9KSl9O214R3JhcGgucHJvdG90eXBlLmNhbkltcG9ydENlbGw9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuaW1wb3J0RW5hYmxlZH07bXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsU2VsZWN0YWJsZT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pc0NlbGxzU2VsZWN0YWJsZSgpfTtteEdyYXBoLnByb3RvdHlwZS5pc0NlbGxzU2VsZWN0YWJsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGxzU2VsZWN0YWJsZX07bXhHcmFwaC5wcm90b3R5cGUuc2V0Q2VsbHNTZWxlY3RhYmxlPWZ1bmN0aW9uKGEpe3RoaXMuY2VsbHNTZWxlY3RhYmxlPWF9OwpteEdyYXBoLnByb3RvdHlwZS5nZXREZWxldGFibGVDZWxscz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5tb2RlbC5maWx0ZXJDZWxscyhhLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmlzQ2VsbERlbGV0YWJsZShhKX0pKX07bXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsRGVsZXRhYmxlPWZ1bmN0aW9uKGEpe2E9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpO3JldHVybiB0aGlzLmlzQ2VsbHNEZWxldGFibGUoKSYmMCE9YVtteENvbnN0YW50cy5TVFlMRV9ERUxFVEFCTEVdfTtteEdyYXBoLnByb3RvdHlwZS5pc0NlbGxzRGVsZXRhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbHNEZWxldGFibGV9O214R3JhcGgucHJvdG90eXBlLnNldENlbGxzRGVsZXRhYmxlPWZ1bmN0aW9uKGEpe3RoaXMuY2VsbHNEZWxldGFibGU9YX07Cm14R3JhcGgucHJvdG90eXBlLmlzTGFiZWxNb3ZhYmxlPWZ1bmN0aW9uKGEpe3JldHVybiF0aGlzLmlzQ2VsbExvY2tlZChhKSYmKHRoaXMubW9kZWwuaXNFZGdlKGEpJiZ0aGlzLmVkZ2VMYWJlbHNNb3ZhYmxlfHx0aGlzLm1vZGVsLmlzVmVydGV4KGEpJiZ0aGlzLnZlcnRleExhYmVsc01vdmFibGUpfTtteEdyYXBoLnByb3RvdHlwZS5pc0NlbGxSb3RhdGFibGU9ZnVuY3Rpb24oYSl7cmV0dXJuIDAhPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShhKVtteENvbnN0YW50cy5TVFlMRV9ST1RBVEFCTEVdfTtteEdyYXBoLnByb3RvdHlwZS5nZXRNb3ZhYmxlQ2VsbHM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubW9kZWwuZmlsdGVyQ2VsbHMoYSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pc0NlbGxNb3ZhYmxlKGEpfSkpfTsKbXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsTW92YWJsZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdldEN1cnJlbnRDZWxsU3R5bGUoYSk7cmV0dXJuIHRoaXMuaXNDZWxsc01vdmFibGUoKSYmIXRoaXMuaXNDZWxsTG9ja2VkKGEpJiYwIT1iW214Q29uc3RhbnRzLlNUWUxFX01PVkFCTEVdfTtteEdyYXBoLnByb3RvdHlwZS5pc0NlbGxzTW92YWJsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGxzTW92YWJsZX07bXhHcmFwaC5wcm90b3R5cGUuc2V0Q2VsbHNNb3ZhYmxlPWZ1bmN0aW9uKGEpe3RoaXMuY2VsbHNNb3ZhYmxlPWF9O214R3JhcGgucHJvdG90eXBlLmlzR3JpZEVuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmlkRW5hYmxlZH07bXhHcmFwaC5wcm90b3R5cGUuc2V0R3JpZEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5ncmlkRW5hYmxlZD1hfTtteEdyYXBoLnByb3RvdHlwZS5pc1BvcnRzRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvcnRzRW5hYmxlZH07Cm14R3JhcGgucHJvdG90eXBlLnNldFBvcnRzRW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLnBvcnRzRW5hYmxlZD1hfTtteEdyYXBoLnByb3RvdHlwZS5nZXRHcmlkU2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdyaWRTaXplfTtteEdyYXBoLnByb3RvdHlwZS5zZXRHcmlkU2l6ZT1mdW5jdGlvbihhKXt0aGlzLmdyaWRTaXplPWF9O214R3JhcGgucHJvdG90eXBlLmdldFRvbGVyYW5jZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRvbGVyYW5jZX07bXhHcmFwaC5wcm90b3R5cGUuc2V0VG9sZXJhbmNlPWZ1bmN0aW9uKGEpe3RoaXMudG9sZXJhbmNlPWF9O214R3JhcGgucHJvdG90eXBlLmlzVmVydGV4TGFiZWxzTW92YWJsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZlcnRleExhYmVsc01vdmFibGV9O214R3JhcGgucHJvdG90eXBlLnNldFZlcnRleExhYmVsc01vdmFibGU9ZnVuY3Rpb24oYSl7dGhpcy52ZXJ0ZXhMYWJlbHNNb3ZhYmxlPWF9OwpteEdyYXBoLnByb3RvdHlwZS5pc0VkZ2VMYWJlbHNNb3ZhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZUxhYmVsc01vdmFibGV9O214R3JhcGgucHJvdG90eXBlLnNldEVkZ2VMYWJlbHNNb3ZhYmxlPWZ1bmN0aW9uKGEpe3RoaXMuZWRnZUxhYmVsc01vdmFibGU9YX07bXhHcmFwaC5wcm90b3R5cGUuaXNTd2ltbGFuZU5lc3Rpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zd2ltbGFuZU5lc3Rpbmd9O214R3JhcGgucHJvdG90eXBlLnNldFN3aW1sYW5lTmVzdGluZz1mdW5jdGlvbihhKXt0aGlzLnN3aW1sYW5lTmVzdGluZz1hfTtteEdyYXBoLnByb3RvdHlwZS5pc1N3aW1sYW5lU2VsZWN0aW9uRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN3aW1sYW5lU2VsZWN0aW9uRW5hYmxlZH07bXhHcmFwaC5wcm90b3R5cGUuc2V0U3dpbWxhbmVTZWxlY3Rpb25FbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuc3dpbWxhbmVTZWxlY3Rpb25FbmFibGVkPWF9OwpteEdyYXBoLnByb3RvdHlwZS5pc011bHRpZ3JhcGg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tdWx0aWdyYXBofTtteEdyYXBoLnByb3RvdHlwZS5zZXRNdWx0aWdyYXBoPWZ1bmN0aW9uKGEpe3RoaXMubXVsdGlncmFwaD1hfTtteEdyYXBoLnByb3RvdHlwZS5pc0FsbG93TG9vcHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hbGxvd0xvb3BzfTtteEdyYXBoLnByb3RvdHlwZS5zZXRBbGxvd0RhbmdsaW5nRWRnZXM9ZnVuY3Rpb24oYSl7dGhpcy5hbGxvd0RhbmdsaW5nRWRnZXM9YX07bXhHcmFwaC5wcm90b3R5cGUuaXNBbGxvd0RhbmdsaW5nRWRnZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hbGxvd0RhbmdsaW5nRWRnZXN9O214R3JhcGgucHJvdG90eXBlLnNldENvbm5lY3RhYmxlRWRnZXM9ZnVuY3Rpb24oYSl7dGhpcy5jb25uZWN0YWJsZUVkZ2VzPWF9O214R3JhcGgucHJvdG90eXBlLmlzQ29ubmVjdGFibGVFZGdlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbm5lY3RhYmxlRWRnZXN9OwpteEdyYXBoLnByb3RvdHlwZS5zZXRDbG9uZUludmFsaWRFZGdlcz1mdW5jdGlvbihhKXt0aGlzLmNsb25lSW52YWxpZEVkZ2VzPWF9O214R3JhcGgucHJvdG90eXBlLmlzQ2xvbmVJbnZhbGlkRWRnZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbG9uZUludmFsaWRFZGdlc307bXhHcmFwaC5wcm90b3R5cGUuc2V0QWxsb3dMb29wcz1mdW5jdGlvbihhKXt0aGlzLmFsbG93TG9vcHM9YX07bXhHcmFwaC5wcm90b3R5cGUuaXNEaXNjb25uZWN0T25Nb3ZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzY29ubmVjdE9uTW92ZX07bXhHcmFwaC5wcm90b3R5cGUuc2V0RGlzY29ubmVjdE9uTW92ZT1mdW5jdGlvbihhKXt0aGlzLmRpc2Nvbm5lY3RPbk1vdmU9YX07bXhHcmFwaC5wcm90b3R5cGUuaXNEcm9wRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRyb3BFbmFibGVkfTsKbXhHcmFwaC5wcm90b3R5cGUuc2V0RHJvcEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5kcm9wRW5hYmxlZD1hfTtteEdyYXBoLnByb3RvdHlwZS5pc1NwbGl0RW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNwbGl0RW5hYmxlZH07bXhHcmFwaC5wcm90b3R5cGUuc2V0U3BsaXRFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuc3BsaXRFbmFibGVkPWF9O214R3JhcGgucHJvdG90eXBlLmlzQ2VsbFJlc2l6YWJsZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdldEN1cnJlbnRDZWxsU3R5bGUoYSk7cmV0dXJuIHRoaXMuaXNDZWxsc1Jlc2l6YWJsZSgpJiYhdGhpcy5pc0NlbGxMb2NrZWQoYSkmJiIwIiE9bXhVdGlscy5nZXRWYWx1ZShiLG14Q29uc3RhbnRzLlNUWUxFX1JFU0laQUJMRSwiMSIpfTtteEdyYXBoLnByb3RvdHlwZS5pc0NlbGxzUmVzaXphYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbHNSZXNpemFibGV9OwpteEdyYXBoLnByb3RvdHlwZS5zZXRDZWxsc1Jlc2l6YWJsZT1mdW5jdGlvbihhKXt0aGlzLmNlbGxzUmVzaXphYmxlPWF9O214R3JhcGgucHJvdG90eXBlLmlzVGVybWluYWxQb2ludE1vdmFibGU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4hMH07bXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsQmVuZGFibGU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpO3JldHVybiB0aGlzLmlzQ2VsbHNCZW5kYWJsZSgpJiYhdGhpcy5pc0NlbGxMb2NrZWQoYSkmJjAhPWJbbXhDb25zdGFudHMuU1RZTEVfQkVOREFCTEVdfTtteEdyYXBoLnByb3RvdHlwZS5pc0NlbGxzQmVuZGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsc0JlbmRhYmxlfTtteEdyYXBoLnByb3RvdHlwZS5zZXRDZWxsc0JlbmRhYmxlPWZ1bmN0aW9uKGEpe3RoaXMuY2VsbHNCZW5kYWJsZT1hfTsKbXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsRWRpdGFibGU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpO3JldHVybiB0aGlzLmlzQ2VsbHNFZGl0YWJsZSgpJiYhdGhpcy5pc0NlbGxMb2NrZWQoYSkmJjAhPWJbbXhDb25zdGFudHMuU1RZTEVfRURJVEFCTEVdfTtteEdyYXBoLnByb3RvdHlwZS5pc0NlbGxzRWRpdGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsc0VkaXRhYmxlfTtteEdyYXBoLnByb3RvdHlwZS5zZXRDZWxsc0VkaXRhYmxlPWZ1bmN0aW9uKGEpe3RoaXMuY2VsbHNFZGl0YWJsZT1hfTtteEdyYXBoLnByb3RvdHlwZS5pc0NlbGxEaXNjb25uZWN0YWJsZT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRoaXMuaXNDZWxsc0Rpc2Nvbm5lY3RhYmxlKCkmJiF0aGlzLmlzQ2VsbExvY2tlZChhKX07bXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsc0Rpc2Nvbm5lY3RhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbHNEaXNjb25uZWN0YWJsZX07Cm14R3JhcGgucHJvdG90eXBlLnNldENlbGxzRGlzY29ubmVjdGFibGU9ZnVuY3Rpb24oYSl7dGhpcy5jZWxsc0Rpc2Nvbm5lY3RhYmxlPWF9O214R3JhcGgucHJvdG90eXBlLmlzVmFsaWRTb3VyY2U9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWEmJnRoaXMuYWxsb3dEYW5nbGluZ0VkZ2VzfHxudWxsIT1hJiYoIXRoaXMubW9kZWwuaXNFZGdlKGEpfHx0aGlzLmNvbm5lY3RhYmxlRWRnZXMpJiZ0aGlzLmlzQ2VsbENvbm5lY3RhYmxlKGEpfTtteEdyYXBoLnByb3RvdHlwZS5pc1ZhbGlkVGFyZ2V0PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmlzVmFsaWRTb3VyY2UoYSl9O214R3JhcGgucHJvdG90eXBlLmlzVmFsaWRDb25uZWN0aW9uPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuaXNWYWxpZFNvdXJjZShhKSYmdGhpcy5pc1ZhbGlkVGFyZ2V0KGIpfTtteEdyYXBoLnByb3RvdHlwZS5zZXRDb25uZWN0YWJsZT1mdW5jdGlvbihhKXt0aGlzLmNvbm5lY3Rpb25IYW5kbGVyLnNldEVuYWJsZWQoYSl9OwpteEdyYXBoLnByb3RvdHlwZS5pc0Nvbm5lY3RhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29ubmVjdGlvbkhhbmRsZXIuaXNFbmFibGVkKCl9O214R3JhcGgucHJvdG90eXBlLnNldFRvb2x0aXBzPWZ1bmN0aW9uKGEpe3RoaXMudG9vbHRpcEhhbmRsZXIuc2V0RW5hYmxlZChhKX07bXhHcmFwaC5wcm90b3R5cGUuc2V0UGFubmluZz1mdW5jdGlvbihhKXt0aGlzLnBhbm5pbmdIYW5kbGVyLnBhbm5pbmdFbmFibGVkPWF9O214R3JhcGgucHJvdG90eXBlLmlzRWRpdGluZz1mdW5jdGlvbihhKXtpZihudWxsIT10aGlzLmNlbGxFZGl0b3Ipe3ZhciBiPXRoaXMuY2VsbEVkaXRvci5nZXRFZGl0aW5nQ2VsbCgpO3JldHVybiBudWxsPT1hP251bGwhPWI6YT09Yn1yZXR1cm4hMX07bXhHcmFwaC5wcm90b3R5cGUuaXNBdXRvU2l6ZUNlbGw9ZnVuY3Rpb24oYSl7YT10aGlzLmdldEN1cnJlbnRDZWxsU3R5bGUoYSk7cmV0dXJuIHRoaXMuaXNBdXRvU2l6ZUNlbGxzKCl8fDE9PWFbbXhDb25zdGFudHMuU1RZTEVfQVVUT1NJWkVdfTsKbXhHcmFwaC5wcm90b3R5cGUuaXNBdXRvU2l6ZUNlbGxzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXV0b1NpemVDZWxsc307bXhHcmFwaC5wcm90b3R5cGUuc2V0QXV0b1NpemVDZWxscz1mdW5jdGlvbihhKXt0aGlzLmF1dG9TaXplQ2VsbHM9YX07bXhHcmFwaC5wcm90b3R5cGUuaXNFeHRlbmRQYXJlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIXRoaXMuZ2V0TW9kZWwoKS5pc0VkZ2UoYSkmJnRoaXMuaXNFeHRlbmRQYXJlbnRzKCl9O214R3JhcGgucHJvdG90eXBlLmlzRXh0ZW5kUGFyZW50cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmV4dGVuZFBhcmVudHN9O214R3JhcGgucHJvdG90eXBlLnNldEV4dGVuZFBhcmVudHM9ZnVuY3Rpb24oYSl7dGhpcy5leHRlbmRQYXJlbnRzPWF9O214R3JhcGgucHJvdG90eXBlLmlzRXh0ZW5kUGFyZW50c09uQWRkPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmV4dGVuZFBhcmVudHNPbkFkZH07Cm14R3JhcGgucHJvdG90eXBlLnNldEV4dGVuZFBhcmVudHNPbkFkZD1mdW5jdGlvbihhKXt0aGlzLmV4dGVuZFBhcmVudHNPbkFkZD1hfTtteEdyYXBoLnByb3RvdHlwZS5pc0V4dGVuZFBhcmVudHNPbk1vdmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leHRlbmRQYXJlbnRzT25Nb3ZlfTtteEdyYXBoLnByb3RvdHlwZS5zZXRFeHRlbmRQYXJlbnRzT25Nb3ZlPWZ1bmN0aW9uKGEpe3RoaXMuZXh0ZW5kUGFyZW50c09uTW92ZT1hfTtteEdyYXBoLnByb3RvdHlwZS5pc1JlY3Vyc2l2ZVJlc2l6ZT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5yZWN1cnNpdmVSZXNpemV9O214R3JhcGgucHJvdG90eXBlLnNldFJlY3Vyc2l2ZVJlc2l6ZT1mdW5jdGlvbihhKXt0aGlzLnJlY3Vyc2l2ZVJlc2l6ZT1hfTtteEdyYXBoLnByb3RvdHlwZS5pc0NvbnN0cmFpbkNoaWxkPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmlzQ29uc3RyYWluQ2hpbGRyZW4oKSYmIXRoaXMuZ2V0TW9kZWwoKS5pc0VkZ2UodGhpcy5nZXRNb2RlbCgpLmdldFBhcmVudChhKSl9OwpteEdyYXBoLnByb3RvdHlwZS5pc0NvbnN0cmFpbkNoaWxkcmVuPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RyYWluQ2hpbGRyZW59O214R3JhcGgucHJvdG90eXBlLnNldENvbnN0cmFpbkNoaWxkcmVuPWZ1bmN0aW9uKGEpe3RoaXMuY29uc3RyYWluQ2hpbGRyZW49YX07bXhHcmFwaC5wcm90b3R5cGUuaXNDb25zdHJhaW5SZWxhdGl2ZUNoaWxkcmVuPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RyYWluUmVsYXRpdmVDaGlsZHJlbn07bXhHcmFwaC5wcm90b3R5cGUuc2V0Q29uc3RyYWluUmVsYXRpdmVDaGlsZHJlbj1mdW5jdGlvbihhKXt0aGlzLmNvbnN0cmFpblJlbGF0aXZlQ2hpbGRyZW49YX07bXhHcmFwaC5wcm90b3R5cGUuaXNBbGxvd05lZ2F0aXZlQ29vcmRpbmF0ZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hbGxvd05lZ2F0aXZlQ29vcmRpbmF0ZXN9OwpteEdyYXBoLnByb3RvdHlwZS5zZXRBbGxvd05lZ2F0aXZlQ29vcmRpbmF0ZXM9ZnVuY3Rpb24oYSl7dGhpcy5hbGxvd05lZ2F0aXZlQ29vcmRpbmF0ZXM9YX07bXhHcmFwaC5wcm90b3R5cGUuZ2V0T3ZlcmxhcD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pc0FsbG93T3ZlcmxhcFBhcmVudChhKT90aGlzLmRlZmF1bHRPdmVybGFwOjB9O214R3JhcGgucHJvdG90eXBlLmlzQWxsb3dPdmVybGFwUGFyZW50PWZ1bmN0aW9uKGEpe3JldHVybiExfTtteEdyYXBoLnByb3RvdHlwZS5nZXRGb2xkYWJsZUNlbGxzPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMubW9kZWwuZmlsdGVyQ2VsbHMoYSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pc0NlbGxGb2xkYWJsZShhLGIpfSkpfTsKbXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsRm9sZGFibGU9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdldEN1cnJlbnRDZWxsU3R5bGUoYSk7cmV0dXJuIDA8dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGEpJiYwIT1jW214Q29uc3RhbnRzLlNUWUxFX0ZPTERBQkxFXX07bXhHcmFwaC5wcm90b3R5cGUuaXNWYWxpZERyb3BUYXJnZXQ9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBudWxsIT1hJiYodGhpcy5pc1NwbGl0RW5hYmxlZCgpJiZ0aGlzLmlzU3BsaXRUYXJnZXQoYSxiLGMpfHwhdGhpcy5tb2RlbC5pc0VkZ2UoYSkmJih0aGlzLmlzU3dpbWxhbmUoYSl8fDA8dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGEpJiYhdGhpcy5pc0NlbGxDb2xsYXBzZWQoYSkpKX07Cm14R3JhcGgucHJvdG90eXBlLmlzU3BsaXRUYXJnZXQ9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB0aGlzLm1vZGVsLmlzRWRnZShhKSYmbnVsbCE9YiYmMT09Yi5sZW5ndGgmJnRoaXMuaXNDZWxsQ29ubmVjdGFibGUoYlswXSkmJm51bGw9PXRoaXMuZ2V0RWRnZVZhbGlkYXRpb25FcnJvcihhLHRoaXMubW9kZWwuZ2V0VGVybWluYWwoYSwhMCksYlswXSk/KGM9dGhpcy5tb2RlbC5nZXRUZXJtaW5hbChhLCEwKSxhPXRoaXMubW9kZWwuZ2V0VGVybWluYWwoYSwhMSksIXRoaXMubW9kZWwuaXNBbmNlc3RvcihiWzBdLGMpJiYhdGhpcy5tb2RlbC5pc0FuY2VzdG9yKGJbMF0sYSkpOiExfTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0RHJvcFRhcmdldD1mdW5jdGlvbihhLGIsYyxkKXtpZighdGhpcy5pc1N3aW1sYW5lTmVzdGluZygpKWZvcih2YXIgZT0wO2U8YS5sZW5ndGg7ZSsrKWlmKHRoaXMuaXNTd2ltbGFuZShhW2VdKSlyZXR1cm4gbnVsbDtlPW14VXRpbHMuY29udmVydFBvaW50KHRoaXMuY29udGFpbmVyLG14RXZlbnQuZ2V0Q2xpZW50WChiKSxteEV2ZW50LmdldENsaWVudFkoYikpO2UueC09dGhpcy5wYW5EeDtlLnktPXRoaXMucGFuRHk7ZT10aGlzLmdldFN3aW1sYW5lQXQoZS54LGUueSk7aWYobnVsbD09YyljPWU7ZWxzZSBpZihudWxsIT1lKXtmb3IodmFyIGY9dGhpcy5tb2RlbC5nZXRQYXJlbnQoZSk7bnVsbCE9ZiYmdGhpcy5pc1N3aW1sYW5lKGYpJiZmIT1jOylmPXRoaXMubW9kZWwuZ2V0UGFyZW50KGYpO2Y9PWMmJihjPWUpfWZvcig7bnVsbCE9YyYmIXRoaXMuaXNWYWxpZERyb3BUYXJnZXQoYyxhLGIpJiYhdGhpcy5tb2RlbC5pc0xheWVyKGMpOyljPXRoaXMubW9kZWwuZ2V0UGFyZW50KGMpOwppZihudWxsPT1kfHwhZClmb3IodmFyIGc9YztudWxsIT1nJiYwPm14VXRpbHMuaW5kZXhPZihhLGcpOylnPXRoaXMubW9kZWwuZ2V0UGFyZW50KGcpO3JldHVybiB0aGlzLm1vZGVsLmlzTGF5ZXIoYyl8fG51bGwhPWc/bnVsbDpjfTtteEdyYXBoLnByb3RvdHlwZS5nZXREZWZhdWx0UGFyZW50PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRDdXJyZW50Um9vdCgpO251bGw9PWEmJihhPXRoaXMuZGVmYXVsdFBhcmVudCxudWxsPT1hJiYoYT10aGlzLm1vZGVsLmdldFJvb3QoKSxhPXRoaXMubW9kZWwuZ2V0Q2hpbGRBdChhLDApKSk7cmV0dXJuIGF9O214R3JhcGgucHJvdG90eXBlLnNldERlZmF1bHRQYXJlbnQ9ZnVuY3Rpb24oYSl7dGhpcy5kZWZhdWx0UGFyZW50PWF9O214R3JhcGgucHJvdG90eXBlLmdldFN3aW1sYW5lPWZ1bmN0aW9uKGEpe2Zvcig7bnVsbCE9YSYmIXRoaXMuaXNTd2ltbGFuZShhKTspYT10aGlzLm1vZGVsLmdldFBhcmVudChhKTtyZXR1cm4gYX07Cm14R3JhcGgucHJvdG90eXBlLmdldFN3aW1sYW5lQXQ9ZnVuY3Rpb24oYSxiLGMpe251bGw9PWMmJihjPXRoaXMuZ2V0Q3VycmVudFJvb3QoKSxudWxsPT1jJiYoYz10aGlzLm1vZGVsLmdldFJvb3QoKSkpO2lmKG51bGwhPWMpZm9yKHZhciBkPXRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChjKSxlPTA7ZTxkO2UrKyl7dmFyIGY9dGhpcy5tb2RlbC5nZXRDaGlsZEF0KGMsZSk7aWYobnVsbCE9Zil7dmFyIGc9dGhpcy5nZXRTd2ltbGFuZUF0KGEsYixmKTtpZihudWxsIT1nKXJldHVybiBnO2lmKHRoaXMuaXNDZWxsVmlzaWJsZShmKSYmdGhpcy5pc1N3aW1sYW5lKGYpJiYoZz10aGlzLnZpZXcuZ2V0U3RhdGUoZiksdGhpcy5pbnRlcnNlY3RzKGcsYSxiKSkpcmV0dXJuIGZ9fXJldHVybiBudWxsfTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0Q2VsbEF0PWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtkPW51bGwhPWQ/ZDohMDtlPW51bGwhPWU/ZTohMDtudWxsPT1jJiYoYz10aGlzLmdldEN1cnJlbnRSb290KCksbnVsbD09YyYmKGM9dGhpcy5nZXRNb2RlbCgpLmdldFJvb3QoKSkpO2lmKG51bGwhPWMpZm9yKHZhciBnPXRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChjKS0xOzA8PWc7Zy0tKXt2YXIgaz10aGlzLm1vZGVsLmdldENoaWxkQXQoYyxnKSxsPXRoaXMuZ2V0Q2VsbEF0KGEsYixrLGQsZSxmKTtpZihudWxsIT1sKXJldHVybiBsO2lmKHRoaXMuaXNDZWxsVmlzaWJsZShrKSYmKGUmJnRoaXMubW9kZWwuaXNFZGdlKGspfHxkJiZ0aGlzLm1vZGVsLmlzVmVydGV4KGspKSYmKGw9dGhpcy52aWV3LmdldFN0YXRlKGspLG51bGwhPWwmJihudWxsPT1mfHwhZihsLGEsYikpJiZ0aGlzLmludGVyc2VjdHMobCxhLGIpKSlyZXR1cm4ga31yZXR1cm4gbnVsbH07Cm14R3JhcGgucHJvdG90eXBlLmludGVyc2VjdHM9ZnVuY3Rpb24oYSxiLGMpe2lmKG51bGwhPWEpe3ZhciBkPWEuYWJzb2x1dGVQb2ludHM7aWYobnVsbCE9ZCl7YT10aGlzLnRvbGVyYW5jZSp0aGlzLnRvbGVyYW5jZTtmb3IodmFyIGU9ZFswXSxmPTE7ZjxkLmxlbmd0aDtmKyspe3ZhciBnPWRbZl07aWYobXhVdGlscy5wdFNlZ0Rpc3RTcShlLngsZS55LGcueCxnLnksYixjKTw9YSlyZXR1cm4hMDtlPWd9fWVsc2UgaWYoZT1teFV0aWxzLnRvUmFkaWFucyhteFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT04pfHwwKSwwIT1lJiYoZD1NYXRoLmNvcygtZSksZT1NYXRoLnNpbigtZSksZj1uZXcgbXhQb2ludChhLmdldENlbnRlclgoKSxhLmdldENlbnRlclkoKSksZT1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChuZXcgbXhQb2ludChiLGMpLGQsZSxmKSxiPWUueCxjPWUueSksbXhVdGlscy5jb250YWlucyhhLGIsYykpcmV0dXJuITB9cmV0dXJuITF9OwpteEdyYXBoLnByb3RvdHlwZS5oaXRzU3dpbWxhbmVDb250ZW50PWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLmdldFZpZXcoKS5nZXRTdGF0ZShhKTthPXRoaXMuZ2V0U3RhcnRTaXplKGEpO2lmKG51bGwhPWQpe3ZhciBlPXRoaXMuZ2V0VmlldygpLmdldFNjYWxlKCk7Yi09ZC54O2MtPWQueTtpZigwPGEud2lkdGgmJjA8YiYmYj5hLndpZHRoKmV8fDA8YS5oZWlnaHQmJjA8YyYmYz5hLmhlaWdodCplKXJldHVybiEwfXJldHVybiExfTtteEdyYXBoLnByb3RvdHlwZS5nZXRDaGlsZFZlcnRpY2VzPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdldENoaWxkQ2VsbHMoYSwhMCwhMSl9O214R3JhcGgucHJvdG90eXBlLmdldENoaWxkRWRnZXM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZ2V0Q2hpbGRDZWxscyhhLCExLCEwKX07Cm14R3JhcGgucHJvdG90eXBlLmdldENoaWxkQ2VsbHM9ZnVuY3Rpb24oYSxiLGMpe2E9bnVsbCE9YT9hOnRoaXMuZ2V0RGVmYXVsdFBhcmVudCgpO2E9dGhpcy5tb2RlbC5nZXRDaGlsZENlbGxzKGEsbnVsbCE9Yj9iOiExLG51bGwhPWM/YzohMSk7Yj1bXTtmb3IoYz0wO2M8YS5sZW5ndGg7YysrKXRoaXMuaXNDZWxsVmlzaWJsZShhW2NdKSYmYi5wdXNoKGFbY10pO3JldHVybiBifTtteEdyYXBoLnByb3RvdHlwZS5nZXRDb25uZWN0aW9ucz1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmdldEVkZ2VzKGEsYiwhMCwhMCwhMSl9O214R3JhcGgucHJvdG90eXBlLmdldEluY29taW5nRWRnZXM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5nZXRFZGdlcyhhLGIsITAsITEsITEpfTtteEdyYXBoLnByb3RvdHlwZS5nZXRPdXRnb2luZ0VkZ2VzPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuZ2V0RWRnZXMoYSxiLCExLCEwLCExKX07Cm14R3JhcGgucHJvdG90eXBlLmdldEVkZ2VzPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtjPW51bGwhPWM/YzohMDtkPW51bGwhPWQ/ZDohMDtlPW51bGwhPWU/ZTohMDtmPW51bGwhPWY/ZjohMTtmb3IodmFyIGc9W10saz10aGlzLmlzQ2VsbENvbGxhcHNlZChhKSxsPXRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChhKSxtPTA7bTxsO20rKyl7dmFyIG49dGhpcy5tb2RlbC5nZXRDaGlsZEF0KGEsbSk7aWYoa3x8IXRoaXMuaXNDZWxsVmlzaWJsZShuKSlnPWcuY29uY2F0KHRoaXMubW9kZWwuZ2V0RWRnZXMobixjLGQpKX1nPWcuY29uY2F0KHRoaXMubW9kZWwuZ2V0RWRnZXMoYSxjLGQpKTtrPVtdO2ZvcihtPTA7bTxnLmxlbmd0aDttKyspbj10aGlzLnZpZXcuZ2V0U3RhdGUoZ1ttXSksbD1udWxsIT1uP24uZ2V0VmlzaWJsZVRlcm1pbmFsKCEwKTp0aGlzLnZpZXcuZ2V0VmlzaWJsZVRlcm1pbmFsKGdbbV0sITApLG49bnVsbCE9bj9uLmdldFZpc2libGVUZXJtaW5hbCghMSk6dGhpcy52aWV3LmdldFZpc2libGVUZXJtaW5hbChnW21dLAohMSksKGUmJmw9PW58fGwhPW4mJihjJiZuPT1hJiYobnVsbD09Ynx8dGhpcy5pc1ZhbGlkQW5jZXN0b3IobCxiLGYpKXx8ZCYmbD09YSYmKG51bGw9PWJ8fHRoaXMuaXNWYWxpZEFuY2VzdG9yKG4sYixmKSkpKSYmay5wdXNoKGdbbV0pO3JldHVybiBrfTtteEdyYXBoLnByb3RvdHlwZS5pc1ZhbGlkQW5jZXN0b3I9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBjP3RoaXMubW9kZWwuaXNBbmNlc3RvcihiLGEpOnRoaXMubW9kZWwuZ2V0UGFyZW50KGEpPT1ifTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0T3Bwb3NpdGVzPWZ1bmN0aW9uKGEsYixjLGQpe2M9bnVsbCE9Yz9jOiEwO2Q9bnVsbCE9ZD9kOiEwO3ZhciBlPVtdLGY9bmV3IG14RGljdGlvbmFyeTtpZihudWxsIT1hKWZvcih2YXIgZz0wO2c8YS5sZW5ndGg7ZysrKXt2YXIgaz10aGlzLnZpZXcuZ2V0U3RhdGUoYVtnXSksbD1udWxsIT1rP2suZ2V0VmlzaWJsZVRlcm1pbmFsKCEwKTp0aGlzLnZpZXcuZ2V0VmlzaWJsZVRlcm1pbmFsKGFbZ10sITApLGs9bnVsbCE9az9rLmdldFZpc2libGVUZXJtaW5hbCghMSk6dGhpcy52aWV3LmdldFZpc2libGVUZXJtaW5hbChhW2ddLCExKTtsPT1iJiZudWxsIT1rJiZrIT1iJiZkP2YuZ2V0KGspfHwoZi5wdXQoaywhMCksZS5wdXNoKGspKTprPT1iJiZudWxsIT1sJiZsIT1iJiZjJiYhZi5nZXQobCkmJihmLnB1dChsLCEwKSxlLnB1c2gobCkpfXJldHVybiBlfTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0RWRnZXNCZXR3ZWVuPWZ1bmN0aW9uKGEsYixjKXtjPW51bGwhPWM/YzohMTtmb3IodmFyIGQ9dGhpcy5nZXRFZGdlcyhhKSxlPVtdLGY9MDtmPGQubGVuZ3RoO2YrKyl7dmFyIGc9dGhpcy52aWV3LmdldFN0YXRlKGRbZl0pLGs9bnVsbCE9Zz9nLmdldFZpc2libGVUZXJtaW5hbCghMCk6dGhpcy52aWV3LmdldFZpc2libGVUZXJtaW5hbChkW2ZdLCEwKSxnPW51bGwhPWc/Zy5nZXRWaXNpYmxlVGVybWluYWwoITEpOnRoaXMudmlldy5nZXRWaXNpYmxlVGVybWluYWwoZFtmXSwhMSk7KGs9PWEmJmc9PWJ8fCFjJiZrPT1iJiZnPT1hKSYmZS5wdXNoKGRbZl0pfXJldHVybiBlfTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0UG9pbnRGb3JFdmVudD1mdW5jdGlvbihhLGIpe3ZhciBjPW14VXRpbHMuY29udmVydFBvaW50KHRoaXMuY29udGFpbmVyLG14RXZlbnQuZ2V0Q2xpZW50WChhKSxteEV2ZW50LmdldENsaWVudFkoYSkpLGQ9dGhpcy52aWV3LnNjYWxlLGU9dGhpcy52aWV3LnRyYW5zbGF0ZSxmPTAhPWI/dGhpcy5ncmlkU2l6ZS8yOjA7Yy54PXRoaXMuc25hcChjLngvZC1lLngtZik7Yy55PXRoaXMuc25hcChjLnkvZC1lLnktZik7cmV0dXJuIGN9OwpteEdyYXBoLnByb3RvdHlwZS5nZXRDZWxscz1mdW5jdGlvbihhLGIsYyxkLGUsZil7Zj1udWxsIT1mP2Y6W107aWYoMDxjfHwwPGQpe3ZhciBnPXRoaXMuZ2V0TW9kZWwoKSxrPWErYyxsPWIrZDtudWxsPT1lJiYoZT10aGlzLmdldEN1cnJlbnRSb290KCksbnVsbD09ZSYmKGU9Zy5nZXRSb290KCkpKTtpZihudWxsIT1lKWZvcih2YXIgbT1nLmdldENoaWxkQ291bnQoZSksbj0wO248bTtuKyspe3ZhciBwPWcuZ2V0Q2hpbGRBdChlLG4pLHE9dGhpcy52aWV3LmdldFN0YXRlKHApO2lmKG51bGwhPXEmJnRoaXMuaXNDZWxsVmlzaWJsZShwKSl7dmFyIHI9bXhVdGlscy5nZXRWYWx1ZShxLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OKXx8MDswIT1yJiYocT1teFV0aWxzLmdldEJvdW5kaW5nQm94KHEscikpOyhnLmlzRWRnZShwKXx8Zy5pc1ZlcnRleChwKSkmJnEueD49YSYmcS55K3EuaGVpZ2h0PD1sJiZxLnk+PWImJnEueCtxLndpZHRoPD1rP2YucHVzaChwKTp0aGlzLmdldENlbGxzKGEsCmIsYyxkLHAsZil9fX1yZXR1cm4gZn07bXhHcmFwaC5wcm90b3R5cGUuZ2V0Q2VsbHNCZXlvbmQ9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1bXTtpZihkfHxlKWlmKG51bGw9PWMmJihjPXRoaXMuZ2V0RGVmYXVsdFBhcmVudCgpKSxudWxsIT1jKWZvcih2YXIgZz10aGlzLm1vZGVsLmdldENoaWxkQ291bnQoYyksaz0wO2s8ZztrKyspe3ZhciBsPXRoaXMubW9kZWwuZ2V0Q2hpbGRBdChjLGspLG09dGhpcy52aWV3LmdldFN0YXRlKGwpO3RoaXMuaXNDZWxsVmlzaWJsZShsKSYmbnVsbCE9bSYmKCFkfHxtLng+PWEpJiYoIWV8fG0ueT49YikmJmYucHVzaChsKX1yZXR1cm4gZn07Cm14R3JhcGgucHJvdG90eXBlLmZpbmRUcmVlUm9vdHM9ZnVuY3Rpb24oYSxiLGMpe2I9bnVsbCE9Yj9iOiExO2M9bnVsbCE9Yz9jOiExO3ZhciBkPVtdO2lmKG51bGwhPWEpe2Zvcih2YXIgZT10aGlzLmdldE1vZGVsKCksZj1lLmdldENoaWxkQ291bnQoYSksZz1udWxsLGs9MCxsPTA7bDxmO2wrKyl7dmFyIG09ZS5nZXRDaGlsZEF0KGEsbCk7aWYodGhpcy5tb2RlbC5pc1ZlcnRleChtKSYmdGhpcy5pc0NlbGxWaXNpYmxlKG0pKXtmb3IodmFyIG49dGhpcy5nZXRDb25uZWN0aW9ucyhtLGI/YTpudWxsKSxwPTAscT0wLHI9MDtyPG4ubGVuZ3RoO3IrKyl0aGlzLnZpZXcuZ2V0VmlzaWJsZVRlcm1pbmFsKG5bcl0sITApPT1tP3ArKzpxKys7KGMmJjA9PXAmJjA8cXx8IWMmJjA9PXEmJjA8cCkmJmQucHVzaChtKTtuPWM/cS1wOnAtcTtuPmsmJihrPW4sZz1tKX19MD09ZC5sZW5ndGgmJm51bGwhPWcmJmQucHVzaChnKX1yZXR1cm4gZH07Cm14R3JhcGgucHJvdG90eXBlLnRyYXZlcnNlPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtpZihudWxsIT1jJiZudWxsIT1hJiYoYj1udWxsIT1iP2I6ITAsZj1udWxsIT1mP2Y6ITEsZT1lfHxuZXcgbXhEaWN0aW9uYXJ5LCFlLmdldChhKSYmKGUucHV0KGEsITApLGQ9YyhhLGQpLG51bGw9PWR8fGQpKSYmKGQ9dGhpcy5tb2RlbC5nZXRFZGdlQ291bnQoYSksMDxkKSlmb3IodmFyIGc9MDtnPGQ7ZysrKXt2YXIgaz10aGlzLm1vZGVsLmdldEVkZ2VBdChhLGcpLGw9dGhpcy5tb2RlbC5nZXRUZXJtaW5hbChrLCEwKT09YTtiJiYhZiE9bHx8KGw9dGhpcy5tb2RlbC5nZXRUZXJtaW5hbChrLCFsKSx0aGlzLnRyYXZlcnNlKGwsYixjLGssZSxmKSl9fTtteEdyYXBoLnByb3RvdHlwZS5pc0NlbGxTZWxlY3RlZD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmlzU2VsZWN0ZWQoYSl9O214R3JhcGgucHJvdG90eXBlLmlzU2VsZWN0aW9uRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmlzRW1wdHkoKX07Cm14R3JhcGgucHJvdG90eXBlLmNsZWFyU2VsZWN0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5jbGVhcigpfTtteEdyYXBoLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25Db3VudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuY2VsbHMubGVuZ3RofTtteEdyYXBoLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25DZWxsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5jZWxsc1swXX07bXhHcmFwaC5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uQ2VsbHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmNlbGxzLnNsaWNlKCl9O214R3JhcGgucHJvdG90eXBlLnNldFNlbGVjdGlvbkNlbGw9ZnVuY3Rpb24oYSl7dGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLnNldENlbGwoYSl9O214R3JhcGgucHJvdG90eXBlLnNldFNlbGVjdGlvbkNlbGxzPWZ1bmN0aW9uKGEpe3RoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5zZXRDZWxscyhhKX07Cm14R3JhcGgucHJvdG90eXBlLmFkZFNlbGVjdGlvbkNlbGw9ZnVuY3Rpb24oYSl7dGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmFkZENlbGwoYSl9O214R3JhcGgucHJvdG90eXBlLmFkZFNlbGVjdGlvbkNlbGxzPWZ1bmN0aW9uKGEpe3RoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5hZGRDZWxscyhhKX07bXhHcmFwaC5wcm90b3R5cGUucmVtb3ZlU2VsZWN0aW9uQ2VsbD1mdW5jdGlvbihhKXt0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkucmVtb3ZlQ2VsbChhKX07bXhHcmFwaC5wcm90b3R5cGUucmVtb3ZlU2VsZWN0aW9uQ2VsbHM9ZnVuY3Rpb24oYSl7dGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLnJlbW92ZUNlbGxzKGEpfTtteEdyYXBoLnByb3RvdHlwZS5zZWxlY3RSZWdpb249ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdldENlbGxzKGEueCxhLnksYS53aWR0aCxhLmhlaWdodCk7dGhpcy5zZWxlY3RDZWxsc0ZvckV2ZW50KGMsYik7cmV0dXJuIGN9OwpteEdyYXBoLnByb3RvdHlwZS5zZWxlY3ROZXh0Q2VsbD1mdW5jdGlvbigpe3RoaXMuc2VsZWN0Q2VsbCghMCl9O214R3JhcGgucHJvdG90eXBlLnNlbGVjdFByZXZpb3VzQ2VsbD1mdW5jdGlvbigpe3RoaXMuc2VsZWN0Q2VsbCgpfTtteEdyYXBoLnByb3RvdHlwZS5zZWxlY3RQYXJlbnRDZWxsPWZ1bmN0aW9uKCl7dGhpcy5zZWxlY3RDZWxsKCExLCEwKX07bXhHcmFwaC5wcm90b3R5cGUuc2VsZWN0Q2hpbGRDZWxsPWZ1bmN0aW9uKCl7dGhpcy5zZWxlY3RDZWxsKCExLCExLCEwKX07Cm14R3JhcGgucHJvdG90eXBlLnNlbGVjdENlbGw9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuc2VsZWN0aW9uTW9kZWwsZT0wPGQuY2VsbHMubGVuZ3RoP2QuY2VsbHNbMF06bnVsbDsxPGQuY2VsbHMubGVuZ3RoJiZkLmNsZWFyKCk7dmFyIGQ9bnVsbCE9ZT90aGlzLm1vZGVsLmdldFBhcmVudChlKTp0aGlzLmdldERlZmF1bHRQYXJlbnQoKSxmPXRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChkKTtudWxsPT1lJiYwPGY/KGE9dGhpcy5tb2RlbC5nZXRDaGlsZEF0KGQsMCksdGhpcy5zZXRTZWxlY3Rpb25DZWxsKGEpKTpudWxsIT1lJiYhYnx8bnVsbD09dGhpcy52aWV3LmdldFN0YXRlKGQpfHxudWxsPT10aGlzLm1vZGVsLmdldEdlb21ldHJ5KGQpP251bGwhPWUmJmM/MDx0aGlzLm1vZGVsLmdldENoaWxkQ291bnQoZSkmJihhPXRoaXMubW9kZWwuZ2V0Q2hpbGRBdChlLDApLHRoaXMuc2V0U2VsZWN0aW9uQ2VsbChhKSk6MDxmJiYoYj1kLmdldEluZGV4KGUpLGE/KGIrKyxhPXRoaXMubW9kZWwuZ2V0Q2hpbGRBdChkLApiJWYpKTooYi0tLGE9dGhpcy5tb2RlbC5nZXRDaGlsZEF0KGQsMD5iP2YtMTpiKSksdGhpcy5zZXRTZWxlY3Rpb25DZWxsKGEpKTp0aGlzLmdldEN1cnJlbnRSb290KCkhPWQmJnRoaXMuc2V0U2VsZWN0aW9uQ2VsbChkKX07bXhHcmFwaC5wcm90b3R5cGUuc2VsZWN0QWxsPWZ1bmN0aW9uKGEsYil7YT1hfHx0aGlzLmdldERlZmF1bHRQYXJlbnQoKTt2YXIgYz1iP3RoaXMubW9kZWwuZmlsdGVyRGVzY2VuZGFudHMobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7cmV0dXJuIGIhPWEmJm51bGwhPXRoaXMudmlldy5nZXRTdGF0ZShiKX0pLGEpOnRoaXMubW9kZWwuZ2V0Q2hpbGRyZW4oYSk7bnVsbCE9YyYmdGhpcy5zZXRTZWxlY3Rpb25DZWxscyhjKX07bXhHcmFwaC5wcm90b3R5cGUuc2VsZWN0VmVydGljZXM9ZnVuY3Rpb24oYSxiKXt0aGlzLnNlbGVjdENlbGxzKCEwLCExLGEsYil9OwpteEdyYXBoLnByb3RvdHlwZS5zZWxlY3RFZGdlcz1mdW5jdGlvbihhKXt0aGlzLnNlbGVjdENlbGxzKCExLCEwLGEpfTtteEdyYXBoLnByb3RvdHlwZS5zZWxlY3RDZWxscz1mdW5jdGlvbihhLGIsYyxkKXtjPWN8fHRoaXMuZ2V0RGVmYXVsdFBhcmVudCgpO3ZhciBlPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGMpe3JldHVybiBudWxsIT10aGlzLnZpZXcuZ2V0U3RhdGUoYykmJigoZHx8MD09dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGMpKSYmdGhpcy5tb2RlbC5pc1ZlcnRleChjKSYmYSYmIXRoaXMubW9kZWwuaXNFZGdlKHRoaXMubW9kZWwuZ2V0UGFyZW50KGMpKXx8dGhpcy5tb2RlbC5pc0VkZ2UoYykmJmIpfSk7Yz10aGlzLm1vZGVsLmZpbHRlckRlc2NlbmRhbnRzKGUsYyk7bnVsbCE9YyYmdGhpcy5zZXRTZWxlY3Rpb25DZWxscyhjKX07Cm14R3JhcGgucHJvdG90eXBlLnNlbGVjdENlbGxGb3JFdmVudD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuaXNDZWxsU2VsZWN0ZWQoYSk7dGhpcy5pc1RvZ2dsZUV2ZW50KGIpP2M/dGhpcy5yZW1vdmVTZWxlY3Rpb25DZWxsKGEpOnRoaXMuYWRkU2VsZWN0aW9uQ2VsbChhKTpjJiYxPT10aGlzLmdldFNlbGVjdGlvbkNvdW50KCl8fHRoaXMuc2V0U2VsZWN0aW9uQ2VsbChhKX07bXhHcmFwaC5wcm90b3R5cGUuc2VsZWN0Q2VsbHNGb3JFdmVudD1mdW5jdGlvbihhLGIpe3RoaXMuaXNUb2dnbGVFdmVudChiKT90aGlzLmFkZFNlbGVjdGlvbkNlbGxzKGEpOnRoaXMuc2V0U2VsZWN0aW9uQ2VsbHMoYSl9OwpteEdyYXBoLnByb3RvdHlwZS5jcmVhdGVIYW5kbGVyPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7aWYobnVsbCE9YSlpZih0aGlzLm1vZGVsLmlzRWRnZShhLmNlbGwpKXZhciBiPWEuZ2V0VmlzaWJsZVRlcm1pbmFsU3RhdGUoITApLGM9YS5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZSghMSksZD10aGlzLmdldENlbGxHZW9tZXRyeShhLmNlbGwpLGI9dGhpcy52aWV3LmdldEVkZ2VTdHlsZShhLG51bGwhPWQ/ZC5wb2ludHM6bnVsbCxiLGMpLGI9dGhpcy5jcmVhdGVFZGdlSGFuZGxlcihhLGIpO2Vsc2UgYj10aGlzLmNyZWF0ZVZlcnRleEhhbmRsZXIoYSk7cmV0dXJuIGJ9O214R3JhcGgucHJvdG90eXBlLmNyZWF0ZVZlcnRleEhhbmRsZXI9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBteFZlcnRleEhhbmRsZXIoYSl9OwpteEdyYXBoLnByb3RvdHlwZS5jcmVhdGVFZGdlSGFuZGxlcj1mdW5jdGlvbihhLGIpe3JldHVybiBiPT1teEVkZ2VTdHlsZS5Mb29wfHxiPT1teEVkZ2VTdHlsZS5FbGJvd0Nvbm5lY3Rvcnx8Yj09bXhFZGdlU3R5bGUuU2lkZVRvU2lkZXx8Yj09bXhFZGdlU3R5bGUuVG9wVG9Cb3R0b20/dGhpcy5jcmVhdGVFbGJvd0VkZ2VIYW5kbGVyKGEpOmI9PW14RWRnZVN0eWxlLlNlZ21lbnRDb25uZWN0b3J8fGI9PW14RWRnZVN0eWxlLk9ydGhDb25uZWN0b3I/dGhpcy5jcmVhdGVFZGdlU2VnbWVudEhhbmRsZXIoYSk6bmV3IG14RWRnZUhhbmRsZXIoYSl9O214R3JhcGgucHJvdG90eXBlLmNyZWF0ZUVkZ2VTZWdtZW50SGFuZGxlcj1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IG14RWRnZVNlZ21lbnRIYW5kbGVyKGEpfTtteEdyYXBoLnByb3RvdHlwZS5jcmVhdGVFbGJvd0VkZ2VIYW5kbGVyPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgbXhFbGJvd0VkZ2VIYW5kbGVyKGEpfTsKbXhHcmFwaC5wcm90b3R5cGUuYWRkTW91c2VMaXN0ZW5lcj1mdW5jdGlvbihhKXtudWxsPT10aGlzLm1vdXNlTGlzdGVuZXJzJiYodGhpcy5tb3VzZUxpc3RlbmVycz1bXSk7dGhpcy5tb3VzZUxpc3RlbmVycy5wdXNoKGEpfTtteEdyYXBoLnByb3RvdHlwZS5yZW1vdmVNb3VzZUxpc3RlbmVyPWZ1bmN0aW9uKGEpe2lmKG51bGwhPXRoaXMubW91c2VMaXN0ZW5lcnMpZm9yKHZhciBiPTA7Yjx0aGlzLm1vdXNlTGlzdGVuZXJzLmxlbmd0aDtiKyspaWYodGhpcy5tb3VzZUxpc3RlbmVyc1tiXT09YSl7dGhpcy5tb3VzZUxpc3RlbmVycy5zcGxpY2UoYiwxKTticmVha319OwpteEdyYXBoLnByb3RvdHlwZS51cGRhdGVNb3VzZUV2ZW50PWZ1bmN0aW9uKGEsYil7aWYobnVsbD09YS5ncmFwaFh8fG51bGw9PWEuZ3JhcGhZKXt2YXIgYz1teFV0aWxzLmNvbnZlcnRQb2ludCh0aGlzLmNvbnRhaW5lcixhLmdldFgoKSxhLmdldFkoKSk7YS5ncmFwaFg9Yy54LXRoaXMucGFuRHg7YS5ncmFwaFk9Yy55LXRoaXMucGFuRHk7bnVsbD09YS5nZXRDZWxsKCkmJnRoaXMuaXNNb3VzZURvd24mJmI9PW14RXZlbnQuTU9VU0VfTU9WRSYmKGEuc3RhdGU9dGhpcy52aWV3LmdldFN0YXRlKHRoaXMuZ2V0Q2VsbEF0KGMueCxjLnksbnVsbCxudWxsLG51bGwsZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWEuc2hhcGV8fGEuc2hhcGUucGFpbnRCYWNrZ3JvdW5kIT1teFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5wYWludEJhY2tncm91bmR8fCIxIj09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1BPSU5URVJfRVZFTlRTLCIxIil8fG51bGwhPWEuc2hhcGUuZmlsbCYmCmEuc2hhcGUuZmlsbCE9bXhDb25zdGFudHMuTk9ORX0pKSl9cmV0dXJuIGF9O214R3JhcGgucHJvdG90eXBlLmdldFN0YXRlRm9yVG91Y2hFdmVudD1mdW5jdGlvbihhKXt2YXIgYj1teEV2ZW50LmdldENsaWVudFgoYSk7YT1teEV2ZW50LmdldENsaWVudFkoYSk7Yj1teFV0aWxzLmNvbnZlcnRQb2ludCh0aGlzLmNvbnRhaW5lcixiLGEpO3JldHVybiB0aGlzLnZpZXcuZ2V0U3RhdGUodGhpcy5nZXRDZWxsQXQoYi54LGIueSkpfTsKbXhHcmFwaC5wcm90b3R5cGUuaXNFdmVudElnbm9yZWQ9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPW14RXZlbnQuaXNNb3VzZUV2ZW50KGIuZ2V0RXZlbnQoKSksZT0hMTtiLmdldEV2ZW50KCk9PXRoaXMubGFzdEV2ZW50P2U9ITA6dGhpcy5sYXN0RXZlbnQ9Yi5nZXRFdmVudCgpO251bGwhPXRoaXMuZXZlbnRTb3VyY2UmJmEhPW14RXZlbnQuTU9VU0VfTU9WRT8obXhFdmVudC5yZW1vdmVHZXN0dXJlTGlzdGVuZXJzKHRoaXMuZXZlbnRTb3VyY2UsbnVsbCx0aGlzLm1vdXNlTW92ZVJlZGlyZWN0LHRoaXMubW91c2VVcFJlZGlyZWN0KSx0aGlzLmV2ZW50U291cmNlPXRoaXMubW91c2VVcFJlZGlyZWN0PXRoaXMubW91c2VNb3ZlUmVkaXJlY3Q9bnVsbCk6bXhDbGllbnQuSVNfR0N8fG51bGw9PXRoaXMuZXZlbnRTb3VyY2V8fGIuZ2V0U291cmNlKCk9PXRoaXMuZXZlbnRTb3VyY2U/IW14Q2xpZW50LklTX1RPVUNIfHxhIT1teEV2ZW50Lk1PVVNFX0RPV058fGR8fG14RXZlbnQuaXNQZW5FdmVudChiLmdldEV2ZW50KCkpfHwKKHRoaXMuZXZlbnRTb3VyY2U9Yi5nZXRTb3VyY2UoKSx0aGlzLm1vdXNlTW92ZVJlZGlyZWN0PW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuZmlyZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9NT1ZFLG5ldyBteE1vdXNlRXZlbnQoYSx0aGlzLmdldFN0YXRlRm9yVG91Y2hFdmVudChhKSkpfSksdGhpcy5tb3VzZVVwUmVkaXJlY3Q9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX1VQLG5ldyBteE1vdXNlRXZlbnQoYSx0aGlzLmdldFN0YXRlRm9yVG91Y2hFdmVudChhKSkpfSksbXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKHRoaXMuZXZlbnRTb3VyY2UsbnVsbCx0aGlzLm1vdXNlTW92ZVJlZGlyZWN0LHRoaXMubW91c2VVcFJlZGlyZWN0KSk6ZT0hMDt0aGlzLmlzU3ludGhldGljRXZlbnRJZ25vcmVkKGEsYixjKSYmKGU9ITApO2lmKCFteEV2ZW50LmlzUG9wdXBUcmlnZ2VyKHRoaXMubGFzdEV2ZW50KSYmCmEhPW14RXZlbnQuTU9VU0VfTU9WRSYmMj09dGhpcy5sYXN0RXZlbnQuZGV0YWlsKXJldHVybiEwO2E9PW14RXZlbnQuTU9VU0VfVVAmJnRoaXMuaXNNb3VzZURvd24/dGhpcy5pc01vdXNlRG93bj0hMTphIT1teEV2ZW50Lk1PVVNFX0RPV058fHRoaXMuaXNNb3VzZURvd24/IWUmJigoIW14Q2xpZW50LklTX0ZGfHxhIT1teEV2ZW50Lk1PVVNFX01PVkUpJiZ0aGlzLmlzTW91c2VEb3duJiZ0aGlzLmlzTW91c2VUcmlnZ2VyIT1kfHxhPT1teEV2ZW50Lk1PVVNFX0RPV04mJnRoaXMuaXNNb3VzZURvd258fGE9PW14RXZlbnQuTU9VU0VfVVAmJiF0aGlzLmlzTW91c2VEb3duKSYmKGU9ITApOih0aGlzLmlzTW91c2VEb3duPSEwLHRoaXMuaXNNb3VzZVRyaWdnZXI9ZCk7ZXx8YSE9bXhFdmVudC5NT1VTRV9ET1dOfHwodGhpcy5sYXN0TW91c2VYPWIuZ2V0WCgpLHRoaXMubGFzdE1vdXNlWT1iLmdldFkoKSk7cmV0dXJuIGV9OwpteEdyYXBoLnByb3RvdHlwZS5pc1N5bnRoZXRpY0V2ZW50SWdub3JlZD1mdW5jdGlvbihhLGIsYyl7Yz0hMTtiPW14RXZlbnQuaXNNb3VzZUV2ZW50KGIuZ2V0RXZlbnQoKSk7dGhpcy5pZ25vcmVNb3VzZUV2ZW50cyYmYiYmYSE9bXhFdmVudC5NT1VTRV9NT1ZFPyh0aGlzLmlnbm9yZU1vdXNlRXZlbnRzPWEhPW14RXZlbnQuTU9VU0VfVVAsYz0hMCk6bXhDbGllbnQuSVNfRkYmJiFiJiZhPT1teEV2ZW50Lk1PVVNFX1VQJiYodGhpcy5pZ25vcmVNb3VzZUV2ZW50cz0hMCk7cmV0dXJuIGN9OwpteEdyYXBoLnByb3RvdHlwZS5pc0V2ZW50U291cmNlSWdub3JlZD1mdW5jdGlvbihhLGIpe3ZhciBjPWIuZ2V0U291cmNlKCksZD1udWxsIT1jLm5vZGVOYW1lP2Mubm9kZU5hbWUudG9Mb3dlckNhc2UoKToiIixlPSFteEV2ZW50LmlzTW91c2VFdmVudChiLmdldEV2ZW50KCkpfHxteEV2ZW50LmlzTGVmdE1vdXNlQnV0dG9uKGIuZ2V0RXZlbnQoKSk7cmV0dXJuIGE9PW14RXZlbnQuTU9VU0VfRE9XTiYmZSYmKCJzZWxlY3QiPT1kfHwib3B0aW9uIj09ZHx8ImlucHV0Ij09ZCYmImNoZWNrYm94IiE9Yy50eXBlJiYicmFkaW8iIT1jLnR5cGUmJiJidXR0b24iIT1jLnR5cGUmJiJzdWJtaXQiIT1jLnR5cGUmJiJmaWxlIiE9Yy50eXBlKX07bXhHcmFwaC5wcm90b3R5cGUuZ2V0RXZlbnRTdGF0ZT1mdW5jdGlvbihhKXtyZXR1cm4gYX07Cm14R3JhcGgucHJvdG90eXBlLmZpcmVNb3VzZUV2ZW50PWZ1bmN0aW9uKGEsYixjKXtpZih0aGlzLmlzRXZlbnRTb3VyY2VJZ25vcmVkKGEsYikpbnVsbCE9dGhpcy50b29sdGlwSGFuZGxlciYmdGhpcy50b29sdGlwSGFuZGxlci5oaWRlKCk7ZWxzZXtudWxsPT1jJiYoYz10aGlzKTtiPXRoaXMudXBkYXRlTW91c2VFdmVudChiLGEpO2lmKCF0aGlzLm5hdGl2ZURibENsaWNrRW5hYmxlZCYmIW14RXZlbnQuaXNQb3B1cFRyaWdnZXIoYi5nZXRFdmVudCgpKXx8dGhpcy5kb3VibGVUYXBFbmFibGVkJiZteENsaWVudC5JU19UT1VDSCYmKG14RXZlbnQuaXNUb3VjaEV2ZW50KGIuZ2V0RXZlbnQoKSl8fG14RXZlbnQuaXNQZW5FdmVudChiLmdldEV2ZW50KCkpKSl7dmFyIGQ9KG5ldyBEYXRlKS5nZXRUaW1lKCk7aWYoIW14Q2xpZW50LklTX1FVSVJLUyYmYT09bXhFdmVudC5NT1VTRV9ET1dOfHxteENsaWVudC5JU19RVUlSS1MmJmE9PW14RXZlbnQuTU9VU0VfVVAmJiF0aGlzLmZpcmVEb3VibGVDbGljaylpZihudWxsIT0KdGhpcy5sYXN0VG91Y2hFdmVudCYmdGhpcy5sYXN0VG91Y2hFdmVudCE9Yi5nZXRFdmVudCgpJiZkLXRoaXMubGFzdFRvdWNoVGltZTx0aGlzLmRvdWJsZVRhcFRpbWVvdXQmJk1hdGguYWJzKHRoaXMubGFzdFRvdWNoWC1iLmdldFgoKSk8dGhpcy5kb3VibGVUYXBUb2xlcmFuY2UmJk1hdGguYWJzKHRoaXMubGFzdFRvdWNoWS1iLmdldFkoKSk8dGhpcy5kb3VibGVUYXBUb2xlcmFuY2UmJjI+dGhpcy5kb3VibGVDbGlja0NvdW50ZXIpe2lmKHRoaXMuZG91YmxlQ2xpY2tDb3VudGVyKyssZD0hMSxhPT1teEV2ZW50Lk1PVVNFX1VQP2IuZ2V0Q2VsbCgpPT10aGlzLmxhc3RUb3VjaENlbGwmJm51bGwhPXRoaXMubGFzdFRvdWNoQ2VsbCYmKHRoaXMubGFzdFRvdWNoVGltZT0wLGQ9dGhpcy5sYXN0VG91Y2hDZWxsLHRoaXMubGFzdFRvdWNoQ2VsbD1udWxsLG14Q2xpZW50LklTX1FVSVJLUyYmYi5nZXRTb3VyY2UoKS5maXJlRXZlbnQoIm9uZGJsY2xpY2siKSx0aGlzLmRibENsaWNrKGIuZ2V0RXZlbnQoKSwKZCksZD0hMCk6KHRoaXMuZmlyZURvdWJsZUNsaWNrPSEwLHRoaXMubGFzdFRvdWNoVGltZT0wKSwhbXhDbGllbnQuSVNfUVVJUktTfHxkKXtteEV2ZW50LmNvbnN1bWUoYi5nZXRFdmVudCgpKTtyZXR1cm59fWVsc2V7aWYobnVsbD09dGhpcy5sYXN0VG91Y2hFdmVudHx8dGhpcy5sYXN0VG91Y2hFdmVudCE9Yi5nZXRFdmVudCgpKXRoaXMubGFzdFRvdWNoQ2VsbD1iLmdldENlbGwoKSx0aGlzLmxhc3RUb3VjaFg9Yi5nZXRYKCksdGhpcy5sYXN0VG91Y2hZPWIuZ2V0WSgpLHRoaXMubGFzdFRvdWNoVGltZT1kLHRoaXMubGFzdFRvdWNoRXZlbnQ9Yi5nZXRFdmVudCgpLHRoaXMuZG91YmxlQ2xpY2tDb3VudGVyPTB9ZWxzZSBpZigodGhpcy5pc01vdXNlRG93bnx8YT09bXhFdmVudC5NT1VTRV9VUCkmJnRoaXMuZmlyZURvdWJsZUNsaWNrKXt0aGlzLmZpcmVEb3VibGVDbGljaz0hMTtkPXRoaXMubGFzdFRvdWNoQ2VsbDt0aGlzLmxhc3RUb3VjaENlbGw9bnVsbDt0aGlzLmlzTW91c2VEb3duPQohMTsobnVsbCE9ZHx8KG14RXZlbnQuaXNUb3VjaEV2ZW50KGIuZ2V0RXZlbnQoKSl8fG14RXZlbnQuaXNQZW5FdmVudChiLmdldEV2ZW50KCkpKSYmKG14Q2xpZW50LklTX0dDfHxteENsaWVudC5JU19TRikpJiZNYXRoLmFicyh0aGlzLmxhc3RUb3VjaFgtYi5nZXRYKCkpPHRoaXMuZG91YmxlVGFwVG9sZXJhbmNlJiZNYXRoLmFicyh0aGlzLmxhc3RUb3VjaFktYi5nZXRZKCkpPHRoaXMuZG91YmxlVGFwVG9sZXJhbmNlP3RoaXMuZGJsQ2xpY2soYi5nZXRFdmVudCgpLGQpOm14RXZlbnQuY29uc3VtZShiLmdldEV2ZW50KCkpO3JldHVybn19aWYoIXRoaXMuaXNFdmVudElnbm9yZWQoYSxiLGMpKXtiLnN0YXRlPXRoaXMuZ2V0RXZlbnRTdGF0ZShiLmdldFN0YXRlKCkpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuRklSRV9NT1VTRV9FVkVOVCwiZXZlbnROYW1lIixhLCJldmVudCIsYikpO2lmKG14Q2xpZW50LklTX09QfHxteENsaWVudC5JU19TRnx8bXhDbGllbnQuSVNfR0N8fApteENsaWVudC5JU19JRTExfHxteENsaWVudC5JU19JRSYmbXhDbGllbnQuSVNfU1ZHfHxiLmdldEV2ZW50KCkudGFyZ2V0IT10aGlzLmNvbnRhaW5lcil7aWYoYT09bXhFdmVudC5NT1VTRV9NT1ZFJiZ0aGlzLmlzTW91c2VEb3duJiZ0aGlzLmF1dG9TY3JvbGwmJiFteEV2ZW50LmlzTXVsdGlUb3VjaEV2ZW50KGIuZ2V0RXZlbnQpKXRoaXMuc2Nyb2xsUG9pbnRUb1Zpc2libGUoYi5nZXRHcmFwaFgoKSxiLmdldEdyYXBoWSgpLHRoaXMuYXV0b0V4dGVuZCk7ZWxzZSBpZihhPT1teEV2ZW50Lk1PVVNFX1VQJiZ0aGlzLmlnbm9yZVNjcm9sbGJhcnMmJnRoaXMudHJhbnNsYXRlVG9TY3JvbGxQb3NpdGlvbiYmKDAhPXRoaXMuY29udGFpbmVyLnNjcm9sbExlZnR8fDAhPXRoaXMuY29udGFpbmVyLnNjcm9sbFRvcCkpe3ZhciBkPXRoaXMudmlldy5zY2FsZSxlPXRoaXMudmlldy50cmFuc2xhdGU7dGhpcy52aWV3LnNldFRyYW5zbGF0ZShlLngtdGhpcy5jb250YWluZXIuc2Nyb2xsTGVmdC8KZCxlLnktdGhpcy5jb250YWluZXIuc2Nyb2xsVG9wL2QpO3RoaXMuY29udGFpbmVyLnNjcm9sbExlZnQ9MDt0aGlzLmNvbnRhaW5lci5zY3JvbGxUb3A9MH1pZihudWxsIT10aGlzLm1vdXNlTGlzdGVuZXJzKWZvcihkPVtjLGJdLGIuZ2V0RXZlbnQoKS5wcmV2ZW50RGVmYXVsdHx8KGIuZ2V0RXZlbnQoKS5yZXR1cm5WYWx1ZT0hMCksZT0wO2U8dGhpcy5tb3VzZUxpc3RlbmVycy5sZW5ndGg7ZSsrKXt2YXIgZj10aGlzLm1vdXNlTGlzdGVuZXJzW2VdO2E9PW14RXZlbnQuTU9VU0VfRE9XTj9mLm1vdXNlRG93bi5hcHBseShmLGQpOmE9PW14RXZlbnQuTU9VU0VfTU9WRT9mLm1vdXNlTW92ZS5hcHBseShmLGQpOmE9PW14RXZlbnQuTU9VU0VfVVAmJmYubW91c2VVcC5hcHBseShmLGQpfWE9PW14RXZlbnQuTU9VU0VfVVAmJnRoaXMuY2xpY2soYil9KG14RXZlbnQuaXNUb3VjaEV2ZW50KGIuZ2V0RXZlbnQoKSl8fG14RXZlbnQuaXNQZW5FdmVudChiLmdldEV2ZW50KCkpKSYmYT09bXhFdmVudC5NT1VTRV9ET1dOJiYKdGhpcy50YXBBbmRIb2xkRW5hYmxlZCYmIXRoaXMudGFwQW5kSG9sZEluUHJvZ3Jlc3M/KHRoaXMudGFwQW5kSG9sZEluUHJvZ3Jlc3M9ITAsdGhpcy5pbml0aWFsVG91Y2hYPWIuZ2V0R3JhcGhYKCksdGhpcy5pbml0aWFsVG91Y2hZPWIuZ2V0R3JhcGhZKCksdGhpcy50YXBBbmRIb2xkVGhyZWFkJiZ3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMudGFwQW5kSG9sZFRocmVhZCksdGhpcy50YXBBbmRIb2xkVGhyZWFkPXdpbmRvdy5zZXRUaW1lb3V0KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy50YXBBbmRIb2xkVmFsaWQmJnRoaXMudGFwQW5kSG9sZChiKTt0aGlzLnRhcEFuZEhvbGRWYWxpZD10aGlzLnRhcEFuZEhvbGRJblByb2dyZXNzPSExfSksdGhpcy50YXBBbmRIb2xkRGVsYXkpLHRoaXMudGFwQW5kSG9sZFZhbGlkPSEwKTphPT1teEV2ZW50Lk1PVVNFX1VQP3RoaXMudGFwQW5kSG9sZFZhbGlkPXRoaXMudGFwQW5kSG9sZEluUHJvZ3Jlc3M9ITE6dGhpcy50YXBBbmRIb2xkVmFsaWQmJgoodGhpcy50YXBBbmRIb2xkVmFsaWQ9TWF0aC5hYnModGhpcy5pbml0aWFsVG91Y2hYLWIuZ2V0R3JhcGhYKCkpPHRoaXMudG9sZXJhbmNlJiZNYXRoLmFicyh0aGlzLmluaXRpYWxUb3VjaFktYi5nZXRHcmFwaFkoKSk8dGhpcy50b2xlcmFuY2UpO2E9PW14RXZlbnQuTU9VU0VfRE9XTiYmdGhpcy5pc0VkaXRpbmcoKSYmIXRoaXMuY2VsbEVkaXRvci5pc0V2ZW50U291cmNlKGIuZ2V0RXZlbnQoKSkmJnRoaXMuc3RvcEVkaXRpbmcoIXRoaXMuaXNJbnZva2VzU3RvcENlbGxFZGl0aW5nKCkpO3RoaXMuY29uc3VtZU1vdXNlRXZlbnQoYSxiLGMpfX19O214R3JhcGgucHJvdG90eXBlLmNvbnN1bWVNb3VzZUV2ZW50PWZ1bmN0aW9uKGEsYixjKXthPT1teEV2ZW50Lk1PVVNFX0RPV04mJm14RXZlbnQuaXNUb3VjaEV2ZW50KGIuZ2V0RXZlbnQoKSkmJmIuY29uc3VtZSghMSl9OwpteEdyYXBoLnByb3RvdHlwZS5maXJlR2VzdHVyZUV2ZW50PWZ1bmN0aW9uKGEsYil7dGhpcy5sYXN0VG91Y2hUaW1lPTA7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5HRVNUVVJFLCJldmVudCIsYSwiY2VsbCIsYikpfTsKbXhHcmFwaC5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZGVzdHJveWVkfHwodGhpcy5kZXN0cm95ZWQ9ITAsbnVsbCE9dGhpcy50b29sdGlwSGFuZGxlciYmdGhpcy50b29sdGlwSGFuZGxlci5kZXN0cm95KCksbnVsbCE9dGhpcy5zZWxlY3Rpb25DZWxsc0hhbmRsZXImJnRoaXMuc2VsZWN0aW9uQ2VsbHNIYW5kbGVyLmRlc3Ryb3koKSxudWxsIT10aGlzLnBhbm5pbmdIYW5kbGVyJiZ0aGlzLnBhbm5pbmdIYW5kbGVyLmRlc3Ryb3koKSxudWxsIT10aGlzLnBvcHVwTWVudUhhbmRsZXImJnRoaXMucG9wdXBNZW51SGFuZGxlci5kZXN0cm95KCksbnVsbCE9dGhpcy5jb25uZWN0aW9uSGFuZGxlciYmdGhpcy5jb25uZWN0aW9uSGFuZGxlci5kZXN0cm95KCksbnVsbCE9dGhpcy5ncmFwaEhhbmRsZXImJnRoaXMuZ3JhcGhIYW5kbGVyLmRlc3Ryb3koKSxudWxsIT10aGlzLmNlbGxFZGl0b3ImJnRoaXMuY2VsbEVkaXRvci5kZXN0cm95KCksbnVsbCE9dGhpcy52aWV3JiZ0aGlzLnZpZXcuZGVzdHJveSgpLApudWxsIT10aGlzLm1vZGVsJiZudWxsIT10aGlzLmdyYXBoTW9kZWxDaGFuZ2VMaXN0ZW5lciYmKHRoaXMubW9kZWwucmVtb3ZlTGlzdGVuZXIodGhpcy5ncmFwaE1vZGVsQ2hhbmdlTGlzdGVuZXIpLHRoaXMuZ3JhcGhNb2RlbENoYW5nZUxpc3RlbmVyPW51bGwpLHRoaXMuY29udGFpbmVyPW51bGwpfTtmdW5jdGlvbiBteENlbGxPdmVybGF5KGEsYixjLGQsZSxmKXt0aGlzLmltYWdlPWE7dGhpcy50b29sdGlwPWI7dGhpcy5hbGlnbj1udWxsIT1jP2M6dGhpcy5hbGlnbjt0aGlzLnZlcnRpY2FsQWxpZ249bnVsbCE9ZD9kOnRoaXMudmVydGljYWxBbGlnbjt0aGlzLm9mZnNldD1udWxsIT1lP2U6bmV3IG14UG9pbnQ7dGhpcy5jdXJzb3I9bnVsbCE9Zj9mOiJoZWxwIn1teENlbGxPdmVybGF5LnByb3RvdHlwZT1uZXcgbXhFdmVudFNvdXJjZTtteENlbGxPdmVybGF5LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1teENlbGxPdmVybGF5O214Q2VsbE92ZXJsYXkucHJvdG90eXBlLmltYWdlPW51bGw7Cm14Q2VsbE92ZXJsYXkucHJvdG90eXBlLnRvb2x0aXA9bnVsbDtteENlbGxPdmVybGF5LnByb3RvdHlwZS5hbGlnbj1teENvbnN0YW50cy5BTElHTl9SSUdIVDtteENlbGxPdmVybGF5LnByb3RvdHlwZS52ZXJ0aWNhbEFsaWduPW14Q29uc3RhbnRzLkFMSUdOX0JPVFRPTTtteENlbGxPdmVybGF5LnByb3RvdHlwZS5vZmZzZXQ9bnVsbDtteENlbGxPdmVybGF5LnByb3RvdHlwZS5jdXJzb3I9bnVsbDtteENlbGxPdmVybGF5LnByb3RvdHlwZS5kZWZhdWx0T3ZlcmxhcD0uNTsKbXhDZWxsT3ZlcmxheS5wcm90b3R5cGUuZ2V0Qm91bmRzPWZ1bmN0aW9uKGEpe3ZhciBiPWEudmlldy5ncmFwaC5nZXRNb2RlbCgpLmlzRWRnZShhLmNlbGwpLGM9YS52aWV3LnNjYWxlLGQ9dGhpcy5pbWFnZS53aWR0aCxlPXRoaXMuaW1hZ2UuaGVpZ2h0O2lmKGIpaWYoYj1hLmFic29sdXRlUG9pbnRzLDE9PWIubGVuZ3RoJTIpYj1iW01hdGguZmxvb3IoYi5sZW5ndGgvMildO2Vsc2V7dmFyIGY9Yi5sZW5ndGgvMjthPWJbZi0xXTtiPWJbZl07Yj1uZXcgbXhQb2ludChhLngrKGIueC1hLngpLzIsYS55KyhiLnktYS55KS8yKX1lbHNlIGI9bmV3IG14UG9pbnQsYi54PXRoaXMuYWxpZ249PW14Q29uc3RhbnRzLkFMSUdOX0xFRlQ/YS54OnRoaXMuYWxpZ249PW14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUj9hLngrYS53aWR0aC8yOmEueCthLndpZHRoLGIueT10aGlzLnZlcnRpY2FsQWxpZ249PW14Q29uc3RhbnRzLkFMSUdOX1RPUD9hLnk6dGhpcy52ZXJ0aWNhbEFsaWduPT1teENvbnN0YW50cy5BTElHTl9NSURETEU/CmEueSthLmhlaWdodC8yOmEueSthLmhlaWdodDtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKE1hdGgucm91bmQoYi54LShkKnRoaXMuZGVmYXVsdE92ZXJsYXAtdGhpcy5vZmZzZXQueCkqYyksTWF0aC5yb3VuZChiLnktKGUqdGhpcy5kZWZhdWx0T3ZlcmxhcC10aGlzLm9mZnNldC55KSpjKSxkKmMsZSpjKX07bXhDZWxsT3ZlcmxheS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b29sdGlwfTtmdW5jdGlvbiBteE91dGxpbmUoYSxiKXt0aGlzLnNvdXJjZT1hO251bGwhPWImJnRoaXMuaW5pdChiKX1teE91dGxpbmUucHJvdG90eXBlLnNvdXJjZT1udWxsO214T3V0bGluZS5wcm90b3R5cGUub3V0bGluZT1udWxsO214T3V0bGluZS5wcm90b3R5cGUuZ3JhcGhSZW5kZXJIaW50PW14Q29uc3RhbnRzLlJFTkRFUklOR19ISU5UX0ZBU1RFUjtteE91dGxpbmUucHJvdG90eXBlLmVuYWJsZWQ9ITA7bXhPdXRsaW5lLnByb3RvdHlwZS5zaG93Vmlld3BvcnQ9ITA7Cm14T3V0bGluZS5wcm90b3R5cGUuYm9yZGVyPTEwO214T3V0bGluZS5wcm90b3R5cGUuc2l6ZXJTaXplPTg7bXhPdXRsaW5lLnByb3RvdHlwZS5sYWJlbHNWaXNpYmxlPSExO214T3V0bGluZS5wcm90b3R5cGUudXBkYXRlT25QYW49ITE7bXhPdXRsaW5lLnByb3RvdHlwZS5zaXplckltYWdlPW51bGw7bXhPdXRsaW5lLnByb3RvdHlwZS5taW5TY2FsZT0xRS00O214T3V0bGluZS5wcm90b3R5cGUuc3VzcGVuZGVkPSExO214T3V0bGluZS5wcm90b3R5cGUuZm9yY2VWbWxIYW5kbGVzPTg9PWRvY3VtZW50LmRvY3VtZW50TW9kZTtteE91dGxpbmUucHJvdG90eXBlLmNyZWF0ZUdyYXBoPWZ1bmN0aW9uKGEpe2E9bmV3IG14R3JhcGgoYSx0aGlzLnNvdXJjZS5nZXRNb2RlbCgpLHRoaXMuZ3JhcGhSZW5kZXJIaW50LHRoaXMuc291cmNlLmdldFN0eWxlc2hlZXQoKSk7YS5mb2xkaW5nRW5hYmxlZD0hMTthLmF1dG9TY3JvbGw9ITE7cmV0dXJuIGF9OwpteE91dGxpbmUucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oYSl7dGhpcy5vdXRsaW5lPXRoaXMuY3JlYXRlR3JhcGgoYSk7dmFyIGI9dGhpcy5vdXRsaW5lLmdyYXBoTW9kZWxDaGFuZ2VkO3RoaXMub3V0bGluZS5ncmFwaE1vZGVsQ2hhbmdlZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLnN1c3BlbmRlZHx8bnVsbD09dGhpcy5vdXRsaW5lfHxiLmFwcGx5KHRoaXMub3V0bGluZSxhcmd1bWVudHMpfSk7bXhDbGllbnQuSVNfU1ZHJiYoYT10aGlzLm91dGxpbmUuZ2V0VmlldygpLmdldENhbnZhcygpLnBhcmVudE5vZGUsYS5zZXRBdHRyaWJ1dGUoInNoYXBlLXJlbmRlcmluZyIsIm9wdGltaXplU3BlZWQiKSxhLnNldEF0dHJpYnV0ZSgiaW1hZ2UtcmVuZGVyaW5nIiwib3B0aW1pemVTcGVlZCIpKTt0aGlzLm91dGxpbmUubGFiZWxzVmlzaWJsZT10aGlzLmxhYmVsc1Zpc2libGU7dGhpcy5vdXRsaW5lLnNldEVuYWJsZWQoITEpO3RoaXMudXBkYXRlSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcywKZnVuY3Rpb24oYSxiKXt0aGlzLnN1c3BlbmRlZHx8dGhpcy5hY3RpdmV8fHRoaXMudXBkYXRlKCl9KTt0aGlzLnNvdXJjZS5nZXRNb2RlbCgpLmFkZExpc3RlbmVyKG14RXZlbnQuQ0hBTkdFLHRoaXMudXBkYXRlSGFuZGxlcik7dGhpcy5vdXRsaW5lLmFkZE1vdXNlTGlzdGVuZXIodGhpcyk7YT10aGlzLnNvdXJjZS5nZXRWaWV3KCk7YS5hZGRMaXN0ZW5lcihteEV2ZW50LlNDQUxFLHRoaXMudXBkYXRlSGFuZGxlcik7YS5hZGRMaXN0ZW5lcihteEV2ZW50LlRSQU5TTEFURSx0aGlzLnVwZGF0ZUhhbmRsZXIpO2EuYWRkTGlzdGVuZXIobXhFdmVudC5TQ0FMRV9BTkRfVFJBTlNMQVRFLHRoaXMudXBkYXRlSGFuZGxlcik7YS5hZGRMaXN0ZW5lcihteEV2ZW50LkRPV04sdGhpcy51cGRhdGVIYW5kbGVyKTthLmFkZExpc3RlbmVyKG14RXZlbnQuVVAsdGhpcy51cGRhdGVIYW5kbGVyKTtteEV2ZW50LmFkZExpc3RlbmVyKHRoaXMuc291cmNlLmNvbnRhaW5lciwic2Nyb2xsIix0aGlzLnVwZGF0ZUhhbmRsZXIpOwp0aGlzLnBhbkhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy51cGRhdGVPblBhbiYmdGhpcy51cGRhdGVIYW5kbGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pO3RoaXMuc291cmNlLmFkZExpc3RlbmVyKG14RXZlbnQuUEFOLHRoaXMucGFuSGFuZGxlcik7dGhpcy5yZWZyZXNoSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLm91dGxpbmUuc2V0U3R5bGVzaGVldCh0aGlzLnNvdXJjZS5nZXRTdHlsZXNoZWV0KCkpO3RoaXMub3V0bGluZS5yZWZyZXNoKCl9KTt0aGlzLnNvdXJjZS5hZGRMaXN0ZW5lcihteEV2ZW50LlJFRlJFU0gsdGhpcy5yZWZyZXNoSGFuZGxlcik7dGhpcy5ib3VuZHM9bmV3IG14UmVjdGFuZ2xlKDAsMCwwLDApO3RoaXMuc2VsZWN0aW9uQm9yZGVyPW5ldyBteFJlY3RhbmdsZVNoYXBlKHRoaXMuYm91bmRzLG51bGwsbXhDb25zdGFudHMuT1VUTElORV9DT0xPUixteENvbnN0YW50cy5PVVRMSU5FX1NUUk9LRVdJRFRIKTsKdGhpcy5zZWxlY3Rpb25Cb3JkZXIuZGlhbGVjdD10aGlzLm91dGxpbmUuZGlhbGVjdDt0aGlzLmZvcmNlVm1sSGFuZGxlcyYmKHRoaXMuc2VsZWN0aW9uQm9yZGVyLmlzSHRtbEFsbG93ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX0pO3RoaXMuc2VsZWN0aW9uQm9yZGVyLmluaXQodGhpcy5vdXRsaW5lLmdldFZpZXcoKS5nZXRPdmVybGF5UGFuZSgpKTthPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBiPW14RXZlbnQuZ2V0U291cmNlKGEpLGM9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5vdXRsaW5lLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfTU9WRSxuZXcgbXhNb3VzZUV2ZW50KGEpKX0pLGY9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bXhFdmVudC5yZW1vdmVHZXN0dXJlTGlzdGVuZXJzKGIsbnVsbCxjLGYpO3RoaXMub3V0bGluZS5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX1VQLG5ldyBteE1vdXNlRXZlbnQoYSkpfSk7Cm14RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyhiLG51bGwsYyxmKTt0aGlzLm91dGxpbmUuZmlyZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9ET1dOLG5ldyBteE1vdXNlRXZlbnQoYSkpfSk7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKHRoaXMuc2VsZWN0aW9uQm9yZGVyLm5vZGUsYSk7dGhpcy5zaXplcj10aGlzLmNyZWF0ZVNpemVyKCk7dGhpcy5mb3JjZVZtbEhhbmRsZXMmJih0aGlzLnNpemVyLmlzSHRtbEFsbG93ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX0pO3RoaXMuc2l6ZXIuaW5pdCh0aGlzLm91dGxpbmUuZ2V0VmlldygpLmdldE92ZXJsYXlQYW5lKCkpO3RoaXMuZW5hYmxlZCYmKHRoaXMuc2l6ZXIubm9kZS5zdHlsZS5jdXJzb3I9Im53c2UtcmVzaXplIik7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKHRoaXMuc2l6ZXIubm9kZSxhKTt0aGlzLnNlbGVjdGlvbkJvcmRlci5ub2RlLnN0eWxlLmRpc3BsYXk9dGhpcy5zaG93Vmlld3BvcnQ/IiI6Im5vbmUiO3RoaXMuc2l6ZXIubm9kZS5zdHlsZS5kaXNwbGF5PQp0aGlzLnNlbGVjdGlvbkJvcmRlci5ub2RlLnN0eWxlLmRpc3BsYXk7dGhpcy5zZWxlY3Rpb25Cb3JkZXIubm9kZS5zdHlsZS5jdXJzb3I9Im1vdmUiO3RoaXMudXBkYXRlKCExKX07bXhPdXRsaW5lLnByb3RvdHlwZS5pc0VuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbmFibGVkfTtteE91dGxpbmUucHJvdG90eXBlLnNldEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5lbmFibGVkPWF9O214T3V0bGluZS5wcm90b3R5cGUuc2V0Wm9vbUVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5zaXplci5ub2RlLnN0eWxlLnZpc2liaWxpdHk9YT8idmlzaWJsZSI6ImhpZGRlbiJ9O214T3V0bGluZS5wcm90b3R5cGUucmVmcmVzaD1mdW5jdGlvbigpe3RoaXMudXBkYXRlKCEwKX07Cm14T3V0bGluZS5wcm90b3R5cGUuY3JlYXRlU2l6ZXI9ZnVuY3Rpb24oKXt2YXIgYT1udWxsIT10aGlzLnNpemVySW1hZ2U/bmV3IG14SW1hZ2VTaGFwZShuZXcgbXhSZWN0YW5nbGUoMCwwLHRoaXMuc2l6ZXJJbWFnZS53aWR0aCx0aGlzLnNpemVySW1hZ2UuaGVpZ2h0KSx0aGlzLnNpemVySW1hZ2Uuc3JjKTpuZXcgbXhSZWN0YW5nbGVTaGFwZShuZXcgbXhSZWN0YW5nbGUoMCwwLHRoaXMuc2l6ZXJTaXplLHRoaXMuc2l6ZXJTaXplKSxteENvbnN0YW50cy5PVVRMSU5FX0hBTkRMRV9GSUxMQ09MT1IsbXhDb25zdGFudHMuT1VUTElORV9IQU5ETEVfU1RST0tFQ09MT1IpO2EuZGlhbGVjdD10aGlzLm91dGxpbmUuZGlhbGVjdDtyZXR1cm4gYX07bXhPdXRsaW5lLnByb3RvdHlwZS5nZXRTb3VyY2VDb250YWluZXJTaXplPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBteFJlY3RhbmdsZSgwLDAsdGhpcy5zb3VyY2UuY29udGFpbmVyLnNjcm9sbFdpZHRoLHRoaXMuc291cmNlLmNvbnRhaW5lci5zY3JvbGxIZWlnaHQpfTsKbXhPdXRsaW5lLnByb3RvdHlwZS5nZXRPdXRsaW5lT2Zmc2V0PWZ1bmN0aW9uKGEpe3JldHVybiBudWxsfTtteE91dGxpbmUucHJvdG90eXBlLmdldFNvdXJjZUdyYXBoQm91bmRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc291cmNlLmdldEdyYXBoQm91bmRzKCl9OwpteE91dGxpbmUucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihhKXtpZihudWxsIT10aGlzLnNvdXJjZSYmbnVsbCE9dGhpcy5zb3VyY2UuY29udGFpbmVyJiZudWxsIT10aGlzLm91dGxpbmUmJm51bGwhPXRoaXMub3V0bGluZS5jb250YWluZXIpe3ZhciBiPXRoaXMuc291cmNlLnZpZXcuc2NhbGUsYz10aGlzLmdldFNvdXJjZUdyYXBoQm91bmRzKCksYz1uZXcgbXhSZWN0YW5nbGUoYy54L2IrdGhpcy5zb3VyY2UucGFuRHgsYy55L2IrdGhpcy5zb3VyY2UucGFuRHksYy53aWR0aC9iLGMuaGVpZ2h0L2IpLGQ9bmV3IG14UmVjdGFuZ2xlKDAsMCx0aGlzLnNvdXJjZS5jb250YWluZXIuY2xpZW50V2lkdGgvYix0aGlzLnNvdXJjZS5jb250YWluZXIuY2xpZW50SGVpZ2h0L2IpLGU9Yy5jbG9uZSgpO2UuYWRkKGQpO2Q9dGhpcy5nZXRTb3VyY2VDb250YWluZXJTaXplKCk7Yj1NYXRoLm1pbihNYXRoLm1heCgwLHRoaXMub3V0bGluZS5jb250YWluZXIuY2xpZW50V2lkdGgtdGhpcy5ib3JkZXIpLwpNYXRoLm1heChkLndpZHRoL2IsZS53aWR0aCksTWF0aC5tYXgoMCx0aGlzLm91dGxpbmUuY29udGFpbmVyLmNsaWVudEhlaWdodC10aGlzLmJvcmRlcikvTWF0aC5tYXgoZC5oZWlnaHQvYixlLmhlaWdodCkpO2Q9aXNOYU4oYik/dGhpcy5taW5TY2FsZTpNYXRoLm1heCh0aGlzLm1pblNjYWxlLGIpO2lmKDA8ZCl7dGhpcy5vdXRsaW5lLmdldFZpZXcoKS5zY2FsZSE9ZCYmKHRoaXMub3V0bGluZS5nZXRWaWV3KCkuc2NhbGU9ZCxhPSEwKTtiPXRoaXMub3V0bGluZS5nZXRWaWV3KCk7Yi5jdXJyZW50Um9vdCE9dGhpcy5zb3VyY2UuZ2V0VmlldygpLmN1cnJlbnRSb290JiZiLnNldEN1cnJlbnRSb290KHRoaXMuc291cmNlLmdldFZpZXcoKS5jdXJyZW50Um9vdCk7dmFyIGU9dGhpcy5zb3VyY2Uudmlldy50cmFuc2xhdGUsZj1lLngrdGhpcy5zb3VyY2UucGFuRHgsZz1lLnkrdGhpcy5zb3VyY2UucGFuRHksZD10aGlzLmdldE91dGxpbmVPZmZzZXQoZCk7bnVsbCE9ZCYmKGYrPWQueCwKZys9ZC55KTswPmMueCYmKGYtPWMueCk7MD5jLnkmJihnLT1jLnkpO2lmKGIudHJhbnNsYXRlLnghPWZ8fGIudHJhbnNsYXRlLnkhPWcpYi50cmFuc2xhdGUueD1mLGIudHJhbnNsYXRlLnk9ZyxhPSEwO3ZhciBjPWIudHJhbnNsYXRlLGQ9dGhpcy5zb3VyY2UuZ2V0VmlldygpLnNjYWxlLGY9ZC9iLnNjYWxlLGc9MS9iLnNjYWxlLGs9dGhpcy5zb3VyY2UuY29udGFpbmVyO3RoaXMuYm91bmRzPW5ldyBteFJlY3RhbmdsZSgoYy54LWUueC10aGlzLnNvdXJjZS5wYW5EeCkvZywoYy55LWUueS10aGlzLnNvdXJjZS5wYW5EeSkvZyxrLmNsaWVudFdpZHRoL2Ysay5jbGllbnRIZWlnaHQvZik7dGhpcy5ib3VuZHMueCs9dGhpcy5zb3VyY2UuY29udGFpbmVyLnNjcm9sbExlZnQqYi5zY2FsZS9kO3RoaXMuYm91bmRzLnkrPXRoaXMuc291cmNlLmNvbnRhaW5lci5zY3JvbGxUb3AqYi5zY2FsZS9kO2M9dGhpcy5zZWxlY3Rpb25Cb3JkZXIuYm91bmRzO2lmKGMueCE9dGhpcy5ib3VuZHMueHx8CmMueSE9dGhpcy5ib3VuZHMueXx8Yy53aWR0aCE9dGhpcy5ib3VuZHMud2lkdGh8fGMuaGVpZ2h0IT10aGlzLmJvdW5kcy5oZWlnaHQpdGhpcy5zZWxlY3Rpb25Cb3JkZXIuYm91bmRzPXRoaXMuYm91bmRzLHRoaXMuc2VsZWN0aW9uQm9yZGVyLnJlZHJhdygpO2M9dGhpcy5zaXplci5ib3VuZHM7Yj1uZXcgbXhSZWN0YW5nbGUodGhpcy5ib3VuZHMueCt0aGlzLmJvdW5kcy53aWR0aC1jLndpZHRoLzIsdGhpcy5ib3VuZHMueSt0aGlzLmJvdW5kcy5oZWlnaHQtYy5oZWlnaHQvMixjLndpZHRoLGMuaGVpZ2h0KTtpZihjLnghPWIueHx8Yy55IT1iLnl8fGMud2lkdGghPWIud2lkdGh8fGMuaGVpZ2h0IT1iLmhlaWdodCl0aGlzLnNpemVyLmJvdW5kcz1iLCJoaWRkZW4iIT10aGlzLnNpemVyLm5vZGUuc3R5bGUudmlzaWJpbGl0eSYmdGhpcy5zaXplci5yZWRyYXcoKTthJiZ0aGlzLm91dGxpbmUudmlldy5yZXZhbGlkYXRlKCl9fX07Cm14T3V0bGluZS5wcm90b3R5cGUubW91c2VEb3duPWZ1bmN0aW9uKGEsYil7aWYodGhpcy5lbmFibGVkJiZ0aGlzLnNob3dWaWV3cG9ydCl7dmFyIGM9bXhFdmVudC5pc01vdXNlRXZlbnQoYi5nZXRFdmVudCgpKT8wOnRoaXMuc291cmNlLnRvbGVyYW5jZSxjPXRoaXMuc291cmNlLmFsbG93SGFuZGxlQm91bmRzQ2hlY2smJihteENsaWVudC5JU19JRXx8MDxjKT9uZXcgbXhSZWN0YW5nbGUoYi5nZXRHcmFwaFgoKS1jLGIuZ2V0R3JhcGhZKCktYywyKmMsMipjKTpudWxsO3RoaXMuem9vbT1iLmlzU291cmNlKHRoaXMuc2l6ZXIpfHxudWxsIT1jJiZteFV0aWxzLmludGVyc2VjdHMoc2hhcGUuYm91bmRzLGMpO3RoaXMuc3RhcnRYPWIuZ2V0WCgpO3RoaXMuc3RhcnRZPWIuZ2V0WSgpO3RoaXMuYWN0aXZlPSEwO3RoaXMuc291cmNlLnVzZVNjcm9sbGJhcnNGb3JQYW5uaW5nJiZteFV0aWxzLmhhc1Njcm9sbGJhcnModGhpcy5zb3VyY2UuY29udGFpbmVyKT8odGhpcy5keDA9dGhpcy5zb3VyY2UuY29udGFpbmVyLnNjcm9sbExlZnQsCnRoaXMuZHkwPXRoaXMuc291cmNlLmNvbnRhaW5lci5zY3JvbGxUb3ApOnRoaXMuZHkwPXRoaXMuZHgwPTB9Yi5jb25zdW1lKCl9OwpteE91dGxpbmUucHJvdG90eXBlLm1vdXNlTW92ZT1mdW5jdGlvbihhLGIpe2lmKHRoaXMuYWN0aXZlKXt0aGlzLnNlbGVjdGlvbkJvcmRlci5ub2RlLnN0eWxlLmRpc3BsYXk9dGhpcy5zaG93Vmlld3BvcnQ/IiI6Im5vbmUiO3RoaXMuc2l6ZXIubm9kZS5zdHlsZS5kaXNwbGF5PXRoaXMuc2VsZWN0aW9uQm9yZGVyLm5vZGUuc3R5bGUuZGlzcGxheTt2YXIgYz10aGlzLmdldFRyYW5zbGF0ZUZvckV2ZW50KGIpLGQ9Yy54LGU9Yy55O2lmKHRoaXMuem9vbSljPXRoaXMuc291cmNlLmNvbnRhaW5lcixlPWQvKGMuY2xpZW50V2lkdGgvYy5jbGllbnRIZWlnaHQpLGM9bmV3IG14UmVjdGFuZ2xlKHRoaXMuYm91bmRzLngsdGhpcy5ib3VuZHMueSxNYXRoLm1heCgxLHRoaXMuYm91bmRzLndpZHRoK2QpLE1hdGgubWF4KDEsdGhpcy5ib3VuZHMuaGVpZ2h0K2UpKSx0aGlzLnNlbGVjdGlvbkJvcmRlci5ib3VuZHM9Yyx0aGlzLnNlbGVjdGlvbkJvcmRlci5yZWRyYXcoKTtlbHNle3ZhciBmPXRoaXMub3V0bGluZS5nZXRWaWV3KCkuc2NhbGUsCmM9bmV3IG14UmVjdGFuZ2xlKHRoaXMuYm91bmRzLngrZCx0aGlzLmJvdW5kcy55K2UsdGhpcy5ib3VuZHMud2lkdGgsdGhpcy5ib3VuZHMuaGVpZ2h0KTt0aGlzLnNlbGVjdGlvbkJvcmRlci5ib3VuZHM9Yzt0aGlzLnNlbGVjdGlvbkJvcmRlci5yZWRyYXcoKTtkPWQvZip0aGlzLnNvdXJjZS5nZXRWaWV3KCkuc2NhbGU7ZT1lL2YqdGhpcy5zb3VyY2UuZ2V0VmlldygpLnNjYWxlO3RoaXMuc291cmNlLnBhbkdyYXBoKC1kLXRoaXMuZHgwLC1lLXRoaXMuZHkwKX1kPXRoaXMuc2l6ZXIuYm91bmRzO3RoaXMuc2l6ZXIuYm91bmRzPW5ldyBteFJlY3RhbmdsZShjLngrYy53aWR0aC1kLndpZHRoLzIsYy55K2MuaGVpZ2h0LWQuaGVpZ2h0LzIsZC53aWR0aCxkLmhlaWdodCk7ImhpZGRlbiIhPXRoaXMuc2l6ZXIubm9kZS5zdHlsZS52aXNpYmlsaXR5JiZ0aGlzLnNpemVyLnJlZHJhdygpO2IuY29uc3VtZSgpfX07Cm14T3V0bGluZS5wcm90b3R5cGUuZ2V0VHJhbnNsYXRlRm9yRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBteFBvaW50KGEuZ2V0WCgpLXRoaXMuc3RhcnRYLGEuZ2V0WSgpLXRoaXMuc3RhcnRZKX07Cm14T3V0bGluZS5wcm90b3R5cGUubW91c2VVcD1mdW5jdGlvbihhLGIpe2lmKHRoaXMuYWN0aXZlKXt2YXIgYz10aGlzLmdldFRyYW5zbGF0ZUZvckV2ZW50KGIpLGQ9Yy54LGM9Yy55O2lmKDA8TWF0aC5hYnMoZCl8fDA8TWF0aC5hYnMoYykpe2lmKHRoaXMuem9vbSl7dmFyIGM9dGhpcy5zZWxlY3Rpb25Cb3JkZXIuYm91bmRzLndpZHRoLGU9dGhpcy5zb3VyY2UuZ2V0VmlldygpLnNjYWxlO3RoaXMuc291cmNlLnpvb21UbyhNYXRoLm1heCh0aGlzLm1pblNjYWxlLGUtZCplL2MpLCExKX1lbHNlIHRoaXMuc291cmNlLnVzZVNjcm9sbGJhcnNGb3JQYW5uaW5nJiZteFV0aWxzLmhhc1Njcm9sbGJhcnModGhpcy5zb3VyY2UuY29udGFpbmVyKXx8KHRoaXMuc291cmNlLnBhbkdyYXBoKDAsMCksZC89dGhpcy5vdXRsaW5lLmdldFZpZXcoKS5zY2FsZSxjLz10aGlzLm91dGxpbmUuZ2V0VmlldygpLnNjYWxlLGU9dGhpcy5zb3VyY2UuZ2V0VmlldygpLnRyYW5zbGF0ZSx0aGlzLnNvdXJjZS5nZXRWaWV3KCkuc2V0VHJhbnNsYXRlKGUueC0KZCxlLnktYykpO3RoaXMudXBkYXRlKCk7Yi5jb25zdW1lKCl9dGhpcy5pbmRleD1udWxsO3RoaXMuYWN0aXZlPSExfX07Cm14T3V0bGluZS5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe251bGwhPXRoaXMuc291cmNlJiYodGhpcy5zb3VyY2UucmVtb3ZlTGlzdGVuZXIodGhpcy5wYW5IYW5kbGVyKSx0aGlzLnNvdXJjZS5yZW1vdmVMaXN0ZW5lcih0aGlzLnJlZnJlc2hIYW5kbGVyKSx0aGlzLnNvdXJjZS5nZXRNb2RlbCgpLnJlbW92ZUxpc3RlbmVyKHRoaXMudXBkYXRlSGFuZGxlciksdGhpcy5zb3VyY2UuZ2V0VmlldygpLnJlbW92ZUxpc3RlbmVyKHRoaXMudXBkYXRlSGFuZGxlciksbXhFdmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLnNvdXJjZS5jb250YWluZXIsInNjcm9sbCIsdGhpcy51cGRhdGVIYW5kbGVyKSx0aGlzLnNvdXJjZT1udWxsKTtudWxsIT10aGlzLm91dGxpbmUmJih0aGlzLm91dGxpbmUucmVtb3ZlTW91c2VMaXN0ZW5lcih0aGlzKSx0aGlzLm91dGxpbmUuZGVzdHJveSgpLHRoaXMub3V0bGluZT1udWxsKTtudWxsIT10aGlzLnNlbGVjdGlvbkJvcmRlciYmKHRoaXMuc2VsZWN0aW9uQm9yZGVyLmRlc3Ryb3koKSwKdGhpcy5zZWxlY3Rpb25Cb3JkZXI9bnVsbCk7bnVsbCE9dGhpcy5zaXplciYmKHRoaXMuc2l6ZXIuZGVzdHJveSgpLHRoaXMuc2l6ZXI9bnVsbCl9O2Z1bmN0aW9uIG14TXVsdGlwbGljaXR5KGEsYixjLGQsZSxmLGcsayxsLG0pe3RoaXMuc291cmNlPWE7dGhpcy50eXBlPWI7dGhpcy5hdHRyPWM7dGhpcy52YWx1ZT1kO3RoaXMubWluPW51bGwhPWU/ZTowO3RoaXMubWF4PW51bGwhPWY/ZjoibiI7dGhpcy52YWxpZE5laWdoYm9ycz1nO3RoaXMuY291bnRFcnJvcj1teFJlc291cmNlcy5nZXQoayl8fGs7dGhpcy50eXBlRXJyb3I9bXhSZXNvdXJjZXMuZ2V0KGwpfHxsO3RoaXMudmFsaWROZWlnaGJvcnNBbGxvd2VkPW51bGwhPW0/bTohMH1teE11bHRpcGxpY2l0eS5wcm90b3R5cGUudHlwZT1udWxsO214TXVsdGlwbGljaXR5LnByb3RvdHlwZS5hdHRyPW51bGw7bXhNdWx0aXBsaWNpdHkucHJvdG90eXBlLnZhbHVlPW51bGw7bXhNdWx0aXBsaWNpdHkucHJvdG90eXBlLnNvdXJjZT1udWxsOwpteE11bHRpcGxpY2l0eS5wcm90b3R5cGUubWluPW51bGw7bXhNdWx0aXBsaWNpdHkucHJvdG90eXBlLm1heD1udWxsO214TXVsdGlwbGljaXR5LnByb3RvdHlwZS52YWxpZE5laWdoYm9ycz1udWxsO214TXVsdGlwbGljaXR5LnByb3RvdHlwZS52YWxpZE5laWdoYm9yc0FsbG93ZWQ9ITA7bXhNdWx0aXBsaWNpdHkucHJvdG90eXBlLmNvdW50RXJyb3I9bnVsbDtteE11bHRpcGxpY2l0eS5wcm90b3R5cGUudHlwZUVycm9yPW51bGw7Cm14TXVsdGlwbGljaXR5LnByb3RvdHlwZS5jaGVjaz1mdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGc9IiI7aWYodGhpcy5zb3VyY2UmJnRoaXMuY2hlY2tUZXJtaW5hbChhLGMsYil8fCF0aGlzLnNvdXJjZSYmdGhpcy5jaGVja1Rlcm1pbmFsKGEsZCxiKSludWxsIT10aGlzLmNvdW50RXJyb3ImJih0aGlzLnNvdXJjZSYmKDA9PXRoaXMubWF4fHxlPj10aGlzLm1heCl8fCF0aGlzLnNvdXJjZSYmKDA9PXRoaXMubWF4fHxmPj10aGlzLm1heCkpJiYoZys9dGhpcy5jb3VudEVycm9yKyJcbiIpLG51bGwhPXRoaXMudmFsaWROZWlnaGJvcnMmJm51bGwhPXRoaXMudHlwZUVycm9yJiYwPHRoaXMudmFsaWROZWlnaGJvcnMubGVuZ3RoJiYodGhpcy5jaGVja05laWdoYm9ycyhhLGIsYyxkKXx8KGcrPXRoaXMudHlwZUVycm9yKyJcbiIpKTtyZXR1cm4gMDxnLmxlbmd0aD9nOm51bGx9OwpteE11bHRpcGxpY2l0eS5wcm90b3R5cGUuY2hlY2tOZWlnaGJvcnM9ZnVuY3Rpb24oYSxiLGMsZCl7Yj1hLm1vZGVsLmdldFZhbHVlKGMpO2Q9YS5tb2RlbC5nZXRWYWx1ZShkKTtjPSF0aGlzLnZhbGlkTmVpZ2hib3JzQWxsb3dlZDtmb3IodmFyIGU9dGhpcy52YWxpZE5laWdoYm9ycyxmPTA7ZjxlLmxlbmd0aDtmKyspaWYodGhpcy5zb3VyY2UmJnRoaXMuY2hlY2tUeXBlKGEsZCxlW2ZdKSl7Yz10aGlzLnZhbGlkTmVpZ2hib3JzQWxsb3dlZDticmVha31lbHNlIGlmKCF0aGlzLnNvdXJjZSYmdGhpcy5jaGVja1R5cGUoYSxiLGVbZl0pKXtjPXRoaXMudmFsaWROZWlnaGJvcnNBbGxvd2VkO2JyZWFrfXJldHVybiBjfTtteE11bHRpcGxpY2l0eS5wcm90b3R5cGUuY2hlY2tUZXJtaW5hbD1mdW5jdGlvbihhLGIsYyl7Yj1hLm1vZGVsLmdldFZhbHVlKGIpO3JldHVybiB0aGlzLmNoZWNrVHlwZShhLGIsdGhpcy50eXBlLHRoaXMuYXR0cix0aGlzLnZhbHVlKX07Cm14TXVsdGlwbGljaXR5LnByb3RvdHlwZS5jaGVja1R5cGU9ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gbnVsbCE9Yj9pc05hTihiLm5vZGVUeXBlKT9iPT1jOm14VXRpbHMuaXNOb2RlKGIsYyxkLGUpOiExfTsKZnVuY3Rpb24gbXhMYXlvdXRNYW5hZ2VyKGEpe3RoaXMudW5kb0hhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXt0aGlzLmlzRW5hYmxlZCgpJiZ0aGlzLmJlZm9yZVVuZG8oYy5nZXRQcm9wZXJ0eSgiZWRpdCIpKX0pO3RoaXMubW92ZUhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXt0aGlzLmlzRW5hYmxlZCgpJiZ0aGlzLmNlbGxzTW92ZWQoYy5nZXRQcm9wZXJ0eSgiY2VsbHMiKSxjLmdldFByb3BlcnR5KCJldmVudCIpKX0pO3RoaXMucmVzaXplSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGMpe3RoaXMuaXNFbmFibGVkKCkmJnRoaXMuY2VsbHNSZXNpemVkKGMuZ2V0UHJvcGVydHkoImNlbGxzIiksYy5nZXRQcm9wZXJ0eSgiYm91bmRzIiksYy5nZXRQcm9wZXJ0eSgicHJldmlvdXMiKSl9KTt0aGlzLnNldEdyYXBoKGEpfW14TGF5b3V0TWFuYWdlci5wcm90b3R5cGU9bmV3IG14RXZlbnRTb3VyY2U7Cm14TGF5b3V0TWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhMYXlvdXRNYW5hZ2VyO214TGF5b3V0TWFuYWdlci5wcm90b3R5cGUuZ3JhcGg9bnVsbDtteExheW91dE1hbmFnZXIucHJvdG90eXBlLmJ1YmJsaW5nPSEwO214TGF5b3V0TWFuYWdlci5wcm90b3R5cGUuZW5hYmxlZD0hMDtteExheW91dE1hbmFnZXIucHJvdG90eXBlLnVuZG9IYW5kbGVyPW51bGw7bXhMYXlvdXRNYW5hZ2VyLnByb3RvdHlwZS5tb3ZlSGFuZGxlcj1udWxsO214TGF5b3V0TWFuYWdlci5wcm90b3R5cGUucmVzaXplSGFuZGxlcj1udWxsO214TGF5b3V0TWFuYWdlci5wcm90b3R5cGUuaXNFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5hYmxlZH07bXhMYXlvdXRNYW5hZ2VyLnByb3RvdHlwZS5zZXRFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuZW5hYmxlZD1hfTtteExheW91dE1hbmFnZXIucHJvdG90eXBlLmlzQnViYmxpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5idWJibGluZ307Cm14TGF5b3V0TWFuYWdlci5wcm90b3R5cGUuc2V0QnViYmxpbmc9ZnVuY3Rpb24oYSl7dGhpcy5idWJibGluZz1hfTtteExheW91dE1hbmFnZXIucHJvdG90eXBlLmdldEdyYXBoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ3JhcGh9OwpteExheW91dE1hbmFnZXIucHJvdG90eXBlLnNldEdyYXBoPWZ1bmN0aW9uKGEpe2lmKG51bGwhPXRoaXMuZ3JhcGgpe3ZhciBiPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKTtiLnJlbW92ZUxpc3RlbmVyKHRoaXMudW5kb0hhbmRsZXIpO3RoaXMuZ3JhcGgucmVtb3ZlTGlzdGVuZXIodGhpcy5tb3ZlSGFuZGxlcik7dGhpcy5ncmFwaC5yZW1vdmVMaXN0ZW5lcih0aGlzLnJlc2l6ZUhhbmRsZXIpfXRoaXMuZ3JhcGg9YTtudWxsIT10aGlzLmdyYXBoJiYoYj10aGlzLmdyYXBoLmdldE1vZGVsKCksYi5hZGRMaXN0ZW5lcihteEV2ZW50LkJFRk9SRV9VTkRPLHRoaXMudW5kb0hhbmRsZXIpLHRoaXMuZ3JhcGguYWRkTGlzdGVuZXIobXhFdmVudC5NT1ZFX0NFTExTLHRoaXMubW92ZUhhbmRsZXIpLHRoaXMuZ3JhcGguYWRkTGlzdGVuZXIobXhFdmVudC5SRVNJWkVfQ0VMTFMsdGhpcy5yZXNpemVIYW5kbGVyKSl9OwpteExheW91dE1hbmFnZXIucHJvdG90eXBlLmhhc0xheW91dD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5nZXRMYXlvdXQoYSxteEV2ZW50LkxBWU9VVF9DRUxMUyl9O214TGF5b3V0TWFuYWdlci5wcm90b3R5cGUuZ2V0TGF5b3V0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIG51bGx9O214TGF5b3V0TWFuYWdlci5wcm90b3R5cGUuYmVmb3JlVW5kbz1mdW5jdGlvbihhKXt0aGlzLmV4ZWN1dGVMYXlvdXRGb3JDZWxscyh0aGlzLmdldENlbGxzRm9yQ2hhbmdlcyhhLmNoYW5nZXMpKX07Cm14TGF5b3V0TWFuYWdlci5wcm90b3R5cGUuY2VsbHNNb3ZlZD1mdW5jdGlvbihhLGIpe2lmKG51bGwhPWEmJm51bGwhPWIpZm9yKHZhciBjPW14VXRpbHMuY29udmVydFBvaW50KHRoaXMuZ2V0R3JhcGgoKS5jb250YWluZXIsbXhFdmVudC5nZXRDbGllbnRYKGIpLG14RXZlbnQuZ2V0Q2xpZW50WShiKSksZD0wO2Q8YS5sZW5ndGg7ZCsrKXt2YXIgZT10aGlzLmdldEFuY2VzdG9yTGF5b3V0KGFbZF0sbXhFdmVudC5NT1ZFX0NFTExTKTtudWxsIT1lJiZlLm1vdmVDZWxsKGFbZF0sYy54LGMueSl9fTtteExheW91dE1hbmFnZXIucHJvdG90eXBlLmNlbGxzUmVzaXplZD1mdW5jdGlvbihhLGIsYyl7aWYobnVsbCE9YSYmbnVsbCE9Yilmb3IodmFyIGQ9MDtkPGEubGVuZ3RoO2QrKyl7dmFyIGU9dGhpcy5nZXRBbmNlc3RvckxheW91dChhW2RdLG14RXZlbnQuUkVTSVpFX0NFTExTKTtudWxsIT1lJiZlLnJlc2l6ZUNlbGwoYVtkXSxiW2RdLGNbZF0pfX07Cm14TGF5b3V0TWFuYWdlci5wcm90b3R5cGUuZ2V0QW5jZXN0b3JMYXlvdXQ9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9dGhpcy5nZXRHcmFwaCgpLmdldE1vZGVsKCk7bnVsbCE9YTspe3ZhciBkPXRoaXMuZ2V0TGF5b3V0KGEsYik7aWYobnVsbCE9ZClyZXR1cm4gZDthPWMuZ2V0UGFyZW50KGEpfXJldHVybiBudWxsfTtteExheW91dE1hbmFnZXIucHJvdG90eXBlLmdldENlbGxzRm9yQ2hhbmdlcz1mdW5jdGlvbihhKXtmb3IodmFyIGI9W10sYz0wO2M8YS5sZW5ndGg7YysrKXt2YXIgZD1hW2NdO2lmKGQgaW5zdGFuY2VvZiBteFJvb3RDaGFuZ2UpcmV0dXJuW107Yj1iLmNvbmNhdCh0aGlzLmdldENlbGxzRm9yQ2hhbmdlKGQpKX1yZXR1cm4gYn07Cm14TGF5b3V0TWFuYWdlci5wcm90b3R5cGUuZ2V0Q2VsbHNGb3JDaGFuZ2U9ZnVuY3Rpb24oYSl7cmV0dXJuIGEgaW5zdGFuY2VvZiBteENoaWxkQ2hhbmdlP3RoaXMuYWRkQ2VsbHNXaXRoTGF5b3V0KGEuY2hpbGQsdGhpcy5hZGRDZWxsc1dpdGhMYXlvdXQoYS5wcmV2aW91cykpOmEgaW5zdGFuY2VvZiBteFRlcm1pbmFsQ2hhbmdlfHxhIGluc3RhbmNlb2YgbXhHZW9tZXRyeUNoYW5nZXx8YSBpbnN0YW5jZW9mIG14VmlzaWJsZUNoYW5nZXx8YSBpbnN0YW5jZW9mIG14U3R5bGVDaGFuZ2U/dGhpcy5hZGRDZWxsc1dpdGhMYXlvdXQoYS5jZWxsKTpbXX07bXhMYXlvdXRNYW5hZ2VyLnByb3RvdHlwZS5hZGRDZWxsc1dpdGhMYXlvdXQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5hZGREZXNjZW5kYW50c1dpdGhMYXlvdXQoYSx0aGlzLmFkZEFuY2VzdG9yc1dpdGhMYXlvdXQoYSxiKSl9OwpteExheW91dE1hbmFnZXIucHJvdG90eXBlLmFkZEFuY2VzdG9yc1dpdGhMYXlvdXQ9ZnVuY3Rpb24oYSxiKXtiPW51bGwhPWI/YjpbXTtpZihudWxsIT1hJiYobnVsbCE9dGhpcy5oYXNMYXlvdXQoYSkmJmIucHVzaChhKSx0aGlzLmlzQnViYmxpbmcoKSkpe3ZhciBjPXRoaXMuZ2V0R3JhcGgoKS5nZXRNb2RlbCgpO3RoaXMuYWRkQW5jZXN0b3JzV2l0aExheW91dChjLmdldFBhcmVudChhKSxiKX1yZXR1cm4gYn07bXhMYXlvdXRNYW5hZ2VyLnByb3RvdHlwZS5hZGREZXNjZW5kYW50c1dpdGhMYXlvdXQ9ZnVuY3Rpb24oYSxiKXtiPW51bGwhPWI/YjpbXTtpZihudWxsIT1hJiZ0aGlzLmhhc0xheW91dChhKSlmb3IodmFyIGM9dGhpcy5nZXRHcmFwaCgpLmdldE1vZGVsKCksZD0wO2Q8Yy5nZXRDaGlsZENvdW50KGEpO2QrKyl7dmFyIGU9Yy5nZXRDaGlsZEF0KGEsZCk7dGhpcy5oYXNMYXlvdXQoZSkmJihiLnB1c2goZSksdGhpcy5hZGREZXNjZW5kYW50c1dpdGhMYXlvdXQoZSxiKSl9cmV0dXJuIGJ9OwpteExheW91dE1hbmFnZXIucHJvdG90eXBlLmV4ZWN1dGVMYXlvdXRGb3JDZWxscz1mdW5jdGlvbihhKXthPW14VXRpbHMuc29ydENlbGxzKGEsITEpO3RoaXMubGF5b3V0Q2VsbHMoYSwhMCk7dGhpcy5sYXlvdXRDZWxscyhhLnJldmVyc2UoKSwhMSl9O214TGF5b3V0TWFuYWdlci5wcm90b3R5cGUubGF5b3V0Q2VsbHM9ZnVuY3Rpb24oYSxiKXtpZigwPGEubGVuZ3RoKXt2YXIgYz10aGlzLmdldEdyYXBoKCkuZ2V0TW9kZWwoKTtjLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgZD1udWxsLGU9MDtlPGEubGVuZ3RoO2UrKylhW2VdIT1jLmdldFJvb3QoKSYmYVtlXSE9ZCYmKHRoaXMuZXhlY3V0ZUxheW91dChhW2VdLGIpLGQ9YVtlXSk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5MQVlPVVRfQ0VMTFMsImNlbGxzIixhKSl9ZmluYWxseXtjLmVuZFVwZGF0ZSgpfX19OwpteExheW91dE1hbmFnZXIucHJvdG90eXBlLmV4ZWN1dGVMYXlvdXQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdldExheW91dChhLGI/bXhFdmVudC5CRUdJTl9VUERBVEU6bXhFdmVudC5FTkRfVVBEQVRFKTtudWxsIT1jJiZjLmV4ZWN1dGUoYSl9O214TGF5b3V0TWFuYWdlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuc2V0R3JhcGgobnVsbCl9OwpmdW5jdGlvbiBteFN3aW1sYW5lTWFuYWdlcihhLGIsYyxkKXt0aGlzLmhvcml6b250YWw9bnVsbCE9Yj9iOiEwO3RoaXMuYWRkRW5hYmxlZD1udWxsIT1jP2M6ITA7dGhpcy5yZXNpemVFbmFibGVkPW51bGwhPWQ/ZDohMDt0aGlzLmFkZEhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiKXt0aGlzLmlzRW5hYmxlZCgpJiZ0aGlzLmlzQWRkRW5hYmxlZCgpJiZ0aGlzLmNlbGxzQWRkZWQoYi5nZXRQcm9wZXJ0eSgiY2VsbHMiKSl9KTt0aGlzLnJlc2l6ZUhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiKXt0aGlzLmlzRW5hYmxlZCgpJiZ0aGlzLmlzUmVzaXplRW5hYmxlZCgpJiZ0aGlzLmNlbGxzUmVzaXplZChiLmdldFByb3BlcnR5KCJjZWxscyIpKX0pO3RoaXMuc2V0R3JhcGgoYSl9bXhTd2ltbGFuZU1hbmFnZXIucHJvdG90eXBlPW5ldyBteEV2ZW50U291cmNlO214U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1teFN3aW1sYW5lTWFuYWdlcjsKbXhTd2ltbGFuZU1hbmFnZXIucHJvdG90eXBlLmdyYXBoPW51bGw7bXhTd2ltbGFuZU1hbmFnZXIucHJvdG90eXBlLmVuYWJsZWQ9ITA7bXhTd2ltbGFuZU1hbmFnZXIucHJvdG90eXBlLmhvcml6b250YWw9ITA7bXhTd2ltbGFuZU1hbmFnZXIucHJvdG90eXBlLmFkZEVuYWJsZWQ9ITA7bXhTd2ltbGFuZU1hbmFnZXIucHJvdG90eXBlLnJlc2l6ZUVuYWJsZWQ9ITA7bXhTd2ltbGFuZU1hbmFnZXIucHJvdG90eXBlLmFkZEhhbmRsZXI9bnVsbDtteFN3aW1sYW5lTWFuYWdlci5wcm90b3R5cGUucmVzaXplSGFuZGxlcj1udWxsO214U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZS5pc0VuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbmFibGVkfTtteFN3aW1sYW5lTWFuYWdlci5wcm90b3R5cGUuc2V0RW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLmVuYWJsZWQ9YX07bXhTd2ltbGFuZU1hbmFnZXIucHJvdG90eXBlLmlzSG9yaXpvbnRhbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhvcml6b250YWx9OwpteFN3aW1sYW5lTWFuYWdlci5wcm90b3R5cGUuc2V0SG9yaXpvbnRhbD1mdW5jdGlvbihhKXt0aGlzLmhvcml6b250YWw9YX07bXhTd2ltbGFuZU1hbmFnZXIucHJvdG90eXBlLmlzQWRkRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFkZEVuYWJsZWR9O214U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZS5zZXRBZGRFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuYWRkRW5hYmxlZD1hfTtteFN3aW1sYW5lTWFuYWdlci5wcm90b3R5cGUuaXNSZXNpemVFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVzaXplRW5hYmxlZH07bXhTd2ltbGFuZU1hbmFnZXIucHJvdG90eXBlLnNldFJlc2l6ZUVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5yZXNpemVFbmFibGVkPWF9O214U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZS5nZXRHcmFwaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdyYXBofTsKbXhTd2ltbGFuZU1hbmFnZXIucHJvdG90eXBlLnNldEdyYXBoPWZ1bmN0aW9uKGEpe251bGwhPXRoaXMuZ3JhcGgmJih0aGlzLmdyYXBoLnJlbW92ZUxpc3RlbmVyKHRoaXMuYWRkSGFuZGxlciksdGhpcy5ncmFwaC5yZW1vdmVMaXN0ZW5lcih0aGlzLnJlc2l6ZUhhbmRsZXIpKTt0aGlzLmdyYXBoPWE7bnVsbCE9dGhpcy5ncmFwaCYmKHRoaXMuZ3JhcGguYWRkTGlzdGVuZXIobXhFdmVudC5BRERfQ0VMTFMsdGhpcy5hZGRIYW5kbGVyKSx0aGlzLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuQ0VMTFNfUkVTSVpFRCx0aGlzLnJlc2l6ZUhhbmRsZXIpKX07bXhTd2ltbGFuZU1hbmFnZXIucHJvdG90eXBlLmlzU3dpbWxhbmVJZ25vcmVkPWZ1bmN0aW9uKGEpe3JldHVybiF0aGlzLmdldEdyYXBoKCkuaXNTd2ltbGFuZShhKX07Cm14U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZS5pc0NlbGxIb3Jpem9udGFsPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdyYXBoLmlzU3dpbWxhbmUoYSk/KGE9dGhpcy5ncmFwaC5nZXRDZWxsU3R5bGUoYSksMT09bXhVdGlscy5nZXRWYWx1ZShhLG14Q29uc3RhbnRzLlNUWUxFX0hPUklaT05UQUwsMSkpOiF0aGlzLmlzSG9yaXpvbnRhbCgpfTtteFN3aW1sYW5lTWFuYWdlci5wcm90b3R5cGUuY2VsbHNBZGRlZD1mdW5jdGlvbihhKXtpZihudWxsIT1hKXt2YXIgYj10aGlzLmdldEdyYXBoKCkuZ2V0TW9kZWwoKTtiLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKXRoaXMuaXNTd2ltbGFuZUlnbm9yZWQoYVtjXSl8fHRoaXMuc3dpbWxhbmVBZGRlZChhW2NdKX1maW5hbGx5e2IuZW5kVXBkYXRlKCl9fX07Cm14U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZS5zd2ltbGFuZUFkZGVkPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj10aGlzLmdldEdyYXBoKCkuZ2V0TW9kZWwoKSxjPWIuZ2V0UGFyZW50KGEpLGQ9Yi5nZXRDaGlsZENvdW50KGMpLGU9bnVsbCxmPTA7ZjxkO2YrKyl7dmFyIGc9Yi5nZXRDaGlsZEF0KGMsZik7aWYoZyE9YSYmIXRoaXMuaXNTd2ltbGFuZUlnbm9yZWQoZykmJihlPWIuZ2V0R2VvbWV0cnkoZyksbnVsbCE9ZSkpYnJlYWt9bnVsbCE9ZSYmKGI9bnVsbCE9Yz90aGlzLmlzQ2VsbEhvcml6b250YWwoYyk6dGhpcy5ob3Jpem9udGFsLHRoaXMucmVzaXplU3dpbWxhbmUoYSxlLndpZHRoLGUuaGVpZ2h0LGIpKX07Cm14U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZS5jZWxsc1Jlc2l6ZWQ9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSl7dmFyIGI9dGhpcy5nZXRHcmFwaCgpLmdldE1vZGVsKCk7Yi5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKylpZighdGhpcy5pc1N3aW1sYW5lSWdub3JlZChhW2NdKSl7dmFyIGQ9Yi5nZXRHZW9tZXRyeShhW2NdKTtpZihudWxsIT1kKXtmb3IodmFyIGU9bmV3IG14UmVjdGFuZ2xlKDAsMCxkLndpZHRoLGQuaGVpZ2h0KSxmPWFbY10sZz1mO251bGwhPWc7KXt2YXIgZj1nLGc9Yi5nZXRQYXJlbnQoZyksaz10aGlzLmdyYXBoLmlzU3dpbWxhbmUoZyk/dGhpcy5ncmFwaC5nZXRTdGFydFNpemUoZyk6bmV3IG14UmVjdGFuZ2xlO2Uud2lkdGgrPWsud2lkdGg7ZS5oZWlnaHQrPWsuaGVpZ2h0fXZhciBsPW51bGwhPWc/dGhpcy5pc0NlbGxIb3Jpem9udGFsKGcpOnRoaXMuaG9yaXpvbnRhbDt0aGlzLnJlc2l6ZVN3aW1sYW5lKGYsZS53aWR0aCwKZS5oZWlnaHQsbCl9fX1maW5hbGx5e2IuZW5kVXBkYXRlKCl9fX07Cm14U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZS5yZXNpemVTd2ltbGFuZT1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLmdldEdyYXBoKCkuZ2V0TW9kZWwoKTtlLmJlZ2luVXBkYXRlKCk7dHJ5e3ZhciBmPXRoaXMuaXNDZWxsSG9yaXpvbnRhbChhKTtpZighdGhpcy5pc1N3aW1sYW5lSWdub3JlZChhKSl7dmFyIGc9ZS5nZXRHZW9tZXRyeShhKTtudWxsIT1nJiYoZCYmZy5oZWlnaHQhPWN8fCFkJiZnLndpZHRoIT1iKSYmKGc9Zy5jbG9uZSgpLGQ/Zy5oZWlnaHQ9YzpnLndpZHRoPWIsZS5zZXRHZW9tZXRyeShhLGcpKX12YXIgaz10aGlzLmdyYXBoLmlzU3dpbWxhbmUoYSk/dGhpcy5ncmFwaC5nZXRTdGFydFNpemUoYSk6bmV3IG14UmVjdGFuZ2xlO2ItPWsud2lkdGg7Yy09ay5oZWlnaHQ7dmFyIGw9ZS5nZXRDaGlsZENvdW50KGEpO2ZvcihkPTA7ZDxsO2QrKyl7dmFyIG09ZS5nZXRDaGlsZEF0KGEsZCk7dGhpcy5yZXNpemVTd2ltbGFuZShtLGIsYyxmKX19ZmluYWxseXtlLmVuZFVwZGF0ZSgpfX07Cm14U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5zZXRHcmFwaChudWxsKX07CmZ1bmN0aW9uIG14VGVtcG9yYXJ5Q2VsbFN0YXRlcyhhLGIsYyxkLGUpe2I9bnVsbCE9Yj9iOjE7dGhpcy52aWV3PWE7dGhpcy5vbGRWYWxpZGF0ZUNlbGxTdGF0ZT1hLnZhbGlkYXRlQ2VsbFN0YXRlO3RoaXMub2xkQm91bmRzPWEuZ2V0R3JhcGhCb3VuZHMoKTt0aGlzLm9sZFN0YXRlcz1hLmdldFN0YXRlcygpO3RoaXMub2xkU2NhbGU9YS5nZXRTY2FsZSgpO3RoaXMub2xkRG9SZWRyYXdTaGFwZT1hLmdyYXBoLmNlbGxSZW5kZXJlci5kb1JlZHJhd1NoYXBlO3ZhciBmPXRoaXM7bnVsbCE9ZSYmKGEuZ3JhcGguY2VsbFJlbmRlcmVyLmRvUmVkcmF3U2hhcGU9ZnVuY3Rpb24oYil7dmFyIGM9Yi5zaGFwZS5wYWludDtiLnNoYXBlLnBhaW50PWZ1bmN0aW9uKGEpe3ZhciBkPWUoYik7bnVsbCE9ZCYmYS5zZXRMaW5rKGQpO2MuYXBwbHkodGhpcyxhcmd1bWVudHMpO251bGwhPWQmJmEuc2V0TGluayhudWxsKX07Zi5vbGREb1JlZHJhd1NoYXBlLmFwcGx5KGEuZ3JhcGguY2VsbFJlbmRlcmVyLAphcmd1bWVudHMpO2Iuc2hhcGUucGFpbnQ9Y30pO2EudmFsaWRhdGVDZWxsU3RhdGU9ZnVuY3Rpb24oYixjKXtyZXR1cm4gbnVsbD09Ynx8bnVsbD09ZHx8ZChiKT9mLm9sZFZhbGlkYXRlQ2VsbFN0YXRlLmFwcGx5KGEsYXJndW1lbnRzKTpudWxsfTthLnNldFN0YXRlcyhuZXcgbXhEaWN0aW9uYXJ5KTthLnNldFNjYWxlKGIpO2lmKG51bGwhPWMpe2EucmVzZXRWYWxpZGF0aW9uU3RhdGUoKTtiPW51bGw7Zm9yKHZhciBnPTA7ZzxjLmxlbmd0aDtnKyspe3ZhciBrPWEuZ2V0Qm91bmRpbmdCb3goYS52YWxpZGF0ZUNlbGxTdGF0ZShhLnZhbGlkYXRlQ2VsbChjW2ddKSkpO251bGw9PWI/Yj1rOmIuYWRkKGspfWEuc2V0R3JhcGhCb3VuZHMoYnx8bmV3IG14UmVjdGFuZ2xlKX19bXhUZW1wb3JhcnlDZWxsU3RhdGVzLnByb3RvdHlwZS52aWV3PW51bGw7bXhUZW1wb3JhcnlDZWxsU3RhdGVzLnByb3RvdHlwZS5vbGRTdGF0ZXM9bnVsbDsKbXhUZW1wb3JhcnlDZWxsU3RhdGVzLnByb3RvdHlwZS5vbGRCb3VuZHM9bnVsbDtteFRlbXBvcmFyeUNlbGxTdGF0ZXMucHJvdG90eXBlLm9sZFNjYWxlPW51bGw7bXhUZW1wb3JhcnlDZWxsU3RhdGVzLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy52aWV3LnNldFNjYWxlKHRoaXMub2xkU2NhbGUpO3RoaXMudmlldy5zZXRTdGF0ZXModGhpcy5vbGRTdGF0ZXMpO3RoaXMudmlldy5zZXRHcmFwaEJvdW5kcyh0aGlzLm9sZEJvdW5kcyk7dGhpcy52aWV3LnZhbGlkYXRlQ2VsbFN0YXRlPXRoaXMub2xkVmFsaWRhdGVDZWxsU3RhdGU7dGhpcy52aWV3LmdyYXBoLmNlbGxSZW5kZXJlci5kb1JlZHJhd1NoYXBlPXRoaXMub2xkRG9SZWRyYXdTaGFwZX07ZnVuY3Rpb24gbXhDZWxsU3RhdGVQcmV2aWV3KGEpe3RoaXMuZGVsdGFzPW5ldyBteERpY3Rpb25hcnk7dGhpcy5ncmFwaD1hfW14Q2VsbFN0YXRlUHJldmlldy5wcm90b3R5cGUuZ3JhcGg9bnVsbDsKbXhDZWxsU3RhdGVQcmV2aWV3LnByb3RvdHlwZS5kZWx0YXM9bnVsbDtteENlbGxTdGF0ZVByZXZpZXcucHJvdG90eXBlLmNvdW50PTA7bXhDZWxsU3RhdGVQcmV2aWV3LnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIDA9PXRoaXMuY291bnR9O214Q2VsbFN0YXRlUHJldmlldy5wcm90b3R5cGUubW92ZVN0YXRlPWZ1bmN0aW9uKGEsYixjLGQsZSl7ZD1udWxsIT1kP2Q6ITA7ZT1udWxsIT1lP2U6ITA7dmFyIGY9dGhpcy5kZWx0YXMuZ2V0KGEuY2VsbCk7bnVsbD09Zj8oZj17cG9pbnQ6bmV3IG14UG9pbnQoYixjKSxzdGF0ZTphfSx0aGlzLmRlbHRhcy5wdXQoYS5jZWxsLGYpLHRoaXMuY291bnQrKyk6ZD8oZi5wb2ludC54Kz1iLGYucG9pbnQueSs9Yyk6KGYucG9pbnQueD1iLGYucG9pbnQueT1jKTtlJiZ0aGlzLmFkZEVkZ2VzKGEpO3JldHVybiBmLnBvaW50fTsKbXhDZWxsU3RhdGVQcmV2aWV3LnByb3RvdHlwZS5zaG93PWZ1bmN0aW9uKGEpe3RoaXMuZGVsdGFzLnZpc2l0KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7dGhpcy50cmFuc2xhdGVTdGF0ZShjLnN0YXRlLGMucG9pbnQueCxjLnBvaW50LnkpfSkpO3RoaXMuZGVsdGFzLnZpc2l0KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIsYyl7dGhpcy5yZXZhbGlkYXRlU3RhdGUoYy5zdGF0ZSxjLnBvaW50LngsYy5wb2ludC55LGEpfSkpfTsKbXhDZWxsU3RhdGVQcmV2aWV3LnByb3RvdHlwZS50cmFuc2xhdGVTdGF0ZT1mdW5jdGlvbihhLGIsYyl7aWYobnVsbCE9YSl7dmFyIGQ9dGhpcy5ncmFwaC5nZXRNb2RlbCgpO2lmKGQuaXNWZXJ0ZXgoYS5jZWxsKSl7YS52aWV3LnVwZGF0ZUNlbGxTdGF0ZShhKTt2YXIgZT1kLmdldEdlb21ldHJ5KGEuY2VsbCk7MD09YiYmMD09Y3x8bnVsbD09ZXx8ZS5yZWxhdGl2ZSYmbnVsbD09dGhpcy5kZWx0YXMuZ2V0KGEuY2VsbCl8fChhLngrPWIsYS55Kz1jKX1mb3IodmFyIGU9ZC5nZXRDaGlsZENvdW50KGEuY2VsbCksZj0wO2Y8ZTtmKyspdGhpcy50cmFuc2xhdGVTdGF0ZShhLnZpZXcuZ2V0U3RhdGUoZC5nZXRDaGlsZEF0KGEuY2VsbCxmKSksYixjKX19OwpteENlbGxTdGF0ZVByZXZpZXcucHJvdG90eXBlLnJldmFsaWRhdGVTdGF0ZT1mdW5jdGlvbihhLGIsYyxkKXtpZihudWxsIT1hKXt2YXIgZT10aGlzLmdyYXBoLmdldE1vZGVsKCk7ZS5pc0VkZ2UoYS5jZWxsKSYmYS52aWV3LnVwZGF0ZUNlbGxTdGF0ZShhKTt2YXIgZj10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShhLmNlbGwpLGc9YS52aWV3LmdldFN0YXRlKGUuZ2V0UGFyZW50KGEuY2VsbCkpOzA9PWImJjA9PWN8fG51bGw9PWZ8fCFmLnJlbGF0aXZlfHwhZS5pc1ZlcnRleChhLmNlbGwpfHxudWxsIT1nJiYhZS5pc1ZlcnRleChnLmNlbGwpJiZudWxsPT10aGlzLmRlbHRhcy5nZXQoYS5jZWxsKXx8KGEueCs9YixhLnkrPWMpO3RoaXMuZ3JhcGguY2VsbFJlbmRlcmVyLnJlZHJhdyhhKTtudWxsIT1kJiZkKGEpO2Y9ZS5nZXRDaGlsZENvdW50KGEuY2VsbCk7Zm9yKGc9MDtnPGY7ZysrKXRoaXMucmV2YWxpZGF0ZVN0YXRlKHRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZShlLmdldENoaWxkQXQoYS5jZWxsLApnKSksYixjLGQpfX07bXhDZWxsU3RhdGVQcmV2aWV3LnByb3RvdHlwZS5hZGRFZGdlcz1mdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGM9Yi5nZXRFZGdlQ291bnQoYS5jZWxsKSxkPTA7ZDxjO2QrKyl7dmFyIGU9YS52aWV3LmdldFN0YXRlKGIuZ2V0RWRnZUF0KGEuY2VsbCxkKSk7bnVsbCE9ZSYmdGhpcy5tb3ZlU3RhdGUoZSwwLDApfX07ZnVuY3Rpb24gbXhDb25uZWN0aW9uQ29uc3RyYWludChhLGIsYyxkLGUpe3RoaXMucG9pbnQ9YTt0aGlzLnBlcmltZXRlcj1udWxsIT1iP2I6ITA7dGhpcy5uYW1lPWM7dGhpcy5keD1kP2Q6MDt0aGlzLmR5PWU/ZTowfW14Q29ubmVjdGlvbkNvbnN0cmFpbnQucHJvdG90eXBlLnBvaW50PW51bGw7bXhDb25uZWN0aW9uQ29uc3RyYWludC5wcm90b3R5cGUucGVyaW1ldGVyPW51bGw7bXhDb25uZWN0aW9uQ29uc3RyYWludC5wcm90b3R5cGUubmFtZT1udWxsOwpteENvbm5lY3Rpb25Db25zdHJhaW50LnByb3RvdHlwZS5keD1udWxsO214Q29ubmVjdGlvbkNvbnN0cmFpbnQucHJvdG90eXBlLmR5PW51bGw7CmZ1bmN0aW9uIG14R3JhcGhIYW5kbGVyKGEpe3RoaXMuZ3JhcGg9YTt0aGlzLmdyYXBoLmFkZE1vdXNlTGlzdGVuZXIodGhpcyk7dGhpcy5wYW5IYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5zdXNwZW5kZWR8fCh0aGlzLnVwZGF0ZVByZXZpZXcoKSx0aGlzLnVwZGF0ZUhpbnQoKSl9KTt0aGlzLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuUEFOLHRoaXMucGFuSGFuZGxlcik7dGhpcy5lc2NhcGVIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7dGhpcy5yZXNldCgpfSk7dGhpcy5ncmFwaC5hZGRMaXN0ZW5lcihteEV2ZW50LkVTQ0FQRSx0aGlzLmVzY2FwZUhhbmRsZXIpO3RoaXMucmVmcmVzaEhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXt3aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2lmKG51bGwhPXRoaXMuZmlyc3QmJiF0aGlzLnN1c3BlbmRlZCl7dmFyIGE9dGhpcy5jdXJyZW50RHgsCmI9dGhpcy5jdXJyZW50RHk7dGhpcy5jdXJyZW50RHk9dGhpcy5jdXJyZW50RHg9MDt0aGlzLnVwZGF0ZVByZXZpZXcoKTt0aGlzLmJvdW5kcz10aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRCb3VuZHModGhpcy5jZWxscyk7dGhpcy5wQm91bmRzPXRoaXMuZ2V0UHJldmlld0JvdW5kcyh0aGlzLmNlbGxzKTtudWxsPT10aGlzLnBCb3VuZHM/dGhpcy5yZXNldCgpOih0aGlzLmN1cnJlbnREeD1hLHRoaXMuY3VycmVudER5PWIsdGhpcy51cGRhdGVQcmV2aWV3KCksdGhpcy51cGRhdGVIaW50KCksdGhpcy5saXZlUHJldmlld1VzZWQmJnRoaXMuc2V0SGFuZGxlc1Zpc2libGVGb3JDZWxscyh0aGlzLmdyYXBoLnNlbGVjdGlvbkNlbGxzSGFuZGxlci5nZXRIYW5kbGVkU2VsZWN0aW9uQ2VsbHMoKSwhMSkpfX0pLDApfSk7dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmFkZExpc3RlbmVyKG14RXZlbnQuQ0hBTkdFLHRoaXMucmVmcmVzaEhhbmRsZXIpO3RoaXMua2V5SGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcywKZnVuY3Rpb24oYSl7bnVsbD09dGhpcy5ncmFwaC5jb250YWluZXJ8fCJoaWRkZW4iPT10aGlzLmdyYXBoLmNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5fHxudWxsPT10aGlzLmZpcnN0fHx0aGlzLnN1c3BlbmRlZHx8KGE9dGhpcy5ncmFwaC5pc0Nsb25lRXZlbnQoYSkmJnRoaXMuZ3JhcGguaXNDZWxsc0Nsb25lYWJsZSgpJiZ0aGlzLmlzQ2xvbmVFbmFibGVkKCksYSE9dGhpcy5jbG9uaW5nJiYodGhpcy5jbG9uaW5nPWEsdGhpcy5jaGVja1ByZXZpZXcoKSx0aGlzLnVwZGF0ZVByZXZpZXcoKSkpfSk7bXhFdmVudC5hZGRMaXN0ZW5lcihkb2N1bWVudCwia2V5ZG93biIsdGhpcy5rZXlIYW5kbGVyKTtteEV2ZW50LmFkZExpc3RlbmVyKGRvY3VtZW50LCJrZXl1cCIsdGhpcy5rZXlIYW5kbGVyKX1teEdyYXBoSGFuZGxlci5wcm90b3R5cGUuZ3JhcGg9bnVsbDtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUubWF4Q2VsbHM9bXhDbGllbnQuSVNfSUU/MjA6NTA7Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5lbmFibGVkPSEwO214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5oaWdobGlnaHRFbmFibGVkPSEwO214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5jbG9uZUVuYWJsZWQ9ITA7bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLm1vdmVFbmFibGVkPSEwO214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5ndWlkZXNFbmFibGVkPSExO214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVzVmlzaWJsZT0hMDtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuZ3VpZGU9bnVsbDtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuY3VycmVudER4PW51bGw7bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmN1cnJlbnREeT1udWxsO214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVDdXJzb3I9ITA7bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnNlbGVjdEVuYWJsZWQ9ITA7bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnJlbW92ZUNlbGxzRnJvbVBhcmVudD0hMDsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnJlbW92ZUVtcHR5UGFyZW50cz0hMTtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuY29ubmVjdE9uRHJvcD0hMTtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuc2Nyb2xsT25Nb3ZlPSEwO214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5taW5pbXVtU2l6ZT02O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5wcmV2aWV3Q29sb3I9ImJsYWNrIjtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuaHRtbFByZXZpZXc9ITE7bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnNoYXBlPW51bGw7bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnNjYWxlR3JpZD0hMTtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUucm90YXRpb25FbmFibGVkPSEwO214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5tYXhMaXZlUHJldmlldz0wO214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5hbGxvd0xpdmVQcmV2aWV3PW14Q2xpZW50LklTX1NWRzsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmlzRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuYWJsZWR9O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5zZXRFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuZW5hYmxlZD1hfTtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuaXNDbG9uZUVuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbG9uZUVuYWJsZWR9O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5zZXRDbG9uZUVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5jbG9uZUVuYWJsZWQ9YX07bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmlzTW92ZUVuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tb3ZlRW5hYmxlZH07bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnNldE1vdmVFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMubW92ZUVuYWJsZWQ9YX07bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmlzU2VsZWN0RW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNlbGVjdEVuYWJsZWR9OwpteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuc2V0U2VsZWN0RW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLnNlbGVjdEVuYWJsZWQ9YX07bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmlzUmVtb3ZlQ2VsbHNGcm9tUGFyZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVtb3ZlQ2VsbHNGcm9tUGFyZW50fTtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuc2V0UmVtb3ZlQ2VsbHNGcm9tUGFyZW50PWZ1bmN0aW9uKGEpe3RoaXMucmVtb3ZlQ2VsbHNGcm9tUGFyZW50PWF9OwpteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuaXNQcm9wYWdhdGVTZWxlY3Rpb25DZWxsPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLmdyYXBoLm1vZGVsLmdldFBhcmVudChhKTtyZXR1cm4gYj8oYj10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShhKSwhdGhpcy5ncmFwaC5tb2RlbC5pc0VkZ2UoYSkmJiF0aGlzLmdyYXBoLm1vZGVsLmlzRWRnZShkKSYmIXRoaXMuZ3JhcGguaXNTaWJsaW5nU2VsZWN0ZWQoYSkmJihudWxsPT1ifHxiLnJlbGF0aXZlfHwhdGhpcy5ncmFwaC5pc1N3aW1sYW5lKGQpKSk6KCF0aGlzLmdyYXBoLmlzVG9nZ2xlRXZlbnQoYy5nZXRFdmVudCgpKXx8IXRoaXMuZ3JhcGguaXNTaWJsaW5nU2VsZWN0ZWQoYSkmJiF0aGlzLmdyYXBoLmlzQ2VsbFNlbGVjdGVkKGEpJiYhdGhpcy5ncmFwaC5pc1N3aW1sYW5lKGQpfHx0aGlzLmdyYXBoLmlzQ2VsbFNlbGVjdGVkKGQpKSYmKHRoaXMuZ3JhcGguaXNUb2dnbGVFdmVudChjLmdldEV2ZW50KCkpfHwhdGhpcy5ncmFwaC5pc0NlbGxTZWxlY3RlZChkKSl9OwpteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuZ2V0SW5pdGlhbENlbGxGb3JFdmVudD1mdW5jdGlvbihhKXt2YXIgYj1hLmdldFN0YXRlKCk7aWYoISh0aGlzLmdyYXBoLmlzVG9nZ2xlRXZlbnQoYS5nZXRFdmVudCgpKSYmbXhFdmVudC5pc0FsdERvd24oYS5nZXRFdmVudCgpKXx8bnVsbD09Ynx8dGhpcy5ncmFwaC5pc0NlbGxTZWxlY3RlZChiLmNlbGwpKSlmb3IodmFyIGM9dGhpcy5ncmFwaC5tb2RlbCxkPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZShjLmdldFBhcmVudChiLmNlbGwpKTtudWxsIT1kJiYhdGhpcy5ncmFwaC5pc0NlbGxTZWxlY3RlZChkLmNlbGwpJiYoYy5pc1ZlcnRleChkLmNlbGwpfHxjLmlzRWRnZShkLmNlbGwpKSYmdGhpcy5pc1Byb3BhZ2F0ZVNlbGVjdGlvbkNlbGwoYi5jZWxsLCEwLGEpOyliPWQsZD10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUodGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldFBhcmVudChiLmNlbGwpKTtyZXR1cm4gbnVsbCE9Yj9iLmNlbGw6bnVsbH07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5pc0RlbGF5ZWRTZWxlY3Rpb249ZnVuY3Rpb24oYSxiKXtpZighdGhpcy5ncmFwaC5pc1RvZ2dsZUV2ZW50KGIuZ2V0RXZlbnQoKSl8fCFteEV2ZW50LmlzQWx0RG93bihiLmdldEV2ZW50KCkpKWZvcig7bnVsbCE9YTspe2lmKHRoaXMuZ3JhcGguc2VsZWN0aW9uQ2VsbHNIYW5kbGVyLmlzSGFuZGxlZChhKSlyZXR1cm4gdGhpcy5ncmFwaC5jZWxsRWRpdG9yLmdldEVkaXRpbmdDZWxsKCkhPWE7YT10aGlzLmdyYXBoLm1vZGVsLmdldFBhcmVudChhKX1yZXR1cm4gdGhpcy5ncmFwaC5pc1RvZ2dsZUV2ZW50KGIuZ2V0RXZlbnQoKSkmJiFteEV2ZW50LmlzQWx0RG93bihiLmdldEV2ZW50KCkpfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnNlbGVjdERlbGF5ZWQ9ZnVuY3Rpb24oYSl7aWYoIXRoaXMuZ3JhcGgucG9wdXBNZW51SGFuZGxlci5pc1BvcHVwVHJpZ2dlcihhKSl7dmFyIGI9YS5nZXRDZWxsKCk7bnVsbD09YiYmKGI9dGhpcy5jZWxsKTt2YXIgYz10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUoYik7aWYobnVsbCE9Yyl7aWYoIShhLmlzU291cmNlKGMuY29udHJvbCl8fHRoaXMuZ3JhcGguaXNUb2dnbGVFdmVudChhLmdldEV2ZW50KCkpJiZteEV2ZW50LmlzQWx0RG93bihhLmdldEV2ZW50KCkpKSlmb3IodmFyIGM9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGQ9Yy5nZXRQYXJlbnQoYik7bnVsbCE9dGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKGQpJiYoYy5pc1ZlcnRleChkKXx8Yy5pc0VkZ2UoZCkpJiZ0aGlzLmlzUHJvcGFnYXRlU2VsZWN0aW9uQ2VsbChiLCExLGEpOyliPWQsZD1jLmdldFBhcmVudChiKTt0aGlzLmdyYXBoLnNlbGVjdENlbGxGb3JFdmVudChiLGEuZ2V0RXZlbnQoKSl9fX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5jb25zdW1lTW91c2VFdmVudD1mdW5jdGlvbihhLGIpe2IuY29uc3VtZSgpfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLm1vdXNlRG93bj1mdW5jdGlvbihhLGIpe2lmKCFiLmlzQ29uc3VtZWQoKSYmdGhpcy5pc0VuYWJsZWQoKSYmdGhpcy5ncmFwaC5pc0VuYWJsZWQoKSYmbnVsbCE9Yi5nZXRTdGF0ZSgpJiYhbXhFdmVudC5pc011bHRpVG91Y2hFdmVudChiLmdldEV2ZW50KCkpKXt2YXIgYz10aGlzLmdldEluaXRpYWxDZWxsRm9yRXZlbnQoYik7dGhpcy5kZWxheWVkU2VsZWN0aW9uPXRoaXMuaXNEZWxheWVkU2VsZWN0aW9uKGMsYik7dGhpcy5jZWxsPW51bGw7dGhpcy5pc1NlbGVjdEVuYWJsZWQoKSYmIXRoaXMuZGVsYXllZFNlbGVjdGlvbiYmdGhpcy5ncmFwaC5zZWxlY3RDZWxsRm9yRXZlbnQoYyxiLmdldEV2ZW50KCkpO2lmKHRoaXMuaXNNb3ZlRW5hYmxlZCgpKXt2YXIgZD10aGlzLmdyYXBoLm1vZGVsLGU9ZC5nZXRHZW9tZXRyeShjKTt0aGlzLmdyYXBoLmlzQ2VsbE1vdmFibGUoYykmJighZC5pc0VkZ2UoYyl8fDE8dGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25Db3VudCgpfHwKbnVsbCE9ZS5wb2ludHMmJjA8ZS5wb2ludHMubGVuZ3RofHxudWxsPT1kLmdldFRlcm1pbmFsKGMsITApfHxudWxsPT1kLmdldFRlcm1pbmFsKGMsITEpfHx0aGlzLmdyYXBoLmFsbG93RGFuZ2xpbmdFZGdlc3x8dGhpcy5ncmFwaC5pc0Nsb25lRXZlbnQoYi5nZXRFdmVudCgpKSYmdGhpcy5ncmFwaC5pc0NlbGxzQ2xvbmVhYmxlKCkpP3RoaXMuc3RhcnQoYyxiLmdldFgoKSxiLmdldFkoKSk6dGhpcy5kZWxheWVkU2VsZWN0aW9uJiYodGhpcy5jZWxsPWMpO3RoaXMuY2VsbFdhc0NsaWNrZWQ9ITA7dGhpcy5jb25zdW1lTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX0RPV04sYil9fX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5nZXRHdWlkZVN0YXRlcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ3JhcGguZ2V0RGVmYXVsdFBhcmVudCgpLGI9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGM9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZShhKSYmYi5pc1ZlcnRleChhKSYmbnVsbCE9Yi5nZXRHZW9tZXRyeShhKSYmIWIuZ2V0R2VvbWV0cnkoYSkucmVsYXRpdmV9KTtyZXR1cm4gdGhpcy5ncmFwaC52aWV3LmdldENlbGxTdGF0ZXMoYi5maWx0ZXJEZXNjZW5kYW50cyhjLGEpKX07bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmdldENlbGxzPWZ1bmN0aW9uKGEpe3JldHVybiF0aGlzLmRlbGF5ZWRTZWxlY3Rpb24mJnRoaXMuZ3JhcGguaXNDZWxsTW92YWJsZShhKT9bYV06dGhpcy5ncmFwaC5nZXRNb3ZhYmxlQ2VsbHModGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25DZWxscygpKX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5nZXRQcmV2aWV3Qm91bmRzPWZ1bmN0aW9uKGEpe2E9dGhpcy5nZXRCb3VuZGluZ0JveChhKTtudWxsIT1hJiYoYS53aWR0aD1NYXRoLm1heCgwLGEud2lkdGgtMSksYS5oZWlnaHQ9TWF0aC5tYXgoMCxhLmhlaWdodC0xKSxhLndpZHRoPHRoaXMubWluaW11bVNpemU/KGEueC09KHRoaXMubWluaW11bVNpemUtYS53aWR0aCkvMixhLndpZHRoPXRoaXMubWluaW11bVNpemUpOihhLng9TWF0aC5yb3VuZChhLngpLGEud2lkdGg9TWF0aC5jZWlsKGEud2lkdGgpKSxhLmhlaWdodDx0aGlzLm1pbmltdW1TaXplPyhhLnktPSh0aGlzLm1pbmltdW1TaXplLWEuaGVpZ2h0KS8yLGEuaGVpZ2h0PXRoaXMubWluaW11bVNpemUpOihhLnk9TWF0aC5yb3VuZChhLnkpLGEuaGVpZ2h0PU1hdGguY2VpbChhLmhlaWdodCkpKTtyZXR1cm4gYX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveD1mdW5jdGlvbihhKXt2YXIgYj1udWxsO2lmKG51bGwhPWEmJjA8YS5sZW5ndGgpZm9yKHZhciBjPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxkPTA7ZDxhLmxlbmd0aDtkKyspaWYoYy5pc1ZlcnRleChhW2RdKXx8Yy5pc0VkZ2UoYVtkXSkpe3ZhciBlPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZShhW2RdKTtpZihudWxsIT1lKXt2YXIgZj1lO2MuaXNWZXJ0ZXgoYVtkXSkmJm51bGwhPWUuc2hhcGUmJm51bGwhPWUuc2hhcGUuYm91bmRpbmdCb3gmJihmPWUuc2hhcGUuYm91bmRpbmdCb3gpO251bGw9PWI/Yj1teFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlKGYpOmIuYWRkKGYpfX1yZXR1cm4gYn07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVQcmV2aWV3U2hhcGU9ZnVuY3Rpb24oYSl7YT1uZXcgbXhSZWN0YW5nbGVTaGFwZShhLG51bGwsdGhpcy5wcmV2aWV3Q29sb3IpO2EuaXNEYXNoZWQ9ITA7dGhpcy5odG1sUHJldmlldz8oYS5kaWFsZWN0PW14Q29uc3RhbnRzLkRJQUxFQ1RfU1RSSUNUSFRNTCxhLmluaXQodGhpcy5ncmFwaC5jb250YWluZXIpKTooYS5kaWFsZWN0PXRoaXMuZ3JhcGguZGlhbGVjdCE9bXhDb25zdGFudHMuRElBTEVDVF9TVkc/bXhDb25zdGFudHMuRElBTEVDVF9WTUw6bXhDb25zdGFudHMuRElBTEVDVF9TVkcsYS5pbml0KHRoaXMuZ3JhcGguZ2V0VmlldygpLmdldE92ZXJsYXlQYW5lKCkpLGEucG9pbnRlckV2ZW50cz0hMSxteENsaWVudC5JU19JT1MmJihhLmdldFN2Z1NjcmVlbk9mZnNldD1mdW5jdGlvbigpe3JldHVybiAwfSkpO3JldHVybiBhfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMuY2VsbD1hO3RoaXMuZmlyc3Q9bXhVdGlscy5jb252ZXJ0UG9pbnQodGhpcy5ncmFwaC5jb250YWluZXIsYixjKTt0aGlzLmNlbGxzPW51bGwhPWQ/ZDp0aGlzLmdldENlbGxzKHRoaXMuY2VsbCk7dGhpcy5ib3VuZHM9dGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0Qm91bmRzKHRoaXMuY2VsbHMpO3RoaXMucEJvdW5kcz10aGlzLmdldFByZXZpZXdCb3VuZHModGhpcy5jZWxscyk7dGhpcy5hbGxDZWxscz1uZXcgbXhEaWN0aW9uYXJ5O3RoaXMuY2xvbmluZz0hMTtmb3IoYj10aGlzLmNlbGxDb3VudD0wO2I8dGhpcy5jZWxscy5sZW5ndGg7YisrKXRoaXMuY2VsbENvdW50Kz10aGlzLmFkZFN0YXRlcyh0aGlzLmNlbGxzW2JdLHRoaXMuYWxsQ2VsbHMpO2lmKHRoaXMuZ3VpZGVzRW5hYmxlZCl7dGhpcy5ndWlkZT1uZXcgbXhHdWlkZSh0aGlzLmdyYXBoLHRoaXMuZ2V0R3VpZGVTdGF0ZXMoKSk7CnZhciBlPXRoaXMuZ3JhcGgubW9kZWwuZ2V0UGFyZW50KGEpLGY9Mj50aGlzLmdyYXBoLm1vZGVsLmdldENoaWxkQ291bnQoZSksZz1uZXcgbXhEaWN0aW9uYXJ5O2E9dGhpcy5ncmFwaC5nZXRPcHBvc2l0ZXModGhpcy5ncmFwaC5nZXRFZGdlcyh0aGlzLmNlbGwpLHRoaXMuY2VsbCk7Zm9yKGI9MDtiPGEubGVuZ3RoO2IrKyljPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZShhW2JdKSxudWxsPT1jfHxnLmdldChjKXx8Zy5wdXQoYywhMCk7dGhpcy5ndWlkZS5pc1N0YXRlSWdub3JlZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt2YXIgYj10aGlzLmdyYXBoLm1vZGVsLmdldFBhcmVudChhLmNlbGwpO3JldHVybiBudWxsIT1hLmNlbGwmJighdGhpcy5jbG9uaW5nJiZ0aGlzLmlzQ2VsbE1vdmluZyhhLmNlbGwpfHxhLmNlbGwhPSh0aGlzLnRhcmdldHx8ZSkmJiFmJiYhZy5nZXQoYSkmJihudWxsPT10aGlzLnRhcmdldHx8Mjw9dGhpcy5ncmFwaC5tb2RlbC5nZXRDaGlsZENvdW50KHRoaXMudGFyZ2V0KSkmJgpiIT0odGhpcy50YXJnZXR8fGUpKX0pfX07bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmFkZFN0YXRlcz1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZShhKSxkPTA7aWYobnVsbCE9YyYmbnVsbD09Yi5nZXQoYSkpe2IucHV0KGEsYyk7ZCsrO2Zvcih2YXIgYz10aGlzLmdyYXBoLm1vZGVsLmdldENoaWxkQ291bnQoYSksZT0wO2U8YztlKyspZCs9dGhpcy5hZGRTdGF0ZXModGhpcy5ncmFwaC5tb2RlbC5nZXRDaGlsZEF0KGEsZSksYil9cmV0dXJuIGR9O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5pc0NlbGxNb3Zpbmc9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPXRoaXMuYWxsQ2VsbHMuZ2V0KGEpfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnVzZUd1aWRlc0ZvckV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT10aGlzLmd1aWRlP3RoaXMuZ3VpZGUuaXNFbmFibGVkRm9yRXZlbnQoYS5nZXRFdmVudCgpKSYmIXRoaXMuZ3JhcGguaXNDb25zdHJhaW5lZEV2ZW50KGEuZ2V0RXZlbnQoKSk6ITB9O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5zbmFwPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc2NhbGVHcmlkP3RoaXMuZ3JhcGgudmlldy5zY2FsZToxO2EueD10aGlzLmdyYXBoLnNuYXAoYS54L2IpKmI7YS55PXRoaXMuZ3JhcGguc25hcChhLnkvYikqYjtyZXR1cm4gYX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5nZXREZWx0YT1mdW5jdGlvbihhKXthPW14VXRpbHMuY29udmVydFBvaW50KHRoaXMuZ3JhcGguY29udGFpbmVyLGEuZ2V0WCgpLGEuZ2V0WSgpKTtyZXR1cm4gbmV3IG14UG9pbnQoYS54LXRoaXMuZmlyc3QueC10aGlzLmdyYXBoLnBhbkR4LGEueS10aGlzLmZpcnN0LnktdGhpcy5ncmFwaC5wYW5EeSl9O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVIaW50PWZ1bmN0aW9uKGEpe307bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnJlbW92ZUhpbnQ9ZnVuY3Rpb24oKXt9O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5yb3VuZExlbmd0aD1mdW5jdGlvbihhKXtyZXR1cm4gTWF0aC5yb3VuZCgxMDAqYSkvMTAwfTtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuaXNWYWxpZERyb3BUYXJnZXQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5ncmFwaC5tb2RlbC5nZXRQYXJlbnQodGhpcy5jZWxsKSE9YX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5jaGVja1ByZXZpZXc9ZnVuY3Rpb24oKXt0aGlzLmxpdmVQcmV2aWV3QWN0aXZlJiZ0aGlzLmNsb25pbmc/KHRoaXMucmVzZXRMaXZlUHJldmlldygpLHRoaXMubGl2ZVByZXZpZXdBY3RpdmU9ITEpOnRoaXMubWF4TGl2ZVByZXZpZXc+PXRoaXMuY2VsbENvdW50JiYhdGhpcy5saXZlUHJldmlld0FjdGl2ZSYmdGhpcy5hbGxvd0xpdmVQcmV2aWV3P3RoaXMuY2xvbmluZyYmdGhpcy5saXZlUHJldmlld0FjdGl2ZXx8KHRoaXMubGl2ZVByZXZpZXdVc2VkPXRoaXMubGl2ZVByZXZpZXdBY3RpdmU9ITApOnRoaXMubGl2ZVByZXZpZXdVc2VkfHxudWxsIT10aGlzLnNoYXBlfHwodGhpcy5zaGFwZT10aGlzLmNyZWF0ZVByZXZpZXdTaGFwZSh0aGlzLmJvdW5kcykpfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLm1vdXNlTW92ZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ3JhcGg7aWYoYi5pc0NvbnN1bWVkKCl8fCFjLmlzTW91c2VEb3dufHxudWxsPT10aGlzLmNlbGx8fG51bGw9PXRoaXMuZmlyc3R8fG51bGw9PXRoaXMuYm91bmRzfHx0aGlzLnN1c3BlbmRlZCkhdGhpcy5pc01vdmVFbmFibGVkKCkmJiF0aGlzLmlzQ2xvbmVFbmFibGVkKCl8fCF0aGlzLnVwZGF0ZUN1cnNvcnx8Yi5pc0NvbnN1bWVkKCl8fG51bGw9PWIuZ2V0U3RhdGUoKSYmbnVsbD09Yi5zb3VyY2VTdGF0ZXx8Yy5pc01vdXNlRG93bnx8KGQ9Yy5nZXRDdXJzb3JGb3JNb3VzZUV2ZW50KGIpLG51bGw9PWQmJmMuaXNFbmFibGVkKCkmJmMuaXNDZWxsTW92YWJsZShiLmdldENlbGwoKSkmJihkPWMuZ2V0TW9kZWwoKS5pc0VkZ2UoYi5nZXRDZWxsKCkpP214Q29uc3RhbnRzLkNVUlNPUl9NT1ZBQkxFX0VER0U6bXhDb25zdGFudHMuQ1VSU09SX01PVkFCTEVfVkVSVEVYKSxudWxsIT0KZCYmbnVsbCE9Yi5zb3VyY2VTdGF0ZSYmYi5zb3VyY2VTdGF0ZS5zZXRDdXJzb3IoZCkpO2Vsc2UgaWYobXhFdmVudC5pc011bHRpVG91Y2hFdmVudChiLmdldEV2ZW50KCkpKXRoaXMucmVzZXQoKTtlbHNle3ZhciBkPXRoaXMuZ2V0RGVsdGEoYiksZT1jLnRvbGVyYW5jZTtpZihudWxsIT10aGlzLnNoYXBlfHx0aGlzLmxpdmVQcmV2aWV3QWN0aXZlfHxNYXRoLmFicyhkLngpPmV8fE1hdGguYWJzKGQueSk+ZSl7bnVsbD09dGhpcy5oaWdobGlnaHQmJih0aGlzLmhpZ2hsaWdodD1uZXcgbXhDZWxsSGlnaGxpZ2h0KHRoaXMuZ3JhcGgsbXhDb25zdGFudHMuRFJPUF9UQVJHRVRfQ09MT1IsMykpO3ZhciBlPWMuaXNDbG9uZUV2ZW50KGIuZ2V0RXZlbnQoKSkmJmMuaXNDZWxsc0Nsb25lYWJsZSgpJiZ0aGlzLmlzQ2xvbmVFbmFibGVkKCksZj1jLmlzR3JpZEVuYWJsZWRFdmVudChiLmdldEV2ZW50KCkpLGc9Yi5nZXRDZWxsKCksaz0hMCxsPW51bGw7dGhpcy5jbG9uaW5nPWU7Yy5pc0Ryb3BFbmFibGVkKCkmJgp0aGlzLmhpZ2hsaWdodEVuYWJsZWQmJihsPWMuZ2V0RHJvcFRhcmdldCh0aGlzLmNlbGxzLGIuZ2V0RXZlbnQoKSxnLGUpKTt2YXIgbT1jLmdldFZpZXcoKS5nZXRTdGF0ZShsKSxuPSExO251bGwhPW0mJihlfHx0aGlzLmlzVmFsaWREcm9wVGFyZ2V0KGwsYikpPyh0aGlzLnRhcmdldCE9bCYmKHRoaXMudGFyZ2V0PWwsdGhpcy5zZXRIaWdobGlnaHRDb2xvcihteENvbnN0YW50cy5EUk9QX1RBUkdFVF9DT0xPUikpLG49ITApOih0aGlzLnRhcmdldD1udWxsLHRoaXMuY29ubmVjdE9uRHJvcCYmbnVsbCE9ZyYmMT09dGhpcy5jZWxscy5sZW5ndGgmJmMuZ2V0TW9kZWwoKS5pc1ZlcnRleChnKSYmYy5pc0NlbGxDb25uZWN0YWJsZShnKSYmKG09Yy5nZXRWaWV3KCkuZ2V0U3RhdGUoZyksbnVsbCE9bSYmKGc9bnVsbD09Yy5nZXRFZGdlVmFsaWRhdGlvbkVycm9yKG51bGwsdGhpcy5jZWxsLGcpP214Q29uc3RhbnRzLlZBTElEX0NPTE9SOm14Q29uc3RhbnRzLklOVkFMSURfQ09OTkVDVF9UQVJHRVRfQ09MT1IsCnRoaXMuc2V0SGlnaGxpZ2h0Q29sb3IoZyksbj0hMCkpKTtudWxsIT1tJiZuP3RoaXMuaGlnaGxpZ2h0LmhpZ2hsaWdodChtKTp0aGlzLmhpZ2hsaWdodC5oaWRlKCk7bnVsbCE9dGhpcy5ndWlkZSYmdGhpcy51c2VHdWlkZXNGb3JFdmVudChiKT8oZD10aGlzLmd1aWRlLm1vdmUodGhpcy5ib3VuZHMsZCxmLGUpLGs9ITEpOmQ9dGhpcy5ncmFwaC5zbmFwRGVsdGEoZCx0aGlzLmJvdW5kcywhZiwhMSwhMSk7bnVsbCE9dGhpcy5ndWlkZSYmayYmdGhpcy5ndWlkZS5oaWRlKCk7Yy5pc0NvbnN0cmFpbmVkRXZlbnQoYi5nZXRFdmVudCgpKSYmKE1hdGguYWJzKGQueCk+TWF0aC5hYnMoZC55KT9kLnk9MDpkLng9MCk7dGhpcy5jaGVja1ByZXZpZXcoKTtpZih0aGlzLmN1cnJlbnREeCE9ZC54fHx0aGlzLmN1cnJlbnREeSE9ZC55KXRoaXMuY3VycmVudER4PWQueCx0aGlzLmN1cnJlbnREeT1kLnksdGhpcy51cGRhdGVQcmV2aWV3KCl9dGhpcy51cGRhdGVIaW50KGIpO3RoaXMuY29uc3VtZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9NT1ZFLApiKTtteEV2ZW50LmNvbnN1bWUoYi5nZXRFdmVudCgpKX19O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVQcmV2aWV3PWZ1bmN0aW9uKGEpe3RoaXMubGl2ZVByZXZpZXdVc2VkJiYhYT9udWxsIT10aGlzLmNlbGxzJiYodGhpcy5zZXRIYW5kbGVzVmlzaWJsZUZvckNlbGxzKHRoaXMuZ3JhcGguc2VsZWN0aW9uQ2VsbHNIYW5kbGVyLmdldEhhbmRsZWRTZWxlY3Rpb25DZWxscygpLCExKSx0aGlzLnVwZGF0ZUxpdmVQcmV2aWV3KHRoaXMuY3VycmVudER4LHRoaXMuY3VycmVudER5KSk6dGhpcy51cGRhdGVQcmV2aWV3U2hhcGUoKX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVQcmV2aWV3U2hhcGU9ZnVuY3Rpb24oKXtudWxsIT10aGlzLnNoYXBlJiZudWxsIT10aGlzLnBCb3VuZHMmJih0aGlzLnNoYXBlLmJvdW5kcz1uZXcgbXhSZWN0YW5nbGUoTWF0aC5yb3VuZCh0aGlzLnBCb3VuZHMueCt0aGlzLmN1cnJlbnREeCksTWF0aC5yb3VuZCh0aGlzLnBCb3VuZHMueSt0aGlzLmN1cnJlbnREeSksdGhpcy5wQm91bmRzLndpZHRoLHRoaXMucEJvdW5kcy5oZWlnaHQpLHRoaXMuc2hhcGUucmVkcmF3KCkpfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZUxpdmVQcmV2aWV3PWZ1bmN0aW9uKGEsYil7aWYoIXRoaXMuc3VzcGVuZGVkKXt2YXIgYz1bXTtudWxsIT10aGlzLmFsbENlbGxzJiZ0aGlzLmFsbENlbGxzLnZpc2l0KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGQsZSl7aWYobnVsbD09dGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKGUuY2VsbCkpZS5kZXN0cm95KCk7ZWxzZXt2YXIgZj1lLmNsb25lKCk7Yy5wdXNoKFtlLGZdKTtudWxsIT1lLnNoYXBlJiYobnVsbD09ZS5zaGFwZS5vcmlnaW5hbFBvaW50ZXJFdmVudHMmJihlLnNoYXBlLm9yaWdpbmFsUG9pbnRlckV2ZW50cz1lLnNoYXBlLnBvaW50ZXJFdmVudHMpLGUuc2hhcGUucG9pbnRlckV2ZW50cz0hMSxudWxsIT1lLnRleHQmJihudWxsPT1lLnRleHQub3JpZ2luYWxQb2ludGVyRXZlbnRzJiYoZS50ZXh0Lm9yaWdpbmFsUG9pbnRlckV2ZW50cz1lLnRleHQucG9pbnRlckV2ZW50cyksZS50ZXh0LnBvaW50ZXJFdmVudHM9CiExKSk7dGhpcy5ncmFwaC5tb2RlbC5pc1ZlcnRleChlLmNlbGwpJiYoZS54Kz1hLGUueSs9Yix0aGlzLmNsb25pbmd8fChlLnZpZXcuZ3JhcGguY2VsbFJlbmRlcmVyLnJlZHJhdyhlLCEwKSxlLnZpZXcuaW52YWxpZGF0ZShlLmNlbGwpLGUuaW52YWxpZD0hMSxudWxsIT1lLmNvbnRyb2wmJm51bGwhPWUuY29udHJvbC5ub2RlJiYoZS5jb250cm9sLm5vZGUuc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIikpKX19KSk7aWYoMD09Yy5sZW5ndGgpdGhpcy5yZXNldCgpO2Vsc2V7Zm9yKHZhciBkPXRoaXMuZ3JhcGgudmlldy5zY2FsZSxlPTA7ZTxjLmxlbmd0aDtlKyspe3ZhciBmPWNbZV1bMF07aWYodGhpcy5ncmFwaC5tb2RlbC5pc0VkZ2UoZi5jZWxsKSl7dmFyIGc9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoZi5jZWxsKSxrPVtdO2lmKG51bGwhPWcmJm51bGwhPWcucG9pbnRzKWZvcih2YXIgbD0wO2w8Zy5wb2ludHMubGVuZ3RoO2wrKyludWxsIT1nLnBvaW50c1tsXSYmay5wdXNoKG5ldyBteFBvaW50KGcucG9pbnRzW2xdLngrCmEvZCxnLnBvaW50c1tsXS55K2IvZCkpO3ZhciBnPWYudmlzaWJsZVNvdXJjZVN0YXRlLGw9Zi52aXNpYmxlVGFyZ2V0U3RhdGUsbT1jW2VdWzFdLmFic29sdXRlUG9pbnRzO251bGwhPWcmJnRoaXMuaXNDZWxsTW92aW5nKGcuY2VsbCk/Zi52aWV3LnVwZGF0ZUZpeGVkVGVybWluYWxQb2ludChmLGcsITAsdGhpcy5ncmFwaC5nZXRDb25uZWN0aW9uQ29uc3RyYWludChmLGcsITApKTooZz1tWzBdLGYuc2V0QWJzb2x1dGVUZXJtaW5hbFBvaW50KG5ldyBteFBvaW50KGcueCthLGcueStiKSwhMCksZz1udWxsKTtudWxsIT1sJiZ0aGlzLmlzQ2VsbE1vdmluZyhsLmNlbGwpP2Yudmlldy51cGRhdGVGaXhlZFRlcm1pbmFsUG9pbnQoZixsLCExLHRoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvbkNvbnN0cmFpbnQoZixsLCExKSk6KGw9bVttLmxlbmd0aC0xXSxmLnNldEFic29sdXRlVGVybWluYWxQb2ludChuZXcgbXhQb2ludChsLngrYSxsLnkrYiksITEpLGw9bnVsbCk7Zi52aWV3LnVwZGF0ZVBvaW50cyhmLAprLGcsbCk7Zi52aWV3LnVwZGF0ZUZsb2F0aW5nVGVybWluYWxQb2ludHMoZixnLGwpO2Yudmlldy51cGRhdGVFZGdlTGFiZWxPZmZzZXQoZik7Zi5pbnZhbGlkPSExO3RoaXMuY2xvbmluZ3x8Zi52aWV3LmdyYXBoLmNlbGxSZW5kZXJlci5yZWRyYXcoZiwhMCl9fXRoaXMuZ3JhcGgudmlldy52YWxpZGF0ZSgpO3RoaXMucmVkcmF3SGFuZGxlcyhjKTt0aGlzLnJlc2V0UHJldmlld1N0YXRlcyhjKX19fTtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUucmVkcmF3SGFuZGxlcz1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5ncmFwaC5zZWxlY3Rpb25DZWxsc0hhbmRsZXIuZ2V0SGFuZGxlcihhW2JdWzBdLmNlbGwpO251bGwhPWMmJmMucmVkcmF3KCEwKX19O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5yZXNldFByZXZpZXdTdGF0ZXM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspYVtiXVswXS5zZXRTdGF0ZShhW2JdWzFdKX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5zdXNwZW5kPWZ1bmN0aW9uKCl7dGhpcy5zdXNwZW5kZWR8fCh0aGlzLmxpdmVQcmV2aWV3VXNlZCYmdGhpcy51cGRhdGVMaXZlUHJldmlldygwLDApLG51bGwhPXRoaXMuc2hhcGUmJih0aGlzLnNoYXBlLm5vZGUuc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIiksbnVsbCE9dGhpcy5ndWlkZSYmdGhpcy5ndWlkZS5zZXRWaXNpYmxlKCExKSx0aGlzLnN1c3BlbmRlZD0hMCl9O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5yZXN1bWU9ZnVuY3Rpb24oKXt0aGlzLnN1c3BlbmRlZCYmKHRoaXMuc3VzcGVuZGVkPW51bGwsdGhpcy5saXZlUHJldmlld1VzZWQmJih0aGlzLmxpdmVQcmV2aWV3QWN0aXZlPSEwKSxudWxsIT10aGlzLnNoYXBlJiYodGhpcy5zaGFwZS5ub2RlLnN0eWxlLnZpc2liaWxpdHk9InZpc2libGUiKSxudWxsIT10aGlzLmd1aWRlJiZ0aGlzLmd1aWRlLnNldFZpc2libGUoITApKX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5yZXNldExpdmVQcmV2aWV3PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5hbGxDZWxscyYmKHRoaXMuYWxsQ2VsbHMudmlzaXQobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiKXtudWxsIT1iLnNoYXBlJiZudWxsIT1iLnNoYXBlLm9yaWdpbmFsUG9pbnRlckV2ZW50cyYmKGIuc2hhcGUucG9pbnRlckV2ZW50cz1iLnNoYXBlLm9yaWdpbmFsUG9pbnRlckV2ZW50cyxiLnNoYXBlLm9yaWdpbmFsUG9pbnRlckV2ZW50cz1udWxsLGIuc2hhcGUuYm91bmRzPW51bGwsbnVsbCE9Yi50ZXh0JiYoYi50ZXh0LnBvaW50ZXJFdmVudHM9Yi50ZXh0Lm9yaWdpbmFsUG9pbnRlckV2ZW50cyxiLnRleHQub3JpZ2luYWxQb2ludGVyRXZlbnRzPW51bGwpKTtudWxsIT1iLmNvbnRyb2wmJm51bGwhPWIuY29udHJvbC5ub2RlJiYiaGlkZGVuIj09Yi5jb250cm9sLm5vZGUuc3R5bGUudmlzaWJpbGl0eSYmKGIuY29udHJvbC5ub2RlLnN0eWxlLnZpc2liaWxpdHk9CiIiKTtiLnZpZXcuaW52YWxpZGF0ZShiLmNlbGwpfSkpLHRoaXMuZ3JhcGgudmlldy52YWxpZGF0ZSgpKX07bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnNldEhhbmRsZXNWaXNpYmxlRm9yQ2VsbHM9ZnVuY3Rpb24oYSxiKXtpZih0aGlzLmhhbmRsZXNWaXNpYmxlIT1iKXt0aGlzLmhhbmRsZXNWaXNpYmxlPWI7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBkPXRoaXMuZ3JhcGguc2VsZWN0aW9uQ2VsbHNIYW5kbGVyLmdldEhhbmRsZXIoYVtjXSk7bnVsbCE9ZCYmKGQuc2V0SGFuZGxlc1Zpc2libGUoYiksYiYmZC5yZWRyYXcoKSl9fX07bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnNldEhpZ2hsaWdodENvbG9yPWZ1bmN0aW9uKGEpe251bGwhPXRoaXMuaGlnaGxpZ2h0JiZ0aGlzLmhpZ2hsaWdodC5zZXRIaWdobGlnaHRDb2xvcihhKX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5tb3VzZVVwPWZ1bmN0aW9uKGEsYil7aWYoIWIuaXNDb25zdW1lZCgpKWlmKHRoaXMubGl2ZVByZXZpZXdVc2VkJiZ0aGlzLnJlc2V0TGl2ZVByZXZpZXcoKSxudWxsPT10aGlzLmNlbGx8fG51bGw9PXRoaXMuZmlyc3R8fG51bGw9PXRoaXMuc2hhcGUmJiF0aGlzLmxpdmVQcmV2aWV3VXNlZHx8bnVsbD09dGhpcy5jdXJyZW50RHh8fG51bGw9PXRoaXMuY3VycmVudER5KXRoaXMuaXNTZWxlY3RFbmFibGVkKCkmJnRoaXMuZGVsYXllZFNlbGVjdGlvbiYmbnVsbCE9dGhpcy5jZWxsJiZ0aGlzLnNlbGVjdERlbGF5ZWQoYik7ZWxzZXt2YXIgYz10aGlzLmdyYXBoLGQ9Yi5nZXRDZWxsKCk7aWYodGhpcy5jb25uZWN0T25Ecm9wJiZudWxsPT10aGlzLnRhcmdldCYmbnVsbCE9ZCYmYy5nZXRNb2RlbCgpLmlzVmVydGV4KGQpJiZjLmlzQ2VsbENvbm5lY3RhYmxlKGQpJiZjLmlzRWRnZVZhbGlkKG51bGwsdGhpcy5jZWxsLGQpKWMuY29ubmVjdGlvbkhhbmRsZXIuY29ubmVjdCh0aGlzLmNlbGwsCmQsYi5nZXRFdmVudCgpKTtlbHNle3ZhciBkPWMuaXNDbG9uZUV2ZW50KGIuZ2V0RXZlbnQoKSkmJmMuaXNDZWxsc0Nsb25lYWJsZSgpJiZ0aGlzLmlzQ2xvbmVFbmFibGVkKCksZT1jLmdldFZpZXcoKS5zY2FsZSxmPXRoaXMucm91bmRMZW5ndGgodGhpcy5jdXJyZW50RHgvZSksZT10aGlzLnJvdW5kTGVuZ3RoKHRoaXMuY3VycmVudER5L2UpLGc9dGhpcy50YXJnZXQ7Yy5pc1NwbGl0RW5hYmxlZCgpJiZjLmlzU3BsaXRUYXJnZXQoZyx0aGlzLmNlbGxzLGIuZ2V0RXZlbnQoKSk/Yy5zcGxpdEVkZ2UoZyx0aGlzLmNlbGxzLG51bGwsZixlLGIuZ2V0R3JhcGhYKCksYi5nZXRHcmFwaFkoKSk6dGhpcy5tb3ZlQ2VsbHModGhpcy5jZWxscyxmLGUsZCx0aGlzLnRhcmdldCxiLmdldEV2ZW50KCkpfX10aGlzLmNlbGxXYXNDbGlja2VkJiZ0aGlzLmNvbnN1bWVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfVVAsYik7dGhpcy5yZXNldCgpfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5saXZlUHJldmlld1VzZWQmJih0aGlzLnJlc2V0TGl2ZVByZXZpZXcoKSx0aGlzLnNldEhhbmRsZXNWaXNpYmxlRm9yQ2VsbHModGhpcy5ncmFwaC5zZWxlY3Rpb25DZWxsc0hhbmRsZXIuZ2V0SGFuZGxlZFNlbGVjdGlvbkNlbGxzKCksITApKTt0aGlzLmRlc3Ryb3lTaGFwZXMoKTt0aGlzLnJlbW92ZUhpbnQoKTt0aGlzLmRlbGF5ZWRTZWxlY3Rpb249ITE7dGhpcy5saXZlUHJldmlld1VzZWQ9dGhpcy5saXZlUHJldmlld0FjdGl2ZT1udWxsO3RoaXMuY2VsbFdhc0NsaWNrZWQ9ITE7dGhpcy5jZWxsQ291bnQ9dGhpcy5jdXJyZW50RHk9dGhpcy5jdXJyZW50RHg9dGhpcy5zdXNwZW5kZWQ9bnVsbDt0aGlzLmNsb25pbmc9ITE7dGhpcy5jZWxsPXRoaXMuY2VsbHM9dGhpcy5maXJzdD10aGlzLnRhcmdldD10aGlzLmd1aWRlcz10aGlzLnBCb3VuZHM9dGhpcy5hbGxDZWxscz1udWxsfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnNob3VsZFJlbW92ZUNlbGxzRnJvbVBhcmVudD1mdW5jdGlvbihhLGIsYyl7aWYodGhpcy5ncmFwaC5nZXRNb2RlbCgpLmlzVmVydGV4KGEpJiYoYT10aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRTdGF0ZShhKSxudWxsIT1hKSl7Yz1teFV0aWxzLmNvbnZlcnRQb2ludCh0aGlzLmdyYXBoLmNvbnRhaW5lcixteEV2ZW50LmdldENsaWVudFgoYyksbXhFdmVudC5nZXRDbGllbnRZKGMpKTt2YXIgZD1teFV0aWxzLnRvUmFkaWFucyhteFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT04pfHwwKTtpZigwIT1kKXtiPU1hdGguY29zKC1kKTt2YXIgZD1NYXRoLnNpbigtZCksZT1uZXcgbXhQb2ludChhLmdldENlbnRlclgoKSxhLmdldENlbnRlclkoKSk7Yz1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChjLGIsZCxlKX1yZXR1cm4hbXhVdGlscy5jb250YWlucyhhLGMueCxjLnkpfXJldHVybiExfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLm1vdmVDZWxscz1mdW5jdGlvbihhLGIsYyxkLGUsZil7ZCYmKGE9dGhpcy5ncmFwaC5nZXRDbG9uZWFibGVDZWxscyhhKSk7dmFyIGc9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldFBhcmVudCh0aGlzLmNlbGwpO251bGw9PWUmJnRoaXMuaXNSZW1vdmVDZWxsc0Zyb21QYXJlbnQoKSYmdGhpcy5zaG91bGRSZW1vdmVDZWxsc0Zyb21QYXJlbnQoZyxhLGYpJiYoZT10aGlzLmdyYXBoLmdldERlZmF1bHRQYXJlbnQoKSk7ZD1kJiYhdGhpcy5ncmFwaC5pc0NlbGxMb2NrZWQoZXx8dGhpcy5ncmFwaC5nZXREZWZhdWx0UGFyZW50KCkpO3RoaXMuZ3JhcGguZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtnPVtdO2lmKCFkJiZudWxsIT1lJiZ0aGlzLnJlbW92ZUVtcHR5UGFyZW50cyl7Zm9yKHZhciBrPW5ldyBteERpY3Rpb25hcnksbD0wO2w8YS5sZW5ndGg7bCsrKWsucHV0KGFbbF0sITApO2ZvcihsPTA7bDxhLmxlbmd0aDtsKyspe3ZhciBtPQp0aGlzLmdyYXBoLm1vZGVsLmdldFBhcmVudChhW2xdKTtudWxsPT1tfHxrLmdldChtKXx8KGsucHV0KG0sITApLGcucHVzaChtKSl9fWE9dGhpcy5ncmFwaC5tb3ZlQ2VsbHMoYSxiLGMsZCxlLGYpO2I9W107Zm9yKGw9MDtsPGcubGVuZ3RoO2wrKyl0aGlzLnNob3VsZFJlbW92ZVBhcmVudChnW2xdKSYmYi5wdXNoKGdbbF0pO3RoaXMuZ3JhcGgucmVtb3ZlQ2VsbHMoYiwhMSl9ZmluYWxseXt0aGlzLmdyYXBoLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9ZCYmdGhpcy5ncmFwaC5zZXRTZWxlY3Rpb25DZWxscyhhKTt0aGlzLmlzU2VsZWN0RW5hYmxlZCgpJiZ0aGlzLnNjcm9sbE9uTW92ZSYmdGhpcy5ncmFwaC5zY3JvbGxDZWxsVG9WaXNpYmxlKGFbMF0pfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnNob3VsZFJlbW92ZVBhcmVudD1mdW5jdGlvbihhKXthPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZShhKTtyZXR1cm4gbnVsbCE9YSYmKHRoaXMuZ3JhcGgubW9kZWwuaXNFZGdlKGEuY2VsbCl8fHRoaXMuZ3JhcGgubW9kZWwuaXNWZXJ0ZXgoYS5jZWxsKSkmJnRoaXMuZ3JhcGguaXNDZWxsRGVsZXRhYmxlKGEuY2VsbCkmJjA9PXRoaXMuZ3JhcGgubW9kZWwuZ2V0Q2hpbGRDb3VudChhLmNlbGwpJiZ0aGlzLmdyYXBoLmlzVHJhbnNwYXJlbnRTdGF0ZShhKX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95U2hhcGVzPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5zaGFwZSYmKHRoaXMuc2hhcGUuZGVzdHJveSgpLHRoaXMuc2hhcGU9bnVsbCk7bnVsbCE9dGhpcy5ndWlkZSYmKHRoaXMuZ3VpZGUuZGVzdHJveSgpLHRoaXMuZ3VpZGU9bnVsbCk7bnVsbCE9dGhpcy5oaWdobGlnaHQmJih0aGlzLmhpZ2hsaWdodC5kZXN0cm95KCksdGhpcy5oaWdobGlnaHQ9bnVsbCl9OwpteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZ3JhcGgucmVtb3ZlTW91c2VMaXN0ZW5lcih0aGlzKTt0aGlzLmdyYXBoLnJlbW92ZUxpc3RlbmVyKHRoaXMucGFuSGFuZGxlcik7bnVsbCE9dGhpcy5lc2NhcGVIYW5kbGVyJiYodGhpcy5ncmFwaC5yZW1vdmVMaXN0ZW5lcih0aGlzLmVzY2FwZUhhbmRsZXIpLHRoaXMuZXNjYXBlSGFuZGxlcj1udWxsKTtudWxsIT10aGlzLnJlZnJlc2hIYW5kbGVyJiYodGhpcy5ncmFwaC5nZXRNb2RlbCgpLnJlbW92ZUxpc3RlbmVyKHRoaXMucmVmcmVzaEhhbmRsZXIpLHRoaXMucmVmcmVzaEhhbmRsZXI9bnVsbCk7bXhFdmVudC5yZW1vdmVMaXN0ZW5lcihkb2N1bWVudCwia2V5ZG93biIsdGhpcy5rZXlIYW5kbGVyKTtteEV2ZW50LnJlbW92ZUxpc3RlbmVyKGRvY3VtZW50LCJrZXl1cCIsdGhpcy5rZXlIYW5kbGVyKTt0aGlzLmRlc3Ryb3lTaGFwZXMoKTt0aGlzLnJlbW92ZUhpbnQoKX07CmZ1bmN0aW9uIG14UGFubmluZ0hhbmRsZXIoYSl7bnVsbCE9YSYmKHRoaXMuZ3JhcGg9YSx0aGlzLmdyYXBoLmFkZE1vdXNlTGlzdGVuZXIodGhpcyksdGhpcy5mb3JjZVBhbm5pbmdIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7dmFyIGI9Yy5nZXRQcm9wZXJ0eSgiZXZlbnROYW1lIiksZT1jLmdldFByb3BlcnR5KCJldmVudCIpO2I9PW14RXZlbnQuTU9VU0VfRE9XTiYmdGhpcy5pc0ZvcmNlUGFubmluZ0V2ZW50KGUpJiYodGhpcy5zdGFydChlKSx0aGlzLmFjdGl2ZT0hMCx0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlBBTl9TVEFSVCwiZXZlbnQiLGUpKSxlLmNvbnN1bWUoKSl9KSx0aGlzLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuRklSRV9NT1VTRV9FVkVOVCx0aGlzLmZvcmNlUGFubmluZ0hhbmRsZXIpLHRoaXMuZ2VzdHVyZUhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXtpZih0aGlzLmlzUGluY2hFbmFibGVkKCkpe3ZhciBiPQpjLmdldFByb3BlcnR5KCJldmVudCIpO214RXZlbnQuaXNDb25zdW1lZChiKXx8Imdlc3R1cmVzdGFydCIhPWIudHlwZT8iZ2VzdHVyZWVuZCI9PWIudHlwZSYmbnVsbCE9dGhpcy5pbml0aWFsU2NhbGUmJih0aGlzLmluaXRpYWxTY2FsZT1udWxsKToodGhpcy5pbml0aWFsU2NhbGU9dGhpcy5ncmFwaC52aWV3LnNjYWxlLHRoaXMuYWN0aXZlfHxudWxsPT10aGlzLm1vdXNlRG93bkV2ZW50fHwodGhpcy5zdGFydCh0aGlzLm1vdXNlRG93bkV2ZW50KSx0aGlzLm1vdXNlRG93bkV2ZW50PW51bGwpKTtudWxsIT10aGlzLmluaXRpYWxTY2FsZSYmdGhpcy56b29tR3JhcGgoYil9fSksdGhpcy5ncmFwaC5hZGRMaXN0ZW5lcihteEV2ZW50LkdFU1RVUkUsdGhpcy5nZXN0dXJlSGFuZGxlciksdGhpcy5tb3VzZVVwTGlzdGVuZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmFjdGl2ZSYmdGhpcy5yZXNldCgpfSksbXhFdmVudC5hZGRMaXN0ZW5lcihkb2N1bWVudCwibW91c2V1cCIsCnRoaXMubW91c2VVcExpc3RlbmVyKSl9bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGU9bmV3IG14RXZlbnRTb3VyY2U7bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhQYW5uaW5nSGFuZGxlcjtteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5ncmFwaD1udWxsO214UGFubmluZ0hhbmRsZXIucHJvdG90eXBlLnVzZUxlZnRCdXR0b25Gb3JQYW5uaW5nPSExO214UGFubmluZ0hhbmRsZXIucHJvdG90eXBlLnVzZVBvcHVwVHJpZ2dlcj0hMDtteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5pZ25vcmVDZWxsPSExO214UGFubmluZ0hhbmRsZXIucHJvdG90eXBlLnByZXZpZXdFbmFibGVkPSEwO214UGFubmluZ0hhbmRsZXIucHJvdG90eXBlLnVzZUdyaWQ9ITE7bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUucGFubmluZ0VuYWJsZWQ9ITA7bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUucGluY2hFbmFibGVkPSEwOwpteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5tYXhTY2FsZT04O214UGFubmluZ0hhbmRsZXIucHJvdG90eXBlLm1pblNjYWxlPS4wMTtteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5keD1udWxsO214UGFubmluZ0hhbmRsZXIucHJvdG90eXBlLmR5PW51bGw7bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUuc3RhcnRYPTA7bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUuc3RhcnRZPTA7bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUuaXNBY3RpdmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hY3RpdmV8fG51bGwhPXRoaXMuaW5pdGlhbFNjYWxlfTtteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5pc1Bhbm5pbmdFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFubmluZ0VuYWJsZWR9O214UGFubmluZ0hhbmRsZXIucHJvdG90eXBlLnNldFBhbm5pbmdFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMucGFubmluZ0VuYWJsZWQ9YX07Cm14UGFubmluZ0hhbmRsZXIucHJvdG90eXBlLmlzUGluY2hFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGluY2hFbmFibGVkfTtteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5zZXRQaW5jaEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5waW5jaEVuYWJsZWQ9YX07bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUuaXNQYW5uaW5nVHJpZ2dlcj1mdW5jdGlvbihhKXt2YXIgYj1hLmdldEV2ZW50KCk7cmV0dXJuIHRoaXMudXNlTGVmdEJ1dHRvbkZvclBhbm5pbmcmJm51bGw9PWEuZ2V0U3RhdGUoKSYmbXhFdmVudC5pc0xlZnRNb3VzZUJ1dHRvbihiKXx8bXhFdmVudC5pc0NvbnRyb2xEb3duKGIpJiZteEV2ZW50LmlzU2hpZnREb3duKGIpfHx0aGlzLnVzZVBvcHVwVHJpZ2dlciYmbXhFdmVudC5pc1BvcHVwVHJpZ2dlcihiKX07bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUuaXNGb3JjZVBhbm5pbmdFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pZ25vcmVDZWxsfHxteEV2ZW50LmlzTXVsdGlUb3VjaEV2ZW50KGEuZ2V0RXZlbnQoKSl9OwpteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5tb3VzZURvd249ZnVuY3Rpb24oYSxiKXt0aGlzLm1vdXNlRG93bkV2ZW50PWI7IWIuaXNDb25zdW1lZCgpJiZ0aGlzLmlzUGFubmluZ0VuYWJsZWQoKSYmIXRoaXMuYWN0aXZlJiZ0aGlzLmlzUGFubmluZ1RyaWdnZXIoYikmJih0aGlzLnN0YXJ0KGIpLHRoaXMuY29uc3VtZVBhbm5pbmdUcmlnZ2VyKGIpKX07bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24oYSl7dGhpcy5keDA9LXRoaXMuZ3JhcGguY29udGFpbmVyLnNjcm9sbExlZnQ7dGhpcy5keTA9LXRoaXMuZ3JhcGguY29udGFpbmVyLnNjcm9sbFRvcDt0aGlzLnN0YXJ0WD1hLmdldFgoKTt0aGlzLnN0YXJ0WT1hLmdldFkoKTt0aGlzLmR5PXRoaXMuZHg9bnVsbDt0aGlzLnBhbm5pbmdUcmlnZ2VyPSEwfTtteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5jb25zdW1lUGFubmluZ1RyaWdnZXI9ZnVuY3Rpb24oYSl7YS5jb25zdW1lKCl9OwpteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5tb3VzZU1vdmU9ZnVuY3Rpb24oYSxiKXt0aGlzLmR4PWIuZ2V0WCgpLXRoaXMuc3RhcnRYO3RoaXMuZHk9Yi5nZXRZKCktdGhpcy5zdGFydFk7aWYodGhpcy5hY3RpdmUpdGhpcy5wcmV2aWV3RW5hYmxlZCYmKHRoaXMudXNlR3JpZCYmKHRoaXMuZHg9dGhpcy5ncmFwaC5zbmFwKHRoaXMuZHgpLHRoaXMuZHk9dGhpcy5ncmFwaC5zbmFwKHRoaXMuZHkpKSx0aGlzLmdyYXBoLnBhbkdyYXBoKHRoaXMuZHgrdGhpcy5keDAsdGhpcy5keSt0aGlzLmR5MCkpLHRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuUEFOLCJldmVudCIsYikpO2Vsc2UgaWYodGhpcy5wYW5uaW5nVHJpZ2dlcil7dmFyIGM9dGhpcy5hY3RpdmU7dGhpcy5hY3RpdmU9TWF0aC5hYnModGhpcy5keCk+dGhpcy5ncmFwaC50b2xlcmFuY2V8fE1hdGguYWJzKHRoaXMuZHkpPnRoaXMuZ3JhcGgudG9sZXJhbmNlOyFjJiZ0aGlzLmFjdGl2ZSYmdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5QQU5fU1RBUlQsCiJldmVudCIsYikpfSh0aGlzLmFjdGl2ZXx8dGhpcy5wYW5uaW5nVHJpZ2dlcikmJmIuY29uc3VtZSgpfTtteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5tb3VzZVVwPWZ1bmN0aW9uKGEsYil7aWYodGhpcy5hY3RpdmUpe2lmKG51bGwhPXRoaXMuZHgmJm51bGwhPXRoaXMuZHkpe2lmKCF0aGlzLmdyYXBoLnVzZVNjcm9sbGJhcnNGb3JQYW5uaW5nfHwhbXhVdGlscy5oYXNTY3JvbGxiYXJzKHRoaXMuZ3JhcGguY29udGFpbmVyKSl7dmFyIGM9dGhpcy5ncmFwaC5nZXRWaWV3KCkuc2NhbGUsZD10aGlzLmdyYXBoLmdldFZpZXcoKS50cmFuc2xhdGU7dGhpcy5ncmFwaC5wYW5HcmFwaCgwLDApO3RoaXMucGFuR3JhcGgoZC54K3RoaXMuZHgvYyxkLnkrdGhpcy5keS9jKX1iLmNvbnN1bWUoKX10aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlBBTl9FTkQsImV2ZW50IixiKSl9dGhpcy5yZXNldCgpfTsKbXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUuem9vbUdyYXBoPWZ1bmN0aW9uKGEpe3ZhciBiPU1hdGgucm91bmQodGhpcy5pbml0aWFsU2NhbGUqYS5zY2FsZSoxMDApLzEwMDtudWxsIT10aGlzLm1pblNjYWxlJiYoYj1NYXRoLm1heCh0aGlzLm1pblNjYWxlLGIpKTtudWxsIT10aGlzLm1heFNjYWxlJiYoYj1NYXRoLm1pbih0aGlzLm1heFNjYWxlLGIpKTt0aGlzLmdyYXBoLnZpZXcuc2NhbGUhPWImJih0aGlzLmdyYXBoLnpvb21UbyhiKSxteEV2ZW50LmNvbnN1bWUoYSkpfTtteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMucGFubmluZ1RyaWdnZXI9ITE7dGhpcy5tb3VzZURvd25FdmVudD1udWxsO3RoaXMuYWN0aXZlPSExO3RoaXMuZHk9dGhpcy5keD1udWxsfTtteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5wYW5HcmFwaD1mdW5jdGlvbihhLGIpe3RoaXMuZ3JhcGguZ2V0VmlldygpLnNldFRyYW5zbGF0ZShhLGIpfTsKbXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZ3JhcGgucmVtb3ZlTW91c2VMaXN0ZW5lcih0aGlzKTt0aGlzLmdyYXBoLnJlbW92ZUxpc3RlbmVyKHRoaXMuZm9yY2VQYW5uaW5nSGFuZGxlcik7dGhpcy5ncmFwaC5yZW1vdmVMaXN0ZW5lcih0aGlzLmdlc3R1cmVIYW5kbGVyKTtteEV2ZW50LnJlbW92ZUxpc3RlbmVyKGRvY3VtZW50LCJtb3VzZXVwIix0aGlzLm1vdXNlVXBMaXN0ZW5lcil9OwpmdW5jdGlvbiBteFBvcHVwTWVudUhhbmRsZXIoYSxiKXtudWxsIT1hJiYodGhpcy5ncmFwaD1hLHRoaXMuZmFjdG9yeU1ldGhvZD1iLHRoaXMuZ3JhcGguYWRkTW91c2VMaXN0ZW5lcih0aGlzKSx0aGlzLmdlc3R1cmVIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYil7dGhpcy5pblRvbGVyYW5jZT0hMX0pLHRoaXMuZ3JhcGguYWRkTGlzdGVuZXIobXhFdmVudC5HRVNUVVJFLHRoaXMuZ2VzdHVyZUhhbmRsZXIpLHRoaXMuaW5pdCgpKX1teFBvcHVwTWVudUhhbmRsZXIucHJvdG90eXBlPW5ldyBteFBvcHVwTWVudTtteFBvcHVwTWVudUhhbmRsZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14UG9wdXBNZW51SGFuZGxlcjtteFBvcHVwTWVudUhhbmRsZXIucHJvdG90eXBlLmdyYXBoPW51bGw7bXhQb3B1cE1lbnVIYW5kbGVyLnByb3RvdHlwZS5zZWxlY3RPblBvcHVwPSEwOwpteFBvcHVwTWVudUhhbmRsZXIucHJvdG90eXBlLmNsZWFyU2VsZWN0aW9uT25CYWNrZ3JvdW5kPSEwO214UG9wdXBNZW51SGFuZGxlci5wcm90b3R5cGUudHJpZ2dlclg9bnVsbDtteFBvcHVwTWVudUhhbmRsZXIucHJvdG90eXBlLnRyaWdnZXJZPW51bGw7bXhQb3B1cE1lbnVIYW5kbGVyLnByb3RvdHlwZS5zY3JlZW5YPW51bGw7bXhQb3B1cE1lbnVIYW5kbGVyLnByb3RvdHlwZS5zY3JlZW5ZPW51bGw7bXhQb3B1cE1lbnVIYW5kbGVyLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7bXhQb3B1cE1lbnUucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcyk7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKHRoaXMuZGl2LG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuZ3JhcGgudG9vbHRpcEhhbmRsZXIuaGlkZSgpfSkpfTtteFBvcHVwTWVudUhhbmRsZXIucHJvdG90eXBlLmlzU2VsZWN0T25Qb3B1cD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5zZWxlY3RPblBvcHVwfTsKbXhQb3B1cE1lbnVIYW5kbGVyLnByb3RvdHlwZS5tb3VzZURvd249ZnVuY3Rpb24oYSxiKXt0aGlzLmlzRW5hYmxlZCgpJiYhbXhFdmVudC5pc011bHRpVG91Y2hFdmVudChiLmdldEV2ZW50KCkpJiYodGhpcy5oaWRlTWVudSgpLHRoaXMudHJpZ2dlclg9Yi5nZXRHcmFwaFgoKSx0aGlzLnRyaWdnZXJZPWIuZ2V0R3JhcGhZKCksdGhpcy5zY3JlZW5YPW14RXZlbnQuZ2V0TWFpbkV2ZW50KGIuZ2V0RXZlbnQoKSkuc2NyZWVuWCx0aGlzLnNjcmVlblk9bXhFdmVudC5nZXRNYWluRXZlbnQoYi5nZXRFdmVudCgpKS5zY3JlZW5ZLHRoaXMucG9wdXBUcmlnZ2VyPXRoaXMuaXNQb3B1cFRyaWdnZXIoYiksdGhpcy5pblRvbGVyYW5jZT0hMCl9OwpteFBvcHVwTWVudUhhbmRsZXIucHJvdG90eXBlLm1vdXNlTW92ZT1mdW5jdGlvbihhLGIpe3RoaXMuaW5Ub2xlcmFuY2UmJm51bGwhPXRoaXMuc2NyZWVuWCYmbnVsbCE9dGhpcy5zY3JlZW5ZJiYoTWF0aC5hYnMobXhFdmVudC5nZXRNYWluRXZlbnQoYi5nZXRFdmVudCgpKS5zY3JlZW5YLXRoaXMuc2NyZWVuWCk+dGhpcy5ncmFwaC50b2xlcmFuY2V8fE1hdGguYWJzKG14RXZlbnQuZ2V0TWFpbkV2ZW50KGIuZ2V0RXZlbnQoKSkuc2NyZWVuWS10aGlzLnNjcmVlblkpPnRoaXMuZ3JhcGgudG9sZXJhbmNlKSYmKHRoaXMuaW5Ub2xlcmFuY2U9ITEpfTsKbXhQb3B1cE1lbnVIYW5kbGVyLnByb3RvdHlwZS5tb3VzZVVwPWZ1bmN0aW9uKGEsYil7aWYodGhpcy5wb3B1cFRyaWdnZXImJnRoaXMuaW5Ub2xlcmFuY2UmJm51bGwhPXRoaXMudHJpZ2dlclgmJm51bGwhPXRoaXMudHJpZ2dlclkpe3ZhciBjPXRoaXMuZ2V0Q2VsbEZvclBvcHVwRXZlbnQoYik7dGhpcy5ncmFwaC5pc0VuYWJsZWQoKSYmdGhpcy5pc1NlbGVjdE9uUG9wdXAoYikmJm51bGwhPWMmJiF0aGlzLmdyYXBoLmlzQ2VsbFNlbGVjdGVkKGMpP3RoaXMuZ3JhcGguc2V0U2VsZWN0aW9uQ2VsbChjKTp0aGlzLmNsZWFyU2VsZWN0aW9uT25CYWNrZ3JvdW5kJiZudWxsPT1jJiZ0aGlzLmdyYXBoLmNsZWFyU2VsZWN0aW9uKCk7dGhpcy5ncmFwaC50b29sdGlwSGFuZGxlci5oaWRlKCk7dmFyIGQ9bXhVdGlscy5nZXRTY3JvbGxPcmlnaW4oKTt0aGlzLnBvcHVwKGIuZ2V0WCgpK2QueCsxLGIuZ2V0WSgpK2QueSsxLGMsYi5nZXRFdmVudCgpKTtiLmNvbnN1bWUoKX10aGlzLmluVG9sZXJhbmNlPQp0aGlzLnBvcHVwVHJpZ2dlcj0hMX07bXhQb3B1cE1lbnVIYW5kbGVyLnByb3RvdHlwZS5nZXRDZWxsRm9yUG9wdXBFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gYS5nZXRDZWxsKCl9O214UG9wdXBNZW51SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZ3JhcGgucmVtb3ZlTW91c2VMaXN0ZW5lcih0aGlzKTt0aGlzLmdyYXBoLnJlbW92ZUxpc3RlbmVyKHRoaXMuZ2VzdHVyZUhhbmRsZXIpO214UG9wdXBNZW51LnByb3RvdHlwZS5kZXN0cm95LmFwcGx5KHRoaXMpfTsKZnVuY3Rpb24gbXhDZWxsTWFya2VyKGEsYixjLGQpe214RXZlbnRTb3VyY2UuY2FsbCh0aGlzKTtudWxsIT1hJiYodGhpcy5ncmFwaD1hLHRoaXMudmFsaWRDb2xvcj1udWxsIT1iP2I6bXhDb25zdGFudHMuREVGQVVMVF9WQUxJRF9DT0xPUix0aGlzLmludmFsaWRDb2xvcj1udWxsIT1jP2M6bXhDb25zdGFudHMuREVGQVVMVF9JTlZBTElEX0NPTE9SLHRoaXMuaG90c3BvdD1udWxsIT1kP2Q6bXhDb25zdGFudHMuREVGQVVMVF9IT1RTUE9ULHRoaXMuaGlnaGxpZ2h0PW5ldyBteENlbGxIaWdobGlnaHQoYSkpfW14VXRpbHMuZXh0ZW5kKG14Q2VsbE1hcmtlcixteEV2ZW50U291cmNlKTtteENlbGxNYXJrZXIucHJvdG90eXBlLmdyYXBoPW51bGw7bXhDZWxsTWFya2VyLnByb3RvdHlwZS5lbmFibGVkPSEwO214Q2VsbE1hcmtlci5wcm90b3R5cGUuaG90c3BvdD1teENvbnN0YW50cy5ERUZBVUxUX0hPVFNQT1Q7bXhDZWxsTWFya2VyLnByb3RvdHlwZS5ob3RzcG90RW5hYmxlZD0hMTsKbXhDZWxsTWFya2VyLnByb3RvdHlwZS52YWxpZENvbG9yPW51bGw7bXhDZWxsTWFya2VyLnByb3RvdHlwZS5pbnZhbGlkQ29sb3I9bnVsbDtteENlbGxNYXJrZXIucHJvdG90eXBlLmN1cnJlbnRDb2xvcj1udWxsO214Q2VsbE1hcmtlci5wcm90b3R5cGUudmFsaWRTdGF0ZT1udWxsO214Q2VsbE1hcmtlci5wcm90b3R5cGUubWFya2VkU3RhdGU9bnVsbDtteENlbGxNYXJrZXIucHJvdG90eXBlLnNldEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5lbmFibGVkPWF9O214Q2VsbE1hcmtlci5wcm90b3R5cGUuaXNFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5hYmxlZH07bXhDZWxsTWFya2VyLnByb3RvdHlwZS5zZXRIb3RzcG90PWZ1bmN0aW9uKGEpe3RoaXMuaG90c3BvdD1hfTtteENlbGxNYXJrZXIucHJvdG90eXBlLmdldEhvdHNwb3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ob3RzcG90fTsKbXhDZWxsTWFya2VyLnByb3RvdHlwZS5zZXRIb3RzcG90RW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLmhvdHNwb3RFbmFibGVkPWF9O214Q2VsbE1hcmtlci5wcm90b3R5cGUuaXNIb3RzcG90RW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhvdHNwb3RFbmFibGVkfTtteENlbGxNYXJrZXIucHJvdG90eXBlLmhhc1ZhbGlkU3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy52YWxpZFN0YXRlfTtteENlbGxNYXJrZXIucHJvdG90eXBlLmdldFZhbGlkU3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWxpZFN0YXRlfTtteENlbGxNYXJrZXIucHJvdG90eXBlLmdldE1hcmtlZFN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFya2VkU3RhdGV9O214Q2VsbE1hcmtlci5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLnZhbGlkU3RhdGU9bnVsbDtudWxsIT10aGlzLm1hcmtlZFN0YXRlJiYodGhpcy5tYXJrZWRTdGF0ZT1udWxsLHRoaXMudW5tYXJrKCkpfTsKbXhDZWxsTWFya2VyLnByb3RvdHlwZS5wcm9jZXNzPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7dGhpcy5pc0VuYWJsZWQoKSYmKGI9dGhpcy5nZXRTdGF0ZShhKSx0aGlzLnNldEN1cnJlbnRTdGF0ZShiLGEpKTtyZXR1cm4gYn07bXhDZWxsTWFya2VyLnByb3RvdHlwZS5zZXRDdXJyZW50U3RhdGU9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPW51bGwhPWE/dGhpcy5pc1ZhbGlkU3RhdGUoYSk6ITE7Yz1udWxsIT1jP2M6dGhpcy5nZXRNYXJrZXJDb2xvcihiLmdldEV2ZW50KCksYSxkKTt0aGlzLnZhbGlkU3RhdGU9ZD9hOm51bGw7aWYoYSE9dGhpcy5tYXJrZWRTdGF0ZXx8YyE9dGhpcy5jdXJyZW50Q29sb3IpdGhpcy5jdXJyZW50Q29sb3I9YyxudWxsIT1hJiZudWxsIT10aGlzLmN1cnJlbnRDb2xvcj8odGhpcy5tYXJrZWRTdGF0ZT1hLHRoaXMubWFyaygpKTpudWxsIT10aGlzLm1hcmtlZFN0YXRlJiYodGhpcy5tYXJrZWRTdGF0ZT1udWxsLHRoaXMudW5tYXJrKCkpfTsKbXhDZWxsTWFya2VyLnByb3RvdHlwZS5tYXJrQ2VsbD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ3JhcGguZ2V0VmlldygpLmdldFN0YXRlKGEpO251bGwhPWMmJih0aGlzLmN1cnJlbnRDb2xvcj1udWxsIT1iP2I6dGhpcy52YWxpZENvbG9yLHRoaXMubWFya2VkU3RhdGU9Yyx0aGlzLm1hcmsoKSl9O214Q2VsbE1hcmtlci5wcm90b3R5cGUubWFyaz1mdW5jdGlvbigpe3RoaXMuaGlnaGxpZ2h0LnNldEhpZ2hsaWdodENvbG9yKHRoaXMuY3VycmVudENvbG9yKTt0aGlzLmhpZ2hsaWdodC5oaWdobGlnaHQodGhpcy5tYXJrZWRTdGF0ZSk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5NQVJLLCJzdGF0ZSIsdGhpcy5tYXJrZWRTdGF0ZSkpfTtteENlbGxNYXJrZXIucHJvdG90eXBlLnVubWFyaz1mdW5jdGlvbigpe3RoaXMubWFyaygpfTtteENlbGxNYXJrZXIucHJvdG90eXBlLmlzVmFsaWRTdGF0ZT1mdW5jdGlvbihhKXtyZXR1cm4hMH07Cm14Q2VsbE1hcmtlci5wcm90b3R5cGUuZ2V0TWFya2VyQ29sb3I9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBjP3RoaXMudmFsaWRDb2xvcjp0aGlzLmludmFsaWRDb2xvcn07bXhDZWxsTWFya2VyLnByb3RvdHlwZS5nZXRTdGF0ZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdyYXBoLmdldFZpZXcoKSxjPXRoaXMuZ2V0Q2VsbChhKSxiPXRoaXMuZ2V0U3RhdGVUb01hcmsoYi5nZXRTdGF0ZShjKSk7cmV0dXJuIG51bGwhPWImJnRoaXMuaW50ZXJzZWN0cyhiLGEpP2I6bnVsbH07bXhDZWxsTWFya2VyLnByb3RvdHlwZS5nZXRDZWxsPWZ1bmN0aW9uKGEpe3JldHVybiBhLmdldENlbGwoKX07bXhDZWxsTWFya2VyLnByb3RvdHlwZS5nZXRTdGF0ZVRvTWFyaz1mdW5jdGlvbihhKXtyZXR1cm4gYX07Cm14Q2VsbE1hcmtlci5wcm90b3R5cGUuaW50ZXJzZWN0cz1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmhvdHNwb3RFbmFibGVkP214VXRpbHMuaW50ZXJzZWN0c0hvdHNwb3QoYSxiLmdldEdyYXBoWCgpLGIuZ2V0R3JhcGhZKCksdGhpcy5ob3RzcG90LG14Q29uc3RhbnRzLk1JTl9IT1RTUE9UX1NJWkUsbXhDb25zdGFudHMuTUFYX0hPVFNQT1RfU0laRSk6ITB9O214Q2VsbE1hcmtlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZ3JhcGguZ2V0VmlldygpLnJlbW92ZUxpc3RlbmVyKHRoaXMucmVzZXRIYW5kbGVyKTt0aGlzLmdyYXBoLmdldE1vZGVsKCkucmVtb3ZlTGlzdGVuZXIodGhpcy5yZXNldEhhbmRsZXIpO3RoaXMuaGlnaGxpZ2h0LmRlc3Ryb3koKX07CmZ1bmN0aW9uIG14U2VsZWN0aW9uQ2VsbHNIYW5kbGVyKGEpe214RXZlbnRTb3VyY2UuY2FsbCh0aGlzKTt0aGlzLmdyYXBoPWE7dGhpcy5oYW5kbGVycz1uZXcgbXhEaWN0aW9uYXJ5O3RoaXMuZ3JhcGguYWRkTW91c2VMaXN0ZW5lcih0aGlzKTt0aGlzLnJlZnJlc2hIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7dGhpcy5pc0VuYWJsZWQoKSYmdGhpcy5yZWZyZXNoKCl9KTt0aGlzLmdyYXBoLmdldFNlbGVjdGlvbk1vZGVsKCkuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsdGhpcy5yZWZyZXNoSGFuZGxlcik7dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmFkZExpc3RlbmVyKG14RXZlbnQuQ0hBTkdFLHRoaXMucmVmcmVzaEhhbmRsZXIpO3RoaXMuZ3JhcGguZ2V0VmlldygpLmFkZExpc3RlbmVyKG14RXZlbnQuU0NBTEUsdGhpcy5yZWZyZXNoSGFuZGxlcik7dGhpcy5ncmFwaC5nZXRWaWV3KCkuYWRkTGlzdGVuZXIobXhFdmVudC5UUkFOU0xBVEUsdGhpcy5yZWZyZXNoSGFuZGxlcik7CnRoaXMuZ3JhcGguZ2V0VmlldygpLmFkZExpc3RlbmVyKG14RXZlbnQuU0NBTEVfQU5EX1RSQU5TTEFURSx0aGlzLnJlZnJlc2hIYW5kbGVyKTt0aGlzLmdyYXBoLmdldFZpZXcoKS5hZGRMaXN0ZW5lcihteEV2ZW50LkRPV04sdGhpcy5yZWZyZXNoSGFuZGxlcik7dGhpcy5ncmFwaC5nZXRWaWV3KCkuYWRkTGlzdGVuZXIobXhFdmVudC5VUCx0aGlzLnJlZnJlc2hIYW5kbGVyKX1teFV0aWxzLmV4dGVuZChteFNlbGVjdGlvbkNlbGxzSGFuZGxlcixteEV2ZW50U291cmNlKTtteFNlbGVjdGlvbkNlbGxzSGFuZGxlci5wcm90b3R5cGUuZ3JhcGg9bnVsbDtteFNlbGVjdGlvbkNlbGxzSGFuZGxlci5wcm90b3R5cGUuZW5hYmxlZD0hMDtteFNlbGVjdGlvbkNlbGxzSGFuZGxlci5wcm90b3R5cGUucmVmcmVzaEhhbmRsZXI9bnVsbDtteFNlbGVjdGlvbkNlbGxzSGFuZGxlci5wcm90b3R5cGUubWF4SGFuZGxlcnM9MTAwOwpteFNlbGVjdGlvbkNlbGxzSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlcnM9bnVsbDtteFNlbGVjdGlvbkNlbGxzSGFuZGxlci5wcm90b3R5cGUuaXNFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5hYmxlZH07bXhTZWxlY3Rpb25DZWxsc0hhbmRsZXIucHJvdG90eXBlLnNldEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5lbmFibGVkPWF9O214U2VsZWN0aW9uQ2VsbHNIYW5kbGVyLnByb3RvdHlwZS5nZXRIYW5kbGVyPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmhhbmRsZXJzLmdldChhKX07bXhTZWxlY3Rpb25DZWxsc0hhbmRsZXIucHJvdG90eXBlLmlzSGFuZGxlZD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9dGhpcy5nZXRIYW5kbGVyKGEpfTtteFNlbGVjdGlvbkNlbGxzSGFuZGxlci5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmhhbmRsZXJzLnZpc2l0KGZ1bmN0aW9uKGEsYil7Yi5yZXNldC5hcHBseShiKX0pfTsKbXhTZWxlY3Rpb25DZWxsc0hhbmRsZXIucHJvdG90eXBlLmdldEhhbmRsZWRTZWxlY3Rpb25DZWxscz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdyYXBoLmdldFNlbGVjdGlvbkNlbGxzKCl9OwpteFNlbGVjdGlvbkNlbGxzSGFuZGxlci5wcm90b3R5cGUucmVmcmVzaD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuaGFuZGxlcnM7dGhpcy5oYW5kbGVycz1uZXcgbXhEaWN0aW9uYXJ5O2Zvcih2YXIgYj1teFV0aWxzLnNvcnRDZWxscyh0aGlzLmdldEhhbmRsZWRTZWxlY3Rpb25DZWxscygpLCExKSxjPTA7YzxiLmxlbmd0aDtjKyspe3ZhciBkPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZShiW2NdKTtpZihudWxsIT1kKXt2YXIgZT1hLnJlbW92ZShiW2NdKTtudWxsIT1lJiYoZS5zdGF0ZSE9ZD8oZS5kZXN0cm95KCksZT1udWxsKTp0aGlzLmlzSGFuZGxlckFjdGl2ZShlKXx8KG51bGwhPWUucmVmcmVzaCYmZS5yZWZyZXNoKCksZS5yZWRyYXcoKSkpO251bGw9PWUmJihlPXRoaXMuZ3JhcGguY3JlYXRlSGFuZGxlcihkKSx0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkFERCwic3RhdGUiLGQpKSk7bnVsbCE9ZSYmdGhpcy5oYW5kbGVycy5wdXQoYltjXSxlKX19YS52aXNpdChteFV0aWxzLmJpbmQodGhpcywKZnVuY3Rpb24oYSxiKXt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlJFTU9WRSwic3RhdGUiLGIuc3RhdGUpKTtiLmRlc3Ryb3koKX0pKX07bXhTZWxlY3Rpb25DZWxsc0hhbmRsZXIucHJvdG90eXBlLmlzSGFuZGxlckFjdGl2ZT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YS5pbmRleH07bXhTZWxlY3Rpb25DZWxsc0hhbmRsZXIucHJvdG90eXBlLnVwZGF0ZUhhbmRsZXI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5oYW5kbGVycy5yZW1vdmUoYS5jZWxsKTtpZihudWxsIT1iKXt2YXIgYz1iLmluZGV4LGQ9Yi5zdGFydFgsZT1iLnN0YXJ0WTtiLmRlc3Ryb3koKTtiPXRoaXMuZ3JhcGguY3JlYXRlSGFuZGxlcihhKTtudWxsIT1iJiYodGhpcy5oYW5kbGVycy5wdXQoYS5jZWxsLGIpLG51bGwhPWMmJm51bGwhPWQmJm51bGwhPWUmJmIuc3RhcnQoZCxlLGMpKX19OwpteFNlbGVjdGlvbkNlbGxzSGFuZGxlci5wcm90b3R5cGUubW91c2VEb3duPWZ1bmN0aW9uKGEsYil7aWYodGhpcy5ncmFwaC5pc0VuYWJsZWQoKSYmdGhpcy5pc0VuYWJsZWQoKSl7dmFyIGM9W2EsYl07dGhpcy5oYW5kbGVycy52aXNpdChmdW5jdGlvbihhLGIpe2IubW91c2VEb3duLmFwcGx5KGIsYyl9KX19O214U2VsZWN0aW9uQ2VsbHNIYW5kbGVyLnByb3RvdHlwZS5tb3VzZU1vdmU9ZnVuY3Rpb24oYSxiKXtpZih0aGlzLmdyYXBoLmlzRW5hYmxlZCgpJiZ0aGlzLmlzRW5hYmxlZCgpKXt2YXIgYz1bYSxiXTt0aGlzLmhhbmRsZXJzLnZpc2l0KGZ1bmN0aW9uKGEsYil7Yi5tb3VzZU1vdmUuYXBwbHkoYixjKX0pfX07Cm14U2VsZWN0aW9uQ2VsbHNIYW5kbGVyLnByb3RvdHlwZS5tb3VzZVVwPWZ1bmN0aW9uKGEsYil7aWYodGhpcy5ncmFwaC5pc0VuYWJsZWQoKSYmdGhpcy5pc0VuYWJsZWQoKSl7dmFyIGM9W2EsYl07dGhpcy5oYW5kbGVycy52aXNpdChmdW5jdGlvbihhLGIpe2IubW91c2VVcC5hcHBseShiLGMpfSl9fTtteFNlbGVjdGlvbkNlbGxzSGFuZGxlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZ3JhcGgucmVtb3ZlTW91c2VMaXN0ZW5lcih0aGlzKTtudWxsIT10aGlzLnJlZnJlc2hIYW5kbGVyJiYodGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25Nb2RlbCgpLnJlbW92ZUxpc3RlbmVyKHRoaXMucmVmcmVzaEhhbmRsZXIpLHRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5yZW1vdmVMaXN0ZW5lcih0aGlzLnJlZnJlc2hIYW5kbGVyKSx0aGlzLmdyYXBoLmdldFZpZXcoKS5yZW1vdmVMaXN0ZW5lcih0aGlzLnJlZnJlc2hIYW5kbGVyKSx0aGlzLnJlZnJlc2hIYW5kbGVyPW51bGwpfTsKZnVuY3Rpb24gbXhDb25uZWN0aW9uSGFuZGxlcihhLGIpe214RXZlbnRTb3VyY2UuY2FsbCh0aGlzKTtudWxsIT1hJiYodGhpcy5ncmFwaD1hLHRoaXMuZmFjdG9yeU1ldGhvZD1iLHRoaXMuaW5pdCgpLHRoaXMuZXNjYXBlSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIpe3RoaXMucmVzZXQoKX0pLHRoaXMuZ3JhcGguYWRkTGlzdGVuZXIobXhFdmVudC5FU0NBUEUsdGhpcy5lc2NhcGVIYW5kbGVyKSl9bXhVdGlscy5leHRlbmQobXhDb25uZWN0aW9uSGFuZGxlcixteEV2ZW50U291cmNlKTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5ncmFwaD1udWxsO214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmZhY3RvcnlNZXRob2Q9ITA7bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUubW92ZUljb25Gcm9udD0hMTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5tb3ZlSWNvbkJhY2s9ITE7Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmNvbm5lY3RJbWFnZT1udWxsO214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLnRhcmdldENvbm5lY3RJbWFnZT0hMTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5lbmFibGVkPSEwO214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLnNlbGVjdD0hMDtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVUYXJnZXQ9ITE7bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUubWFya2VyPW51bGw7bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY29uc3RyYWludEhhbmRsZXI9bnVsbDtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5lcnJvcj1udWxsO214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLndheXBvaW50c0VuYWJsZWQ9ITE7bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuaWdub3JlTW91c2VEb3duPSExO214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmZpcnN0PW51bGw7Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmNvbm5lY3RJY29uT2Zmc2V0PW5ldyBteFBvaW50KDAsbXhDb25zdGFudHMuVE9PTFRJUF9WRVJUSUNBTF9PRkZTRVQpO214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmVkZ2VTdGF0ZT1udWxsO214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmNoYW5nZUhhbmRsZXI9bnVsbDtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5kcmlsbEhhbmRsZXI9bnVsbDtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5tb3VzZURvd25Db3VudGVyPTA7bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUubW92ZVByZXZpZXdBd2F5PW14Q2xpZW50LklTX1ZNTDtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5vdXRsaW5lQ29ubmVjdD0hMTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5saXZlUHJldmlldz0hMTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5jdXJzb3I9bnVsbDsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlU291cmNlPSExO214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmlzRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuYWJsZWR9O214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLnNldEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5lbmFibGVkPWF9O214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmlzSW5zZXJ0QmVmb3JlPWZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlU291cmNlJiZiIT1jfTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5pc0NyZWF0ZVRhcmdldD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5jcmVhdGVUYXJnZXR9O214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLnNldENyZWF0ZVRhcmdldD1mdW5jdGlvbihhKXt0aGlzLmNyZWF0ZVRhcmdldD1hfTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlU2hhcGU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmxpdmVQcmV2aWV3JiZudWxsIT10aGlzLmVkZ2VTdGF0ZT90aGlzLmdyYXBoLmNlbGxSZW5kZXJlci5jcmVhdGVTaGFwZSh0aGlzLmVkZ2VTdGF0ZSk6bmV3IG14UG9seWxpbmUoW10sbXhDb25zdGFudHMuSU5WQUxJRF9DT0xPUik7YS5kaWFsZWN0PXRoaXMuZ3JhcGguZGlhbGVjdCE9bXhDb25zdGFudHMuRElBTEVDVF9TVkc/bXhDb25zdGFudHMuRElBTEVDVF9WTUw6bXhDb25zdGFudHMuRElBTEVDVF9TVkc7YS5zY2FsZT10aGlzLmdyYXBoLnZpZXcuc2NhbGU7YS5wb2ludGVyRXZlbnRzPSExO2EuaXNEYXNoZWQ9ITA7YS5pbml0KHRoaXMuZ3JhcGguZ2V0VmlldygpLmdldE92ZXJsYXlQYW5lKCkpO214RXZlbnQucmVkaXJlY3RNb3VzZUV2ZW50cyhhLm5vZGUsdGhpcy5ncmFwaCxudWxsKTtyZXR1cm4gYX07Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oKXt0aGlzLmdyYXBoLmFkZE1vdXNlTGlzdGVuZXIodGhpcyk7dGhpcy5tYXJrZXI9dGhpcy5jcmVhdGVNYXJrZXIoKTt0aGlzLmNvbnN0cmFpbnRIYW5kbGVyPW5ldyBteENvbnN0cmFpbnRIYW5kbGVyKHRoaXMuZ3JhcGgpO3RoaXMuY2hhbmdlSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsIT10aGlzLmljb25TdGF0ZSYmKHRoaXMuaWNvblN0YXRlPXRoaXMuZ3JhcGguZ2V0VmlldygpLmdldFN0YXRlKHRoaXMuaWNvblN0YXRlLmNlbGwpKTtudWxsIT10aGlzLmljb25TdGF0ZT8odGhpcy5yZWRyYXdJY29ucyh0aGlzLmljb25zLHRoaXMuaWNvblN0YXRlKSx0aGlzLmNvbnN0cmFpbnRIYW5kbGVyLnJlc2V0KCkpOm51bGwhPXRoaXMucHJldmlvdXMmJm51bGw9PXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZSh0aGlzLnByZXZpb3VzLmNlbGwpJiZ0aGlzLnJlc2V0KCl9KTt0aGlzLmdyYXBoLmdldE1vZGVsKCkuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsCnRoaXMuY2hhbmdlSGFuZGxlcik7dGhpcy5ncmFwaC5nZXRWaWV3KCkuYWRkTGlzdGVuZXIobXhFdmVudC5TQ0FMRSx0aGlzLmNoYW5nZUhhbmRsZXIpO3RoaXMuZ3JhcGguZ2V0VmlldygpLmFkZExpc3RlbmVyKG14RXZlbnQuVFJBTlNMQVRFLHRoaXMuY2hhbmdlSGFuZGxlcik7dGhpcy5ncmFwaC5nZXRWaWV3KCkuYWRkTGlzdGVuZXIobXhFdmVudC5TQ0FMRV9BTkRfVFJBTlNMQVRFLHRoaXMuY2hhbmdlSGFuZGxlcik7dGhpcy5kcmlsbEhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5yZXNldCgpfSk7dGhpcy5ncmFwaC5hZGRMaXN0ZW5lcihteEV2ZW50LlNUQVJUX0VESVRJTkcsdGhpcy5kcmlsbEhhbmRsZXIpO3RoaXMuZ3JhcGguZ2V0VmlldygpLmFkZExpc3RlbmVyKG14RXZlbnQuRE9XTix0aGlzLmRyaWxsSGFuZGxlcik7dGhpcy5ncmFwaC5nZXRWaWV3KCkuYWRkTGlzdGVuZXIobXhFdmVudC5VUCx0aGlzLmRyaWxsSGFuZGxlcil9OwpteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5pc0Nvbm5lY3RhYmxlQ2VsbD1mdW5jdGlvbihhKXtyZXR1cm4hMH07Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZU1hcmtlcj1mdW5jdGlvbigpe3ZhciBhPW5ldyBteENlbGxNYXJrZXIodGhpcy5ncmFwaCk7YS5ob3RzcG90RW5hYmxlZD0hMDthLmdldENlbGw9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7dmFyIGM9bXhDZWxsTWFya2VyLnByb3RvdHlwZS5nZXRDZWxsLmFwcGx5KGEsYXJndW1lbnRzKTt0aGlzLmVycm9yPW51bGw7bnVsbD09YyYmbnVsbCE9dGhpcy5jdXJyZW50UG9pbnQmJihjPXRoaXMuZ3JhcGguZ2V0Q2VsbEF0KHRoaXMuY3VycmVudFBvaW50LngsdGhpcy5jdXJyZW50UG9pbnQueSkpO2lmKG51bGwhPWMmJiF0aGlzLmdyYXBoLmlzQ2VsbENvbm5lY3RhYmxlKGMpKXt2YXIgZD10aGlzLmdyYXBoLmdldE1vZGVsKCkuZ2V0UGFyZW50KGMpO3RoaXMuZ3JhcGguZ2V0TW9kZWwoKS5pc1ZlcnRleChkKSYmdGhpcy5ncmFwaC5pc0NlbGxDb25uZWN0YWJsZShkKSYmKGM9ZCl9aWYodGhpcy5ncmFwaC5pc1N3aW1sYW5lKGMpJiYKbnVsbCE9dGhpcy5jdXJyZW50UG9pbnQmJnRoaXMuZ3JhcGguaGl0c1N3aW1sYW5lQ29udGVudChjLHRoaXMuY3VycmVudFBvaW50LngsdGhpcy5jdXJyZW50UG9pbnQueSl8fCF0aGlzLmlzQ29ubmVjdGFibGVDZWxsKGMpKWM9bnVsbDtudWxsIT1jP3RoaXMuaXNDb25uZWN0aW5nKCk/bnVsbCE9dGhpcy5wcmV2aW91cyYmKHRoaXMuZXJyb3I9dGhpcy52YWxpZGF0ZUNvbm5lY3Rpb24odGhpcy5wcmV2aW91cy5jZWxsLGMpLG51bGwhPXRoaXMuZXJyb3ImJjA9PXRoaXMuZXJyb3IubGVuZ3RoJiYoYz1udWxsLHRoaXMuaXNDcmVhdGVUYXJnZXQoYi5nZXRFdmVudCgpKSYmKHRoaXMuZXJyb3I9bnVsbCkpKTp0aGlzLmlzVmFsaWRTb3VyY2UoYyxiKXx8KGM9bnVsbCk6IXRoaXMuaXNDb25uZWN0aW5nKCl8fHRoaXMuaXNDcmVhdGVUYXJnZXQoYi5nZXRFdmVudCgpKXx8dGhpcy5ncmFwaC5hbGxvd0RhbmdsaW5nRWRnZXN8fCh0aGlzLmVycm9yPSIiKTtyZXR1cm4gY30pO2EuaXNWYWxpZFN0YXRlPQpteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXtyZXR1cm4gdGhpcy5pc0Nvbm5lY3RpbmcoKT9udWxsPT10aGlzLmVycm9yOm14Q2VsbE1hcmtlci5wcm90b3R5cGUuaXNWYWxpZFN0YXRlLmFwcGx5KGEsYXJndW1lbnRzKX0pO2EuZ2V0TWFya2VyQ29sb3I9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYixjLGQpe3JldHVybiBudWxsPT10aGlzLmNvbm5lY3RJbWFnZXx8dGhpcy5pc0Nvbm5lY3RpbmcoKT9teENlbGxNYXJrZXIucHJvdG90eXBlLmdldE1hcmtlckNvbG9yLmFwcGx5KGEsYXJndW1lbnRzKTpudWxsfSk7YS5pbnRlcnNlY3RzPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIsYyl7cmV0dXJuIG51bGwhPXRoaXMuY29ubmVjdEltYWdlfHx0aGlzLmlzQ29ubmVjdGluZygpPyEwOm14Q2VsbE1hcmtlci5wcm90b3R5cGUuaW50ZXJzZWN0cy5hcHBseShhLGFyZ3VtZW50cyl9KTtyZXR1cm4gYX07Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMucHJldmlvdXM9YTt0aGlzLmZpcnN0PW5ldyBteFBvaW50KGIsYyk7dGhpcy5lZGdlU3RhdGU9bnVsbCE9ZD9kOnRoaXMuY3JlYXRlRWRnZVN0YXRlKG51bGwpO3RoaXMubWFya2VyLmN1cnJlbnRDb2xvcj10aGlzLm1hcmtlci52YWxpZENvbG9yO3RoaXMubWFya2VyLm1hcmtlZFN0YXRlPWE7dGhpcy5tYXJrZXIubWFyaygpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuU1RBUlQsInN0YXRlIix0aGlzLnByZXZpb3VzKSl9O214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmlzQ29ubmVjdGluZz1mdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLmZpcnN0JiZudWxsIT10aGlzLnNoYXBlfTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5pc1ZhbGlkU291cmNlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuZ3JhcGguaXNWYWxpZFNvdXJjZShhKX07Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmlzVmFsaWRUYXJnZXQ9ZnVuY3Rpb24oYSl7cmV0dXJuITB9O214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLnZhbGlkYXRlQ29ubmVjdGlvbj1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmlzVmFsaWRUYXJnZXQoYik/dGhpcy5ncmFwaC5nZXRFZGdlVmFsaWRhdGlvbkVycm9yKG51bGwsYSxiKToiIn07bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuZ2V0Q29ubmVjdEltYWdlPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmNvbm5lY3RJbWFnZX07bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuaXNNb3ZlSWNvblRvRnJvbnRGb3JTdGF0ZT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YS50ZXh0JiZhLnRleHQubm9kZS5wYXJlbnROb2RlPT10aGlzLmdyYXBoLmNvbnRhaW5lcj8hMDp0aGlzLm1vdmVJY29uRnJvbnR9OwpteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVJY29ucz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdldENvbm5lY3RJbWFnZShhKTtpZihudWxsIT1iJiZudWxsIT1hKXt0aGlzLmljb25TdGF0ZT1hO3ZhciBjPVtdLGQ9bmV3IG14UmVjdGFuZ2xlKDAsMCxiLndpZHRoLGIuaGVpZ2h0KSxlPW5ldyBteEltYWdlU2hhcGUoZCxiLnNyYyxudWxsLG51bGwsMCk7ZS5wcmVzZXJ2ZUltYWdlQXNwZWN0PSExO3RoaXMuaXNNb3ZlSWNvblRvRnJvbnRGb3JTdGF0ZShhKT8oZS5kaWFsZWN0PW14Q29uc3RhbnRzLkRJQUxFQ1RfU1RSSUNUSFRNTCxlLmluaXQodGhpcy5ncmFwaC5jb250YWluZXIpKTooZS5kaWFsZWN0PXRoaXMuZ3JhcGguZGlhbGVjdD09bXhDb25zdGFudHMuRElBTEVDVF9TVkc/bXhDb25zdGFudHMuRElBTEVDVF9TVkc6bXhDb25zdGFudHMuRElBTEVDVF9WTUwsZS5pbml0KHRoaXMuZ3JhcGguZ2V0VmlldygpLmdldE92ZXJsYXlQYW5lKCkpLHRoaXMubW92ZUljb25CYWNrJiYKbnVsbCE9ZS5ub2RlLnByZXZpb3VzU2libGluZyYmZS5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUubm9kZSxlLm5vZGUucGFyZW50Tm9kZS5maXJzdENoaWxkKSk7ZS5ub2RlLnN0eWxlLmN1cnNvcj1teENvbnN0YW50cy5DVVJTT1JfQ09OTkVDVDt2YXIgZj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLmN1cnJlbnRTdGF0ZT90aGlzLmN1cnJlbnRTdGF0ZTphfSksYj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtteEV2ZW50LmlzQ29uc3VtZWQoYSl8fCh0aGlzLmljb249ZSx0aGlzLmdyYXBoLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfRE9XTixuZXcgbXhNb3VzZUV2ZW50KGEsZigpKSkpfSk7bXhFdmVudC5yZWRpcmVjdE1vdXNlRXZlbnRzKGUubm9kZSx0aGlzLmdyYXBoLGYsYik7Yy5wdXNoKGUpO3RoaXMucmVkcmF3SWNvbnMoYyx0aGlzLmljb25TdGF0ZSk7cmV0dXJuIGN9cmV0dXJuIG51bGx9OwpteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5yZWRyYXdJY29ucz1mdW5jdGlvbihhLGIpe2lmKG51bGwhPWEmJm51bGwhPWFbMF0mJm51bGwhPWIpe3ZhciBjPXRoaXMuZ2V0SWNvblBvc2l0aW9uKGFbMF0sYik7YVswXS5ib3VuZHMueD1jLng7YVswXS5ib3VuZHMueT1jLnk7YVswXS5yZWRyYXcoKX19OwpteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5nZXRJY29uUG9zaXRpb249ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdyYXBoLmdldFZpZXcoKS5zY2FsZSxkPWIuZ2V0Q2VudGVyWCgpLGU9Yi5nZXRDZW50ZXJZKCk7aWYodGhpcy5ncmFwaC5pc1N3aW1sYW5lKGIuY2VsbCkpe3ZhciBmPXRoaXMuZ3JhcGguZ2V0U3RhcnRTaXplKGIuY2VsbCksZD0wIT1mLndpZHRoP2IueCtmLndpZHRoKmMvMjpkLGU9MCE9Zi5oZWlnaHQ/Yi55K2YuaGVpZ2h0KmMvMjplLGY9bXhVdGlscy50b1JhZGlhbnMobXhVdGlscy5nZXRWYWx1ZShiLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OKXx8MCk7aWYoMCE9Zil2YXIgYz1NYXRoLmNvcyhmKSxmPU1hdGguc2luKGYpLGc9bmV3IG14UG9pbnQoYi5nZXRDZW50ZXJYKCksYi5nZXRDZW50ZXJZKCkpLGU9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQobmV3IG14UG9pbnQoZCxlKSxjLGYsZyksZD1lLngsZT1lLnl9cmV0dXJuIG5ldyBteFBvaW50KGQtCmEuYm91bmRzLndpZHRoLzIsZS1hLmJvdW5kcy5oZWlnaHQvMil9O214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3lJY29ucz1mdW5jdGlvbigpe2lmKG51bGwhPXRoaXMuaWNvbnMpe2Zvcih2YXIgYT0wO2E8dGhpcy5pY29ucy5sZW5ndGg7YSsrKXRoaXMuaWNvbnNbYV0uZGVzdHJveSgpO3RoaXMuaWNvblN0YXRlPXRoaXMuc2VsZWN0ZWRJY29uPXRoaXMuaWNvbj10aGlzLmljb25zPW51bGx9fTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5pc1N0YXJ0RXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudEZvY3VzJiZudWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRDb25zdHJhaW50fHxudWxsIT10aGlzLnByZXZpb3VzJiZudWxsPT10aGlzLmVycm9yJiYobnVsbD09dGhpcy5pY29uc3x8bnVsbCE9dGhpcy5pY29ucyYmbnVsbCE9dGhpcy5pY29uKX07Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLm1vdXNlRG93bj1mdW5jdGlvbihhLGIpe3RoaXMubW91c2VEb3duQ291bnRlcisrO2lmKHRoaXMuaXNFbmFibGVkKCkmJnRoaXMuZ3JhcGguaXNFbmFibGVkKCkmJiFiLmlzQ29uc3VtZWQoKSYmIXRoaXMuaXNDb25uZWN0aW5nKCkmJnRoaXMuaXNTdGFydEV2ZW50KGIpKXtudWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRDb25zdHJhaW50JiZudWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRGb2N1cyYmbnVsbCE9dGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50UG9pbnQ/KHRoaXMuc291cmNlQ29uc3RyYWludD10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRDb25zdHJhaW50LHRoaXMucHJldmlvdXM9dGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Rm9jdXMsdGhpcy5maXJzdD10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRQb2ludC5jbG9uZSgpKTp0aGlzLmZpcnN0PW5ldyBteFBvaW50KGIuZ2V0R3JhcGhYKCksCmIuZ2V0R3JhcGhZKCkpO3RoaXMuZWRnZVN0YXRlPXRoaXMuY3JlYXRlRWRnZVN0YXRlKGIpO3RoaXMubW91c2VEb3duQ291bnRlcj0xO3RoaXMud2F5cG9pbnRzRW5hYmxlZCYmbnVsbD09dGhpcy5zaGFwZSYmKHRoaXMud2F5cG9pbnRzPW51bGwsdGhpcy5zaGFwZT10aGlzLmNyZWF0ZVNoYXBlKCksbnVsbCE9dGhpcy5lZGdlU3RhdGUmJnRoaXMuc2hhcGUuYXBwbHkodGhpcy5lZGdlU3RhdGUpKTtpZihudWxsPT10aGlzLnByZXZpb3VzJiZudWxsIT10aGlzLmVkZ2VTdGF0ZSl7dmFyIGM9dGhpcy5ncmFwaC5nZXRQb2ludEZvckV2ZW50KGIuZ2V0RXZlbnQoKSk7dGhpcy5lZGdlU3RhdGUuY2VsbC5nZW9tZXRyeS5zZXRUZXJtaW5hbFBvaW50KGMsITApfXRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuU1RBUlQsInN0YXRlIix0aGlzLnByZXZpb3VzKSk7Yi5jb25zdW1lKCl9dGhpcy5zZWxlY3RlZEljb249dGhpcy5pY29uO3RoaXMuaWNvbj1udWxsfTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuaXNJbW1lZGlhdGVDb25uZWN0U291cmNlPWZ1bmN0aW9uKGEpe3JldHVybiF0aGlzLmdyYXBoLmlzQ2VsbE1vdmFibGUoYS5jZWxsKX07bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlRWRnZVN0YXRlPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsfTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuaXNPdXRsaW5lQ29ubmVjdEV2ZW50PWZ1bmN0aW9uKGEpe3ZhciBiPW14VXRpbHMuZ2V0T2Zmc2V0KHRoaXMuZ3JhcGguY29udGFpbmVyKSxjPWEuZ2V0RXZlbnQoKSxkPW14RXZlbnQuZ2V0Q2xpZW50WChjKSxjPW14RXZlbnQuZ2V0Q2xpZW50WShjKSxlPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxmPXRoaXMuY3VycmVudFBvaW50LngtdGhpcy5ncmFwaC5jb250YWluZXIuc2Nyb2xsTGVmdCtiLngtKCh3aW5kb3cucGFnZVhPZmZzZXR8fGUuc2Nyb2xsTGVmdCktKGUuY2xpZW50TGVmdHx8MCkpLGI9dGhpcy5jdXJyZW50UG9pbnQueS10aGlzLmdyYXBoLmNvbnRhaW5lci5zY3JvbGxUb3ArYi55LSgod2luZG93LnBhZ2VZT2Zmc2V0fHxlLnNjcm9sbFRvcCktKGUuY2xpZW50VG9wfHwwKSk7cmV0dXJuIHRoaXMub3V0bGluZUNvbm5lY3QmJiFteEV2ZW50LmlzU2hpZnREb3duKGEuZ2V0RXZlbnQoKSkmJihhLmlzU291cmNlKHRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZSl8fApteEV2ZW50LmlzQWx0RG93bihhLmdldEV2ZW50KCkpJiZudWxsIT1hLmdldFN0YXRlKCl8fHRoaXMubWFya2VyLmhpZ2hsaWdodC5pc0hpZ2hsaWdodEF0KGQsYyl8fChmIT1kfHxiIT1jKSYmbnVsbD09YS5nZXRTdGF0ZSgpJiZ0aGlzLm1hcmtlci5oaWdobGlnaHQuaXNIaWdobGlnaHRBdChmLGIpKX07Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZUN1cnJlbnRTdGF0ZT1mdW5jdGlvbihhLGIpe3RoaXMuY29uc3RyYWludEhhbmRsZXIudXBkYXRlKGEsbnVsbD09dGhpcy5maXJzdCwhMSxudWxsPT10aGlzLmZpcnN0fHxhLmlzU291cmNlKHRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZSk/bnVsbDpiKTtpZihudWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRGb2N1cyYmbnVsbCE9dGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Q29uc3RyYWludCludWxsIT10aGlzLm1hcmtlci5oaWdobGlnaHQmJm51bGwhPXRoaXMubWFya2VyLmhpZ2hsaWdodC5zdGF0ZSYmdGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnN0YXRlLmNlbGw9PXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudEZvY3VzLmNlbGw/InRyYW5zcGFyZW50IiE9dGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnNoYXBlLnN0cm9rZSYmKHRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZS5zdHJva2U9InRyYW5zcGFyZW50IiwKdGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnJlcGFpbnQoKSk6dGhpcy5tYXJrZXIubWFya0NlbGwodGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Rm9jdXMuY2VsbCwidHJhbnNwYXJlbnQiKSxudWxsIT10aGlzLnByZXZpb3VzJiYodGhpcy5lcnJvcj10aGlzLnZhbGlkYXRlQ29ubmVjdGlvbih0aGlzLnByZXZpb3VzLmNlbGwsdGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Rm9jdXMuY2VsbCksbnVsbD09dGhpcy5lcnJvciYmKHRoaXMuY3VycmVudFN0YXRlPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudEZvY3VzKSwobnVsbCE9dGhpcy5lcnJvcnx8bnVsbCE9dGhpcy5jdXJyZW50U3RhdGUmJiF0aGlzLmlzQ2VsbEVuYWJsZWQodGhpcy5jdXJyZW50U3RhdGUuY2VsbCkpJiZ0aGlzLmNvbnN0cmFpbnRIYW5kbGVyLnJlc2V0KCkpO2Vsc2V7dGhpcy5ncmFwaC5pc0lnbm9yZVRlcm1pbmFsRXZlbnQoYS5nZXRFdmVudCgpKT8odGhpcy5tYXJrZXIucmVzZXQoKSx0aGlzLmN1cnJlbnRTdGF0ZT0KbnVsbCk6KHRoaXMubWFya2VyLnByb2Nlc3MoYSksdGhpcy5jdXJyZW50U3RhdGU9dGhpcy5tYXJrZXIuZ2V0VmFsaWRTdGF0ZSgpKTtudWxsPT10aGlzLmN1cnJlbnRTdGF0ZXx8dGhpcy5pc0NlbGxFbmFibGVkKHRoaXMuY3VycmVudFN0YXRlLmNlbGwpfHwodGhpcy5jb25zdHJhaW50SGFuZGxlci5yZXNldCgpLHRoaXMubWFya2VyLnJlc2V0KCksdGhpcy5jdXJyZW50U3RhdGU9bnVsbCk7dmFyIGM9dGhpcy5pc091dGxpbmVDb25uZWN0RXZlbnQoYSk7bnVsbCE9dGhpcy5jdXJyZW50U3RhdGUmJmMmJihhLmlzU291cmNlKHRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZSkmJihiPW5ldyBteFBvaW50KGEuZ2V0R3JhcGhYKCksYS5nZXRHcmFwaFkoKSkpLGM9dGhpcy5ncmFwaC5nZXRPdXRsaW5lQ29uc3RyYWludChiLHRoaXMuY3VycmVudFN0YXRlLGEpLHRoaXMuY29uc3RyYWludEhhbmRsZXIuc2V0Rm9jdXMoYSx0aGlzLmN1cnJlbnRTdGF0ZSwhMSksdGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Q29uc3RyYWludD0KYyx0aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRQb2ludD1iKTt0aGlzLm91dGxpbmVDb25uZWN0JiZudWxsIT10aGlzLm1hcmtlci5oaWdobGlnaHQmJm51bGwhPXRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZSYmKGM9dGhpcy5ncmFwaC52aWV3LnNjYWxlLG51bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudENvbnN0cmFpbnQmJm51bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudEZvY3VzPyh0aGlzLm1hcmtlci5oaWdobGlnaHQuc2hhcGUuc3Ryb2tlPW14Q29uc3RhbnRzLk9VVExJTkVfSElHSExJR0hUX0NPTE9SLHRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZS5zdHJva2V3aWR0aD1teENvbnN0YW50cy5PVVRMSU5FX0hJR0hMSUdIVF9TVFJPS0VXSURUSC9jL2MsdGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnJlcGFpbnQoKSk6dGhpcy5tYXJrZXIuaGFzVmFsaWRTdGF0ZSgpJiYodGhpcy5ncmFwaC5pc0NlbGxDb25uZWN0YWJsZShhLmdldENlbGwoKSkmJgp0aGlzLm1hcmtlci5nZXRWYWxpZFN0YXRlKCkhPWEuZ2V0U3RhdGUoKT8odGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnNoYXBlLnN0cm9rZT0idHJhbnNwYXJlbnQiLHRoaXMuY3VycmVudFN0YXRlPW51bGwpOnRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZS5zdHJva2U9bXhDb25zdGFudHMuREVGQVVMVF9WQUxJRF9DT0xPUix0aGlzLm1hcmtlci5oaWdobGlnaHQuc2hhcGUuc3Ryb2tld2lkdGg9bXhDb25zdGFudHMuSElHSExJR0hUX1NUUk9LRVdJRFRIL2MvYyx0aGlzLm1hcmtlci5oaWdobGlnaHQucmVwYWludCgpKSl9fTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5pc0NlbGxFbmFibGVkPWZ1bmN0aW9uKGEpe3JldHVybiEwfTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY29udmVydFdheXBvaW50PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ3JhcGguZ2V0VmlldygpLmdldFNjYWxlKCksYz10aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRUcmFuc2xhdGUoKTthLng9YS54L2ItYy54O2EueT1hLnkvYi1jLnl9OwpteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5zbmFwVG9QcmV2aWV3PWZ1bmN0aW9uKGEsYil7aWYoIW14RXZlbnQuaXNBbHREb3duKGEuZ2V0RXZlbnQoKSkmJm51bGwhPXRoaXMucHJldmlvdXMpe3ZhciBjPXRoaXMuZ3JhcGguZ3JpZFNpemUqdGhpcy5ncmFwaC52aWV3LnNjYWxlLzIsZD1udWxsIT10aGlzLnNvdXJjZUNvbnN0cmFpbnQ/dGhpcy5maXJzdDpuZXcgbXhQb2ludCh0aGlzLnByZXZpb3VzLmdldENlbnRlclgoKSx0aGlzLnByZXZpb3VzLmdldENlbnRlclkoKSk7TWF0aC5hYnMoZC54LWEuZ2V0R3JhcGhYKCkpPGMmJihiLng9ZC54KTtNYXRoLmFicyhkLnktYS5nZXRHcmFwaFkoKSk8YyYmKGIueT1kLnkpfX07Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLm1vdXNlTW92ZT1mdW5jdGlvbihhLGIpe2lmKGIuaXNDb25zdW1lZCgpfHwhdGhpcy5pZ25vcmVNb3VzZURvd24mJm51bGw9PXRoaXMuZmlyc3QmJnRoaXMuZ3JhcGguaXNNb3VzZURvd24pdGhpcy5jb25zdHJhaW50SGFuZGxlci5yZXNldCgpO2Vsc2V7dGhpcy5pc0VuYWJsZWQoKXx8bnVsbD09dGhpcy5jdXJyZW50U3RhdGV8fCh0aGlzLmRlc3Ryb3lJY29ucygpLHRoaXMuY3VycmVudFN0YXRlPW51bGwpO3ZhciBjPXRoaXMuZ3JhcGguZ2V0VmlldygpLGQ9Yy5zY2FsZSxlPWMudHJhbnNsYXRlLGM9bmV3IG14UG9pbnQoYi5nZXRHcmFwaFgoKSxiLmdldEdyYXBoWSgpKTt0aGlzLmVycm9yPW51bGw7dGhpcy5ncmFwaC5pc0dyaWRFbmFibGVkRXZlbnQoYi5nZXRFdmVudCgpKSYmKGM9bmV3IG14UG9pbnQoKHRoaXMuZ3JhcGguc25hcChjLngvZC1lLngpK2UueCkqZCwodGhpcy5ncmFwaC5zbmFwKGMueS9kLWUueSkrZS55KSpkKSk7CnRoaXMuc25hcFRvUHJldmlldyhiLGMpO3RoaXMuY3VycmVudFBvaW50PWM7KG51bGwhPXRoaXMuZmlyc3R8fHRoaXMuaXNFbmFibGVkKCkmJnRoaXMuZ3JhcGguaXNFbmFibGVkKCkpJiYobnVsbCE9dGhpcy5zaGFwZXx8bnVsbD09dGhpcy5maXJzdHx8TWF0aC5hYnMoYi5nZXRHcmFwaFgoKS10aGlzLmZpcnN0LngpPnRoaXMuZ3JhcGgudG9sZXJhbmNlfHxNYXRoLmFicyhiLmdldEdyYXBoWSgpLXRoaXMuZmlyc3QueSk+dGhpcy5ncmFwaC50b2xlcmFuY2UpJiZ0aGlzLnVwZGF0ZUN1cnJlbnRTdGF0ZShiLGMpO2lmKG51bGwhPXRoaXMuZmlyc3Qpe3ZhciBmPW51bGwsZD1jO251bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudENvbnN0cmFpbnQmJm51bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudEZvY3VzJiZudWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRQb2ludD8oZj10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRDb25zdHJhaW50LApkPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudFBvaW50LmNsb25lKCkpOm51bGwhPXRoaXMucHJldmlvdXMmJiF0aGlzLmdyYXBoLmlzSWdub3JlVGVybWluYWxFdmVudChiLmdldEV2ZW50KCkpJiZteEV2ZW50LmlzU2hpZnREb3duKGIuZ2V0RXZlbnQoKSkmJihNYXRoLmFicyh0aGlzLnByZXZpb3VzLmdldENlbnRlclgoKS1jLngpPE1hdGguYWJzKHRoaXMucHJldmlvdXMuZ2V0Q2VudGVyWSgpLWMueSk/Yy54PXRoaXMucHJldmlvdXMuZ2V0Q2VudGVyWCgpOmMueT10aGlzLnByZXZpb3VzLmdldENlbnRlclkoKSk7ZT10aGlzLmZpcnN0O2lmKG51bGwhPXRoaXMuc2VsZWN0ZWRJY29uKXt2YXIgZz10aGlzLnNlbGVjdGVkSWNvbi5ib3VuZHMud2lkdGgsaz10aGlzLnNlbGVjdGVkSWNvbi5ib3VuZHMuaGVpZ2h0O251bGwhPXRoaXMuY3VycmVudFN0YXRlJiZ0aGlzLnRhcmdldENvbm5lY3RJbWFnZT8oZz10aGlzLmdldEljb25Qb3NpdGlvbih0aGlzLnNlbGVjdGVkSWNvbiwKdGhpcy5jdXJyZW50U3RhdGUpLHRoaXMuc2VsZWN0ZWRJY29uLmJvdW5kcy54PWcueCx0aGlzLnNlbGVjdGVkSWNvbi5ib3VuZHMueT1nLnkpOihnPW5ldyBteFJlY3RhbmdsZShiLmdldEdyYXBoWCgpK3RoaXMuY29ubmVjdEljb25PZmZzZXQueCxiLmdldEdyYXBoWSgpK3RoaXMuY29ubmVjdEljb25PZmZzZXQueSxnLGspLHRoaXMuc2VsZWN0ZWRJY29uLmJvdW5kcz1nKTt0aGlzLnNlbGVjdGVkSWNvbi5yZWRyYXcoKX1udWxsIT10aGlzLmVkZ2VTdGF0ZT8odGhpcy51cGRhdGVFZGdlU3RhdGUoZCxmKSxkPXRoaXMuZWRnZVN0YXRlLmFic29sdXRlUG9pbnRzW3RoaXMuZWRnZVN0YXRlLmFic29sdXRlUG9pbnRzLmxlbmd0aC0xXSxlPXRoaXMuZWRnZVN0YXRlLmFic29sdXRlUG9pbnRzWzBdKToobnVsbCE9dGhpcy5jdXJyZW50U3RhdGUmJm51bGw9PXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudENvbnN0cmFpbnQmJihnPXRoaXMuZ2V0VGFyZ2V0UGVyaW1ldGVyUG9pbnQodGhpcy5jdXJyZW50U3RhdGUsCmIpLG51bGwhPWcmJihkPWcpKSxudWxsPT10aGlzLnNvdXJjZUNvbnN0cmFpbnQmJm51bGwhPXRoaXMucHJldmlvdXMmJihnPXRoaXMuZ2V0U291cmNlUGVyaW1ldGVyUG9pbnQodGhpcy5wcmV2aW91cyxudWxsIT10aGlzLndheXBvaW50cyYmMDx0aGlzLndheXBvaW50cy5sZW5ndGg/dGhpcy53YXlwb2ludHNbMF06ZCxiKSxudWxsIT1nJiYoZT1nKSkpO2lmKG51bGw9PXRoaXMuY3VycmVudFN0YXRlJiZ0aGlzLm1vdmVQcmV2aWV3QXdheSl7Zz1lO251bGwhPXRoaXMuZWRnZVN0YXRlJiYyPD10aGlzLmVkZ2VTdGF0ZS5hYnNvbHV0ZVBvaW50cy5sZW5ndGgmJihmPXRoaXMuZWRnZVN0YXRlLmFic29sdXRlUG9pbnRzW3RoaXMuZWRnZVN0YXRlLmFic29sdXRlUG9pbnRzLmxlbmd0aC0yXSxudWxsIT1mJiYoZz1mKSk7Zj1kLngtZy54O2c9ZC55LWcueTtrPU1hdGguc3FydChmKmYrZypnKTtpZigwPT1rKXJldHVybjt0aGlzLm9yaWdpbmFsUG9pbnQ9ZC5jbG9uZSgpO2QueC09NCpmLwprO2QueS09NCpnL2t9ZWxzZSB0aGlzLm9yaWdpbmFsUG9pbnQ9bnVsbDtudWxsPT10aGlzLnNoYXBlJiYoZj1NYXRoLmFicyhiLmdldEdyYXBoWCgpLXRoaXMuZmlyc3QueCksZz1NYXRoLmFicyhiLmdldEdyYXBoWSgpLXRoaXMuZmlyc3QueSksZj50aGlzLmdyYXBoLnRvbGVyYW5jZXx8Zz50aGlzLmdyYXBoLnRvbGVyYW5jZSkmJih0aGlzLnNoYXBlPXRoaXMuY3JlYXRlU2hhcGUoKSxudWxsIT10aGlzLmVkZ2VTdGF0ZSYmdGhpcy5zaGFwZS5hcHBseSh0aGlzLmVkZ2VTdGF0ZSksdGhpcy51cGRhdGVDdXJyZW50U3RhdGUoYixjKSk7bnVsbCE9dGhpcy5zaGFwZSYmKG51bGwhPXRoaXMuZWRnZVN0YXRlP3RoaXMuc2hhcGUucG9pbnRzPXRoaXMuZWRnZVN0YXRlLmFic29sdXRlUG9pbnRzOihjPVtlXSxudWxsIT10aGlzLndheXBvaW50cyYmKGM9Yy5jb25jYXQodGhpcy53YXlwb2ludHMpKSxjLnB1c2goZCksdGhpcy5zaGFwZS5wb2ludHM9YyksdGhpcy5kcmF3UHJldmlldygpKTsKbnVsbCE9dGhpcy5jdXJzb3ImJih0aGlzLmdyYXBoLmNvbnRhaW5lci5zdHlsZS5jdXJzb3I9dGhpcy5jdXJzb3IpO214RXZlbnQuY29uc3VtZShiLmdldEV2ZW50KCkpO2IuY29uc3VtZSgpfWVsc2UgdGhpcy5pc0VuYWJsZWQoKSYmdGhpcy5ncmFwaC5pc0VuYWJsZWQoKT90aGlzLnByZXZpb3VzIT10aGlzLmN1cnJlbnRTdGF0ZSYmbnVsbD09dGhpcy5lZGdlU3RhdGU/KHRoaXMuZGVzdHJveUljb25zKCksbnVsbCE9dGhpcy5jdXJyZW50U3RhdGUmJm51bGw9PXRoaXMuZXJyb3ImJm51bGw9PXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudENvbnN0cmFpbnQmJih0aGlzLmljb25zPXRoaXMuY3JlYXRlSWNvbnModGhpcy5jdXJyZW50U3RhdGUpLG51bGw9PXRoaXMuaWNvbnMmJih0aGlzLmN1cnJlbnRTdGF0ZS5zZXRDdXJzb3IobXhDb25zdGFudHMuQ1VSU09SX0NPTk5FQ1QpLGIuY29uc3VtZSgpKSksdGhpcy5wcmV2aW91cz10aGlzLmN1cnJlbnRTdGF0ZSk6dGhpcy5wcmV2aW91cyE9CnRoaXMuY3VycmVudFN0YXRlfHxudWxsPT10aGlzLmN1cnJlbnRTdGF0ZXx8bnVsbCE9dGhpcy5pY29uc3x8dGhpcy5ncmFwaC5pc01vdXNlRG93bnx8Yi5jb25zdW1lKCk6dGhpcy5jb25zdHJhaW50SGFuZGxlci5yZXNldCgpO2lmKCF0aGlzLmdyYXBoLmlzTW91c2VEb3duJiZudWxsIT10aGlzLmN1cnJlbnRTdGF0ZSYmbnVsbCE9dGhpcy5pY29ucyl7Yz0hMTtkPWIuZ2V0U291cmNlKCk7Zm9yKGU9MDtlPHRoaXMuaWNvbnMubGVuZ3RoJiYhYztlKyspYz1kPT10aGlzLmljb25zW2VdLm5vZGV8fGQucGFyZW50Tm9kZT09dGhpcy5pY29uc1tlXS5ub2RlO2N8fHRoaXMudXBkYXRlSWNvbnModGhpcy5jdXJyZW50U3RhdGUsdGhpcy5pY29ucyxiKX19fTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUudXBkYXRlRWRnZVN0YXRlPWZ1bmN0aW9uKGEsYil7bnVsbCE9dGhpcy5zb3VyY2VDb25zdHJhaW50JiZudWxsIT10aGlzLnNvdXJjZUNvbnN0cmFpbnQucG9pbnQmJih0aGlzLmVkZ2VTdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FWElUX1hdPXRoaXMuc291cmNlQ29uc3RyYWludC5wb2ludC54LHRoaXMuZWRnZVN0YXRlLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VYSVRfWV09dGhpcy5zb3VyY2VDb25zdHJhaW50LnBvaW50LnkpO251bGwhPWImJm51bGwhPWIucG9pbnQ/KHRoaXMuZWRnZVN0YXRlLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VOVFJZX1hdPWIucG9pbnQueCx0aGlzLmVkZ2VTdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FTlRSWV9ZXT1iLnBvaW50LnkpOihkZWxldGUgdGhpcy5lZGdlU3RhdGUuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRU5UUllfWF0sZGVsZXRlIHRoaXMuZWRnZVN0YXRlLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VOVFJZX1ldKTsKdGhpcy5lZGdlU3RhdGUuYWJzb2x1dGVQb2ludHM9W251bGwsbnVsbCE9dGhpcy5jdXJyZW50U3RhdGU/bnVsbDphXTt0aGlzLmdyYXBoLnZpZXcudXBkYXRlRml4ZWRUZXJtaW5hbFBvaW50KHRoaXMuZWRnZVN0YXRlLHRoaXMucHJldmlvdXMsITAsdGhpcy5zb3VyY2VDb25zdHJhaW50KTtudWxsIT10aGlzLmN1cnJlbnRTdGF0ZSYmKG51bGw9PWImJihiPXRoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvbkNvbnN0cmFpbnQodGhpcy5lZGdlU3RhdGUsdGhpcy5wcmV2aW91cywhMSkpLHRoaXMuZWRnZVN0YXRlLnNldEFic29sdXRlVGVybWluYWxQb2ludChudWxsLCExKSx0aGlzLmdyYXBoLnZpZXcudXBkYXRlRml4ZWRUZXJtaW5hbFBvaW50KHRoaXMuZWRnZVN0YXRlLHRoaXMuY3VycmVudFN0YXRlLCExLGIpKTt2YXIgYz1udWxsO2lmKG51bGwhPXRoaXMud2F5cG9pbnRzKWZvcih2YXIgYz1bXSxkPTA7ZDx0aGlzLndheXBvaW50cy5sZW5ndGg7ZCsrKXt2YXIgZT10aGlzLndheXBvaW50c1tkXS5jbG9uZSgpOwp0aGlzLmNvbnZlcnRXYXlwb2ludChlKTtjW2RdPWV9dGhpcy5ncmFwaC52aWV3LnVwZGF0ZVBvaW50cyh0aGlzLmVkZ2VTdGF0ZSxjLHRoaXMucHJldmlvdXMsdGhpcy5jdXJyZW50U3RhdGUpO3RoaXMuZ3JhcGgudmlldy51cGRhdGVGbG9hdGluZ1Rlcm1pbmFsUG9pbnRzKHRoaXMuZWRnZVN0YXRlLHRoaXMucHJldmlvdXMsdGhpcy5jdXJyZW50U3RhdGUpfTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuZ2V0VGFyZ2V0UGVyaW1ldGVyUG9pbnQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1udWxsLGQ9YS52aWV3LGU9ZC5nZXRQZXJpbWV0ZXJGdW5jdGlvbihhKTtpZihudWxsIT1lKXt2YXIgZj1udWxsIT10aGlzLndheXBvaW50cyYmMDx0aGlzLndheXBvaW50cy5sZW5ndGg/dGhpcy53YXlwb2ludHNbdGhpcy53YXlwb2ludHMubGVuZ3RoLTFdOm5ldyBteFBvaW50KHRoaXMucHJldmlvdXMuZ2V0Q2VudGVyWCgpLHRoaXMucHJldmlvdXMuZ2V0Q2VudGVyWSgpKSxkPWUoZC5nZXRQZXJpbWV0ZXJCb3VuZHMoYSksdGhpcy5lZGdlU3RhdGUsZiwhMSk7bnVsbCE9ZCYmKGM9ZCl9ZWxzZSBjPW5ldyBteFBvaW50KGEuZ2V0Q2VudGVyWCgpLGEuZ2V0Q2VudGVyWSgpKTtyZXR1cm4gY307Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmdldFNvdXJjZVBlcmltZXRlclBvaW50PWZ1bmN0aW9uKGEsYixjKXtjPW51bGw7dmFyIGQ9YS52aWV3LGU9ZC5nZXRQZXJpbWV0ZXJGdW5jdGlvbihhKSxmPW5ldyBteFBvaW50KGEuZ2V0Q2VudGVyWCgpLGEuZ2V0Q2VudGVyWSgpKTtpZihudWxsIT1lKXt2YXIgZz1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT04sMCksaz1NYXRoLlBJLzE4MCotZzswIT1nJiYoYj1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChuZXcgbXhQb2ludChiLngsYi55KSxNYXRoLmNvcyhrKSxNYXRoLnNpbihrKSxmKSk7YT1lKGQuZ2V0UGVyaW1ldGVyQm91bmRzKGEpLGEsYiwhMSk7bnVsbCE9YSYmKDAhPWcmJihhPW14VXRpbHMuZ2V0Um90YXRlZFBvaW50KG5ldyBteFBvaW50KGEueCxhLnkpLE1hdGguY29zKC1rKSxNYXRoLnNpbigtayksZikpLGM9YSl9ZWxzZSBjPWY7cmV0dXJuIGN9OwpteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS51cGRhdGVJY29ucz1mdW5jdGlvbihhLGIsYyl7fTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5pc1N0b3BFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YS5nZXRTdGF0ZSgpfTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuYWRkV2F5cG9pbnRGb3JFdmVudD1mdW5jdGlvbihhKXt2YXIgYj1teFV0aWxzLmNvbnZlcnRQb2ludCh0aGlzLmdyYXBoLmNvbnRhaW5lcixhLmdldFgoKSxhLmdldFkoKSksYz1NYXRoLmFicyhiLngtdGhpcy5maXJzdC54KSxiPU1hdGguYWJzKGIueS10aGlzLmZpcnN0LnkpO2lmKG51bGwhPXRoaXMud2F5cG9pbnRzfHwxPHRoaXMubW91c2VEb3duQ291bnRlciYmKGM+dGhpcy5ncmFwaC50b2xlcmFuY2V8fGI+dGhpcy5ncmFwaC50b2xlcmFuY2UpKW51bGw9PXRoaXMud2F5cG9pbnRzJiYodGhpcy53YXlwb2ludHM9W10pLGM9dGhpcy5ncmFwaC52aWV3LnNjYWxlLGI9bmV3IG14UG9pbnQodGhpcy5ncmFwaC5zbmFwKGEuZ2V0R3JhcGhYKCkvYykqYyx0aGlzLmdyYXBoLnNuYXAoYS5nZXRHcmFwaFkoKS9jKSpjKSx0aGlzLndheXBvaW50cy5wdXNoKGIpfTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY2hlY2tDb25zdHJhaW50cz1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsPT1hfHxudWxsPT1ifHxudWxsPT1hLnBvaW50fHxudWxsPT1iLnBvaW50fHwhYS5wb2ludC5lcXVhbHMoYi5wb2ludCl8fGEuZHghPWIuZHh8fGEuZHkhPWIuZHl8fGEucGVyaW1ldGVyIT1iLnBlcmltZXRlcn07Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLm1vdXNlVXA9ZnVuY3Rpb24oYSxiKXtpZighYi5pc0NvbnN1bWVkKCkmJnRoaXMuaXNDb25uZWN0aW5nKCkpe2lmKHRoaXMud2F5cG9pbnRzRW5hYmxlZCYmIXRoaXMuaXNTdG9wRXZlbnQoYikpe3RoaXMuYWRkV2F5cG9pbnRGb3JFdmVudChiKTtiLmNvbnN1bWUoKTtyZXR1cm59dmFyIGM9dGhpcy5zb3VyY2VDb25zdHJhaW50LGQ9dGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Q29uc3RyYWludCxlPW51bGwhPXRoaXMucHJldmlvdXM/dGhpcy5wcmV2aW91cy5jZWxsOm51bGwsZj1udWxsO251bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudENvbnN0cmFpbnQmJm51bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudEZvY3VzJiYoZj10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRGb2N1cy5jZWxsKTtudWxsPT1mJiZudWxsIT10aGlzLmN1cnJlbnRTdGF0ZSYmKGY9dGhpcy5jdXJyZW50U3RhdGUuY2VsbCk7Cm51bGwhPXRoaXMuZXJyb3J8fG51bGwhPWUmJm51bGwhPWYmJmU9PWYmJiF0aGlzLmNoZWNrQ29uc3RyYWludHMoYyxkKT8obnVsbCE9dGhpcy5wcmV2aW91cyYmbnVsbCE9dGhpcy5tYXJrZXIudmFsaWRTdGF0ZSYmdGhpcy5wcmV2aW91cy5jZWxsPT10aGlzLm1hcmtlci52YWxpZFN0YXRlLmNlbGwmJnRoaXMuZ3JhcGguc2VsZWN0Q2VsbEZvckV2ZW50KHRoaXMubWFya2VyLnNvdXJjZSxiLmdldEV2ZW50KCkpLG51bGwhPXRoaXMuZXJyb3ImJjA8dGhpcy5lcnJvci5sZW5ndGgmJnRoaXMuZ3JhcGgudmFsaWRhdGlvbkFsZXJ0KHRoaXMuZXJyb3IpKTp0aGlzLmNvbm5lY3QoZSxmLGIuZ2V0RXZlbnQoKSxiLmdldENlbGwoKSk7dGhpcy5kZXN0cm95SWNvbnMoKTtiLmNvbnN1bWUoKX1udWxsIT10aGlzLmZpcnN0JiZ0aGlzLnJlc2V0KCl9OwpteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe251bGwhPXRoaXMuc2hhcGUmJih0aGlzLnNoYXBlLmRlc3Ryb3koKSx0aGlzLnNoYXBlPW51bGwpO251bGwhPXRoaXMuY3Vyc29yJiZudWxsIT10aGlzLmdyYXBoLmNvbnRhaW5lciYmKHRoaXMuZ3JhcGguY29udGFpbmVyLnN0eWxlLmN1cnNvcj0iIik7dGhpcy5kZXN0cm95SWNvbnMoKTt0aGlzLm1hcmtlci5yZXNldCgpO3RoaXMuY29uc3RyYWludEhhbmRsZXIucmVzZXQoKTt0aGlzLnNvdXJjZUNvbnN0cmFpbnQ9dGhpcy5lcnJvcj10aGlzLnByZXZpb3VzPXRoaXMuZWRnZVN0YXRlPXRoaXMuY3VycmVudFBvaW50PXRoaXMub3JpZ2luYWxQb2ludD1udWxsO3RoaXMubW91c2VEb3duQ291bnRlcj0wO3RoaXMuZmlyc3Q9bnVsbDt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlJFU0VUKSl9OwpteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5kcmF3UHJldmlldz1mdW5jdGlvbigpe3RoaXMudXBkYXRlUHJldmlldyhudWxsPT10aGlzLmVycm9yKTt0aGlzLnNoYXBlLnJlZHJhdygpfTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS51cGRhdGVQcmV2aWV3PWZ1bmN0aW9uKGEpe3RoaXMuc2hhcGUuc3Ryb2tld2lkdGg9dGhpcy5nZXRFZGdlV2lkdGgoYSk7dGhpcy5zaGFwZS5zdHJva2U9dGhpcy5nZXRFZGdlQ29sb3IoYSl9O214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmdldEVkZ2VDb2xvcj1mdW5jdGlvbihhKXtyZXR1cm4gYT9teENvbnN0YW50cy5WQUxJRF9DT0xPUjpteENvbnN0YW50cy5JTlZBTElEX0NPTE9SfTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5nZXRFZGdlV2lkdGg9ZnVuY3Rpb24oYSl7cmV0dXJuIGE/MzoxfTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY29ubmVjdD1mdW5jdGlvbihhLGIsYyxkKXtpZihudWxsIT1ifHx0aGlzLmlzQ3JlYXRlVGFyZ2V0KGMpfHx0aGlzLmdyYXBoLmFsbG93RGFuZ2xpbmdFZGdlcyl7dmFyIGU9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGY9ITEsZz1udWxsO2UuYmVnaW5VcGRhdGUoKTt0cnl7aWYobnVsbCE9YSYmbnVsbD09YiYmIXRoaXMuZ3JhcGguaXNJZ25vcmVUZXJtaW5hbEV2ZW50KGMpJiZ0aGlzLmlzQ3JlYXRlVGFyZ2V0KGMpJiYoYj10aGlzLmNyZWF0ZVRhcmdldFZlcnRleChjLGEpLG51bGwhPWIpKXtkPXRoaXMuZ3JhcGguZ2V0RHJvcFRhcmdldChbYl0sYyxkKTtmPSEwO2lmKG51bGwhPWQmJnRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5pc0VkZ2UoZCkpZD10aGlzLmdyYXBoLmdldERlZmF1bHRQYXJlbnQoKTtlbHNle3ZhciBrPXRoaXMuZ3JhcGguZ2V0VmlldygpLmdldFN0YXRlKGQpO2lmKG51bGwhPWspe3ZhciBsPWUuZ2V0R2VvbWV0cnkoYik7CmwueC09ay5vcmlnaW4ueDtsLnktPWsub3JpZ2luLnl9fXRoaXMuZ3JhcGguYWRkQ2VsbChiLGQpfXZhciBtPXRoaXMuZ3JhcGguZ2V0RGVmYXVsdFBhcmVudCgpO251bGwhPWEmJm51bGwhPWImJmUuZ2V0UGFyZW50KGEpPT1lLmdldFBhcmVudChiKSYmZS5nZXRQYXJlbnQoZS5nZXRQYXJlbnQoYSkpIT1lLmdldFJvb3QoKSYmKG09ZS5nZXRQYXJlbnQoYSksbnVsbCE9YS5nZW9tZXRyeSYmYS5nZW9tZXRyeS5yZWxhdGl2ZSYmbnVsbCE9Yi5nZW9tZXRyeSYmYi5nZW9tZXRyeS5yZWxhdGl2ZSYmKG09ZS5nZXRQYXJlbnQobSkpKTt2YXIgbj1rPW51bGw7bnVsbCE9dGhpcy5lZGdlU3RhdGUmJihrPXRoaXMuZWRnZVN0YXRlLmNlbGwudmFsdWUsbj10aGlzLmVkZ2VTdGF0ZS5jZWxsLnN0eWxlKTtnPXRoaXMuaW5zZXJ0RWRnZShtLG51bGwsayxhLGIsbik7aWYobnVsbCE9Zyl7dGhpcy5ncmFwaC5zZXRDb25uZWN0aW9uQ29uc3RyYWludChnLGEsITAsdGhpcy5zb3VyY2VDb25zdHJhaW50KTsKdGhpcy5ncmFwaC5zZXRDb25uZWN0aW9uQ29uc3RyYWludChnLGIsITEsdGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Q29uc3RyYWludCk7bnVsbCE9dGhpcy5lZGdlU3RhdGUmJmUuc2V0R2VvbWV0cnkoZyx0aGlzLmVkZ2VTdGF0ZS5jZWxsLmdlb21ldHJ5KTttPWUuZ2V0UGFyZW50KGEpO2lmKHRoaXMuaXNJbnNlcnRCZWZvcmUoZyxhLGIsYyxkKSl7Zm9yKGw9YTtudWxsIT1sLnBhcmVudCYmbnVsbCE9bC5nZW9tZXRyeSYmbC5nZW9tZXRyeS5yZWxhdGl2ZSYmbC5wYXJlbnQhPWcucGFyZW50OylsPXRoaXMuZ3JhcGgubW9kZWwuZ2V0UGFyZW50KGwpO251bGwhPWwmJm51bGwhPWwucGFyZW50JiZsLnBhcmVudD09Zy5wYXJlbnQmJmUuYWRkKG0sZyxsLnBhcmVudC5nZXRJbmRleChsKSl9dmFyIHA9ZS5nZXRHZW9tZXRyeShnKTtudWxsPT1wJiYocD1uZXcgbXhHZW9tZXRyeSxwLnJlbGF0aXZlPSEwLGUuc2V0R2VvbWV0cnkoZyxwKSk7aWYobnVsbCE9dGhpcy53YXlwb2ludHMmJgowPHRoaXMud2F5cG9pbnRzLmxlbmd0aCl7dmFyIHE9dGhpcy5ncmFwaC52aWV3LnNjYWxlLHI9dGhpcy5ncmFwaC52aWV3LnRyYW5zbGF0ZTtwLnBvaW50cz1bXTtmb3IoYT0wO2E8dGhpcy53YXlwb2ludHMubGVuZ3RoO2ErKyl7dmFyIHQ9dGhpcy53YXlwb2ludHNbYV07cC5wb2ludHMucHVzaChuZXcgbXhQb2ludCh0LngvcS1yLngsdC55L3Etci55KSl9fWlmKG51bGw9PWIpe3ZhciB1PXRoaXMuZ3JhcGgudmlldy50cmFuc2xhdGUscT10aGlzLmdyYXBoLnZpZXcuc2NhbGUsdD1udWxsIT10aGlzLm9yaWdpbmFsUG9pbnQ/bmV3IG14UG9pbnQodGhpcy5vcmlnaW5hbFBvaW50LngvcS11LngsdGhpcy5vcmlnaW5hbFBvaW50LnkvcS11LnkpOm5ldyBteFBvaW50KHRoaXMuY3VycmVudFBvaW50LngvcS11LngsdGhpcy5jdXJyZW50UG9pbnQueS9xLXUueSk7dC54LT10aGlzLmdyYXBoLnBhbkR4L3RoaXMuZ3JhcGgudmlldy5zY2FsZTt0LnktPXRoaXMuZ3JhcGgucGFuRHkvdGhpcy5ncmFwaC52aWV3LnNjYWxlOwpwLnNldFRlcm1pbmFsUG9pbnQodCwhMSl9dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5DT05ORUNULCJjZWxsIixnLCJ0ZXJtaW5hbCIsYiwiZXZlbnQiLGMsInRhcmdldCIsZCwidGVybWluYWxJbnNlcnRlZCIsZikpfX1jYXRjaCh4KXtteExvZy5zaG93KCksbXhMb2cuZGVidWcoeC5tZXNzYWdlKX1maW5hbGx5e2UuZW5kVXBkYXRlKCl9dGhpcy5zZWxlY3QmJnRoaXMuc2VsZWN0Q2VsbHMoZyxmP2I6bnVsbCl9fTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5zZWxlY3RDZWxscz1mdW5jdGlvbihhLGIpe3RoaXMuZ3JhcGguc2V0U2VsZWN0aW9uQ2VsbChhKX07Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmluc2VydEVkZ2U9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2lmKG51bGw9PXRoaXMuZmFjdG9yeU1ldGhvZClyZXR1cm4gdGhpcy5ncmFwaC5pbnNlcnRFZGdlKGEsYixjLGQsZSxmKTtiPXRoaXMuY3JlYXRlRWRnZShjLGQsZSxmKTtyZXR1cm4gdGhpcy5ncmFwaC5hZGRFZGdlKGIsYSxkLGUpfTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlVGFyZ2V0VmVydGV4PWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGIpO251bGwhPWMmJmMucmVsYXRpdmU7KWI9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldFBhcmVudChiKSxjPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGIpO3ZhciBkPXRoaXMuZ3JhcGguY2xvbmVDZWxsKGIpLGM9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldEdlb21ldHJ5KGQpO2lmKG51bGwhPWMpe3ZhciBlPXRoaXMuZ3JhcGgudmlldy50cmFuc2xhdGUsZj10aGlzLmdyYXBoLnZpZXcuc2NhbGUsZz1uZXcgbXhQb2ludCh0aGlzLmN1cnJlbnRQb2ludC54L2YtZS54LHRoaXMuY3VycmVudFBvaW50LnkvZi1lLnkpO2MueD1NYXRoLnJvdW5kKGcueC1jLndpZHRoLzItdGhpcy5ncmFwaC5wYW5EeC9mKTtjLnk9TWF0aC5yb3VuZChnLnktYy5oZWlnaHQvMi10aGlzLmdyYXBoLnBhbkR5L2YpO2c9dGhpcy5nZXRBbGlnbm1lbnRUb2xlcmFuY2UoKTsKaWYoMDxnKXt2YXIgaz10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUoYik7aWYobnVsbCE9ayl7dmFyIGw9ay54L2YtZS54LGU9ay55L2YtZS55O01hdGguYWJzKGwtYy54KTw9ZyYmKGMueD1NYXRoLnJvdW5kKGwpKTtNYXRoLmFicyhlLWMueSk8PWcmJihjLnk9TWF0aC5yb3VuZChlKSl9fX1yZXR1cm4gZH07bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuZ2V0QWxpZ25tZW50VG9sZXJhbmNlPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdyYXBoLmlzR3JpZEVuYWJsZWQoKT90aGlzLmdyYXBoLmdyaWRTaXplLzI6dGhpcy5ncmFwaC50b2xlcmFuY2V9OwpteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVFZGdlPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPW51bGw7bnVsbCE9dGhpcy5mYWN0b3J5TWV0aG9kJiYoZT10aGlzLmZhY3RvcnlNZXRob2QoYixjLGQpKTtudWxsPT1lJiYoZT1uZXcgbXhDZWxsKGF8fCIiKSxlLnNldEVkZ2UoITApLGUuc2V0U3R5bGUoZCksYT1uZXcgbXhHZW9tZXRyeSxhLnJlbGF0aXZlPSEwLGUuc2V0R2VvbWV0cnkoYSkpO3JldHVybiBlfTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZ3JhcGgucmVtb3ZlTW91c2VMaXN0ZW5lcih0aGlzKTtudWxsIT10aGlzLnNoYXBlJiYodGhpcy5zaGFwZS5kZXN0cm95KCksdGhpcy5zaGFwZT1udWxsKTtudWxsIT10aGlzLm1hcmtlciYmKHRoaXMubWFya2VyLmRlc3Ryb3koKSx0aGlzLm1hcmtlcj1udWxsKTtudWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyJiYodGhpcy5jb25zdHJhaW50SGFuZGxlci5kZXN0cm95KCksdGhpcy5jb25zdHJhaW50SGFuZGxlcj1udWxsKTtudWxsIT10aGlzLmNoYW5nZUhhbmRsZXImJih0aGlzLmdyYXBoLmdldE1vZGVsKCkucmVtb3ZlTGlzdGVuZXIodGhpcy5jaGFuZ2VIYW5kbGVyKSx0aGlzLmdyYXBoLmdldFZpZXcoKS5yZW1vdmVMaXN0ZW5lcih0aGlzLmNoYW5nZUhhbmRsZXIpLHRoaXMuY2hhbmdlSGFuZGxlcj1udWxsKTtudWxsIT10aGlzLmRyaWxsSGFuZGxlciYmKHRoaXMuZ3JhcGgucmVtb3ZlTGlzdGVuZXIodGhpcy5kcmlsbEhhbmRsZXIpLAp0aGlzLmdyYXBoLmdldFZpZXcoKS5yZW1vdmVMaXN0ZW5lcih0aGlzLmRyaWxsSGFuZGxlciksdGhpcy5kcmlsbEhhbmRsZXI9bnVsbCk7bnVsbCE9dGhpcy5lc2NhcGVIYW5kbGVyJiYodGhpcy5ncmFwaC5yZW1vdmVMaXN0ZW5lcih0aGlzLmVzY2FwZUhhbmRsZXIpLHRoaXMuZXNjYXBlSGFuZGxlcj1udWxsKX07CmZ1bmN0aW9uIG14Q29uc3RyYWludEhhbmRsZXIoYSl7dGhpcy5ncmFwaD1hO3RoaXMucmVzZXRIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7bnVsbCE9dGhpcy5jdXJyZW50Rm9jdXMmJm51bGw9PXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZSh0aGlzLmN1cnJlbnRGb2N1cy5jZWxsKT90aGlzLnJlc2V0KCk6dGhpcy5yZWRyYXcoKX0pO3RoaXMuZ3JhcGgubW9kZWwuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsdGhpcy5yZXNldEhhbmRsZXIpO3RoaXMuZ3JhcGgudmlldy5hZGRMaXN0ZW5lcihteEV2ZW50LlNDQUxFX0FORF9UUkFOU0xBVEUsdGhpcy5yZXNldEhhbmRsZXIpO3RoaXMuZ3JhcGgudmlldy5hZGRMaXN0ZW5lcihteEV2ZW50LlRSQU5TTEFURSx0aGlzLnJlc2V0SGFuZGxlcik7dGhpcy5ncmFwaC52aWV3LmFkZExpc3RlbmVyKG14RXZlbnQuU0NBTEUsdGhpcy5yZXNldEhhbmRsZXIpO3RoaXMuZ3JhcGguYWRkTGlzdGVuZXIobXhFdmVudC5ST09ULAp0aGlzLnJlc2V0SGFuZGxlcil9bXhDb25zdHJhaW50SGFuZGxlci5wcm90b3R5cGUucG9pbnRJbWFnZT1uZXcgbXhJbWFnZShteENsaWVudC5pbWFnZUJhc2VQYXRoKyIvcG9pbnQuZ2lmIiw1LDUpO214Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLmdyYXBoPW51bGw7bXhDb25zdHJhaW50SGFuZGxlci5wcm90b3R5cGUuZW5hYmxlZD0hMDtteENvbnN0cmFpbnRIYW5kbGVyLnByb3RvdHlwZS5oaWdobGlnaHRDb2xvcj1teENvbnN0YW50cy5ERUZBVUxUX1ZBTElEX0NPTE9SO214Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLmlzRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuYWJsZWR9O214Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLnNldEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5lbmFibGVkPWF9OwpteENvbnN0cmFpbnRIYW5kbGVyLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe2lmKG51bGwhPXRoaXMuZm9jdXNJY29ucyl7Zm9yKHZhciBhPTA7YTx0aGlzLmZvY3VzSWNvbnMubGVuZ3RoO2ErKyl0aGlzLmZvY3VzSWNvbnNbYV0uZGVzdHJveSgpO3RoaXMuZm9jdXNJY29ucz1udWxsfW51bGwhPXRoaXMuZm9jdXNIaWdobGlnaHQmJih0aGlzLmZvY3VzSGlnaGxpZ2h0LmRlc3Ryb3koKSx0aGlzLmZvY3VzSGlnaGxpZ2h0PW51bGwpO3RoaXMuZm9jdXNQb2ludHM9dGhpcy5jdXJyZW50Rm9jdXM9dGhpcy5jdXJyZW50UG9pbnQ9dGhpcy5jdXJyZW50Rm9jdXNBcmVhPXRoaXMuY3VycmVudENvbnN0cmFpbnQ9bnVsbH07bXhDb25zdHJhaW50SGFuZGxlci5wcm90b3R5cGUuZ2V0VG9sZXJhbmNlPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdyYXBoLmdldFRvbGVyYW5jZSgpfTsKbXhDb25zdHJhaW50SGFuZGxlci5wcm90b3R5cGUuZ2V0SW1hZ2VGb3JDb25zdHJhaW50PWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gdGhpcy5wb2ludEltYWdlfTtteENvbnN0cmFpbnRIYW5kbGVyLnByb3RvdHlwZS5pc0V2ZW50SWdub3JlZD1mdW5jdGlvbihhLGIpe3JldHVybiExfTtteENvbnN0cmFpbnRIYW5kbGVyLnByb3RvdHlwZS5pc1N0YXRlSWdub3JlZD1mdW5jdGlvbihhLGIpe3JldHVybiExfTtteENvbnN0cmFpbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95SWNvbnM9ZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLmZvY3VzSWNvbnMpe2Zvcih2YXIgYT0wO2E8dGhpcy5mb2N1c0ljb25zLmxlbmd0aDthKyspdGhpcy5mb2N1c0ljb25zW2FdLmRlc3Ryb3koKTt0aGlzLmZvY3VzUG9pbnRzPXRoaXMuZm9jdXNJY29ucz1udWxsfX07Cm14Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3lGb2N1c0hpZ2hsaWdodD1mdW5jdGlvbigpe251bGwhPXRoaXMuZm9jdXNIaWdobGlnaHQmJih0aGlzLmZvY3VzSGlnaGxpZ2h0LmRlc3Ryb3koKSx0aGlzLmZvY3VzSGlnaGxpZ2h0PW51bGwpfTtteENvbnN0cmFpbnRIYW5kbGVyLnByb3RvdHlwZS5pc0tlZXBGb2N1c0V2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiBteEV2ZW50LmlzU2hpZnREb3duKGEuZ2V0RXZlbnQoKSl9OwpteENvbnN0cmFpbnRIYW5kbGVyLnByb3RvdHlwZS5nZXRDZWxsRm9yRXZlbnQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmdldENlbGwoKTtudWxsIT1jfHxudWxsPT1ifHxhLmdldEdyYXBoWCgpPT1iLngmJmEuZ2V0R3JhcGhZKCk9PWIueXx8KGM9dGhpcy5ncmFwaC5nZXRDZWxsQXQoYi54LGIueSkpO2lmKG51bGwhPWMmJiF0aGlzLmdyYXBoLmlzQ2VsbENvbm5lY3RhYmxlKGMpKXt2YXIgZD10aGlzLmdyYXBoLmdldE1vZGVsKCkuZ2V0UGFyZW50KGMpO3RoaXMuZ3JhcGguZ2V0TW9kZWwoKS5pc1ZlcnRleChkKSYmdGhpcy5ncmFwaC5pc0NlbGxDb25uZWN0YWJsZShkKSYmKGM9ZCl9cmV0dXJuIHRoaXMuZ3JhcGguaXNDZWxsTG9ja2VkKGMpP251bGw6Y307Cm14Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihhLGIsYyxkKXtpZih0aGlzLmlzRW5hYmxlZCgpJiYhdGhpcy5pc0V2ZW50SWdub3JlZChhKSl7bnVsbD09dGhpcy5tb3VzZWxlYXZlSGFuZGxlciYmbnVsbCE9dGhpcy5ncmFwaC5jb250YWluZXImJih0aGlzLm1vdXNlbGVhdmVIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5yZXNldCgpfSksbXhFdmVudC5hZGRMaXN0ZW5lcih0aGlzLmdyYXBoLmNvbnRhaW5lciwibW91c2VsZWF2ZSIsdGhpcy5yZXNldEhhbmRsZXIpKTt2YXIgZT10aGlzLmdldFRvbGVyYW5jZShhKSxmPW51bGwhPWQ/ZC54OmEuZ2V0R3JhcGhYKCksZz1udWxsIT1kP2QueTphLmdldEdyYXBoWSgpLGY9bmV3IG14UmVjdGFuZ2xlKGYtZSxnLWUsMiplLDIqZSksZT1uZXcgbXhSZWN0YW5nbGUoYS5nZXRHcmFwaFgoKS1lLGEuZ2V0R3JhcGhZKCktZSwyKmUsMiplKSxrPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZSh0aGlzLmdldENlbGxGb3JFdmVudChhLApkKSk7dGhpcy5pc0tlZXBGb2N1c0V2ZW50KGEpfHxudWxsIT10aGlzLmN1cnJlbnRGb2N1c0FyZWEmJm51bGwhPXRoaXMuY3VycmVudEZvY3VzJiZudWxsPT1rJiZ0aGlzLmdyYXBoLmdldE1vZGVsKCkuaXNWZXJ0ZXgodGhpcy5jdXJyZW50Rm9jdXMuY2VsbCkmJm14VXRpbHMuaW50ZXJzZWN0cyh0aGlzLmN1cnJlbnRGb2N1c0FyZWEsZSl8fGs9PXRoaXMuY3VycmVudEZvY3VzfHwodGhpcy5jdXJyZW50Rm9jdXM9dGhpcy5jdXJyZW50Rm9jdXNBcmVhPW51bGwsdGhpcy5zZXRGb2N1cyhhLGssYikpO2E9dGhpcy5jdXJyZW50UG9pbnQ9dGhpcy5jdXJyZW50Q29uc3RyYWludD1udWxsO2lmKG51bGwhPXRoaXMuZm9jdXNJY29ucyYmbnVsbCE9dGhpcy5jb25zdHJhaW50cyYmKG51bGw9PWt8fHRoaXMuY3VycmVudEZvY3VzPT1rKSlmb3IodmFyIGc9ZS5nZXRDZW50ZXJYKCksbD1lLmdldENlbnRlclkoKSxtPTA7bTx0aGlzLmZvY3VzSWNvbnMubGVuZ3RoO20rKyl7dmFyIG49Zy10aGlzLmZvY3VzSWNvbnNbbV0uYm91bmRzLmdldENlbnRlclgoKSwKcD1sLXRoaXMuZm9jdXNJY29uc1ttXS5ib3VuZHMuZ2V0Q2VudGVyWSgpLG49bipuK3AqcDtpZigodGhpcy5pbnRlcnNlY3RzKHRoaXMuZm9jdXNJY29uc1ttXSxlLGIsYyl8fG51bGwhPWQmJnRoaXMuaW50ZXJzZWN0cyh0aGlzLmZvY3VzSWNvbnNbbV0sZixiLGMpKSYmKG51bGw9PWF8fG48YSkpe3RoaXMuY3VycmVudENvbnN0cmFpbnQ9dGhpcy5jb25zdHJhaW50c1ttXTt0aGlzLmN1cnJlbnRQb2ludD10aGlzLmZvY3VzUG9pbnRzW21dO2E9bjtuPXRoaXMuZm9jdXNJY29uc1ttXS5ib3VuZHMuY2xvbmUoKTtuLmdyb3cobXhDb25zdGFudHMuSElHSExJR0hUX1NJWkUrMSk7LS1uLndpZHRoOy0tbi5oZWlnaHQ7aWYobnVsbD09dGhpcy5mb2N1c0hpZ2hsaWdodCl7cD10aGlzLmNyZWF0ZUhpZ2hsaWdodFNoYXBlKCk7cC5kaWFsZWN0PXRoaXMuZ3JhcGguZGlhbGVjdD09bXhDb25zdGFudHMuRElBTEVDVF9TVkc/bXhDb25zdGFudHMuRElBTEVDVF9TVkc6bXhDb25zdGFudHMuRElBTEVDVF9WTUw7CnAucG9pbnRlckV2ZW50cz0hMTtwLmluaXQodGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0T3ZlcmxheVBhbmUoKSk7dGhpcy5mb2N1c0hpZ2hsaWdodD1wO3ZhciBxPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuY3VycmVudEZvY3VzP3RoaXMuY3VycmVudEZvY3VzOmt9KTtteEV2ZW50LnJlZGlyZWN0TW91c2VFdmVudHMocC5ub2RlLHRoaXMuZ3JhcGgscSl9dGhpcy5mb2N1c0hpZ2hsaWdodC5ib3VuZHM9bjt0aGlzLmZvY3VzSGlnaGxpZ2h0LnJlZHJhdygpfX1udWxsPT10aGlzLmN1cnJlbnRDb25zdHJhaW50JiZ0aGlzLmRlc3Ryb3lGb2N1c0hpZ2hsaWdodCgpfWVsc2UgdGhpcy5jdXJyZW50UG9pbnQ9dGhpcy5jdXJyZW50Rm9jdXM9dGhpcy5jdXJyZW50Q29uc3RyYWludD1udWxsfTsKbXhDb25zdHJhaW50SGFuZGxlci5wcm90b3R5cGUucmVkcmF3PWZ1bmN0aW9uKCl7aWYobnVsbCE9dGhpcy5jdXJyZW50Rm9jdXMmJm51bGwhPXRoaXMuY29uc3RyYWludHMmJm51bGwhPXRoaXMuZm9jdXNJY29ucyl7dmFyIGE9dGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKHRoaXMuY3VycmVudEZvY3VzLmNlbGwpO3RoaXMuY3VycmVudEZvY3VzPWE7dGhpcy5jdXJyZW50Rm9jdXNBcmVhPW5ldyBteFJlY3RhbmdsZShhLngsYS55LGEud2lkdGgsYS5oZWlnaHQpO2Zvcih2YXIgYj0wO2I8dGhpcy5jb25zdHJhaW50cy5sZW5ndGg7YisrKXt2YXIgYz10aGlzLmdyYXBoLmdldENvbm5lY3Rpb25Qb2ludChhLHRoaXMuY29uc3RyYWludHNbYl0pLGQ9dGhpcy5nZXRJbWFnZUZvckNvbnN0cmFpbnQoYSx0aGlzLmNvbnN0cmFpbnRzW2JdLGMpLGQ9bmV3IG14UmVjdGFuZ2xlKE1hdGgucm91bmQoYy54LWQud2lkdGgvMiksTWF0aC5yb3VuZChjLnktZC5oZWlnaHQvMiksZC53aWR0aCxkLmhlaWdodCk7CnRoaXMuZm9jdXNJY29uc1tiXS5ib3VuZHM9ZDt0aGlzLmZvY3VzSWNvbnNbYl0ucmVkcmF3KCk7dGhpcy5jdXJyZW50Rm9jdXNBcmVhLmFkZCh0aGlzLmZvY3VzSWNvbnNbYl0uYm91bmRzKTt0aGlzLmZvY3VzUG9pbnRzW2JdPWN9fX07Cm14Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLnNldEZvY3VzPWZ1bmN0aW9uKGEsYixjKXt0aGlzLmNvbnN0cmFpbnRzPW51bGwhPWImJiF0aGlzLmlzU3RhdGVJZ25vcmVkKGIsYykmJnRoaXMuZ3JhcGguaXNDZWxsQ29ubmVjdGFibGUoYi5jZWxsKT90aGlzLmlzRW5hYmxlZCgpP3RoaXMuZ3JhcGguZ2V0QWxsQ29ubmVjdGlvbkNvbnN0cmFpbnRzKGIsYyl8fFtdOltdOm51bGw7aWYobnVsbCE9dGhpcy5jb25zdHJhaW50cyl7dGhpcy5jdXJyZW50Rm9jdXM9Yjt0aGlzLmN1cnJlbnRGb2N1c0FyZWE9bmV3IG14UmVjdGFuZ2xlKGIueCxiLnksYi53aWR0aCxiLmhlaWdodCk7aWYobnVsbCE9dGhpcy5mb2N1c0ljb25zKXtmb3IoYz0wO2M8dGhpcy5mb2N1c0ljb25zLmxlbmd0aDtjKyspdGhpcy5mb2N1c0ljb25zW2NdLmRlc3Ryb3koKTt0aGlzLmZvY3VzUG9pbnRzPXRoaXMuZm9jdXNJY29ucz1udWxsfXRoaXMuZm9jdXNQb2ludHM9W107dGhpcy5mb2N1c0ljb25zPVtdO2ZvcihjPQowO2M8dGhpcy5jb25zdHJhaW50cy5sZW5ndGg7YysrKXt2YXIgZD10aGlzLmdyYXBoLmdldENvbm5lY3Rpb25Qb2ludChiLHRoaXMuY29uc3RyYWludHNbY10pLGU9dGhpcy5nZXRJbWFnZUZvckNvbnN0cmFpbnQoYix0aGlzLmNvbnN0cmFpbnRzW2NdLGQpLGY9ZS5zcmMsZT1uZXcgbXhSZWN0YW5nbGUoTWF0aC5yb3VuZChkLngtZS53aWR0aC8yKSxNYXRoLnJvdW5kKGQueS1lLmhlaWdodC8yKSxlLndpZHRoLGUuaGVpZ2h0KSxmPW5ldyBteEltYWdlU2hhcGUoZSxmKTtmLmRpYWxlY3Q9dGhpcy5ncmFwaC5kaWFsZWN0IT1teENvbnN0YW50cy5ESUFMRUNUX1NWRz9teENvbnN0YW50cy5ESUFMRUNUX01JWEVESFRNTDpteENvbnN0YW50cy5ESUFMRUNUX1NWRztmLnByZXNlcnZlSW1hZ2VBc3BlY3Q9ITE7Zi5pbml0KHRoaXMuZ3JhcGguZ2V0VmlldygpLmdldERlY29yYXRvclBhbmUoKSk7KG14Q2xpZW50LklTX1FVSVJLU3x8OD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSYmbXhFdmVudC5hZGRMaXN0ZW5lcihmLm5vZGUsCiJkcmFnc3RhcnQiLGZ1bmN0aW9uKGEpe214RXZlbnQuY29uc3VtZShhKTtyZXR1cm4hMX0pO251bGwhPWYubm9kZS5wcmV2aW91c1NpYmxpbmcmJmYubm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShmLm5vZGUsZi5ub2RlLnBhcmVudE5vZGUuZmlyc3RDaGlsZCk7ZT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLmN1cnJlbnRGb2N1cz90aGlzLmN1cnJlbnRGb2N1czpifSk7Zi5yZWRyYXcoKTtteEV2ZW50LnJlZGlyZWN0TW91c2VFdmVudHMoZi5ub2RlLHRoaXMuZ3JhcGgsZSk7dGhpcy5jdXJyZW50Rm9jdXNBcmVhLmFkZChmLmJvdW5kcyk7dGhpcy5mb2N1c0ljb25zLnB1c2goZik7dGhpcy5mb2N1c1BvaW50cy5wdXNoKGQpfXRoaXMuY3VycmVudEZvY3VzQXJlYS5ncm93KHRoaXMuZ2V0VG9sZXJhbmNlKGEpKX1lbHNlIHRoaXMuZGVzdHJveUljb25zKCksdGhpcy5kZXN0cm95Rm9jdXNIaWdobGlnaHQoKX07Cm14Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUhpZ2hsaWdodFNoYXBlPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14UmVjdGFuZ2xlU2hhcGUobnVsbCx0aGlzLmhpZ2hsaWdodENvbG9yLHRoaXMuaGlnaGxpZ2h0Q29sb3IsbXhDb25zdGFudHMuSElHSExJR0hUX1NUUk9LRVdJRFRIKTthLm9wYWNpdHk9bXhDb25zdGFudHMuSElHSExJR0hUX09QQUNJVFk7cmV0dXJuIGF9O214Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLmludGVyc2VjdHM9ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIG14VXRpbHMuaW50ZXJzZWN0cyhhLmJvdW5kcyxiKX07Cm14Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLnJlc2V0KCk7bnVsbCE9dGhpcy5yZXNldEhhbmRsZXImJih0aGlzLmdyYXBoLm1vZGVsLnJlbW92ZUxpc3RlbmVyKHRoaXMucmVzZXRIYW5kbGVyKSx0aGlzLmdyYXBoLnZpZXcucmVtb3ZlTGlzdGVuZXIodGhpcy5yZXNldEhhbmRsZXIpLHRoaXMuZ3JhcGgucmVtb3ZlTGlzdGVuZXIodGhpcy5yZXNldEhhbmRsZXIpLHRoaXMucmVzZXRIYW5kbGVyPW51bGwpO251bGwhPXRoaXMubW91c2VsZWF2ZUhhbmRsZXImJm51bGwhPXRoaXMuZ3JhcGguY29udGFpbmVyJiYobXhFdmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLmdyYXBoLmNvbnRhaW5lciwibW91c2VsZWF2ZSIsdGhpcy5tb3VzZWxlYXZlSGFuZGxlciksdGhpcy5tb3VzZWxlYXZlSGFuZGxlcj1udWxsKX07CmZ1bmN0aW9uIG14UnViYmVyYmFuZChhKXtudWxsIT1hJiYodGhpcy5ncmFwaD1hLHRoaXMuZ3JhcGguYWRkTW91c2VMaXN0ZW5lcih0aGlzKSx0aGlzLmZvcmNlUnViYmVyYmFuZEhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXt2YXIgYj1jLmdldFByb3BlcnR5KCJldmVudE5hbWUiKSxlPWMuZ2V0UHJvcGVydHkoImV2ZW50Iik7aWYoYj09bXhFdmVudC5NT1VTRV9ET1dOJiZ0aGlzLmlzRm9yY2VSdWJiZXJiYW5kRXZlbnQoZSkpe3ZhciBiPW14VXRpbHMuZ2V0T2Zmc2V0KHRoaXMuZ3JhcGguY29udGFpbmVyKSxmPW14VXRpbHMuZ2V0U2Nyb2xsT3JpZ2luKHRoaXMuZ3JhcGguY29udGFpbmVyKTtmLngtPWIueDtmLnktPWIueTt0aGlzLnN0YXJ0KGUuZ2V0WCgpK2YueCxlLmdldFkoKStmLnkpO2UuY29uc3VtZSghMSl9fSksdGhpcy5ncmFwaC5hZGRMaXN0ZW5lcihteEV2ZW50LkZJUkVfTU9VU0VfRVZFTlQsdGhpcy5mb3JjZVJ1YmJlcmJhbmRIYW5kbGVyKSwKdGhpcy5wYW5IYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5yZXBhaW50KCl9KSx0aGlzLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuUEFOLHRoaXMucGFuSGFuZGxlciksdGhpcy5nZXN0dXJlSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGMpe251bGwhPXRoaXMuZmlyc3QmJnRoaXMucmVzZXQoKX0pLHRoaXMuZ3JhcGguYWRkTGlzdGVuZXIobXhFdmVudC5HRVNUVVJFLHRoaXMuZ2VzdHVyZUhhbmRsZXIpLG14Q2xpZW50LklTX0lFJiZteEV2ZW50LmFkZExpc3RlbmVyKHdpbmRvdywidW5sb2FkIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuZGVzdHJveSgpfSkpKX1teFJ1YmJlcmJhbmQucHJvdG90eXBlLmRlZmF1bHRPcGFjaXR5PTIwO214UnViYmVyYmFuZC5wcm90b3R5cGUuZW5hYmxlZD0hMDtteFJ1YmJlcmJhbmQucHJvdG90eXBlLmRpdj1udWxsO214UnViYmVyYmFuZC5wcm90b3R5cGUuc2hhcmVkRGl2PW51bGw7Cm14UnViYmVyYmFuZC5wcm90b3R5cGUuY3VycmVudFg9MDtteFJ1YmJlcmJhbmQucHJvdG90eXBlLmN1cnJlbnRZPTA7bXhSdWJiZXJiYW5kLnByb3RvdHlwZS5mYWRlT3V0PSExO214UnViYmVyYmFuZC5wcm90b3R5cGUuaXNFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5hYmxlZH07bXhSdWJiZXJiYW5kLnByb3RvdHlwZS5zZXRFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuZW5hYmxlZD1hfTtteFJ1YmJlcmJhbmQucHJvdG90eXBlLmlzRm9yY2VSdWJiZXJiYW5kRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG14RXZlbnQuaXNBbHREb3duKGEuZ2V0RXZlbnQoKSl9OwpteFJ1YmJlcmJhbmQucHJvdG90eXBlLm1vdXNlRG93bj1mdW5jdGlvbihhLGIpe2lmKCFiLmlzQ29uc3VtZWQoKSYmdGhpcy5pc0VuYWJsZWQoKSYmdGhpcy5ncmFwaC5pc0VuYWJsZWQoKSYmbnVsbD09Yi5nZXRTdGF0ZSgpJiYhbXhFdmVudC5pc011bHRpVG91Y2hFdmVudChiLmdldEV2ZW50KCkpKXt2YXIgYz1teFV0aWxzLmdldE9mZnNldCh0aGlzLmdyYXBoLmNvbnRhaW5lciksZD1teFV0aWxzLmdldFNjcm9sbE9yaWdpbih0aGlzLmdyYXBoLmNvbnRhaW5lcik7ZC54LT1jLng7ZC55LT1jLnk7dGhpcy5zdGFydChiLmdldFgoKStkLngsYi5nZXRZKCkrZC55KTtiLmNvbnN1bWUoITEpfX07Cm14UnViYmVyYmFuZC5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEpe2E9bmV3IG14TW91c2VFdmVudChhKTt2YXIgYj1teFV0aWxzLmNvbnZlcnRQb2ludChkLGEuZ2V0WCgpLGEuZ2V0WSgpKTthLmdyYXBoWD1iLng7YS5ncmFwaFk9Yi55O3JldHVybiBhfXRoaXMuZmlyc3Q9bmV3IG14UG9pbnQoYSxiKTt2YXIgZD10aGlzLmdyYXBoLmNvbnRhaW5lcjt0aGlzLmRyYWdIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMubW91c2VNb3ZlKHRoaXMuZ3JhcGgsYyhhKSl9KTt0aGlzLmRyb3BIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMubW91c2VVcCh0aGlzLmdyYXBoLGMoYSkpfSk7bXhDbGllbnQuSVNfRkYmJm14RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyhkb2N1bWVudCxudWxsLHRoaXMuZHJhZ0hhbmRsZXIsdGhpcy5kcm9wSGFuZGxlcil9OwpteFJ1YmJlcmJhbmQucHJvdG90eXBlLm1vdXNlTW92ZT1mdW5jdGlvbihhLGIpe2lmKCFiLmlzQ29uc3VtZWQoKSYmbnVsbCE9dGhpcy5maXJzdCl7dmFyIGM9bXhVdGlscy5nZXRTY3JvbGxPcmlnaW4odGhpcy5ncmFwaC5jb250YWluZXIpLGQ9bXhVdGlscy5nZXRPZmZzZXQodGhpcy5ncmFwaC5jb250YWluZXIpO2MueC09ZC54O2MueS09ZC55O3ZhciBkPWIuZ2V0WCgpK2MueCxjPWIuZ2V0WSgpK2MueSxlPXRoaXMuZmlyc3QueC1kLGY9dGhpcy5maXJzdC55LWMsZz10aGlzLmdyYXBoLnRvbGVyYW5jZTtpZihudWxsIT10aGlzLmRpdnx8TWF0aC5hYnMoZSk+Z3x8TWF0aC5hYnMoZik+ZyludWxsPT10aGlzLmRpdiYmKHRoaXMuZGl2PXRoaXMuY3JlYXRlU2hhcGUoKSksbXhVdGlscy5jbGVhclNlbGVjdGlvbigpLHRoaXMudXBkYXRlKGQsYyksYi5jb25zdW1lKCl9fTsKbXhSdWJiZXJiYW5kLnByb3RvdHlwZS5jcmVhdGVTaGFwZT1mdW5jdGlvbigpe251bGw9PXRoaXMuc2hhcmVkRGl2JiYodGhpcy5zaGFyZWREaXY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2IiksdGhpcy5zaGFyZWREaXYuY2xhc3NOYW1lPSJteFJ1YmJlcmJhbmQiLG14VXRpbHMuc2V0T3BhY2l0eSh0aGlzLnNoYXJlZERpdix0aGlzLmRlZmF1bHRPcGFjaXR5KSk7dGhpcy5ncmFwaC5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zaGFyZWREaXYpO3ZhciBhPXRoaXMuc2hhcmVkRGl2O214Q2xpZW50LklTX1NWRyYmKCFteENsaWVudC5JU19JRXx8MTA8PWRvY3VtZW50LmRvY3VtZW50TW9kZSkmJnRoaXMuZmFkZU91dCYmKHRoaXMuc2hhcmVkRGl2PW51bGwpO3JldHVybiBhfTtteFJ1YmJlcmJhbmQucHJvdG90eXBlLmlzQWN0aXZlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG51bGwhPXRoaXMuZGl2JiYibm9uZSIhPXRoaXMuZGl2LnN0eWxlLmRpc3BsYXl9OwpteFJ1YmJlcmJhbmQucHJvdG90eXBlLm1vdXNlVXA9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmlzQWN0aXZlKCk7dGhpcy5yZXNldCgpO2MmJih0aGlzLmV4ZWN1dGUoYi5nZXRFdmVudCgpKSxiLmNvbnN1bWUoKSl9O214UnViYmVyYmFuZC5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihhKXt2YXIgYj1uZXcgbXhSZWN0YW5nbGUodGhpcy54LHRoaXMueSx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KTt0aGlzLmdyYXBoLnNlbGVjdFJlZ2lvbihiLGEpfTsKbXhSdWJiZXJiYW5kLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe2lmKG51bGwhPXRoaXMuZGl2KWlmKG14Q2xpZW50LklTX1NWRyYmKCFteENsaWVudC5JU19JRXx8MTA8PWRvY3VtZW50LmRvY3VtZW50TW9kZSkmJnRoaXMuZmFkZU91dCl7dmFyIGE9dGhpcy5kaXY7bXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGEuc3R5bGUsInRyYW5zaXRpb24iLCJhbGwgMC4ycyBsaW5lYXIiKTthLnN0eWxlLnBvaW50ZXJFdmVudHM9Im5vbmUiO2Euc3R5bGUub3BhY2l0eT0wO3dpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpfSwyMDApfWVsc2UgdGhpcy5kaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRpdik7bXhFdmVudC5yZW1vdmVHZXN0dXJlTGlzdGVuZXJzKGRvY3VtZW50LG51bGwsdGhpcy5kcmFnSGFuZGxlcix0aGlzLmRyb3BIYW5kbGVyKTt0aGlzLmRyb3BIYW5kbGVyPXRoaXMuZHJhZ0hhbmRsZXI9bnVsbDt0aGlzLmN1cnJlbnRZPQp0aGlzLmN1cnJlbnRYPTA7dGhpcy5kaXY9dGhpcy5maXJzdD1udWxsfTtteFJ1YmJlcmJhbmQucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihhLGIpe3RoaXMuY3VycmVudFg9YTt0aGlzLmN1cnJlbnRZPWI7dGhpcy5yZXBhaW50KCl9OwpteFJ1YmJlcmJhbmQucHJvdG90eXBlLnJlcGFpbnQ9ZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLmRpdil7dmFyIGE9dGhpcy5jdXJyZW50WC10aGlzLmdyYXBoLnBhbkR4LGI9dGhpcy5jdXJyZW50WS10aGlzLmdyYXBoLnBhbkR5O3RoaXMueD1NYXRoLm1pbih0aGlzLmZpcnN0LngsYSk7dGhpcy55PU1hdGgubWluKHRoaXMuZmlyc3QueSxiKTt0aGlzLndpZHRoPU1hdGgubWF4KHRoaXMuZmlyc3QueCxhKS10aGlzLng7dGhpcy5oZWlnaHQ9TWF0aC5tYXgodGhpcy5maXJzdC55LGIpLXRoaXMueTthPW14Q2xpZW50LklTX1ZNTD90aGlzLmdyYXBoLnBhbkR5OjA7dGhpcy5kaXYuc3R5bGUubGVmdD10aGlzLngrKG14Q2xpZW50LklTX1ZNTD90aGlzLmdyYXBoLnBhbkR4OjApKyJweCI7dGhpcy5kaXYuc3R5bGUudG9wPXRoaXMueSthKyJweCI7dGhpcy5kaXYuc3R5bGUud2lkdGg9TWF0aC5tYXgoMSx0aGlzLndpZHRoKSsicHgiO3RoaXMuZGl2LnN0eWxlLmhlaWdodD1NYXRoLm1heCgxLAp0aGlzLmhlaWdodCkrInB4In19O214UnViYmVyYmFuZC5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZGVzdHJveWVkfHwodGhpcy5kZXN0cm95ZWQ9ITAsdGhpcy5ncmFwaC5yZW1vdmVNb3VzZUxpc3RlbmVyKHRoaXMpLHRoaXMuZ3JhcGgucmVtb3ZlTGlzdGVuZXIodGhpcy5mb3JjZVJ1YmJlcmJhbmRIYW5kbGVyKSx0aGlzLmdyYXBoLnJlbW92ZUxpc3RlbmVyKHRoaXMucGFuSGFuZGxlciksdGhpcy5yZXNldCgpLG51bGwhPXRoaXMuc2hhcmVkRGl2JiYodGhpcy5zaGFyZWREaXY9bnVsbCkpfTtmdW5jdGlvbiBteEhhbmRsZShhLGIsYyxkKXt0aGlzLmdyYXBoPWEudmlldy5ncmFwaDt0aGlzLnN0YXRlPWE7dGhpcy5jdXJzb3I9bnVsbCE9Yj9iOnRoaXMuY3Vyc29yO3RoaXMuaW1hZ2U9bnVsbCE9Yz9jOnRoaXMuaW1hZ2U7dGhpcy5zaGFwZT1udWxsIT1kP2Q6bnVsbDt0aGlzLmluaXQoKX1teEhhbmRsZS5wcm90b3R5cGUuY3Vyc29yPSJkZWZhdWx0IjsKbXhIYW5kbGUucHJvdG90eXBlLmltYWdlPW51bGw7bXhIYW5kbGUucHJvdG90eXBlLmlnbm9yZUdyaWQ9ITE7bXhIYW5kbGUucHJvdG90eXBlLmdldFBvc2l0aW9uPWZ1bmN0aW9uKGEpe307bXhIYW5kbGUucHJvdG90eXBlLnNldFBvc2l0aW9uPWZ1bmN0aW9uKGEsYixjKXt9O214SGFuZGxlLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGEpe307bXhIYW5kbGUucHJvdG90eXBlLmNvcHlTdHlsZT1mdW5jdGlvbihhKXt0aGlzLmdyYXBoLnNldENlbGxTdHlsZXMoYSx0aGlzLnN0YXRlLnN0eWxlW2FdLFt0aGlzLnN0YXRlLmNlbGxdKX07Cm14SGFuZGxlLnByb3RvdHlwZS5wcm9jZXNzRXZlbnQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5ncmFwaC52aWV3LnNjYWxlLGM9dGhpcy5ncmFwaC52aWV3LnRyYW5zbGF0ZSxjPW5ldyBteFBvaW50KGEuZ2V0R3JhcGhYKCkvYi1jLngsYS5nZXRHcmFwaFkoKS9iLWMueSk7bnVsbCE9dGhpcy5zaGFwZSYmbnVsbCE9dGhpcy5zaGFwZS5ib3VuZHMmJihjLngtPXRoaXMuc2hhcGUuYm91bmRzLndpZHRoL2IvNCxjLnktPXRoaXMuc2hhcGUuYm91bmRzLmhlaWdodC9iLzQpO3ZhciBiPS1teFV0aWxzLnRvUmFkaWFucyh0aGlzLmdldFJvdGF0aW9uKCkpLGQ9LW14VXRpbHMudG9SYWRpYW5zKHRoaXMuZ2V0VG90YWxSb3RhdGlvbigpKS1iLGM9dGhpcy5mbGlwUG9pbnQodGhpcy5yb3RhdGVQb2ludCh0aGlzLnNuYXBQb2ludCh0aGlzLnJvdGF0ZVBvaW50KGMsYiksdGhpcy5pZ25vcmVHcmlkfHwhdGhpcy5ncmFwaC5pc0dyaWRFbmFibGVkRXZlbnQoYS5nZXRFdmVudCgpKSksZCkpO3RoaXMuc2V0UG9zaXRpb24odGhpcy5zdGF0ZS5nZXRQYWludEJvdW5kcygpLApjLGEpO3RoaXMucmVkcmF3KCl9O214SGFuZGxlLnByb3RvdHlwZS5wb3NpdGlvbkNoYW5nZWQ9ZnVuY3Rpb24oKXtudWxsIT10aGlzLnN0YXRlLnRleHQmJnRoaXMuc3RhdGUudGV4dC5hcHBseSh0aGlzLnN0YXRlKTtudWxsIT10aGlzLnN0YXRlLnNoYXBlJiZ0aGlzLnN0YXRlLnNoYXBlLmFwcGx5KHRoaXMuc3RhdGUpO3RoaXMuZ3JhcGguY2VsbFJlbmRlcmVyLnJlZHJhdyh0aGlzLnN0YXRlLCEwKX07bXhIYW5kbGUucHJvdG90eXBlLmdldFJvdGF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuc3RhdGUuc2hhcGU/dGhpcy5zdGF0ZS5zaGFwZS5nZXRSb3RhdGlvbigpOjB9O214SGFuZGxlLnByb3RvdHlwZS5nZXRUb3RhbFJvdGF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuc3RhdGUuc2hhcGU/dGhpcy5zdGF0ZS5zaGFwZS5nZXRTaGFwZVJvdGF0aW9uKCk6MH07Cm14SGFuZGxlLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5pc0h0bWxSZXF1aXJlZCgpO251bGwhPXRoaXMuaW1hZ2U/KHRoaXMuc2hhcGU9bmV3IG14SW1hZ2VTaGFwZShuZXcgbXhSZWN0YW5nbGUoMCwwLHRoaXMuaW1hZ2Uud2lkdGgsdGhpcy5pbWFnZS5oZWlnaHQpLHRoaXMuaW1hZ2Uuc3JjKSx0aGlzLnNoYXBlLnByZXNlcnZlSW1hZ2VBc3BlY3Q9ITEpOm51bGw9PXRoaXMuc2hhcGUmJih0aGlzLnNoYXBlPXRoaXMuY3JlYXRlU2hhcGUoYSkpO3RoaXMuaW5pdFNoYXBlKGEpfTtteEhhbmRsZS5wcm90b3R5cGUuY3JlYXRlU2hhcGU9ZnVuY3Rpb24oYSl7YT1uZXcgbXhSZWN0YW5nbGUoMCwwLG14Q29uc3RhbnRzLkhBTkRMRV9TSVpFLG14Q29uc3RhbnRzLkhBTkRMRV9TSVpFKTtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlU2hhcGUoYSxteENvbnN0YW50cy5IQU5ETEVfRklMTENPTE9SLG14Q29uc3RhbnRzLkhBTkRMRV9TVFJPS0VDT0xPUil9OwpteEhhbmRsZS5wcm90b3R5cGUuaW5pdFNoYXBlPWZ1bmN0aW9uKGEpe2EmJnRoaXMuc2hhcGUuaXNIdG1sQWxsb3dlZCgpPyh0aGlzLnNoYXBlLmRpYWxlY3Q9bXhDb25zdGFudHMuRElBTEVDVF9TVFJJQ1RIVE1MLHRoaXMuc2hhcGUuaW5pdCh0aGlzLmdyYXBoLmNvbnRhaW5lcikpOih0aGlzLnNoYXBlLmRpYWxlY3Q9dGhpcy5ncmFwaC5kaWFsZWN0IT1teENvbnN0YW50cy5ESUFMRUNUX1NWRz9teENvbnN0YW50cy5ESUFMRUNUX01JWEVESFRNTDpteENvbnN0YW50cy5ESUFMRUNUX1NWRyxudWxsIT10aGlzLmN1cnNvciYmdGhpcy5zaGFwZS5pbml0KHRoaXMuZ3JhcGguZ2V0VmlldygpLmdldE92ZXJsYXlQYW5lKCkpKTtteEV2ZW50LnJlZGlyZWN0TW91c2VFdmVudHModGhpcy5zaGFwZS5ub2RlLHRoaXMuZ3JhcGgsdGhpcy5zdGF0ZSk7dGhpcy5zaGFwZS5ub2RlLnN0eWxlLmN1cnNvcj10aGlzLmN1cnNvcn07Cm14SGFuZGxlLnByb3RvdHlwZS5yZWRyYXc9ZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLnNoYXBlJiZudWxsIT10aGlzLnN0YXRlLnNoYXBlKXt2YXIgYT10aGlzLmdldFBvc2l0aW9uKHRoaXMuc3RhdGUuZ2V0UGFpbnRCb3VuZHMoKSk7aWYobnVsbCE9YSl7dmFyIGI9bXhVdGlscy50b1JhZGlhbnModGhpcy5nZXRUb3RhbFJvdGF0aW9uKCkpLGE9dGhpcy5yb3RhdGVQb2ludCh0aGlzLmZsaXBQb2ludChhKSxiKSxiPXRoaXMuZ3JhcGgudmlldy5zY2FsZSxjPXRoaXMuZ3JhcGgudmlldy50cmFuc2xhdGU7dGhpcy5zaGFwZS5ib3VuZHMueD1NYXRoLmZsb29yKChhLngrYy54KSpiLXRoaXMuc2hhcGUuYm91bmRzLndpZHRoLzIpO3RoaXMuc2hhcGUuYm91bmRzLnk9TWF0aC5mbG9vcigoYS55K2MueSkqYi10aGlzLnNoYXBlLmJvdW5kcy5oZWlnaHQvMik7dGhpcy5zaGFwZS5yZWRyYXcoKX19fTsKbXhIYW5kbGUucHJvdG90eXBlLmlzSHRtbFJlcXVpcmVkPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuc3RhdGUudGV4dCYmdGhpcy5zdGF0ZS50ZXh0Lm5vZGUucGFyZW50Tm9kZT09dGhpcy5ncmFwaC5jb250YWluZXJ9O214SGFuZGxlLnByb3RvdHlwZS5yb3RhdGVQb2ludD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuc3RhdGUuZ2V0Q2VsbEJvdW5kcygpLGM9bmV3IG14UG9pbnQoYy5nZXRDZW50ZXJYKCksYy5nZXRDZW50ZXJZKCkpO3JldHVybiBteFV0aWxzLmdldFJvdGF0ZWRQb2ludChhLE1hdGguY29zKGIpLE1hdGguc2luKGIpLGMpfTsKbXhIYW5kbGUucHJvdG90eXBlLmZsaXBQb2ludD1mdW5jdGlvbihhKXtpZihudWxsIT10aGlzLnN0YXRlLnNoYXBlKXt2YXIgYj10aGlzLnN0YXRlLmdldENlbGxCb3VuZHMoKTt0aGlzLnN0YXRlLnNoYXBlLmZsaXBIJiYoYS54PTIqYi54K2Iud2lkdGgtYS54KTt0aGlzLnN0YXRlLnNoYXBlLmZsaXBWJiYoYS55PTIqYi55K2IuaGVpZ2h0LWEueSl9cmV0dXJuIGF9O214SGFuZGxlLnByb3RvdHlwZS5zbmFwUG9pbnQ9ZnVuY3Rpb24oYSxiKXtifHwoYS54PXRoaXMuZ3JhcGguc25hcChhLngpLGEueT10aGlzLmdyYXBoLnNuYXAoYS55KSk7cmV0dXJuIGF9O214SGFuZGxlLnByb3RvdHlwZS5zZXRWaXNpYmxlPWZ1bmN0aW9uKGEpe251bGwhPXRoaXMuc2hhcGUmJm51bGwhPXRoaXMuc2hhcGUubm9kZSYmKHRoaXMuc2hhcGUubm9kZS5zdHlsZS5kaXNwbGF5PWE/IiI6Im5vbmUiKX07Cm14SGFuZGxlLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMuc2V0VmlzaWJsZSghMCk7dGhpcy5zdGF0ZS5zdHlsZT10aGlzLmdyYXBoLmdldENlbGxTdHlsZSh0aGlzLnN0YXRlLmNlbGwpO3RoaXMucG9zaXRpb25DaGFuZ2VkKCl9O214SGFuZGxlLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5zaGFwZSYmKHRoaXMuc2hhcGUuZGVzdHJveSgpLHRoaXMuc2hhcGU9bnVsbCl9OwpmdW5jdGlvbiBteFZlcnRleEhhbmRsZXIoYSl7bnVsbCE9YSYmKHRoaXMuc3RhdGU9YSx0aGlzLmluaXQoKSx0aGlzLmVzY2FwZUhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXt0aGlzLmxpdmVQcmV2aWV3JiZudWxsIT10aGlzLmluZGV4JiYodGhpcy5zdGF0ZS52aWV3LmdyYXBoLmNlbGxSZW5kZXJlci5yZWRyYXcodGhpcy5zdGF0ZSwhMCksdGhpcy5zdGF0ZS52aWV3LmludmFsaWRhdGUodGhpcy5zdGF0ZS5jZWxsKSx0aGlzLnN0YXRlLmludmFsaWQ9ITEsdGhpcy5zdGF0ZS52aWV3LnZhbGlkYXRlKCkpO3RoaXMucmVzZXQoKX0pLHRoaXMuc3RhdGUudmlldy5ncmFwaC5hZGRMaXN0ZW5lcihteEV2ZW50LkVTQ0FQRSx0aGlzLmVzY2FwZUhhbmRsZXIpKX1teFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmdyYXBoPW51bGw7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5zdGF0ZT1udWxsO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuc2luZ2xlU2l6ZXI9ITE7Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaW5kZXg9bnVsbDtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmFsbG93SGFuZGxlQm91bmRzQ2hlY2s9ITA7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVJbWFnZT1udWxsO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUudG9sZXJhbmNlPTA7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5yb3RhdGlvbkVuYWJsZWQ9ITE7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5wYXJlbnRIaWdobGlnaHRFbmFibGVkPSExO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUucm90YXRpb25SYXN0ZXI9ITA7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5yb3RhdGlvbkN1cnNvcj0iY3Jvc3NoYWlyIjtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmxpdmVQcmV2aWV3PSExO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUubWFuYWdlU2l6ZXJzPSExO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuY29uc3RyYWluR3JvdXBCeUNoaWxkcmVuPSExOwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJvdGF0aW9uSGFuZGxlVlNwYWNpbmc9LTE2O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaG9yaXpvbnRhbE9mZnNldD0wO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUudmVydGljYWxPZmZzZXQ9MDsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7dGhpcy5ncmFwaD10aGlzLnN0YXRlLnZpZXcuZ3JhcGg7dGhpcy5zZWxlY3Rpb25Cb3VuZHM9dGhpcy5nZXRTZWxlY3Rpb25Cb3VuZHModGhpcy5zdGF0ZSk7dGhpcy5ib3VuZHM9bmV3IG14UmVjdGFuZ2xlKHRoaXMuc2VsZWN0aW9uQm91bmRzLngsdGhpcy5zZWxlY3Rpb25Cb3VuZHMueSx0aGlzLnNlbGVjdGlvbkJvdW5kcy53aWR0aCx0aGlzLnNlbGVjdGlvbkJvdW5kcy5oZWlnaHQpO3RoaXMuc2VsZWN0aW9uQm9yZGVyPXRoaXMuY3JlYXRlU2VsZWN0aW9uU2hhcGUodGhpcy5ib3VuZHMpO3RoaXMuc2VsZWN0aW9uQm9yZGVyLmRpYWxlY3Q9dGhpcy5ncmFwaC5kaWFsZWN0IT1teENvbnN0YW50cy5ESUFMRUNUX1NWRz9teENvbnN0YW50cy5ESUFMRUNUX1ZNTDpteENvbnN0YW50cy5ESUFMRUNUX1NWRzt0aGlzLnNlbGVjdGlvbkJvcmRlci5wb2ludGVyRXZlbnRzPSExO3RoaXMuc2VsZWN0aW9uQm9yZGVyLnJvdGF0aW9uPQpOdW1iZXIodGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTl18fCIwIik7dGhpcy5zZWxlY3Rpb25Cb3JkZXIuaW5pdCh0aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRPdmVybGF5UGFuZSgpKTtteEV2ZW50LnJlZGlyZWN0TW91c2VFdmVudHModGhpcy5zZWxlY3Rpb25Cb3JkZXIubm9kZSx0aGlzLmdyYXBoLHRoaXMuc3RhdGUpO3RoaXMuZ3JhcGguaXNDZWxsTW92YWJsZSh0aGlzLnN0YXRlLmNlbGwpJiZ0aGlzLnNlbGVjdGlvbkJvcmRlci5zZXRDdXJzb3IobXhDb25zdGFudHMuQ1VSU09SX01PVkFCTEVfVkVSVEVYKTtpZigwPj1teEdyYXBoSGFuZGxlci5wcm90b3R5cGUubWF4Q2VsbHN8fHRoaXMuZ3JhcGguZ2V0U2VsZWN0aW9uQ291bnQoKTxteEdyYXBoSGFuZGxlci5wcm90b3R5cGUubWF4Q2VsbHMpe3ZhciBhPXRoaXMuZ3JhcGguaXNDZWxsUmVzaXphYmxlKHRoaXMuc3RhdGUuY2VsbCk7dGhpcy5zaXplcnM9W107aWYoYXx8dGhpcy5ncmFwaC5pc0xhYmVsTW92YWJsZSh0aGlzLnN0YXRlLmNlbGwpJiYKMjw9dGhpcy5zdGF0ZS53aWR0aCYmMjw9dGhpcy5zdGF0ZS5oZWlnaHQpe3ZhciBiPTA7YSYmKHRoaXMuc2luZ2xlU2l6ZXJ8fCh0aGlzLnNpemVycy5wdXNoKHRoaXMuY3JlYXRlU2l6ZXIoIm53LXJlc2l6ZSIsYisrKSksdGhpcy5zaXplcnMucHVzaCh0aGlzLmNyZWF0ZVNpemVyKCJuLXJlc2l6ZSIsYisrKSksdGhpcy5zaXplcnMucHVzaCh0aGlzLmNyZWF0ZVNpemVyKCJuZS1yZXNpemUiLGIrKykpLHRoaXMuc2l6ZXJzLnB1c2godGhpcy5jcmVhdGVTaXplcigidy1yZXNpemUiLGIrKykpLHRoaXMuc2l6ZXJzLnB1c2godGhpcy5jcmVhdGVTaXplcigiZS1yZXNpemUiLGIrKykpLHRoaXMuc2l6ZXJzLnB1c2godGhpcy5jcmVhdGVTaXplcigic3ctcmVzaXplIixiKyspKSx0aGlzLnNpemVycy5wdXNoKHRoaXMuY3JlYXRlU2l6ZXIoInMtcmVzaXplIixiKyspKSksdGhpcy5zaXplcnMucHVzaCh0aGlzLmNyZWF0ZVNpemVyKCJzZS1yZXNpemUiLGIrKykpKTthPXRoaXMuZ3JhcGgubW9kZWwuZ2V0R2VvbWV0cnkodGhpcy5zdGF0ZS5jZWxsKTsKbnVsbD09YXx8YS5yZWxhdGl2ZXx8dGhpcy5ncmFwaC5pc1N3aW1sYW5lKHRoaXMuc3RhdGUuY2VsbCl8fCF0aGlzLmdyYXBoLmlzTGFiZWxNb3ZhYmxlKHRoaXMuc3RhdGUuY2VsbCl8fCh0aGlzLmxhYmVsU2hhcGU9dGhpcy5jcmVhdGVTaXplcihteENvbnN0YW50cy5DVVJTT1JfTEFCRUxfSEFORExFLG14RXZlbnQuTEFCRUxfSEFORExFLG14Q29uc3RhbnRzLkxBQkVMX0hBTkRMRV9TSVpFLG14Q29uc3RhbnRzLkxBQkVMX0hBTkRMRV9GSUxMQ09MT1IpLHRoaXMuc2l6ZXJzLnB1c2godGhpcy5sYWJlbFNoYXBlKSl9ZWxzZSB0aGlzLmdyYXBoLmlzQ2VsbE1vdmFibGUodGhpcy5zdGF0ZS5jZWxsKSYmIXRoaXMuZ3JhcGguaXNDZWxsUmVzaXphYmxlKHRoaXMuc3RhdGUuY2VsbCkmJjI+dGhpcy5zdGF0ZS53aWR0aCYmMj50aGlzLnN0YXRlLmhlaWdodCYmKHRoaXMubGFiZWxTaGFwZT10aGlzLmNyZWF0ZVNpemVyKG14Q29uc3RhbnRzLkNVUlNPUl9NT1ZBQkxFX1ZFUlRFWCxteEV2ZW50LkxBQkVMX0hBTkRMRSwKbnVsbCxteENvbnN0YW50cy5MQUJFTF9IQU5ETEVfRklMTENPTE9SKSx0aGlzLnNpemVycy5wdXNoKHRoaXMubGFiZWxTaGFwZSkpfXRoaXMuaXNSb3RhdGlvbkhhbmRsZVZpc2libGUoKSYmKHRoaXMucm90YXRpb25TaGFwZT10aGlzLmNyZWF0ZVNpemVyKHRoaXMucm90YXRpb25DdXJzb3IsbXhFdmVudC5ST1RBVElPTl9IQU5ETEUsbXhDb25zdGFudHMuSEFORExFX1NJWkUrMyxteENvbnN0YW50cy5IQU5ETEVfRklMTENPTE9SKSx0aGlzLnNpemVycy5wdXNoKHRoaXMucm90YXRpb25TaGFwZSkpO3RoaXMuY3VzdG9tSGFuZGxlcz10aGlzLmNyZWF0ZUN1c3RvbUhhbmRsZXMoKTt0aGlzLnJlZHJhdygpO3RoaXMuY29uc3RyYWluR3JvdXBCeUNoaWxkcmVuJiZ0aGlzLnVwZGF0ZU1pbkJvdW5kcygpfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5pc1JvdGF0aW9uSGFuZGxlVmlzaWJsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdyYXBoLmlzRW5hYmxlZCgpJiZ0aGlzLnJvdGF0aW9uRW5hYmxlZCYmdGhpcy5ncmFwaC5pc0NlbGxSb3RhdGFibGUodGhpcy5zdGF0ZS5jZWxsKSYmKDA+PW14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5tYXhDZWxsc3x8dGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25Db3VudCgpPG14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5tYXhDZWxscyl9O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaXNDb25zdHJhaW5lZEV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiBteEV2ZW50LmlzU2hpZnREb3duKGEuZ2V0RXZlbnQoKSl8fCJmaXhlZCI9PXRoaXMuc3RhdGUuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfQVNQRUNUXX07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5pc0NlbnRlcmVkRXZlbnQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4hMX07Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuY3JlYXRlQ3VzdG9tSGFuZGxlcz1mdW5jdGlvbigpe3JldHVybiBudWxsfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVNaW5Cb3VuZHM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoLmdldENoaWxkQ2VsbHModGhpcy5zdGF0ZS5jZWxsKTtpZigwPGEubGVuZ3RoJiYodGhpcy5taW5Cb3VuZHM9dGhpcy5ncmFwaC52aWV3LmdldEJvdW5kcyhhKSxudWxsIT10aGlzLm1pbkJvdW5kcykpe3ZhciBhPXRoaXMuc3RhdGUudmlldy5zY2FsZSxiPXRoaXMuc3RhdGUudmlldy50cmFuc2xhdGU7dGhpcy5taW5Cb3VuZHMueC09dGhpcy5zdGF0ZS54O3RoaXMubWluQm91bmRzLnktPXRoaXMuc3RhdGUueTt0aGlzLm1pbkJvdW5kcy54Lz1hO3RoaXMubWluQm91bmRzLnkvPWE7dGhpcy5taW5Cb3VuZHMud2lkdGgvPWE7dGhpcy5taW5Cb3VuZHMuaGVpZ2h0Lz1hO3RoaXMueDA9dGhpcy5zdGF0ZS54L2EtYi54O3RoaXMueTA9dGhpcy5zdGF0ZS55L2EtYi55fX07Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uQm91bmRzPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgbXhSZWN0YW5nbGUoTWF0aC5yb3VuZChhLngpLE1hdGgucm91bmQoYS55KSxNYXRoLnJvdW5kKGEud2lkdGgpLE1hdGgucm91bmQoYS5oZWlnaHQpKX07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVQYXJlbnRIaWdobGlnaHRTaGFwZT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5jcmVhdGVTZWxlY3Rpb25TaGFwZShhKX07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVTZWxlY3Rpb25TaGFwZT1mdW5jdGlvbihhKXthPW5ldyBteFJlY3RhbmdsZVNoYXBlKG14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUoYSksbnVsbCx0aGlzLmdldFNlbGVjdGlvbkNvbG9yKCkpO2Euc3Ryb2tld2lkdGg9dGhpcy5nZXRTZWxlY3Rpb25TdHJva2VXaWR0aCgpO2EuaXNEYXNoZWQ9dGhpcy5pc1NlbGVjdGlvbkRhc2hlZCgpO3JldHVybiBhfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25Db2xvcj1mdW5jdGlvbigpe3JldHVybiBteENvbnN0YW50cy5WRVJURVhfU0VMRUNUSU9OX0NPTE9SfTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmdldFNlbGVjdGlvblN0cm9rZVdpZHRoPWZ1bmN0aW9uKCl7cmV0dXJuIG14Q29uc3RhbnRzLlZFUlRFWF9TRUxFQ1RJT05fU1RST0tFV0lEVEh9O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaXNTZWxlY3Rpb25EYXNoZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbXhDb25zdGFudHMuVkVSVEVYX1NFTEVDVElPTl9EQVNIRUR9OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZVNpemVyPWZ1bmN0aW9uKGEsYixjLGQpe2M9Y3x8bXhDb25zdGFudHMuSEFORExFX1NJWkU7Yz1uZXcgbXhSZWN0YW5nbGUoMCwwLGMsYyk7ZD10aGlzLmNyZWF0ZVNpemVyU2hhcGUoYyxiLGQpO2QuaXNIdG1sQWxsb3dlZCgpJiZudWxsIT10aGlzLnN0YXRlLnRleHQmJnRoaXMuc3RhdGUudGV4dC5ub2RlLnBhcmVudE5vZGU9PXRoaXMuZ3JhcGguY29udGFpbmVyPygtLWQuYm91bmRzLmhlaWdodCwtLWQuYm91bmRzLndpZHRoLGQuZGlhbGVjdD1teENvbnN0YW50cy5ESUFMRUNUX1NUUklDVEhUTUwsZC5pbml0KHRoaXMuZ3JhcGguY29udGFpbmVyKSk6KGQuZGlhbGVjdD10aGlzLmdyYXBoLmRpYWxlY3QhPW14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHP214Q29uc3RhbnRzLkRJQUxFQ1RfTUlYRURIVE1MOm14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHLGQuaW5pdCh0aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRPdmVybGF5UGFuZSgpKSk7Cm14RXZlbnQucmVkaXJlY3RNb3VzZUV2ZW50cyhkLm5vZGUsdGhpcy5ncmFwaCx0aGlzLnN0YXRlKTt0aGlzLmdyYXBoLmlzRW5hYmxlZCgpJiZkLnNldEN1cnNvcihhKTt0aGlzLmlzU2l6ZXJWaXNpYmxlKGIpfHwoZC52aXNpYmxlPSExKTtyZXR1cm4gZH07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5pc1NpemVyVmlzaWJsZT1mdW5jdGlvbihhKXtyZXR1cm4hMH07Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuY3JlYXRlU2l6ZXJTaGFwZT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIG51bGwhPXRoaXMuaGFuZGxlSW1hZ2U/KGE9bmV3IG14UmVjdGFuZ2xlKGEueCxhLnksdGhpcy5oYW5kbGVJbWFnZS53aWR0aCx0aGlzLmhhbmRsZUltYWdlLmhlaWdodCksYT1uZXcgbXhJbWFnZVNoYXBlKGEsdGhpcy5oYW5kbGVJbWFnZS5zcmMpLGEucHJlc2VydmVJbWFnZUFzcGVjdD0hMSxhKTpiPT1teEV2ZW50LlJPVEFUSU9OX0hBTkRMRT9uZXcgbXhFbGxpcHNlKGEsY3x8bXhDb25zdGFudHMuSEFORExFX0ZJTExDT0xPUixteENvbnN0YW50cy5IQU5ETEVfU1RST0tFQ09MT1IpOm5ldyBteFJlY3RhbmdsZVNoYXBlKGEsY3x8bXhDb25zdGFudHMuSEFORExFX0ZJTExDT0xPUixteENvbnN0YW50cy5IQU5ETEVfU1RST0tFQ09MT1IpfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5tb3ZlU2l6ZXJUbz1mdW5jdGlvbihhLGIsYyl7bnVsbCE9YSYmKGEuYm91bmRzLng9TWF0aC5mbG9vcihiLWEuYm91bmRzLndpZHRoLzIpLGEuYm91bmRzLnk9TWF0aC5mbG9vcihjLWEuYm91bmRzLmhlaWdodC8yKSxudWxsIT1hLm5vZGUmJiJub25lIiE9YS5ub2RlLnN0eWxlLmRpc3BsYXkmJmEucmVkcmF3KCkpfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5nZXRIYW5kbGVGb3JFdmVudD1mdW5jdGlvbihhKXt2YXIgYj1teEV2ZW50LmlzTW91c2VFdmVudChhLmdldEV2ZW50KCkpPzE6dGhpcy50b2xlcmFuY2UsYz10aGlzLmFsbG93SGFuZGxlQm91bmRzQ2hlY2smJihteENsaWVudC5JU19JRXx8MDxiKT9uZXcgbXhSZWN0YW5nbGUoYS5nZXRHcmFwaFgoKS1iLGEuZ2V0R3JhcGhZKCktYiwyKmIsMipiKTpudWxsLGI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7dmFyIGQ9bnVsbCE9YiYmYi5jb25zdHJ1Y3RvciE9bXhJbWFnZVNoYXBlJiZ0aGlzLmFsbG93SGFuZGxlQm91bmRzQ2hlY2s/bmV3IG14UmVjdGFuZ2xlKGEuZ2V0R3JhcGhYKCktYi5zdmdTdHJva2VUb2xlcmFuY2UsYS5nZXRHcmFwaFkoKS1iLnN2Z1N0cm9rZVRvbGVyYW5jZSwyKmIuc3ZnU3Ryb2tlVG9sZXJhbmNlLDIqYi5zdmdTdHJva2VUb2xlcmFuY2UpOmM7cmV0dXJuIG51bGwhPWImJihhLmlzU291cmNlKGIpfHxudWxsIT0KZCYmbXhVdGlscy5pbnRlcnNlY3RzKGIuYm91bmRzLGQpJiYibm9uZSIhPWIubm9kZS5zdHlsZS5kaXNwbGF5JiYiaGlkZGVuIiE9Yi5ub2RlLnN0eWxlLnZpc2liaWxpdHkpfSk7aWYoYih0aGlzLnJvdGF0aW9uU2hhcGUpKXJldHVybiBteEV2ZW50LlJPVEFUSU9OX0hBTkRMRTtpZihiKHRoaXMubGFiZWxTaGFwZSkpcmV0dXJuIG14RXZlbnQuTEFCRUxfSEFORExFO2lmKG51bGwhPXRoaXMuc2l6ZXJzKWZvcih2YXIgZD0wO2Q8dGhpcy5zaXplcnMubGVuZ3RoO2QrKylpZihiKHRoaXMuc2l6ZXJzW2RdKSlyZXR1cm4gZDtpZihudWxsIT10aGlzLmN1c3RvbUhhbmRsZXMmJnRoaXMuaXNDdXN0b21IYW5kbGVFdmVudChhKSlmb3IoZD10aGlzLmN1c3RvbUhhbmRsZXMubGVuZ3RoLTE7MDw9ZDtkLS0paWYoYih0aGlzLmN1c3RvbUhhbmRsZXNbZF0uc2hhcGUpKXJldHVybiBteEV2ZW50LkNVU1RPTV9IQU5ETEUtZDtyZXR1cm4gbnVsbH07Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaXNDdXN0b21IYW5kbGVFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4hMH07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5tb3VzZURvd249ZnVuY3Rpb24oYSxiKXtpZighYi5pc0NvbnN1bWVkKCkmJnRoaXMuZ3JhcGguaXNFbmFibGVkKCkpe3ZhciBjPXRoaXMuZ2V0SGFuZGxlRm9yRXZlbnQoYik7bnVsbCE9YyYmKHRoaXMuc3RhcnQoYi5nZXRHcmFwaFgoKSxiLmdldEdyYXBoWSgpLGMpLGIuY29uc3VtZSgpKX19O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaXNMaXZlUHJldmlld0JvcmRlcj1mdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLnN0YXRlLnNoYXBlJiZudWxsPT10aGlzLnN0YXRlLnNoYXBlLmZpbGwmJm51bGw9PXRoaXMuc3RhdGUuc2hhcGUuc3Ryb2tlfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbihhLGIsYyl7aWYobnVsbCE9dGhpcy5zZWxlY3Rpb25Cb3JkZXIpaWYodGhpcy5saXZlUHJldmlld0FjdGl2ZT10aGlzLmxpdmVQcmV2aWV3JiYwPT10aGlzLmdyYXBoLm1vZGVsLmdldENoaWxkQ291bnQodGhpcy5zdGF0ZS5jZWxsKSx0aGlzLmluVG9sZXJhbmNlPSEwLHRoaXMuY2hpbGRPZmZzZXRZPXRoaXMuY2hpbGRPZmZzZXRYPTAsdGhpcy5pbmRleD1jLHRoaXMuc3RhcnRYPWEsdGhpcy5zdGFydFk9Yix0aGlzLmluZGV4PD1teEV2ZW50LkNVU1RPTV9IQU5ETEUmJnRoaXMuaXNHaG9zdFByZXZpZXcoKSl0aGlzLmdob3N0UHJldmlldz10aGlzLmNyZWF0ZUdob3N0UHJldmlldygpO2Vsc2V7YT10aGlzLnN0YXRlLnZpZXcuZ3JhcGgubW9kZWw7Yj1hLmdldFBhcmVudCh0aGlzLnN0YXRlLmNlbGwpO3RoaXMuc3RhdGUudmlldy5jdXJyZW50Um9vdCE9YiYmKGEuaXNWZXJ0ZXgoYil8fGEuaXNFZGdlKGIpKSYmCih0aGlzLnBhcmVudFN0YXRlPXRoaXMuc3RhdGUudmlldy5ncmFwaC52aWV3LmdldFN0YXRlKGIpKTt0aGlzLnNlbGVjdGlvbkJvcmRlci5ub2RlLnN0eWxlLmRpc3BsYXk9Yz09bXhFdmVudC5ST1RBVElPTl9IQU5ETEU/ImlubGluZSI6Im5vbmUiO2lmKCF0aGlzLmxpdmVQcmV2aWV3QWN0aXZlfHx0aGlzLmlzTGl2ZVByZXZpZXdCb3JkZXIoKSl0aGlzLnByZXZpZXc9dGhpcy5jcmVhdGVTZWxlY3Rpb25TaGFwZSh0aGlzLmJvdW5kcyksbXhDbGllbnQuSVNfU1ZHJiYwIT1OdW1iZXIodGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTl18fCIwIil8fG51bGw9PXRoaXMuc3RhdGUudGV4dHx8dGhpcy5zdGF0ZS50ZXh0Lm5vZGUucGFyZW50Tm9kZSE9dGhpcy5ncmFwaC5jb250YWluZXI/KHRoaXMucHJldmlldy5kaWFsZWN0PXRoaXMuZ3JhcGguZGlhbGVjdCE9bXhDb25zdGFudHMuRElBTEVDVF9TVkc/bXhDb25zdGFudHMuRElBTEVDVF9WTUw6bXhDb25zdGFudHMuRElBTEVDVF9TVkcsCnRoaXMucHJldmlldy5pbml0KHRoaXMuZ3JhcGgudmlldy5nZXRPdmVybGF5UGFuZSgpKSk6KHRoaXMucHJldmlldy5kaWFsZWN0PW14Q29uc3RhbnRzLkRJQUxFQ1RfU1RSSUNUSFRNTCx0aGlzLnByZXZpZXcuaW5pdCh0aGlzLmdyYXBoLmNvbnRhaW5lcikpO2M9PW14RXZlbnQuUk9UQVRJT05fSEFORExFJiYoYj10aGlzLmdldFJvdGF0aW9uSGFuZGxlUG9zaXRpb24oKSxhPWIueC10aGlzLnN0YXRlLmdldENlbnRlclgoKSxiPWIueS10aGlzLnN0YXRlLmdldENlbnRlclkoKSx0aGlzLnN0YXJ0QW5nbGU9MCE9YT8xODAqTWF0aC5hdGFuKGIvYSkvTWF0aC5QSSs5MDowPmI/MTgwOjAsdGhpcy5zdGFydERpc3Q9TWF0aC5zcXJ0KGEqYStiKmIpKTtpZih0aGlzLmxpdmVQcmV2aWV3QWN0aXZlKWZvcih0aGlzLmhpZGVTaXplcnMoKSxjPT1teEV2ZW50LlJPVEFUSU9OX0hBTkRMRT90aGlzLnJvdGF0aW9uU2hhcGUubm9kZS5zdHlsZS5kaXNwbGF5PSIiOmM9PW14RXZlbnQuTEFCRUxfSEFORExFPwp0aGlzLmxhYmVsU2hhcGUubm9kZS5zdHlsZS5kaXNwbGF5PSIiOm51bGwhPXRoaXMuc2l6ZXJzJiZudWxsIT10aGlzLnNpemVyc1tjXT90aGlzLnNpemVyc1tjXS5ub2RlLnN0eWxlLmRpc3BsYXk9IiI6Yzw9bXhFdmVudC5DVVNUT01fSEFORExFJiZudWxsIT10aGlzLmN1c3RvbUhhbmRsZXMmJnRoaXMuY3VzdG9tSGFuZGxlc1tteEV2ZW50LkNVU1RPTV9IQU5ETEUtY10uc2V0VmlzaWJsZSghMCksYz10aGlzLmdyYXBoLmdldEVkZ2VzKHRoaXMuc3RhdGUuY2VsbCksdGhpcy5lZGdlSGFuZGxlcnM9W10sYT0wO2E8Yy5sZW5ndGg7YSsrKWI9dGhpcy5ncmFwaC5zZWxlY3Rpb25DZWxsc0hhbmRsZXIuZ2V0SGFuZGxlcihjW2FdKSxudWxsIT1iJiZ0aGlzLmVkZ2VIYW5kbGVycy5wdXNoKGIpfX07Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuY3JlYXRlR2hvc3RQcmV2aWV3PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5ncmFwaC5jZWxsUmVuZGVyZXIuY3JlYXRlU2hhcGUodGhpcy5zdGF0ZSk7YS5pbml0KHRoaXMuZ3JhcGgudmlldy5nZXRPdmVybGF5UGFuZSgpKTthLnNjYWxlPXRoaXMuc3RhdGUudmlldy5zY2FsZTthLmJvdW5kcz10aGlzLmJvdW5kczthLm91dGxpbmU9ITA7cmV0dXJuIGF9O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuc2V0SGFuZGxlc1Zpc2libGU9ZnVuY3Rpb24oYSl7aWYobnVsbCE9dGhpcy5zaXplcnMpZm9yKHZhciBiPTA7Yjx0aGlzLnNpemVycy5sZW5ndGg7YisrKXRoaXMuc2l6ZXJzW2JdLm5vZGUuc3R5bGUuZGlzcGxheT1hPyIiOiJub25lIjtpZihudWxsIT10aGlzLmN1c3RvbUhhbmRsZXMpZm9yKGI9MDtiPHRoaXMuY3VzdG9tSGFuZGxlcy5sZW5ndGg7YisrKXRoaXMuY3VzdG9tSGFuZGxlc1tiXS5zZXRWaXNpYmxlKGEpfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5oaWRlU2l6ZXJzPWZ1bmN0aW9uKCl7dGhpcy5zZXRIYW5kbGVzVmlzaWJsZSghMSl9O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuY2hlY2tUb2xlcmFuY2U9ZnVuY3Rpb24oYSl7dGhpcy5pblRvbGVyYW5jZSYmbnVsbCE9dGhpcy5zdGFydFgmJm51bGwhPXRoaXMuc3RhcnRZJiYobXhFdmVudC5pc01vdXNlRXZlbnQoYS5nZXRFdmVudCgpKXx8TWF0aC5hYnMoYS5nZXRHcmFwaFgoKS10aGlzLnN0YXJ0WCk+dGhpcy5ncmFwaC50b2xlcmFuY2V8fE1hdGguYWJzKGEuZ2V0R3JhcGhZKCktdGhpcy5zdGFydFkpPnRoaXMuZ3JhcGgudG9sZXJhbmNlKSYmKHRoaXMuaW5Ub2xlcmFuY2U9ITEpfTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZUhpbnQ9ZnVuY3Rpb24oYSl7fTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJlbW92ZUhpbnQ9ZnVuY3Rpb24oKXt9OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJvdW5kQW5nbGU9ZnVuY3Rpb24oYSl7cmV0dXJuIE1hdGgucm91bmQoMTAqYSkvMTB9O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUucm91bmRMZW5ndGg9ZnVuY3Rpb24oYSl7cmV0dXJuIE1hdGgucm91bmQoMTAwKmEpLzEwMH07Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUubW91c2VNb3ZlPWZ1bmN0aW9uKGEsYil7Yi5pc0NvbnN1bWVkKCl8fG51bGw9PXRoaXMuaW5kZXg/dGhpcy5ncmFwaC5pc01vdXNlRG93bnx8bnVsbD09dGhpcy5nZXRIYW5kbGVGb3JFdmVudChiKXx8Yi5jb25zdW1lKCExKToodGhpcy5jaGVja1RvbGVyYW5jZShiKSx0aGlzLmluVG9sZXJhbmNlfHwodGhpcy5pbmRleDw9bXhFdmVudC5DVVNUT01fSEFORExFP251bGwhPXRoaXMuY3VzdG9tSGFuZGxlcyYmKHRoaXMuY3VzdG9tSGFuZGxlc1tteEV2ZW50LkNVU1RPTV9IQU5ETEUtdGhpcy5pbmRleF0ucHJvY2Vzc0V2ZW50KGIpLHRoaXMuY3VzdG9tSGFuZGxlc1tteEV2ZW50LkNVU1RPTV9IQU5ETEUtdGhpcy5pbmRleF0uYWN0aXZlPSEwLG51bGwhPXRoaXMuZ2hvc3RQcmV2aWV3Pyh0aGlzLmdob3N0UHJldmlldy5hcHBseSh0aGlzLnN0YXRlKSx0aGlzLmdob3N0UHJldmlldy5zdHJva2V3aWR0aD10aGlzLmdldFNlbGVjdGlvblN0cm9rZVdpZHRoKCkvCnRoaXMuZ2hvc3RQcmV2aWV3LnNjYWxlL3RoaXMuZ2hvc3RQcmV2aWV3LnNjYWxlLHRoaXMuZ2hvc3RQcmV2aWV3LmlzRGFzaGVkPXRoaXMuaXNTZWxlY3Rpb25EYXNoZWQoKSx0aGlzLmdob3N0UHJldmlldy5zdHJva2U9dGhpcy5nZXRTZWxlY3Rpb25Db2xvcigpLHRoaXMuZ2hvc3RQcmV2aWV3LnJlZHJhdygpLG51bGwhPXRoaXMuc2VsZWN0aW9uQm91bmRzJiYodGhpcy5zZWxlY3Rpb25Cb3JkZXIubm9kZS5zdHlsZS5kaXNwbGF5PSJub25lIikpOih0aGlzLm1vdmVUb0Zyb250KCksdGhpcy5jdXN0b21IYW5kbGVzW214RXZlbnQuQ1VTVE9NX0hBTkRMRS10aGlzLmluZGV4XS5wb3NpdGlvbkNoYW5nZWQoKSkpOnRoaXMuaW5kZXg9PW14RXZlbnQuTEFCRUxfSEFORExFP3RoaXMubW92ZUxhYmVsKGIpOnRoaXMuaW5kZXg9PW14RXZlbnQuUk9UQVRJT05fSEFORExFP3RoaXMucm90YXRlVmVydGV4KGIpOih0aGlzLnJlc2l6ZVZlcnRleChiKSx0aGlzLnVwZGF0ZUhpbnQoYikpKSxiLmNvbnN1bWUoKSl9OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmlzR2hvc3RQcmV2aWV3PWZ1bmN0aW9uKCl7cmV0dXJuIDA8dGhpcy5zdGF0ZS52aWV3LmdyYXBoLm1vZGVsLmdldENoaWxkQ291bnQodGhpcy5zdGF0ZS5jZWxsKX07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5tb3ZlTGFiZWw9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IG14UG9pbnQoYS5nZXRHcmFwaFgoKSxhLmdldEdyYXBoWSgpKSxjPXRoaXMuZ3JhcGgudmlldy50cmFuc2xhdGUsZD10aGlzLmdyYXBoLnZpZXcuc2NhbGU7dGhpcy5ncmFwaC5pc0dyaWRFbmFibGVkRXZlbnQoYS5nZXRFdmVudCgpKSYmKGIueD0odGhpcy5ncmFwaC5zbmFwKGIueC9kLWMueCkrYy54KSpkLGIueT0odGhpcy5ncmFwaC5zbmFwKGIueS9kLWMueSkrYy55KSpkKTt0aGlzLm1vdmVTaXplclRvKHRoaXMuc2l6ZXJzW251bGwhPXRoaXMucm90YXRpb25TaGFwZT90aGlzLnNpemVycy5sZW5ndGgtMjp0aGlzLnNpemVycy5sZW5ndGgtMV0sYi54LGIueSl9OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJvdGF0ZVZlcnRleD1mdW5jdGlvbihhKXt2YXIgYj1uZXcgbXhQb2ludChhLmdldEdyYXBoWCgpLGEuZ2V0R3JhcGhZKCkpLGM9dGhpcy5zdGF0ZS54K3RoaXMuc3RhdGUud2lkdGgvMi1iLngsZD10aGlzLnN0YXRlLnkrdGhpcy5zdGF0ZS5oZWlnaHQvMi1iLnk7dGhpcy5jdXJyZW50QWxwaGE9MCE9Yz8xODAqTWF0aC5hdGFuKGQvYykvTWF0aC5QSSs5MDowPmQ/MTgwOjA7MDxjJiYodGhpcy5jdXJyZW50QWxwaGEtPTE4MCk7dGhpcy5jdXJyZW50QWxwaGEtPXRoaXMuc3RhcnRBbmdsZTt0aGlzLnJvdGF0aW9uUmFzdGVyJiZ0aGlzLmdyYXBoLmlzR3JpZEVuYWJsZWRFdmVudChhLmdldEV2ZW50KCkpPyhjPWIueC10aGlzLnN0YXRlLmdldENlbnRlclgoKSxkPWIueS10aGlzLnN0YXRlLmdldENlbnRlclkoKSxhPU1hdGguc3FydChjKmMrZCpkKSxyYXN0ZXI9Mj5hLXRoaXMuc3RhcnREaXN0PzE1OjI1PmEtdGhpcy5zdGFydERpc3Q/NToKMSx0aGlzLmN1cnJlbnRBbHBoYT1NYXRoLnJvdW5kKHRoaXMuY3VycmVudEFscGhhL3Jhc3RlcikqcmFzdGVyKTp0aGlzLmN1cnJlbnRBbHBoYT10aGlzLnJvdW5kQW5nbGUodGhpcy5jdXJyZW50QWxwaGEpO3RoaXMuc2VsZWN0aW9uQm9yZGVyLnJvdGF0aW9uPXRoaXMuY3VycmVudEFscGhhO3RoaXMuc2VsZWN0aW9uQm9yZGVyLnJlZHJhdygpO3RoaXMubGl2ZVByZXZpZXdBY3RpdmUmJnRoaXMucmVkcmF3SGFuZGxlcygpfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5yZXNpemVWZXJ0ZXg9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IG14UG9pbnQodGhpcy5zdGF0ZS5nZXRDZW50ZXJYKCksdGhpcy5zdGF0ZS5nZXRDZW50ZXJZKCkpLGM9bXhVdGlscy50b1JhZGlhbnModGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTl18fCIwIiksZD1uZXcgbXhQb2ludChhLmdldEdyYXBoWCgpLGEuZ2V0R3JhcGhZKCkpLGU9dGhpcy5ncmFwaC52aWV3LnRyYW5zbGF0ZSxmPXRoaXMuZ3JhcGgudmlldy5zY2FsZSxnPU1hdGguY29zKC1jKSxrPU1hdGguc2luKC1jKSxsPWQueC10aGlzLnN0YXJ0WCxtPWQueS10aGlzLnN0YXJ0WSxkPWsqbCtnKm0sbD1nKmwtayptLG09ZCxnPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KHRoaXMuc3RhdGUuY2VsbCk7dGhpcy51bnNjYWxlZEJvdW5kcz10aGlzLnVuaW9uKGcsbC9mLG0vZix0aGlzLmluZGV4LHRoaXMuZ3JhcGguaXNHcmlkRW5hYmxlZEV2ZW50KGEuZ2V0RXZlbnQoKSksCjEsbmV3IG14UG9pbnQoMCwwKSx0aGlzLmlzQ29uc3RyYWluZWRFdmVudChhKSx0aGlzLmlzQ2VudGVyZWRFdmVudCh0aGlzLnN0YXRlLGEpKTtnLnJlbGF0aXZlfHwoaz10aGlzLmdyYXBoLmdldE1heGltdW1HcmFwaEJvdW5kcygpLG51bGwhPWsmJm51bGwhPXRoaXMucGFyZW50U3RhdGUmJihrPW14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUoayksay54LT0odGhpcy5wYXJlbnRTdGF0ZS54LWUueCpmKS9mLGsueS09KHRoaXMucGFyZW50U3RhdGUueS1lLnkqZikvZiksdGhpcy5ncmFwaC5pc0NvbnN0cmFpbkNoaWxkKHRoaXMuc3RhdGUuY2VsbCkmJihkPXRoaXMuZ3JhcGguZ2V0Q2VsbENvbnRhaW5tZW50QXJlYSh0aGlzLnN0YXRlLmNlbGwpLG51bGwhPWQmJihsPXRoaXMuZ3JhcGguZ2V0T3ZlcmxhcCh0aGlzLnN0YXRlLmNlbGwpLDA8bCYmKGQ9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShkKSxkLngtPWQud2lkdGgqbCxkLnktPWQuaGVpZ2h0KmwsZC53aWR0aCs9MipkLndpZHRoKgpsLGQuaGVpZ2h0Kz0yKmQuaGVpZ2h0KmwpLG51bGw9PWs/az1kOihrPW14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUoayksay5pbnRlcnNlY3QoZCkpKSksbnVsbCE9ayYmKHRoaXMudW5zY2FsZWRCb3VuZHMueDxrLngmJih0aGlzLnVuc2NhbGVkQm91bmRzLndpZHRoLT1rLngtdGhpcy51bnNjYWxlZEJvdW5kcy54LHRoaXMudW5zY2FsZWRCb3VuZHMueD1rLngpLHRoaXMudW5zY2FsZWRCb3VuZHMueTxrLnkmJih0aGlzLnVuc2NhbGVkQm91bmRzLmhlaWdodC09ay55LXRoaXMudW5zY2FsZWRCb3VuZHMueSx0aGlzLnVuc2NhbGVkQm91bmRzLnk9ay55KSx0aGlzLnVuc2NhbGVkQm91bmRzLngrdGhpcy51bnNjYWxlZEJvdW5kcy53aWR0aD5rLngray53aWR0aCYmKHRoaXMudW5zY2FsZWRCb3VuZHMud2lkdGgtPXRoaXMudW5zY2FsZWRCb3VuZHMueCt0aGlzLnVuc2NhbGVkQm91bmRzLndpZHRoLWsueC1rLndpZHRoKSx0aGlzLnVuc2NhbGVkQm91bmRzLnkrdGhpcy51bnNjYWxlZEJvdW5kcy5oZWlnaHQ+CmsueStrLmhlaWdodCYmKHRoaXMudW5zY2FsZWRCb3VuZHMuaGVpZ2h0LT10aGlzLnVuc2NhbGVkQm91bmRzLnkrdGhpcy51bnNjYWxlZEJvdW5kcy5oZWlnaHQtay55LWsuaGVpZ2h0KSkpO2Q9dGhpcy5ib3VuZHM7dGhpcy5ib3VuZHM9bmV3IG14UmVjdGFuZ2xlKChudWxsIT10aGlzLnBhcmVudFN0YXRlP3RoaXMucGFyZW50U3RhdGUueDplLngqZikrdGhpcy51bnNjYWxlZEJvdW5kcy54KmYsKG51bGwhPXRoaXMucGFyZW50U3RhdGU/dGhpcy5wYXJlbnRTdGF0ZS55OmUueSpmKSt0aGlzLnVuc2NhbGVkQm91bmRzLnkqZix0aGlzLnVuc2NhbGVkQm91bmRzLndpZHRoKmYsdGhpcy51bnNjYWxlZEJvdW5kcy5oZWlnaHQqZik7Zy5yZWxhdGl2ZSYmbnVsbCE9dGhpcy5wYXJlbnRTdGF0ZSYmKHRoaXMuYm91bmRzLngrPXRoaXMuc3RhdGUueC10aGlzLnBhcmVudFN0YXRlLngsdGhpcy5ib3VuZHMueSs9dGhpcy5zdGF0ZS55LXRoaXMucGFyZW50U3RhdGUueSk7Zz1NYXRoLmNvcyhjKTsKaz1NYXRoLnNpbihjKTtjPW5ldyBteFBvaW50KHRoaXMuYm91bmRzLmdldENlbnRlclgoKSx0aGlzLmJvdW5kcy5nZXRDZW50ZXJZKCkpO2w9Yy54LWIueDttPWMueS1iLnk7Yj1nKmwtayptLWw7Yz1rKmwrZyptLW07bD10aGlzLmJvdW5kcy54LXRoaXMuc3RhdGUueDttPXRoaXMuYm91bmRzLnktdGhpcy5zdGF0ZS55O2U9ZypsLWsqbTtnPWsqbCtnKm07dGhpcy5ib3VuZHMueCs9Yjt0aGlzLmJvdW5kcy55Kz1jO3RoaXMudW5zY2FsZWRCb3VuZHMueD10aGlzLnJvdW5kTGVuZ3RoKHRoaXMudW5zY2FsZWRCb3VuZHMueCtiL2YpO3RoaXMudW5zY2FsZWRCb3VuZHMueT10aGlzLnJvdW5kTGVuZ3RoKHRoaXMudW5zY2FsZWRCb3VuZHMueStjL2YpO3RoaXMudW5zY2FsZWRCb3VuZHMud2lkdGg9dGhpcy5yb3VuZExlbmd0aCh0aGlzLnVuc2NhbGVkQm91bmRzLndpZHRoKTt0aGlzLnVuc2NhbGVkQm91bmRzLmhlaWdodD10aGlzLnJvdW5kTGVuZ3RoKHRoaXMudW5zY2FsZWRCb3VuZHMuaGVpZ2h0KTsKdGhpcy5ncmFwaC5pc0NlbGxDb2xsYXBzZWQodGhpcy5zdGF0ZS5jZWxsKXx8MD09YiYmMD09Yz90aGlzLmNoaWxkT2Zmc2V0WT10aGlzLmNoaWxkT2Zmc2V0WD0wOih0aGlzLmNoaWxkT2Zmc2V0WD10aGlzLnN0YXRlLngtdGhpcy5ib3VuZHMueCtlLHRoaXMuY2hpbGRPZmZzZXRZPXRoaXMuc3RhdGUueS10aGlzLmJvdW5kcy55K2cpO2QuZXF1YWxzKHRoaXMuYm91bmRzKXx8KHRoaXMubGl2ZVByZXZpZXdBY3RpdmUmJnRoaXMudXBkYXRlTGl2ZVByZXZpZXcoYSksbnVsbCE9dGhpcy5wcmV2aWV3P3RoaXMuZHJhd1ByZXZpZXcoKTp0aGlzLnVwZGF0ZVBhcmVudEhpZ2hsaWdodCgpKX07Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUudXBkYXRlTGl2ZVByZXZpZXc9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5ncmFwaC52aWV3LnNjYWxlLGM9dGhpcy5ncmFwaC52aWV3LnRyYW5zbGF0ZTthPXRoaXMuc3RhdGUuY2xvbmUoKTt0aGlzLnN0YXRlLng9dGhpcy5ib3VuZHMueDt0aGlzLnN0YXRlLnk9dGhpcy5ib3VuZHMueTt0aGlzLnN0YXRlLm9yaWdpbj1uZXcgbXhQb2ludCh0aGlzLnN0YXRlLngvYi1jLngsdGhpcy5zdGF0ZS55L2ItYy55KTt0aGlzLnN0YXRlLndpZHRoPXRoaXMuYm91bmRzLndpZHRoO3RoaXMuc3RhdGUuaGVpZ2h0PXRoaXMuYm91bmRzLmhlaWdodDtiPXRoaXMuc3RhdGUuYWJzb2x1dGVPZmZzZXQ7bmV3IG14UG9pbnQoYi54LGIueSk7dGhpcy5zdGF0ZS5hYnNvbHV0ZU9mZnNldC54PTA7dGhpcy5zdGF0ZS5hYnNvbHV0ZU9mZnNldC55PTA7Yj10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeSh0aGlzLnN0YXRlLmNlbGwpO251bGwhPWImJihjPWIub2Zmc2V0fHwKdGhpcy5FTVBUWV9QT0lOVCxudWxsPT1jfHxiLnJlbGF0aXZlfHwodGhpcy5zdGF0ZS5hYnNvbHV0ZU9mZnNldC54PXRoaXMuc3RhdGUudmlldy5zY2FsZSpjLngsdGhpcy5zdGF0ZS5hYnNvbHV0ZU9mZnNldC55PXRoaXMuc3RhdGUudmlldy5zY2FsZSpjLnkpLHRoaXMuc3RhdGUudmlldy51cGRhdGVWZXJ0ZXhMYWJlbE9mZnNldCh0aGlzLnN0YXRlKSk7dGhpcy5zdGF0ZS52aWV3LmdyYXBoLmNlbGxSZW5kZXJlci5yZWRyYXcodGhpcy5zdGF0ZSwhMCk7dGhpcy5zdGF0ZS52aWV3LmludmFsaWRhdGUodGhpcy5zdGF0ZS5jZWxsKTt0aGlzLnN0YXRlLmludmFsaWQ9ITE7dGhpcy5zdGF0ZS52aWV3LnZhbGlkYXRlKCk7dGhpcy5yZWRyYXdIYW5kbGVzKCk7dGhpcy5tb3ZlVG9Gcm9udCgpO251bGwhPXRoaXMuc3RhdGUuY29udHJvbCYmbnVsbCE9dGhpcy5zdGF0ZS5jb250cm9sLm5vZGUmJih0aGlzLnN0YXRlLmNvbnRyb2wubm9kZS5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4iKTt0aGlzLnN0YXRlLnNldFN0YXRlKGEpfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5tb3ZlVG9Gcm9udD1mdW5jdGlvbigpe2lmKG51bGwhPXRoaXMuc3RhdGUudGV4dCYmbnVsbCE9dGhpcy5zdGF0ZS50ZXh0Lm5vZGUmJm51bGwhPXRoaXMuc3RhdGUudGV4dC5ub2RlLm5leHRTaWJsaW5nfHxudWxsIT10aGlzLnN0YXRlLnNoYXBlJiZudWxsIT10aGlzLnN0YXRlLnNoYXBlLm5vZGUmJm51bGwhPXRoaXMuc3RhdGUuc2hhcGUubm9kZS5uZXh0U2libGluZyYmKG51bGw9PXRoaXMuc3RhdGUudGV4dHx8dGhpcy5zdGF0ZS5zaGFwZS5ub2RlLm5leHRTaWJsaW5nIT10aGlzLnN0YXRlLnRleHQubm9kZSkpbnVsbCE9dGhpcy5zdGF0ZS5zaGFwZSYmbnVsbCE9dGhpcy5zdGF0ZS5zaGFwZS5ub2RlJiZ0aGlzLnN0YXRlLnNoYXBlLm5vZGUucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLnN0YXRlLnNoYXBlLm5vZGUpLG51bGwhPXRoaXMuc3RhdGUudGV4dCYmbnVsbCE9dGhpcy5zdGF0ZS50ZXh0Lm5vZGUmJnRoaXMuc3RhdGUudGV4dC5ub2RlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5zdGF0ZS50ZXh0Lm5vZGUpfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5tb3VzZVVwPWZ1bmN0aW9uKGEsYil7aWYobnVsbCE9dGhpcy5pbmRleCYmbnVsbCE9dGhpcy5zdGF0ZSl7dmFyIGM9bmV3IG14UG9pbnQoYi5nZXRHcmFwaFgoKSxiLmdldEdyYXBoWSgpKSxkPXRoaXMuaW5kZXg7dGhpcy5pbmRleD1udWxsO251bGw9PXRoaXMuZ2hvc3RQcmV2aWV3JiYodGhpcy5zdGF0ZS52aWV3LmludmFsaWRhdGUodGhpcy5zdGF0ZS5jZWxsLCExLCExKSx0aGlzLnN0YXRlLnZpZXcudmFsaWRhdGUoKSk7dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmJlZ2luVXBkYXRlKCk7dHJ5e2lmKGQ8PW14RXZlbnQuQ1VTVE9NX0hBTkRMRSl7aWYobnVsbCE9dGhpcy5jdXN0b21IYW5kbGVzKXt2YXIgZT10aGlzLnN0YXRlLnZpZXcuZ3JhcGguZ2V0Q2VsbFN0eWxlKHRoaXMuc3RhdGUuY2VsbCk7dGhpcy5jdXN0b21IYW5kbGVzW214RXZlbnQuQ1VTVE9NX0hBTkRMRS1kXS5hY3RpdmU9ITE7dGhpcy5jdXN0b21IYW5kbGVzW214RXZlbnQuQ1VTVE9NX0hBTkRMRS0KZF0uZXhlY3V0ZShiKTtudWxsIT10aGlzLmN1c3RvbUhhbmRsZXMmJm51bGwhPXRoaXMuY3VzdG9tSGFuZGxlc1tteEV2ZW50LkNVU1RPTV9IQU5ETEUtZF0mJih0aGlzLnN0YXRlLnN0eWxlPWUsdGhpcy5jdXN0b21IYW5kbGVzW214RXZlbnQuQ1VTVE9NX0hBTkRMRS1kXS5wb3NpdGlvbkNoYW5nZWQoKSl9fWVsc2UgaWYoZD09bXhFdmVudC5ST1RBVElPTl9IQU5ETEUpaWYobnVsbCE9dGhpcy5jdXJyZW50QWxwaGEpe3ZhciBmPXRoaXMuY3VycmVudEFscGhhLSh0aGlzLnN0YXRlLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OXXx8MCk7MCE9ZiYmdGhpcy5yb3RhdGVDZWxsKHRoaXMuc3RhdGUuY2VsbCxmKX1lbHNlIHRoaXMucm90YXRlQ2xpY2soKTtlbHNle3ZhciBnPXRoaXMuZ3JhcGguaXNHcmlkRW5hYmxlZEV2ZW50KGIuZ2V0RXZlbnQoKSksaz1teFV0aWxzLnRvUmFkaWFucyh0aGlzLnN0YXRlLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OXXx8IjAiKSwKbD1NYXRoLmNvcygtayksbT1NYXRoLnNpbigtayksbj1jLngtdGhpcy5zdGFydFgscD1jLnktdGhpcy5zdGFydFksYz1tKm4rbCpwLG49bCpuLW0qcCxwPWMscT10aGlzLmdyYXBoLnZpZXcuc2NhbGUscj10aGlzLmlzUmVjdXJzaXZlUmVzaXplKHRoaXMuc3RhdGUsYik7dGhpcy5yZXNpemVDZWxsKHRoaXMuc3RhdGUuY2VsbCx0aGlzLnJvdW5kTGVuZ3RoKG4vcSksdGhpcy5yb3VuZExlbmd0aChwL3EpLGQsZyx0aGlzLmlzQ29uc3RyYWluZWRFdmVudChiKSxyKX19ZmluYWxseXt0aGlzLmdyYXBoLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9Yi5jb25zdW1lKCk7dGhpcy5yZXNldCgpfX07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5pc1JlY3Vyc2l2ZVJlc2l6ZT1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmdyYXBoLmlzUmVjdXJzaXZlUmVzaXplKHRoaXMuc3RhdGUpfTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJvdGF0ZUNsaWNrPWZ1bmN0aW9uKCl7fTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5yb3RhdGVDZWxsPWZ1bmN0aW9uKGEsYixjKXtpZigwIT1iKXt2YXIgZD10aGlzLmdyYXBoLmdldE1vZGVsKCk7aWYoZC5pc1ZlcnRleChhKXx8ZC5pc0VkZ2UoYSkpe2lmKCFkLmlzRWRnZShhKSl7dmFyIGU9KHRoaXMuZ3JhcGguZ2V0Q3VycmVudENlbGxTdHlsZShhKVtteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTl18fDApK2I7dGhpcy5ncmFwaC5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OLGUsW2FdKX1lPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGEpO2lmKG51bGwhPWUpe3ZhciBmPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGMpO251bGw9PWZ8fGQuaXNFZGdlKGMpfHwoZT1lLmNsb25lKCksZS5yb3RhdGUoYixuZXcgbXhQb2ludChmLndpZHRoLzIsZi5oZWlnaHQvMikpLGQuc2V0R2VvbWV0cnkoYSxlKSk7aWYoZC5pc1ZlcnRleChhKSYmIWUucmVsYXRpdmV8fGQuaXNFZGdlKGEpKWZvcihjPQpkLmdldENoaWxkQ291bnQoYSksZT0wO2U8YztlKyspdGhpcy5yb3RhdGVDZWxsKGQuZ2V0Q2hpbGRBdChhLGUpLGIsYSl9fX19OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5zaXplcnMmJm51bGwhPXRoaXMuaW5kZXgmJm51bGwhPXRoaXMuc2l6ZXJzW3RoaXMuaW5kZXhdJiYibm9uZSI9PXRoaXMuc2l6ZXJzW3RoaXMuaW5kZXhdLm5vZGUuc3R5bGUuZGlzcGxheSYmKHRoaXMuc2l6ZXJzW3RoaXMuaW5kZXhdLm5vZGUuc3R5bGUuZGlzcGxheT0iIik7dGhpcy5pbmRleD10aGlzLmluVG9sZXJhbmNlPXRoaXMuY3VycmVudEFscGhhPW51bGw7bnVsbCE9dGhpcy5wcmV2aWV3JiYodGhpcy5wcmV2aWV3LmRlc3Ryb3koKSx0aGlzLnByZXZpZXc9bnVsbCk7bnVsbCE9dGhpcy5naG9zdFByZXZpZXcmJih0aGlzLmdob3N0UHJldmlldy5kZXN0cm95KCksdGhpcy5naG9zdFByZXZpZXc9bnVsbCk7aWYodGhpcy5saXZlUHJldmlld0FjdGl2ZSYmbnVsbCE9dGhpcy5zaXplcnMpe2Zvcih2YXIgYT0wO2E8dGhpcy5zaXplcnMubGVuZ3RoO2ErKyludWxsIT10aGlzLnNpemVyc1thXSYmCih0aGlzLnNpemVyc1thXS5ub2RlLnN0eWxlLmRpc3BsYXk9IiIpO251bGwhPXRoaXMuc3RhdGUuY29udHJvbCYmbnVsbCE9dGhpcy5zdGF0ZS5jb250cm9sLm5vZGUmJih0aGlzLnN0YXRlLmNvbnRyb2wubm9kZS5zdHlsZS52aXNpYmlsaXR5PSIiKX1pZihudWxsIT10aGlzLmN1c3RvbUhhbmRsZXMpZm9yKGE9MDthPHRoaXMuY3VzdG9tSGFuZGxlcy5sZW5ndGg7YSsrKXRoaXMuY3VzdG9tSGFuZGxlc1thXS5hY3RpdmU/KHRoaXMuY3VzdG9tSGFuZGxlc1thXS5hY3RpdmU9ITEsdGhpcy5jdXN0b21IYW5kbGVzW2FdLnJlc2V0KCkpOnRoaXMuY3VzdG9tSGFuZGxlc1thXS5zZXRWaXNpYmxlKCEwKTtudWxsIT10aGlzLnNlbGVjdGlvbkJvcmRlciYmKHRoaXMuc2VsZWN0aW9uQm9yZGVyLm5vZGUuc3R5bGUuZGlzcGxheT0iaW5saW5lIix0aGlzLnNlbGVjdGlvbkJvdW5kcz10aGlzLmdldFNlbGVjdGlvbkJvdW5kcyh0aGlzLnN0YXRlKSx0aGlzLmJvdW5kcz1uZXcgbXhSZWN0YW5nbGUodGhpcy5zZWxlY3Rpb25Cb3VuZHMueCwKdGhpcy5zZWxlY3Rpb25Cb3VuZHMueSx0aGlzLnNlbGVjdGlvbkJvdW5kcy53aWR0aCx0aGlzLnNlbGVjdGlvbkJvdW5kcy5oZWlnaHQpLHRoaXMuZHJhd1ByZXZpZXcoKSk7dGhpcy5yZW1vdmVIaW50KCk7dGhpcy5yZWRyYXdIYW5kbGVzKCk7dGhpcy5saXZlUHJldmlld0FjdGl2ZT10aGlzLnVuc2NhbGVkQm91bmRzPXRoaXMuZWRnZUhhbmRsZXJzPW51bGx9OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJlc2l6ZUNlbGw9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyl7Yj10aGlzLmdyYXBoLm1vZGVsLmdldEdlb21ldHJ5KGEpO251bGwhPWImJihkPT1teEV2ZW50LkxBQkVMX0hBTkRMRT8oZD0tbXhVdGlscy50b1JhZGlhbnModGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTl18fCIwIiksZz1NYXRoLmNvcyhkKSxjPU1hdGguc2luKGQpLGQ9dGhpcy5ncmFwaC52aWV3LnNjYWxlLGc9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQobmV3IG14UG9pbnQoTWF0aC5yb3VuZCgodGhpcy5sYWJlbFNoYXBlLmJvdW5kcy5nZXRDZW50ZXJYKCktdGhpcy5zdGFydFgpL2QpLE1hdGgucm91bmQoKHRoaXMubGFiZWxTaGFwZS5ib3VuZHMuZ2V0Q2VudGVyWSgpLXRoaXMuc3RhcnRZKS9kKSksZyxjKSxiPWIuY2xvbmUoKSxudWxsPT1iLm9mZnNldD9iLm9mZnNldD1nOihiLm9mZnNldC54Kz1nLngsYi5vZmZzZXQueSs9Zy55KSx0aGlzLmdyYXBoLm1vZGVsLnNldEdlb21ldHJ5KGEsCmIpKTpudWxsIT10aGlzLnVuc2NhbGVkQm91bmRzJiYoZD10aGlzLmdyYXBoLnZpZXcuc2NhbGUsMD09dGhpcy5jaGlsZE9mZnNldFgmJjA9PXRoaXMuY2hpbGRPZmZzZXRZfHx0aGlzLm1vdmVDaGlsZHJlbihhLE1hdGgucm91bmQodGhpcy5jaGlsZE9mZnNldFgvZCksTWF0aC5yb3VuZCh0aGlzLmNoaWxkT2Zmc2V0WS9kKSksdGhpcy5ncmFwaC5yZXNpemVDZWxsKGEsdGhpcy51bnNjYWxlZEJvdW5kcyxnKSkpfTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLm1vdmVDaGlsZHJlbj1mdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxlPWQuZ2V0Q2hpbGRDb3VudChhKSxmPTA7ZjxlO2YrKyl7dmFyIGc9ZC5nZXRDaGlsZEF0KGEsZiksaz10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShnKTtudWxsIT1rJiYoaz1rLmNsb25lKCksay50cmFuc2xhdGUoYixjKSxkLnNldEdlb21ldHJ5KGcsaykpfX07Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUudW5pb249ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxrLGwpe2U9bnVsbCE9ZT9lJiZ0aGlzLmdyYXBoLmdyaWRFbmFibGVkOnRoaXMuZ3JhcGguZ3JpZEVuYWJsZWQ7aWYodGhpcy5zaW5nbGVTaXplcilyZXR1cm4gZD1hLngrYS53aWR0aCtiLGc9YS55K2EuaGVpZ2h0K2MsZSYmKGQ9dGhpcy5ncmFwaC5zbmFwKGQvZikqZixnPXRoaXMuZ3JhcGguc25hcChnL2YpKmYpLGY9bmV3IG14UmVjdGFuZ2xlKGEueCxhLnksMCwwKSxmLmFkZChuZXcgbXhSZWN0YW5nbGUoZCxnLDAsMCkpLGY7dmFyIG09YS53aWR0aCxuPWEuaGVpZ2h0LHA9YS54LWcueCpmLHE9cCttO2E9YS55LWcueSpmO3ZhciByPWErbix0PXArbS8yLHU9YStuLzI7NDxkPyhyKz1jLHI9ZT90aGlzLmdyYXBoLnNuYXAoci9mKSpmOk1hdGgucm91bmQoci9mKSpmKTozPmQmJihhKz1jLGE9ZT90aGlzLmdyYXBoLnNuYXAoYS9mKSpmOk1hdGgucm91bmQoYS9mKSpmKTtpZigwPT1kfHwKMz09ZHx8NT09ZClwKz1iLHA9ZT90aGlzLmdyYXBoLnNuYXAocC9mKSpmOk1hdGgucm91bmQocC9mKSpmO2Vsc2UgaWYoMj09ZHx8ND09ZHx8Nz09ZClxKz1iLHE9ZT90aGlzLmdyYXBoLnNuYXAocS9mKSpmOk1hdGgucm91bmQocS9mKSpmO2U9cS1wO2M9ci1hO2smJihrPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KHRoaXMuc3RhdGUuY2VsbCksbnVsbCE9ayYmKGs9ay53aWR0aC9rLmhlaWdodCwxPT1kfHwyPT1kfHw3PT1kfHw2PT1kP2U9YyprOmM9ZS9rLDA9PWQmJihwPXEtZSxhPXItYykpKTtsJiYoZSs9ZS1tLGMrPWMtbixwKz10LShwK2UvMiksYSs9dS0oYStjLzIpKTswPmUmJihwKz1lLGU9TWF0aC5hYnMoZSkpOzA+YyYmKGErPWMsYz1NYXRoLmFicyhjKSk7ZD1uZXcgbXhSZWN0YW5nbGUocCtnLngqZixhK2cueSpmLGUsYyk7bnVsbCE9dGhpcy5taW5Cb3VuZHMmJihkLndpZHRoPU1hdGgubWF4KGQud2lkdGgsdGhpcy5taW5Cb3VuZHMueCpmK3RoaXMubWluQm91bmRzLndpZHRoKgpmK01hdGgubWF4KDAsdGhpcy54MCpmLWQueCkpLGQuaGVpZ2h0PU1hdGgubWF4KGQuaGVpZ2h0LHRoaXMubWluQm91bmRzLnkqZit0aGlzLm1pbkJvdW5kcy5oZWlnaHQqZitNYXRoLm1heCgwLHRoaXMueTAqZi1kLnkpKSk7cmV0dXJuIGR9O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUucmVkcmF3PWZ1bmN0aW9uKGEpe3RoaXMuc2VsZWN0aW9uQm91bmRzPXRoaXMuZ2V0U2VsZWN0aW9uQm91bmRzKHRoaXMuc3RhdGUpO3RoaXMuYm91bmRzPW5ldyBteFJlY3RhbmdsZSh0aGlzLnNlbGVjdGlvbkJvdW5kcy54LHRoaXMuc2VsZWN0aW9uQm91bmRzLnksdGhpcy5zZWxlY3Rpb25Cb3VuZHMud2lkdGgsdGhpcy5zZWxlY3Rpb25Cb3VuZHMuaGVpZ2h0KTt0aGlzLmRyYXdQcmV2aWV3KCk7YXx8dGhpcy5yZWRyYXdIYW5kbGVzKCl9OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmdldEhhbmRsZVBhZGRpbmc9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhQb2ludCgwLDApLGI9dGhpcy50b2xlcmFuY2U7bnVsbCE9dGhpcy5zaXplcnMmJjA8dGhpcy5zaXplcnMubGVuZ3RoJiZudWxsIT10aGlzLnNpemVyc1swXSYmKHRoaXMuYm91bmRzLndpZHRoPDIqdGhpcy5zaXplcnNbMF0uYm91bmRzLndpZHRoKzIqYnx8dGhpcy5ib3VuZHMuaGVpZ2h0PDIqdGhpcy5zaXplcnNbMF0uYm91bmRzLmhlaWdodCsyKmIpJiYoYi89MixhLng9dGhpcy5zaXplcnNbMF0uYm91bmRzLndpZHRoK2IsYS55PXRoaXMuc2l6ZXJzWzBdLmJvdW5kcy5oZWlnaHQrYik7cmV0dXJuIGF9O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuZ2V0U2l6ZXJCb3VuZHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ib3VuZHN9OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJlZHJhd0hhbmRsZXM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdldFNpemVyQm91bmRzKCksYj10aGlzLnRvbGVyYW5jZTt0aGlzLnZlcnRpY2FsT2Zmc2V0PXRoaXMuaG9yaXpvbnRhbE9mZnNldD0wO2lmKG51bGwhPXRoaXMuY3VzdG9tSGFuZGxlcylmb3IodmFyIGM9MDtjPHRoaXMuY3VzdG9tSGFuZGxlcy5sZW5ndGg7YysrKXt2YXIgZD10aGlzLmN1c3RvbUhhbmRsZXNbY10uc2hhcGUubm9kZS5zdHlsZS5kaXNwbGF5O3RoaXMuY3VzdG9tSGFuZGxlc1tjXS5yZWRyYXcoKTt0aGlzLmN1c3RvbUhhbmRsZXNbY10uc2hhcGUubm9kZS5zdHlsZS5kaXNwbGF5PWQ7dGhpcy5jdXN0b21IYW5kbGVzW2NdLnNoYXBlLm5vZGUuc3R5bGUudmlzaWJpbGl0eT10aGlzLmlzQ3VzdG9tSGFuZGxlVmlzaWJsZSh0aGlzLmN1c3RvbUhhbmRsZXNbY10pPyIiOiJoaWRkZW4ifWlmKG51bGwhPXRoaXMuc2l6ZXJzJiYwPHRoaXMuc2l6ZXJzLmxlbmd0aCYmCm51bGwhPXRoaXMuc2l6ZXJzWzBdKXtpZihudWxsPT10aGlzLmluZGV4JiZ0aGlzLm1hbmFnZVNpemVycyYmODw9dGhpcy5zaXplcnMubGVuZ3RoKXtjPXRoaXMuZ2V0SGFuZGxlUGFkZGluZygpO3RoaXMuaG9yaXpvbnRhbE9mZnNldD1jLng7dGhpcy52ZXJ0aWNhbE9mZnNldD1jLnk7aWYoMCE9dGhpcy5ob3Jpem9udGFsT2Zmc2V0fHwwIT10aGlzLnZlcnRpY2FsT2Zmc2V0KWE9bmV3IG14UmVjdGFuZ2xlKGEueCxhLnksYS53aWR0aCxhLmhlaWdodCksYS54LT10aGlzLmhvcml6b250YWxPZmZzZXQvMixhLndpZHRoKz10aGlzLmhvcml6b250YWxPZmZzZXQsYS55LT10aGlzLnZlcnRpY2FsT2Zmc2V0LzIsYS5oZWlnaHQrPXRoaXMudmVydGljYWxPZmZzZXQ7ODw9dGhpcy5zaXplcnMubGVuZ3RoJiYoYS53aWR0aDwyKnRoaXMuc2l6ZXJzWzBdLmJvdW5kcy53aWR0aCsyKmJ8fGEuaGVpZ2h0PDIqdGhpcy5zaXplcnNbMF0uYm91bmRzLmhlaWdodCsyKmI/KHRoaXMuc2l6ZXJzWzBdLm5vZGUuc3R5bGUuZGlzcGxheT0KIm5vbmUiLHRoaXMuc2l6ZXJzWzJdLm5vZGUuc3R5bGUuZGlzcGxheT0ibm9uZSIsdGhpcy5zaXplcnNbNV0ubm9kZS5zdHlsZS5kaXNwbGF5PSJub25lIix0aGlzLnNpemVyc1s3XS5ub2RlLnN0eWxlLmRpc3BsYXk9Im5vbmUiKToodGhpcy5zaXplcnNbMF0ubm9kZS5zdHlsZS5kaXNwbGF5PSIiLHRoaXMuc2l6ZXJzWzJdLm5vZGUuc3R5bGUuZGlzcGxheT0iIix0aGlzLnNpemVyc1s1XS5ub2RlLnN0eWxlLmRpc3BsYXk9IiIsdGhpcy5zaXplcnNbN10ubm9kZS5zdHlsZS5kaXNwbGF5PSIiKSl9Yj1hLngrYS53aWR0aDtjPWEueSthLmhlaWdodDtpZih0aGlzLnNpbmdsZVNpemVyKXRoaXMubW92ZVNpemVyVG8odGhpcy5zaXplcnNbMF0sYixjKTtlbHNle3ZhciBkPWEueCthLndpZHRoLzIsZT1hLnkrYS5oZWlnaHQvMjtpZig4PD10aGlzLnNpemVycy5sZW5ndGgpe3ZhciBmPSJudy1yZXNpemUgbi1yZXNpemUgbmUtcmVzaXplIGUtcmVzaXplIHNlLXJlc2l6ZSBzLXJlc2l6ZSBzdy1yZXNpemUgdy1yZXNpemUiLnNwbGl0KCIgIiksCmc9bXhVdGlscy50b1JhZGlhbnModGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTl18fCIwIiksaz1NYXRoLmNvcyhnKSxsPU1hdGguc2luKGcpLGc9TWF0aC5yb3VuZCg0KmcvTWF0aC5QSSksbT1uZXcgbXhQb2ludChhLmdldENlbnRlclgoKSxhLmdldENlbnRlclkoKSksbj1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChuZXcgbXhQb2ludChhLngsYS55KSxrLGwsbSk7dGhpcy5tb3ZlU2l6ZXJUbyh0aGlzLnNpemVyc1swXSxuLngsbi55KTt0aGlzLnNpemVyc1swXS5zZXRDdXJzb3IoZltteFV0aWxzLm1vZCgwK2csZi5sZW5ndGgpXSk7bi54PWQ7bi55PWEueTtuPW14VXRpbHMuZ2V0Um90YXRlZFBvaW50KG4sayxsLG0pO3RoaXMubW92ZVNpemVyVG8odGhpcy5zaXplcnNbMV0sbi54LG4ueSk7dGhpcy5zaXplcnNbMV0uc2V0Q3Vyc29yKGZbbXhVdGlscy5tb2QoMStnLGYubGVuZ3RoKV0pO24ueD1iO24ueT1hLnk7bj1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChuLAprLGwsbSk7dGhpcy5tb3ZlU2l6ZXJUbyh0aGlzLnNpemVyc1syXSxuLngsbi55KTt0aGlzLnNpemVyc1syXS5zZXRDdXJzb3IoZltteFV0aWxzLm1vZCgyK2csZi5sZW5ndGgpXSk7bi54PWEueDtuLnk9ZTtuPW14VXRpbHMuZ2V0Um90YXRlZFBvaW50KG4sayxsLG0pO3RoaXMubW92ZVNpemVyVG8odGhpcy5zaXplcnNbM10sbi54LG4ueSk7dGhpcy5zaXplcnNbM10uc2V0Q3Vyc29yKGZbbXhVdGlscy5tb2QoNytnLGYubGVuZ3RoKV0pO24ueD1iO24ueT1lO249bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQobixrLGwsbSk7dGhpcy5tb3ZlU2l6ZXJUbyh0aGlzLnNpemVyc1s0XSxuLngsbi55KTt0aGlzLnNpemVyc1s0XS5zZXRDdXJzb3IoZltteFV0aWxzLm1vZCgzK2csZi5sZW5ndGgpXSk7bi54PWEueDtuLnk9YztuPW14VXRpbHMuZ2V0Um90YXRlZFBvaW50KG4sayxsLG0pO3RoaXMubW92ZVNpemVyVG8odGhpcy5zaXplcnNbNV0sbi54LG4ueSk7dGhpcy5zaXplcnNbNV0uc2V0Q3Vyc29yKGZbbXhVdGlscy5tb2QoNisKZyxmLmxlbmd0aCldKTtuLng9ZDtuLnk9YztuPW14VXRpbHMuZ2V0Um90YXRlZFBvaW50KG4sayxsLG0pO3RoaXMubW92ZVNpemVyVG8odGhpcy5zaXplcnNbNl0sbi54LG4ueSk7dGhpcy5zaXplcnNbNl0uc2V0Q3Vyc29yKGZbbXhVdGlscy5tb2QoNStnLGYubGVuZ3RoKV0pO24ueD1iO24ueT1jO249bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQobixrLGwsbSk7dGhpcy5tb3ZlU2l6ZXJUbyh0aGlzLnNpemVyc1s3XSxuLngsbi55KTt0aGlzLnNpemVyc1s3XS5zZXRDdXJzb3IoZltteFV0aWxzLm1vZCg0K2csZi5sZW5ndGgpXSk7bi54PWQrdGhpcy5zdGF0ZS5hYnNvbHV0ZU9mZnNldC54O24ueT1lK3RoaXMuc3RhdGUuYWJzb2x1dGVPZmZzZXQueTtuPW14VXRpbHMuZ2V0Um90YXRlZFBvaW50KG4sayxsLG0pO3RoaXMubW92ZVNpemVyVG8odGhpcy5zaXplcnNbOF0sbi54LG4ueSl9ZWxzZSAyPD10aGlzLnN0YXRlLndpZHRoJiYyPD10aGlzLnN0YXRlLmhlaWdodD90aGlzLm1vdmVTaXplclRvKHRoaXMuc2l6ZXJzWzBdLApkK3RoaXMuc3RhdGUuYWJzb2x1dGVPZmZzZXQueCxlK3RoaXMuc3RhdGUuYWJzb2x1dGVPZmZzZXQueSk6dGhpcy5tb3ZlU2l6ZXJUbyh0aGlzLnNpemVyc1swXSx0aGlzLnN0YXRlLngsdGhpcy5zdGF0ZS55KX19bnVsbCE9dGhpcy5yb3RhdGlvblNoYXBlJiYoZz1teFV0aWxzLnRvUmFkaWFucyhudWxsIT10aGlzLmN1cnJlbnRBbHBoYT90aGlzLmN1cnJlbnRBbHBoYTp0aGlzLnN0YXRlLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OXXx8IjAiKSxrPU1hdGguY29zKGcpLGw9TWF0aC5zaW4oZyksbT1uZXcgbXhQb2ludCh0aGlzLnN0YXRlLmdldENlbnRlclgoKSx0aGlzLnN0YXRlLmdldENlbnRlclkoKSksbj1teFV0aWxzLmdldFJvdGF0ZWRQb2ludCh0aGlzLmdldFJvdGF0aW9uSGFuZGxlUG9zaXRpb24oKSxrLGwsbSksbnVsbCE9dGhpcy5yb3RhdGlvblNoYXBlLm5vZGUmJih0aGlzLm1vdmVTaXplclRvKHRoaXMucm90YXRpb25TaGFwZSxuLngsbi55KSx0aGlzLnJvdGF0aW9uU2hhcGUubm9kZS5zdHlsZS52aXNpYmlsaXR5PQp0aGlzLnN0YXRlLnZpZXcuZ3JhcGguaXNFZGl0aW5nKCk/ImhpZGRlbiI6IiIpKTtudWxsIT10aGlzLnNlbGVjdGlvbkJvcmRlciYmKHRoaXMuc2VsZWN0aW9uQm9yZGVyLnJvdGF0aW9uPU51bWJlcih0aGlzLnN0YXRlLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OXXx8IjAiKSk7aWYobnVsbCE9dGhpcy5lZGdlSGFuZGxlcnMpZm9yKGM9MDtjPHRoaXMuZWRnZUhhbmRsZXJzLmxlbmd0aDtjKyspdGhpcy5lZGdlSGFuZGxlcnNbY10ucmVkcmF3KCl9O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaXNDdXN0b21IYW5kbGVWaXNpYmxlPWZ1bmN0aW9uKGEpe3JldHVybiF0aGlzLmdyYXBoLmlzRWRpdGluZygpJiYxPT10aGlzLnN0YXRlLnZpZXcuZ3JhcGguZ2V0U2VsZWN0aW9uQ291bnQoKX07Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuZ2V0Um90YXRpb25IYW5kbGVQb3NpdGlvbj1mdW5jdGlvbigpe3JldHVybiBuZXcgbXhQb2ludCh0aGlzLmJvdW5kcy54K3RoaXMuYm91bmRzLndpZHRoLzIsdGhpcy5ib3VuZHMueSt0aGlzLnJvdGF0aW9uSGFuZGxlVlNwYWNpbmcpfTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmlzUGFyZW50SGlnaGxpZ2h0VmlzaWJsZT1mdW5jdGlvbigpe3JldHVybiEwfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVQYXJlbnRIaWdobGlnaHQ9ZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLnNlbGVjdGlvbkJvcmRlciYmdGhpcy5pc1BhcmVudEhpZ2hsaWdodFZpc2libGUoKSlpZihudWxsIT10aGlzLnBhcmVudEhpZ2hsaWdodCl7dmFyIGE9dGhpcy5ncmFwaC5tb2RlbC5nZXRQYXJlbnQodGhpcy5zdGF0ZS5jZWxsKTtpZih0aGlzLmdyYXBoLm1vZGVsLmlzVmVydGV4KGEpKXt2YXIgYT10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUoYSksYj10aGlzLnBhcmVudEhpZ2hsaWdodC5ib3VuZHM7bnVsbD09YXx8Yi54PT1hLngmJmIueT09YS55JiZiLndpZHRoPT1hLndpZHRoJiZiLmhlaWdodD09YS5oZWlnaHR8fCh0aGlzLnBhcmVudEhpZ2hsaWdodC5ib3VuZHM9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShhKSx0aGlzLnBhcmVudEhpZ2hsaWdodC5yZWRyYXcoKSl9ZWxzZSB0aGlzLnBhcmVudEhpZ2hsaWdodC5kZXN0cm95KCksdGhpcy5wYXJlbnRIaWdobGlnaHQ9Cm51bGx9ZWxzZSB0aGlzLnBhcmVudEhpZ2hsaWdodEVuYWJsZWQmJihhPXRoaXMuZ3JhcGgubW9kZWwuZ2V0UGFyZW50KHRoaXMuc3RhdGUuY2VsbCksdGhpcy5ncmFwaC5tb2RlbC5pc1ZlcnRleChhKSYmKGE9dGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKGEpLG51bGwhPWEmJih0aGlzLnBhcmVudEhpZ2hsaWdodD10aGlzLmNyZWF0ZVBhcmVudEhpZ2hsaWdodFNoYXBlKGEpLHRoaXMucGFyZW50SGlnaGxpZ2h0LmRpYWxlY3Q9dGhpcy5ncmFwaC5kaWFsZWN0IT1teENvbnN0YW50cy5ESUFMRUNUX1NWRz9teENvbnN0YW50cy5ESUFMRUNUX1ZNTDpteENvbnN0YW50cy5ESUFMRUNUX1NWRyx0aGlzLnBhcmVudEhpZ2hsaWdodC5wb2ludGVyRXZlbnRzPSExLHRoaXMucGFyZW50SGlnaGxpZ2h0LnJvdGF0aW9uPU51bWJlcihhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OXXx8IjAiKSx0aGlzLnBhcmVudEhpZ2hsaWdodC5pbml0KHRoaXMuZ3JhcGguZ2V0VmlldygpLmdldE92ZXJsYXlQYW5lKCkpLAp0aGlzLnBhcmVudEhpZ2hsaWdodC5yZWRyYXcoKSkpKX07Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuZHJhd1ByZXZpZXc9ZnVuY3Rpb24oKXtudWxsIT10aGlzLnByZXZpZXcmJih0aGlzLnByZXZpZXcuYm91bmRzPXRoaXMuYm91bmRzLHRoaXMucHJldmlldy5ub2RlLnBhcmVudE5vZGU9PXRoaXMuZ3JhcGguY29udGFpbmVyJiYodGhpcy5wcmV2aWV3LmJvdW5kcy53aWR0aD1NYXRoLm1heCgwLHRoaXMucHJldmlldy5ib3VuZHMud2lkdGgtMSksdGhpcy5wcmV2aWV3LmJvdW5kcy5oZWlnaHQ9TWF0aC5tYXgoMCx0aGlzLnByZXZpZXcuYm91bmRzLmhlaWdodC0xKSksdGhpcy5wcmV2aWV3LnJvdGF0aW9uPU51bWJlcih0aGlzLnN0YXRlLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OXXx8IjAiKSx0aGlzLnByZXZpZXcucmVkcmF3KCkpO3RoaXMuc2VsZWN0aW9uQm9yZGVyLmJvdW5kcz10aGlzLmdldFNlbGVjdGlvbkJvcmRlckJvdW5kcygpO3RoaXMuc2VsZWN0aW9uQm9yZGVyLnJlZHJhdygpO3RoaXMudXBkYXRlUGFyZW50SGlnaGxpZ2h0KCl9OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmdldFNlbGVjdGlvbkJvcmRlckJvdW5kcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJvdW5kc307Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe251bGwhPXRoaXMuZXNjYXBlSGFuZGxlciYmKHRoaXMuc3RhdGUudmlldy5ncmFwaC5yZW1vdmVMaXN0ZW5lcih0aGlzLmVzY2FwZUhhbmRsZXIpLHRoaXMuZXNjYXBlSGFuZGxlcj1udWxsKTtudWxsIT10aGlzLnByZXZpZXcmJih0aGlzLnByZXZpZXcuZGVzdHJveSgpLHRoaXMucHJldmlldz1udWxsKTtudWxsIT10aGlzLnBhcmVudEhpZ2hsaWdodCYmKHRoaXMucGFyZW50SGlnaGxpZ2h0LmRlc3Ryb3koKSx0aGlzLnBhcmVudEhpZ2hsaWdodD1udWxsKTtudWxsIT10aGlzLmdob3N0UHJldmlldyYmKHRoaXMuZ2hvc3RQcmV2aWV3LmRlc3Ryb3koKSx0aGlzLmdob3N0UHJldmlldz1udWxsKTtudWxsIT10aGlzLnNlbGVjdGlvbkJvcmRlciYmKHRoaXMuc2VsZWN0aW9uQm9yZGVyLmRlc3Ryb3koKSx0aGlzLnNlbGVjdGlvbkJvcmRlcj1udWxsKTt0aGlzLmxhYmVsU2hhcGU9bnVsbDt0aGlzLnJlbW92ZUhpbnQoKTsKaWYobnVsbCE9dGhpcy5zaXplcnMpe2Zvcih2YXIgYT0wO2E8dGhpcy5zaXplcnMubGVuZ3RoO2ErKyl0aGlzLnNpemVyc1thXS5kZXN0cm95KCk7dGhpcy5zaXplcnM9bnVsbH1pZihudWxsIT10aGlzLmN1c3RvbUhhbmRsZXMpe2ZvcihhPTA7YTx0aGlzLmN1c3RvbUhhbmRsZXMubGVuZ3RoO2ErKyl0aGlzLmN1c3RvbUhhbmRsZXNbYV0uZGVzdHJveSgpO3RoaXMuY3VzdG9tSGFuZGxlcz1udWxsfX07CmZ1bmN0aW9uIG14RWRnZUhhbmRsZXIoYSl7bnVsbCE9YSYmKHRoaXMuc3RhdGU9YSx0aGlzLmluaXQoKSx0aGlzLmVzY2FwZUhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYixjKXt2YXIgZD1udWxsIT10aGlzLmluZGV4O3RoaXMucmVzZXQoKTtkJiZ0aGlzLmdyYXBoLmNlbGxSZW5kZXJlci5yZWRyYXcodGhpcy5zdGF0ZSwhMSxhLnZpZXcuaXNSZW5kZXJpbmcoKSl9KSx0aGlzLnN0YXRlLnZpZXcuZ3JhcGguYWRkTGlzdGVuZXIobXhFdmVudC5FU0NBUEUsdGhpcy5lc2NhcGVIYW5kbGVyKSl9bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuZ3JhcGg9bnVsbDtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5zdGF0ZT1udWxsO214RWRnZUhhbmRsZXIucHJvdG90eXBlLm1hcmtlcj1udWxsO214RWRnZUhhbmRsZXIucHJvdG90eXBlLmNvbnN0cmFpbnRIYW5kbGVyPW51bGw7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuZXJyb3I9bnVsbDsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUuc2hhcGU9bnVsbDtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5iZW5kcz1udWxsO214RWRnZUhhbmRsZXIucHJvdG90eXBlLmxhYmVsU2hhcGU9bnVsbDtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5jbG9uZUVuYWJsZWQ9ITA7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuYWRkRW5hYmxlZD0hMTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5yZW1vdmVFbmFibGVkPSExO214RWRnZUhhbmRsZXIucHJvdG90eXBlLmRibENsaWNrUmVtb3ZlRW5hYmxlZD0hMTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5tZXJnZVJlbW92ZUVuYWJsZWQ9ITE7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuc3RyYWlnaHRSZW1vdmVFbmFibGVkPSExO214RWRnZUhhbmRsZXIucHJvdG90eXBlLnZpcnR1YWxCZW5kc0VuYWJsZWQ9ITE7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUudmlydHVhbEJlbmRPcGFjaXR5PTIwOwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5wYXJlbnRIaWdobGlnaHRFbmFibGVkPSExO214RWRnZUhhbmRsZXIucHJvdG90eXBlLnByZWZlckh0bWw9ITE7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuYWxsb3dIYW5kbGVCb3VuZHNDaGVjaz0hMDtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5zbmFwVG9UZXJtaW5hbHM9ITE7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlSW1hZ2U9bnVsbDtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS50b2xlcmFuY2U9MDtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5vdXRsaW5lQ29ubmVjdD0hMTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5tYW5hZ2VMYWJlbEhhbmRsZT0hMTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe3RoaXMuZ3JhcGg9dGhpcy5zdGF0ZS52aWV3LmdyYXBoO3RoaXMubWFya2VyPXRoaXMuY3JlYXRlTWFya2VyKCk7dGhpcy5jb25zdHJhaW50SGFuZGxlcj1uZXcgbXhDb25zdHJhaW50SGFuZGxlcih0aGlzLmdyYXBoKTt0aGlzLnBvaW50cz1bXTt0aGlzLmFic3BvaW50cz10aGlzLmdldFNlbGVjdGlvblBvaW50cyh0aGlzLnN0YXRlKTt0aGlzLnNoYXBlPXRoaXMuY3JlYXRlU2VsZWN0aW9uU2hhcGUodGhpcy5hYnNwb2ludHMpO3RoaXMuc2hhcGUuZGlhbGVjdD10aGlzLmdyYXBoLmRpYWxlY3QhPW14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHP214Q29uc3RhbnRzLkRJQUxFQ1RfTUlYRURIVE1MOm14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHO3RoaXMuc2hhcGUuaW5pdCh0aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRPdmVybGF5UGFuZSgpKTt0aGlzLnNoYXBlLnBvaW50ZXJFdmVudHM9ITE7dGhpcy5zaGFwZS5zZXRDdXJzb3IobXhDb25zdGFudHMuQ1VSU09SX01PVkFCTEVfRURHRSk7Cm14RXZlbnQucmVkaXJlY3RNb3VzZUV2ZW50cyh0aGlzLnNoYXBlLm5vZGUsdGhpcy5ncmFwaCx0aGlzLnN0YXRlKTt0aGlzLnByZWZlckh0bWw9bnVsbCE9dGhpcy5zdGF0ZS50ZXh0JiZ0aGlzLnN0YXRlLnRleHQubm9kZS5wYXJlbnROb2RlPT10aGlzLmdyYXBoLmNvbnRhaW5lcjtpZighdGhpcy5wcmVmZXJIdG1sKXt2YXIgYT10aGlzLnN0YXRlLmdldFZpc2libGVUZXJtaW5hbFN0YXRlKCEwKTtudWxsIT1hJiYodGhpcy5wcmVmZXJIdG1sPW51bGwhPWEudGV4dCYmYS50ZXh0Lm5vZGUucGFyZW50Tm9kZT09dGhpcy5ncmFwaC5jb250YWluZXIpO3RoaXMucHJlZmVySHRtbHx8KGE9dGhpcy5zdGF0ZS5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZSghMSksbnVsbCE9YSYmKHRoaXMucHJlZmVySHRtbD1udWxsIT1hLnRleHQmJmEudGV4dC5ub2RlLnBhcmVudE5vZGU9PXRoaXMuZ3JhcGguY29udGFpbmVyKSl9dGhpcy5wYXJlbnRIaWdobGlnaHRFbmFibGVkJiYoYT10aGlzLmdyYXBoLm1vZGVsLmdldFBhcmVudCh0aGlzLnN0YXRlLmNlbGwpLAp0aGlzLmdyYXBoLm1vZGVsLmlzVmVydGV4KGEpJiYoYT10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUoYSksbnVsbCE9YSYmKHRoaXMucGFyZW50SGlnaGxpZ2h0PXRoaXMuY3JlYXRlUGFyZW50SGlnaGxpZ2h0U2hhcGUoYSksdGhpcy5wYXJlbnRIaWdobGlnaHQuZGlhbGVjdD10aGlzLmdyYXBoLmRpYWxlY3QhPW14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHP214Q29uc3RhbnRzLkRJQUxFQ1RfVk1MOm14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHLHRoaXMucGFyZW50SGlnaGxpZ2h0LnBvaW50ZXJFdmVudHM9ITEsdGhpcy5wYXJlbnRIaWdobGlnaHQucm90YXRpb249TnVtYmVyKGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT05dfHwiMCIpLHRoaXMucGFyZW50SGlnaGxpZ2h0LmluaXQodGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0T3ZlcmxheVBhbmUoKSkpKSk7aWYodGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25Db3VudCgpPG14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5tYXhDZWxsc3x8CjA+PW14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5tYXhDZWxscyl0aGlzLmJlbmRzPXRoaXMuY3JlYXRlQmVuZHMoKSx0aGlzLmlzVmlydHVhbEJlbmRzRW5hYmxlZCgpJiYodGhpcy52aXJ0dWFsQmVuZHM9dGhpcy5jcmVhdGVWaXJ0dWFsQmVuZHMoKSk7dGhpcy5sYWJlbD1uZXcgbXhQb2ludCh0aGlzLnN0YXRlLmFic29sdXRlT2Zmc2V0LngsdGhpcy5zdGF0ZS5hYnNvbHV0ZU9mZnNldC55KTt0aGlzLmxhYmVsU2hhcGU9dGhpcy5jcmVhdGVMYWJlbEhhbmRsZVNoYXBlKCk7dGhpcy5pbml0QmVuZCh0aGlzLmxhYmVsU2hhcGUpO3RoaXMubGFiZWxTaGFwZS5zZXRDdXJzb3IobXhDb25zdGFudHMuQ1VSU09SX0xBQkVMX0hBTkRMRSk7dGhpcy5jdXN0b21IYW5kbGVzPXRoaXMuY3JlYXRlQ3VzdG9tSGFuZGxlcygpO3RoaXMucmVkcmF3KCl9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUN1c3RvbUhhbmRsZXM9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLmlzVmlydHVhbEJlbmRzRW5hYmxlZD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy52aXJ0dWFsQmVuZHNFbmFibGVkJiYobnVsbD09dGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FREdFXXx8dGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FREdFXT09bXhDb25zdGFudHMuTk9ORXx8MT09dGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9OT0VER0VTVFlMRV0pJiYiYXJyb3ciIT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU0hBUEUsbnVsbCl9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmlzQ2VsbEVuYWJsZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuITB9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmlzQWRkUG9pbnRFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gbXhFdmVudC5pc1NoaWZ0RG93bihhKX07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLmlzUmVtb3ZlUG9pbnRFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gbXhFdmVudC5pc1NoaWZ0RG93bihhKX07bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uUG9pbnRzPWZ1bmN0aW9uKGEpe3JldHVybiBhLmFic29sdXRlUG9pbnRzfTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVQYXJlbnRIaWdobGlnaHRTaGFwZT1mdW5jdGlvbihhKXthPW5ldyBteFJlY3RhbmdsZVNoYXBlKGEsbnVsbCx0aGlzLmdldFNlbGVjdGlvbkNvbG9yKCkpO2Euc3Ryb2tld2lkdGg9dGhpcy5nZXRTZWxlY3Rpb25TdHJva2VXaWR0aCgpO2EuaXNEYXNoZWQ9dGhpcy5pc1NlbGVjdGlvbkRhc2hlZCgpO3JldHVybiBhfTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlU2VsZWN0aW9uU2hhcGU9ZnVuY3Rpb24oYSl7YT1uZXcgdGhpcy5zdGF0ZS5zaGFwZS5jb25zdHJ1Y3RvcjthLm91dGxpbmU9ITA7YS5hcHBseSh0aGlzLnN0YXRlKTthLmlzRGFzaGVkPXRoaXMuaXNTZWxlY3Rpb25EYXNoZWQoKTthLnN0cm9rZT10aGlzLmdldFNlbGVjdGlvbkNvbG9yKCk7YS5pc1NoYWRvdz0hMTtyZXR1cm4gYX07bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uQ29sb3I9ZnVuY3Rpb24oKXtyZXR1cm4gbXhDb25zdGFudHMuRURHRV9TRUxFQ1RJT05fQ09MT1J9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmdldFNlbGVjdGlvblN0cm9rZVdpZHRoPWZ1bmN0aW9uKCl7cmV0dXJuIG14Q29uc3RhbnRzLkVER0VfU0VMRUNUSU9OX1NUUk9LRVdJRFRIfTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5pc1NlbGVjdGlvbkRhc2hlZD1mdW5jdGlvbigpe3JldHVybiBteENvbnN0YW50cy5FREdFX1NFTEVDVElPTl9EQVNIRUR9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5pc0Nvbm5lY3RhYmxlQ2VsbD1mdW5jdGlvbihhKXtyZXR1cm4hMH07bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuZ2V0Q2VsbEF0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMub3V0bGluZUNvbm5lY3Q/bnVsbDp0aGlzLmdyYXBoLmdldENlbGxBdChhLGIpfTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlTWFya2VyPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14Q2VsbE1hcmtlcih0aGlzLmdyYXBoKSxiPXRoaXM7YS5nZXRDZWxsPWZ1bmN0aW9uKGEpe3ZhciBjPW14Q2VsbE1hcmtlci5wcm90b3R5cGUuZ2V0Q2VsbC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YyE9Yi5zdGF0ZS5jZWxsJiZudWxsIT1jfHxudWxsPT1iLmN1cnJlbnRQb2ludHx8KGM9Yi5ncmFwaC5nZXRDZWxsQXQoYi5jdXJyZW50UG9pbnQueCxiLmN1cnJlbnRQb2ludC55KSk7aWYobnVsbCE9YyYmIXRoaXMuZ3JhcGguaXNDZWxsQ29ubmVjdGFibGUoYykpe3ZhciBlPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5nZXRQYXJlbnQoYyk7dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmlzVmVydGV4KGUpJiZ0aGlzLmdyYXBoLmlzQ2VsbENvbm5lY3RhYmxlKGUpJiYoYz1lKX1lPWIuZ3JhcGguZ2V0TW9kZWwoKTtpZih0aGlzLmdyYXBoLmlzU3dpbWxhbmUoYykmJm51bGwhPWIuY3VycmVudFBvaW50JiYKdGhpcy5ncmFwaC5oaXRzU3dpbWxhbmVDb250ZW50KGMsYi5jdXJyZW50UG9pbnQueCxiLmN1cnJlbnRQb2ludC55KXx8IWIuaXNDb25uZWN0YWJsZUNlbGwoYyl8fGM9PWIuc3RhdGUuY2VsbHx8bnVsbCE9YyYmIWIuZ3JhcGguY29ubmVjdGFibGVFZGdlcyYmZS5pc0VkZ2UoYyl8fGUuaXNBbmNlc3RvcihiLnN0YXRlLmNlbGwsYykpYz1udWxsO3RoaXMuZ3JhcGguaXNDZWxsQ29ubmVjdGFibGUoYyl8fChjPW51bGwpO3JldHVybiBjfTthLmlzVmFsaWRTdGF0ZT1mdW5jdGlvbihhKXt2YXIgYz1iLmdyYXBoLmdldE1vZGVsKCksYz1iLmdyYXBoLnZpZXcuZ2V0VGVybWluYWxQb3J0KGEsYi5ncmFwaC52aWV3LmdldFN0YXRlKGMuZ2V0VGVybWluYWwoYi5zdGF0ZS5jZWxsLCFiLmlzU291cmNlKSksIWIuaXNTb3VyY2UpLGM9bnVsbCE9Yz9jLmNlbGw6bnVsbDtiLmVycm9yPWIudmFsaWRhdGVDb25uZWN0aW9uKGIuaXNTb3VyY2U/YS5jZWxsOmMsYi5pc1NvdXJjZT9jOmEuY2VsbCk7CnJldHVybiBudWxsPT1iLmVycm9yfTtyZXR1cm4gYX07bXhFZGdlSGFuZGxlci5wcm90b3R5cGUudmFsaWRhdGVDb25uZWN0aW9uPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuZ3JhcGguZ2V0RWRnZVZhbGlkYXRpb25FcnJvcih0aGlzLnN0YXRlLmNlbGwsYSxiKX07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUJlbmRzPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMuc3RhdGUuY2VsbCxiPVtdLGM9MDtjPHRoaXMuYWJzcG9pbnRzLmxlbmd0aDtjKyspaWYodGhpcy5pc0hhbmRsZVZpc2libGUoYykpe3ZhciBkPWM9PXRoaXMuYWJzcG9pbnRzLmxlbmd0aC0xLGU9MD09Y3x8ZDsoZXx8dGhpcy5ncmFwaC5pc0NlbGxCZW5kYWJsZShhKSkmJm14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBkPXRoaXMuY3JlYXRlSGFuZGxlU2hhcGUoYSk7dGhpcy5pbml0QmVuZChkLG14VXRpbHMuYmluZCh0aGlzLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5kYmxDbGlja1JlbW92ZUVuYWJsZWQmJnRoaXMucmVtb3ZlUG9pbnQodGhpcy5zdGF0ZSxhKX0pKSk7dGhpcy5pc0hhbmRsZUVuYWJsZWQoYykmJmQuc2V0Q3Vyc29yKGU/bXhDb25zdGFudHMuQ1VSU09SX1RFUk1JTkFMX0hBTkRMRTpteENvbnN0YW50cy5DVVJTT1JfQkVORF9IQU5ETEUpOwpiLnB1c2goZCk7ZXx8KHRoaXMucG9pbnRzLnB1c2gobmV3IG14UG9pbnQoMCwwKSksZC5ub2RlLnN0eWxlLnZpc2liaWxpdHk9ImhpZGRlbiIpfSkoYyl9cmV0dXJuIGJ9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZVZpcnR1YWxCZW5kcz1mdW5jdGlvbigpe3ZhciBhPVtdO2lmKHRoaXMuZ3JhcGguaXNDZWxsQmVuZGFibGUodGhpcy5zdGF0ZS5jZWxsKSlmb3IodmFyIGI9MTtiPHRoaXMuYWJzcG9pbnRzLmxlbmd0aDtiKyspbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7dGhpcy5pbml0QmVuZChiKTtiLnNldEN1cnNvcihteENvbnN0YW50cy5DVVJTT1JfVklSVFVBTF9CRU5EX0hBTkRMRSk7YS5wdXNoKGIpfSkodGhpcy5jcmVhdGVIYW5kbGVTaGFwZSgpKTtyZXR1cm4gYX07bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuaXNIYW5kbGVFbmFibGVkPWZ1bmN0aW9uKGEpe3JldHVybiEwfTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUuaXNIYW5kbGVWaXNpYmxlPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc3RhdGUuZ2V0VmlzaWJsZVRlcm1pbmFsU3RhdGUoITApLGM9dGhpcy5zdGF0ZS5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZSghMSksZD10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeSh0aGlzLnN0YXRlLmNlbGwpO3JldHVybihudWxsIT1kP3RoaXMuZ3JhcGgudmlldy5nZXRFZGdlU3R5bGUodGhpcy5zdGF0ZSxkLnBvaW50cyxiLGMpOm51bGwpIT1teEVkZ2VTdHlsZS5FbnRpdHlSZWxhdGlvbnx8MD09YXx8YT09dGhpcy5hYnNwb2ludHMubGVuZ3RoLTF9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVIYW5kbGVTaGFwZT1mdW5jdGlvbihhKXtpZihudWxsIT10aGlzLmhhbmRsZUltYWdlKXJldHVybiBhPW5ldyBteEltYWdlU2hhcGUobmV3IG14UmVjdGFuZ2xlKDAsMCx0aGlzLmhhbmRsZUltYWdlLndpZHRoLHRoaXMuaGFuZGxlSW1hZ2UuaGVpZ2h0KSx0aGlzLmhhbmRsZUltYWdlLnNyYyksYS5wcmVzZXJ2ZUltYWdlQXNwZWN0PSExLGE7YT1teENvbnN0YW50cy5IQU5ETEVfU0laRTt0aGlzLnByZWZlckh0bWwmJi0tYTtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlU2hhcGUobmV3IG14UmVjdGFuZ2xlKDAsMCxhLGEpLG14Q29uc3RhbnRzLkhBTkRMRV9GSUxMQ09MT1IsbXhDb25zdGFudHMuSEFORExFX1NUUk9LRUNPTE9SKX07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUxhYmVsSGFuZGxlU2hhcGU9ZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLmxhYmVsSGFuZGxlSW1hZ2Upe3ZhciBhPW5ldyBteEltYWdlU2hhcGUobmV3IG14UmVjdGFuZ2xlKDAsMCx0aGlzLmxhYmVsSGFuZGxlSW1hZ2Uud2lkdGgsdGhpcy5sYWJlbEhhbmRsZUltYWdlLmhlaWdodCksdGhpcy5sYWJlbEhhbmRsZUltYWdlLnNyYyk7YS5wcmVzZXJ2ZUltYWdlQXNwZWN0PSExO3JldHVybiBhfWE9bXhDb25zdGFudHMuTEFCRUxfSEFORExFX1NJWkU7cmV0dXJuIG5ldyBteFJlY3RhbmdsZVNoYXBlKG5ldyBteFJlY3RhbmdsZSgwLDAsYSxhKSxteENvbnN0YW50cy5MQUJFTF9IQU5ETEVfRklMTENPTE9SLG14Q29uc3RhbnRzLkhBTkRMRV9TVFJPS0VDT0xPUil9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5pbml0QmVuZD1mdW5jdGlvbihhLGIpe3RoaXMucHJlZmVySHRtbD8oYS5kaWFsZWN0PW14Q29uc3RhbnRzLkRJQUxFQ1RfU1RSSUNUSFRNTCxhLmluaXQodGhpcy5ncmFwaC5jb250YWluZXIpKTooYS5kaWFsZWN0PXRoaXMuZ3JhcGguZGlhbGVjdCE9bXhDb25zdGFudHMuRElBTEVDVF9TVkc/bXhDb25zdGFudHMuRElBTEVDVF9NSVhFREhUTUw6bXhDb25zdGFudHMuRElBTEVDVF9TVkcsYS5pbml0KHRoaXMuZ3JhcGguZ2V0VmlldygpLmdldE92ZXJsYXlQYW5lKCkpKTtteEV2ZW50LnJlZGlyZWN0TW91c2VFdmVudHMoYS5ub2RlLHRoaXMuZ3JhcGgsdGhpcy5zdGF0ZSxudWxsLG51bGwsbnVsbCxiKTsobXhDbGllbnQuSVNfUVVJUktTfHw4PT1kb2N1bWVudC5kb2N1bWVudE1vZGUpJiZteEV2ZW50LmFkZExpc3RlbmVyKGEubm9kZSwiZHJhZ3N0YXJ0IixmdW5jdGlvbihhKXtteEV2ZW50LmNvbnN1bWUoYSk7cmV0dXJuITF9KTtteENsaWVudC5JU19UT1VDSCYmCmEubm9kZS5zZXRBdHRyaWJ1dGUoInBvaW50ZXItZXZlbnRzIiwibm9uZSIpfTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUuZ2V0SGFuZGxlRm9yRXZlbnQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiKXtpZihudWxsIT1iJiZudWxsIT1iLm5vZGUmJiJub25lIiE9Yi5ub2RlLnN0eWxlLmRpc3BsYXkmJiJoaWRkZW4iIT1iLm5vZGUuc3R5bGUudmlzaWJpbGl0eSYmKGEuaXNTb3VyY2UoYil8fG51bGwhPWQmJm14VXRpbHMuaW50ZXJzZWN0cyhiLmJvdW5kcyxkKSkpe3ZhciBjPWEuZ2V0R3JhcGhYKCktYi5ib3VuZHMuZ2V0Q2VudGVyWCgpO2I9YS5nZXRHcmFwaFkoKS1iLmJvdW5kcy5nZXRDZW50ZXJZKCk7Yz1jKmMrYipiO2lmKG51bGw9PWV8fGM8PWUpcmV0dXJuIGU9YywhMH1yZXR1cm4hMX12YXIgYz1teEV2ZW50LmlzTW91c2VFdmVudChhLmdldEV2ZW50KCkpPzE6dGhpcy50b2xlcmFuY2UsZD10aGlzLmFsbG93SGFuZGxlQm91bmRzQ2hlY2smJihteENsaWVudC5JU19JRXx8MDxjKT9uZXcgbXhSZWN0YW5nbGUoYS5nZXRHcmFwaFgoKS1jLGEuZ2V0R3JhcGhZKCktCmMsMipjLDIqYyk6bnVsbCxlPW51bGwsYz1udWxsO2lmKG51bGwhPXRoaXMuY3VzdG9tSGFuZGxlcyYmdGhpcy5pc0N1c3RvbUhhbmRsZUV2ZW50KGEpKWZvcih2YXIgZj10aGlzLmN1c3RvbUhhbmRsZXMubGVuZ3RoLTE7MDw9ZjtmLS0paWYoYih0aGlzLmN1c3RvbUhhbmRsZXNbZl0uc2hhcGUpKXJldHVybiBteEV2ZW50LkNVU1RPTV9IQU5ETEUtZjtpZihhLmlzU291cmNlKHRoaXMuc3RhdGUudGV4dCl8fGIodGhpcy5sYWJlbFNoYXBlKSljPW14RXZlbnQuTEFCRUxfSEFORExFO2lmKG51bGwhPXRoaXMuYmVuZHMpZm9yKGY9MDtmPHRoaXMuYmVuZHMubGVuZ3RoO2YrKyliKHRoaXMuYmVuZHNbZl0pJiYoYz1mKTtpZihudWxsIT10aGlzLnZpcnR1YWxCZW5kcyYmdGhpcy5pc0FkZFZpcnR1YWxCZW5kRXZlbnQoYSkpZm9yKGY9MDtmPHRoaXMudmlydHVhbEJlbmRzLmxlbmd0aDtmKyspYih0aGlzLnZpcnR1YWxCZW5kc1tmXSkmJihjPW14RXZlbnQuVklSVFVBTF9IQU5ETEUtZik7cmV0dXJuIGN9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5pc0FkZFZpcnR1YWxCZW5kRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuITB9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmlzQ3VzdG9tSGFuZGxlRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuITB9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5tb3VzZURvd249ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdldEhhbmRsZUZvckV2ZW50KGIpO2lmKG51bGwhPXRoaXMuYmVuZHMmJm51bGwhPXRoaXMuYmVuZHNbY10pe3ZhciBkPXRoaXMuYmVuZHNbY10uYm91bmRzO3RoaXMuc25hcFBvaW50PW5ldyBteFBvaW50KGQuZ2V0Q2VudGVyWCgpLGQuZ2V0Q2VudGVyWSgpKX1pZih0aGlzLmFkZEVuYWJsZWQmJm51bGw9PWMmJnRoaXMuaXNBZGRQb2ludEV2ZW50KGIuZ2V0RXZlbnQoKSkpdGhpcy5hZGRQb2ludCh0aGlzLnN0YXRlLGIuZ2V0RXZlbnQoKSksYi5jb25zdW1lKCk7ZWxzZSBpZihudWxsIT1jJiYhYi5pc0NvbnN1bWVkKCkmJnRoaXMuZ3JhcGguaXNFbmFibGVkKCkpe2lmKHRoaXMucmVtb3ZlRW5hYmxlZCYmdGhpcy5pc1JlbW92ZVBvaW50RXZlbnQoYi5nZXRFdmVudCgpKSl0aGlzLnJlbW92ZVBvaW50KHRoaXMuc3RhdGUsYyk7ZWxzZSBpZihjIT1teEV2ZW50LkxBQkVMX0hBTkRMRXx8CnRoaXMuZ3JhcGguaXNMYWJlbE1vdmFibGUoYi5nZXRDZWxsKCkpKWM8PW14RXZlbnQuVklSVFVBTF9IQU5ETEUmJm14VXRpbHMuc2V0T3BhY2l0eSh0aGlzLnZpcnR1YWxCZW5kc1tteEV2ZW50LlZJUlRVQUxfSEFORExFLWNdLm5vZGUsMTAwKSx0aGlzLnN0YXJ0KGIuZ2V0WCgpLGIuZ2V0WSgpLGMpO2IuY29uc3VtZSgpfX07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKGEsYixjKXt0aGlzLnN0YXJ0WD1hO3RoaXMuc3RhcnRZPWI7dGhpcy5pc1NvdXJjZT1udWxsPT10aGlzLmJlbmRzPyExOjA9PWM7dGhpcy5pc1RhcmdldD1udWxsPT10aGlzLmJlbmRzPyExOmM9PXRoaXMuYmVuZHMubGVuZ3RoLTE7dGhpcy5pc0xhYmVsPWM9PW14RXZlbnQuTEFCRUxfSEFORExFO2lmKHRoaXMuaXNTb3VyY2V8fHRoaXMuaXNUYXJnZXQpe2lmKGE9dGhpcy5zdGF0ZS5jZWxsLGI9dGhpcy5ncmFwaC5tb2RlbC5nZXRUZXJtaW5hbChhLHRoaXMuaXNTb3VyY2UpLG51bGw9PWImJnRoaXMuZ3JhcGguaXNUZXJtaW5hbFBvaW50TW92YWJsZShhLHRoaXMuaXNTb3VyY2UpfHxudWxsIT1iJiZ0aGlzLmdyYXBoLmlzQ2VsbERpc2Nvbm5lY3RhYmxlKGEsYix0aGlzLmlzU291cmNlKSl0aGlzLmluZGV4PWN9ZWxzZSB0aGlzLmluZGV4PWM7aWYodGhpcy5pbmRleDw9bXhFdmVudC5DVVNUT01fSEFORExFJiZ0aGlzLmluZGV4PgpteEV2ZW50LlZJUlRVQUxfSEFORExFJiZudWxsIT10aGlzLmN1c3RvbUhhbmRsZXMpZm9yKGM9MDtjPHRoaXMuY3VzdG9tSGFuZGxlcy5sZW5ndGg7YysrKWMhPW14RXZlbnQuQ1VTVE9NX0hBTkRMRS10aGlzLmluZGV4JiZ0aGlzLmN1c3RvbUhhbmRsZXNbY10uc2V0VmlzaWJsZSghMSl9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmNsb25lUHJldmlld1N0YXRlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuc3RhdGUuY2xvbmUoKX07bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuZ2V0U25hcFRvVGVybWluYWxUb2xlcmFuY2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmFwaC5ncmlkU2l6ZSp0aGlzLmdyYXBoLnZpZXcuc2NhbGUvMn07bXhFZGdlSGFuZGxlci5wcm90b3R5cGUudXBkYXRlSGludD1mdW5jdGlvbihhLGIpe307bXhFZGdlSGFuZGxlci5wcm90b3R5cGUucmVtb3ZlSGludD1mdW5jdGlvbigpe307bXhFZGdlSGFuZGxlci5wcm90b3R5cGUucm91bmRMZW5ndGg9ZnVuY3Rpb24oYSl7cmV0dXJuIE1hdGgucm91bmQoYSl9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5pc1NuYXBUb1Rlcm1pbmFsc0V2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnNuYXBUb1Rlcm1pbmFscyYmIW14RXZlbnQuaXNBbHREb3duKGEuZ2V0RXZlbnQoKSl9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5nZXRQb2ludEZvckV2ZW50PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ3JhcGguZ2V0VmlldygpLGM9Yi5zY2FsZSxkPW5ldyBteFBvaW50KHRoaXMucm91bmRMZW5ndGgoYS5nZXRHcmFwaFgoKS9jKSpjLHRoaXMucm91bmRMZW5ndGgoYS5nZXRHcmFwaFkoKS9jKSpjKSxlPXRoaXMuZ2V0U25hcFRvVGVybWluYWxUb2xlcmFuY2UoKSxmPSExLGc9ITE7aWYoMDxlJiZ0aGlzLmlzU25hcFRvVGVybWluYWxzRXZlbnQoYSkpe3ZhciBrPWZ1bmN0aW9uKGEpe251bGwhPWEmJmwuY2FsbCh0aGlzLG5ldyBteFBvaW50KGIuZ2V0Um91dGluZ0NlbnRlclgoYSksYi5nZXRSb3V0aW5nQ2VudGVyWShhKSkpfSxsPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe3ZhciBiPWEueDtNYXRoLmFicyhkLngtYik8ZSYmKGQueD1iLGY9ITApO2E9YS55O01hdGguYWJzKGQueS1hKTxlJiYoZC55PWEsZz0hMCl9fTtrLmNhbGwodGhpcyx0aGlzLnN0YXRlLmdldFZpc2libGVUZXJtaW5hbFN0YXRlKCEwKSk7CmsuY2FsbCh0aGlzLHRoaXMuc3RhdGUuZ2V0VmlzaWJsZVRlcm1pbmFsU3RhdGUoITEpKTtpZihudWxsIT10aGlzLnN0YXRlLmFic29sdXRlUG9pbnRzKWZvcihrPTA7azx0aGlzLnN0YXRlLmFic29sdXRlUG9pbnRzLmxlbmd0aDtrKyspbC5jYWxsKHRoaXMsdGhpcy5zdGF0ZS5hYnNvbHV0ZVBvaW50c1trXSl9dGhpcy5ncmFwaC5pc0dyaWRFbmFibGVkRXZlbnQoYS5nZXRFdmVudCgpKSYmKGE9Yi50cmFuc2xhdGUsZnx8KGQueD0odGhpcy5ncmFwaC5zbmFwKGQueC9jLWEueCkrYS54KSpjKSxnfHwoZC55PSh0aGlzLmdyYXBoLnNuYXAoZC55L2MtYS55KSthLnkpKmMpKTtyZXR1cm4gZH07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLmdldFByZXZpZXdUZXJtaW5hbFN0YXRlPWZ1bmN0aW9uKGEpe3RoaXMuY29uc3RyYWludEhhbmRsZXIudXBkYXRlKGEsdGhpcy5pc1NvdXJjZSwhMCxhLmlzU291cmNlKHRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZSk/bnVsbDp0aGlzLmN1cnJlbnRQb2ludCk7aWYobnVsbCE9dGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Rm9jdXMmJm51bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudENvbnN0cmFpbnQpcmV0dXJuIG51bGwhPXRoaXMubWFya2VyLmhpZ2hsaWdodCYmbnVsbCE9dGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnN0YXRlJiZ0aGlzLm1hcmtlci5oaWdobGlnaHQuc3RhdGUuY2VsbD09dGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Rm9jdXMuY2VsbD8idHJhbnNwYXJlbnQiIT10aGlzLm1hcmtlci5oaWdobGlnaHQuc2hhcGUuc3Ryb2tlJiYodGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnNoYXBlLnN0cm9rZT0idHJhbnNwYXJlbnQiLAp0aGlzLm1hcmtlci5oaWdobGlnaHQucmVwYWludCgpKTp0aGlzLm1hcmtlci5tYXJrQ2VsbCh0aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRGb2N1cy5jZWxsLCJ0cmFuc3BhcmVudCIpLGE9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGE9dGhpcy5ncmFwaC52aWV3LmdldFRlcm1pbmFsUG9ydCh0aGlzLnN0YXRlLHRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZShhLmdldFRlcm1pbmFsKHRoaXMuc3RhdGUuY2VsbCwhdGhpcy5pc1NvdXJjZSkpLCF0aGlzLmlzU291cmNlKSxhPW51bGwhPWE/YS5jZWxsOm51bGwsdGhpcy5lcnJvcj10aGlzLnZhbGlkYXRlQ29ubmVjdGlvbih0aGlzLmlzU291cmNlP3RoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudEZvY3VzLmNlbGw6YSx0aGlzLmlzU291cmNlP2E6dGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Rm9jdXMuY2VsbCksYT1udWxsLG51bGw9PXRoaXMuZXJyb3ImJihhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudEZvY3VzKSwKKG51bGwhPXRoaXMuZXJyb3J8fG51bGwhPWEmJiF0aGlzLmlzQ2VsbEVuYWJsZWQoYS5jZWxsKSkmJnRoaXMuY29uc3RyYWludEhhbmRsZXIucmVzZXQoKSxhO2lmKHRoaXMuZ3JhcGguaXNJZ25vcmVUZXJtaW5hbEV2ZW50KGEuZ2V0RXZlbnQoKSkpcmV0dXJuIHRoaXMubWFya2VyLnJlc2V0KCksbnVsbDt0aGlzLm1hcmtlci5wcm9jZXNzKGEpO2E9dGhpcy5tYXJrZXIuZ2V0VmFsaWRTdGF0ZSgpO251bGw9PWF8fHRoaXMuaXNDZWxsRW5hYmxlZChhLmNlbGwpfHwodGhpcy5jb25zdHJhaW50SGFuZGxlci5yZXNldCgpLHRoaXMubWFya2VyLnJlc2V0KCkpO3JldHVybiB0aGlzLm1hcmtlci5nZXRWYWxpZFN0YXRlKCl9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5nZXRQcmV2aWV3UG9pbnRzPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkodGhpcy5zdGF0ZS5jZWxsKSxjPW51bGwhPWMucG9pbnRzP2MucG9pbnRzLnNsaWNlKCk6bnVsbCxkPW5ldyBteFBvaW50KGEueCxhLnkpLGU9bnVsbDtpZih0aGlzLmlzU291cmNlfHx0aGlzLmlzVGFyZ2V0KXRoaXMuZ3JhcGgucmVzZXRFZGdlc09uQ29ubmVjdCYmKGM9bnVsbCk7ZWxzZSBpZih0aGlzLmNvbnZlcnRQb2ludChkLCExKSxudWxsPT1jKWM9W2RdO2Vsc2V7dGhpcy5pbmRleDw9bXhFdmVudC5WSVJUVUFMX0hBTkRMRSYmYy5zcGxpY2UobXhFdmVudC5WSVJUVUFMX0hBTkRMRS10aGlzLmluZGV4LDAsZCk7aWYoIXRoaXMuaXNTb3VyY2UmJiF0aGlzLmlzVGFyZ2V0KXtmb3IodmFyIGY9MDtmPHRoaXMuYmVuZHMubGVuZ3RoO2YrKylpZihmIT10aGlzLmluZGV4KXt2YXIgZz10aGlzLmJlbmRzW2ZdO251bGwhPWcmJm14VXRpbHMuY29udGFpbnMoZy5ib3VuZHMsCmEueCxhLnkpJiYodGhpcy5pbmRleDw9bXhFdmVudC5WSVJUVUFMX0hBTkRMRT9jLnNwbGljZShteEV2ZW50LlZJUlRVQUxfSEFORExFLXRoaXMuaW5kZXgsMSk6Yy5zcGxpY2UodGhpcy5pbmRleC0xLDEpLGU9Yyl9aWYobnVsbD09ZSYmdGhpcy5zdHJhaWdodFJlbW92ZUVuYWJsZWQmJihudWxsPT1ifHwhbXhFdmVudC5pc0FsdERvd24oYi5nZXRFdmVudCgpKSkpe2Y9dGhpcy5ncmFwaC50b2xlcmFuY2UqdGhpcy5ncmFwaC50b2xlcmFuY2U7Zz10aGlzLnN0YXRlLmFic29sdXRlUG9pbnRzLnNsaWNlKCk7Z1t0aGlzLmluZGV4XT1hO3ZhciBrPXRoaXMuc3RhdGUuZ2V0VmlzaWJsZVRlcm1pbmFsU3RhdGUoITApO2lmKG51bGwhPWspe3ZhciBsPXRoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvbkNvbnN0cmFpbnQodGhpcy5zdGF0ZSxrLCEwKTtpZihudWxsPT1sfHxudWxsPT10aGlzLmdyYXBoLmdldENvbm5lY3Rpb25Qb2ludChrLGwpKWdbMF09bmV3IG14UG9pbnQoay52aWV3LmdldFJvdXRpbmdDZW50ZXJYKGspLAprLnZpZXcuZ2V0Um91dGluZ0NlbnRlclkoaykpfWs9dGhpcy5zdGF0ZS5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZSghMSk7bnVsbCE9ayYmKGw9dGhpcy5ncmFwaC5nZXRDb25uZWN0aW9uQ29uc3RyYWludCh0aGlzLnN0YXRlLGssITEpLG51bGw9PWx8fG51bGw9PXRoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvblBvaW50KGssbCkpJiYoZ1tnLmxlbmd0aC0xXT1uZXcgbXhQb2ludChrLnZpZXcuZ2V0Um91dGluZ0NlbnRlclgoayksay52aWV3LmdldFJvdXRpbmdDZW50ZXJZKGspKSk7bD10aGlzLmluZGV4OzA8bCYmbDxnLmxlbmd0aC0xJiZteFV0aWxzLnB0U2VnRGlzdFNxKGdbbC0xXS54LGdbbC0xXS55LGdbbCsxXS54LGdbbCsxXS55LGEueCxhLnkpPGYmJihjLnNwbGljZShsLTEsMSksZT1jKX19bnVsbD09ZSYmdGhpcy5pbmRleD5teEV2ZW50LlZJUlRVQUxfSEFORExFJiYoY1t0aGlzLmluZGV4LTFdPWQpfXJldHVybiBudWxsIT1lP2U6Y307Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLmlzT3V0bGluZUNvbm5lY3RFdmVudD1mdW5jdGlvbihhKXt2YXIgYj1teFV0aWxzLmdldE9mZnNldCh0aGlzLmdyYXBoLmNvbnRhaW5lciksYz1hLmdldEV2ZW50KCksZD1teEV2ZW50LmdldENsaWVudFgoYyksYz1teEV2ZW50LmdldENsaWVudFkoYyksZT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsZj10aGlzLmN1cnJlbnRQb2ludC54LXRoaXMuZ3JhcGguY29udGFpbmVyLnNjcm9sbExlZnQrYi54LSgod2luZG93LnBhZ2VYT2Zmc2V0fHxlLnNjcm9sbExlZnQpLShlLmNsaWVudExlZnR8fDApKSxiPXRoaXMuY3VycmVudFBvaW50LnktdGhpcy5ncmFwaC5jb250YWluZXIuc2Nyb2xsVG9wK2IueS0oKHdpbmRvdy5wYWdlWU9mZnNldHx8ZS5zY3JvbGxUb3ApLShlLmNsaWVudFRvcHx8MCkpO3JldHVybiB0aGlzLm91dGxpbmVDb25uZWN0JiYhbXhFdmVudC5pc1NoaWZ0RG93bihhLmdldEV2ZW50KCkpJiYoYS5pc1NvdXJjZSh0aGlzLm1hcmtlci5oaWdobGlnaHQuc2hhcGUpfHwKbXhFdmVudC5pc0FsdERvd24oYS5nZXRFdmVudCgpKSYmbnVsbCE9YS5nZXRTdGF0ZSgpfHx0aGlzLm1hcmtlci5oaWdobGlnaHQuaXNIaWdobGlnaHRBdChkLGMpfHwoZiE9ZHx8YiE9YykmJm51bGw9PWEuZ2V0U3RhdGUoKSYmdGhpcy5tYXJrZXIuaGlnaGxpZ2h0LmlzSGlnaGxpZ2h0QXQoZixiKSl9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVQcmV2aWV3U3RhdGU9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj10aGlzLmlzU291cmNlP2M6dGhpcy5zdGF0ZS5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZSghMCksZz10aGlzLmlzVGFyZ2V0P2M6dGhpcy5zdGF0ZS5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZSghMSksaz10aGlzLmdyYXBoLmdldENvbm5lY3Rpb25Db25zdHJhaW50KGEsZiwhMCksbD10aGlzLmdyYXBoLmdldENvbm5lY3Rpb25Db25zdHJhaW50KGEsZywhMSksbT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRDb25zdHJhaW50O251bGw9PW0mJmUmJihudWxsIT1jPyhkLmlzU291cmNlKHRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZSkmJihiPW5ldyBteFBvaW50KGQuZ2V0R3JhcGhYKCksZC5nZXRHcmFwaFkoKSkpLG09dGhpcy5ncmFwaC5nZXRPdXRsaW5lQ29uc3RyYWludChiLGMsZCksdGhpcy5jb25zdHJhaW50SGFuZGxlci5zZXRGb2N1cyhkLGMsdGhpcy5pc1NvdXJjZSksCnRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudENvbnN0cmFpbnQ9bSx0aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRQb2ludD1iKTptPW5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KTtpZih0aGlzLm91dGxpbmVDb25uZWN0JiZudWxsIT10aGlzLm1hcmtlci5oaWdobGlnaHQmJm51bGwhPXRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZSl7dmFyIG49dGhpcy5ncmFwaC52aWV3LnNjYWxlO251bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudENvbnN0cmFpbnQmJm51bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudEZvY3VzPyh0aGlzLm1hcmtlci5oaWdobGlnaHQuc2hhcGUuc3Ryb2tlPWU/bXhDb25zdGFudHMuT1VUTElORV9ISUdITElHSFRfQ09MT1I6InRyYW5zcGFyZW50Iix0aGlzLm1hcmtlci5oaWdobGlnaHQuc2hhcGUuc3Ryb2tld2lkdGg9bXhDb25zdGFudHMuT1VUTElORV9ISUdITElHSFRfU1RST0tFV0lEVEgvbi9uLHRoaXMubWFya2VyLmhpZ2hsaWdodC5yZXBhaW50KCkpOgp0aGlzLm1hcmtlci5oYXNWYWxpZFN0YXRlKCkmJih0aGlzLm1hcmtlci5oaWdobGlnaHQuc2hhcGUuc3Ryb2tlPXRoaXMuZ3JhcGguaXNDZWxsQ29ubmVjdGFibGUoZC5nZXRDZWxsKCkpJiZ0aGlzLm1hcmtlci5nZXRWYWxpZFN0YXRlKCkhPWQuZ2V0U3RhdGUoKT8idHJhbnNwYXJlbnQiOm14Q29uc3RhbnRzLkRFRkFVTFRfVkFMSURfQ09MT1IsdGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnNoYXBlLnN0cm9rZXdpZHRoPW14Q29uc3RhbnRzLkhJR0hMSUdIVF9TVFJPS0VXSURUSC9uL24sdGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnJlcGFpbnQoKSl9dGhpcy5pc1NvdXJjZT9rPW06dGhpcy5pc1RhcmdldCYmKGw9bSk7aWYodGhpcy5pc1NvdXJjZXx8dGhpcy5pc1RhcmdldCludWxsIT1tJiZudWxsIT1tLnBvaW50PyhhLnN0eWxlW3RoaXMuaXNTb3VyY2U/bXhDb25zdGFudHMuU1RZTEVfRVhJVF9YOm14Q29uc3RhbnRzLlNUWUxFX0VOVFJZX1hdPW0ucG9pbnQueCxhLnN0eWxlW3RoaXMuaXNTb3VyY2U/Cm14Q29uc3RhbnRzLlNUWUxFX0VYSVRfWTpteENvbnN0YW50cy5TVFlMRV9FTlRSWV9ZXT1tLnBvaW50LnkpOihkZWxldGUgYS5zdHlsZVt0aGlzLmlzU291cmNlP214Q29uc3RhbnRzLlNUWUxFX0VYSVRfWDpteENvbnN0YW50cy5TVFlMRV9FTlRSWV9YXSxkZWxldGUgYS5zdHlsZVt0aGlzLmlzU291cmNlP214Q29uc3RhbnRzLlNUWUxFX0VYSVRfWTpteENvbnN0YW50cy5TVFlMRV9FTlRSWV9ZXSk7YS5zZXRWaXNpYmxlVGVybWluYWxTdGF0ZShmLCEwKTthLnNldFZpc2libGVUZXJtaW5hbFN0YXRlKGcsITEpO3RoaXMuaXNTb3VyY2UmJm51bGw9PWZ8fGEudmlldy51cGRhdGVGaXhlZFRlcm1pbmFsUG9pbnQoYSxmLCEwLGspO3RoaXMuaXNUYXJnZXQmJm51bGw9PWd8fGEudmlldy51cGRhdGVGaXhlZFRlcm1pbmFsUG9pbnQoYSxnLCExLGwpOyh0aGlzLmlzU291cmNlfHx0aGlzLmlzVGFyZ2V0KSYmbnVsbD09YyYmKGEuc2V0QWJzb2x1dGVUZXJtaW5hbFBvaW50KGIsdGhpcy5pc1NvdXJjZSksCm51bGw9PXRoaXMubWFya2VyLmdldE1hcmtlZFN0YXRlKCkmJih0aGlzLmVycm9yPXRoaXMuZ3JhcGguYWxsb3dEYW5nbGluZ0VkZ2VzP251bGw6IiIpKTthLnZpZXcudXBkYXRlUG9pbnRzKGEsdGhpcy5wb2ludHMsZixnKTthLnZpZXcudXBkYXRlRmxvYXRpbmdUZXJtaW5hbFBvaW50cyhhLGYsZyl9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5tb3VzZU1vdmU9ZnVuY3Rpb24oYSxiKXtpZihudWxsIT10aGlzLmluZGV4JiZudWxsIT10aGlzLm1hcmtlcil7dGhpcy5jdXJyZW50UG9pbnQ9dGhpcy5nZXRQb2ludEZvckV2ZW50KGIpO3RoaXMuZXJyb3I9bnVsbDshdGhpcy5ncmFwaC5pc0lnbm9yZVRlcm1pbmFsRXZlbnQoYi5nZXRFdmVudCgpKSYmbXhFdmVudC5pc1NoaWZ0RG93bihiLmdldEV2ZW50KCkpJiZudWxsIT10aGlzLnNuYXBQb2ludCYmKE1hdGguYWJzKHRoaXMuc25hcFBvaW50LngtdGhpcy5jdXJyZW50UG9pbnQueCk8TWF0aC5hYnModGhpcy5zbmFwUG9pbnQueS10aGlzLmN1cnJlbnRQb2ludC55KT90aGlzLmN1cnJlbnRQb2ludC54PXRoaXMuc25hcFBvaW50Lng6dGhpcy5jdXJyZW50UG9pbnQueT10aGlzLnNuYXBQb2ludC55KTtpZih0aGlzLmluZGV4PD1teEV2ZW50LkNVU1RPTV9IQU5ETEUmJnRoaXMuaW5kZXg+bXhFdmVudC5WSVJUVUFMX0hBTkRMRSludWxsIT0KdGhpcy5jdXN0b21IYW5kbGVzJiYodGhpcy5jdXN0b21IYW5kbGVzW214RXZlbnQuQ1VTVE9NX0hBTkRMRS10aGlzLmluZGV4XS5wcm9jZXNzRXZlbnQoYiksdGhpcy5jdXN0b21IYW5kbGVzW214RXZlbnQuQ1VTVE9NX0hBTkRMRS10aGlzLmluZGV4XS5wb3NpdGlvbkNoYW5nZWQoKSk7ZWxzZSBpZih0aGlzLmlzTGFiZWwpdGhpcy5sYWJlbC54PXRoaXMuY3VycmVudFBvaW50LngsdGhpcy5sYWJlbC55PXRoaXMuY3VycmVudFBvaW50Lnk7ZWxzZXt0aGlzLnBvaW50cz10aGlzLmdldFByZXZpZXdQb2ludHModGhpcy5jdXJyZW50UG9pbnQsYik7dmFyIGM9dGhpcy5pc1NvdXJjZXx8dGhpcy5pc1RhcmdldD90aGlzLmdldFByZXZpZXdUZXJtaW5hbFN0YXRlKGIpOm51bGw7aWYobnVsbCE9dGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Q29uc3RyYWludCYmbnVsbCE9dGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Rm9jdXMmJm51bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudFBvaW50KXRoaXMuY3VycmVudFBvaW50PQp0aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRQb2ludC5jbG9uZSgpO2Vsc2UgaWYodGhpcy5vdXRsaW5lQ29ubmVjdCl7dmFyIGQ9dGhpcy5pc1NvdXJjZXx8dGhpcy5pc1RhcmdldD90aGlzLmlzT3V0bGluZUNvbm5lY3RFdmVudChiKTohMTtkP2M9dGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnN0YXRlOm51bGwhPWMmJmMhPWIuZ2V0U3RhdGUoKSYmdGhpcy5ncmFwaC5pc0NlbGxDb25uZWN0YWJsZShiLmdldENlbGwoKSkmJm51bGwhPXRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZSYmKHRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZS5zdHJva2U9InRyYW5zcGFyZW50Iix0aGlzLm1hcmtlci5oaWdobGlnaHQucmVwYWludCgpLGM9bnVsbCl9bnVsbD09Y3x8dGhpcy5pc0NlbGxFbmFibGVkKGMuY2VsbCl8fChjPW51bGwsdGhpcy5tYXJrZXIucmVzZXQoKSk7dmFyIGU9dGhpcy5jbG9uZVByZXZpZXdTdGF0ZSh0aGlzLmN1cnJlbnRQb2ludCxudWxsIT1jP2MuY2VsbDpudWxsKTsKdGhpcy51cGRhdGVQcmV2aWV3U3RhdGUoZSx0aGlzLmN1cnJlbnRQb2ludCxjLGIsZCk7dGhpcy5zZXRQcmV2aWV3Q29sb3IobnVsbD09dGhpcy5lcnJvcj90aGlzLm1hcmtlci52YWxpZENvbG9yOnRoaXMubWFya2VyLmludmFsaWRDb2xvcik7dGhpcy5hYnNwb2ludHM9ZS5hYnNvbHV0ZVBvaW50czt0aGlzLmFjdGl2ZT0hMDt0aGlzLnVwZGF0ZUhpbnQoYix0aGlzLmN1cnJlbnRQb2ludCl9dGhpcy5kcmF3UHJldmlldygpO214RXZlbnQuY29uc3VtZShiLmdldEV2ZW50KCkpO2IuY29uc3VtZSgpfWVsc2UgbXhDbGllbnQuSVNfSUUmJm51bGwhPXRoaXMuZ2V0SGFuZGxlRm9yRXZlbnQoYikmJmIuY29uc3VtZSghMSl9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5tb3VzZVVwPWZ1bmN0aW9uKGEsYil7aWYobnVsbCE9dGhpcy5pbmRleCYmbnVsbCE9dGhpcy5tYXJrZXIpe3ZhciBjPXRoaXMuc3RhdGUuY2VsbCxkPXRoaXMuaW5kZXg7dGhpcy5pbmRleD1udWxsO2lmKGIuZ2V0WCgpIT10aGlzLnN0YXJ0WHx8Yi5nZXRZKCkhPXRoaXMuc3RhcnRZKXt2YXIgZT0hdGhpcy5ncmFwaC5pc0lnbm9yZVRlcm1pbmFsRXZlbnQoYi5nZXRFdmVudCgpKSYmdGhpcy5ncmFwaC5pc0Nsb25lRXZlbnQoYi5nZXRFdmVudCgpKSYmdGhpcy5jbG9uZUVuYWJsZWQmJnRoaXMuZ3JhcGguaXNDZWxsc0Nsb25lYWJsZSgpO2lmKG51bGwhPXRoaXMuZXJyb3IpMDx0aGlzLmVycm9yLmxlbmd0aCYmdGhpcy5ncmFwaC52YWxpZGF0aW9uQWxlcnQodGhpcy5lcnJvcik7ZWxzZSBpZihkPD1teEV2ZW50LkNVU1RPTV9IQU5ETEUmJmQ+bXhFdmVudC5WSVJUVUFMX0hBTkRMRSl7aWYobnVsbCE9dGhpcy5jdXN0b21IYW5kbGVzKXt2YXIgZj0KdGhpcy5ncmFwaC5nZXRNb2RlbCgpO2YuYmVnaW5VcGRhdGUoKTt0cnl7dGhpcy5jdXN0b21IYW5kbGVzW214RXZlbnQuQ1VTVE9NX0hBTkRMRS1kXS5leGVjdXRlKGIpfWZpbmFsbHl7Zi5lbmRVcGRhdGUoKX19fWVsc2UgaWYodGhpcy5pc0xhYmVsKXRoaXMubW92ZUxhYmVsKHRoaXMuc3RhdGUsdGhpcy5sYWJlbC54LHRoaXMubGFiZWwueSk7ZWxzZSBpZih0aGlzLmlzU291cmNlfHx0aGlzLmlzVGFyZ2V0KWlmKGQ9bnVsbCxudWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRDb25zdHJhaW50JiZudWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRGb2N1cyYmKGQ9dGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Rm9jdXMuY2VsbCksbnVsbD09ZCYmdGhpcy5tYXJrZXIuaGFzVmFsaWRTdGF0ZSgpJiZudWxsIT10aGlzLm1hcmtlci5oaWdobGlnaHQmJm51bGwhPXRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZSYmInRyYW5zcGFyZW50IiE9dGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnNoYXBlLnN0cm9rZSYmCiJ3aGl0ZSIhPXRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZS5zdHJva2UmJihkPXRoaXMubWFya2VyLnZhbGlkU3RhdGUuY2VsbCksbnVsbCE9ZCl7dmFyIGY9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGc9Zi5nZXRQYXJlbnQoYyk7Zi5iZWdpblVwZGF0ZSgpO3RyeXtpZihlKXt2YXIgaz1mLmdldEdlb21ldHJ5KGMpLGU9dGhpcy5ncmFwaC5jbG9uZUNlbGwoYyk7Zi5hZGQoZyxlLGYuZ2V0Q2hpbGRDb3VudChnKSk7bnVsbCE9ayYmKGs9ay5jbG9uZSgpLGYuc2V0R2VvbWV0cnkoZSxrKSk7dmFyIGw9Zi5nZXRUZXJtaW5hbChjLCF0aGlzLmlzU291cmNlKTt0aGlzLmdyYXBoLmNvbm5lY3RDZWxsKGUsbCwhdGhpcy5pc1NvdXJjZSk7Yz1lfWM9dGhpcy5jb25uZWN0KGMsZCx0aGlzLmlzU291cmNlLGUsYil9ZmluYWxseXtmLmVuZFVwZGF0ZSgpfX1lbHNlIHRoaXMuZ3JhcGguaXNBbGxvd0RhbmdsaW5nRWRnZXMoKSYmKGY9dGhpcy5hYnNwb2ludHNbdGhpcy5pc1NvdXJjZT8wOnRoaXMuYWJzcG9pbnRzLmxlbmd0aC0KMV0sZi54PXRoaXMucm91bmRMZW5ndGgoZi54L3RoaXMuZ3JhcGgudmlldy5zY2FsZS10aGlzLmdyYXBoLnZpZXcudHJhbnNsYXRlLngpLGYueT10aGlzLnJvdW5kTGVuZ3RoKGYueS90aGlzLmdyYXBoLnZpZXcuc2NhbGUtdGhpcy5ncmFwaC52aWV3LnRyYW5zbGF0ZS55KSxrPXRoaXMuZ3JhcGguZ2V0VmlldygpLmdldFN0YXRlKHRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5nZXRQYXJlbnQoYykpLG51bGwhPWsmJihmLngtPWsub3JpZ2luLngsZi55LT1rLm9yaWdpbi55KSxmLngtPXRoaXMuZ3JhcGgucGFuRHgvdGhpcy5ncmFwaC52aWV3LnNjYWxlLGYueS09dGhpcy5ncmFwaC5wYW5EeS90aGlzLmdyYXBoLnZpZXcuc2NhbGUsYz10aGlzLmNoYW5nZVRlcm1pbmFsUG9pbnQoYyxmLHRoaXMuaXNTb3VyY2UsZSkpO2Vsc2UgdGhpcy5hY3RpdmU/Yz10aGlzLmNoYW5nZVBvaW50cyhjLHRoaXMucG9pbnRzLGUpOih0aGlzLmdyYXBoLmdldFZpZXcoKS5pbnZhbGlkYXRlKHRoaXMuc3RhdGUuY2VsbCksCnRoaXMuZ3JhcGguZ2V0VmlldygpLnZhbGlkYXRlKHRoaXMuc3RhdGUuY2VsbCkpfWVsc2UgdGhpcy5ncmFwaC5pc1RvZ2dsZUV2ZW50KGIuZ2V0RXZlbnQoKSkmJnRoaXMuZ3JhcGguc2VsZWN0Q2VsbEZvckV2ZW50KHRoaXMuc3RhdGUuY2VsbCxiLmdldEV2ZW50KCkpO251bGwhPXRoaXMubWFya2VyJiYodGhpcy5yZXNldCgpLGMhPXRoaXMuc3RhdGUuY2VsbCYmdGhpcy5ncmFwaC5zZXRTZWxlY3Rpb25DZWxsKGMpKTtiLmNvbnN1bWUoKX19OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMuYWN0aXZlJiZ0aGlzLnJlZnJlc2goKTt0aGlzLnNuYXBQb2ludD10aGlzLnBvaW50cz10aGlzLmxhYmVsPXRoaXMuaW5kZXg9dGhpcy5lcnJvcj1udWxsO3RoaXMuYWN0aXZlPXRoaXMuaXNUYXJnZXQ9dGhpcy5pc1NvdXJjZT10aGlzLmlzTGFiZWw9ITE7aWYodGhpcy5saXZlUHJldmlldyYmbnVsbCE9dGhpcy5zaXplcnMpZm9yKHZhciBhPTA7YTx0aGlzLnNpemVycy5sZW5ndGg7YSsrKW51bGwhPXRoaXMuc2l6ZXJzW2FdJiYodGhpcy5zaXplcnNbYV0ubm9kZS5zdHlsZS5kaXNwbGF5PSIiKTtudWxsIT10aGlzLm1hcmtlciYmdGhpcy5tYXJrZXIucmVzZXQoKTtudWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyJiZ0aGlzLmNvbnN0cmFpbnRIYW5kbGVyLnJlc2V0KCk7aWYobnVsbCE9dGhpcy5jdXN0b21IYW5kbGVzKWZvcihhPTA7YTx0aGlzLmN1c3RvbUhhbmRsZXMubGVuZ3RoO2ErKyl0aGlzLmN1c3RvbUhhbmRsZXNbYV0ucmVzZXQoKTsKdGhpcy5zZXRQcmV2aWV3Q29sb3IobXhDb25zdGFudHMuRURHRV9TRUxFQ1RJT05fQ09MT1IpO3RoaXMucmVtb3ZlSGludCgpO3RoaXMucmVkcmF3KCl9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLnNldFByZXZpZXdDb2xvcj1mdW5jdGlvbihhKXtudWxsIT10aGlzLnNoYXBlJiYodGhpcy5zaGFwZS5zdHJva2U9YSl9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5jb252ZXJ0UG9pbnQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRTY2FsZSgpLGQ9dGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0VHJhbnNsYXRlKCk7YiYmKGEueD10aGlzLmdyYXBoLnNuYXAoYS54KSxhLnk9dGhpcy5ncmFwaC5zbmFwKGEueSkpO2EueD1NYXRoLnJvdW5kKGEueC9jLWQueCk7YS55PU1hdGgucm91bmQoYS55L2MtZC55KTtjPXRoaXMuZ3JhcGguZ2V0VmlldygpLmdldFN0YXRlKHRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5nZXRQYXJlbnQodGhpcy5zdGF0ZS5jZWxsKSk7bnVsbCE9YyYmKGEueC09Yy5vcmlnaW4ueCxhLnktPWMub3JpZ2luLnkpO3JldHVybiBhfTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUubW92ZUxhYmVsPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLmdyYXBoLmdldE1vZGVsKCksZT1kLmdldEdlb21ldHJ5KGEuY2VsbCk7aWYobnVsbCE9ZSl7dmFyIGY9dGhpcy5ncmFwaC5nZXRWaWV3KCkuc2NhbGUsZT1lLmNsb25lKCk7aWYoZS5yZWxhdGl2ZSl7dmFyIGc9dGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0UmVsYXRpdmVQb2ludChhLGIsYyk7ZS54PU1hdGgucm91bmQoMUU0KmcueCkvMUU0O2UueT1NYXRoLnJvdW5kKGcueSk7ZS5vZmZzZXQ9bmV3IG14UG9pbnQoMCwwKTtnPXRoaXMuZ3JhcGgudmlldy5nZXRQb2ludChhLGUpO2Uub2Zmc2V0PW5ldyBteFBvaW50KE1hdGgucm91bmQoKGItZy54KS9mKSxNYXRoLnJvdW5kKChjLWcueSkvZikpfWVsc2V7dmFyIGs9YS5hYnNvbHV0ZVBvaW50cyxnPWtbMF0saz1rW2subGVuZ3RoLTFdO251bGwhPWcmJm51bGwhPWsmJihlLm9mZnNldD1uZXcgbXhQb2ludChNYXRoLnJvdW5kKChiLQooZy54KyhrLngtZy54KS8yKSkvZiksTWF0aC5yb3VuZCgoYy0oZy55KyhrLnktZy55KS8yKSkvZikpLGUueD0wLGUueT0wKX1kLnNldEdlb21ldHJ5KGEuY2VsbCxlKX19O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmNvbm5lY3Q9ZnVuY3Rpb24oYSxiLGMsZCxlKXtkPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKTtkLmdldFBhcmVudChhKTtkLmJlZ2luVXBkYXRlKCk7dHJ5e3ZhciBmPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudENvbnN0cmFpbnQ7bnVsbD09ZiYmKGY9bmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQpO3RoaXMuZ3JhcGguY29ubmVjdENlbGwoYSxiLGMsZil9ZmluYWxseXtkLmVuZFVwZGF0ZSgpfXJldHVybiBhfTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUuY2hhbmdlVGVybWluYWxQb2ludD1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLmdyYXBoLmdldE1vZGVsKCk7ZS5iZWdpblVwZGF0ZSgpO3RyeXtpZihkKXt2YXIgZj1lLmdldFBhcmVudChhKSxnPWUuZ2V0VGVybWluYWwoYSwhYyk7YT10aGlzLmdyYXBoLmNsb25lQ2VsbChhKTtlLmFkZChmLGEsZS5nZXRDaGlsZENvdW50KGYpKTtlLnNldFRlcm1pbmFsKGEsZywhYyl9dmFyIGs9ZS5nZXRHZW9tZXRyeShhKTtudWxsIT1rJiYoaz1rLmNsb25lKCksay5zZXRUZXJtaW5hbFBvaW50KGIsYyksZS5zZXRHZW9tZXRyeShhLGspLHRoaXMuZ3JhcGguY29ubmVjdENlbGwoYSxudWxsLGMsbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQpKX1maW5hbGx5e2UuZW5kVXBkYXRlKCl9cmV0dXJuIGF9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5jaGFuZ2VQb2ludHM9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKTtkLmJlZ2luVXBkYXRlKCk7dHJ5e2lmKGMpe3ZhciBlPWQuZ2V0UGFyZW50KGEpLGY9ZC5nZXRUZXJtaW5hbChhLCEwKSxnPWQuZ2V0VGVybWluYWwoYSwhMSk7YT10aGlzLmdyYXBoLmNsb25lQ2VsbChhKTtkLmFkZChlLGEsZC5nZXRDaGlsZENvdW50KGUpKTtkLnNldFRlcm1pbmFsKGEsZiwhMCk7ZC5zZXRUZXJtaW5hbChhLGcsITEpfXZhciBrPWQuZ2V0R2VvbWV0cnkoYSk7bnVsbCE9ayYmKGs9ay5jbG9uZSgpLGsucG9pbnRzPWIsZC5zZXRHZW9tZXRyeShhLGspKX1maW5hbGx5e2QuZW5kVXBkYXRlKCl9cmV0dXJuIGF9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5hZGRQb2ludD1mdW5jdGlvbihhLGIpe3ZhciBjPW14VXRpbHMuY29udmVydFBvaW50KHRoaXMuZ3JhcGguY29udGFpbmVyLG14RXZlbnQuZ2V0Q2xpZW50WChiKSxteEV2ZW50LmdldENsaWVudFkoYikpLGQ9dGhpcy5ncmFwaC5pc0dyaWRFbmFibGVkRXZlbnQoYik7dGhpcy5jb252ZXJ0UG9pbnQoYyxkKTt0aGlzLmFkZFBvaW50QXQoYSxjLngsYy55KTtteEV2ZW50LmNvbnN1bWUoYil9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5hZGRQb2ludEF0PWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShhLmNlbGwpO2I9bmV3IG14UG9pbnQoYixjKTtpZihudWxsIT1kKXt2YXIgZD1kLmNsb25lKCksZT10aGlzLmdyYXBoLnZpZXcudHJhbnNsYXRlO2M9dGhpcy5ncmFwaC52aWV3LnNjYWxlO3ZhciBlPW5ldyBteFBvaW50KGUueCpjLGUueSpjKSxmPXRoaXMuZ3JhcGgubW9kZWwuZ2V0UGFyZW50KHRoaXMuc3RhdGUuY2VsbCk7dGhpcy5ncmFwaC5tb2RlbC5pc1ZlcnRleChmKSYmKGU9dGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKGYpLGU9bmV3IG14UG9pbnQoZS54LGUueSkpO2M9bXhVdGlscy5maW5kTmVhcmVzdFNlZ21lbnQoYSxiLngqYytlLngsYi55KmMrZS55KTtudWxsPT1kLnBvaW50cz9kLnBvaW50cz1bYl06ZC5wb2ludHMuc3BsaWNlKGMsMCxiKTt0aGlzLmdyYXBoLmdldE1vZGVsKCkuc2V0R2VvbWV0cnkoYS5jZWxsLGQpO3RoaXMucmVmcmVzaCgpOwp0aGlzLnJlZHJhdygpfX07bXhFZGdlSGFuZGxlci5wcm90b3R5cGUucmVtb3ZlUG9pbnQ9ZnVuY3Rpb24oYSxiKXtpZigwPGImJmI8dGhpcy5hYnNwb2ludHMubGVuZ3RoLTEpe3ZhciBjPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KHRoaXMuc3RhdGUuY2VsbCk7bnVsbCE9YyYmbnVsbCE9Yy5wb2ludHMmJihjPWMuY2xvbmUoKSxjLnBvaW50cy5zcGxpY2UoYi0xLDEpLHRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5zZXRHZW9tZXRyeShhLmNlbGwsYyksdGhpcy5yZWZyZXNoKCksdGhpcy5yZWRyYXcoKSl9fTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUuZ2V0SGFuZGxlRmlsbENvbG9yPWZ1bmN0aW9uKGEpe2E9MD09YTt2YXIgYj10aGlzLnN0YXRlLmNlbGwsYz10aGlzLmdyYXBoLmdldE1vZGVsKCkuZ2V0VGVybWluYWwoYixhKSxkPW14Q29uc3RhbnRzLkhBTkRMRV9GSUxMQ09MT1I7bnVsbCE9YyYmIXRoaXMuZ3JhcGguaXNDZWxsRGlzY29ubmVjdGFibGUoYixjLGEpfHxudWxsPT1jJiYhdGhpcy5ncmFwaC5pc1Rlcm1pbmFsUG9pbnRNb3ZhYmxlKGIsYSk/ZD1teENvbnN0YW50cy5MT0NLRURfSEFORExFX0ZJTExDT0xPUjpudWxsIT1jJiZ0aGlzLmdyYXBoLmlzQ2VsbERpc2Nvbm5lY3RhYmxlKGIsYyxhKSYmKGQ9bXhDb25zdGFudHMuQ09OTkVDVF9IQU5ETEVfRklMTENPTE9SKTtyZXR1cm4gZH07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLnJlZHJhdz1mdW5jdGlvbihhKXt0aGlzLmFic3BvaW50cz10aGlzLnN0YXRlLmFic29sdXRlUG9pbnRzLnNsaWNlKCk7dmFyIGI9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldEdlb21ldHJ5KHRoaXMuc3RhdGUuY2VsbCk7aWYobnVsbCE9YiYmKGI9Yi5wb2ludHMsbnVsbCE9dGhpcy5iZW5kcyYmMDx0aGlzLmJlbmRzLmxlbmd0aCYmbnVsbCE9Yikpe251bGw9PXRoaXMucG9pbnRzJiYodGhpcy5wb2ludHM9W10pO2Zvcih2YXIgYz0xO2M8dGhpcy5iZW5kcy5sZW5ndGgtMTtjKyspbnVsbCE9dGhpcy5iZW5kc1tjXSYmbnVsbCE9dGhpcy5hYnNwb2ludHNbY10mJih0aGlzLnBvaW50c1tjLTFdPWJbYy0xXSl9dGhpcy5kcmF3UHJldmlldygpO2F8fHRoaXMucmVkcmF3SGFuZGxlcygpfTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUucmVkcmF3SGFuZGxlcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuc3RhdGUuY2VsbCxiPXRoaXMubGFiZWxTaGFwZS5ib3VuZHM7dGhpcy5sYWJlbD1uZXcgbXhQb2ludCh0aGlzLnN0YXRlLmFic29sdXRlT2Zmc2V0LngsdGhpcy5zdGF0ZS5hYnNvbHV0ZU9mZnNldC55KTt0aGlzLmxhYmVsU2hhcGUuYm91bmRzPW5ldyBteFJlY3RhbmdsZShNYXRoLnJvdW5kKHRoaXMubGFiZWwueC1iLndpZHRoLzIpLE1hdGgucm91bmQodGhpcy5sYWJlbC55LWIuaGVpZ2h0LzIpLGIud2lkdGgsYi5oZWlnaHQpO2I9dGhpcy5ncmFwaC5nZXRMYWJlbChhKTt0aGlzLmxhYmVsU2hhcGUudmlzaWJsZT1udWxsIT1iJiYwPGIubGVuZ3RoJiZ0aGlzLmdyYXBoLmlzTGFiZWxNb3ZhYmxlKGEpO2lmKG51bGwhPXRoaXMuYmVuZHMmJjA8dGhpcy5iZW5kcy5sZW5ndGgpe3ZhciBjPXRoaXMuYWJzcG9pbnRzLmxlbmd0aC0xLGE9dGhpcy5hYnNwb2ludHNbMF0sZD1hLngsCmU9YS55LGI9dGhpcy5iZW5kc1swXS5ib3VuZHM7dGhpcy5iZW5kc1swXS5ib3VuZHM9bmV3IG14UmVjdGFuZ2xlKE1hdGguZmxvb3IoZC1iLndpZHRoLzIpLE1hdGguZmxvb3IoZS1iLmhlaWdodC8yKSxiLndpZHRoLGIuaGVpZ2h0KTt0aGlzLmJlbmRzWzBdLmZpbGw9dGhpcy5nZXRIYW5kbGVGaWxsQ29sb3IoMCk7dGhpcy5iZW5kc1swXS5yZWRyYXcoKTt0aGlzLm1hbmFnZUxhYmVsSGFuZGxlJiZ0aGlzLmNoZWNrTGFiZWxIYW5kbGUodGhpcy5iZW5kc1swXS5ib3VuZHMpO3ZhciBjPXRoaXMuYWJzcG9pbnRzW2NdLGQ9Yy54LGU9Yy55LGY9dGhpcy5iZW5kcy5sZW5ndGgtMSxiPXRoaXMuYmVuZHNbZl0uYm91bmRzO3RoaXMuYmVuZHNbZl0uYm91bmRzPW5ldyBteFJlY3RhbmdsZShNYXRoLmZsb29yKGQtYi53aWR0aC8yKSxNYXRoLmZsb29yKGUtYi5oZWlnaHQvMiksYi53aWR0aCxiLmhlaWdodCk7dGhpcy5iZW5kc1tmXS5maWxsPXRoaXMuZ2V0SGFuZGxlRmlsbENvbG9yKGYpOwp0aGlzLmJlbmRzW2ZdLnJlZHJhdygpO3RoaXMubWFuYWdlTGFiZWxIYW5kbGUmJnRoaXMuY2hlY2tMYWJlbEhhbmRsZSh0aGlzLmJlbmRzW2ZdLmJvdW5kcyk7dGhpcy5yZWRyYXdJbm5lckJlbmRzKGEsYyl9aWYobnVsbCE9dGhpcy5hYnNwb2ludHMmJm51bGwhPXRoaXMudmlydHVhbEJlbmRzJiYwPHRoaXMudmlydHVhbEJlbmRzLmxlbmd0aClmb3IoYz10aGlzLmFic3BvaW50c1swXSxhPTA7YTx0aGlzLnZpcnR1YWxCZW5kcy5sZW5ndGg7YSsrKW51bGwhPXRoaXMudmlydHVhbEJlbmRzW2FdJiZudWxsIT10aGlzLmFic3BvaW50c1thKzFdJiYoZD10aGlzLmFic3BvaW50c1thKzFdLGI9dGhpcy52aXJ0dWFsQmVuZHNbYV0sYi5ib3VuZHM9bmV3IG14UmVjdGFuZ2xlKE1hdGguZmxvb3IoYy54KyhkLngtYy54KS8yLWIuYm91bmRzLndpZHRoLzIpLE1hdGguZmxvb3IoYy55KyhkLnktYy55KS8yLWIuYm91bmRzLmhlaWdodC8yKSxiLmJvdW5kcy53aWR0aCxiLmJvdW5kcy5oZWlnaHQpLApiLnJlZHJhdygpLG14VXRpbHMuc2V0T3BhY2l0eShiLm5vZGUsdGhpcy52aXJ0dWFsQmVuZE9wYWNpdHkpLGM9ZCx0aGlzLm1hbmFnZUxhYmVsSGFuZGxlJiZ0aGlzLmNoZWNrTGFiZWxIYW5kbGUoYi5ib3VuZHMpKTtudWxsIT10aGlzLmxhYmVsU2hhcGUmJnRoaXMubGFiZWxTaGFwZS5yZWRyYXcoKTtpZihudWxsIT10aGlzLmN1c3RvbUhhbmRsZXMpZm9yKGE9MDthPHRoaXMuY3VzdG9tSGFuZGxlcy5sZW5ndGg7YSsrKWI9dGhpcy5jdXN0b21IYW5kbGVzW2FdLnNoYXBlLm5vZGUuc3R5bGUuZGlzcGxheSx0aGlzLmN1c3RvbUhhbmRsZXNbYV0ucmVkcmF3KCksdGhpcy5jdXN0b21IYW5kbGVzW2FdLnNoYXBlLm5vZGUuc3R5bGUuZGlzcGxheT1iLHRoaXMuY3VzdG9tSGFuZGxlc1thXS5zaGFwZS5ub2RlLnN0eWxlLnZpc2liaWxpdHk9dGhpcy5pc0N1c3RvbUhhbmRsZVZpc2libGUodGhpcy5jdXN0b21IYW5kbGVzW2FdKT8iIjoiaGlkZGVuIn07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLmlzQ3VzdG9tSGFuZGxlVmlzaWJsZT1mdW5jdGlvbihhKXtyZXR1cm4hdGhpcy5ncmFwaC5pc0VkaXRpbmcoKSYmMT09dGhpcy5zdGF0ZS52aWV3LmdyYXBoLmdldFNlbGVjdGlvbkNvdW50KCl9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5zZXRIYW5kbGVzVmlzaWJsZT1mdW5jdGlvbihhKXtpZihudWxsIT10aGlzLmJlbmRzKWZvcih2YXIgYj0wO2I8dGhpcy5iZW5kcy5sZW5ndGg7YisrKXRoaXMuYmVuZHNbYl0ubm9kZS5zdHlsZS5kaXNwbGF5PWE/IiI6Im5vbmUiO2lmKG51bGwhPXRoaXMudmlydHVhbEJlbmRzKWZvcihiPTA7Yjx0aGlzLnZpcnR1YWxCZW5kcy5sZW5ndGg7YisrKXRoaXMudmlydHVhbEJlbmRzW2JdLm5vZGUuc3R5bGUuZGlzcGxheT1hPyIiOiJub25lIjtudWxsIT10aGlzLmxhYmVsU2hhcGUmJih0aGlzLmxhYmVsU2hhcGUubm9kZS5zdHlsZS5kaXNwbGF5PWE/IiI6Im5vbmUiKTtpZihudWxsIT10aGlzLmN1c3RvbUhhbmRsZXMpZm9yKGI9MDtiPHRoaXMuY3VzdG9tSGFuZGxlcy5sZW5ndGg7YisrKXRoaXMuY3VzdG9tSGFuZGxlc1tiXS5zZXRWaXNpYmxlKGEpfTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUucmVkcmF3SW5uZXJCZW5kcz1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0xO2M8dGhpcy5iZW5kcy5sZW5ndGgtMTtjKyspaWYobnVsbCE9dGhpcy5iZW5kc1tjXSlpZihudWxsIT10aGlzLmFic3BvaW50c1tjXSl7dmFyIGQ9dGhpcy5hYnNwb2ludHNbY10ueCxlPXRoaXMuYWJzcG9pbnRzW2NdLnksZj10aGlzLmJlbmRzW2NdLmJvdW5kczt0aGlzLmJlbmRzW2NdLm5vZGUuc3R5bGUudmlzaWJpbGl0eT0idmlzaWJsZSI7dGhpcy5iZW5kc1tjXS5ib3VuZHM9bmV3IG14UmVjdGFuZ2xlKE1hdGgucm91bmQoZC1mLndpZHRoLzIpLE1hdGgucm91bmQoZS1mLmhlaWdodC8yKSxmLndpZHRoLGYuaGVpZ2h0KTt0aGlzLm1hbmFnZUxhYmVsSGFuZGxlP3RoaXMuY2hlY2tMYWJlbEhhbmRsZSh0aGlzLmJlbmRzW2NdLmJvdW5kcyk6bnVsbD09dGhpcy5oYW5kbGVJbWFnZSYmdGhpcy5sYWJlbFNoYXBlLnZpc2libGUmJm14VXRpbHMuaW50ZXJzZWN0cyh0aGlzLmJlbmRzW2NdLmJvdW5kcywKdGhpcy5sYWJlbFNoYXBlLmJvdW5kcykmJih3PW14Q29uc3RhbnRzLkhBTkRMRV9TSVpFKzMsaD1teENvbnN0YW50cy5IQU5ETEVfU0laRSszLHRoaXMuYmVuZHNbY10uYm91bmRzPW5ldyBteFJlY3RhbmdsZShNYXRoLnJvdW5kKGQtdy8yKSxNYXRoLnJvdW5kKGUtaC8yKSx3LGgpKTt0aGlzLmJlbmRzW2NdLnJlZHJhdygpfWVsc2UgdGhpcy5iZW5kc1tjXS5kZXN0cm95KCksdGhpcy5iZW5kc1tjXT1udWxsfTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5jaGVja0xhYmVsSGFuZGxlPWZ1bmN0aW9uKGEpe2lmKG51bGwhPXRoaXMubGFiZWxTaGFwZSl7dmFyIGI9dGhpcy5sYWJlbFNoYXBlLmJvdW5kcztteFV0aWxzLmludGVyc2VjdHMoYSxiKSYmKGEuZ2V0Q2VudGVyWSgpPGIuZ2V0Q2VudGVyWSgpP2IueT1hLnkrYS5oZWlnaHQ6Yi55PWEueS1iLmhlaWdodCl9fTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUuZHJhd1ByZXZpZXc9ZnVuY3Rpb24oKXtpZih0aGlzLmlzTGFiZWwpe3ZhciBhPXRoaXMubGFiZWxTaGFwZS5ib3VuZHMsYT1uZXcgbXhSZWN0YW5nbGUoTWF0aC5yb3VuZCh0aGlzLmxhYmVsLngtYS53aWR0aC8yKSxNYXRoLnJvdW5kKHRoaXMubGFiZWwueS1hLmhlaWdodC8yKSxhLndpZHRoLGEuaGVpZ2h0KTt0aGlzLmxhYmVsU2hhcGUuYm91bmRzLmVxdWFscyhhKXx8KHRoaXMubGFiZWxTaGFwZS5ib3VuZHM9YSx0aGlzLmxhYmVsU2hhcGUucmVkcmF3KCkpfW51bGw9PXRoaXMuc2hhcGV8fG14VXRpbHMuZXF1YWxQb2ludHModGhpcy5zaGFwZS5wb2ludHMsdGhpcy5hYnNwb2ludHMpfHwodGhpcy5zaGFwZS5hcHBseSh0aGlzLnN0YXRlKSx0aGlzLnNoYXBlLnBvaW50cz10aGlzLmFic3BvaW50cy5zbGljZSgpLHRoaXMuc2hhcGUuc2NhbGU9dGhpcy5zdGF0ZS52aWV3LnNjYWxlLHRoaXMuc2hhcGUuaXNEYXNoZWQ9dGhpcy5pc1NlbGVjdGlvbkRhc2hlZCgpLAp0aGlzLnNoYXBlLnN0cm9rZT10aGlzLmdldFNlbGVjdGlvbkNvbG9yKCksdGhpcy5zaGFwZS5zdHJva2V3aWR0aD10aGlzLmdldFNlbGVjdGlvblN0cm9rZVdpZHRoKCkvdGhpcy5zaGFwZS5zY2FsZS90aGlzLnNoYXBlLnNjYWxlLHRoaXMuc2hhcGUuaXNTaGFkb3c9ITEsdGhpcy5zaGFwZS5yZWRyYXcoKSk7bnVsbCE9dGhpcy5wYXJlbnRIaWdobGlnaHQmJnRoaXMucGFyZW50SGlnaGxpZ2h0LnJlZHJhdygpfTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUucmVmcmVzaD1mdW5jdGlvbigpe3RoaXMuYWJzcG9pbnRzPXRoaXMuZ2V0U2VsZWN0aW9uUG9pbnRzKHRoaXMuc3RhdGUpO3RoaXMucG9pbnRzPVtdO251bGwhPXRoaXMuYmVuZHMmJih0aGlzLmRlc3Ryb3lCZW5kcyh0aGlzLmJlbmRzKSx0aGlzLmJlbmRzPXRoaXMuY3JlYXRlQmVuZHMoKSk7bnVsbCE9dGhpcy52aXJ0dWFsQmVuZHMmJih0aGlzLmRlc3Ryb3lCZW5kcyh0aGlzLnZpcnR1YWxCZW5kcyksdGhpcy52aXJ0dWFsQmVuZHM9dGhpcy5jcmVhdGVWaXJ0dWFsQmVuZHMoKSk7bnVsbCE9dGhpcy5jdXN0b21IYW5kbGVzJiYodGhpcy5kZXN0cm95QmVuZHModGhpcy5jdXN0b21IYW5kbGVzKSx0aGlzLmN1c3RvbUhhbmRsZXM9dGhpcy5jcmVhdGVDdXN0b21IYW5kbGVzKCkpO251bGwhPXRoaXMubGFiZWxTaGFwZSYmbnVsbCE9dGhpcy5sYWJlbFNoYXBlLm5vZGUmJm51bGwhPXRoaXMubGFiZWxTaGFwZS5ub2RlLnBhcmVudE5vZGUmJnRoaXMubGFiZWxTaGFwZS5ub2RlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5sYWJlbFNoYXBlLm5vZGUpfTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUuZGVzdHJveUJlbmRzPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpZm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspbnVsbCE9YVtiXSYmYVtiXS5kZXN0cm95KCl9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5lc2NhcGVIYW5kbGVyJiYodGhpcy5zdGF0ZS52aWV3LmdyYXBoLnJlbW92ZUxpc3RlbmVyKHRoaXMuZXNjYXBlSGFuZGxlciksdGhpcy5lc2NhcGVIYW5kbGVyPW51bGwpO251bGwhPXRoaXMubWFya2VyJiYodGhpcy5tYXJrZXIuZGVzdHJveSgpLHRoaXMubWFya2VyPW51bGwpO251bGwhPXRoaXMuc2hhcGUmJih0aGlzLnNoYXBlLmRlc3Ryb3koKSx0aGlzLnNoYXBlPW51bGwpO251bGwhPXRoaXMucGFyZW50SGlnaGxpZ2h0JiYodGhpcy5wYXJlbnRIaWdobGlnaHQuZGVzdHJveSgpLHRoaXMucGFyZW50SGlnaGxpZ2h0PW51bGwpO251bGwhPXRoaXMubGFiZWxTaGFwZSYmKHRoaXMubGFiZWxTaGFwZS5kZXN0cm95KCksdGhpcy5sYWJlbFNoYXBlPW51bGwpO251bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXImJih0aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmRlc3Ryb3koKSx0aGlzLmNvbnN0cmFpbnRIYW5kbGVyPQpudWxsKTt0aGlzLmRlc3Ryb3lCZW5kcyh0aGlzLnZpcnR1YWxCZW5kcyk7dGhpcy52aXJ0dWFsQmVuZHM9bnVsbDt0aGlzLmRlc3Ryb3lCZW5kcyh0aGlzLmN1c3RvbUhhbmRsZXMpO3RoaXMuY3VzdG9tSGFuZGxlcz1udWxsO3RoaXMuZGVzdHJveUJlbmRzKHRoaXMuYmVuZHMpO3RoaXMuYmVuZHM9bnVsbDt0aGlzLnJlbW92ZUhpbnQoKX07ZnVuY3Rpb24gbXhFbGJvd0VkZ2VIYW5kbGVyKGEpe214RWRnZUhhbmRsZXIuY2FsbCh0aGlzLGEpfW14VXRpbHMuZXh0ZW5kKG14RWxib3dFZGdlSGFuZGxlcixteEVkZ2VIYW5kbGVyKTtteEVsYm93RWRnZUhhbmRsZXIucHJvdG90eXBlLmZsaXBFbmFibGVkPSEwO214RWxib3dFZGdlSGFuZGxlci5wcm90b3R5cGUuZG91YmxlQ2xpY2tPcmllbnRhdGlvblJlc291cmNlPSJub25lIiE9bXhDbGllbnQubGFuZ3VhZ2U/ImRvdWJsZUNsaWNrT3JpZW50YXRpb24iOiIiOwpteEVsYm93RWRnZUhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUJlbmRzPWZ1bmN0aW9uKCl7dmFyIGE9W10sYj10aGlzLmNyZWF0ZUhhbmRsZVNoYXBlKDApO3RoaXMuaW5pdEJlbmQoYik7Yi5zZXRDdXJzb3IobXhDb25zdGFudHMuQ1VSU09SX1RFUk1JTkFMX0hBTkRMRSk7YS5wdXNoKGIpO2EucHVzaCh0aGlzLmNyZWF0ZVZpcnR1YWxCZW5kKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpeyFteEV2ZW50LmlzQ29uc3VtZWQoYSkmJnRoaXMuZmxpcEVuYWJsZWQmJih0aGlzLmdyYXBoLmZsaXBFZGdlKHRoaXMuc3RhdGUuY2VsbCxhKSxteEV2ZW50LmNvbnN1bWUoYSkpfSkpKTt0aGlzLnBvaW50cy5wdXNoKG5ldyBteFBvaW50KDAsMCkpO2I9dGhpcy5jcmVhdGVIYW5kbGVTaGFwZSgyKTt0aGlzLmluaXRCZW5kKGIpO2Iuc2V0Q3Vyc29yKG14Q29uc3RhbnRzLkNVUlNPUl9URVJNSU5BTF9IQU5ETEUpO2EucHVzaChiKTtyZXR1cm4gYX07Cm14RWxib3dFZGdlSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlVmlydHVhbEJlbmQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jcmVhdGVIYW5kbGVTaGFwZSgpO3RoaXMuaW5pdEJlbmQoYixhKTtiLnNldEN1cnNvcih0aGlzLmdldEN1cnNvckZvckJlbmQoKSk7dGhpcy5ncmFwaC5pc0NlbGxCZW5kYWJsZSh0aGlzLnN0YXRlLmNlbGwpfHwoYi5ub2RlLnN0eWxlLmRpc3BsYXk9Im5vbmUiKTtyZXR1cm4gYn07Cm14RWxib3dFZGdlSGFuZGxlci5wcm90b3R5cGUuZ2V0Q3Vyc29yRm9yQmVuZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VER0VdPT1teEVkZ2VTdHlsZS5Ub3BUb0JvdHRvbXx8dGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FREdFXT09bXhDb25zdGFudHMuRURHRVNUWUxFX1RPUFRPQk9UVE9NfHwodGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FREdFXT09bXhFZGdlU3R5bGUuRWxib3dDb25uZWN0b3J8fHRoaXMuc3RhdGUuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRURHRV09PW14Q29uc3RhbnRzLkVER0VTVFlMRV9FTEJPVykmJnRoaXMuc3RhdGUuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRUxCT1ddPT1teENvbnN0YW50cy5FTEJPV19WRVJUSUNBTD8icm93LXJlc2l6ZSI6ImNvbC1yZXNpemUifTsKbXhFbGJvd0VkZ2VIYW5kbGVyLnByb3RvdHlwZS5nZXRUb29sdGlwRm9yTm9kZT1mdW5jdGlvbihhKXt2YXIgYj1udWxsO251bGw9PXRoaXMuYmVuZHN8fG51bGw9PXRoaXMuYmVuZHNbMV18fGEhPXRoaXMuYmVuZHNbMV0ubm9kZSYmYS5wYXJlbnROb2RlIT10aGlzLmJlbmRzWzFdLm5vZGV8fChiPXRoaXMuZG91YmxlQ2xpY2tPcmllbnRhdGlvblJlc291cmNlLGI9bXhSZXNvdXJjZXMuZ2V0KGIpfHxiKTtyZXR1cm4gYn07Cm14RWxib3dFZGdlSGFuZGxlci5wcm90b3R5cGUuY29udmVydFBvaW50PWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0U2NhbGUoKSxkPXRoaXMuZ3JhcGguZ2V0VmlldygpLmdldFRyYW5zbGF0ZSgpLGU9dGhpcy5zdGF0ZS5vcmlnaW47YiYmKGEueD10aGlzLmdyYXBoLnNuYXAoYS54KSxhLnk9dGhpcy5ncmFwaC5zbmFwKGEueSkpO2EueD1NYXRoLnJvdW5kKGEueC9jLWQueC1lLngpO2EueT1NYXRoLnJvdW5kKGEueS9jLWQueS1lLnkpO3JldHVybiBhfTsKbXhFbGJvd0VkZ2VIYW5kbGVyLnByb3RvdHlwZS5yZWRyYXdJbm5lckJlbmRzPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldEdlb21ldHJ5KHRoaXMuc3RhdGUuY2VsbCksZD10aGlzLnN0YXRlLmFic29sdXRlUG9pbnRzLGU9bnVsbDsxPGQubGVuZ3RoPyhhPWRbMV0sYj1kW2QubGVuZ3RoLTJdKTpudWxsIT1jLnBvaW50cyYmMDxjLnBvaW50cy5sZW5ndGgmJihlPWRbMF0pO2U9bnVsbD09ZT9uZXcgbXhQb2ludChhLngrKGIueC1hLngpLzIsYS55KyhiLnktYS55KS8yKTpuZXcgbXhQb2ludCh0aGlzLmdyYXBoLmdldFZpZXcoKS5zY2FsZSooZS54K3RoaXMuZ3JhcGguZ2V0VmlldygpLnRyYW5zbGF0ZS54K3RoaXMuc3RhdGUub3JpZ2luLngpLHRoaXMuZ3JhcGguZ2V0VmlldygpLnNjYWxlKihlLnkrdGhpcy5ncmFwaC5nZXRWaWV3KCkudHJhbnNsYXRlLnkrdGhpcy5zdGF0ZS5vcmlnaW4ueSkpO2Q9dGhpcy5iZW5kc1sxXS5ib3VuZHM7Yz1kLndpZHRoOwpkPWQuaGVpZ2h0O2M9bmV3IG14UmVjdGFuZ2xlKE1hdGgucm91bmQoZS54LWMvMiksTWF0aC5yb3VuZChlLnktZC8yKSxjLGQpO3RoaXMubWFuYWdlTGFiZWxIYW5kbGU/dGhpcy5jaGVja0xhYmVsSGFuZGxlKGMpOm51bGw9PXRoaXMuaGFuZGxlSW1hZ2UmJnRoaXMubGFiZWxTaGFwZS52aXNpYmxlJiZteFV0aWxzLmludGVyc2VjdHMoYyx0aGlzLmxhYmVsU2hhcGUuYm91bmRzKSYmKGM9bXhDb25zdGFudHMuSEFORExFX1NJWkUrMyxkPW14Q29uc3RhbnRzLkhBTkRMRV9TSVpFKzMsYz1uZXcgbXhSZWN0YW5nbGUoTWF0aC5mbG9vcihlLngtYy8yKSxNYXRoLmZsb29yKGUueS1kLzIpLGMsZCkpO3RoaXMuYmVuZHNbMV0uYm91bmRzPWM7dGhpcy5iZW5kc1sxXS5yZWRyYXcoKTt0aGlzLm1hbmFnZUxhYmVsSGFuZGxlJiZ0aGlzLmNoZWNrTGFiZWxIYW5kbGUodGhpcy5iZW5kc1sxXS5ib3VuZHMpfTsKZnVuY3Rpb24gbXhFZGdlU2VnbWVudEhhbmRsZXIoYSl7bXhFZGdlSGFuZGxlci5jYWxsKHRoaXMsYSl9bXhVdGlscy5leHRlbmQobXhFZGdlU2VnbWVudEhhbmRsZXIsbXhFbGJvd0VkZ2VIYW5kbGVyKTsKbXhFZGdlU2VnbWVudEhhbmRsZXIucHJvdG90eXBlLmdldEN1cnJlbnRQb2ludHM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnN0YXRlLmFic29sdXRlUG9pbnRzO2lmKG51bGwhPWEpe3ZhciBiPU1hdGgubWF4KDEsdGhpcy5ncmFwaC52aWV3LnNjYWxlKTtpZigyPT1hLmxlbmd0aHx8Mz09YS5sZW5ndGgmJihNYXRoLmFicyhhWzBdLngtYVsxXS54KTxiJiZNYXRoLmFicyhhWzFdLngtYVsyXS54KTxifHxNYXRoLmFicyhhWzBdLnktYVsxXS55KTxiJiZNYXRoLmFicyhhWzFdLnktYVsyXS55KTxiKSl2YXIgYj1hWzBdLngrKGFbYS5sZW5ndGgtMV0ueC1hWzBdLngpLzIsYz1hWzBdLnkrKGFbYS5sZW5ndGgtMV0ueS1hWzBdLnkpLzIsYT1bYVswXSxuZXcgbXhQb2ludChiLGMpLG5ldyBteFBvaW50KGIsYyksYVthLmxlbmd0aC0xXV19cmV0dXJuIGF9OwpteEVkZ2VTZWdtZW50SGFuZGxlci5wcm90b3R5cGUuZ2V0UHJldmlld1BvaW50cz1mdW5jdGlvbihhKXtpZih0aGlzLmlzU291cmNlfHx0aGlzLmlzVGFyZ2V0KXJldHVybiBteEVsYm93RWRnZUhhbmRsZXIucHJvdG90eXBlLmdldFByZXZpZXdQb2ludHMuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciBiPXRoaXMuZ2V0Q3VycmVudFBvaW50cygpLGM9dGhpcy5jb252ZXJ0UG9pbnQoYlswXS5jbG9uZSgpLCExKTthPXRoaXMuY29udmVydFBvaW50KGEuY2xvbmUoKSwhMSk7Zm9yKHZhciBkPVtdLGU9MTtlPGIubGVuZ3RoO2UrKyl7dmFyIGY9dGhpcy5jb252ZXJ0UG9pbnQoYltlXS5jbG9uZSgpLCExKTtlPT10aGlzLmluZGV4JiYoMD09TWF0aC5yb3VuZChjLngtZi54KSYmKGMueD1hLngsZi54PWEueCksMD09TWF0aC5yb3VuZChjLnktZi55KSYmKGMueT1hLnksZi55PWEueSkpO2U8Yi5sZW5ndGgtMSYmZC5wdXNoKGYpO2M9Zn1pZigxPT1kLmxlbmd0aCl7dmFyIGI9dGhpcy5zdGF0ZS5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZSghMCksCmM9dGhpcy5zdGF0ZS5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZSghMSksZj10aGlzLnN0YXRlLnZpZXcuZ2V0U2NhbGUoKSxnPXRoaXMuc3RhdGUudmlldy5nZXRUcmFuc2xhdGUoKSxlPWRbMF0ueCpmK2cueCxmPWRbMF0ueSpmK2cueTtpZihudWxsIT1iJiZteFV0aWxzLmNvbnRhaW5zKGIsZSxmKXx8bnVsbCE9YyYmbXhVdGlscy5jb250YWlucyhjLGUsZikpZD1bYSxhXX1yZXR1cm4gZH07Cm14RWRnZVNlZ21lbnRIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVQcmV2aWV3U3RhdGU9ZnVuY3Rpb24oYSxiLGMsZCl7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUudXBkYXRlUHJldmlld1N0YXRlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZighdGhpcy5pc1NvdXJjZSYmIXRoaXMuaXNUYXJnZXQpe2I9dGhpcy5jb252ZXJ0UG9pbnQoYi5jbG9uZSgpLCExKTtmb3IodmFyIGU9YS5hYnNvbHV0ZVBvaW50cyxmPWVbMF0sZz1lWzFdLGs9W10sbD0yO2w8ZS5sZW5ndGg7bCsrKXt2YXIgbT1lW2xdOzA9PU1hdGgucm91bmQoZi54LWcueCkmJjA9PU1hdGgucm91bmQoZy54LW0ueCl8fDA9PU1hdGgucm91bmQoZi55LWcueSkmJjA9PU1hdGgucm91bmQoZy55LW0ueSl8fGsucHVzaCh0aGlzLmNvbnZlcnRQb2ludChnLmNsb25lKCksITEpKTtmPWc7Zz1tfWY9dGhpcy5zdGF0ZS5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZSghMCk7Zz10aGlzLnN0YXRlLmdldFZpc2libGVUZXJtaW5hbFN0YXRlKCExKTsKbD10aGlzLnN0YXRlLmFic29sdXRlUG9pbnRzO2lmKDA9PWsubGVuZ3RoJiYoMD09TWF0aC5yb3VuZChlWzBdLngtZVtlLmxlbmd0aC0xXS54KXx8MD09TWF0aC5yb3VuZChlWzBdLnktZVtlLmxlbmd0aC0xXS55KSkpaz1bYixiXTtlbHNlIGlmKDU9PWUubGVuZ3RoJiYyPT1rLmxlbmd0aCYmbnVsbCE9ZiYmbnVsbCE9ZyYmbnVsbCE9bCYmMD09TWF0aC5yb3VuZChsWzBdLngtbFtsLmxlbmd0aC0xXS54KSl7dmFyIGs9dGhpcy5ncmFwaC5nZXRWaWV3KCksbD1rLmdldFNjYWxlKCksbT1rLmdldFRyYW5zbGF0ZSgpLGU9ay5nZXRSb3V0aW5nQ2VudGVyWShmKS9sLW0ueSxuPXRoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvbkNvbnN0cmFpbnQoYSxmLCEwKTtudWxsIT1uJiYobj10aGlzLmdyYXBoLmdldENvbm5lY3Rpb25Qb2ludChmLG4pLG51bGwhPW4mJih0aGlzLmNvbnZlcnRQb2ludChuLCExKSxlPW4ueSkpO2s9ay5nZXRSb3V0aW5nQ2VudGVyWShnKS9sLW0ueTtpZihsPXRoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvbkNvbnN0cmFpbnQoYSwKZywhMSkpbj10aGlzLmdyYXBoLmdldENvbm5lY3Rpb25Qb2ludChnLGwpLG51bGwhPW4mJih0aGlzLmNvbnZlcnRQb2ludChuLCExKSxrPW4ueSk7az1bbmV3IG14UG9pbnQoYi54LGUpLG5ldyBteFBvaW50KGIueCxrKV19dGhpcy5wb2ludHM9azthLnZpZXcudXBkYXRlRml4ZWRUZXJtaW5hbFBvaW50cyhhLGYsZyk7YS52aWV3LnVwZGF0ZVBvaW50cyhhLHRoaXMucG9pbnRzLGYsZyk7YS52aWV3LnVwZGF0ZUZsb2F0aW5nVGVybWluYWxQb2ludHMoYSxmLGcpfX07Cm14RWRnZVNlZ21lbnRIYW5kbGVyLnByb3RvdHlwZS5jb25uZWN0PWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGc9Zi5nZXRHZW9tZXRyeShhKSxrPW51bGw7aWYobnVsbCE9ZyYmbnVsbCE9Zy5wb2ludHMmJjA8Zy5wb2ludHMubGVuZ3RoKWZvcih2YXIgbD10aGlzLmFic3BvaW50cyxtPWxbMF0sbj1sWzFdLGs9W10scD0yO3A8bC5sZW5ndGg7cCsrKXt2YXIgcT1sW3BdOzA9PU1hdGgucm91bmQobS54LW4ueCkmJjA9PU1hdGgucm91bmQobi54LXEueCl8fDA9PU1hdGgucm91bmQobS55LW4ueSkmJjA9PU1hdGgucm91bmQobi55LXEueSl8fGsucHVzaCh0aGlzLmNvbnZlcnRQb2ludChuLmNsb25lKCksITEpKTttPW47bj1xfWYuYmVnaW5VcGRhdGUoKTt0cnl7bnVsbCE9ayYmKGc9Zi5nZXRHZW9tZXRyeShhKSxudWxsIT1nJiYoZz1nLmNsb25lKCksZy5wb2ludHM9ayxmLnNldEdlb21ldHJ5KGEsZykpKSxhPW14RWRnZUhhbmRsZXIucHJvdG90eXBlLmNvbm5lY3QuYXBwbHkodGhpcywKYXJndW1lbnRzKX1maW5hbGx5e2YuZW5kVXBkYXRlKCl9cmV0dXJuIGF9O214RWRnZVNlZ21lbnRIYW5kbGVyLnByb3RvdHlwZS5nZXRUb29sdGlwRm9yTm9kZT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbH07bXhFZGdlU2VnbWVudEhhbmRsZXIucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKGEsYixjKXtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5zdGFydC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbD09dGhpcy5iZW5kc3x8bnVsbD09dGhpcy5iZW5kc1tjXXx8dGhpcy5pc1NvdXJjZXx8dGhpcy5pc1RhcmdldHx8bXhVdGlscy5zZXRPcGFjaXR5KHRoaXMuYmVuZHNbY10ubm9kZSwxMDApfTsKbXhFZGdlU2VnbWVudEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUJlbmRzPWZ1bmN0aW9uKCl7dmFyIGE9W10sYj10aGlzLmNyZWF0ZUhhbmRsZVNoYXBlKDApO3RoaXMuaW5pdEJlbmQoYik7Yi5zZXRDdXJzb3IobXhDb25zdGFudHMuQ1VSU09SX1RFUk1JTkFMX0hBTkRMRSk7YS5wdXNoKGIpO3ZhciBjPXRoaXMuZ2V0Q3VycmVudFBvaW50cygpO2lmKHRoaXMuZ3JhcGguaXNDZWxsQmVuZGFibGUodGhpcy5zdGF0ZS5jZWxsKSl7bnVsbD09dGhpcy5wb2ludHMmJih0aGlzLnBvaW50cz1bXSk7Zm9yKHZhciBkPTA7ZDxjLmxlbmd0aC0xO2QrKyl7Yj10aGlzLmNyZWF0ZVZpcnR1YWxCZW5kKCk7YS5wdXNoKGIpO3ZhciBlPTA9PU1hdGgucm91bmQoY1tkXS54LWNbZCsxXS54KTswPT1NYXRoLnJvdW5kKGNbZF0ueS1jW2QrMV0ueSkmJmQ8Yy5sZW5ndGgtMiYmKGU9MD09TWF0aC5yb3VuZChjW2RdLngtY1tkKzJdLngpKTtiLnNldEN1cnNvcihlPyJjb2wtcmVzaXplIjoicm93LXJlc2l6ZSIpOwp0aGlzLnBvaW50cy5wdXNoKG5ldyBteFBvaW50KDAsMCkpfX1iPXRoaXMuY3JlYXRlSGFuZGxlU2hhcGUoYy5sZW5ndGgpO3RoaXMuaW5pdEJlbmQoYik7Yi5zZXRDdXJzb3IobXhDb25zdGFudHMuQ1VSU09SX1RFUk1JTkFMX0hBTkRMRSk7YS5wdXNoKGIpO3JldHVybiBhfTtteEVkZ2VTZWdtZW50SGFuZGxlci5wcm90b3R5cGUucmVkcmF3PWZ1bmN0aW9uKCl7dGhpcy5yZWZyZXNoKCk7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUucmVkcmF3LmFwcGx5KHRoaXMsYXJndW1lbnRzKX07Cm14RWRnZVNlZ21lbnRIYW5kbGVyLnByb3RvdHlwZS5yZWRyYXdJbm5lckJlbmRzPWZ1bmN0aW9uKGEsYil7aWYodGhpcy5ncmFwaC5pc0NlbGxCZW5kYWJsZSh0aGlzLnN0YXRlLmNlbGwpKXt2YXIgYz10aGlzLmdldEN1cnJlbnRQb2ludHMoKTtpZihudWxsIT1jJiYxPGMubGVuZ3RoKXt2YXIgZD0hMTtpZig0PT1jLmxlbmd0aCYmMD09TWF0aC5yb3VuZChjWzFdLngtY1syXS54KSYmMD09TWF0aC5yb3VuZChjWzFdLnktY1syXS55KSlpZihkPSEwLDA9PU1hdGgucm91bmQoY1swXS55LWNbYy5sZW5ndGgtMV0ueSkpe3ZhciBlPWNbMF0ueCsoY1tjLmxlbmd0aC0xXS54LWNbMF0ueCkvMjtjWzFdPW5ldyBteFBvaW50KGUsY1sxXS55KTtjWzJdPW5ldyBteFBvaW50KGUsY1syXS55KX1lbHNlIGU9Y1swXS55KyhjW2MubGVuZ3RoLTFdLnktY1swXS55KS8yLGNbMV09bmV3IG14UG9pbnQoY1sxXS54LGUpLGNbMl09bmV3IG14UG9pbnQoY1syXS54LGUpO2ZvcihlPTA7ZTxjLmxlbmd0aC0KMTtlKyspaWYobnVsbCE9dGhpcy5iZW5kc1tlKzFdKXthPWNbZV07Yj1jW2UrMV07dmFyIGY9bmV3IG14UG9pbnQoYS54KyhiLngtYS54KS8yLGEueSsoYi55LWEueSkvMiksZz10aGlzLmJlbmRzW2UrMV0uYm91bmRzO3RoaXMuYmVuZHNbZSsxXS5ib3VuZHM9bmV3IG14UmVjdGFuZ2xlKE1hdGguZmxvb3IoZi54LWcud2lkdGgvMiksTWF0aC5mbG9vcihmLnktZy5oZWlnaHQvMiksZy53aWR0aCxnLmhlaWdodCk7dGhpcy5iZW5kc1tlKzFdLnJlZHJhdygpO3RoaXMubWFuYWdlTGFiZWxIYW5kbGUmJnRoaXMuY2hlY2tMYWJlbEhhbmRsZSh0aGlzLmJlbmRzW2UrMV0uYm91bmRzKX1kJiYobXhVdGlscy5zZXRPcGFjaXR5KHRoaXMuYmVuZHNbMV0ubm9kZSx0aGlzLnZpcnR1YWxCZW5kT3BhY2l0eSksbXhVdGlscy5zZXRPcGFjaXR5KHRoaXMuYmVuZHNbM10ubm9kZSx0aGlzLnZpcnR1YWxCZW5kT3BhY2l0eSkpfX19OwpmdW5jdGlvbiBteEtleUhhbmRsZXIoYSxiKXtudWxsIT1hJiYodGhpcy5ncmFwaD1hLHRoaXMudGFyZ2V0PWJ8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCx0aGlzLm5vcm1hbEtleXM9W10sdGhpcy5zaGlmdEtleXM9W10sdGhpcy5jb250cm9sS2V5cz1bXSx0aGlzLmNvbnRyb2xTaGlmdEtleXM9W10sdGhpcy5rZXlkb3duSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmtleURvd24oYSl9KSxteEV2ZW50LmFkZExpc3RlbmVyKHRoaXMudGFyZ2V0LCJrZXlkb3duIix0aGlzLmtleWRvd25IYW5kbGVyKSxteENsaWVudC5JU19JRSYmbXhFdmVudC5hZGRMaXN0ZW5lcih3aW5kb3csInVubG9hZCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmRlc3Ryb3koKX0pKSl9bXhLZXlIYW5kbGVyLnByb3RvdHlwZS5ncmFwaD1udWxsO214S2V5SGFuZGxlci5wcm90b3R5cGUudGFyZ2V0PW51bGw7Cm14S2V5SGFuZGxlci5wcm90b3R5cGUubm9ybWFsS2V5cz1udWxsO214S2V5SGFuZGxlci5wcm90b3R5cGUuc2hpZnRLZXlzPW51bGw7bXhLZXlIYW5kbGVyLnByb3RvdHlwZS5jb250cm9sS2V5cz1udWxsO214S2V5SGFuZGxlci5wcm90b3R5cGUuY29udHJvbFNoaWZ0S2V5cz1udWxsO214S2V5SGFuZGxlci5wcm90b3R5cGUuZW5hYmxlZD0hMDtteEtleUhhbmRsZXIucHJvdG90eXBlLmlzRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuYWJsZWR9O214S2V5SGFuZGxlci5wcm90b3R5cGUuc2V0RW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLmVuYWJsZWQ9YX07bXhLZXlIYW5kbGVyLnByb3RvdHlwZS5iaW5kS2V5PWZ1bmN0aW9uKGEsYil7dGhpcy5ub3JtYWxLZXlzW2FdPWJ9O214S2V5SGFuZGxlci5wcm90b3R5cGUuYmluZFNoaWZ0S2V5PWZ1bmN0aW9uKGEsYil7dGhpcy5zaGlmdEtleXNbYV09Yn07Cm14S2V5SGFuZGxlci5wcm90b3R5cGUuYmluZENvbnRyb2xLZXk9ZnVuY3Rpb24oYSxiKXt0aGlzLmNvbnRyb2xLZXlzW2FdPWJ9O214S2V5SGFuZGxlci5wcm90b3R5cGUuYmluZENvbnRyb2xTaGlmdEtleT1mdW5jdGlvbihhLGIpe3RoaXMuY29udHJvbFNoaWZ0S2V5c1thXT1ifTtteEtleUhhbmRsZXIucHJvdG90eXBlLmlzQ29udHJvbERvd249ZnVuY3Rpb24oYSl7cmV0dXJuIG14RXZlbnQuaXNDb250cm9sRG93bihhKX07bXhLZXlIYW5kbGVyLnByb3RvdHlwZS5nZXRGdW5jdGlvbj1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09YXx8bXhFdmVudC5pc0FsdERvd24oYSk/bnVsbDp0aGlzLmlzQ29udHJvbERvd24oYSk/bXhFdmVudC5pc1NoaWZ0RG93bihhKT90aGlzLmNvbnRyb2xTaGlmdEtleXNbYS5rZXlDb2RlXTp0aGlzLmNvbnRyb2xLZXlzW2Eua2V5Q29kZV06bXhFdmVudC5pc1NoaWZ0RG93bihhKT90aGlzLnNoaWZ0S2V5c1thLmtleUNvZGVdOnRoaXMubm9ybWFsS2V5c1thLmtleUNvZGVdfTsKbXhLZXlIYW5kbGVyLnByb3RvdHlwZS5pc0dyYXBoRXZlbnQ9ZnVuY3Rpb24oYSl7dmFyIGI9bXhFdmVudC5nZXRTb3VyY2UoYSk7cmV0dXJuIGI9PXRoaXMudGFyZ2V0fHxiLnBhcmVudE5vZGU9PXRoaXMudGFyZ2V0fHxudWxsIT10aGlzLmdyYXBoLmNlbGxFZGl0b3ImJnRoaXMuZ3JhcGguY2VsbEVkaXRvci5pc0V2ZW50U291cmNlKGEpPyEwOm14VXRpbHMuaXNBbmNlc3Rvck5vZGUodGhpcy5ncmFwaC5jb250YWluZXIsYil9O214S2V5SGFuZGxlci5wcm90b3R5cGUua2V5RG93bj1mdW5jdGlvbihhKXtpZih0aGlzLmlzRW5hYmxlZEZvckV2ZW50KGEpKWlmKDI3PT1hLmtleUNvZGUpdGhpcy5lc2NhcGUoYSk7ZWxzZSBpZighdGhpcy5pc0V2ZW50SWdub3JlZChhKSl7dmFyIGI9dGhpcy5nZXRGdW5jdGlvbihhKTtudWxsIT1iJiYoYihhKSxteEV2ZW50LmNvbnN1bWUoYSkpfX07Cm14S2V5SGFuZGxlci5wcm90b3R5cGUuaXNFbmFibGVkRm9yRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZ3JhcGguaXNFbmFibGVkKCkmJiFteEV2ZW50LmlzQ29uc3VtZWQoYSkmJnRoaXMuaXNHcmFwaEV2ZW50KGEpJiZ0aGlzLmlzRW5hYmxlZCgpfTtteEtleUhhbmRsZXIucHJvdG90eXBlLmlzRXZlbnRJZ25vcmVkPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdyYXBoLmlzRWRpdGluZygpfTtteEtleUhhbmRsZXIucHJvdG90eXBlLmVzY2FwZT1mdW5jdGlvbihhKXt0aGlzLmdyYXBoLmlzRXNjYXBlRW5hYmxlZCgpJiZ0aGlzLmdyYXBoLmVzY2FwZShhKX07Cm14S2V5SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe251bGwhPXRoaXMudGFyZ2V0JiZudWxsIT10aGlzLmtleWRvd25IYW5kbGVyJiYobXhFdmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLnRhcmdldCwia2V5ZG93biIsdGhpcy5rZXlkb3duSGFuZGxlciksdGhpcy5rZXlkb3duSGFuZGxlcj1udWxsKTt0aGlzLnRhcmdldD1udWxsfTtmdW5jdGlvbiBteFRvb2x0aXBIYW5kbGVyKGEsYil7bnVsbCE9YSYmKHRoaXMuZ3JhcGg9YSx0aGlzLmRlbGF5PWJ8fDUwMCx0aGlzLmdyYXBoLmFkZE1vdXNlTGlzdGVuZXIodGhpcykpfW14VG9vbHRpcEhhbmRsZXIucHJvdG90eXBlLnpJbmRleD0xMDAwNTtteFRvb2x0aXBIYW5kbGVyLnByb3RvdHlwZS5ncmFwaD1udWxsO214VG9vbHRpcEhhbmRsZXIucHJvdG90eXBlLmRlbGF5PW51bGw7bXhUb29sdGlwSGFuZGxlci5wcm90b3R5cGUuaWdub3JlVG91Y2hFdmVudHM9ITA7Cm14VG9vbHRpcEhhbmRsZXIucHJvdG90eXBlLmhpZGVPbkhvdmVyPSExO214VG9vbHRpcEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3llZD0hMTtteFRvb2x0aXBIYW5kbGVyLnByb3RvdHlwZS5lbmFibGVkPSEwO214VG9vbHRpcEhhbmRsZXIucHJvdG90eXBlLmlzRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuYWJsZWR9O214VG9vbHRpcEhhbmRsZXIucHJvdG90eXBlLnNldEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5lbmFibGVkPWF9O214VG9vbHRpcEhhbmRsZXIucHJvdG90eXBlLmlzSGlkZU9uSG92ZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oaWRlT25Ib3Zlcn07bXhUb29sdGlwSGFuZGxlci5wcm90b3R5cGUuc2V0SGlkZU9uSG92ZXI9ZnVuY3Rpb24oYSl7dGhpcy5oaWRlT25Ib3Zlcj1hfTsKbXhUb29sdGlwSGFuZGxlci5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe251bGwhPWRvY3VtZW50LmJvZHkmJih0aGlzLmRpdj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSx0aGlzLmRpdi5jbGFzc05hbWU9Im14VG9vbHRpcCIsdGhpcy5kaXYuc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIixkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZGl2KSxteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnModGhpcy5kaXYsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5oaWRlVG9vbHRpcCgpfSkpKX07bXhUb29sdGlwSGFuZGxlci5wcm90b3R5cGUuZ2V0U3RhdGVGb3JFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gYS5nZXRTdGF0ZSgpfTtteFRvb2x0aXBIYW5kbGVyLnByb3RvdHlwZS5tb3VzZURvd249ZnVuY3Rpb24oYSxiKXt0aGlzLnJlc2V0KGIsITEpO3RoaXMuaGlkZVRvb2x0aXAoKX07Cm14VG9vbHRpcEhhbmRsZXIucHJvdG90eXBlLm1vdXNlTW92ZT1mdW5jdGlvbihhLGIpe2lmKGIuZ2V0WCgpIT10aGlzLmxhc3RYfHxiLmdldFkoKSE9dGhpcy5sYXN0WSl7dGhpcy5yZXNldChiLCEwKTt2YXIgYz10aGlzLmdldFN0YXRlRm9yRXZlbnQoYik7KHRoaXMuaXNIaWRlT25Ib3ZlcigpfHxjIT10aGlzLnN0YXRlfHxiLmdldFNvdXJjZSgpIT10aGlzLm5vZGUmJighdGhpcy5zdGF0ZVNvdXJjZXx8bnVsbCE9YyYmdGhpcy5zdGF0ZVNvdXJjZT09KGIuaXNTb3VyY2UoYy5zaGFwZSl8fCFiLmlzU291cmNlKGMudGV4dCkpKSkmJnRoaXMuaGlkZVRvb2x0aXAoKX10aGlzLmxhc3RYPWIuZ2V0WCgpO3RoaXMubGFzdFk9Yi5nZXRZKCl9O214VG9vbHRpcEhhbmRsZXIucHJvdG90eXBlLm1vdXNlVXA9ZnVuY3Rpb24oYSxiKXt0aGlzLnJlc2V0KGIsITApO3RoaXMuaGlkZVRvb2x0aXAoKX07Cm14VG9vbHRpcEhhbmRsZXIucHJvdG90eXBlLnJlc2V0VGltZXI9ZnVuY3Rpb24oKXtudWxsIT10aGlzLnRocmVhZCYmKHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy50aHJlYWQpLHRoaXMudGhyZWFkPW51bGwpfTsKbXhUb29sdGlwSGFuZGxlci5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oYSxiLGMpe2lmKCF0aGlzLmlnbm9yZVRvdWNoRXZlbnRzfHxteEV2ZW50LmlzTW91c2VFdmVudChhLmdldEV2ZW50KCkpKWlmKHRoaXMucmVzZXRUaW1lcigpLGM9bnVsbCE9Yz9jOnRoaXMuZ2V0U3RhdGVGb3JFdmVudChhKSxiJiZ0aGlzLmlzRW5hYmxlZCgpJiZudWxsIT1jJiYobnVsbD09dGhpcy5kaXZ8fCJoaWRkZW4iPT10aGlzLmRpdi5zdHlsZS52aXNpYmlsaXR5KSl7dmFyIGQ9YS5nZXRTb3VyY2UoKSxlPWEuZ2V0WCgpLGY9YS5nZXRZKCksZz1hLmlzU291cmNlKGMuc2hhcGUpfHxhLmlzU291cmNlKGMudGV4dCk7dGhpcy50aHJlYWQ9d2luZG93LnNldFRpbWVvdXQobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtpZighdGhpcy5ncmFwaC5pc0VkaXRpbmcoKSYmIXRoaXMuZ3JhcGgucG9wdXBNZW51SGFuZGxlci5pc01lbnVTaG93aW5nKCkmJiF0aGlzLmdyYXBoLmlzTW91c2VEb3duKXt2YXIgYT0KdGhpcy5ncmFwaC5nZXRUb29sdGlwKGMsZCxlLGYpO3RoaXMuc2hvdyhhLGUsZik7dGhpcy5zdGF0ZT1jO3RoaXMubm9kZT1kO3RoaXMuc3RhdGVTb3VyY2U9Z319KSx0aGlzLmRlbGF5KX19O214VG9vbHRpcEhhbmRsZXIucHJvdG90eXBlLmhpZGU9ZnVuY3Rpb24oKXt0aGlzLnJlc2V0VGltZXIoKTt0aGlzLmhpZGVUb29sdGlwKCl9O214VG9vbHRpcEhhbmRsZXIucHJvdG90eXBlLmhpZGVUb29sdGlwPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5kaXYmJih0aGlzLmRpdi5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4iLHRoaXMuZGl2LmlubmVySFRNTD0iIil9OwpteFRvb2x0aXBIYW5kbGVyLnByb3RvdHlwZS5zaG93PWZ1bmN0aW9uKGEsYixjKXtpZighdGhpcy5kZXN0cm95ZWQmJm51bGwhPWEmJjA8YS5sZW5ndGgpe251bGw9PXRoaXMuZGl2JiZ0aGlzLmluaXQoKTt2YXIgZD1teFV0aWxzLmdldFNjcm9sbE9yaWdpbigpO3RoaXMuZGl2LnN0eWxlLnpJbmRleD10aGlzLnpJbmRleDt0aGlzLmRpdi5zdHlsZS5sZWZ0PWIrZC54KyJweCI7dGhpcy5kaXYuc3R5bGUudG9wPWMrbXhDb25zdGFudHMuVE9PTFRJUF9WRVJUSUNBTF9PRkZTRVQrZC55KyJweCI7bXhVdGlscy5pc05vZGUoYSk/KHRoaXMuZGl2LmlubmVySFRNTD0iIix0aGlzLmRpdi5hcHBlbmRDaGlsZChhKSk6dGhpcy5kaXYuaW5uZXJIVE1MPWEucmVwbGFjZSgvXG4vZywiPGJyPiIpO3RoaXMuZGl2LnN0eWxlLnZpc2liaWxpdHk9IiI7bXhVdGlscy5maXQodGhpcy5kaXYpfX07Cm14VG9vbHRpcEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLmRlc3Ryb3llZHx8KHRoaXMuZ3JhcGgucmVtb3ZlTW91c2VMaXN0ZW5lcih0aGlzKSxteEV2ZW50LnJlbGVhc2UodGhpcy5kaXYpLG51bGwhPXRoaXMuZGl2JiZudWxsIT10aGlzLmRpdi5wYXJlbnROb2RlJiZ0aGlzLmRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZGl2KSx0aGlzLmRlc3Ryb3llZD0hMCx0aGlzLmRpdj1udWxsKX07ZnVuY3Rpb24gbXhDZWxsVHJhY2tlcihhLGIsYyl7bXhDZWxsTWFya2VyLmNhbGwodGhpcyxhLGIpO3RoaXMuZ3JhcGguYWRkTW91c2VMaXN0ZW5lcih0aGlzKTtudWxsIT1jJiYodGhpcy5nZXRDZWxsPWMpO214Q2xpZW50LklTX0lFJiZteEV2ZW50LmFkZExpc3RlbmVyKHdpbmRvdywidW5sb2FkIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuZGVzdHJveSgpfSkpfW14VXRpbHMuZXh0ZW5kKG14Q2VsbFRyYWNrZXIsbXhDZWxsTWFya2VyKTsKbXhDZWxsVHJhY2tlci5wcm90b3R5cGUubW91c2VEb3duPWZ1bmN0aW9uKGEsYil7fTtteENlbGxUcmFja2VyLnByb3RvdHlwZS5tb3VzZU1vdmU9ZnVuY3Rpb24oYSxiKXt0aGlzLmlzRW5hYmxlZCgpJiZ0aGlzLnByb2Nlc3MoYil9O214Q2VsbFRyYWNrZXIucHJvdG90eXBlLm1vdXNlVXA9ZnVuY3Rpb24oYSxiKXt9O214Q2VsbFRyYWNrZXIucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLmRlc3Ryb3llZHx8KHRoaXMuZGVzdHJveWVkPSEwLHRoaXMuZ3JhcGgucmVtb3ZlTW91c2VMaXN0ZW5lcih0aGlzKSxteENlbGxNYXJrZXIucHJvdG90eXBlLmRlc3Ryb3kuYXBwbHkodGhpcykpfTsKZnVuY3Rpb24gbXhDZWxsSGlnaGxpZ2h0KGEsYixjLGQpe251bGwhPWEmJih0aGlzLmdyYXBoPWEsdGhpcy5oaWdobGlnaHRDb2xvcj1udWxsIT1iP2I6bXhDb25zdGFudHMuREVGQVVMVF9WQUxJRF9DT0xPUix0aGlzLnN0cm9rZVdpZHRoPW51bGwhPWM/YzpteENvbnN0YW50cy5ISUdITElHSFRfU1RST0tFV0lEVEgsdGhpcy5kYXNoZWQ9bnVsbCE9ZD9kOiExLHRoaXMub3BhY2l0eT1teENvbnN0YW50cy5ISUdITElHSFRfT1BBQ0lUWSx0aGlzLnJlcGFpbnRIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7aWYobnVsbCE9dGhpcy5zdGF0ZSl7dmFyIGE9dGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKHRoaXMuc3RhdGUuY2VsbCk7bnVsbD09YT90aGlzLmhpZGUoKToodGhpcy5zdGF0ZT1hLHRoaXMucmVwYWludCgpKX19KSx0aGlzLmdyYXBoLmdldFZpZXcoKS5hZGRMaXN0ZW5lcihteEV2ZW50LlNDQUxFLHRoaXMucmVwYWludEhhbmRsZXIpLHRoaXMuZ3JhcGguZ2V0VmlldygpLmFkZExpc3RlbmVyKG14RXZlbnQuVFJBTlNMQVRFLAp0aGlzLnJlcGFpbnRIYW5kbGVyKSx0aGlzLmdyYXBoLmdldFZpZXcoKS5hZGRMaXN0ZW5lcihteEV2ZW50LlNDQUxFX0FORF9UUkFOU0xBVEUsdGhpcy5yZXBhaW50SGFuZGxlciksdGhpcy5ncmFwaC5nZXRNb2RlbCgpLmFkZExpc3RlbmVyKG14RXZlbnQuQ0hBTkdFLHRoaXMucmVwYWludEhhbmRsZXIpLHRoaXMucmVzZXRIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5oaWRlKCl9KSx0aGlzLmdyYXBoLmdldFZpZXcoKS5hZGRMaXN0ZW5lcihteEV2ZW50LkRPV04sdGhpcy5yZXNldEhhbmRsZXIpLHRoaXMuZ3JhcGguZ2V0VmlldygpLmFkZExpc3RlbmVyKG14RXZlbnQuVVAsdGhpcy5yZXNldEhhbmRsZXIpKX1teENlbGxIaWdobGlnaHQucHJvdG90eXBlLmtlZXBPblRvcD0hMTtteENlbGxIaWdobGlnaHQucHJvdG90eXBlLmdyYXBoPW51bGw7bXhDZWxsSGlnaGxpZ2h0LnByb3RvdHlwZS5zdGF0ZT1udWxsOwpteENlbGxIaWdobGlnaHQucHJvdG90eXBlLnNwYWNpbmc9MjtteENlbGxIaWdobGlnaHQucHJvdG90eXBlLnJlc2V0SGFuZGxlcj1udWxsO214Q2VsbEhpZ2hsaWdodC5wcm90b3R5cGUuc2V0SGlnaGxpZ2h0Q29sb3I9ZnVuY3Rpb24oYSl7dGhpcy5oaWdobGlnaHRDb2xvcj1hO251bGwhPXRoaXMuc2hhcGUmJih0aGlzLnNoYXBlLnN0cm9rZT1hKX07bXhDZWxsSGlnaGxpZ2h0LnByb3RvdHlwZS5kcmF3SGlnaGxpZ2h0PWZ1bmN0aW9uKCl7dGhpcy5zaGFwZT10aGlzLmNyZWF0ZVNoYXBlKCk7dGhpcy5yZXBhaW50KCk7dGhpcy5rZWVwT25Ub3B8fHRoaXMuc2hhcGUubm9kZS5wYXJlbnROb2RlLmZpcnN0Q2hpbGQ9PXRoaXMuc2hhcGUubm9kZXx8dGhpcy5zaGFwZS5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuc2hhcGUubm9kZSx0aGlzLnNoYXBlLm5vZGUucGFyZW50Tm9kZS5maXJzdENoaWxkKX07Cm14Q2VsbEhpZ2hsaWdodC5wcm90b3R5cGUuY3JlYXRlU2hhcGU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoLmNlbGxSZW5kZXJlci5jcmVhdGVTaGFwZSh0aGlzLnN0YXRlKTthLnN2Z1N0cm9rZVRvbGVyYW5jZT10aGlzLmdyYXBoLnRvbGVyYW5jZTthLnBvaW50cz10aGlzLnN0YXRlLmFic29sdXRlUG9pbnRzO2EuYXBwbHkodGhpcy5zdGF0ZSk7YS5zdHJva2U9dGhpcy5oaWdobGlnaHRDb2xvcjthLm9wYWNpdHk9dGhpcy5vcGFjaXR5O2EuaXNEYXNoZWQ9dGhpcy5kYXNoZWQ7YS5pc1NoYWRvdz0hMTthLmRpYWxlY3Q9dGhpcy5ncmFwaC5kaWFsZWN0IT1teENvbnN0YW50cy5ESUFMRUNUX1NWRz9teENvbnN0YW50cy5ESUFMRUNUX1ZNTDpteENvbnN0YW50cy5ESUFMRUNUX1NWRzthLmluaXQodGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0T3ZlcmxheVBhbmUoKSk7bXhFdmVudC5yZWRpcmVjdE1vdXNlRXZlbnRzKGEubm9kZSx0aGlzLmdyYXBoLHRoaXMuc3RhdGUpO3RoaXMuZ3JhcGguZGlhbGVjdCE9Cm14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHP2EucG9pbnRlckV2ZW50cz0hMTphLnN2Z1BvaW50ZXJFdmVudHM9InN0cm9rZSI7cmV0dXJuIGF9O214Q2VsbEhpZ2hsaWdodC5wcm90b3R5cGUuZ2V0U3Ryb2tlV2lkdGg9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuc3Ryb2tlV2lkdGh9OwpteENlbGxIaWdobGlnaHQucHJvdG90eXBlLnJlcGFpbnQ9ZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLnN0YXRlJiZudWxsIT10aGlzLnNoYXBlKXt0aGlzLnNoYXBlLnNjYWxlPXRoaXMuc3RhdGUudmlldy5zY2FsZTt0aGlzLmdyYXBoLm1vZGVsLmlzRWRnZSh0aGlzLnN0YXRlLmNlbGwpPyh0aGlzLnNoYXBlLnN0cm9rZXdpZHRoPXRoaXMuZ2V0U3Ryb2tlV2lkdGgoKSx0aGlzLnNoYXBlLnBvaW50cz10aGlzLnN0YXRlLmFic29sdXRlUG9pbnRzLHRoaXMuc2hhcGUub3V0bGluZT0hMSk6KHRoaXMuc2hhcGUuYm91bmRzPW5ldyBteFJlY3RhbmdsZSh0aGlzLnN0YXRlLngtdGhpcy5zcGFjaW5nLHRoaXMuc3RhdGUueS10aGlzLnNwYWNpbmcsdGhpcy5zdGF0ZS53aWR0aCsyKnRoaXMuc3BhY2luZyx0aGlzLnN0YXRlLmhlaWdodCsyKnRoaXMuc3BhY2luZyksdGhpcy5zaGFwZS5yb3RhdGlvbj1OdW1iZXIodGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTl18fAoiMCIpLHRoaXMuc2hhcGUuc3Ryb2tld2lkdGg9dGhpcy5nZXRTdHJva2VXaWR0aCgpL3RoaXMuc3RhdGUudmlldy5zY2FsZSx0aGlzLnNoYXBlLm91dGxpbmU9ITApO251bGwhPXRoaXMuc3RhdGUuc2hhcGUmJnRoaXMuc2hhcGUuc2V0Q3Vyc29yKHRoaXMuc3RhdGUuc2hhcGUuZ2V0Q3Vyc29yKCkpO2lmKG14Q2xpZW50LklTX1FVSVJLU3x8OD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSJ0cmFuc3BhcmVudCI9PXRoaXMuc2hhcGUuc3Ryb2tlPyh0aGlzLnNoYXBlLnN0cm9rZT0id2hpdGUiLHRoaXMuc2hhcGUub3BhY2l0eT0xKTp0aGlzLnNoYXBlLm9wYWNpdHk9dGhpcy5vcGFjaXR5O3RoaXMuc2hhcGUucmVkcmF3KCl9fTtteENlbGxIaWdobGlnaHQucHJvdG90eXBlLmhpZGU9ZnVuY3Rpb24oKXt0aGlzLmhpZ2hsaWdodChudWxsKX07Cm14Q2VsbEhpZ2hsaWdodC5wcm90b3R5cGUuaGlnaGxpZ2h0PWZ1bmN0aW9uKGEpe3RoaXMuc3RhdGUhPWEmJihudWxsIT10aGlzLnNoYXBlJiYodGhpcy5zaGFwZS5kZXN0cm95KCksdGhpcy5zaGFwZT1udWxsKSx0aGlzLnN0YXRlPWEsbnVsbCE9dGhpcy5zdGF0ZSYmdGhpcy5kcmF3SGlnaGxpZ2h0KCkpfTtteENlbGxIaWdobGlnaHQucHJvdG90eXBlLmlzSGlnaGxpZ2h0QXQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz0hMTtpZihudWxsIT10aGlzLnNoYXBlJiZudWxsIT1kb2N1bWVudC5lbGVtZW50RnJvbVBvaW50JiYhbXhDbGllbnQuSVNfUVVJUktTKWZvcih2YXIgZD1kb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGEsYik7bnVsbCE9ZDspe2lmKGQ9PXRoaXMuc2hhcGUubm9kZSl7Yz0hMDticmVha31kPWQucGFyZW50Tm9kZX1yZXR1cm4gY307Cm14Q2VsbEhpZ2hsaWdodC5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZ3JhcGguZ2V0VmlldygpLnJlbW92ZUxpc3RlbmVyKHRoaXMucmVzZXRIYW5kbGVyKTt0aGlzLmdyYXBoLmdldFZpZXcoKS5yZW1vdmVMaXN0ZW5lcih0aGlzLnJlcGFpbnRIYW5kbGVyKTt0aGlzLmdyYXBoLmdldE1vZGVsKCkucmVtb3ZlTGlzdGVuZXIodGhpcy5yZXBhaW50SGFuZGxlcik7bnVsbCE9dGhpcy5zaGFwZSYmKHRoaXMuc2hhcGUuZGVzdHJveSgpLHRoaXMuc2hhcGU9bnVsbCl9OwpmdW5jdGlvbiBteERlZmF1bHRLZXlIYW5kbGVyKGEpe2lmKG51bGwhPWEpe3RoaXMuZWRpdG9yPWE7dGhpcy5oYW5kbGVyPW5ldyBteEtleUhhbmRsZXIoYS5ncmFwaCk7dmFyIGI9dGhpcy5oYW5kbGVyLmVzY2FwZTt0aGlzLmhhbmRsZXIuZXNjYXBlPWZ1bmN0aW9uKGMpe2IuYXBwbHkodGhpcyxhcmd1bWVudHMpO2EuaGlkZVByb3BlcnRpZXMoKTthLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkVTQ0FQRSwiZXZlbnQiLGMpKX19fW14RGVmYXVsdEtleUhhbmRsZXIucHJvdG90eXBlLmVkaXRvcj1udWxsO214RGVmYXVsdEtleUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZXI9bnVsbDsKbXhEZWZhdWx0S2V5SGFuZGxlci5wcm90b3R5cGUuYmluZEFjdGlvbj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmVkaXRvci5leGVjdXRlKGIpfSk7Yz90aGlzLmhhbmRsZXIuYmluZENvbnRyb2xLZXkoYSxkKTp0aGlzLmhhbmRsZXIuYmluZEtleShhLGQpfTtteERlZmF1bHRLZXlIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5oYW5kbGVyLmRlc3Ryb3koKTt0aGlzLmhhbmRsZXI9bnVsbH07ZnVuY3Rpb24gbXhEZWZhdWx0UG9wdXBNZW51KGEpe3RoaXMuY29uZmlnPWF9bXhEZWZhdWx0UG9wdXBNZW51LnByb3RvdHlwZS5pbWFnZUJhc2VQYXRoPW51bGw7bXhEZWZhdWx0UG9wdXBNZW51LnByb3RvdHlwZS5jb25maWc9bnVsbDsKbXhEZWZhdWx0UG9wdXBNZW51LnByb3RvdHlwZS5jcmVhdGVNZW51PWZ1bmN0aW9uKGEsYixjLGQpe2lmKG51bGwhPXRoaXMuY29uZmlnKXt2YXIgZT10aGlzLmNyZWF0ZUNvbmRpdGlvbnMoYSxjLGQpO3RoaXMuYWRkSXRlbXMoYSxiLGMsZCxlLHRoaXMuY29uZmlnLmZpcnN0Q2hpbGQsbnVsbCl9fTsKbXhEZWZhdWx0UG9wdXBNZW51LnByb3RvdHlwZS5hZGRJdGVtcz1mdW5jdGlvbihhLGIsYyxkLGUsZixnKXtmb3IodmFyIGs9ITE7bnVsbCE9Zjspe2lmKCJhZGQiPT1mLm5vZGVOYW1lKXt2YXIgbD1mLmdldEF0dHJpYnV0ZSgiaWYiKTtpZihudWxsPT1sfHxlW2xdKXt2YXIgbD1mLmdldEF0dHJpYnV0ZSgiYXMiKSxsPW14UmVzb3VyY2VzLmdldChsKXx8bCxtPW14VXRpbHMuZXZhbChteFV0aWxzLmdldFRleHRDb250ZW50KGYpKSxuPWYuZ2V0QXR0cmlidXRlKCJhY3Rpb24iKSxwPWYuZ2V0QXR0cmlidXRlKCJpY29uIikscT1mLmdldEF0dHJpYnV0ZSgiaWNvbkNscyIpLHI9Zi5nZXRBdHRyaWJ1dGUoImVuYWJsZWQtaWYiKSxyPW51bGw9PXJ8fGVbcl07ayYmKGIuYWRkU2VwYXJhdG9yKGcpLGs9ITEpO251bGwhPXAmJnRoaXMuaW1hZ2VCYXNlUGF0aCYmKHA9dGhpcy5pbWFnZUJhc2VQYXRoK3ApO2w9dGhpcy5hZGRBY3Rpb24oYixhLGwscCxtLG4sYyxnLHEscik7dGhpcy5hZGRJdGVtcyhhLApiLGMsZCxlLGYuZmlyc3RDaGlsZCxsKX19ZWxzZSJzZXBhcmF0b3IiPT1mLm5vZGVOYW1lJiYoaz0hMCk7Zj1mLm5leHRTaWJsaW5nfX07bXhEZWZhdWx0UG9wdXBNZW51LnByb3RvdHlwZS5hZGRBY3Rpb249ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxrLGwsbSl7cmV0dXJuIGEuYWRkSXRlbShjLGQsZnVuY3Rpb24oYSl7ImZ1bmN0aW9uIj09dHlwZW9mIGUmJmUuY2FsbChiLGIsZyxhKTtudWxsIT1mJiZiLmV4ZWN1dGUoZixnLGEpfSxrLGwsbSl9OwpteERlZmF1bHRQb3B1cE1lbnUucHJvdG90eXBlLmNyZWF0ZUNvbmRpdGlvbnM9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWEuZ3JhcGguZ2V0TW9kZWwoKSxlPWQuZ2V0Q2hpbGRDb3VudChiKSxmPVtdO2Yubm9jZWxsPW51bGw9PWI7Zi5uY2VsbHM9MTxhLmdyYXBoLmdldFNlbGVjdGlvbkNvdW50KCk7Zi5ub3RSb290PWQuZ2V0Um9vdCgpIT1kLmdldFBhcmVudChhLmdyYXBoLmdldERlZmF1bHRQYXJlbnQoKSk7Zi5jZWxsPW51bGwhPWI7ZD1udWxsIT1iJiYxPT1hLmdyYXBoLmdldFNlbGVjdGlvbkNvdW50KCk7Zi5ub25FbXB0eT1kJiYwPGU7Zi5leHBhbmRhYmxlPWQmJmEuZ3JhcGguaXNDZWxsRm9sZGFibGUoYiwhMSk7Zi5jb2xsYXBzYWJsZT1kJiZhLmdyYXBoLmlzQ2VsbEZvbGRhYmxlKGIsITApO2YudmFsaWRSb290PWQmJmEuZ3JhcGguaXNWYWxpZFJvb3QoYik7Zi5lbXB0eVZhbGlkUm9vdD1mLnZhbGlkUm9vdCYmMD09ZTtmLnN3aW1sYW5lPWQmJmEuZ3JhcGguaXNTd2ltbGFuZShiKTsKZT10aGlzLmNvbmZpZy5nZXRFbGVtZW50c0J5VGFnTmFtZSgiY29uZGl0aW9uIik7Zm9yKGQ9MDtkPGUubGVuZ3RoO2QrKyl7dmFyIGc9bXhVdGlscy5ldmFsKG14VXRpbHMuZ2V0VGV4dENvbnRlbnQoZVtkXSkpLGs9ZVtkXS5nZXRBdHRyaWJ1dGUoIm5hbWUiKTtudWxsIT1rJiYiZnVuY3Rpb24iPT10eXBlb2YgZyYmKGZba109ZyhhLGIsYykpfXJldHVybiBmfTtmdW5jdGlvbiBteERlZmF1bHRUb29sYmFyKGEsYil7dGhpcy5lZGl0b3I9YjtudWxsIT1hJiZudWxsIT1iJiZ0aGlzLmluaXQoYSl9bXhEZWZhdWx0VG9vbGJhci5wcm90b3R5cGUuZWRpdG9yPW51bGw7bXhEZWZhdWx0VG9vbGJhci5wcm90b3R5cGUudG9vbGJhcj1udWxsO214RGVmYXVsdFRvb2xiYXIucHJvdG90eXBlLnJlc2V0SGFuZGxlcj1udWxsO214RGVmYXVsdFRvb2xiYXIucHJvdG90eXBlLnNwYWNpbmc9NDtteERlZmF1bHRUb29sYmFyLnByb3RvdHlwZS5jb25uZWN0T25Ecm9wPSExOwpteERlZmF1bHRUb29sYmFyLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKGEpe251bGwhPWEmJih0aGlzLnRvb2xiYXI9bmV3IG14VG9vbGJhcihhKSx0aGlzLnRvb2xiYXIuYWRkTGlzdGVuZXIobXhFdmVudC5TRUxFQ1QsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXt2YXIgYj1jLmdldFByb3BlcnR5KCJmdW5jdGlvbiIpO3RoaXMuZWRpdG9yLmluc2VydEZ1bmN0aW9uPW51bGwhPWI/bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtiLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLnRvb2xiYXIucmVzZXRNb2RlKCl9KTpudWxsfSkpLHRoaXMucmVzZXRIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bnVsbCE9dGhpcy50b29sYmFyJiZ0aGlzLnRvb2xiYXIucmVzZXRNb2RlKCEwKX0pLHRoaXMuZWRpdG9yLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuRE9VQkxFX0NMSUNLLHRoaXMucmVzZXRIYW5kbGVyKSx0aGlzLmVkaXRvci5hZGRMaXN0ZW5lcihteEV2ZW50LkVTQ0FQRSwKdGhpcy5yZXNldEhhbmRsZXIpKX07bXhEZWZhdWx0VG9vbGJhci5wcm90b3R5cGUuYWRkSXRlbT1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe251bGwhPWMmJjA8Yy5sZW5ndGgmJnRoaXMuZWRpdG9yLmV4ZWN1dGUoYyl9KTtyZXR1cm4gdGhpcy50b29sYmFyLmFkZEl0ZW0oYSxiLGUsZCl9O214RGVmYXVsdFRvb2xiYXIucHJvdG90eXBlLmFkZFNlcGFyYXRvcj1mdW5jdGlvbihhKXthPWF8fG14Q2xpZW50LmltYWdlQmFzZVBhdGgrIi9zZXBhcmF0b3IuZ2lmIjt0aGlzLnRvb2xiYXIuYWRkU2VwYXJhdG9yKGEpfTtteERlZmF1bHRUb29sYmFyLnByb3RvdHlwZS5hZGRDb21ibz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRvb2xiYXIuYWRkQ29tYm8oKX07bXhEZWZhdWx0VG9vbGJhci5wcm90b3R5cGUuYWRkQWN0aW9uQ29tYm89ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMudG9vbGJhci5hZGRBY3Rpb25Db21ibyhhKX07Cm14RGVmYXVsdFRvb2xiYXIucHJvdG90eXBlLmFkZEFjdGlvbk9wdGlvbj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmVkaXRvci5leGVjdXRlKGMpfSk7dGhpcy5hZGRPcHRpb24oYSxiLGQpfTtteERlZmF1bHRUb29sYmFyLnByb3RvdHlwZS5hZGRPcHRpb249ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB0aGlzLnRvb2xiYXIuYWRkT3B0aW9uKGEsYixjKX07bXhEZWZhdWx0VG9vbGJhci5wcm90b3R5cGUuYWRkTW9kZT1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5lZGl0b3Iuc2V0TW9kZShjKTtudWxsIT1lJiZlKHRoaXMuZWRpdG9yKX0pO3JldHVybiB0aGlzLnRvb2xiYXIuYWRkU3dpdGNoTW9kZShhLGIsZixkKX07Cm14RGVmYXVsdFRvb2xiYXIucHJvdG90eXBlLmFkZFByb3RvdHlwZT1mdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGc9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4iZnVuY3Rpb24iPT10eXBlb2YgYz9jKCk6bnVsbCE9Yz90aGlzLmVkaXRvci5ncmFwaC5jbG9uZUNlbGwoYyk6bnVsbH0pLGs9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiKXsiZnVuY3Rpb24iPT10eXBlb2YgZT9lKHRoaXMuZWRpdG9yLGcoKSxhLGIpOnRoaXMuZHJvcChnKCksYSxiKTt0aGlzLnRvb2xiYXIucmVzZXRNb2RlKCk7bXhFdmVudC5jb25zdW1lKGEpfSk7YT10aGlzLnRvb2xiYXIuYWRkTW9kZShhLGIsayxkLG51bGwsZik7dGhpcy5pbnN0YWxsRHJvcEhhbmRsZXIoYSxmdW5jdGlvbihhLGIsYyl7ayhiLGMpfSk7cmV0dXJuIGF9OwpteERlZmF1bHRUb29sYmFyLnByb3RvdHlwZS5kcm9wPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLmVkaXRvci5ncmFwaCxlPWQuZ2V0TW9kZWwoKTtpZihudWxsIT1jJiYhZS5pc0VkZ2UoYykmJnRoaXMuY29ubmVjdE9uRHJvcCYmZC5pc0NlbGxDb25uZWN0YWJsZShjKSl0aGlzLmNvbm5lY3QoYSxiLGMpO2Vsc2V7Zm9yKDtudWxsIT1jJiYhZC5pc1ZhbGlkRHJvcFRhcmdldChjLFthXSxiKTspYz1lLmdldFBhcmVudChjKTt0aGlzLmluc2VydChhLGIsYyl9fTsKbXhEZWZhdWx0VG9vbGJhci5wcm90b3R5cGUuaW5zZXJ0PWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLmVkaXRvci5ncmFwaDtpZihkLmNhbkltcG9ydENlbGwoYSkpe3ZhciBlPW14RXZlbnQuZ2V0Q2xpZW50WChiKSxmPW14RXZlbnQuZ2V0Q2xpZW50WShiKSxlPW14VXRpbHMuY29udmVydFBvaW50KGQuY29udGFpbmVyLGUsZik7cmV0dXJuIGQuaXNTcGxpdEVuYWJsZWQoKSYmZC5pc1NwbGl0VGFyZ2V0KGMsW2FdLGIpP2Quc3BsaXRFZGdlKGMsW2FdLG51bGwsZS54LGUueSk6dGhpcy5lZGl0b3IuYWRkVmVydGV4KGMsYSxlLngsZS55KX1yZXR1cm4gbnVsbH07Cm14RGVmYXVsdFRvb2xiYXIucHJvdG90eXBlLmNvbm5lY3Q9ZnVuY3Rpb24oYSxiLGMpe2I9dGhpcy5lZGl0b3IuZ3JhcGg7dmFyIGQ9Yi5nZXRNb2RlbCgpO2lmKG51bGwhPWMmJmIuaXNDZWxsQ29ubmVjdGFibGUoYSkmJmIuaXNFZGdlVmFsaWQobnVsbCxjLGEpKXt2YXIgZT1udWxsO2QuYmVnaW5VcGRhdGUoKTt0cnl7dmFyIGY9ZC5nZXRHZW9tZXRyeShjKSxnPWQuZ2V0R2VvbWV0cnkoYSkuY2xvbmUoKTtnLng9Zi54KyhmLndpZHRoLWcud2lkdGgpLzI7Zy55PWYueSsoZi5oZWlnaHQtZy5oZWlnaHQpLzI7dmFyIGs9dGhpcy5zcGFjaW5nKmIuZ3JpZFNpemUsbD0yMCpkLmdldERpcmVjdGVkRWRnZUNvdW50KGMsITApO3RoaXMuZWRpdG9yLmhvcml6b250YWxGbG93P2cueCs9KGcud2lkdGgrZi53aWR0aCkvMitrK2w6Zy55Kz0oZy5oZWlnaHQrZi5oZWlnaHQpLzIraytsO2Euc2V0R2VvbWV0cnkoZyk7dmFyIG09ZC5nZXRQYXJlbnQoYyk7Yi5hZGRDZWxsKGEsbSk7Yi5jb25zdHJhaW5DaGlsZChhKTsKZT10aGlzLmVkaXRvci5jcmVhdGVFZGdlKGMsYSk7aWYobnVsbD09ZC5nZXRHZW9tZXRyeShlKSl7dmFyIG49bmV3IG14R2VvbWV0cnk7bi5yZWxhdGl2ZT0hMDtkLnNldEdlb21ldHJ5KGUsbil9Yi5hZGRFZGdlKGUsbSxjLGEpfWZpbmFsbHl7ZC5lbmRVcGRhdGUoKX1iLnNldFNlbGVjdGlvbkNlbGxzKFthLGVdKTtiLnNjcm9sbENlbGxUb1Zpc2libGUoYSl9fTsKbXhEZWZhdWx0VG9vbGJhci5wcm90b3R5cGUuaW5zdGFsbERyb3BIYW5kbGVyPWZ1bmN0aW9uKGEsYil7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIik7Yy5zZXRBdHRyaWJ1dGUoInNyYyIsYS5nZXRBdHRyaWJ1dGUoInNyYyIpKTt2YXIgZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihlKXtjLnN0eWxlLndpZHRoPTIqYS5vZmZzZXRXaWR0aCsicHgiO2Muc3R5bGUuaGVpZ2h0PTIqYS5vZmZzZXRIZWlnaHQrInB4IjtteFV0aWxzLm1ha2VEcmFnZ2FibGUoYSx0aGlzLmVkaXRvci5ncmFwaCxiLGMpO214RXZlbnQucmVtb3ZlTGlzdGVuZXIoYywibG9hZCIsZCl9KTtteENsaWVudC5JU19JRT9kKCk6bXhFdmVudC5hZGRMaXN0ZW5lcihjLCJsb2FkIixkKX07Cm14RGVmYXVsdFRvb2xiYXIucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXtudWxsIT10aGlzLnJlc2V0SGFuZGxlciYmKHRoaXMuZWRpdG9yLmdyYXBoLnJlbW92ZUxpc3RlbmVyKCJkYmxjbGljayIsdGhpcy5yZXNldEhhbmRsZXIpLHRoaXMuZWRpdG9yLnJlbW92ZUxpc3RlbmVyKCJlc2NhcGUiLHRoaXMucmVzZXRIYW5kbGVyKSx0aGlzLnJlc2V0SGFuZGxlcj1udWxsKTtudWxsIT10aGlzLnRvb2xiYXImJih0aGlzLnRvb2xiYXIuZGVzdHJveSgpLHRoaXMudG9vbGJhcj1udWxsKX07CmZ1bmN0aW9uIG14RWRpdG9yKGEpe3RoaXMuYWN0aW9ucz1bXTt0aGlzLmFkZEFjdGlvbnMoKTtpZihudWxsIT1kb2N1bWVudC5ib2R5KXt0aGlzLmN5Y2xlQXR0cmlidXRlVmFsdWVzPVtdO3RoaXMucG9wdXBIYW5kbGVyPW5ldyBteERlZmF1bHRQb3B1cE1lbnU7dGhpcy51bmRvTWFuYWdlcj1uZXcgbXhVbmRvTWFuYWdlcjt0aGlzLmdyYXBoPXRoaXMuY3JlYXRlR3JhcGgoKTt0aGlzLnRvb2xiYXI9dGhpcy5jcmVhdGVUb29sYmFyKCk7dGhpcy5rZXlIYW5kbGVyPW5ldyBteERlZmF1bHRLZXlIYW5kbGVyKHRoaXMpO3RoaXMuY29uZmlndXJlKGEpO3RoaXMuZ3JhcGguc3dpbWxhbmVJbmRpY2F0b3JDb2xvckF0dHJpYnV0ZT10aGlzLmN5Y2xlQXR0cmlidXRlTmFtZTtpZihudWxsIT10aGlzLm9uSW5pdCl0aGlzLm9uSW5pdCgpO214Q2xpZW50LklTX0lFJiZteEV2ZW50LmFkZExpc3RlbmVyKHdpbmRvdywidW5sb2FkIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuZGVzdHJveSgpfSkpfX0KbXhMb2FkUmVzb3VyY2VzP214UmVzb3VyY2VzLmFkZChteENsaWVudC5iYXNlUGF0aCsiL3Jlc291cmNlcy9lZGl0b3IiKTpteENsaWVudC5kZWZhdWx0QnVuZGxlcy5wdXNoKG14Q2xpZW50LmJhc2VQYXRoKyIvcmVzb3VyY2VzL2VkaXRvciIpO214RWRpdG9yLnByb3RvdHlwZT1uZXcgbXhFdmVudFNvdXJjZTtteEVkaXRvci5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhFZGl0b3I7bXhFZGl0b3IucHJvdG90eXBlLmFza1pvb21SZXNvdXJjZT0ibm9uZSIhPW14Q2xpZW50Lmxhbmd1YWdlPyJhc2tab29tIjoiIjtteEVkaXRvci5wcm90b3R5cGUubGFzdFNhdmVkUmVzb3VyY2U9Im5vbmUiIT1teENsaWVudC5sYW5ndWFnZT8ibGFzdFNhdmVkIjoiIjtteEVkaXRvci5wcm90b3R5cGUuY3VycmVudEZpbGVSZXNvdXJjZT0ibm9uZSIhPW14Q2xpZW50Lmxhbmd1YWdlPyJjdXJyZW50RmlsZSI6IiI7Cm14RWRpdG9yLnByb3RvdHlwZS5wcm9wZXJ0aWVzUmVzb3VyY2U9Im5vbmUiIT1teENsaWVudC5sYW5ndWFnZT8icHJvcGVydGllcyI6IiI7bXhFZGl0b3IucHJvdG90eXBlLnRhc2tzUmVzb3VyY2U9Im5vbmUiIT1teENsaWVudC5sYW5ndWFnZT8idGFza3MiOiIiO214RWRpdG9yLnByb3RvdHlwZS5oZWxwUmVzb3VyY2U9Im5vbmUiIT1teENsaWVudC5sYW5ndWFnZT8iaGVscCI6IiI7bXhFZGl0b3IucHJvdG90eXBlLm91dGxpbmVSZXNvdXJjZT0ibm9uZSIhPW14Q2xpZW50Lmxhbmd1YWdlPyJvdXRsaW5lIjoiIjtteEVkaXRvci5wcm90b3R5cGUub3V0bGluZT1udWxsO214RWRpdG9yLnByb3RvdHlwZS5ncmFwaD1udWxsO214RWRpdG9yLnByb3RvdHlwZS5ncmFwaFJlbmRlckhpbnQ9bnVsbDtteEVkaXRvci5wcm90b3R5cGUudG9vbGJhcj1udWxsO214RWRpdG9yLnByb3RvdHlwZS5zdGF0dXM9bnVsbDtteEVkaXRvci5wcm90b3R5cGUucG9wdXBIYW5kbGVyPW51bGw7Cm14RWRpdG9yLnByb3RvdHlwZS51bmRvTWFuYWdlcj1udWxsO214RWRpdG9yLnByb3RvdHlwZS5rZXlIYW5kbGVyPW51bGw7bXhFZGl0b3IucHJvdG90eXBlLmFjdGlvbnM9bnVsbDtteEVkaXRvci5wcm90b3R5cGUuZGJsQ2xpY2tBY3Rpb249ImVkaXQiO214RWRpdG9yLnByb3RvdHlwZS5zd2ltbGFuZVJlcXVpcmVkPSExO214RWRpdG9yLnByb3RvdHlwZS5kaXNhYmxlQ29udGV4dE1lbnU9ITA7bXhFZGl0b3IucHJvdG90eXBlLmluc2VydEZ1bmN0aW9uPW51bGw7bXhFZGl0b3IucHJvdG90eXBlLmZvcmNlZEluc2VydGluZz0hMTtteEVkaXRvci5wcm90b3R5cGUudGVtcGxhdGVzPW51bGw7bXhFZGl0b3IucHJvdG90eXBlLmRlZmF1bHRFZGdlPW51bGw7bXhFZGl0b3IucHJvdG90eXBlLmRlZmF1bHRFZGdlU3R5bGU9bnVsbDtteEVkaXRvci5wcm90b3R5cGUuZGVmYXVsdEdyb3VwPW51bGw7bXhFZGl0b3IucHJvdG90eXBlLmdyb3VwQm9yZGVyU2l6ZT1udWxsOwpteEVkaXRvci5wcm90b3R5cGUuZmlsZW5hbWU9bnVsbDtteEVkaXRvci5wcm90b3R5cGUubGluZWZlZWQ9IiYjeGE7IjtteEVkaXRvci5wcm90b3R5cGUucG9zdFBhcmFtZXRlck5hbWU9InhtbCI7bXhFZGl0b3IucHJvdG90eXBlLmVzY2FwZVBvc3REYXRhPSEwO214RWRpdG9yLnByb3RvdHlwZS51cmxQb3N0PW51bGw7bXhFZGl0b3IucHJvdG90eXBlLnVybEltYWdlPW51bGw7bXhFZGl0b3IucHJvdG90eXBlLmhvcml6b250YWxGbG93PSExO214RWRpdG9yLnByb3RvdHlwZS5sYXlvdXREaWFncmFtPSExO214RWRpdG9yLnByb3RvdHlwZS5zd2ltbGFuZVNwYWNpbmc9MDtteEVkaXRvci5wcm90b3R5cGUubWFpbnRhaW5Td2ltbGFuZXM9ITE7bXhFZGl0b3IucHJvdG90eXBlLmxheW91dFN3aW1sYW5lcz0hMTtteEVkaXRvci5wcm90b3R5cGUuY3ljbGVBdHRyaWJ1dGVWYWx1ZXM9bnVsbDtteEVkaXRvci5wcm90b3R5cGUuY3ljbGVBdHRyaWJ1dGVJbmRleD0wOwpteEVkaXRvci5wcm90b3R5cGUuY3ljbGVBdHRyaWJ1dGVOYW1lPSJmaWxsQ29sb3IiO214RWRpdG9yLnByb3RvdHlwZS50YXNrcz1udWxsO214RWRpdG9yLnByb3RvdHlwZS50YXNrc1dpbmRvd0ltYWdlPW51bGw7bXhFZGl0b3IucHJvdG90eXBlLnRhc2tzVG9wPTIwO214RWRpdG9yLnByb3RvdHlwZS5oZWxwPW51bGw7bXhFZGl0b3IucHJvdG90eXBlLmhlbHBXaW5kb3dJbWFnZT1udWxsO214RWRpdG9yLnByb3RvdHlwZS51cmxIZWxwPW51bGw7bXhFZGl0b3IucHJvdG90eXBlLmhlbHBXaWR0aD0zMDA7bXhFZGl0b3IucHJvdG90eXBlLmhlbHBIZWlnaHQ9MjYwO214RWRpdG9yLnByb3RvdHlwZS5wcm9wZXJ0aWVzV2lkdGg9MjQwO214RWRpdG9yLnByb3RvdHlwZS5wcm9wZXJ0aWVzSGVpZ2h0PW51bGw7bXhFZGl0b3IucHJvdG90eXBlLm1vdmVQcm9wZXJ0aWVzRGlhbG9nPSExO214RWRpdG9yLnByb3RvdHlwZS52YWxpZGF0aW5nPSExOwpteEVkaXRvci5wcm90b3R5cGUubW9kaWZpZWQ9ITE7bXhFZGl0b3IucHJvdG90eXBlLmlzTW9kaWZpZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tb2RpZmllZH07bXhFZGl0b3IucHJvdG90eXBlLnNldE1vZGlmaWVkPWZ1bmN0aW9uKGEpe3RoaXMubW9kaWZpZWQ9YX07Cm14RWRpdG9yLnByb3RvdHlwZS5hZGRBY3Rpb25zPWZ1bmN0aW9uKCl7dGhpcy5hZGRBY3Rpb24oInNhdmUiLGZ1bmN0aW9uKGEpe2Euc2F2ZSgpfSk7dGhpcy5hZGRBY3Rpb24oInByaW50IixmdW5jdGlvbihhKXsobmV3IG14UHJpbnRQcmV2aWV3KGEuZ3JhcGgsMSkpLm9wZW4oKX0pO3RoaXMuYWRkQWN0aW9uKCJzaG93IixmdW5jdGlvbihhKXtteFV0aWxzLnNob3coYS5ncmFwaCxudWxsLDEwLDEwKX0pO3RoaXMuYWRkQWN0aW9uKCJleHBvcnRJbWFnZSIsZnVuY3Rpb24oYSl7dmFyIGI9YS5nZXRVcmxJbWFnZSgpO2lmKG51bGw9PWJ8fG14Q2xpZW50LklTX0xPQ0FMKWEuZXhlY3V0ZSgic2hvdyIpO2Vsc2V7dmFyIGM9bXhVdGlscy5nZXRWaWV3WG1sKGEuZ3JhcGgsMSksYz1teFV0aWxzLmdldFhtbChjLCJcbiIpO214VXRpbHMuc3VibWl0KGIsYS5wb3N0UGFyYW1ldGVyTmFtZSsiPSIrZW5jb2RlVVJJQ29tcG9uZW50KGMpLGRvY3VtZW50LCJfYmxhbmsiKX19KTt0aGlzLmFkZEFjdGlvbigicmVmcmVzaCIsCmZ1bmN0aW9uKGEpe2EuZ3JhcGgucmVmcmVzaCgpfSk7dGhpcy5hZGRBY3Rpb24oImN1dCIsZnVuY3Rpb24oYSl7YS5ncmFwaC5pc0VuYWJsZWQoKSYmbXhDbGlwYm9hcmQuY3V0KGEuZ3JhcGgpfSk7dGhpcy5hZGRBY3Rpb24oImNvcHkiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJm14Q2xpcGJvYXJkLmNvcHkoYS5ncmFwaCl9KTt0aGlzLmFkZEFjdGlvbigicGFzdGUiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJm14Q2xpcGJvYXJkLnBhc3RlKGEuZ3JhcGgpfSk7dGhpcy5hZGRBY3Rpb24oImRlbGV0ZSIsZnVuY3Rpb24oYSl7YS5ncmFwaC5pc0VuYWJsZWQoKSYmYS5ncmFwaC5yZW1vdmVDZWxscygpfSk7dGhpcy5hZGRBY3Rpb24oImdyb3VwIixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLmdyYXBoLnNldFNlbGVjdGlvbkNlbGwoYS5ncm91cENlbGxzKCkpfSk7dGhpcy5hZGRBY3Rpb24oInVuZ3JvdXAiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJgphLmdyYXBoLnNldFNlbGVjdGlvbkNlbGxzKGEuZ3JhcGgudW5ncm91cENlbGxzKCkpfSk7dGhpcy5hZGRBY3Rpb24oInJlbW92ZUZyb21QYXJlbnQiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGgucmVtb3ZlQ2VsbHNGcm9tUGFyZW50KCl9KTt0aGlzLmFkZEFjdGlvbigidW5kbyIsZnVuY3Rpb24oYSl7YS5ncmFwaC5pc0VuYWJsZWQoKSYmYS51bmRvKCl9KTt0aGlzLmFkZEFjdGlvbigicmVkbyIsZnVuY3Rpb24oYSl7YS5ncmFwaC5pc0VuYWJsZWQoKSYmYS5yZWRvKCl9KTt0aGlzLmFkZEFjdGlvbigiem9vbUluIixmdW5jdGlvbihhKXthLmdyYXBoLnpvb21JbigpfSk7dGhpcy5hZGRBY3Rpb24oInpvb21PdXQiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguem9vbU91dCgpfSk7dGhpcy5hZGRBY3Rpb24oImFjdHVhbFNpemUiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguem9vbUFjdHVhbCgpfSk7dGhpcy5hZGRBY3Rpb24oImZpdCIsZnVuY3Rpb24oYSl7YS5ncmFwaC5maXQoKX0pOwp0aGlzLmFkZEFjdGlvbigic2hvd1Byb3BlcnRpZXMiLGZ1bmN0aW9uKGEsYil7YS5zaG93UHJvcGVydGllcyhiKX0pO3RoaXMuYWRkQWN0aW9uKCJzZWxlY3RBbGwiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGguc2VsZWN0QWxsKCl9KTt0aGlzLmFkZEFjdGlvbigic2VsZWN0Tm9uZSIsZnVuY3Rpb24oYSl7YS5ncmFwaC5pc0VuYWJsZWQoKSYmYS5ncmFwaC5jbGVhclNlbGVjdGlvbigpfSk7dGhpcy5hZGRBY3Rpb24oInNlbGVjdFZlcnRpY2VzIixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLmdyYXBoLnNlbGVjdFZlcnRpY2VzKCl9KTt0aGlzLmFkZEFjdGlvbigic2VsZWN0RWRnZXMiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGguc2VsZWN0RWRnZXMoKX0pO3RoaXMuYWRkQWN0aW9uKCJlZGl0IixmdW5jdGlvbihhLGIpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGguaXNDZWxsRWRpdGFibGUoYikmJmEuZ3JhcGguc3RhcnRFZGl0aW5nQXRDZWxsKGIpfSk7CnRoaXMuYWRkQWN0aW9uKCJ0b0JhY2siLGZ1bmN0aW9uKGEsYil7YS5ncmFwaC5pc0VuYWJsZWQoKSYmYS5ncmFwaC5vcmRlckNlbGxzKCEwKX0pO3RoaXMuYWRkQWN0aW9uKCJ0b0Zyb250IixmdW5jdGlvbihhLGIpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGgub3JkZXJDZWxscyghMSl9KTt0aGlzLmFkZEFjdGlvbigiZW50ZXJHcm91cCIsZnVuY3Rpb24oYSxiKXthLmdyYXBoLmVudGVyR3JvdXAoYil9KTt0aGlzLmFkZEFjdGlvbigiZXhpdEdyb3VwIixmdW5jdGlvbihhKXthLmdyYXBoLmV4aXRHcm91cCgpfSk7dGhpcy5hZGRBY3Rpb24oImhvbWUiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaG9tZSgpfSk7dGhpcy5hZGRBY3Rpb24oInNlbGVjdFByZXZpb3VzIixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLmdyYXBoLnNlbGVjdFByZXZpb3VzQ2VsbCgpfSk7dGhpcy5hZGRBY3Rpb24oInNlbGVjdE5leHQiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJgphLmdyYXBoLnNlbGVjdE5leHRDZWxsKCl9KTt0aGlzLmFkZEFjdGlvbigic2VsZWN0UGFyZW50IixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLmdyYXBoLnNlbGVjdFBhcmVudENlbGwoKX0pO3RoaXMuYWRkQWN0aW9uKCJzZWxlY3RDaGlsZCIsZnVuY3Rpb24oYSl7YS5ncmFwaC5pc0VuYWJsZWQoKSYmYS5ncmFwaC5zZWxlY3RDaGlsZENlbGwoKX0pO3RoaXMuYWRkQWN0aW9uKCJjb2xsYXBzZSIsZnVuY3Rpb24oYSl7YS5ncmFwaC5pc0VuYWJsZWQoKSYmYS5ncmFwaC5mb2xkQ2VsbHMoITApfSk7dGhpcy5hZGRBY3Rpb24oImNvbGxhcHNlQWxsIixmdW5jdGlvbihhKXtpZihhLmdyYXBoLmlzRW5hYmxlZCgpKXt2YXIgYj1hLmdyYXBoLmdldENoaWxkVmVydGljZXMoKTthLmdyYXBoLmZvbGRDZWxscyghMCwhMSxiKX19KTt0aGlzLmFkZEFjdGlvbigiZXhwYW5kIixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLmdyYXBoLmZvbGRDZWxscyghMSl9KTsKdGhpcy5hZGRBY3Rpb24oImV4cGFuZEFsbCIsZnVuY3Rpb24oYSl7aWYoYS5ncmFwaC5pc0VuYWJsZWQoKSl7dmFyIGI9YS5ncmFwaC5nZXRDaGlsZFZlcnRpY2VzKCk7YS5ncmFwaC5mb2xkQ2VsbHMoITEsITEsYil9fSk7dGhpcy5hZGRBY3Rpb24oImJvbGQiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGgudG9nZ2xlQ2VsbFN0eWxlRmxhZ3MobXhDb25zdGFudHMuU1RZTEVfRk9OVFNUWUxFLG14Q29uc3RhbnRzLkZPTlRfQk9MRCl9KTt0aGlzLmFkZEFjdGlvbigiaXRhbGljIixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLmdyYXBoLnRvZ2dsZUNlbGxTdHlsZUZsYWdzKG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRTVFlMRSxteENvbnN0YW50cy5GT05UX0lUQUxJQyl9KTt0aGlzLmFkZEFjdGlvbigidW5kZXJsaW5lIixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLmdyYXBoLnRvZ2dsZUNlbGxTdHlsZUZsYWdzKG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRTVFlMRSwKbXhDb25zdGFudHMuRk9OVF9VTkRFUkxJTkUpfSk7dGhpcy5hZGRBY3Rpb24oImFsaWduQ2VsbHNMZWZ0IixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLmdyYXBoLmFsaWduQ2VsbHMobXhDb25zdGFudHMuQUxJR05fTEVGVCl9KTt0aGlzLmFkZEFjdGlvbigiYWxpZ25DZWxsc0NlbnRlciIsZnVuY3Rpb24oYSl7YS5ncmFwaC5pc0VuYWJsZWQoKSYmYS5ncmFwaC5hbGlnbkNlbGxzKG14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUil9KTt0aGlzLmFkZEFjdGlvbigiYWxpZ25DZWxsc1JpZ2h0IixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLmdyYXBoLmFsaWduQ2VsbHMobXhDb25zdGFudHMuQUxJR05fUklHSFQpfSk7dGhpcy5hZGRBY3Rpb24oImFsaWduQ2VsbHNUb3AiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGguYWxpZ25DZWxscyhteENvbnN0YW50cy5BTElHTl9UT1ApfSk7dGhpcy5hZGRBY3Rpb24oImFsaWduQ2VsbHNNaWRkbGUiLApmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLmdyYXBoLmFsaWduQ2VsbHMobXhDb25zdGFudHMuQUxJR05fTUlERExFKX0pO3RoaXMuYWRkQWN0aW9uKCJhbGlnbkNlbGxzQm90dG9tIixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLmdyYXBoLmFsaWduQ2VsbHMobXhDb25zdGFudHMuQUxJR05fQk9UVE9NKX0pO3RoaXMuYWRkQWN0aW9uKCJhbGlnbkZvbnRMZWZ0IixmdW5jdGlvbihhKXthLmdyYXBoLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfQUxJR04sbXhDb25zdGFudHMuQUxJR05fTEVGVCl9KTt0aGlzLmFkZEFjdGlvbigiYWxpZ25Gb250Q2VudGVyIixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLmdyYXBoLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfQUxJR04sbXhDb25zdGFudHMuQUxJR05fQ0VOVEVSKX0pO3RoaXMuYWRkQWN0aW9uKCJhbGlnbkZvbnRSaWdodCIsZnVuY3Rpb24oYSl7YS5ncmFwaC5pc0VuYWJsZWQoKSYmCmEuZ3JhcGguc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9BTElHTixteENvbnN0YW50cy5BTElHTl9SSUdIVCl9KTt0aGlzLmFkZEFjdGlvbigiYWxpZ25Gb250VG9wIixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLmdyYXBoLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfVkVSVElDQUxfQUxJR04sbXhDb25zdGFudHMuQUxJR05fVE9QKX0pO3RoaXMuYWRkQWN0aW9uKCJhbGlnbkZvbnRNaWRkbGUiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGguc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9WRVJUSUNBTF9BTElHTixteENvbnN0YW50cy5BTElHTl9NSURETEUpfSk7dGhpcy5hZGRBY3Rpb24oImFsaWduRm9udEJvdHRvbSIsZnVuY3Rpb24oYSl7YS5ncmFwaC5pc0VuYWJsZWQoKSYmYS5ncmFwaC5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX1ZFUlRJQ0FMX0FMSUdOLG14Q29uc3RhbnRzLkFMSUdOX0JPVFRPTSl9KTsKdGhpcy5hZGRBY3Rpb24oInpvb20iLGZ1bmN0aW9uKGEpe3ZhciBiPTEwMCphLmdyYXBoLmdldFZpZXcoKS5zY2FsZSxiPXBhcnNlRmxvYXQobXhVdGlscy5wcm9tcHQobXhSZXNvdXJjZXMuZ2V0KGEuYXNrWm9vbVJlc291cmNlKXx8YS5hc2tab29tUmVzb3VyY2UsYikpLzEwMDtpc05hTihiKXx8YS5ncmFwaC5nZXRWaWV3KCkuc2V0U2NhbGUoYil9KTt0aGlzLmFkZEFjdGlvbigidG9nZ2xlVGFza3MiLGZ1bmN0aW9uKGEpe251bGwhPWEudGFza3M/YS50YXNrcy5zZXRWaXNpYmxlKCFhLnRhc2tzLmlzVmlzaWJsZSgpKTphLnNob3dUYXNrcygpfSk7dGhpcy5hZGRBY3Rpb24oInRvZ2dsZUhlbHAiLGZ1bmN0aW9uKGEpe251bGwhPWEuaGVscD9hLmhlbHAuc2V0VmlzaWJsZSghYS5oZWxwLmlzVmlzaWJsZSgpKTphLnNob3dIZWxwKCl9KTt0aGlzLmFkZEFjdGlvbigidG9nZ2xlT3V0bGluZSIsZnVuY3Rpb24oYSl7bnVsbD09YS5vdXRsaW5lP2Euc2hvd091dGxpbmUoKTphLm91dGxpbmUuc2V0VmlzaWJsZSghYS5vdXRsaW5lLmlzVmlzaWJsZSgpKX0pOwp0aGlzLmFkZEFjdGlvbigidG9nZ2xlQ29uc29sZSIsZnVuY3Rpb24oYSl7bXhMb2cuc2V0VmlzaWJsZSghbXhMb2cuaXNWaXNpYmxlKCkpfSl9O214RWRpdG9yLnByb3RvdHlwZS5jb25maWd1cmU9ZnVuY3Rpb24oYSl7bnVsbCE9YSYmKChuZXcgbXhDb2RlYyhhLm93bmVyRG9jdW1lbnQpKS5kZWNvZGUoYSx0aGlzKSx0aGlzLnJlc2V0SGlzdG9yeSgpKX07bXhFZGl0b3IucHJvdG90eXBlLnJlc2V0Rmlyc3RUaW1lPWZ1bmN0aW9uKCl7ZG9jdW1lbnQuY29va2llPSJteGdyYXBoPXNlZW47IGV4cGlyZXM9RnJpLCAyNyBKdWwgMjAwMSAwMjo0NzoxMSBVVEM7IHBhdGg9LyJ9O214RWRpdG9yLnByb3RvdHlwZS5yZXNldEhpc3Rvcnk9ZnVuY3Rpb24oKXt0aGlzLmxhc3RTbmFwc2hvdD0obmV3IERhdGUpLmdldFRpbWUoKTt0aGlzLnVuZG9NYW5hZ2VyLmNsZWFyKCk7dGhpcy5pZ25vcmVkQ2hhbmdlcz0wO3RoaXMuc2V0TW9kaWZpZWQoITEpfTsKbXhFZGl0b3IucHJvdG90eXBlLmFkZEFjdGlvbj1mdW5jdGlvbihhLGIpe3RoaXMuYWN0aW9uc1thXT1ifTtteEVkaXRvci5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5hY3Rpb25zW2FdO2lmKG51bGwhPWQpdHJ5e3ZhciBlPWFyZ3VtZW50cztlWzBdPXRoaXM7ZC5hcHBseSh0aGlzLGUpfWNhdGNoKGYpe3Rocm93IG14VXRpbHMuZXJyb3IoIkNhbm5vdCBleGVjdXRlICIrYSsiOiAiK2YubWVzc2FnZSwyODAsITApLGY7fWVsc2UgbXhVdGlscy5lcnJvcigiQ2Fubm90IGZpbmQgYWN0aW9uICIrYSwyODAsITApfTtteEVkaXRvci5wcm90b3R5cGUuYWRkVGVtcGxhdGU9ZnVuY3Rpb24oYSxiKXt0aGlzLnRlbXBsYXRlc1thXT1ifTtteEVkaXRvci5wcm90b3R5cGUuZ2V0VGVtcGxhdGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMudGVtcGxhdGVzW2FdfTsKbXhFZGl0b3IucHJvdG90eXBlLmNyZWF0ZUdyYXBoPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14R3JhcGgobnVsbCxudWxsLHRoaXMuZ3JhcGhSZW5kZXJIaW50KTthLnNldFRvb2x0aXBzKCEwKTthLnNldFBhbm5pbmcoITApO3RoaXMuaW5zdGFsbERibENsaWNrSGFuZGxlcihhKTt0aGlzLmluc3RhbGxVbmRvSGFuZGxlcihhKTt0aGlzLmluc3RhbGxEcmlsbEhhbmRsZXIoYSk7dGhpcy5pbnN0YWxsQ2hhbmdlSGFuZGxlcihhKTt0aGlzLmluc3RhbGxJbnNlcnRIYW5kbGVyKGEpO2EucG9wdXBNZW51SGFuZGxlci5mYWN0b3J5TWV0aG9kPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyxkKXtyZXR1cm4gdGhpcy5jcmVhdGVQb3B1cE1lbnUoYSxjLGQpfSk7YS5jb25uZWN0aW9uSGFuZGxlci5mYWN0b3J5TWV0aG9kPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7cmV0dXJuIHRoaXMuY3JlYXRlRWRnZShhLGMpfSk7dGhpcy5jcmVhdGVTd2ltbGFuZU1hbmFnZXIoYSk7CnRoaXMuY3JlYXRlTGF5b3V0TWFuYWdlcihhKTtyZXR1cm4gYX07bXhFZGl0b3IucHJvdG90eXBlLmNyZWF0ZVN3aW1sYW5lTWFuYWdlcj1mdW5jdGlvbihhKXthPW5ldyBteFN3aW1sYW5lTWFuYWdlcihhLCExKTthLmlzSG9yaXpvbnRhbD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3JldHVybiB0aGlzLmhvcml6b250YWxGbG93fSk7YS5pc0VuYWJsZWQ9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYWludGFpblN3aW1sYW5lc30pO3JldHVybiBhfTsKbXhFZGl0b3IucHJvdG90eXBlLmNyZWF0ZUxheW91dE1hbmFnZXI9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IG14TGF5b3V0TWFuYWdlcihhKSxjPXRoaXM7Yi5nZXRMYXlvdXQ9ZnVuY3Rpb24oYil7dmFyIGQ9bnVsbCxmPWMuZ3JhcGguZ2V0TW9kZWwoKTtudWxsIT1mLmdldFBhcmVudChiKSYmKGMubGF5b3V0U3dpbWxhbmVzJiZhLmlzU3dpbWxhbmUoYik/KG51bGw9PWMuc3dpbWxhbmVMYXlvdXQmJihjLnN3aW1sYW5lTGF5b3V0PWMuY3JlYXRlU3dpbWxhbmVMYXlvdXQoKSksZD1jLnN3aW1sYW5lTGF5b3V0KTpjLmxheW91dERpYWdyYW0mJihhLmlzVmFsaWRSb290KGIpfHxudWxsPT1mLmdldFBhcmVudChmLmdldFBhcmVudChiKSkpJiYobnVsbD09Yy5kaWFncmFtTGF5b3V0JiYoYy5kaWFncmFtTGF5b3V0PWMuY3JlYXRlRGlhZ3JhbUxheW91dCgpKSxkPWMuZGlhZ3JhbUxheW91dCkpO3JldHVybiBkfTtyZXR1cm4gYn07Cm14RWRpdG9yLnByb3RvdHlwZS5zZXRHcmFwaENvbnRhaW5lcj1mdW5jdGlvbihhKXtudWxsPT10aGlzLmdyYXBoLmNvbnRhaW5lciYmKHRoaXMuZ3JhcGguaW5pdChhKSx0aGlzLnJ1YmJlcmJhbmQ9bmV3IG14UnViYmVyYmFuZCh0aGlzLmdyYXBoKSx0aGlzLmRpc2FibGVDb250ZXh0TWVudSYmbXhFdmVudC5kaXNhYmxlQ29udGV4dE1lbnUoYSksbXhDbGllbnQuSVNfUVVJUktTJiZuZXcgbXhEaXZSZXNpemVyKGEpKX07bXhFZGl0b3IucHJvdG90eXBlLmluc3RhbGxEYmxDbGlja0hhbmRsZXI9ZnVuY3Rpb24oYSl7YS5hZGRMaXN0ZW5lcihteEV2ZW50LkRPVUJMRV9DTElDSyxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiLGMpe3ZhciBkPWMuZ2V0UHJvcGVydHkoImNlbGwiKTtudWxsIT1kJiZhLmlzRW5hYmxlZCgpJiZudWxsIT10aGlzLmRibENsaWNrQWN0aW9uJiYodGhpcy5leGVjdXRlKHRoaXMuZGJsQ2xpY2tBY3Rpb24sZCksYy5jb25zdW1lKCkpfSkpfTsKbXhFZGl0b3IucHJvdG90eXBlLmluc3RhbGxVbmRvSGFuZGxlcj1mdW5jdGlvbihhKXt2YXIgYj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIpe3ZhciBjPWIuZ2V0UHJvcGVydHkoImVkaXQiKTt0aGlzLnVuZG9NYW5hZ2VyLnVuZG9hYmxlRWRpdEhhcHBlbmVkKGMpfSk7YS5nZXRNb2RlbCgpLmFkZExpc3RlbmVyKG14RXZlbnQuVU5ETyxiKTthLmdldFZpZXcoKS5hZGRMaXN0ZW5lcihteEV2ZW50LlVORE8sYik7Yj1mdW5jdGlvbihiLGQpe3ZhciBjPWQuZ2V0UHJvcGVydHkoImVkaXQiKS5jaGFuZ2VzO2Euc2V0U2VsZWN0aW9uQ2VsbHMoYS5nZXRTZWxlY3Rpb25DZWxsc0ZvckNoYW5nZXMoYykpfTt0aGlzLnVuZG9NYW5hZ2VyLmFkZExpc3RlbmVyKG14RXZlbnQuVU5ETyxiKTt0aGlzLnVuZG9NYW5hZ2VyLmFkZExpc3RlbmVyKG14RXZlbnQuUkVETyxiKX07Cm14RWRpdG9yLnByb3RvdHlwZS5pbnN0YWxsRHJpbGxIYW5kbGVyPWZ1bmN0aW9uKGEpe3ZhciBiPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuUk9PVCkpfSk7YS5nZXRWaWV3KCkuYWRkTGlzdGVuZXIobXhFdmVudC5ET1dOLGIpO2EuZ2V0VmlldygpLmFkZExpc3RlbmVyKG14RXZlbnQuVVAsYil9OwpteEVkaXRvci5wcm90b3R5cGUuaW5zdGFsbENoYW5nZUhhbmRsZXI9ZnVuY3Rpb24oYSl7dmFyIGI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYixkKXt0aGlzLnNldE1vZGlmaWVkKCEwKTsxPT10aGlzLnZhbGlkYXRpbmcmJmEudmFsaWRhdGVHcmFwaCgpO2Zvcih2YXIgYz1kLmdldFByb3BlcnR5KCJlZGl0IikuY2hhbmdlcyxmPTA7ZjxjLmxlbmd0aDtmKyspe3ZhciBnPWNbZl07aWYoZyBpbnN0YW5jZW9mIG14Um9vdENoYW5nZXx8ZyBpbnN0YW5jZW9mIG14VmFsdWVDaGFuZ2UmJmcuY2VsbD09dGhpcy5ncmFwaC5tb2RlbC5yb290fHxnIGluc3RhbmNlb2YgbXhDZWxsQXR0cmlidXRlQ2hhbmdlJiZnLmNlbGw9PXRoaXMuZ3JhcGgubW9kZWwucm9vdCl7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5ST09UKSk7YnJlYWt9fX0pO2EuZ2V0TW9kZWwoKS5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSxiKX07Cm14RWRpdG9yLnByb3RvdHlwZS5pbnN0YWxsSW5zZXJ0SGFuZGxlcj1mdW5jdGlvbihhKXt2YXIgYj10aGlzO2EuYWRkTW91c2VMaXN0ZW5lcih7bW91c2VEb3duOmZ1bmN0aW9uKGEsZCl7bnVsbD09Yi5pbnNlcnRGdW5jdGlvbnx8ZC5pc1BvcHVwVHJpZ2dlcigpfHwhYi5mb3JjZWRJbnNlcnRpbmcmJm51bGwhPWQuZ2V0U3RhdGUoKXx8KGIuZ3JhcGguY2xlYXJTZWxlY3Rpb24oKSxiLmluc2VydEZ1bmN0aW9uKGQuZ2V0RXZlbnQoKSxkLmdldENlbGwoKSksdGhpcy5pc0FjdGl2ZT0hMCxkLmNvbnN1bWUoKSl9LG1vdXNlTW92ZTpmdW5jdGlvbihhLGIpe3RoaXMuaXNBY3RpdmUmJmIuY29uc3VtZSgpfSxtb3VzZVVwOmZ1bmN0aW9uKGEsYil7dGhpcy5pc0FjdGl2ZSYmKHRoaXMuaXNBY3RpdmU9ITEsYi5jb25zdW1lKCkpfX0pfTsKbXhFZGl0b3IucHJvdG90eXBlLmNyZWF0ZURpYWdyYW1MYXlvdXQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoLmdyaWRTaXplLGI9bmV3IG14U3RhY2tMYXlvdXQodGhpcy5ncmFwaCwhdGhpcy5ob3Jpem9udGFsRmxvdyx0aGlzLnN3aW1sYW5lU3BhY2luZywyKmEsMiphKTtiLmlzVmVydGV4SWdub3JlZD1mdW5jdGlvbihhKXtyZXR1cm4hYi5ncmFwaC5pc1N3aW1sYW5lKGEpfTtyZXR1cm4gYn07bXhFZGl0b3IucHJvdG90eXBlLmNyZWF0ZVN3aW1sYW5lTGF5b3V0PWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBteENvbXBhY3RUcmVlTGF5b3V0KHRoaXMuZ3JhcGgsdGhpcy5ob3Jpem9udGFsRmxvdyl9O214RWRpdG9yLnByb3RvdHlwZS5jcmVhdGVUb29sYmFyPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBteERlZmF1bHRUb29sYmFyKG51bGwsdGhpcyl9OwpteEVkaXRvci5wcm90b3R5cGUuc2V0VG9vbGJhckNvbnRhaW5lcj1mdW5jdGlvbihhKXt0aGlzLnRvb2xiYXIuaW5pdChhKTtteENsaWVudC5JU19RVUlSS1MmJm5ldyBteERpdlJlc2l6ZXIoYSl9OwpteEVkaXRvci5wcm90b3R5cGUuc2V0U3RhdHVzQ29udGFpbmVyPWZ1bmN0aW9uKGEpe251bGw9PXRoaXMuc3RhdHVzJiYodGhpcy5zdGF0dXM9YSx0aGlzLmFkZExpc3RlbmVyKG14RXZlbnQuU0FWRSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3ZhciBhPShuZXcgRGF0ZSkudG9Mb2NhbGVTdHJpbmcoKTt0aGlzLnNldFN0YXR1cygobXhSZXNvdXJjZXMuZ2V0KHRoaXMubGFzdFNhdmVkUmVzb3VyY2UpfHx0aGlzLmxhc3RTYXZlZFJlc291cmNlKSsiOiAiK2EpfSkpLHRoaXMuYWRkTGlzdGVuZXIobXhFdmVudC5PUEVOLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5zZXRTdGF0dXMoKG14UmVzb3VyY2VzLmdldCh0aGlzLmN1cnJlbnRGaWxlUmVzb3VyY2UpfHx0aGlzLmN1cnJlbnRGaWxlUmVzb3VyY2UpKyI6ICIrdGhpcy5maWxlbmFtZSl9KSksbXhDbGllbnQuSVNfUVVJUktTJiZuZXcgbXhEaXZSZXNpemVyKGEpKX07Cm14RWRpdG9yLnByb3RvdHlwZS5zZXRTdGF0dXM9ZnVuY3Rpb24oYSl7bnVsbCE9dGhpcy5zdGF0dXMmJm51bGwhPWEmJih0aGlzLnN0YXR1cy5pbm5lckhUTUw9YSl9O214RWRpdG9yLnByb3RvdHlwZS5zZXRUaXRsZUNvbnRhaW5lcj1mdW5jdGlvbihhKXt0aGlzLmFkZExpc3RlbmVyKG14RXZlbnQuUk9PVCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXthLmlubmVySFRNTD10aGlzLmdldFRpdGxlKCl9KSk7bXhDbGllbnQuSVNfUVVJUktTJiZuZXcgbXhEaXZSZXNpemVyKGEpfTtteEVkaXRvci5wcm90b3R5cGUudHJlZUxheW91dD1mdW5jdGlvbihhLGIpe251bGwhPWEmJihuZXcgbXhDb21wYWN0VHJlZUxheW91dCh0aGlzLmdyYXBoLGIpKS5leGVjdXRlKGEpfTsKbXhFZGl0b3IucHJvdG90eXBlLmdldFRpdGxlPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPSIiLGI9dGhpcy5ncmFwaCxjPWIuZ2V0Q3VycmVudFJvb3QoKTtudWxsIT1jJiZudWxsIT1iLmdldE1vZGVsKCkuZ2V0UGFyZW50KGIuZ2V0TW9kZWwoKS5nZXRQYXJlbnQoYykpOyliLmlzVmFsaWRSb290KGMpJiYoYT0iID4gIitiLmNvbnZlcnRWYWx1ZVRvU3RyaW5nKGMpK2EpLGM9Yi5nZXRNb2RlbCgpLmdldFBhcmVudChjKTtyZXR1cm4gdGhpcy5nZXRSb290VGl0bGUoKSthfTtteEVkaXRvci5wcm90b3R5cGUuZ2V0Um9vdFRpdGxlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldFJvb3QoKTtyZXR1cm4gdGhpcy5ncmFwaC5jb252ZXJ0VmFsdWVUb1N0cmluZyhhKX07bXhFZGl0b3IucHJvdG90eXBlLnVuZG89ZnVuY3Rpb24oKXt0aGlzLnVuZG9NYW5hZ2VyLnVuZG8oKX07bXhFZGl0b3IucHJvdG90eXBlLnJlZG89ZnVuY3Rpb24oKXt0aGlzLnVuZG9NYW5hZ2VyLnJlZG8oKX07Cm14RWRpdG9yLnByb3RvdHlwZS5ncm91cENlbGxzPWZ1bmN0aW9uKCl7dmFyIGE9bnVsbCE9dGhpcy5ncm91cEJvcmRlclNpemU/dGhpcy5ncm91cEJvcmRlclNpemU6dGhpcy5ncmFwaC5ncmlkU2l6ZTtyZXR1cm4gdGhpcy5ncmFwaC5ncm91cENlbGxzKHRoaXMuY3JlYXRlR3JvdXAoKSxhKX07bXhFZGl0b3IucHJvdG90eXBlLmNyZWF0ZUdyb3VwPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5jbG9uZUNlbGwodGhpcy5kZWZhdWx0R3JvdXApfTtteEVkaXRvci5wcm90b3R5cGUub3Blbj1mdW5jdGlvbihhKXtpZihudWxsIT1hKXt2YXIgYj1teFV0aWxzLmxvYWQoYSkuZ2V0WG1sKCk7dGhpcy5yZWFkR3JhcGhNb2RlbChiLmRvY3VtZW50RWxlbWVudCk7dGhpcy5maWxlbmFtZT1hO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuT1BFTiwiZmlsZW5hbWUiLGEpKX19OwpteEVkaXRvci5wcm90b3R5cGUucmVhZEdyYXBoTW9kZWw9ZnVuY3Rpb24oYSl7KG5ldyBteENvZGVjKGEub3duZXJEb2N1bWVudCkpLmRlY29kZShhLHRoaXMuZ3JhcGguZ2V0TW9kZWwoKSk7dGhpcy5yZXNldEhpc3RvcnkoKX07bXhFZGl0b3IucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24oYSxiKXthPWF8fHRoaXMuZ2V0VXJsUG9zdCgpO2lmKG51bGwhPWEmJjA8YS5sZW5ndGgpe3ZhciBjPXRoaXMud3JpdGVHcmFwaE1vZGVsKGIpO3RoaXMucG9zdERpYWdyYW0oYSxjKTt0aGlzLnNldE1vZGlmaWVkKCExKX10aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlNBVkUsInVybCIsYSkpfTsKbXhFZGl0b3IucHJvdG90eXBlLnBvc3REaWFncmFtPWZ1bmN0aW9uKGEsYil7dGhpcy5lc2NhcGVQb3N0RGF0YSYmKGI9ZW5jb2RlVVJJQ29tcG9uZW50KGIpKTtteFV0aWxzLnBvc3QoYSx0aGlzLnBvc3RQYXJhbWV0ZXJOYW1lKyI9IitiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGMpe3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuUE9TVCwicmVxdWVzdCIsYywidXJsIixhLCJkYXRhIixiKSl9KSl9O214RWRpdG9yLnByb3RvdHlwZS53cml0ZUdyYXBoTW9kZWw9ZnVuY3Rpb24oYSl7YT1udWxsIT1hP2E6dGhpcy5saW5lZmVlZDt2YXIgYj0obmV3IG14Q29kZWMpLmVuY29kZSh0aGlzLmdyYXBoLmdldE1vZGVsKCkpO3JldHVybiBteFV0aWxzLmdldFhtbChiLGEpfTtteEVkaXRvci5wcm90b3R5cGUuZ2V0VXJsUG9zdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVybFBvc3R9O214RWRpdG9yLnByb3RvdHlwZS5nZXRVcmxJbWFnZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVybEltYWdlfTsKbXhFZGl0b3IucHJvdG90eXBlLnN3YXBTdHlsZXM9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdyYXBoLmdldFN0eWxlc2hlZXQoKS5zdHlsZXNbYl07dGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0U3R5bGVzaGVldCgpLnB1dENlbGxTdHlsZShiLHRoaXMuZ3JhcGguZ2V0U3R5bGVzaGVldCgpLnN0eWxlc1thXSk7dGhpcy5ncmFwaC5nZXRTdHlsZXNoZWV0KCkucHV0Q2VsbFN0eWxlKGEsYyk7dGhpcy5ncmFwaC5yZWZyZXNoKCl9OwpteEVkaXRvci5wcm90b3R5cGUuc2hvd1Byb3BlcnRpZXM9ZnVuY3Rpb24oYSl7YT1hfHx0aGlzLmdyYXBoLmdldFNlbGVjdGlvbkNlbGwoKTtudWxsPT1hJiYoYT10aGlzLmdyYXBoLmdldEN1cnJlbnRSb290KCksbnVsbD09YSYmKGE9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldFJvb3QoKSkpO2lmKG51bGwhPWEpe3RoaXMuZ3JhcGguc3RvcEVkaXRpbmcoITApO3ZhciBiPW14VXRpbHMuZ2V0T2Zmc2V0KHRoaXMuZ3JhcGguY29udGFpbmVyKSxjPWIueCsxMCxiPWIueTtpZihudWxsPT10aGlzLnByb3BlcnRpZXN8fHRoaXMubW92ZVByb3BlcnRpZXNEaWFsb2cpe3ZhciBkPXRoaXMuZ3JhcGguZ2V0Q2VsbEJvdW5kcyhhKTtudWxsIT1kJiYoYys9ZC54K01hdGgubWluKDIwMCxkLndpZHRoKSxiKz1kLnkpfWVsc2UgYz10aGlzLnByb3BlcnRpZXMuZ2V0WCgpLGI9dGhpcy5wcm9wZXJ0aWVzLmdldFkoKTt0aGlzLmhpZGVQcm9wZXJ0aWVzKCk7YT10aGlzLmNyZWF0ZVByb3BlcnRpZXMoYSk7Cm51bGwhPWEmJih0aGlzLnByb3BlcnRpZXM9bmV3IG14V2luZG93KG14UmVzb3VyY2VzLmdldCh0aGlzLnByb3BlcnRpZXNSZXNvdXJjZSl8fHRoaXMucHJvcGVydGllc1Jlc291cmNlLGEsYyxiLHRoaXMucHJvcGVydGllc1dpZHRoLHRoaXMucHJvcGVydGllc0hlaWdodCwhMSksdGhpcy5wcm9wZXJ0aWVzLnNldFZpc2libGUoITApKX19O214RWRpdG9yLnByb3RvdHlwZS5pc1Byb3BlcnRpZXNWaXNpYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMucHJvcGVydGllc307Cm14RWRpdG9yLnByb3RvdHlwZS5jcmVhdGVQcm9wZXJ0aWVzPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxjPWIuZ2V0VmFsdWUoYSk7aWYobXhVdGlscy5pc05vZGUoYykpe3ZhciBkPW5ldyBteEZvcm0oInByb3BlcnRpZXMiKTtkLmFkZFRleHQoIklEIixhLmdldElkKCkpLnNldEF0dHJpYnV0ZSgicmVhZG9ubHkiLCJ0cnVlIik7dmFyIGU9bnVsbCxmPW51bGwsZz1udWxsLGs9bnVsbCxsPW51bGw7Yi5pc1ZlcnRleChhKSYmKGU9Yi5nZXRHZW9tZXRyeShhKSxudWxsIT1lJiYoZj1kLmFkZFRleHQoInRvcCIsZS55KSxnPWQuYWRkVGV4dCgibGVmdCIsZS54KSxrPWQuYWRkVGV4dCgid2lkdGgiLGUud2lkdGgpLGw9ZC5hZGRUZXh0KCJoZWlnaHQiLGUuaGVpZ2h0KSkpO2Zvcih2YXIgbT1iLmdldFN0eWxlKGEpLG49ZC5hZGRUZXh0KCJTdHlsZSIsbXx8IiIpLHA9Yy5hdHRyaWJ1dGVzLHE9W10sYz0wO2M8cC5sZW5ndGg7YysrKXFbY109ZC5hZGRUZXh0YXJlYShwW2NdLm5vZGVOYW1lLApwW2NdLnZhbHVlLCJsYWJlbCI9PXBbY10ubm9kZU5hbWU/NDoyKTtjPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5oaWRlUHJvcGVydGllcygpO2IuYmVnaW5VcGRhdGUoKTt0cnl7bnVsbCE9ZSYmKGU9ZS5jbG9uZSgpLGUueD1wYXJzZUZsb2F0KGcudmFsdWUpLGUueT1wYXJzZUZsb2F0KGYudmFsdWUpLGUud2lkdGg9cGFyc2VGbG9hdChrLnZhbHVlKSxlLmhlaWdodD1wYXJzZUZsb2F0KGwudmFsdWUpLGIuc2V0R2VvbWV0cnkoYSxlKSk7MDxuLnZhbHVlLmxlbmd0aD9iLnNldFN0eWxlKGEsbi52YWx1ZSk6Yi5zZXRTdHlsZShhLG51bGwpO2Zvcih2YXIgYz0wO2M8cC5sZW5ndGg7YysrKXt2YXIgZD1uZXcgbXhDZWxsQXR0cmlidXRlQ2hhbmdlKGEscFtjXS5ub2RlTmFtZSxxW2NdLnZhbHVlKTtiLmV4ZWN1dGUoZCl9dGhpcy5ncmFwaC5pc0F1dG9TaXplQ2VsbChhKSYmdGhpcy5ncmFwaC51cGRhdGVDZWxsU2l6ZShhKX1maW5hbGx5e2IuZW5kVXBkYXRlKCl9fSk7Cm09bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmhpZGVQcm9wZXJ0aWVzKCl9KTtkLmFkZEJ1dHRvbnMoYyxtKTtyZXR1cm4gZC50YWJsZX1yZXR1cm4gbnVsbH07bXhFZGl0b3IucHJvdG90eXBlLmhpZGVQcm9wZXJ0aWVzPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5wcm9wZXJ0aWVzJiYodGhpcy5wcm9wZXJ0aWVzLmRlc3Ryb3koKSx0aGlzLnByb3BlcnRpZXM9bnVsbCl9OwpteEVkaXRvci5wcm90b3R5cGUuc2hvd1Rhc2tzPWZ1bmN0aW9uKCl7aWYobnVsbD09dGhpcy50YXNrcyl7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7YS5zdHlsZS5wYWRkaW5nPSI0cHgiO2Euc3R5bGUucGFkZGluZ0xlZnQ9IjIwcHgiO3ZhciBiPWRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGgsYj1uZXcgbXhXaW5kb3cobXhSZXNvdXJjZXMuZ2V0KHRoaXMudGFza3NSZXNvdXJjZSl8fHRoaXMudGFza3NSZXNvdXJjZSxhLGItMjIwLHRoaXMudGFza3NUb3AsMjAwKTtiLnNldENsb3NhYmxlKCEwKTtiLmRlc3Ryb3lPbkNsb3NlPSExO3ZhciBjPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe214RXZlbnQucmVsZWFzZShhKTthLmlubmVySFRNTD0iIjt0aGlzLmNyZWF0ZVRhc2tzKGEpfSk7dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmFkZExpc3RlbmVyKG14RXZlbnQuQ0hBTkdFLGMpO3RoaXMuZ3JhcGguZ2V0U2VsZWN0aW9uTW9kZWwoKS5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSwKYyk7dGhpcy5ncmFwaC5hZGRMaXN0ZW5lcihteEV2ZW50LlJPT1QsYyk7bnVsbCE9dGhpcy50YXNrc1dpbmRvd0ltYWdlJiZiLnNldEltYWdlKHRoaXMudGFza3NXaW5kb3dJbWFnZSk7dGhpcy50YXNrcz1iO3RoaXMuY3JlYXRlVGFza3MoYSl9dGhpcy50YXNrcy5zZXRWaXNpYmxlKCEwKX07bXhFZGl0b3IucHJvdG90eXBlLnJlZnJlc2hUYXNrcz1mdW5jdGlvbihhKXtudWxsIT10aGlzLnRhc2tzJiYoYT10aGlzLnRhc2tzLmNvbnRlbnQsbXhFdmVudC5yZWxlYXNlKGEpLGEuaW5uZXJIVE1MPSIiLHRoaXMuY3JlYXRlVGFza3MoYSkpfTtteEVkaXRvci5wcm90b3R5cGUuY3JlYXRlVGFza3M9ZnVuY3Rpb24oYSl7fTsKbXhFZGl0b3IucHJvdG90eXBlLnNob3dIZWxwPWZ1bmN0aW9uKGEpe2lmKG51bGw9PXRoaXMuaGVscCl7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaWZyYW1lIik7Yi5zZXRBdHRyaWJ1dGUoInNyYyIsbXhSZXNvdXJjZXMuZ2V0KCJ1cmxIZWxwIil8fHRoaXMudXJsSGVscCk7Yi5zZXRBdHRyaWJ1dGUoImhlaWdodCIsIjEwMCUiKTtiLnNldEF0dHJpYnV0ZSgid2lkdGgiLCIxMDAlIik7Yi5zZXRBdHRyaWJ1dGUoImZyYW1lQm9yZGVyIiwiMCIpO2Iuc3R5bGUuYmFja2dyb3VuZENvbG9yPSJ3aGl0ZSI7YT1kb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoO3ZhciBjPWRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LGQ9bmV3IG14V2luZG93KG14UmVzb3VyY2VzLmdldCh0aGlzLmhlbHBSZXNvdXJjZSl8fHRoaXMuaGVscFJlc291cmNlLGIsKGEtdGhpcy5oZWxwV2lkdGgpLzIsKGMtdGhpcy5oZWxwSGVpZ2h0KS8KMyx0aGlzLmhlbHBXaWR0aCx0aGlzLmhlbHBIZWlnaHQpO2Quc2V0TWF4aW1pemFibGUoITApO2Quc2V0Q2xvc2FibGUoITApO2QuZGVzdHJveU9uQ2xvc2U9ITE7ZC5zZXRSZXNpemFibGUoITApO251bGwhPXRoaXMuaGVscFdpbmRvd0ltYWdlJiZkLnNldEltYWdlKHRoaXMuaGVscFdpbmRvd0ltYWdlKTtteENsaWVudC5JU19OUyYmKGE9ZnVuY3Rpb24oYSl7Yi5zZXRBdHRyaWJ1dGUoImhlaWdodCIsZC5kaXYub2Zmc2V0SGVpZ2h0LTI2KyJweCIpfSxkLmFkZExpc3RlbmVyKG14RXZlbnQuUkVTSVpFX0VORCxhKSxkLmFkZExpc3RlbmVyKG14RXZlbnQuTUFYSU1JWkUsYSksZC5hZGRMaXN0ZW5lcihteEV2ZW50Lk5PUk1BTElaRSxhKSxkLmFkZExpc3RlbmVyKG14RXZlbnQuU0hPVyxhKSk7dGhpcy5oZWxwPWR9dGhpcy5oZWxwLnNldFZpc2libGUoITApfTsKbXhFZGl0b3IucHJvdG90eXBlLnNob3dPdXRsaW5lPWZ1bmN0aW9uKCl7aWYobnVsbD09dGhpcy5vdXRsaW5lKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTthLnN0eWxlLm92ZXJmbG93PSJoaWRkZW4iO2Euc3R5bGUucG9zaXRpb249InJlbGF0aXZlIjthLnN0eWxlLndpZHRoPSIxMDAlIjthLnN0eWxlLmhlaWdodD0iMTAwJSI7YS5zdHlsZS5iYWNrZ3JvdW5kPSJ3aGl0ZSI7YS5zdHlsZS5jdXJzb3I9Im1vdmUiOzg9PWRvY3VtZW50LmRvY3VtZW50TW9kZSYmKGEuc3R5bGUuZmlsdGVyPSJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuYWxwaGEob3BhY2l0eT0xMDApIik7dmFyIGI9bmV3IG14V2luZG93KG14UmVzb3VyY2VzLmdldCh0aGlzLm91dGxpbmVSZXNvdXJjZSl8fHRoaXMub3V0bGluZVJlc291cmNlLGEsNjAwLDQ4MCwyMDAsMjAwLCExKSxjPW5ldyBteE91dGxpbmUodGhpcy5ncmFwaCxhKTtiLnNldENsb3NhYmxlKCEwKTtiLnNldFJlc2l6YWJsZSghMCk7CmIuZGVzdHJveU9uQ2xvc2U9ITE7Yi5hZGRMaXN0ZW5lcihteEV2ZW50LlJFU0laRV9FTkQsZnVuY3Rpb24oKXtjLnVwZGF0ZSgpfSk7dGhpcy5vdXRsaW5lPWI7dGhpcy5vdXRsaW5lLm91dGxpbmU9Y310aGlzLm91dGxpbmUuc2V0VmlzaWJsZSghMCk7dGhpcy5vdXRsaW5lLm91dGxpbmUudXBkYXRlKCEwKX07bXhFZGl0b3IucHJvdG90eXBlLnNldE1vZGU9ZnVuY3Rpb24oYSl7InNlbGVjdCI9PWE/KHRoaXMuZ3JhcGgucGFubmluZ0hhbmRsZXIudXNlTGVmdEJ1dHRvbkZvclBhbm5pbmc9ITEsdGhpcy5ncmFwaC5zZXRDb25uZWN0YWJsZSghMSkpOiJjb25uZWN0Ij09YT8odGhpcy5ncmFwaC5wYW5uaW5nSGFuZGxlci51c2VMZWZ0QnV0dG9uRm9yUGFubmluZz0hMSx0aGlzLmdyYXBoLnNldENvbm5lY3RhYmxlKCEwKSk6InBhbiI9PWEmJih0aGlzLmdyYXBoLnBhbm5pbmdIYW5kbGVyLnVzZUxlZnRCdXR0b25Gb3JQYW5uaW5nPSEwLHRoaXMuZ3JhcGguc2V0Q29ubmVjdGFibGUoITEpKX07Cm14RWRpdG9yLnByb3RvdHlwZS5jcmVhdGVQb3B1cE1lbnU9ZnVuY3Rpb24oYSxiLGMpe3RoaXMucG9wdXBIYW5kbGVyLmNyZWF0ZU1lbnUodGhpcyxhLGIsYyl9O214RWRpdG9yLnByb3RvdHlwZS5jcmVhdGVFZGdlPWZ1bmN0aW9uKGEsYil7dmFyIGM7aWYobnVsbCE9dGhpcy5kZWZhdWx0RWRnZSljPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5jbG9uZUNlbGwodGhpcy5kZWZhdWx0RWRnZSk7ZWxzZXtjPW5ldyBteENlbGwoIiIpO2Muc2V0RWRnZSghMCk7dmFyIGQ9bmV3IG14R2VvbWV0cnk7ZC5yZWxhdGl2ZT0hMDtjLnNldEdlb21ldHJ5KGQpfWQ9dGhpcy5nZXRFZGdlU3R5bGUoKTtudWxsIT1kJiZjLnNldFN0eWxlKGQpO3JldHVybiBjfTtteEVkaXRvci5wcm90b3R5cGUuZ2V0RWRnZVN0eWxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVmYXVsdEVkZ2VTdHlsZX07Cm14RWRpdG9yLnByb3RvdHlwZS5jb25zdW1lQ3ljbGVBdHRyaWJ1dGU9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPXRoaXMuY3ljbGVBdHRyaWJ1dGVWYWx1ZXMmJjA8dGhpcy5jeWNsZUF0dHJpYnV0ZVZhbHVlcy5sZW5ndGgmJnRoaXMuZ3JhcGguaXNTd2ltbGFuZShhKT90aGlzLmN5Y2xlQXR0cmlidXRlVmFsdWVzW3RoaXMuY3ljbGVBdHRyaWJ1dGVJbmRleCsrJXRoaXMuY3ljbGVBdHRyaWJ1dGVWYWx1ZXMubGVuZ3RoXTpudWxsfTtteEVkaXRvci5wcm90b3R5cGUuY3ljbGVBdHRyaWJ1dGU9ZnVuY3Rpb24oYSl7aWYobnVsbCE9dGhpcy5jeWNsZUF0dHJpYnV0ZU5hbWUpe3ZhciBiPXRoaXMuY29uc3VtZUN5Y2xlQXR0cmlidXRlKGEpO251bGwhPWImJmEuc2V0U3R5bGUoYS5nZXRTdHlsZSgpKyI7Iit0aGlzLmN5Y2xlQXR0cmlidXRlTmFtZSsiPSIrYil9fTsKbXhFZGl0b3IucHJvdG90eXBlLmFkZFZlcnRleD1mdW5jdGlvbihhLGIsYyxkKXtmb3IodmFyIGU9dGhpcy5ncmFwaC5nZXRNb2RlbCgpO251bGwhPWEmJiF0aGlzLmdyYXBoLmlzVmFsaWREcm9wVGFyZ2V0KGEpOylhPWUuZ2V0UGFyZW50KGEpO2E9bnVsbCE9YT9hOnRoaXMuZ3JhcGguZ2V0U3dpbWxhbmVBdChjLGQpO3ZhciBmPXRoaXMuZ3JhcGguZ2V0VmlldygpLnNjYWxlLGc9ZS5nZXRHZW9tZXRyeShiKSxrPWUuZ2V0R2VvbWV0cnkoYSk7aWYodGhpcy5ncmFwaC5pc1N3aW1sYW5lKGIpJiYhdGhpcy5ncmFwaC5zd2ltbGFuZU5lc3RpbmcpYT1udWxsO2Vsc2V7aWYobnVsbD09YSYmdGhpcy5zd2ltbGFuZVJlcXVpcmVkKXJldHVybiBudWxsO2lmKG51bGwhPWEmJm51bGwhPWspe3ZhciBsPXRoaXMuZ3JhcGguZ2V0VmlldygpLmdldFN0YXRlKGEpO2lmKG51bGwhPWwpe2lmKGMtPWwub3JpZ2luLngqZixkLT1sLm9yaWdpbi55KmYsdGhpcy5ncmFwaC5pc0NvbnN0cmFpbmVkTW92aW5nKXt2YXIgaz0KZy53aWR0aCxtPWcuaGVpZ2h0LG49bC54K2wud2lkdGg7YytrPm4mJihjLT1jK2stbik7bj1sLnkrbC5oZWlnaHQ7ZCttPm4mJihkLT1kK20tbil9fWVsc2UgbnVsbCE9ayYmKGMtPWsueCpmLGQtPWsueSpmKX19Zz1nLmNsb25lKCk7Zy54PXRoaXMuZ3JhcGguc25hcChjL2YtdGhpcy5ncmFwaC5nZXRWaWV3KCkudHJhbnNsYXRlLngtdGhpcy5ncmFwaC5ncmlkU2l6ZS8yKTtnLnk9dGhpcy5ncmFwaC5zbmFwKGQvZi10aGlzLmdyYXBoLmdldFZpZXcoKS50cmFuc2xhdGUueS10aGlzLmdyYXBoLmdyaWRTaXplLzIpO2Iuc2V0R2VvbWV0cnkoZyk7bnVsbD09YSYmKGE9dGhpcy5ncmFwaC5nZXREZWZhdWx0UGFyZW50KCkpO3RoaXMuY3ljbGVBdHRyaWJ1dGUoYik7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5CRUZPUkVfQUREX1ZFUlRFWCwidmVydGV4IixiLCJwYXJlbnQiLGEpKTtlLmJlZ2luVXBkYXRlKCk7dHJ5e2I9dGhpcy5ncmFwaC5hZGRDZWxsKGIsCmEpLG51bGwhPWImJih0aGlzLmdyYXBoLmNvbnN0cmFpbkNoaWxkKGIpLHRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuQUREX1ZFUlRFWCwidmVydGV4IixiKSkpfWZpbmFsbHl7ZS5lbmRVcGRhdGUoKX1udWxsIT1iJiYodGhpcy5ncmFwaC5zZXRTZWxlY3Rpb25DZWxsKGIpLHRoaXMuZ3JhcGguc2Nyb2xsQ2VsbFRvVmlzaWJsZShiKSx0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkFGVEVSX0FERF9WRVJURVgsInZlcnRleCIsYikpKTtyZXR1cm4gYn07Cm14RWRpdG9yLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5kZXN0cm95ZWR8fCh0aGlzLmRlc3Ryb3llZD0hMCxudWxsIT10aGlzLnRhc2tzJiZ0aGlzLnRhc2tzLmRlc3Ryb3koKSxudWxsIT10aGlzLm91dGxpbmUmJnRoaXMub3V0bGluZS5kZXN0cm95KCksbnVsbCE9dGhpcy5wcm9wZXJ0aWVzJiZ0aGlzLnByb3BlcnRpZXMuZGVzdHJveSgpLG51bGwhPXRoaXMua2V5SGFuZGxlciYmdGhpcy5rZXlIYW5kbGVyLmRlc3Ryb3koKSxudWxsIT10aGlzLnJ1YmJlcmJhbmQmJnRoaXMucnViYmVyYmFuZC5kZXN0cm95KCksbnVsbCE9dGhpcy50b29sYmFyJiZ0aGlzLnRvb2xiYXIuZGVzdHJveSgpLG51bGwhPXRoaXMuZ3JhcGgmJnRoaXMuZ3JhcGguZGVzdHJveSgpLHRoaXMudGVtcGxhdGVzPXRoaXMuc3RhdHVzPW51bGwpfTsKdmFyIG14Q29kZWNSZWdpc3RyeT17Y29kZWNzOltdLGFsaWFzZXM6W10scmVnaXN0ZXI6ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSl7dmFyIGI9YS5nZXROYW1lKCk7bXhDb2RlY1JlZ2lzdHJ5LmNvZGVjc1tiXT1hO3ZhciBjPW14VXRpbHMuZ2V0RnVuY3Rpb25OYW1lKGEudGVtcGxhdGUuY29uc3RydWN0b3IpO2MhPWImJm14Q29kZWNSZWdpc3RyeS5hZGRBbGlhcyhjLGIpfXJldHVybiBhfSxhZGRBbGlhczpmdW5jdGlvbihhLGIpe214Q29kZWNSZWdpc3RyeS5hbGlhc2VzW2FdPWJ9LGdldENvZGVjOmZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7aWYobnVsbCE9YSl7dmFyIGI9bXhVdGlscy5nZXRGdW5jdGlvbk5hbWUoYSksYz1teENvZGVjUmVnaXN0cnkuYWxpYXNlc1tiXTtudWxsIT1jJiYoYj1jKTtiPW14Q29kZWNSZWdpc3RyeS5jb2RlY3NbYl07aWYobnVsbD09Yil0cnl7Yj1uZXcgbXhPYmplY3RDb2RlYyhuZXcgYSksbXhDb2RlY1JlZ2lzdHJ5LnJlZ2lzdGVyKGIpfWNhdGNoKGQpe319cmV0dXJuIGJ9fTsKZnVuY3Rpb24gbXhDb2RlYyhhKXt0aGlzLmRvY3VtZW50PWF8fG14VXRpbHMuY3JlYXRlWG1sRG9jdW1lbnQoKTt0aGlzLm9iamVjdHM9W119bXhDb2RlYy5wcm90b3R5cGUuZG9jdW1lbnQ9bnVsbDtteENvZGVjLnByb3RvdHlwZS5vYmplY3RzPW51bGw7bXhDb2RlYy5wcm90b3R5cGUuZWxlbWVudHM9bnVsbDtteENvZGVjLnByb3RvdHlwZS5lbmNvZGVEZWZhdWx0cz0hMTtteENvZGVjLnByb3RvdHlwZS5wdXRPYmplY3Q9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5vYmplY3RzW2FdPWJ9O214Q29kZWMucHJvdG90eXBlLmdldE9iamVjdD1mdW5jdGlvbihhKXt2YXIgYj1udWxsO251bGwhPWEmJihiPXRoaXMub2JqZWN0c1thXSxudWxsPT1iJiYoYj10aGlzLmxvb2t1cChhKSxudWxsPT1iJiYoYT10aGlzLmdldEVsZW1lbnRCeUlkKGEpLG51bGwhPWEmJihiPXRoaXMuZGVjb2RlKGEpKSkpKTtyZXR1cm4gYn07bXhDb2RlYy5wcm90b3R5cGUubG9va3VwPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsfTsKbXhDb2RlYy5wcm90b3R5cGUuZ2V0RWxlbWVudEJ5SWQ9ZnVuY3Rpb24oYSl7dGhpcy51cGRhdGVFbGVtZW50cygpO3JldHVybiB0aGlzLmVsZW1lbnRzW2FdfTtteENvZGVjLnByb3RvdHlwZS51cGRhdGVFbGVtZW50cz1mdW5jdGlvbigpe251bGw9PXRoaXMuZWxlbWVudHMmJih0aGlzLmVsZW1lbnRzPXt9LG51bGwhPXRoaXMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiZ0aGlzLmFkZEVsZW1lbnQodGhpcy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKX07Cm14Q29kZWMucHJvdG90eXBlLmFkZEVsZW1lbnQ9ZnVuY3Rpb24oYSl7aWYoYS5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVCl7dmFyIGI9YS5nZXRBdHRyaWJ1dGUoImlkIik7aWYobnVsbCE9YilpZihudWxsPT10aGlzLmVsZW1lbnRzW2JdKXRoaXMuZWxlbWVudHNbYl09YTtlbHNlIGlmKHRoaXMuZWxlbWVudHNbYl0hPWEpdGhyb3cgRXJyb3IoYisiOiBEdXBsaWNhdGUgSUQiKTt9Zm9yKGE9YS5maXJzdENoaWxkO251bGwhPWE7KXRoaXMuYWRkRWxlbWVudChhKSxhPWEubmV4dFNpYmxpbmd9O214Q29kZWMucHJvdG90eXBlLmdldElkPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7bnVsbCE9YSYmKGI9dGhpcy5yZWZlcmVuY2UoYSksbnVsbD09YiYmYSBpbnN0YW5jZW9mIG14Q2VsbCYmKGI9YS5nZXRJZCgpLG51bGw9PWImJihiPW14Q2VsbFBhdGguY3JlYXRlKGEpLDA9PWIubGVuZ3RoJiYoYj0icm9vdCIpKSkpO3JldHVybiBifTsKbXhDb2RlYy5wcm90b3R5cGUucmVmZXJlbmNlPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsfTtteENvZGVjLnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbDtpZihudWxsIT1hJiZudWxsIT1hLmNvbnN0cnVjdG9yKXt2YXIgYz1teENvZGVjUmVnaXN0cnkuZ2V0Q29kZWMoYS5jb25zdHJ1Y3Rvcik7bnVsbCE9Yz9iPWMuZW5jb2RlKHRoaXMsYSk6bXhVdGlscy5pc05vZGUoYSk/Yj1teFV0aWxzLmltcG9ydE5vZGUodGhpcy5kb2N1bWVudCxhLCEwKTpteExvZy53YXJuKCJteENvZGVjLmVuY29kZTogTm8gY29kZWMgZm9yICIrbXhVdGlscy5nZXRGdW5jdGlvbk5hbWUoYS5jb25zdHJ1Y3RvcikpfXJldHVybiBifTsKbXhDb2RlYy5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKGEsYil7dGhpcy51cGRhdGVFbGVtZW50cygpO3ZhciBjPW51bGw7aWYobnVsbCE9YSYmYS5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVCl7Yz1udWxsO3RyeXtjPXdpbmRvd1thLm5vZGVOYW1lXX1jYXRjaChkKXt9Yz1teENvZGVjUmVnaXN0cnkuZ2V0Q29kZWMoYyk7bnVsbCE9Yz9jPWMuZGVjb2RlKHRoaXMsYSxiKTooYz1hLmNsb25lTm9kZSghMCksYy5yZW1vdmVBdHRyaWJ1dGUoImFzIikpfXJldHVybiBjfTtteENvZGVjLnByb3RvdHlwZS5lbmNvZGVDZWxsPWZ1bmN0aW9uKGEsYixjKXtiLmFwcGVuZENoaWxkKHRoaXMuZW5jb2RlKGEpKTtpZihudWxsPT1jfHxjKXtjPWEuZ2V0Q2hpbGRDb3VudCgpO2Zvcih2YXIgZD0wO2Q8YztkKyspdGhpcy5lbmNvZGVDZWxsKGEuZ2V0Q2hpbGRBdChkKSxiKX19OwpteENvZGVjLnByb3RvdHlwZS5pc0NlbGxDb2RlYz1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YSYmImZ1bmN0aW9uIj09dHlwZW9mIGEuaXNDZWxsQ29kZWM/YS5pc0NlbGxDb2RlYygpOiExfTtteENvZGVjLnByb3RvdHlwZS5kZWNvZGVDZWxsPWZ1bmN0aW9uKGEsYil7Yj1udWxsIT1iP2I6ITA7dmFyIGM9bnVsbDtpZihudWxsIT1hJiZhLm5vZGVUeXBlPT1teENvbnN0YW50cy5OT0RFVFlQRV9FTEVNRU5UKXtjPW14Q29kZWNSZWdpc3RyeS5nZXRDb2RlYyhhLm5vZGVOYW1lKTtpZighdGhpcy5pc0NlbGxDb2RlYyhjKSlmb3IodmFyIGQ9YS5maXJzdENoaWxkO251bGwhPWQmJiF0aGlzLmlzQ2VsbENvZGVjKGMpOyljPW14Q29kZWNSZWdpc3RyeS5nZXRDb2RlYyhkLm5vZGVOYW1lKSxkPWQubmV4dFNpYmxpbmc7dGhpcy5pc0NlbGxDb2RlYyhjKXx8KGM9bXhDb2RlY1JlZ2lzdHJ5LmdldENvZGVjKG14Q2VsbCkpO2M9Yy5kZWNvZGUodGhpcyxhKTtiJiZ0aGlzLmluc2VydEludG9HcmFwaChjKX1yZXR1cm4gY307Cm14Q29kZWMucHJvdG90eXBlLmluc2VydEludG9HcmFwaD1mdW5jdGlvbihhKXt2YXIgYj1hLnBhcmVudCxjPWEuZ2V0VGVybWluYWwoITApLGQ9YS5nZXRUZXJtaW5hbCghMSk7YS5zZXRUZXJtaW5hbChudWxsLCExKTthLnNldFRlcm1pbmFsKG51bGwsITApO2EucGFyZW50PW51bGw7aWYobnVsbCE9Yil7aWYoYj09YSl0aHJvdyBFcnJvcihiLmlkKyI6IFNlbGYgUmVmZXJlbmNlIik7Yi5pbnNlcnQoYSl9bnVsbCE9YyYmYy5pbnNlcnRFZGdlKGEsITApO251bGwhPWQmJmQuaW5zZXJ0RWRnZShhLCExKX07bXhDb2RlYy5wcm90b3R5cGUuc2V0QXR0cmlidXRlPWZ1bmN0aW9uKGEsYixjKXtudWxsIT1iJiZudWxsIT1jJiZhLnNldEF0dHJpYnV0ZShiLGMpfTsKZnVuY3Rpb24gbXhPYmplY3RDb2RlYyhhLGIsYyxkKXt0aGlzLnRlbXBsYXRlPWE7dGhpcy5leGNsdWRlPW51bGwhPWI/YjpbXTt0aGlzLmlkcmVmcz1udWxsIT1jP2M6W107dGhpcy5tYXBwaW5nPW51bGwhPWQ/ZDpbXTt0aGlzLnJldmVyc2U9e307Zm9yKHZhciBlIGluIHRoaXMubWFwcGluZyl0aGlzLnJldmVyc2VbdGhpcy5tYXBwaW5nW2VdXT1lfW14T2JqZWN0Q29kZWMuYWxsb3dFdmFsPSExO214T2JqZWN0Q29kZWMucHJvdG90eXBlLnRlbXBsYXRlPW51bGw7bXhPYmplY3RDb2RlYy5wcm90b3R5cGUuZXhjbHVkZT1udWxsO214T2JqZWN0Q29kZWMucHJvdG90eXBlLmlkcmVmcz1udWxsO214T2JqZWN0Q29kZWMucHJvdG90eXBlLm1hcHBpbmc9bnVsbDtteE9iamVjdENvZGVjLnByb3RvdHlwZS5yZXZlcnNlPW51bGw7bXhPYmplY3RDb2RlYy5wcm90b3R5cGUuZ2V0TmFtZT1mdW5jdGlvbigpe3JldHVybiBteFV0aWxzLmdldEZ1bmN0aW9uTmFtZSh0aGlzLnRlbXBsYXRlLmNvbnN0cnVjdG9yKX07Cm14T2JqZWN0Q29kZWMucHJvdG90eXBlLmNsb25lVGVtcGxhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHRoaXMudGVtcGxhdGUuY29uc3RydWN0b3J9O214T2JqZWN0Q29kZWMucHJvdG90eXBlLmdldEZpZWxkTmFtZT1mdW5jdGlvbihhKXtpZihudWxsIT1hKXt2YXIgYj10aGlzLnJldmVyc2VbYV07bnVsbCE9YiYmKGE9Yil9cmV0dXJuIGF9O214T2JqZWN0Q29kZWMucHJvdG90eXBlLmdldEF0dHJpYnV0ZU5hbWU9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSl7dmFyIGI9dGhpcy5tYXBwaW5nW2FdO251bGwhPWImJihhPWIpfXJldHVybiBhfTtteE9iamVjdENvZGVjLnByb3RvdHlwZS5pc0V4Y2x1ZGVkPWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBiPT1teE9iamVjdElkZW50aXR5LkZJRUxEX05BTUV8fDA8PW14VXRpbHMuaW5kZXhPZih0aGlzLmV4Y2x1ZGUsYil9OwpteE9iamVjdENvZGVjLnByb3RvdHlwZS5pc1JlZmVyZW5jZT1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gMDw9bXhVdGlscy5pbmRleE9mKHRoaXMuaWRyZWZzLGIpfTtteE9iamVjdENvZGVjLnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5nZXROYW1lKCkpO2I9dGhpcy5iZWZvcmVFbmNvZGUoYSxiLGMpO3RoaXMuZW5jb2RlT2JqZWN0KGEsYixjKTtyZXR1cm4gdGhpcy5hZnRlckVuY29kZShhLGIsYyl9O214T2JqZWN0Q29kZWMucHJvdG90eXBlLmVuY29kZU9iamVjdD1mdW5jdGlvbihhLGIsYyl7YS5zZXRBdHRyaWJ1dGUoYywiaWQiLGEuZ2V0SWQoYikpO2Zvcih2YXIgZCBpbiBiKXt2YXIgZT1kLGY9YltlXTtudWxsPT1mfHx0aGlzLmlzRXhjbHVkZWQoYixlLGYsITApfHwobXhVdGlscy5pc0ludGVnZXIoZSkmJihlPW51bGwpLHRoaXMuZW5jb2RlVmFsdWUoYSxiLGUsZixjKSl9fTsKbXhPYmplY3RDb2RlYy5wcm90b3R5cGUuZW5jb2RlVmFsdWU9ZnVuY3Rpb24oYSxiLGMsZCxlKXtpZihudWxsIT1kKXtpZih0aGlzLmlzUmVmZXJlbmNlKGIsYyxkLCEwKSl7dmFyIGY9YS5nZXRJZChkKTtpZihudWxsPT1mKXtteExvZy53YXJuKCJteE9iamVjdENvZGVjLmVuY29kZTogTm8gSUQgZm9yICIrdGhpcy5nZXROYW1lKCkrIi4iK2MrIj0iK2QpO3JldHVybn1kPWZ9Zj10aGlzLnRlbXBsYXRlW2NdO2lmKG51bGw9PWN8fGEuZW5jb2RlRGVmYXVsdHN8fGYhPWQpYz10aGlzLmdldEF0dHJpYnV0ZU5hbWUoYyksdGhpcy53cml0ZUF0dHJpYnV0ZShhLGIsYyxkLGUpfX07bXhPYmplY3RDb2RlYy5wcm90b3R5cGUud3JpdGVBdHRyaWJ1dGU9ZnVuY3Rpb24oYSxiLGMsZCxlKXsib2JqZWN0IiE9dHlwZW9mIGQ/dGhpcy53cml0ZVByaW1pdGl2ZUF0dHJpYnV0ZShhLGIsYyxkLGUpOnRoaXMud3JpdGVDb21wbGV4QXR0cmlidXRlKGEsYixjLGQsZSl9OwpteE9iamVjdENvZGVjLnByb3RvdHlwZS53cml0ZVByaW1pdGl2ZUF0dHJpYnV0ZT1mdW5jdGlvbihhLGIsYyxkLGUpe2Q9dGhpcy5jb252ZXJ0QXR0cmlidXRlVG9YbWwoYSxiLGMsZCxlKTtudWxsPT1jPyhiPWEuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYWRkIiksImZ1bmN0aW9uIj09dHlwZW9mIGQ/Yi5hcHBlbmRDaGlsZChhLmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGQpKTphLnNldEF0dHJpYnV0ZShiLCJ2YWx1ZSIsZCksZS5hcHBlbmRDaGlsZChiKSk6ImZ1bmN0aW9uIiE9dHlwZW9mIGQmJmEuc2V0QXR0cmlidXRlKGUsYyxkKX07Cm14T2JqZWN0Q29kZWMucHJvdG90eXBlLndyaXRlQ29tcGxleEF0dHJpYnV0ZT1mdW5jdGlvbihhLGIsYyxkLGUpe2E9YS5lbmNvZGUoZCk7bnVsbCE9YT8obnVsbCE9YyYmYS5zZXRBdHRyaWJ1dGUoImFzIixjKSxlLmFwcGVuZENoaWxkKGEpKTpteExvZy53YXJuKCJteE9iamVjdENvZGVjLmVuY29kZTogTm8gbm9kZSBmb3IgIit0aGlzLmdldE5hbWUoKSsiLiIrYysiOiAiK2QpfTtteE9iamVjdENvZGVjLnByb3RvdHlwZS5jb252ZXJ0QXR0cmlidXRlVG9YbWw9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5pc0Jvb2xlYW5BdHRyaWJ1dGUoYSxiLGMsZCkmJihkPTE9PWQ/IjEiOiIwIik7cmV0dXJuIGR9O214T2JqZWN0Q29kZWMucHJvdG90eXBlLmlzQm9vbGVhbkF0dHJpYnV0ZT1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4idW5kZWZpbmVkIj09dHlwZW9mIGQubGVuZ3RoJiYoMT09ZHx8MD09ZCl9OwpteE9iamVjdENvZGVjLnByb3RvdHlwZS5jb252ZXJ0QXR0cmlidXRlRnJvbVhtbD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9Yi52YWx1ZTt0aGlzLmlzTnVtZXJpY0F0dHJpYnV0ZShhLGIsYykmJihkPXBhcnNlRmxvYXQoZCksaXNOYU4oZCl8fCFpc0Zpbml0ZShkKSkmJihkPTApO3JldHVybiBkfTtteE9iamVjdENvZGVjLnByb3RvdHlwZS5pc051bWVyaWNBdHRyaWJ1dGU9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBjLmNvbnN0cnVjdG9yPT1teEdlb21ldHJ5JiYoIngiPT1iLm5hbWV8fCJ5Ij09Yi5uYW1lfHwid2lkdGgiPT1iLm5hbWV8fCJoZWlnaHQiPT1iLm5hbWUpfHxjLmNvbnN0cnVjdG9yPT1teFBvaW50JiYoIngiPT1iLm5hbWV8fCJ5Ij09Yi5uYW1lKXx8bXhVdGlscy5pc051bWVyaWMoYi52YWx1ZSl9O214T2JqZWN0Q29kZWMucHJvdG90eXBlLmJlZm9yZUVuY29kZT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGJ9OwpteE9iamVjdENvZGVjLnByb3RvdHlwZS5hZnRlckVuY29kZT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGN9O214T2JqZWN0Q29kZWMucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9Yi5nZXRBdHRyaWJ1dGUoImlkIiksZT1hLm9iamVjdHNbZF07bnVsbD09ZSYmKGU9Y3x8dGhpcy5jbG9uZVRlbXBsYXRlKCksbnVsbCE9ZCYmYS5wdXRPYmplY3QoZCxlKSk7Yj10aGlzLmJlZm9yZURlY29kZShhLGIsZSk7dGhpcy5kZWNvZGVOb2RlKGEsYixlKTtyZXR1cm4gdGhpcy5hZnRlckRlY29kZShhLGIsZSl9O214T2JqZWN0Q29kZWMucHJvdG90eXBlLmRlY29kZU5vZGU9ZnVuY3Rpb24oYSxiLGMpe251bGwhPWImJih0aGlzLmRlY29kZUF0dHJpYnV0ZXMoYSxiLGMpLHRoaXMuZGVjb2RlQ2hpbGRyZW4oYSxiLGMpKX07Cm14T2JqZWN0Q29kZWMucHJvdG90eXBlLmRlY29kZUF0dHJpYnV0ZXM9ZnVuY3Rpb24oYSxiLGMpe2I9Yi5hdHRyaWJ1dGVzO2lmKG51bGwhPWIpZm9yKHZhciBkPTA7ZDxiLmxlbmd0aDtkKyspdGhpcy5kZWNvZGVBdHRyaWJ1dGUoYSxiW2RdLGMpfTtteE9iamVjdENvZGVjLnByb3RvdHlwZS5pc0lnbm9yZWRBdHRyaWJ1dGU9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiJhcyI9PWIubm9kZU5hbWV8fCJpZCI9PWIubm9kZU5hbWV9OwpteE9iamVjdENvZGVjLnByb3RvdHlwZS5kZWNvZGVBdHRyaWJ1dGU9ZnVuY3Rpb24oYSxiLGMpe2lmKCF0aGlzLmlzSWdub3JlZEF0dHJpYnV0ZShhLGIsYykpe3ZhciBkPWIubm9kZU5hbWU7Yj10aGlzLmNvbnZlcnRBdHRyaWJ1dGVGcm9tWG1sKGEsYixjKTt2YXIgZT10aGlzLmdldEZpZWxkTmFtZShkKTtpZih0aGlzLmlzUmVmZXJlbmNlKGMsZSxiLCExKSl7YT1hLmdldE9iamVjdChiKTtpZihudWxsPT1hKXtteExvZy53YXJuKCJteE9iamVjdENvZGVjLmRlY29kZTogTm8gb2JqZWN0IGZvciAiK3RoaXMuZ2V0TmFtZSgpKyIuIitkKyI9IitiKTtyZXR1cm59Yj1hfXRoaXMuaXNFeGNsdWRlZChjLGQsYiwhMSl8fChjW2RdPWIpfX07Cm14T2JqZWN0Q29kZWMucHJvdG90eXBlLmRlY29kZUNoaWxkcmVuPWZ1bmN0aW9uKGEsYixjKXtmb3IoYj1iLmZpcnN0Q2hpbGQ7bnVsbCE9Yjspe3ZhciBkPWIubmV4dFNpYmxpbmc7Yi5ub2RlVHlwZSE9bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVHx8dGhpcy5wcm9jZXNzSW5jbHVkZShhLGIsYyl8fHRoaXMuZGVjb2RlQ2hpbGQoYSxiLGMpO2I9ZH19OwpteE9iamVjdENvZGVjLnByb3RvdHlwZS5kZWNvZGVDaGlsZD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5nZXRGaWVsZE5hbWUoYi5nZXRBdHRyaWJ1dGUoImFzIikpO2lmKG51bGw9PWR8fCF0aGlzLmlzRXhjbHVkZWQoYyxkLGIsITEpKXt2YXIgZT10aGlzLmdldEZpZWxkVGVtcGxhdGUoYyxkLGIpOyJhZGQiPT1iLm5vZGVOYW1lPyhhPWIuZ2V0QXR0cmlidXRlKCJ2YWx1ZSIpLG51bGw9PWEmJm14T2JqZWN0Q29kZWMuYWxsb3dFdmFsJiYoYT1teFV0aWxzLmV2YWwobXhVdGlscy5nZXRUZXh0Q29udGVudChiKSkpKTphPWEuZGVjb2RlKGIsZSk7dHJ5e3RoaXMuYWRkT2JqZWN0VmFsdWUoYyxkLGEsZSl9Y2F0Y2goZil7dGhyb3cgRXJyb3IoZi5tZXNzYWdlKyIgZm9yICIrYi5ub2RlTmFtZSk7fX19OwpteE9iamVjdENvZGVjLnByb3RvdHlwZS5nZXRGaWVsZFRlbXBsYXRlPWZ1bmN0aW9uKGEsYixjKXthPWFbYl07YSBpbnN0YW5jZW9mIEFycmF5JiYwPGEubGVuZ3RoJiYoYT1udWxsKTtyZXR1cm4gYX07bXhPYmplY3RDb2RlYy5wcm90b3R5cGUuYWRkT2JqZWN0VmFsdWU9ZnVuY3Rpb24oYSxiLGMsZCl7bnVsbCE9YyYmYyE9ZCYmKG51bGwhPWImJjA8Yi5sZW5ndGg/YVtiXT1jOmEucHVzaChjKSl9O214T2JqZWN0Q29kZWMucHJvdG90eXBlLnByb2Nlc3NJbmNsdWRlPWZ1bmN0aW9uKGEsYixjKXtpZigiaW5jbHVkZSI9PWIubm9kZU5hbWUpe2I9Yi5nZXRBdHRyaWJ1dGUoIm5hbWUiKTtpZihudWxsIT1iKXRyeXt2YXIgZD1teFV0aWxzLmxvYWQoYikuZ2V0RG9jdW1lbnRFbGVtZW50KCk7bnVsbCE9ZCYmYS5kZWNvZGUoZCxjKX1jYXRjaChlKXt9cmV0dXJuITB9cmV0dXJuITF9O214T2JqZWN0Q29kZWMucHJvdG90eXBlLmJlZm9yZURlY29kZT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGJ9OwpteE9iamVjdENvZGVjLnByb3RvdHlwZS5hZnRlckRlY29kZT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGN9OwpteENvZGVjUmVnaXN0cnkucmVnaXN0ZXIoZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhPYmplY3RDb2RlYyhuZXcgbXhDZWxsLFsiY2hpbGRyZW4iLCJlZGdlcyIsIm92ZXJsYXlzIiwibXhUcmFuc2llbnQiXSxbInBhcmVudCIsInNvdXJjZSIsInRhcmdldCJdKTthLmlzQ2VsbENvZGVjPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2EuaXNOdW1lcmljQXR0cmlidXRlPWZ1bmN0aW9uKGEsYyxkKXtyZXR1cm4idmFsdWUiIT09Yy5ub2RlTmFtZSYmbXhPYmplY3RDb2RlYy5wcm90b3R5cGUuaXNOdW1lcmljQXR0cmlidXRlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07YS5pc0V4Y2x1ZGVkPWZ1bmN0aW9uKGEsYyxkLGUpe3JldHVybiBteE9iamVjdENvZGVjLnByb3RvdHlwZS5pc0V4Y2x1ZGVkLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8ZSYmInZhbHVlIj09YyYmZC5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVH07YS5hZnRlckVuY29kZT1mdW5jdGlvbihhLGMsZCl7aWYobnVsbCE9CmMudmFsdWUmJmMudmFsdWUubm9kZVR5cGU9PW14Q29uc3RhbnRzLk5PREVUWVBFX0VMRU1FTlQpe3ZhciBiPWQ7ZD1teFV0aWxzLmltcG9ydE5vZGUoYS5kb2N1bWVudCxjLnZhbHVlLCEwKTtkLmFwcGVuZENoaWxkKGIpO2E9Yi5nZXRBdHRyaWJ1dGUoImlkIik7ZC5zZXRBdHRyaWJ1dGUoImlkIixhKTtiLnJlbW92ZUF0dHJpYnV0ZSgiaWQiKX1yZXR1cm4gZH07YS5iZWZvcmVEZWNvZGU9ZnVuY3Rpb24oYSxjLGQpe3ZhciBiPWMuY2xvbmVOb2RlKCEwKSxmPXRoaXMuZ2V0TmFtZSgpO2Mubm9kZU5hbWUhPWY/KGI9Yy5nZXRFbGVtZW50c0J5VGFnTmFtZShmKVswXSxudWxsIT1iJiZiLnBhcmVudE5vZGU9PWM/KG14VXRpbHMucmVtb3ZlV2hpdGVzcGFjZShiLCEwKSxteFV0aWxzLnJlbW92ZVdoaXRlc3BhY2UoYiwhMSksYi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpKTpiPW51bGwsZC52YWx1ZT1jLmNsb25lTm9kZSghMCksYz1kLnZhbHVlLmdldEF0dHJpYnV0ZSgiaWQiKSxudWxsIT0KYyYmKGQuc2V0SWQoYyksZC52YWx1ZS5yZW1vdmVBdHRyaWJ1dGUoImlkIikpKTpkLnNldElkKGMuZ2V0QXR0cmlidXRlKCJpZCIpKTtpZihudWxsIT1iKWZvcihjPTA7Yzx0aGlzLmlkcmVmcy5sZW5ndGg7YysrKXt2YXIgZj10aGlzLmlkcmVmc1tjXSxnPWIuZ2V0QXR0cmlidXRlKGYpO2lmKG51bGwhPWcpe2IucmVtb3ZlQXR0cmlidXRlKGYpO3ZhciBrPWEub2JqZWN0c1tnXXx8YS5sb29rdXAoZyk7bnVsbD09ayYmKGc9YS5nZXRFbGVtZW50QnlJZChnKSxudWxsIT1nJiYoaz0obXhDb2RlY1JlZ2lzdHJ5LmNvZGVjc1tnLm5vZGVOYW1lXXx8dGhpcykuZGVjb2RlKGEsZykpKTtkW2ZdPWt9fXJldHVybiBifTtyZXR1cm4gYX0oKSk7Cm14Q29kZWNSZWdpc3RyeS5yZWdpc3RlcihmdW5jdGlvbigpe3ZhciBhPW5ldyBteE9iamVjdENvZGVjKG5ldyBteEdyYXBoTW9kZWwpO2EuZW5jb2RlT2JqZWN0PWZ1bmN0aW9uKGEsYyxkKXt2YXIgYj1hLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInJvb3QiKTthLmVuY29kZUNlbGwoYy5nZXRSb290KCksYik7ZC5hcHBlbmRDaGlsZChiKX07YS5kZWNvZGVDaGlsZD1mdW5jdGlvbihhLGMsZCl7InJvb3QiPT1jLm5vZGVOYW1lP3RoaXMuZGVjb2RlUm9vdChhLGMsZCk6bXhPYmplY3RDb2RlYy5wcm90b3R5cGUuZGVjb2RlQ2hpbGQuYXBwbHkodGhpcyxhcmd1bWVudHMpfTthLmRlY29kZVJvb3Q9ZnVuY3Rpb24oYSxjLGQpe3ZhciBiPW51bGw7Zm9yKGM9Yy5maXJzdENoaWxkO251bGwhPWM7KXt2YXIgZj1hLmRlY29kZUNlbGwoYyk7bnVsbCE9ZiYmbnVsbD09Zi5nZXRQYXJlbnQoKSYmKGI9Zik7Yz1jLm5leHRTaWJsaW5nfW51bGwhPWImJmQuc2V0Um9vdChiKX07cmV0dXJuIGF9KCkpOwpteENvZGVjUmVnaXN0cnkucmVnaXN0ZXIoZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhPYmplY3RDb2RlYyhuZXcgbXhSb290Q2hhbmdlLFsibW9kZWwiLCJwcmV2aW91cyIsInJvb3QiXSk7YS5hZnRlckVuY29kZT1mdW5jdGlvbihhLGMsZCl7YS5lbmNvZGVDZWxsKGMucm9vdCxkKTtyZXR1cm4gZH07YS5iZWZvcmVEZWNvZGU9ZnVuY3Rpb24oYSxjLGQpe2lmKG51bGwhPWMuZmlyc3RDaGlsZCYmYy5maXJzdENoaWxkLm5vZGVUeXBlPT1teENvbnN0YW50cy5OT0RFVFlQRV9FTEVNRU5UKXtjPWMuY2xvbmVOb2RlKCEwKTt2YXIgYj1jLmZpcnN0Q2hpbGQ7ZC5yb290PWEuZGVjb2RlQ2VsbChiLCExKTtkPWIubmV4dFNpYmxpbmc7Yi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpO2ZvcihiPWQ7bnVsbCE9YjspZD1iLm5leHRTaWJsaW5nLGEuZGVjb2RlQ2VsbChiKSxiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYiksYj1kfXJldHVybiBjfTthLmFmdGVyRGVjb2RlPWZ1bmN0aW9uKGEsYywKZCl7ZC5wcmV2aW91cz1kLnJvb3Q7cmV0dXJuIGR9O3JldHVybiBhfSgpKTsKbXhDb2RlY1JlZ2lzdHJ5LnJlZ2lzdGVyKGZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14T2JqZWN0Q29kZWMobmV3IG14Q2hpbGRDaGFuZ2UsWyJtb2RlbCIsImNoaWxkIiwicHJldmlvdXNJbmRleCJdLFsicGFyZW50IiwicHJldmlvdXMiXSk7YS5pc1JlZmVyZW5jZT1mdW5jdGlvbihhLGMsZCxlKXtyZXR1cm4iY2hpbGQiIT1jfHxlJiYhYS5tb2RlbC5jb250YWlucyhhLnByZXZpb3VzKT8wPD1teFV0aWxzLmluZGV4T2YodGhpcy5pZHJlZnMsYyk6ITB9O2EuaXNFeGNsdWRlZD1mdW5jdGlvbihhLGMsZCxlKXtyZXR1cm4gbXhPYmplY3RDb2RlYy5wcm90b3R5cGUuaXNFeGNsdWRlZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fGUmJm51bGwhPWQmJigicHJldmlvdXMiPT1jfHwicGFyZW50Ij09YykmJiFhLm1vZGVsLmNvbnRhaW5zKGQpfTthLmFmdGVyRW5jb2RlPWZ1bmN0aW9uKGEsYyxkKXt0aGlzLmlzUmVmZXJlbmNlKGMsImNoaWxkIixjLmNoaWxkLCEwKT9kLnNldEF0dHJpYnV0ZSgiY2hpbGQiLAphLmdldElkKGMuY2hpbGQpKTphLmVuY29kZUNlbGwoYy5jaGlsZCxkKTtyZXR1cm4gZH07YS5iZWZvcmVEZWNvZGU9ZnVuY3Rpb24oYSxjLGQpe2lmKG51bGwhPWMuZmlyc3RDaGlsZCYmYy5maXJzdENoaWxkLm5vZGVUeXBlPT1teENvbnN0YW50cy5OT0RFVFlQRV9FTEVNRU5UKXtjPWMuY2xvbmVOb2RlKCEwKTt2YXIgYj1jLmZpcnN0Q2hpbGQ7ZC5jaGlsZD1hLmRlY29kZUNlbGwoYiwhMSk7ZD1iLm5leHRTaWJsaW5nO2IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKTtmb3IoYj1kO251bGwhPWI7KXtkPWIubmV4dFNpYmxpbmc7aWYoYi5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVCl7dmFyIGY9Yi5nZXRBdHRyaWJ1dGUoImlkIik7bnVsbD09YS5sb29rdXAoZikmJmEuZGVjb2RlQ2VsbChiKX1iLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYik7Yj1kfX1lbHNlIGI9Yy5nZXRBdHRyaWJ1dGUoImNoaWxkIiksZC5jaGlsZD1hLmdldE9iamVjdChiKTtyZXR1cm4gY307CmEuYWZ0ZXJEZWNvZGU9ZnVuY3Rpb24oYSxjLGQpe251bGwhPWQuY2hpbGQmJihudWxsIT1kLmNoaWxkLnBhcmVudCYmbnVsbCE9ZC5wcmV2aW91cyYmZC5jaGlsZC5wYXJlbnQhPWQucHJldmlvdXMmJihkLnByZXZpb3VzPWQuY2hpbGQucGFyZW50KSxkLmNoaWxkLnBhcmVudD1kLnByZXZpb3VzLGQucHJldmlvdXM9ZC5wYXJlbnQsZC5wcmV2aW91c0luZGV4PWQuaW5kZXgpO3JldHVybiBkfTtyZXR1cm4gYX0oKSk7bXhDb2RlY1JlZ2lzdHJ5LnJlZ2lzdGVyKGZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14T2JqZWN0Q29kZWMobmV3IG14VGVybWluYWxDaGFuZ2UsWyJtb2RlbCIsInByZXZpb3VzIl0sWyJjZWxsIiwidGVybWluYWwiXSk7YS5hZnRlckRlY29kZT1mdW5jdGlvbihhLGMsZCl7ZC5wcmV2aW91cz1kLnRlcm1pbmFsO3JldHVybiBkfTtyZXR1cm4gYX0oKSk7CnZhciBteEdlbmVyaWNDaGFuZ2VDb2RlYz1mdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBteE9iamVjdENvZGVjKGEsWyJtb2RlbCIsInByZXZpb3VzIl0sWyJjZWxsIl0pO2MuYWZ0ZXJEZWNvZGU9ZnVuY3Rpb24oYSxjLGYpe214VXRpbHMuaXNOb2RlKGYuY2VsbCkmJihmLmNlbGw9YS5kZWNvZGVDZWxsKGYuY2VsbCwhMSkpO2YucHJldmlvdXM9ZltiXTtyZXR1cm4gZn07cmV0dXJuIGN9O214Q29kZWNSZWdpc3RyeS5yZWdpc3RlcihteEdlbmVyaWNDaGFuZ2VDb2RlYyhuZXcgbXhWYWx1ZUNoYW5nZSwidmFsdWUiKSk7bXhDb2RlY1JlZ2lzdHJ5LnJlZ2lzdGVyKG14R2VuZXJpY0NoYW5nZUNvZGVjKG5ldyBteFN0eWxlQ2hhbmdlLCJzdHlsZSIpKTtteENvZGVjUmVnaXN0cnkucmVnaXN0ZXIobXhHZW5lcmljQ2hhbmdlQ29kZWMobmV3IG14R2VvbWV0cnlDaGFuZ2UsImdlb21ldHJ5IikpOwpteENvZGVjUmVnaXN0cnkucmVnaXN0ZXIobXhHZW5lcmljQ2hhbmdlQ29kZWMobmV3IG14Q29sbGFwc2VDaGFuZ2UsImNvbGxhcHNlZCIpKTtteENvZGVjUmVnaXN0cnkucmVnaXN0ZXIobXhHZW5lcmljQ2hhbmdlQ29kZWMobmV3IG14VmlzaWJsZUNoYW5nZSwidmlzaWJsZSIpKTtteENvZGVjUmVnaXN0cnkucmVnaXN0ZXIobXhHZW5lcmljQ2hhbmdlQ29kZWMobmV3IG14Q2VsbEF0dHJpYnV0ZUNoYW5nZSwidmFsdWUiKSk7bXhDb2RlY1JlZ2lzdHJ5LnJlZ2lzdGVyKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBteE9iamVjdENvZGVjKG5ldyBteEdyYXBoLCJncmFwaExpc3RlbmVycyBldmVudExpc3RlbmVycyB2aWV3IGNvbnRhaW5lciBjZWxsUmVuZGVyZXIgZWRpdG9yIHNlbGVjdGlvbiIuc3BsaXQoIiAiKSl9KCkpOwpteENvZGVjUmVnaXN0cnkucmVnaXN0ZXIoZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhPYmplY3RDb2RlYyhuZXcgbXhHcmFwaFZpZXcpO2EuZW5jb2RlPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIHRoaXMuZW5jb2RlQ2VsbChhLGMsYy5ncmFwaC5nZXRNb2RlbCgpLmdldFJvb3QoKSl9O2EuZW5jb2RlQ2VsbD1mdW5jdGlvbihhLGMsZCl7dmFyIGI9Yy5ncmFwaC5nZXRNb2RlbCgpLGY9Yy5nZXRTdGF0ZShkKSxnPWIuZ2V0UGFyZW50KGQpO2lmKG51bGw9PWd8fG51bGwhPWYpe3ZhciBrPWIuZ2V0Q2hpbGRDb3VudChkKSxsPWMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGQpLG09bnVsbDtnPT1iLmdldFJvb3QoKT9tPSJsYXllciI6bnVsbD09Zz9tPSJncmFwaCI6Yi5pc0VkZ2UoZCk/bT0iZWRnZSI6MDxrJiZudWxsIT1sP209Imdyb3VwIjpiLmlzVmVydGV4KGQpJiYobT0idmVydGV4Iik7aWYobnVsbCE9bSl7dmFyIG49YS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KG0pO251bGwhPWMuZ3JhcGguZ2V0TGFiZWwoZCkmJgoobi5zZXRBdHRyaWJ1dGUoImxhYmVsIixjLmdyYXBoLmdldExhYmVsKGQpKSxjLmdyYXBoLmlzSHRtbExhYmVsKGQpJiZuLnNldEF0dHJpYnV0ZSgiaHRtbCIsITApKTtpZihudWxsPT1nKXt2YXIgcD1jLmdldEdyYXBoQm91bmRzKCk7bnVsbCE9cCYmKG4uc2V0QXR0cmlidXRlKCJ4IixNYXRoLnJvdW5kKHAueCkpLG4uc2V0QXR0cmlidXRlKCJ5IixNYXRoLnJvdW5kKHAueSkpLG4uc2V0QXR0cmlidXRlKCJ3aWR0aCIsTWF0aC5yb3VuZChwLndpZHRoKSksbi5zZXRBdHRyaWJ1dGUoImhlaWdodCIsTWF0aC5yb3VuZChwLmhlaWdodCkpKTtuLnNldEF0dHJpYnV0ZSgic2NhbGUiLGMuc2NhbGUpfWVsc2UgaWYobnVsbCE9ZiYmbnVsbCE9bCl7Zm9yKHAgaW4gZi5zdHlsZSlnPWYuc3R5bGVbcF0sImZ1bmN0aW9uIj09dHlwZW9mIGcmJiJvYmplY3QiPT10eXBlb2YgZyYmKGc9bXhTdHlsZVJlZ2lzdHJ5LmdldE5hbWUoZykpLG51bGwhPWcmJiJmdW5jdGlvbiIhPXR5cGVvZiBnJiYib2JqZWN0IiE9CnR5cGVvZiBnJiZuLnNldEF0dHJpYnV0ZShwLGcpO2c9Zi5hYnNvbHV0ZVBvaW50cztpZihudWxsIT1nJiYwPGcubGVuZ3RoKXtsPU1hdGgucm91bmQoZ1swXS54KSsiLCIrTWF0aC5yb3VuZChnWzBdLnkpO2ZvcihwPTE7cDxnLmxlbmd0aDtwKyspbCs9IiAiK01hdGgucm91bmQoZ1twXS54KSsiLCIrTWF0aC5yb3VuZChnW3BdLnkpO24uc2V0QXR0cmlidXRlKCJwb2ludHMiLGwpfWVsc2Ugbi5zZXRBdHRyaWJ1dGUoIngiLE1hdGgucm91bmQoZi54KSksbi5zZXRBdHRyaWJ1dGUoInkiLE1hdGgucm91bmQoZi55KSksbi5zZXRBdHRyaWJ1dGUoIndpZHRoIixNYXRoLnJvdW5kKGYud2lkdGgpKSxuLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixNYXRoLnJvdW5kKGYuaGVpZ2h0KSk7cD1mLmFic29sdXRlT2Zmc2V0O251bGwhPXAmJigwIT1wLngmJm4uc2V0QXR0cmlidXRlKCJkeCIsTWF0aC5yb3VuZChwLngpKSwwIT1wLnkmJm4uc2V0QXR0cmlidXRlKCJkeSIsTWF0aC5yb3VuZChwLnkpKSl9Zm9yKHA9CjA7cDxrO3ArKylmPXRoaXMuZW5jb2RlQ2VsbChhLGMsYi5nZXRDaGlsZEF0KGQscCkpLG51bGwhPWYmJm4uYXBwZW5kQ2hpbGQoZil9fXJldHVybiBufTtyZXR1cm4gYX0oKSk7CnZhciBteFN0eWxlc2hlZXRDb2RlYz1teENvZGVjUmVnaXN0cnkucmVnaXN0ZXIoZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhPYmplY3RDb2RlYyhuZXcgbXhTdHlsZXNoZWV0KTthLmVuY29kZT1mdW5jdGlvbihhLGMpe3ZhciBiPWEuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLmdldE5hbWUoKSksZTtmb3IoZSBpbiBjLnN0eWxlcyl7dmFyIGY9Yy5zdHlsZXNbZV0sZz1hLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImFkZCIpO2lmKG51bGwhPWUpe2cuc2V0QXR0cmlidXRlKCJhcyIsZSk7Zm9yKHZhciBrIGluIGYpe3ZhciBsPXRoaXMuZ2V0U3RyaW5nVmFsdWUoayxmW2tdKTtpZihudWxsIT1sKXt2YXIgbT1hLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImFkZCIpO20uc2V0QXR0cmlidXRlKCJ2YWx1ZSIsbCk7bS5zZXRBdHRyaWJ1dGUoImFzIixrKTtnLmFwcGVuZENoaWxkKG0pfX0wPGcuY2hpbGROb2Rlcy5sZW5ndGgmJmIuYXBwZW5kQ2hpbGQoZyl9fXJldHVybiBifTthLmdldFN0cmluZ1ZhbHVlPQpmdW5jdGlvbihhLGMpe3ZhciBiPXR5cGVvZiBjOyJmdW5jdGlvbiI9PWI/Yz1teFN0eWxlUmVnaXN0cnkuZ2V0TmFtZShjKToib2JqZWN0Ij09YiYmKGM9bnVsbCk7cmV0dXJuIGN9O2EuZGVjb2RlPWZ1bmN0aW9uKGEsYyxkKXtkPWR8fG5ldyB0aGlzLnRlbXBsYXRlLmNvbnN0cnVjdG9yO3ZhciBiPWMuZ2V0QXR0cmlidXRlKCJpZCIpO251bGwhPWImJihhLm9iamVjdHNbYl09ZCk7Zm9yKGM9Yy5maXJzdENoaWxkO251bGwhPWM7KXtpZighdGhpcy5wcm9jZXNzSW5jbHVkZShhLGMsZCkmJiJhZGQiPT1jLm5vZGVOYW1lJiYoYj1jLmdldEF0dHJpYnV0ZSgiYXMiKSxudWxsIT1iKSl7dmFyIGY9Yy5nZXRBdHRyaWJ1dGUoImV4dGVuZCIpLGc9bnVsbCE9Zj9teFV0aWxzLmNsb25lKGQuc3R5bGVzW2ZdKTpudWxsO251bGw9PWcmJihudWxsIT1mJiZteExvZy53YXJuKCJteFN0eWxlc2hlZXRDb2RlYy5kZWNvZGU6IHN0eWxlc2hlZXQgIitmKyIgbm90IGZvdW5kIHRvIGV4dGVuZCIpLGc9Cnt9KTtmb3IoZj1jLmZpcnN0Q2hpbGQ7bnVsbCE9Zjspe2lmKGYubm9kZVR5cGU9PW14Q29uc3RhbnRzLk5PREVUWVBFX0VMRU1FTlQpe3ZhciBrPWYuZ2V0QXR0cmlidXRlKCJhcyIpO2lmKCJhZGQiPT1mLm5vZGVOYW1lKXt2YXIgbD1teFV0aWxzLmdldFRleHRDb250ZW50KGYpO251bGwhPWwmJjA8bC5sZW5ndGgmJm14U3R5bGVzaGVldENvZGVjLmFsbG93RXZhbD9sPW14VXRpbHMuZXZhbChsKToobD1mLmdldEF0dHJpYnV0ZSgidmFsdWUiKSxteFV0aWxzLmlzTnVtZXJpYyhsKSYmKGw9cGFyc2VGbG9hdChsKSkpO251bGwhPWwmJihnW2tdPWwpfWVsc2UicmVtb3ZlIj09Zi5ub2RlTmFtZSYmZGVsZXRlIGdba119Zj1mLm5leHRTaWJsaW5nfWQucHV0Q2VsbFN0eWxlKGIsZyl9Yz1jLm5leHRTaWJsaW5nfXJldHVybiBkfTtyZXR1cm4gYX0oKSk7bXhTdHlsZXNoZWV0Q29kZWMuYWxsb3dFdmFsPSEwOwpteENvZGVjUmVnaXN0cnkucmVnaXN0ZXIoZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhPYmplY3RDb2RlYyhuZXcgbXhEZWZhdWx0S2V5SGFuZGxlcik7YS5lbmNvZGU9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gbnVsbH07YS5kZWNvZGU9ZnVuY3Rpb24oYSxjLGQpe2lmKG51bGwhPWQpZm9yKGM9Yy5maXJzdENoaWxkO251bGwhPWM7KXtpZighdGhpcy5wcm9jZXNzSW5jbHVkZShhLGMsZCkmJiJhZGQiPT1jLm5vZGVOYW1lKXt2YXIgYj1jLmdldEF0dHJpYnV0ZSgiYXMiKSxmPWMuZ2V0QXR0cmlidXRlKCJhY3Rpb24iKSxnPWMuZ2V0QXR0cmlidXRlKCJjb250cm9sIik7ZC5iaW5kQWN0aW9uKGIsZixnKX1jPWMubmV4dFNpYmxpbmd9cmV0dXJuIGR9O3JldHVybiBhfSgpKTsKdmFyIG14RGVmYXVsdFRvb2xiYXJDb2RlYz1teENvZGVjUmVnaXN0cnkucmVnaXN0ZXIoZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhPYmplY3RDb2RlYyhuZXcgbXhEZWZhdWx0VG9vbGJhcik7YS5lbmNvZGU9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gbnVsbH07YS5kZWNvZGU9ZnVuY3Rpb24oYSxjLGQpe2lmKG51bGwhPWQpe3ZhciBiPWQuZWRpdG9yO2ZvcihjPWMuZmlyc3RDaGlsZDtudWxsIT1jOyl7aWYoYy5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVCYmIXRoaXMucHJvY2Vzc0luY2x1ZGUoYSxjLGQpKWlmKCJzZXBhcmF0b3IiPT1jLm5vZGVOYW1lKWQuYWRkU2VwYXJhdG9yKCk7ZWxzZSBpZigiYnIiPT1jLm5vZGVOYW1lKWQudG9vbGJhci5hZGRCcmVhaygpO2Vsc2UgaWYoImhyIj09Yy5ub2RlTmFtZSlkLnRvb2xiYXIuYWRkTGluZSgpO2Vsc2UgaWYoImFkZCI9PWMubm9kZU5hbWUpe3ZhciBmPWMuZ2V0QXR0cmlidXRlKCJhcyIpLGY9bXhSZXNvdXJjZXMuZ2V0KGYpfHwKZixnPWMuZ2V0QXR0cmlidXRlKCJpY29uIiksaz1jLmdldEF0dHJpYnV0ZSgicHJlc3NlZEljb24iKSxsPWMuZ2V0QXR0cmlidXRlKCJhY3Rpb24iKSxtPWMuZ2V0QXR0cmlidXRlKCJtb2RlIiksbj1jLmdldEF0dHJpYnV0ZSgidGVtcGxhdGUiKSxwPSIwIiE9Yy5nZXRBdHRyaWJ1dGUoInRvZ2dsZSIpLHE9bXhVdGlscy5nZXRUZXh0Q29udGVudChjKSxyPW51bGw7aWYobnVsbCE9bClyPWQuYWRkSXRlbShmLGcsbCxrKTtlbHNlIGlmKG51bGwhPW0pdmFyIHQ9bXhEZWZhdWx0VG9vbGJhckNvZGVjLmFsbG93RXZhbD9teFV0aWxzLmV2YWwocSk6bnVsbCxyPWQuYWRkTW9kZShmLGcsbSxrLHQpO2Vsc2UgaWYobnVsbCE9bnx8bnVsbCE9cSYmMDxxLmxlbmd0aClyPWIudGVtcGxhdGVzW25dLG49Yy5nZXRBdHRyaWJ1dGUoInN0eWxlIiksbnVsbCE9ciYmbnVsbCE9biYmKHI9Yi5ncmFwaC5jbG9uZUNlbGwociksci5zZXRTdHlsZShuKSksbj1udWxsLG51bGwhPXEmJjA8cS5sZW5ndGgmJgpteERlZmF1bHRUb29sYmFyQ29kZWMuYWxsb3dFdmFsJiYobj1teFV0aWxzLmV2YWwocSkpLHI9ZC5hZGRQcm90b3R5cGUoZixnLHIsayxuLHApO2Vsc2UgaWYoaz1teFV0aWxzLmdldENoaWxkTm9kZXMoYyksMDxrLmxlbmd0aClpZihudWxsPT1nKWZvcihuPWQuYWRkQWN0aW9uQ29tYm8oZiksZj0wO2Y8ay5sZW5ndGg7ZisrKXA9a1tmXSwic2VwYXJhdG9yIj09cC5ub2RlTmFtZT9kLmFkZE9wdGlvbihuLCItLS0iKToiYWRkIj09cC5ub2RlTmFtZSYmKGc9cC5nZXRBdHRyaWJ1dGUoImFzIikscD1wLmdldEF0dHJpYnV0ZSgiYWN0aW9uIiksZC5hZGRBY3Rpb25PcHRpb24obixnLHApKTtlbHNle3ZhciB1PW51bGwseD1kLmFkZFByb3RvdHlwZShmLGcsZnVuY3Rpb24oKXt2YXIgYT1iLnRlbXBsYXRlc1t1LnZhbHVlXTtpZihudWxsIT1hKXt2YXIgYT1hLmNsb25lKCksYz11Lm9wdGlvbnNbdS5zZWxlY3RlZEluZGV4XS5jZWxsU3R5bGU7bnVsbCE9YyYmYS5zZXRTdHlsZShjKTtyZXR1cm4gYX1teExvZy53YXJuKCJUZW1wbGF0ZSAiKwphKyIgbm90IGZvdW5kIik7cmV0dXJuIG51bGx9LG51bGwsbnVsbCxwKSx1PWQuYWRkQ29tYm8oKTtteEV2ZW50LmFkZExpc3RlbmVyKHUsImNoYW5nZSIsZnVuY3Rpb24oKXtkLnRvb2xiYXIuc2VsZWN0TW9kZSh4LGZ1bmN0aW9uKGEpe2E9bXhVdGlscy5jb252ZXJ0UG9pbnQoYi5ncmFwaC5jb250YWluZXIsbXhFdmVudC5nZXRDbGllbnRYKGEpLG14RXZlbnQuZ2V0Q2xpZW50WShhKSk7cmV0dXJuIGIuYWRkVmVydGV4KG51bGwsdCgpLGEueCxhLnkpfSk7ZC50b29sYmFyLm5vUmVzZXQ9ITF9KTtmb3IoZj0wO2Y8ay5sZW5ndGg7ZisrKXA9a1tmXSwic2VwYXJhdG9yIj09cC5ub2RlTmFtZT9kLmFkZE9wdGlvbih1LCItLS0iKToiYWRkIj09cC5ub2RlTmFtZSYmKGc9cC5nZXRBdHRyaWJ1dGUoImFzIikscT1wLmdldEF0dHJpYnV0ZSgidGVtcGxhdGUiKSxkLmFkZE9wdGlvbih1LGcscXx8bikuY2VsbFN0eWxlPXAuZ2V0QXR0cmlidXRlKCJzdHlsZSIpKX1udWxsIT1yJiYobj1jLmdldEF0dHJpYnV0ZSgiaWQiKSwKbnVsbCE9biYmMDxuLmxlbmd0aCYmci5zZXRBdHRyaWJ1dGUoImlkIixuKSl9Yz1jLm5leHRTaWJsaW5nfX1yZXR1cm4gZH07cmV0dXJuIGF9KCkpO214RGVmYXVsdFRvb2xiYXJDb2RlYy5hbGxvd0V2YWw9ITA7bXhDb2RlY1JlZ2lzdHJ5LnJlZ2lzdGVyKGZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14T2JqZWN0Q29kZWMobmV3IG14RGVmYXVsdFBvcHVwTWVudSk7YS5lbmNvZGU9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gbnVsbH07YS5kZWNvZGU9ZnVuY3Rpb24oYSxjLGQpe3ZhciBiPWMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImluY2x1ZGUiKVswXTtudWxsIT1iP3RoaXMucHJvY2Vzc0luY2x1ZGUoYSxiLGQpOm51bGwhPWQmJihkLmNvbmZpZz1jKTtyZXR1cm4gZH07cmV0dXJuIGF9KCkpOwpteENvZGVjUmVnaXN0cnkucmVnaXN0ZXIoZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhPYmplY3RDb2RlYyhuZXcgbXhFZGl0b3IsIm1vZGlmaWVkIGxhc3RTbmFwc2hvdCBpZ25vcmVkQ2hhbmdlcyB1bmRvTWFuYWdlciBncmFwaENvbnRhaW5lciB0b29sYmFyQ29udGFpbmVyIi5zcGxpdCgiICIpKTthLmFmdGVyRGVjb2RlPWZ1bmN0aW9uKGEsYyxkKXthPWMuZ2V0QXR0cmlidXRlKCJkZWZhdWx0RWRnZSIpO251bGwhPWEmJihjLnJlbW92ZUF0dHJpYnV0ZSgiZGVmYXVsdEVkZ2UiKSxkLmRlZmF1bHRFZGdlPWQudGVtcGxhdGVzW2FdKTthPWMuZ2V0QXR0cmlidXRlKCJkZWZhdWx0R3JvdXAiKTtudWxsIT1hJiYoYy5yZW1vdmVBdHRyaWJ1dGUoImRlZmF1bHRHcm91cCIpLGQuZGVmYXVsdEdyb3VwPWQudGVtcGxhdGVzW2FdKTtyZXR1cm4gZH07YS5kZWNvZGVDaGlsZD1mdW5jdGlvbihhLGMsZCl7aWYoIkFycmF5Ij09Yy5ub2RlTmFtZSl7aWYoInRlbXBsYXRlcyI9PWMuZ2V0QXR0cmlidXRlKCJhcyIpKXt0aGlzLmRlY29kZVRlbXBsYXRlcyhhLApjLGQpO3JldHVybn19ZWxzZSBpZigidWkiPT1jLm5vZGVOYW1lKXt0aGlzLmRlY29kZVVpKGEsYyxkKTtyZXR1cm59bXhPYmplY3RDb2RlYy5wcm90b3R5cGUuZGVjb2RlQ2hpbGQuYXBwbHkodGhpcyxhcmd1bWVudHMpfTthLmRlY29kZVVpPWZ1bmN0aW9uKGEsYyxkKXtmb3IoYT1jLmZpcnN0Q2hpbGQ7bnVsbCE9YTspe2lmKCJhZGQiPT1hLm5vZGVOYW1lKXtjPWEuZ2V0QXR0cmlidXRlKCJhcyIpO3ZhciBiPWEuZ2V0QXR0cmlidXRlKCJlbGVtZW50IiksZj1hLmdldEF0dHJpYnV0ZSgic3R5bGUiKTtpZihudWxsIT1iKWI9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYiksbnVsbCE9YiYmbnVsbCE9ZiYmKGIuc3R5bGUuY3NzVGV4dCs9IjsiK2YpO2Vsc2V7dmFyIGc9cGFyc2VJbnQoYS5nZXRBdHRyaWJ1dGUoIngiKSksaz1wYXJzZUludChhLmdldEF0dHJpYnV0ZSgieSIpKSxsPWEuZ2V0QXR0cmlidXRlKCJ3aWR0aCIpLG09YS5nZXRBdHRyaWJ1dGUoImhlaWdodCIpLGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7CmIuc3R5bGUuY3NzVGV4dD1mOyhuZXcgbXhXaW5kb3cobXhSZXNvdXJjZXMuZ2V0KGMpfHxjLGIsZyxrLGwsbSwhMSwhMCkpLnNldFZpc2libGUoITApfSJncmFwaCI9PWM/ZC5zZXRHcmFwaENvbnRhaW5lcihiKToidG9vbGJhciI9PWM/ZC5zZXRUb29sYmFyQ29udGFpbmVyKGIpOiJ0aXRsZSI9PWM/ZC5zZXRUaXRsZUNvbnRhaW5lcihiKToic3RhdHVzIj09Yz9kLnNldFN0YXR1c0NvbnRhaW5lcihiKToibWFwIj09YyYmZC5zZXRNYXBDb250YWluZXIoYil9ZWxzZSJyZXNvdXJjZSI9PWEubm9kZU5hbWU/bXhSZXNvdXJjZXMuYWRkKGEuZ2V0QXR0cmlidXRlKCJiYXNlbmFtZSIpKToic3R5bGVzaGVldCI9PWEubm9kZU5hbWUmJm14Q2xpZW50LmxpbmsoInN0eWxlc2hlZXQiLGEuZ2V0QXR0cmlidXRlKCJuYW1lIikpO2E9YS5uZXh0U2libGluZ319O2EuZGVjb2RlVGVtcGxhdGVzPWZ1bmN0aW9uKGEsYyxkKXtudWxsPT1kLnRlbXBsYXRlcyYmKGQudGVtcGxhdGVzPVtdKTtjPW14VXRpbHMuZ2V0Q2hpbGROb2RlcyhjKTsKZm9yKHZhciBiPTA7YjxjLmxlbmd0aDtiKyspe2Zvcih2YXIgZj1jW2JdLmdldEF0dHJpYnV0ZSgiYXMiKSxnPWNbYl0uZmlyc3RDaGlsZDtudWxsIT1nJiYxIT1nLm5vZGVUeXBlOylnPWcubmV4dFNpYmxpbmc7bnVsbCE9ZyYmKGQudGVtcGxhdGVzW2ZdPWEuZGVjb2RlQ2VsbChnKSl9fTtyZXR1cm4gYX0oKSk7LyoKIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgaHR0cDovL3d3dy5nbnUub3JnL2NvcHlsZWZ0L2xlc3Nlci5odG1sCiBAYXV0aG9yICBKYW4gT2R2YXJrbywgaHR0cDovL29kdmFya28uY3oKIEBjcmVhdGVkIDIwMDgtMDYtMTUKIEB1cGRhdGVkIDIwMTItMDEtMTkKIEBsaW5rICAgIGh0dHA6Ly9qc2NvbG9yLmNvbQoqLwp2YXIgbXhKU0NvbG9yPXtiaW5kQ2xhc3M6ImNvbG9yIixiaW5kaW5nOiEwLHByZWxvYWRpbmc6ITAsaW5zdGFsbDpmdW5jdGlvbigpe30saW5pdDpmdW5jdGlvbigpe214SlNDb2xvci5wcmVsb2FkaW5nJiZteEpTQ29sb3IucHJlbG9hZCgpfSxnZXREaXI6ZnVuY3Rpb24oKXtyZXR1cm4gSU1BR0VfUEFUSCsiLyJ9LGRldGVjdERpcjpmdW5jdGlvbigpe2Zvcih2YXIgYT1sb2NhdGlvbi5ocmVmLGI9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImJhc2UiKSxjPTA7YzxiLmxlbmd0aDtjKz0xKWJbY10uaHJlZiYmKGE9YltjXS5ocmVmKTtiPWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJzY3JpcHQiKTtmb3IoYz0wO2M8Yi5sZW5ndGg7Yys9MSlpZihiW2NdLnNyYyYmLyhefFwvKWpzY29sb3JcLmpzKFs/I10uKik/JC9pLnRlc3QoYltjXS5zcmMpKXJldHVybiBhPShuZXcgbXhKU0NvbG9yLlVSSShiW2NdLnNyYykpLnRvQWJzb2x1dGUoYSksYS5wYXRoPWEucGF0aC5yZXBsYWNlKC9bXlwvXSskLywKIiIpLGEucXVlcnk9bnVsbCxhLmZyYWdtZW50PW51bGwsYS50b1N0cmluZygpO3JldHVybiExfSxwcmVsb2FkOmZ1bmN0aW9uKCl7Zm9yKHZhciBhIGluIG14SlNDb2xvci5pbWdSZXF1aXJlKW14SlNDb2xvci5pbWdSZXF1aXJlLmhhc093blByb3BlcnR5KGEpJiZteEpTQ29sb3IubG9hZEltYWdlKGEpfSxpbWFnZXM6e3BhZDpbMTgxLDEwMV0sc2xkOlsxNiwxMDFdLGNyb3NzOlsxNSwxNV0sYXJyb3c6WzcsMTFdfSxpbWdSZXF1aXJlOnt9LGltZ0xvYWRlZDp7fSxyZXF1aXJlSW1hZ2U6ZnVuY3Rpb24oYSl7bXhKU0NvbG9yLmltZ1JlcXVpcmVbYV09ITB9LGxvYWRJbWFnZTpmdW5jdGlvbihhKXtteEpTQ29sb3IuaW1nTG9hZGVkW2FdfHwobXhKU0NvbG9yLmltZ0xvYWRlZFthXT1uZXcgSW1hZ2UsbXhKU0NvbG9yLmltZ0xvYWRlZFthXS5zcmM9bXhKU0NvbG9yLmdldERpcigpK2EpfSxmZXRjaEVsZW1lbnQ6ZnVuY3Rpb24oYSl7cmV0dXJuInN0cmluZyI9PT10eXBlb2YgYT9kb2N1bWVudC5nZXRFbGVtZW50QnlJZChhKToKYX0sYWRkRXZlbnQ6ZnVuY3Rpb24oYSxiLGMpe2EuYWRkRXZlbnRMaXN0ZW5lcj9hLmFkZEV2ZW50TGlzdGVuZXIoYixjLCExKTphLmF0dGFjaEV2ZW50JiZhLmF0dGFjaEV2ZW50KCJvbiIrYixjKX0sZmlyZUV2ZW50OmZ1bmN0aW9uKGEsYil7aWYoYSlpZihkb2N1bWVudC5jcmVhdGVFdmVudCl7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoIkhUTUxFdmVudHMiKTtjLmluaXRFdmVudChiLCEwLCEwKTthLmRpc3BhdGNoRXZlbnQoYyl9ZWxzZSBpZihkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCljPWRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCksYS5maXJlRXZlbnQoIm9uIitiLGMpO2Vsc2UgaWYoYVsib24iK2JdKWFbIm9uIitiXSgpfSxnZXRFbGVtZW50UG9zOmZ1bmN0aW9uKGEpe3ZhciBiPWEsYz0wLGQ9MDtpZihiLm9mZnNldFBhcmVudCl7ZG8gYys9Yi5vZmZzZXRMZWZ0LGQrPWIub2Zmc2V0VG9wO3doaWxlKGI9Yi5vZmZzZXRQYXJlbnQpfWZvcig7KGE9YS5wYXJlbnROb2RlKSYmCiJCT0RZIiE9PWEubm9kZU5hbWUudG9VcHBlckNhc2UoKTspYy09YS5zY3JvbGxMZWZ0LGQtPWEuc2Nyb2xsVG9wO3JldHVybltjLGRdfSxnZXRFbGVtZW50U2l6ZTpmdW5jdGlvbihhKXtyZXR1cm5bYS5vZmZzZXRXaWR0aCxhLm9mZnNldEhlaWdodF19LGdldFJlbE1vdXNlUG9zOmZ1bmN0aW9uKGEpe3ZhciBiPTAsYz0wO2F8fChhPXdpbmRvdy5ldmVudCk7Im51bWJlciI9PT10eXBlb2YgYS5vZmZzZXRYPyhiPWEub2Zmc2V0WCxjPWEub2Zmc2V0WSk6Im51bWJlciI9PT10eXBlb2YgYS5sYXllclgmJihiPWEubGF5ZXJYLGM9YS5sYXllclkpO3JldHVybnt4OmIseTpjfX0sZ2V0Vmlld1BvczpmdW5jdGlvbigpe3JldHVybiJudW1iZXIiPT09dHlwZW9mIHdpbmRvdy5wYWdlWU9mZnNldD9bd2luZG93LnBhZ2VYT2Zmc2V0LHdpbmRvdy5wYWdlWU9mZnNldF06ZG9jdW1lbnQuYm9keSYmKGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdHx8ZG9jdW1lbnQuYm9keS5zY3JvbGxUb3ApP1tkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQsCmRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wXTpkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQmJihkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCk/W2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BdOlswLDBdfSxnZXRWaWV3U2l6ZTpmdW5jdGlvbigpe3JldHVybiJudW1iZXIiPT09dHlwZW9mIHdpbmRvdy5pbm5lcldpZHRoP1t3aW5kb3cuaW5uZXJXaWR0aCx3aW5kb3cuaW5uZXJIZWlnaHRdOmRvY3VtZW50LmJvZHkmJihkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRofHxkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCk/W2RvY3VtZW50LmJvZHkuY2xpZW50V2lkdGgsZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHRdOmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCk/Cltkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodF06WzAsMF19LFVSSTpmdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEpe2Zvcih2YXIgYj0iIjthOylpZigiLi4vIj09PWEuc3Vic3RyKDAsMyl8fCIuLyI9PT1hLnN1YnN0cigwLDIpKWE9YS5yZXBsYWNlKC9eXC4rLywiIikuc3Vic3RyKDEpO2Vsc2UgaWYoIi8uLyI9PT1hLnN1YnN0cigwLDMpfHwiLy4iPT09YSlhPSIvIithLnN1YnN0cigzKTtlbHNlIGlmKCIvLi4vIj09PWEuc3Vic3RyKDAsNCl8fCIvLi4iPT09YSlhPSIvIithLnN1YnN0cig0KSxiPWIucmVwbGFjZSgvXC8/W15cL10qJC8sIiIpO2Vsc2UgaWYoIi4iPT09YXx8Ii4uIj09PWEpYT0iIjtlbHNle3ZhciBjPWEubWF0Y2goL15cLz9bXlwvXSovKVswXTthPWEuc3Vic3RyKGMubGVuZ3RoKTtiKz1jfXJldHVybiBifXRoaXMuYXV0aG9yaXR5PXRoaXMuc2NoZW1lPW51bGw7dGhpcy5wYXRoPQoiIjt0aGlzLmZyYWdtZW50PXRoaXMucXVlcnk9bnVsbDt0aGlzLnBhcnNlPWZ1bmN0aW9uKGEpe2E9YS5tYXRjaCgvXigoW0EtWmEtel1bMC05QS1aYS16Ky4tXSopKDopKT8oKFwvXC8pKFteXC8/I10qKSk/KFtePyNdKikoKFw/KShbXiNdKikpPygoIykoLiopKT8vKTt0aGlzLnNjaGVtZT1hWzNdP2FbMl06bnVsbDt0aGlzLmF1dGhvcml0eT1hWzVdP2FbNl06bnVsbDt0aGlzLnBhdGg9YVs3XTt0aGlzLnF1ZXJ5PWFbOV0/YVsxMF06bnVsbDt0aGlzLmZyYWdtZW50PWFbMTJdP2FbMTNdOm51bGw7cmV0dXJuIHRoaXN9O3RoaXMudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgYT0iIjtudWxsIT09dGhpcy5zY2hlbWUmJihhPWErdGhpcy5zY2hlbWUrIjoiKTtudWxsIT09dGhpcy5hdXRob3JpdHkmJihhPWErIi8vIit0aGlzLmF1dGhvcml0eSk7bnVsbCE9PXRoaXMucGF0aCYmKGErPXRoaXMucGF0aCk7bnVsbCE9PXRoaXMucXVlcnkmJihhPWErIj8iK3RoaXMucXVlcnkpO251bGwhPT0KdGhpcy5mcmFnbWVudCYmKGE9YSsiIyIrdGhpcy5mcmFnbWVudCk7cmV0dXJuIGF9O3RoaXMudG9BYnNvbHV0ZT1mdW5jdGlvbihhKXthPW5ldyBteEpTQ29sb3IuVVJJKGEpO3ZhciBjPW5ldyBteEpTQ29sb3IuVVJJO2lmKG51bGw9PT1hLnNjaGVtZSlyZXR1cm4hMTtudWxsIT09dGhpcy5zY2hlbWUmJnRoaXMuc2NoZW1lLnRvTG93ZXJDYXNlKCk9PT1hLnNjaGVtZS50b0xvd2VyQ2FzZSgpJiYodGhpcy5zY2hlbWU9bnVsbCk7bnVsbCE9PXRoaXMuc2NoZW1lPyhjLnNjaGVtZT10aGlzLnNjaGVtZSxjLmF1dGhvcml0eT10aGlzLmF1dGhvcml0eSxjLnBhdGg9Yih0aGlzLnBhdGgpLGMucXVlcnk9dGhpcy5xdWVyeSk6KG51bGwhPT10aGlzLmF1dGhvcml0eT8oYy5hdXRob3JpdHk9dGhpcy5hdXRob3JpdHksYy5wYXRoPWIodGhpcy5wYXRoKSxjLnF1ZXJ5PXRoaXMucXVlcnkpOigiIj09PXRoaXMucGF0aD8oYy5wYXRoPWEucGF0aCxjLnF1ZXJ5PW51bGwhPT10aGlzLnF1ZXJ5P3RoaXMucXVlcnk6CmEucXVlcnkpOigiLyI9PT10aGlzLnBhdGguc3Vic3RyKDAsMSk/Yy5wYXRoPWIodGhpcy5wYXRoKTooYy5wYXRoPW51bGwhPT1hLmF1dGhvcml0eSYmIiI9PT1hLnBhdGg/Ii8iK3RoaXMucGF0aDphLnBhdGgucmVwbGFjZSgvW15cL10rJC8sIiIpK3RoaXMucGF0aCxjLnBhdGg9YihjLnBhdGgpKSxjLnF1ZXJ5PXRoaXMucXVlcnkpLGMuYXV0aG9yaXR5PWEuYXV0aG9yaXR5KSxjLnNjaGVtZT1hLnNjaGVtZSk7Yy5mcmFnbWVudD10aGlzLmZyYWdtZW50O3JldHVybiBjfTthJiZ0aGlzLnBhcnNlKGEpfSxjb2xvcjpmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSxiLGMpe2lmKG51bGw9PT1hKXJldHVybltjLGMsY107dmFyIGQ9TWF0aC5mbG9vcihhKSxlPWMqKDEtYik7YT1jKigxLWIqKGQlMj9hLWQ6MS0oYS1kKSkpO3N3aXRjaChkKXtjYXNlIDY6Y2FzZSAwOnJldHVybltjLGEsZV07Y2FzZSAxOnJldHVyblthLGMsZV07Y2FzZSAyOnJldHVybltlLGMsYV07Y2FzZSAzOnJldHVybltlLAphLGNdO2Nhc2UgNDpyZXR1cm5bYSxlLGNdO2Nhc2UgNTpyZXR1cm5bYyxlLGFdfX1mdW5jdGlvbiBkKGIsYyl7aWYoIW14SlNDb2xvci5waWNrZXIpe214SlNDb2xvci5waWNrZXI9e2JveDpkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxib3hCOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLHBhZDpkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxwYWRCOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLHBhZE06ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iiksc2xkOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLHNsZEI6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iiksc2xkTTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxidG46ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2IiksYnRuUzpkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIiksYnRuVDpkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyLnBpY2tlckNsb3NlVGV4dCl9O2Zvcih2YXIgZD0KMDtkPG14SlNDb2xvci5pbWFnZXMuc2xkWzFdO2QrPTQpe3ZhciBrPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2suc3R5bGUuaGVpZ2h0PSI0cHgiO2suc3R5bGUuZm9udFNpemU9IjFweCI7ay5zdHlsZS5saW5lSGVpZ2h0PSIwIjtteEpTQ29sb3IucGlja2VyLnNsZC5hcHBlbmRDaGlsZChrKX1teEpTQ29sb3IucGlja2VyLnNsZEIuYXBwZW5kQ2hpbGQobXhKU0NvbG9yLnBpY2tlci5zbGQpO214SlNDb2xvci5waWNrZXIuYm94LmFwcGVuZENoaWxkKG14SlNDb2xvci5waWNrZXIuc2xkQik7bXhKU0NvbG9yLnBpY2tlci5ib3guYXBwZW5kQ2hpbGQobXhKU0NvbG9yLnBpY2tlci5zbGRNKTtteEpTQ29sb3IucGlja2VyLnBhZEIuYXBwZW5kQ2hpbGQobXhKU0NvbG9yLnBpY2tlci5wYWQpO214SlNDb2xvci5waWNrZXIuYm94LmFwcGVuZENoaWxkKG14SlNDb2xvci5waWNrZXIucGFkQik7bXhKU0NvbG9yLnBpY2tlci5ib3guYXBwZW5kQ2hpbGQobXhKU0NvbG9yLnBpY2tlci5wYWRNKTsKbXhKU0NvbG9yLnBpY2tlci5idG5TLmFwcGVuZENoaWxkKG14SlNDb2xvci5waWNrZXIuYnRuVCk7bXhKU0NvbG9yLnBpY2tlci5idG4uYXBwZW5kQ2hpbGQobXhKU0NvbG9yLnBpY2tlci5idG5TKTtteEpTQ29sb3IucGlja2VyLmJveC5hcHBlbmRDaGlsZChteEpTQ29sb3IucGlja2VyLmJ0bik7bXhKU0NvbG9yLnBpY2tlci5ib3hCLmFwcGVuZENoaWxkKG14SlNDb2xvci5waWNrZXIuYm94KX12YXIgbD1teEpTQ29sb3IucGlja2VyO2wuYm94Lm9ubW91c2V1cD1sLmJveC5vbm1vdXNlb3V0PWZ1bmN0aW9uKCl7bXhDbGllbnQuSVNfVE9VQ0h8fGEuZm9jdXMoKX07bC5ib3gub25tb3VzZWRvd249ZnVuY3Rpb24oKXt9O2wuYm94Lm9ubW91c2Vtb3ZlPWZ1bmN0aW9uKGEpe2lmKHl8fEIpeSYmbShhKSxCJiZuKGEpLGRvY3VtZW50LnNlbGVjdGlvbj9kb2N1bWVudC5zZWxlY3Rpb24uZW1wdHkoKTp3aW5kb3cuZ2V0U2VsZWN0aW9uJiZ3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCksCnAoKX07bC5wYWRNLm9ubW91c2V1cD1sLnBhZE0ub25tb3VzZW91dD1mdW5jdGlvbigpe3kmJih5PSExLG14SlNDb2xvci5maXJlRXZlbnQodSwiY2hhbmdlIikpfTtsLnBhZE0ub25tb3VzZWRvd249ZnVuY3Rpb24oYSl7c3dpdGNoKHQpe2Nhc2UgMDowPT09ci5oc3ZbMl0mJnIuZnJvbUhTVihudWxsLG51bGwsMSk7YnJlYWs7Y2FzZSAxOjA9PT1yLmhzdlsxXSYmci5mcm9tSFNWKG51bGwsMSxudWxsKX15PSEwO20oYSk7cCgpfTtsLnNsZE0ub25tb3VzZXVwPWwuc2xkTS5vbm1vdXNlb3V0PWZ1bmN0aW9uKCl7QiYmKEI9ITEsbXhKU0NvbG9yLmZpcmVFdmVudCh1LCJjaGFuZ2UiKSl9O2wuc2xkTS5vbm1vdXNlZG93bj1mdW5jdGlvbihhKXtCPSEwO24oYSk7cCgpfTtkPWUocik7bC5ib3guc3R5bGUud2lkdGg9ZFswXSsicHgiO2wuYm94LnN0eWxlLmhlaWdodD1kWzFdKyJweCI7bC5ib3hCLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7bC5ib3hCLnN0eWxlLmNsZWFyPSJib3RoIjsKbC5ib3hCLnN0eWxlLmxlZnQ9YisicHgiO2wuYm94Qi5zdHlsZS50b3A9YysicHgiO2wuYm94Qi5zdHlsZS56SW5kZXg9ci5waWNrZXJaSW5kZXg7bC5ib3hCLnN0eWxlLmJvcmRlcj1yLnBpY2tlckJvcmRlcisicHggc29saWQiO2wuYm94Qi5zdHlsZS5ib3JkZXJDb2xvcj1yLnBpY2tlckJvcmRlckNvbG9yO2wuYm94Qi5zdHlsZS5iYWNrZ3JvdW5kPXIucGlja2VyRmFjZUNvbG9yO2wucGFkLnN0eWxlLndpZHRoPW14SlNDb2xvci5pbWFnZXMucGFkWzBdKyJweCI7bC5wYWQuc3R5bGUuaGVpZ2h0PW14SlNDb2xvci5pbWFnZXMucGFkWzFdKyJweCI7bC5wYWRCLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7bC5wYWRCLnN0eWxlLmxlZnQ9ci5waWNrZXJGYWNlKyJweCI7bC5wYWRCLnN0eWxlLnRvcD1yLnBpY2tlckZhY2UrInB4IjtsLnBhZEIuc3R5bGUuYm9yZGVyPXIucGlja2VySW5zZXQrInB4IHNvbGlkIjtsLnBhZEIuc3R5bGUuYm9yZGVyQ29sb3I9ci5waWNrZXJJbnNldENvbG9yOwpsLnBhZE0uc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtsLnBhZE0uc3R5bGUubGVmdD0iMCI7bC5wYWRNLnN0eWxlLnRvcD0iMCI7bC5wYWRNLnN0eWxlLndpZHRoPXIucGlja2VyRmFjZSsyKnIucGlja2VySW5zZXQrbXhKU0NvbG9yLmltYWdlcy5wYWRbMF0rbXhKU0NvbG9yLmltYWdlcy5hcnJvd1swXSsicHgiO2wucGFkTS5zdHlsZS5oZWlnaHQ9bC5ib3guc3R5bGUuaGVpZ2h0O2wucGFkTS5zdHlsZS5jdXJzb3I9ImNyb3NzaGFpciI7bC5zbGQuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiI7bC5zbGQuc3R5bGUud2lkdGg9bXhKU0NvbG9yLmltYWdlcy5zbGRbMF0rInB4IjtsLnNsZC5zdHlsZS5oZWlnaHQ9bXhKU0NvbG9yLmltYWdlcy5zbGRbMV0rInB4IjtsLnNsZEIuc3R5bGUuZGlzcGxheT1yLnNsaWRlcj8iYmxvY2siOiJub25lIjtsLnNsZEIuc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtsLnNsZEIuc3R5bGUucmlnaHQ9ci5waWNrZXJGYWNlKyJweCI7bC5zbGRCLnN0eWxlLnRvcD0Kci5waWNrZXJGYWNlKyJweCI7bC5zbGRCLnN0eWxlLmJvcmRlcj1yLnBpY2tlckluc2V0KyJweCBzb2xpZCI7bC5zbGRCLnN0eWxlLmJvcmRlckNvbG9yPXIucGlja2VySW5zZXRDb2xvcjtsLnNsZE0uc3R5bGUuZGlzcGxheT1yLnNsaWRlcj8iYmxvY2siOiJub25lIjtsLnNsZE0uc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtsLnNsZE0uc3R5bGUucmlnaHQ9IjAiO2wuc2xkTS5zdHlsZS50b3A9IjAiO2wuc2xkTS5zdHlsZS53aWR0aD1teEpTQ29sb3IuaW1hZ2VzLnNsZFswXStteEpTQ29sb3IuaW1hZ2VzLmFycm93WzBdK3IucGlja2VyRmFjZSsyKnIucGlja2VySW5zZXQrInB4IjtsLnNsZE0uc3R5bGUuaGVpZ2h0PWwuYm94LnN0eWxlLmhlaWdodDt0cnl7bC5zbGRNLnN0eWxlLmN1cnNvcj0icG9pbnRlciJ9Y2F0Y2goRil7bC5zbGRNLnN0eWxlLmN1cnNvcj0iaGFuZCJ9bC5idG4uc3R5bGUuZGlzcGxheT1yLnBpY2tlckNsb3NhYmxlPyJibG9jayI6Im5vbmUiO2wuYnRuLnN0eWxlLnBvc2l0aW9uPQoiYWJzb2x1dGUiO2wuYnRuLnN0eWxlLmxlZnQ9ci5waWNrZXJGYWNlKyJweCI7bC5idG4uc3R5bGUuYm90dG9tPXIucGlja2VyRmFjZSsicHgiO2wuYnRuLnN0eWxlLnBhZGRpbmc9IjAgMTVweCI7bC5idG4uc3R5bGUuaGVpZ2h0PSIxOHB4IjtsLmJ0bi5zdHlsZS5ib3JkZXI9ci5waWNrZXJJbnNldCsicHggc29saWQiOyhmdW5jdGlvbigpe3ZhciBhPXIucGlja2VySW5zZXRDb2xvci5zcGxpdCgvXHMrLyk7bC5idG4uc3R5bGUuYm9yZGVyQ29sb3I9Mj5hLmxlbmd0aD9hWzBdOmFbMV0rIiAiK2FbMF0rIiAiK2FbMF0rIiAiK2FbMV19KSgpO2wuYnRuLnN0eWxlLmNvbG9yPXIucGlja2VyQnV0dG9uQ29sb3I7bC5idG4uc3R5bGUuZm9udD0iMTJweCBzYW5zLXNlcmlmIjtsLmJ0bi5zdHlsZS50ZXh0QWxpZ249ImNlbnRlciI7dHJ5e2wuYnRuLnN0eWxlLmN1cnNvcj0icG9pbnRlciJ9Y2F0Y2goRil7bC5idG4uc3R5bGUuY3Vyc29yPSJoYW5kIn1sLmJ0bi5vbm1vdXNlZG93bj1mdW5jdGlvbigpe3IuaGlkZVBpY2tlcigpfTsKbC5idG5TLnN0eWxlLmxpbmVIZWlnaHQ9bC5idG4uc3R5bGUuaGVpZ2h0O3N3aXRjaCh0KXtjYXNlIDA6dmFyIHE9ImhzLnBuZyI7YnJlYWs7Y2FzZSAxOnE9Imh2LnBuZyJ9bC5wYWRNLnN0eWxlLmJhY2tncm91bmRJbWFnZT0idXJsKGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaER3QVBBS0VCQUFBQUFQLy8vLy8vLy8vLy95SDVCQUVLQUFJQUxBQUFBQUFQQUE4QUFBSWtsQjhReDUzYjRvdFNVV2N2eWl6NC80QWVRSmJtS1k0cDFISGFwQmx3UEwvdVZSc0ZBRHM9KSI7bC5wYWRNLnN0eWxlLmJhY2tncm91bmRSZXBlYXQ9Im5vLXJlcGVhdCI7bC5zbGRNLnN0eWxlLmJhY2tncm91bmRJbWFnZT0idXJsKGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEJ3QUxBS0VDQUFBQUFQLy8vNmc4ZUtnOGVDSDVCQUVLQUFJQUxBQUFBQUFIQUFzQUFBSVRUSVFZY0xuc2dHeHZpanJ4cWRRcTZEUkpBUUE3KSI7bC5zbGRNLnN0eWxlLmJhY2tncm91bmRSZXBlYXQ9Im5vLXJlcGVhdCI7CmwucGFkLnN0eWxlLmJhY2tncm91bmRJbWFnZT0idXJsKCciK214SlNDb2xvci5nZXREaXIoKStxKyInKSI7bC5wYWQuc3R5bGUuYmFja2dyb3VuZFJlcGVhdD0ibm8tcmVwZWF0IjtsLnBhZC5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb249IjAgMCI7ZigpO2coKTtteEpTQ29sb3IucGlja2VyLm93bmVyPXI7ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImJvZHkiKVswXS5hcHBlbmRDaGlsZChsLmJveEIpfWZ1bmN0aW9uIGUoYSl7cmV0dXJuWzIqYS5waWNrZXJJbnNldCsyKmEucGlja2VyRmFjZStteEpTQ29sb3IuaW1hZ2VzLnBhZFswXSsoYS5zbGlkZXI/MiphLnBpY2tlckluc2V0KzIqbXhKU0NvbG9yLmltYWdlcy5hcnJvd1swXStteEpTQ29sb3IuaW1hZ2VzLnNsZFswXTowKSxhLnBpY2tlckNsb3NhYmxlPzQqYS5waWNrZXJJbnNldCszKmEucGlja2VyRmFjZStteEpTQ29sb3IuaW1hZ2VzLnBhZFsxXSthLnBpY2tlckJ1dHRvbkhlaWdodDoyKmEucGlja2VySW5zZXQrMioKYS5waWNrZXJGYWNlK214SlNDb2xvci5pbWFnZXMucGFkWzFdXX1mdW5jdGlvbiBmKCl7c3dpdGNoKHQpe2Nhc2UgMDp2YXIgYT0xO2JyZWFrO2Nhc2UgMTphPTJ9bXhKU0NvbG9yLnBpY2tlci5wYWRNLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbj1yLnBpY2tlckZhY2Urci5waWNrZXJJbnNldCtNYXRoLnJvdW5kKHIuaHN2WzBdLzYqKG14SlNDb2xvci5pbWFnZXMucGFkWzBdLTEpKS1NYXRoLmZsb29yKG14SlNDb2xvci5pbWFnZXMuY3Jvc3NbMF0vMikrInB4ICIrKHIucGlja2VyRmFjZStyLnBpY2tlckluc2V0K01hdGgucm91bmQoKDEtci5oc3ZbYV0pKihteEpTQ29sb3IuaW1hZ2VzLnBhZFsxXS0xKSktTWF0aC5mbG9vcihteEpTQ29sb3IuaW1hZ2VzLmNyb3NzWzFdLzIpKSsicHgiO2E9bXhKU0NvbG9yLnBpY2tlci5zbGQuY2hpbGROb2Rlcztzd2l0Y2godCl7Y2FzZSAwOmZvcih2YXIgYj1jKHIuaHN2WzBdLHIuaHN2WzFdLDEpLGQ9MDtkPGEubGVuZ3RoO2QrPTEpYVtkXS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9CiJyZ2IoIitiWzBdKigxLWQvYS5sZW5ndGgpKjEwMCsiJSwiK2JbMV0qKDEtZC9hLmxlbmd0aCkqMTAwKyIlLCIrYlsyXSooMS1kL2EubGVuZ3RoKSoxMDArIiUpIjticmVhaztjYXNlIDE6dmFyIGUsZj1bci5oc3ZbMl0sMCwwXSxkPU1hdGguZmxvb3Ioci5oc3ZbMF0pLGc9ZCUyP3IuaHN2WzBdLWQ6MS0oci5oc3ZbMF0tZCk7c3dpdGNoKGQpe2Nhc2UgNjpjYXNlIDA6Yj1bMCwxLDJdO2JyZWFrO2Nhc2UgMTpiPVsxLDAsMl07YnJlYWs7Y2FzZSAyOmI9WzIsMCwxXTticmVhaztjYXNlIDM6Yj1bMiwxLDBdO2JyZWFrO2Nhc2UgNDpiPVsxLDIsMF07YnJlYWs7Y2FzZSA1OmI9WzAsMiwxXX1mb3IoZD0wO2Q8YS5sZW5ndGg7ZCs9MSllPTEtMS8oYS5sZW5ndGgtMSkqZCxmWzFdPWZbMF0qKDEtZSpnKSxmWzJdPWZbMF0qKDEtZSksYVtkXS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9InJnYigiKzEwMCpmW2JbMF1dKyIlLCIrMTAwKmZbYlsxXV0rIiUsIisxMDAqZltiWzJdXSsiJSkifX1mdW5jdGlvbiBnKCl7c3dpdGNoKHQpe2Nhc2UgMDp2YXIgYT0KMjticmVhaztjYXNlIDE6YT0xfW14SlNDb2xvci5waWNrZXIuc2xkTS5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb249IjAgIisoci5waWNrZXJGYWNlK3IucGlja2VySW5zZXQrTWF0aC5yb3VuZCgoMS1yLmhzdlthXSkqKG14SlNDb2xvci5pbWFnZXMuc2xkWzFdLTEpKS1NYXRoLmZsb29yKG14SlNDb2xvci5pbWFnZXMuYXJyb3dbMV0vMikpKyJweCJ9ZnVuY3Rpb24gaygpe3JldHVybiBteEpTQ29sb3IucGlja2VyJiZteEpTQ29sb3IucGlja2VyLm93bmVyPT09cn1mdW5jdGlvbiBsKCl7dSE9PWEmJnIuaW1wb3J0Q29sb3IoKX1mdW5jdGlvbiBtKGEpe3ZhciBiPW14SlNDb2xvci5nZXRSZWxNb3VzZVBvcyhhKTthPWIueC1yLnBpY2tlckZhY2Utci5waWNrZXJJbnNldDtiPWIueS1yLnBpY2tlckZhY2Utci5waWNrZXJJbnNldDtzd2l0Y2godCl7Y2FzZSAwOnIuZnJvbUhTVig2LyhteEpTQ29sb3IuaW1hZ2VzLnBhZFswXS0xKSphLDEtYi8obXhKU0NvbG9yLmltYWdlcy5wYWRbMV0tCjEpLG51bGwsdik7YnJlYWs7Y2FzZSAxOnIuZnJvbUhTVig2LyhteEpTQ29sb3IuaW1hZ2VzLnBhZFswXS0xKSphLG51bGwsMS1iLyhteEpTQ29sb3IuaW1hZ2VzLnBhZFsxXS0xKSx2KX19ZnVuY3Rpb24gbihhKXthPW14SlNDb2xvci5nZXRSZWxNb3VzZVBvcyhhKS55LXIucGlja2VyRmFjZS1yLnBpY2tlckluc2V0O3N3aXRjaCh0KXtjYXNlIDA6ci5mcm9tSFNWKG51bGwsbnVsbCwxLWEvKG14SlNDb2xvci5pbWFnZXMuc2xkWzFdLTEpLEMpO2JyZWFrO2Nhc2UgMTpyLmZyb21IU1YobnVsbCwxLWEvKG14SlNDb2xvci5pbWFnZXMuc2xkWzFdLTEpLG51bGwsQyl9fWZ1bmN0aW9uIHAoKXtpZihyLm9uSW1tZWRpYXRlQ2hhbmdlKWlmKCJzdHJpbmciPT09dHlwZW9mIHIub25JbW1lZGlhdGVDaGFuZ2UpZXZhbChyLm9uSW1tZWRpYXRlQ2hhbmdlKTtlbHNlIHIub25JbW1lZGlhdGVDaGFuZ2Uocil9dGhpcy5hZGp1c3Q9dGhpcy5yZXF1aXJlZD0hMDt0aGlzLmhhc2g9ITE7dGhpcy5zbGlkZXI9CnRoaXMuY2Fwcz0hMDt0aGlzLnN0eWxlRWxlbWVudD10aGlzLnZhbHVlRWxlbWVudD1hO3RoaXMub25JbW1lZGlhdGVDaGFuZ2U9bnVsbDt0aGlzLmhzdj1bMCwwLDFdO3RoaXMucmdiPVsxLDEsMV07dGhpcy5waWNrZXJPbmZvY3VzPSEwO3RoaXMucGlja2VyTW9kZT0iSFNWIjt0aGlzLnBpY2tlclBvc2l0aW9uPSJib3R0b20iO3RoaXMucGlja2VyU21hcnRQb3NpdGlvbj0hMDt0aGlzLnBpY2tlckJ1dHRvbkhlaWdodD0yMDt0aGlzLnBpY2tlckNsb3NhYmxlPSExO3RoaXMucGlja2VyQ2xvc2VUZXh0PSJDbG9zZSI7dGhpcy5waWNrZXJCdXR0b25Db2xvcj0iQnV0dG9uVGV4dCI7dGhpcy5waWNrZXJGYWNlPTA7dGhpcy5waWNrZXJGYWNlQ29sb3I9IlRocmVlREZhY2UiO3RoaXMucGlja2VyQm9yZGVyPTE7dGhpcy5waWNrZXJCb3JkZXJDb2xvcj0iVGhyZWVESGlnaGxpZ2h0IFRocmVlRFNoYWRvdyBUaHJlZURTaGFkb3cgVGhyZWVESGlnaGxpZ2h0Ijt0aGlzLnBpY2tlckluc2V0PQoxO3RoaXMucGlja2VySW5zZXRDb2xvcj0iVGhyZWVEU2hhZG93IFRocmVlREhpZ2hsaWdodCBUaHJlZURIaWdobGlnaHQgVGhyZWVEU2hhZG93Ijt0aGlzLnBpY2tlclpJbmRleD0xRTQ7Zm9yKHZhciBxIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShxKSYmKHRoaXNbcV09YltxXSk7dGhpcy5oaWRlUGlja2VyPWZ1bmN0aW9uKCl7aygpJiYoZGVsZXRlIG14SlNDb2xvci5waWNrZXIub3duZXIsZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImJvZHkiKVswXS5yZW1vdmVDaGlsZChteEpTQ29sb3IucGlja2VyLmJveEIpKX07dGhpcy5zaG93UGlja2VyPWZ1bmN0aW9uKCl7aygpfHwobXhKU0NvbG9yLmdldEVsZW1lbnRQb3MoYSksbXhKU0NvbG9yLmdldEVsZW1lbnRTaXplKGEpLG14SlNDb2xvci5nZXRWaWV3UG9zKCksbXhKU0NvbG9yLmdldFZpZXdTaXplKCksZSh0aGlzKSx0aGlzLnBpY2tlclBvc2l0aW9uLnRvTG93ZXJDYXNlKCksZCgwLDApKX07dGhpcy5pbXBvcnRDb2xvcj0KZnVuY3Rpb24oKXt1P3RoaXMuYWRqdXN0PyF0aGlzLnJlcXVpcmVkJiYvXlxzKiQvLnRlc3QodS52YWx1ZSk/KHUudmFsdWU9IiIseC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2U9eC5qc2NTdHlsZS5iYWNrZ3JvdW5kSW1hZ2UseC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9eC5qc2NTdHlsZS5iYWNrZ3JvdW5kQ29sb3IseC5zdHlsZS5jb2xvcj14LmpzY1N0eWxlLmNvbG9yLHRoaXMuZXhwb3J0Q29sb3IoQXx6KSk6dGhpcy5mcm9tU3RyaW5nKHUudmFsdWUpfHx0aGlzLmV4cG9ydENvbG9yKCk6dGhpcy5mcm9tU3RyaW5nKHUudmFsdWUsQSl8fCh4LnN0eWxlLmJhY2tncm91bmRJbWFnZT14LmpzY1N0eWxlLmJhY2tncm91bmRJbWFnZSx4LnN0eWxlLmJhY2tncm91bmRDb2xvcj14LmpzY1N0eWxlLmJhY2tncm91bmRDb2xvcix4LnN0eWxlLmNvbG9yPXguanNjU3R5bGUuY29sb3IsdGhpcy5leHBvcnRDb2xvcihBfHopKTp0aGlzLmV4cG9ydENvbG9yKCl9O3RoaXMuZXhwb3J0Q29sb3I9ZnVuY3Rpb24oYSl7aWYoIShhJgpBKSYmdSl7dmFyIGI9dGhpcy50b1N0cmluZygpO3RoaXMuY2FwcyYmKGI9Yi50b1VwcGVyQ2FzZSgpKTt0aGlzLmhhc2gmJihiPSIjIitiKTt1LnZhbHVlPWJ9YSZ6fHwheHx8KHguc3R5bGUuYmFja2dyb3VuZEltYWdlPSJub25lIix4LnN0eWxlLmJhY2tncm91bmRDb2xvcj0iIyIrdGhpcy50b1N0cmluZygpLHguc3R5bGUuY29sb3I9LjU+LjIxMyp0aGlzLnJnYlswXSsuNzE1KnRoaXMucmdiWzFdKy4wNzIqdGhpcy5yZ2JbMl0/IiNGRkYiOiIjMDAwIik7YSZDfHwhaygpfHxmKCk7YSZ2fHwhaygpfHxnKCl9O3RoaXMuZnJvbUhTVj1mdW5jdGlvbihhLGIsZCxlKXswPmEmJihhPTApOzY8YSYmKGE9Nik7MD5iJiYoYj0wKTsxPGImJihiPTEpOzA+ZCYmKGQ9MCk7MTxkJiYoZD0xKTt0aGlzLnJnYj1jKG51bGw9PT1hP3RoaXMuaHN2WzBdOnRoaXMuaHN2WzBdPWEsbnVsbD09PWI/dGhpcy5oc3ZbMV06dGhpcy5oc3ZbMV09YixudWxsPT09ZD90aGlzLmhzdlsyXTp0aGlzLmhzdlsyXT0KZCk7dGhpcy5leHBvcnRDb2xvcihlKX07dGhpcy5mcm9tUkdCPWZ1bmN0aW9uKGEsYixjLGQpezA+YSYmKGE9MCk7MTxhJiYoYT0xKTswPmImJihiPTApOzE8YiYmKGI9MSk7MD5jJiYoYz0wKTsxPGMmJihjPTEpO2E9bnVsbD09PWE/dGhpcy5yZ2JbMF06dGhpcy5yZ2JbMF09YTtiPW51bGw9PT1iP3RoaXMucmdiWzFdOnRoaXMucmdiWzFdPWI7dmFyIGU9bnVsbD09PWM/dGhpcy5yZ2JbMl06dGhpcy5yZ2JbMl09YyxmPU1hdGgubWluKE1hdGgubWluKGEsYiksZSk7Yz1NYXRoLm1heChNYXRoLm1heChhLGIpLGUpO3ZhciBnPWMtZjswPT09Zz9hPVtudWxsLDAsY106KGE9YT09PWY/MysoZS1iKS9nOmI9PT1mPzUrKGEtZSkvZzoxKyhiLWEpL2csYT1bNj09PWE/MDphLGcvYyxjXSk7bnVsbCE9PWFbMF0mJih0aGlzLmhzdlswXT1hWzBdKTswIT09YVsyXSYmKHRoaXMuaHN2WzFdPWFbMV0pO3RoaXMuaHN2WzJdPWFbMl07dGhpcy5leHBvcnRDb2xvcihkKX07dGhpcy5mcm9tU3RyaW5nPQpmdW5jdGlvbihhLGIpe3ZhciBjPWEubWF0Y2goL15cVyooWzAtOUEtRl17M30oWzAtOUEtRl17M30pPylcVyokL2kpO3JldHVybiBjPyg2PT09Y1sxXS5sZW5ndGg/dGhpcy5mcm9tUkdCKHBhcnNlSW50KGNbMV0uc3Vic3RyKDAsMiksMTYpLzI1NSxwYXJzZUludChjWzFdLnN1YnN0cigyLDIpLDE2KS8yNTUscGFyc2VJbnQoY1sxXS5zdWJzdHIoNCwyKSwxNikvMjU1LGIpOnRoaXMuZnJvbVJHQihwYXJzZUludChjWzFdLmNoYXJBdCgwKStjWzFdLmNoYXJBdCgwKSwxNikvMjU1LHBhcnNlSW50KGNbMV0uY2hhckF0KDEpK2NbMV0uY2hhckF0KDEpLDE2KS8yNTUscGFyc2VJbnQoY1sxXS5jaGFyQXQoMikrY1sxXS5jaGFyQXQoMiksMTYpLzI1NSxiKSwhMCk6ITF9O3RoaXMudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4oMjU2fE1hdGgucm91bmQoMjU1KnRoaXMucmdiWzBdKSkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSsoMjU2fE1hdGgucm91bmQoMjU1KnRoaXMucmdiWzFdKSkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSsKKDI1NnxNYXRoLnJvdW5kKDI1NSp0aGlzLnJnYlsyXSkpLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSl9O3ZhciByPXRoaXMsdD0iaHZzIj09PXRoaXMucGlja2VyTW9kZS50b0xvd2VyQ2FzZSgpPzE6MCx1PW14SlNDb2xvci5mZXRjaEVsZW1lbnQodGhpcy52YWx1ZUVsZW1lbnQpLHg9bXhKU0NvbG9yLmZldGNoRWxlbWVudCh0aGlzLnN0eWxlRWxlbWVudCkseT0hMSxCPSExLEE9MSx6PTIsQz00LHY9ODt1JiYocT1mdW5jdGlvbigpe3IuZnJvbVN0cmluZyh1LnZhbHVlLEEpO3AoKX0sbXhKU0NvbG9yLmFkZEV2ZW50KHUsImtleXVwIixxKSxteEpTQ29sb3IuYWRkRXZlbnQodSwiaW5wdXQiLHEpLG14SlNDb2xvci5hZGRFdmVudCh1LCJibHVyIixsKSx1LnNldEF0dHJpYnV0ZSgiYXV0b2NvbXBsZXRlIiwib2ZmIikpO3gmJih4LmpzY1N0eWxlPXtiYWNrZ3JvdW5kSW1hZ2U6eC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UsYmFja2dyb3VuZENvbG9yOnguc3R5bGUuYmFja2dyb3VuZENvbG9yLApjb2xvcjp4LnN0eWxlLmNvbG9yfSk7c3dpdGNoKHQpe2Nhc2UgMDpteEpTQ29sb3IucmVxdWlyZUltYWdlKCJocy5wbmciKTticmVhaztjYXNlIDE6bXhKU0NvbG9yLnJlcXVpcmVJbWFnZSgiaHYucG5nIil9dGhpcy5pbXBvcnRDb2xvcigpfX07bXhKU0NvbG9yLmluc3RhbGwoKTsKRWRpdG9yPWZ1bmN0aW9uKGEsYyxmLGQsbSl7bXhFdmVudFNvdXJjZS5jYWxsKHRoaXMpO3RoaXMuY2hyb21lbGVzcz1udWxsIT1hP2E6dGhpcy5jaHJvbWVsZXNzO3RoaXMuaW5pdFN0ZW5jaWxSZWdpc3RyeSgpO3RoaXMuZ3JhcGg9ZHx8dGhpcy5jcmVhdGVHcmFwaChjLGYpO3RoaXMuZWRpdGFibGU9bnVsbCE9bT9tOiFhO3RoaXMudW5kb01hbmFnZXI9dGhpcy5jcmVhdGVVbmRvTWFuYWdlcigpO3RoaXMuc3RhdHVzPSIiO3RoaXMuZ2V0T3JDcmVhdGVGaWxlbmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmZpbGVuYW1lfHxteFJlc291cmNlcy5nZXQoImRyYXdpbmciLFtFZGl0b3IucGFnZUNvdW50ZXJdKSsiLnhtbCJ9O3RoaXMuZ2V0RmlsZW5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5maWxlbmFtZX07dGhpcy5zZXRTdGF0dXM9ZnVuY3Rpb24oYSl7dGhpcy5zdGF0dXM9YTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgic3RhdHVzQ2hhbmdlZCIpKX07dGhpcy5nZXRTdGF0dXM9CmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdHVzfTt0aGlzLmdyYXBoQ2hhbmdlTGlzdGVuZXI9ZnVuY3Rpb24oYSxkKXt2YXIgYj1udWxsIT1kP2QuZ2V0UHJvcGVydHkoImVkaXQiKTpudWxsO251bGwhPWImJmIuaWdub3JlRWRpdHx8dGhpcy5zZXRNb2RpZmllZCghMCl9O3RoaXMuZ3JhcGguZ2V0TW9kZWwoKS5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuZ3JhcGhDaGFuZ2VMaXN0ZW5lci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KSk7dGhpcy5ncmFwaC5yZXNldFZpZXdPblJvb3RDaGFuZ2U9ITE7dGhpcy5pbml0KCl9O0VkaXRvci5wYWdlQ291bnRlcj0wOwooZnVuY3Rpb24oKXt0cnl7Zm9yKHZhciBhPXdpbmRvdztudWxsIT1hLm9wZW5lciYmInVuZGVmaW5lZCIhPT10eXBlb2YgYS5vcGVuZXIuRWRpdG9yJiYhaXNOYU4oYS5vcGVuZXIuRWRpdG9yLnBhZ2VDb3VudGVyKSYmYS5vcGVuZXIhPWE7KWE9YS5vcGVuZXI7bnVsbCE9YSYmKGEuRWRpdG9yLnBhZ2VDb3VudGVyKyssRWRpdG9yLnBhZ2VDb3VudGVyPWEuRWRpdG9yLnBhZ2VDb3VudGVyKX1jYXRjaChjKXt9fSkoKTtFZGl0b3IudXNlTG9jYWxTdG9yYWdlPSJ1bmRlZmluZWQiIT10eXBlb2YgU3RvcmFnZSYmbXhDbGllbnQuSVNfSU9TOwpFZGl0b3IubW92ZUltYWdlPW14Q2xpZW50LklTX1NWRz8iZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJZ2QybGtkR2c5SWpJNGNIZ2lJR2hsYVdkb2REMGlNamh3ZUNJK1BHYytQQzluUGp4blBqeG5QanhuUGp4d1lYUm9JSFJ5WVc1elptOXliVDBpZEhKaGJuTnNZWFJsS0RJdU5Dd3lMalFwYzJOaGJHVW9NQzQ0S1hKdmRHRjBaU2cwTlN3eE1pd3hNaWtpSUhOMGNtOXJaVDBpSXpJNVlqWm1NaUlnWm1sc2JEMGlJekk1WWpabU1pSWdaRDBpVFRFMUxETnNNaTR6TERJdU0yd3RNaTQ0T1N3eUxqZzNiREV1TkRJc01TNDBNa3d4T0M0M0xEWXVOMHd5TVN3NVZqTklNVFY2SUUwekxEbHNNaTR6TFRJdU0yd3lMamczTERJdU9EbHNNUzQwTWkweExqUXlURFl1Tnl3MUxqTk1PU3d6U0ROV09Yb2dUVGtzTWpFZ2JDMHlMak10TWk0emJESXVPRGt0TWk0NE4yd3RNUzQwTWkweExqUXlURFV1TXl3eE55NHpURE1zTVRWMk5rZzVlaUJOTWpFc01UVnNMVEl1TXl3eUxqTnNMVEl1T0RjdE1pNDRPV3d0TVM0ME1pd3hMalF5YkRJdU9Ea3NNaTQ0TjB3eE5Td3lNV2cyVmpFMWVpSXZQand2Wno0OEwyYytQQzluUGp3dmMzWm5QZ289IjpJTUFHRV9QQVRIKwoiL21vdmUucG5nIjtFZGl0b3Iucm93TW92ZUltYWdlPW14Q2xpZW50LklTX1NWRz8iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBY0FBQUFFQkFNQUFBQ3c2RGhPQUFBQUdGQk1WRVV6TXpQLy8vOXRiVzFRVUZDS2lvcEJRVUY4Zkh4ZlgxL0lYbG1YQUFBQUZFbEVRVlFJbVdOZ05WZHpZQkFVRkJSZ2dMTUFFellCeTI5a0VQZ0FBQUFBU1VWT1JLNUNZSUk9IjpJTUFHRV9QQVRIKyIvdGh1bWJfaG9yei5wbmciOwpFZGl0b3IuaGVscEltYWdlPW14Q2xpZW50LklTX1NWRz8iZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJajQ4Y0dGMGFDQm1hV3hzUFNKdWIyNWxJaUJrUFNKTk1DQXdhREkwZGpJMFNEQjZJaTgrUEhCaGRHZ2daRDBpVFRFeElERTRhREoyTFRKb0xUSjJNbnB0TVMweE5rTTJMalE0SURJZ01pQTJMalE0SURJZ01USnpOQzQwT0NBeE1DQXhNQ0F4TUNBeE1DMDBMalE0SURFd0xURXdVekUzTGpVeUlESWdNVElnTW5wdE1DQXhPR010TkM0ME1TQXdMVGd0TXk0MU9TMDRMVGh6TXk0MU9TMDRJRGd0T0NBNElETXVOVGtnT0NBNExUTXVOVGtnT0MwNElEaDZiVEF0TVRSakxUSXVNakVnTUMwMElERXVOemt0TkNBMGFESmpNQzB4TGpFdU9TMHlJREl0TW5NeUlDNDVJRElnTW1Nd0lESXRNeUF4TGpjMUxUTWdOV2d5WXpBdE1pNHlOU0F6TFRJdU5TQXpMVFVnTUMweUxqSXhMVEV1TnprdE5DMDBMVFI2SWk4K1BDOXpkbWMrIjpJTUFHRV9QQVRIKwoiL2hlbHAucG5nIjsKRWRpdG9yLmNoZWNrbWFya0ltYWdlPW14Q2xpZW50LklTX1NWRz8iZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoRlFBVkFNUWZBR3hzYkh4OGZJcUtpb2FHaHZiMjluSnljdnI2K3NEQXdKcWFtbHRiVzVPVGsrbnA2WUdCZ2VUazVMeTh2SmlZbVAzOS9mTHk4cVdscGE2dXJzakl5T0xpNHZqNCtOL2YzKzN0N2ZUMDlMQ3dzSFoyZHVibTVyNit2bVptWnYvLy95SC9DMWhOVUNCRVlYUmhXRTFRUEQ5NGNHRmphMlYwSUdKbFoybHVQU0x2dTc4aUlHbGtQU0pYTlUwd1RYQkRaV2hwU0hweVpWTjZUbFJqZW10ak9XUWlQejRnUEhnNmVHMXdiV1YwWVNCNGJXeHVjenA0UFNKaFpHOWlaVHB1Y3pwdFpYUmhMeUlnZURwNGJYQjBhejBpUVdSdlltVWdXRTFRSUVOdmNtVWdOUzR3TFdNd05qQWdOakV1TVRNME56YzNMQ0F5TURFd0x6QXlMekV5TFRFM09qTXlPakF3SUNBZ0lDQWdJQ0FpUGlBOGNtUm1PbEpFUmlCNGJXeHVjenB5WkdZOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6RTVPVGt2TURJdk1qSXRjbVJtTFhONWJuUmhlQzF1Y3lNaVBpQThjbVJtT2tSbGMyTnlhWEIwYVc5dUlISmtaanBoWW05MWREMGlJaUI0Yld4dWN6cDRiWEE5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM4aUlIaHRiRzV6T25odGNFMU5QU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2YlcwdklpQjRiV3h1Y3pwemRGSmxaajBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDNOVWVYQmxMMUpsYzI5MWNtTmxVbVZtSXlJZ2VHMXdPa055WldGMGIzSlViMjlzUFNKQlpHOWlaU0JRYUc5MGIzTm9iM0FnUTFNMUlGZHBibVJ2ZDNNaUlIaHRjRTFOT2tsdWMzUmhibU5sU1VROUluaHRjQzVwYVdRNk9FWTROVFpFUlRRNVFVRkJNVEZGTVVFNU1UVkRPVE01TVVaR01URTNNMFFpSUhodGNFMU5Pa1J2WTNWdFpXNTBTVVE5SW5odGNDNWthV1E2T0VZNE5UWkVSVFU1UVVGQk1URkZNVUU1TVRWRE9UTTVNVVpHTVRFM00wUWlQaUE4ZUcxd1RVMDZSR1Z5YVhabFpFWnliMjBnYzNSU1pXWTZhVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG80UmpnMU5rUkZNamxCUVVFeE1VVXhRVGt4TlVNNU16a3hSa1l4TVRjelJDSWdjM1JTWldZNlpHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzRSamcxTmtSRk16bEJRVUV4TVVVeFFUa3hOVU01TXpreFJrWXhNVGN6UkNJdlBpQThMM0prWmpwRVpYTmpjbWx3ZEdsdmJqNGdQQzl5WkdZNlVrUkdQaUE4TDNnNmVHMXdiV1YwWVQ0Z1BEOTRjR0ZqYTJWMElHVnVaRDBpY2lJL1BnSC8vdjM4Ky9yNStQZjI5ZlR6OHZIdzcrN3Q3T3ZxNmVqbjV1WGs0K0xoNE4vZTNkemIydG5ZMTliVjFOUFMwZERQenMzTXk4ckp5TWZHeGNURHdzSEF2NzY5dkx1NnViaTN0clcwczdLeHNLK3VyYXlycXFtb3A2YWxwS09pb2FDZm5wMmNtNXFabUplV2xaU1RrcEdRajQ2TmpJdUtpWWlIaG9XRWc0S0JnSDkrZlh4N2VubDRkM1oxZEhOeWNYQnZibTFzYTJwcGFHZG1aV1JqWW1GZ1gxNWRYRnRhV1ZoWFZsVlVVMUpSVUU5T1RVeExTa2xJUjBaRlJFTkNRVUEvUGowOE96bzVPRGMyTlRRek1qRXdMeTR0TENzcUtTZ25KaVVrSXlJaElCOGVIUndiR2hrWUZ4WVZGQk1TRVJBUERnME1Dd29KQ0FjR0JRUURBZ0VBQUNINUJBRUFBQjhBTEFBQUFBQVZBQlVBQUFWSTRDZU9aR21lYUtxdWJLdHlsa3RTZ0NPTFJ5TGQzK1FKRUpuaDRWSGNNb09mWVFYUUxCY0JENFBBNm5nR2xJSW5FSEVoUE9BTlJrYUlGaHE4U3VIQ0UxSGI4TGg4TGdzQkFEcz0iOklNQUdFX1BBVEgrCiIvY2hlY2ttYXJrLmdpZiI7RWRpdG9yLm1heGltaXplSW1hZ2U9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQlVBQUFBVkJBTUFBQUJiT2JpbEFBQUFFbEJNVkVVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEZ0t4bWlBQUFBQlhSU1RsTUE3NTh2WDFQdzNCb0FBQUJKU1VSQlZBalhZOEFKUWtPREdCaFVRME1oYkFVR0JpWVkyNENCZ1JuR0ZtWmdNSVN3Z3d3REdSaEVoVlZCYkFWbUVRWUdSd01tQmpJQVFpL0NUSVJkNkc1QXVBM2R6WVFCQUhqMEVGZEhrdlY0QUFBQUFFbEZUa1N1UW1DQyI7RWRpdG9yLnpvb21PdXRJbWFnZT0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCVUFBQUFWQkFNQUFBQmJPYmlsQUFBQUVsQk1WRVVBQUFBQUFBQXNMQ3h4Y1hFaElTRmdZR0NoalRVeEFBQUFBWFJTVGxNQVFPYllaZ0FBQUVkSlJFRlVDTmRqSUFNd0NRckIyWUtDZ2dKUUpxTXdBN01nbEsxb3dNQmdxQUJWQXBJVGdMSlpYRnhnYklRNFFqM0NISVQ1Z2dvSWU1a2dOa00xS1NEWUtCS3F4UGtEQVBvNUJBWkJFNTRoQUFBQUFFbEZUa1N1UW1DQyI7CkVkaXRvci56b29tSW5JbWFnZT0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCVUFBQUFWQkFNQUFBQmJPYmlsQUFBQUVsQk1WRVVBQUFBQUFBQXNMQ3doSVNGeGNYRmdZR0Jhdkthb0FBQUFBWFJTVGxNQVFPYllaZ0FBQUVsSlJFRlVDTmRqSUFNd0NRckIyWUtDZ2dKUUpxTUlBNHNnbEszb3dNemdxQUJWd3NETXdDZ0FaVE1iRzhQWUNIR0Vlb1E1Q1BNRkZSRDJNa0ZzaG1wU1FMQlJKRlNKOHdjQUVxY0VNMnVobDJNQUFBQUFTVVZPUks1Q1lJST0iO0VkaXRvci56b29tRml0SW1hZ2U9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQlVBQUFBVkJBTUFBQUJiT2JpbEFBQUFEMUJNVkVVQUFBQUFBQUF3TURCd2NIQmdZR0MxeGwwOUFBQUFBWFJTVGxNQVFPYllaZ0FBQUVGSlJFRlVDTmRqSUFNd0NRckIyWUtDZ2dKUUpxTXdBN01nbEsxb3dNQmdxQUJWQXBJVHdNZEdxRWVZZ3pCZlVBRmhMeFBFWnFnbUJRUWJSVUtGT0g4QUFLNU9BM2xBK0ZGT0FBQUFBRWxGVGtTdVFtQ0MiOwpFZGl0b3IubGF5ZXJzSW1hZ2U9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQlVBQUFBVkNBTUFBQUNleVZXa0FBQUFhVkJNVkVVQUFBQWdJQ0FJQ0FnZEhSMFBEdzhXRmhZSUNBZ0xDd3NYRnhjdkx5OE9EZzR1TGk0aUlpSXFLaW9rSkNRWUdCZ0tDZ29uSnljRkJRVUNBZ0lxS2lvY0hCd2NIQndPRGc0ZUhoNGNIQnduSnljSkNRa1VGQlFxS2lvakl5TXVMaTRaR1JrZ0lDQUVCQVRPV1lYQUFBQUFHblJTVGxNQUQ3K2ZuejgvSDcvZmYxOC83Nyt2cjUrZm4zOS9iMjhmSDJ4U29Lc0FBQUNRU1VSQlZCalRyWXhKRXNNZ0RBUlpaTUFZNzNzZ0Njbi9IeG5oS3RuazdqNm9ScTBwc2Z1b3luZFovU3VPRGtIUEx6ZlZUNktleVBlUG5KN0tybmtSaldNWFRuNFNNbk44bVhlMlNTTTN0czhML1pVeHhyYkFVTFNZSkpVTEUwSXc5cGpwZW5vSUNjZ2NYNjFtR2dUZ3RDdjlCZTk5cHpDb0RoTlFXUW5jaEQxbXVwNSsrQ1lHY29RZXhhalpiZndBai8wTUQ4Wk9hVWdBQUFBQVNVVk9SSzVDWUlJPSI7CkVkaXRvci5wcmV2aW91c0ltYWdlPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJRQUFBQVVDQVlBQUFDTmlSME5BQUFBQm1KTFIwUUEvd0QvQVArZ3ZhZVRBQUFBaDBsRVFWUTRqZTNVc1FuQ1VCQ0E0VThocGExTnNvRWpwSFFKUzBkeEFEZHdFTXVNSUprZ0ExaFlDaGJHUWdNaStKQzhxNEwvQUIvdkR1N3g3NGNXV0VaaEpVNDRSbUExenVqUjVHSWJYRjlZTnJqRC9RMGJEUlk0ZkVCWjRQNExsZ1RuQ2JBZjg0cFVNOC85aFkwOHRNVXRFb1ExTHBFZ3JOQkZnbENoRlhSNlE2R2Z3d1I2QUdLSk1GNzRWdHQzQUFBQUFFbEZUa1N1UW1DQyI7RWRpdG9yLm5leHRJbWFnZT0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCUUFBQUFVQ0FZQUFBQ05pUjBOQUFBQUJtSkxSMFFBL3dEL0FQK2d2YWVUQUFBQWkwbEVRVlE0amVYVUlRN0NVQXdBME1lR3hXSTJ5eWx3bkFMSlVkQmNnWXZNN1FZTG1qT1FJQWtJUG1KWmdoaUl2eXBvVXRYMHRmbkpMMzhYNVpmYUVnVWVVY01hbkZCSGdTMFNMbGhIZ2drM2JDUEJoQ2Yya2VDUVI4d2p3WVREcDZZaVp4Sm1PVTFqR3c3dkdBTGVzY3VCeHNBck5sT3dkL0NNMVZTTS91dDFxQ0l3K3VPd2lNSitPRjRDUXpCQ1htM2h5QUFBQUFCSlJVNUVya0pnZ2c9PSI7CkVkaXRvci5lZGl0SW1hZ2U9bXhDbGllbnQuSVNfU1ZHPyJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhDd0FMQUlBQkFGZFhWLy8vL3lINUJBRUFBQUVBTEFBQUFBQUxBQXNBQUFJWmpCOEFpS3VjNGp2TE9HcXpyalg2em1rV3lDaFhhVUpCQVFBNyI6SU1BR0VfUEFUSCsiL2VkaXQuZ2lmIjtFZGl0b3Iuem9vbU91dExhcmdlSW1hZ2U9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBZ0NBTUFBQUJFcElyR0FBQUFpbEJNVkVVQUFBRC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLzJOMmlOQUFBQUxYUlNUbE1BK3ZUY0tNTTk2R1JCSHdYeGkwWWFYMUhMcktXaGlIcFdFT25PcjUyVmIyeEtTRGNUMTlQS3Y1bC9OZ2RrOCt2aUFBQUJKa2xFUVZRNHk0V1QyWGFETUF4RXZXRDJuU1NVTkVuVEpOM3IvLys5U2o3SUxBWTZMMGlqQzRPTllWWlJwbzZjQnlyejJZS1NVR29yR1RwejcxbFBWSHZUK2F2b0I1d0lrVS9teGs4dmVjZVN1Tm9MZzQ0SXp6aVhqdnBpaDcyd0tRbm04eWMyVW9pUC9MQWQ4alFmZTJYZjRQcSsyRXlZSXZ2OXdiekhIQ2d3eERkbEJ0V1pPZHFEZlRDVmdxcHlnUXBzWmFvalZBVmM5VWpReG5BSkRJQmhpUXY4NHRxM2dNUUNBVlR4Vm9TaWJYSmY4dE11YzdlMVRCL0RDbWVqQk5nL3cxWTNjK0FNNXZ2NHc3eE01OS9vWGFtckhhTFZxUFErT1RDbm1NWnhnejBTZEw1emppMC9sZDZqODhxR2E1S0lpQkI2V2VKR0tmVUt3U01LTHVYZ3ZsMVRXMHRtNVI5VVFML2VmU0RZc256eEQ4Q2luaEJzVFRkdWdKYXRLcEp3Zjh2K0FEYjhRbXZXN0FlQUFBQUFBRWxGVGtTdVFtQ0MiOwpFZGl0b3Iuem9vbUluTGFyZ2VJbWFnZT0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDQUFBQUFnQ0FNQUFBQkVwSXJHQUFBQWlsQk1WRVVBQUFELy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vMk4yaU5BQUFBTFhSU1RsTUErdlRjS01NOTZHUkJId1h4aTBZYVgxSExyS1doaUhwV0VPbk9yNTJWYjJ4S1NEY1QxOVBLdjVsL05nZGs4K3ZpQUFBQktFbEVRVlE0eTRXVDZXS0NNQkNFTndrQnduMm9GS3ZXcXIzTCs3OWVzNEVrUUlET0gyZDNQeGsyQUJpSmxCOEpDWGpxdzRMaWtIVkdMSFRtM25NM1VlVk41NjkwR0JCTjBHd3lWLzNra3JVUVIrV2VLblJFZUtwemFYV2Q3N0NtSmlYR2ZQSUVJNFY0eVE5VElXL250bGNNQmU3MzFWdHM5dzVUV0c4RjVqM21RSTRodnJLcGRHZVlBN0NYOXFBY2w2NTBnVkphcnR4UnVoeUhWZ2hGOGlkUUFJYkZMdkNMdTI4QnNRRUM2YUt0Q0s2UHliM0pUN1BtYm10Tkg4Tnk1NkNvdEQvMnFPczVjSmJ1ZmZ4Z1htQ2liK3hkZFZVNVJOT2hrdnZraFRsRmVoelZXQ09oMysrTVlFbE9oZmRvdmFJbW5SWVZtcURkc3VoTnAxUXJCQkU2dUdDMiszWk5qR2RnNUI5NG9EKzl1eVZnV1Q3OUJ3QXhFQlRXZE91M2JXQlZnc24vTi9BSFVEOUlDMDFPZTQwQUFBQUFTVVZPUks1Q1lJST0iOwpFZGl0b3IuYWN0dWFsU2l6ZUxhcmdlSW1hZ2U9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBZ0NBTUFBQUJFcElyR0FBQUFpbEJNVkVVQUFBRC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLzJOMmlOQUFBQUxYUlNUbE1BK3ZUY0tNTTk2R1JCSHdYeGkwWWFYMUhMcktXaGlIcFdFT25PcjUyVmIyeEtTRGNUMTlQS3Y1bC9OZ2RrOCt2aUFBQUJJVWxFUVZRNHk0V1QyWHFESUJDRkJ4RGM5eVRXTkVuVEpOM3IrNzllR1Q0QkViWG5hdWJNcjhkQkJhTTQ1MGRDUXA0TFdGQWFzY0dJUmQ0OGVCNGNOWUU3ZjZYamdHaUNGczVjK2RtbDZDRk42ajFWNklRSWxIUHBkVi91c0tjbUpjVjg4Z1FUUlhqTEQ5TWhiK2ZXcThZRzkvdUNtVENGamVlRGVZODVVR0tJVUdVdXF6TjQya3Y3b0NvdXE5b0hhbWx6VlIxbFZmcEFJdTFRVlJpVytzQXY3cjRGcEFZSVpaVnNSWEI5VFA1RGZwbzFkMXRyQ2d6ejFpaXB0SC9zVWJkejRDek45K21MZVhIbjMraGRkZGQ0UkRlZ3Nydnp3WndTczJHTFBSSmlkQXFDTFRsVndhTVBxcFlNV2pUV0JCMldSVzg2cFZraFNLeURLMmJkdDJ0bWFnWkc0c0JEL2V2ZExRSExFdlFmQU9LUm9MQ21HMUZBQjZ1S21ieStneitSRURuN081K0V3UUFBQUFCSlJVNUVya0pnZ2c9PSI7CkVkaXRvci5wcmludExhcmdlSW1hZ2U9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBZ0NBTUFBQUJFcElyR0FBQUFYVkJNVkVVQUFBRC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vOVJLdnZsQUFBQUhuUlNUbE1BeWRubDc3cWJNTFQwOTNIN0s0TmQ0S3RuMDgyK2xZdDVia2tsRWdQNDRuUVNBQUFBcFVsRVFWUTR5NzNQMlE2RElCUkYwY09nYlJISHpoUC8vNW05bUJBUUtqRzFjVDBZYzdJVEFNdTFMTlFnVVppUTJEWW9OUTBzQ1FiNnFnSEFmUng0OG9wcTNKOUFaNnh1Rjd1T2V3OElrMU9zQ1pSUzJVQUM5VitEOWErUVpZeE5BNDVZRlFmdFB0U2tBVE9odzdkQWMwdlBCd0tXaUlPalAwSloweU11UUoyN2czNkRpcE9Vc3FSQU0wZFI4S0QxL0lMSGFIU0UvdzhESXgwOUUzZy9CVGNlNnJIVUI1c0FQS3ZmRitKZEFBQUFBRWxGVGtTdVFtQ0MiOwpFZGl0b3IubGF5ZXJzTGFyZ2VJbWFnZT0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDQUFBQUFnQ0FNQUFBQkVwSXJHQUFBQW1WQk1WRVVBQUFELy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vKy92Ny8vLytiblpra0FBQUFNblJTVGxNQUJQcjhCeWlEODhLc1RpL3J2SmIyNzJtamVVQTFDdVBlMU0vS2pWeFlIeE1QNktaMFM5bll6R1JHR1Jhem5wR0liemFHVWYwQUFBSEVTVVJCVkRqTGJaTFpZb0l3RUVWRGdMQ2piS0lnQWxxWHF0M20veit1Tnd1MXJjeURoamwza3RuWUw3T1kyNTRDMFZYM3lXRlpmekRyT0NsYmJnS3hpMFlESGp3bDRqYm5Sa1h4SlMvQzFZUDNEYkJoRDFuN0V4NHVhQXFkVkRiM3lKLzRKLzNuSkQydG8vbmdRei9EZlV2ek1wNEpKNXNTQ2FGNW9YbWVtZ1FEZkR4emJpK0txNHNVK3ZOY3VBbXg5NEp0eU9QMkRENEVwejJhc1dTQ3o0Wi80ZkVDeHlOajl6Qzl4TkxIY2RQRU8rYXdES2VTYVV1MFc0dHdaUWlPMmhZVmlzVFIzUkN0Sy9jMVg2dDR4TUVwaUdxWHFWbnRFQkxvbGtaWnNLWTRRdHdINmp6cTY3ZEVIbEp5c0IxYU5PRDNYVDduMVVrYXNRTjU5TDR5QzJSRUxNRFNlQ1J0ejN5VjIyVWIzb3pJVVRrbll4OEpXcURkUXhiVWVzOThjUjJrWnRVU3ZlRi9iQWhjZWR3RVdtbHhJa3BaVXk0WE9DYjZWQmpqeEh2YndvLzFsQkFISGkySkNyME5JNTcwUWh5SHEvRGhKb0UybExneUE0UlZlNkttWjQ3Ty8zYjg2TUNQMEhXYTczQTgvQzNTVWM1UWMxYWp0NmZncFhKK1JHcE12RFNjaGVwWkRPT1FSY1pWSUtjSzkweDJEN2V0cXRJKzU2K3U2bjNzUHJpTzZuZnBoaXRSNCtPMm0zRWJNN2xoM21lMUZNMW8rTE1JODg3ck4rczMvd1pkVEZscE5WSmlPQUFBQUFCSlJVNUVya0pnZ2c9PSI7CkVkaXRvci5jbG9zZUxhcmdlSW1hZ2U9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBZ0NBTUFBQUJFcElyR0FBQUFVVkJNVkVVQUFBRC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy84SU4rZGVBQUFBR25SU1RsTUF1dkFJZy9kRE0vUWxPZXVGaGowUzVzNHZLZ3pqeEpSUU5pTFNleTBBQUFETlNVUkJWRGpMZlpMYkVvTWdERVFqUlJSczFYcVgvLy9RTm1PSEpTbmpQa0hPR1I3SUVtZW9HdEpac3Rud2pxYlJmSXNtZ0VkdFBDcWU5WW56N1pTYzA3ckUyUWlTYytxdjhUdmpSWEEyUERVbTNkcGU4MmlKaE9FVWZ4SkpvM2FDditqS21SbUg0bGNDakNqZWg5R1dPZEwvR1paa1hIM1BZWURySEJuZmM0RC9SVlpmNXNqb0Mxd2FzK1k2SFF4d2FVeEZ2cS9hMFB2MzQzVkNUeGZCU1JpQithYjNNM2VpUVpYbU1OQkozWThwR1JadFlRN0RnSE1YSkVkUExUYU4vcUJqekpPQmMzbm1OY2JzQTE2Yk1SMG9McWYrQUFBQUFFbEZUa1N1UW1DQyI7CkVkaXRvci5lZGl0TGFyZ2VJbWFnZT0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDQUFBQUFnQ0FNQUFBQkVwSXJHQUFBQWdWQk1WRVVBQUFELy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy85ZDN5SlRBQUFBS25SU1RsTUEraHppM25SUVd5WHprbTBoMmozdTU0Z3pFZ1NYamxZb1RCZ0p4TDJsb0dwQU9TM0p0N1d4bTM1R2E3Z1JBQUFBNlVsRVFWUTR5NjNRMlhhQ01CU0Y0UTBKQmFzb1E1REpxYlhqZnY4SGJDSzJCWk53by84RlhIeDdyY01DN2xRdTBpWDhxVS9xdHZBV0Nwb3FIOGRZelMwU3dhVjVlSy9VQWY4WDlwZDJDV0t6dUY1SnJmdHAxb3dYd25JR0xVYUwzUFluZE9IZjRrTk5YV3JYSy9tN0NIdW5rN0s4TEU2WXRCcGNrbndHOUdLeG5yb1kreWxCWGN4NHhLeXgvdS9FdVhpNTA5Y1A5VjdPTzFveUhuenJkRlRjcUxHLzRpYkJBNXBJTXIvNHh2S3p1UURrVnk5d1c4U2dCRkQ2SER2dXpNdnJaY0M5UWxrZk16STd3NjRtK2I0UHFCTU5IQjA1bEgyMVBWeEpvMi9mQlh4VjRoQjM4UGNEKzVBa0k0RnVFVHNBQUFBQVNVVk9SSzVDWUlJPSI7CkVkaXRvci5wcmV2aW91c0xhcmdlSW1hZ2U9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBZ0NBTUFBQUJFcElyR0FBQUFQRkJNVkVVQUFBRC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9ZU1dnVEFBQUFFM1JTVGxNQTdmY2k0OTNjME1XOHVKNkNaa3M0TXhRSEVaTDZld0FBQUZaSlJFRlVPTXZka3NrUmdEQU1BNGxEd2cyQjdiOVhPbGdlL0tLdmRzYTI1S0ZiNVhsUnZ4WEMvRE5CRXY4SUZOakJnR2REZ1h0RmdUeWh3RFhpUUFVSEN2d2E0VXY2bVI2VVIrMWxlZDJtVm9udmwrdE1MNDVxQ1FOUUxJeDdBQUFBQUVsRlRrU3VRbUNDIjtFZGl0b3IubmV4dExhcmdlSW1hZ2U9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBZ0NBTUFBQUJFcElyR0FBQUFQRkJNVkVVQUFBRC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9ZU1dnVEFBQUFFM1JTVGxNQTdmY2k0OTNjME1XOHVKNkNaa3M0TXhRSEVaTDZld0FBQUZSSlJFRlVPTXZkMHNrUmdDQVFCVkVGd1EwVjdmeHpOUVA2d0kwNXY2cFova3lqMWI3Rk5naWsyZ1F6ekxjQXdpVUFpZ0hPVHdESEs0QTFDbUI1QkpBTkpHMWhROXFhZlljcUZsWlAzSUZjOWVWR3JSK2lJZ2tEUVJVWElBQUFBQUJKUlU1RXJrSmdnZz09IjsKRWRpdG9yLnJlZnJlc2hMYXJnZUltYWdlPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNBQUFBQWdDQU1BQUFCRXBJckdBQUFBb2xCTVZFVUFBQUQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vOEVMbmFDQUFBQU5YUlNUbE1BQmZ5RTJRS1UrZGZOeXlEeW9WWUt3blR2N04rNnJudHNZbEZOUWpFcUV3MzE2dVN6ZjJjMUpCM0d2cWViaVZ3NkdBalFCNERRcjEwQUFBRTdTVVJCVkRqTHZaTFhjb013RUFCUElnUkN4M1RUM0EzdWRxTC8vN1VnQWRHUmNSNHlrOGsraWRzZG1nUy9ReVdFcUQvYXhTMkpEVjMzemxuekxISXpRMk1EcTlPZUozbThsNzZLS0VOWWx4cm1NL2I2NVlzMSs4WXhuVEVaRklFWTB2VmhzekZXZlVHWkRKcFFURHpuVGdBZTVrNFhoUXhJTEI3cnV6QlFuK2treURYdUhmUnRqb1lERXZIN0o5THo5OGRCWlhYTDk0WDBPZmNvMlBGbENoS2JqVnpFZGFrb1NsS2pvTm9xUFlrSi93VVpBWXdjK1BwTGoxRWk3K2pkb0JXbHdRWm9KdjJIMXczQ1dnUnZvN2RkOURQNWJ0Z3dDV3owTTAyK29Wb3hDY0lXZVk5UE5tUjZCKyttOXByTXhZRUlTcENCWUJsZnk5YmM3NDVpczdVVVVMQWVtMVd3N0ZmYWxzaUEydWFKc2dtV1AzcFFJOXE5L3lNTGthYUhBcDJmeGhIZmYvY05xN2RCZEhYaEdXN2wrTW8yelUwQ2Y4a25KMnhBMG9KOGVud0FBQUFBU1VWT1JLNUNZSUk9IjsKRWRpdG9yLmJhY2tMYXJnZUltYWdlPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNBQUFBQWdDQU1BQUFCRXBJckdBQUFBY2xCTVZFVUFBQUQvLy8vLy8vLy8vLy8vLy8vKy92Ny8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vKy92Ny8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy84dktMZlRBQUFBSlhSU1RsTUFDaDdoOWdieTNOTEl3endaNTV1VkpnSDU3Yis4dGJDbGpZVjFSUk1RNDZGclR6UXcrdnR4T1FBQUFKNUpSRUZVT011RjAwY1dnekFRQTFEUkRRRkNid0ZTZGY4clpwZFZyTkgyejN0dU12N21sZFpRMldOMnlpOHgrVFQ4SnZ5VGtxdndwaUt2d3NPSXJBMWZXcitYR1RrbGZqOGRPUVIrRDNLeVVGNlF1ZkJrSk4waGZDYXpFdjZzWkJSQ0pEVWNQYXNHS3B1MVJMdFlFOGxrSEFQQlFMb1RzSy9TZkF5Unc1RmpBdWhDekMyTVNqMGdKKzY2bEhhdGdYZEtib0Q5dGZSRUI1bTkvKzNpQzlqSERZdnNHTmNVQUFBQUFFbEZUa1N1UW1DQyI7CkVkaXRvci5mdWxsc2NyZWVuTGFyZ2VJbWFnZT0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDQUFBQUFnQ0FNQUFBQkVwSXJHQUFBQWxsQk1WRVVBQUFELy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL0FKY1dvQUFBQU1YUlNUbE1BK3dJRnhQV1BDSWI0NDZ0blV4bXNvSXlrZ3hUZTI5alFucEtCZTJNTnNaaFZUUi9LeUx1V2JGaEVQalVxN0w5eitiUWorZ0FBQVd4SlJFRlVPTXR0azRsMmdrQU1SVE9EQ080RnRRZ0libldwUzl2OC84ODFpWkZoOFI1MU5POEdKK2dBak1OOHp1VFJGU3cwNGNJT0hRY3FGSEg2b2FRRkd4ZjBqZUJqRWdCOFk1MlRwVzlBZzR6QjVRSUNXT3RIcmd3R3VGWkJjdytnUFAwTUZTNytpaUQ1aW5PbURJUVM5c1pnVHdVendFenl4aHhIVkVFVTdOZERVWHNxVVB0cWpJZ1IySVpTQ1Q0dXB6U2VJZU9kY01IbmZEc3gzZ2lQb2V6ZlU2TXJRR0I1Ly9TY2tMRUcyeFlzY0s0R2ZuVUZxYWl4Mzl6cndvb2FPRC9jWG9ZdXZIS1FJYzdwemQzSFZQdXNwNnQyRkFXL1Jtak1vbmJsOHZ3SERlWm8vR2tsZUpDN2UrcDVYQS9yQXExWC9WMTB3S2FnMDRyQnBhMi9kMExMNE9ZWWNlT0V0c0c1anlNbnRJMXdTK04xQkdjUUJsL0NvTG9QT2w5QUJyVy9CUDUzZTFid1NKSEhsa0lWY2hKd21Id3l5Zko0a0l2RW5LdHdreE5TRWN0ODNLU0NoVDdXaVdnRFozY2NaMEJNNHRsb0pvdzJZVUF0aWZOVDNuam55RCt5L3BNc25QNEROM1k0eWwxR3lrMEFBQUFBU1VWT1JLNUNZSUk9IjsKRWRpdG9yLmN0cmxLZXk9bXhDbGllbnQuSVNfTUFDPyJDbWQiOiJDdHJsIjtFZGl0b3IuaGludE9mZnNldD0yMDtFZGl0b3IucG9wdXBzQWxsb3dlZD0hMDtteFV0aWxzLmV4dGVuZChFZGl0b3IsbXhFdmVudFNvdXJjZSk7RWRpdG9yLnByb3RvdHlwZS5vcmlnaW5hbE5vRm9yZWlnbk9iamVjdD1teENsaWVudC5OT19GTztFZGl0b3IucHJvdG90eXBlLnRyYW5zcGFyZW50SW1hZ2U9bXhDbGllbnQuSVNfU1ZHPyJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhNQUF3QUlBQUFQLy8vd0FBQUNINUJBRUFBQUFBTEFBQUFBQXdBREFBQUFJeGhJK3B5KzBQbzV5MDJvdXozcno3RDRiaVNKYm1pYWJxeXJidUM4ZnlUTmYyamVmNnp2ZitEd3dLaDhTaThlZ3BBQUE3IjpJTUFHRV9QQVRIKyIvdHJhbnNwYXJlbnQuZ2lmIjtFZGl0b3IucHJvdG90eXBlLmV4dGVuZENhbnZhcz0hMDtFZGl0b3IucHJvdG90eXBlLmNocm9tZWxlc3M9ITE7RWRpdG9yLnByb3RvdHlwZS5jYW5jZWxGaXJzdD0hMDsKRWRpdG9yLnByb3RvdHlwZS5lbmFibGVkPSEwO0VkaXRvci5wcm90b3R5cGUuZmlsZW5hbWU9bnVsbDtFZGl0b3IucHJvdG90eXBlLm1vZGlmaWVkPSExO0VkaXRvci5wcm90b3R5cGUuYXV0b3NhdmU9ITA7RWRpdG9yLnByb3RvdHlwZS5pbml0aWFsVG9wU3BhY2luZz0wO0VkaXRvci5wcm90b3R5cGUuYXBwTmFtZT1kb2N1bWVudC50aXRsZTtFZGl0b3IucHJvdG90eXBlLmVkaXRCbGFua1VybD13aW5kb3cubG9jYXRpb24ucHJvdG9jb2wrIi8vIit3aW5kb3cubG9jYXRpb24uaG9zdCsiLyI7RWRpdG9yLnByb3RvdHlwZS5kZWZhdWx0R3JhcGhPdmVyZmxvdz0iaGlkZGVuIjtFZGl0b3IucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oKXt9O0VkaXRvci5wcm90b3R5cGUuaXNDaHJvbWVsZXNzVmlldz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNocm9tZWxlc3N9O0VkaXRvci5wcm90b3R5cGUuc2V0QXV0b3NhdmU9ZnVuY3Rpb24oYSl7dGhpcy5hdXRvc2F2ZT1hO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJhdXRvc2F2ZUNoYW5nZWQiKSl9OwpFZGl0b3IucHJvdG90eXBlLmdldEVkaXRCbGFua1VybD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5lZGl0QmxhbmtVcmwrYX07CkVkaXRvci5wcm90b3R5cGUuZWRpdEFzTmV3PWZ1bmN0aW9uKGEsYyl7dmFyIGY9bnVsbCE9Yz8iP3RpdGxlPSIrZW5jb2RlVVJJQ29tcG9uZW50KGMpOiIiO251bGwhPXVybFBhcmFtcy51aSYmKGYrPSgwPGYubGVuZ3RoPyImIjoiPyIpKyJ1aT0iK3VybFBhcmFtcy51aSk7aWYoInVuZGVmaW5lZCIhPT10eXBlb2Ygd2luZG93LnBvc3RNZXNzYWdlJiYobnVsbD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHwxMDw9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSl7dmFyIGQ9bnVsbCxtPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGMpeyJyZWFkeSI9PWMuZGF0YSYmYy5zb3VyY2U9PWQmJihteEV2ZW50LnJlbW92ZUxpc3RlbmVyKHdpbmRvdywibWVzc2FnZSIsbSksZC5wb3N0TWVzc2FnZShhLCIqIikpfSk7bXhFdmVudC5hZGRMaXN0ZW5lcih3aW5kb3csIm1lc3NhZ2UiLG0pO2Q9dGhpcy5ncmFwaC5vcGVuTGluayh0aGlzLmdldEVkaXRCbGFua1VybChmKygwPGYubGVuZ3RoPyImIjoiPyIpKwoiY2xpZW50PTEiKSxudWxsLCEwKX1lbHNlIHRoaXMuZ3JhcGgub3BlbkxpbmsodGhpcy5nZXRFZGl0QmxhbmtVcmwoZikrIiNSIitlbmNvZGVVUklDb21wb25lbnQoYSkpfTtFZGl0b3IucHJvdG90eXBlLmNyZWF0ZUdyYXBoPWZ1bmN0aW9uKGEsYyl7dmFyIGY9bmV3IEdyYXBoKG51bGwsYyxudWxsLG51bGwsYSk7Zi50cmFuc3BhcmVudEJhY2tncm91bmQ9ITE7dGhpcy5jaHJvbWVsZXNzfHwoZi5pc0JsYW5rTGluaz1mdW5jdGlvbihhKXtyZXR1cm4hdGhpcy5pc0V4dGVybmFsUHJvdG9jb2woYSl9KTtyZXR1cm4gZn07CkVkaXRvci5wcm90b3R5cGUucmVzZXRHcmFwaD1mdW5jdGlvbigpe3RoaXMuZ3JhcGguZ3JpZEVuYWJsZWQ9IXRoaXMuaXNDaHJvbWVsZXNzVmlldygpfHwiMSI9PXVybFBhcmFtcy5ncmlkO3RoaXMuZ3JhcGguZ3JhcGhIYW5kbGVyLmd1aWRlc0VuYWJsZWQ9ITA7dGhpcy5ncmFwaC5zZXRUb29sdGlwcyghMCk7dGhpcy5ncmFwaC5zZXRDb25uZWN0YWJsZSghMCk7dGhpcy5ncmFwaC5mb2xkaW5nRW5hYmxlZD0hMDt0aGlzLmdyYXBoLnNjcm9sbGJhcnM9dGhpcy5ncmFwaC5kZWZhdWx0U2Nyb2xsYmFyczt0aGlzLmdyYXBoLnBhZ2VWaXNpYmxlPXRoaXMuZ3JhcGguZGVmYXVsdFBhZ2VWaXNpYmxlO3RoaXMuZ3JhcGgucGFnZUJyZWFrc1Zpc2libGU9dGhpcy5ncmFwaC5wYWdlVmlzaWJsZTt0aGlzLmdyYXBoLnByZWZlclBhZ2VTaXplPXRoaXMuZ3JhcGgucGFnZUJyZWFrc1Zpc2libGU7dGhpcy5ncmFwaC5iYWNrZ3JvdW5kPW51bGw7dGhpcy5ncmFwaC5wYWdlU2NhbGU9bXhHcmFwaC5wcm90b3R5cGUucGFnZVNjYWxlOwp0aGlzLmdyYXBoLnBhZ2VGb3JtYXQ9bXhHcmFwaC5wcm90b3R5cGUucGFnZUZvcm1hdDt0aGlzLmdyYXBoLmN1cnJlbnRTY2FsZT0xO3RoaXMuZ3JhcGguY3VycmVudFRyYW5zbGF0ZS54PTA7dGhpcy5ncmFwaC5jdXJyZW50VHJhbnNsYXRlLnk9MDt0aGlzLnVwZGF0ZUdyYXBoQ29tcG9uZW50cygpO3RoaXMuZ3JhcGgudmlldy5zZXRTY2FsZSgxKX07CkVkaXRvci5wcm90b3R5cGUucmVhZEdyYXBoU3RhdGU9ZnVuY3Rpb24oYSl7dGhpcy5ncmFwaC5ncmlkRW5hYmxlZD0iMCIhPWEuZ2V0QXR0cmlidXRlKCJncmlkIikmJighdGhpcy5pc0Nocm9tZWxlc3NWaWV3KCl8fCIxIj09dXJsUGFyYW1zLmdyaWQpO3RoaXMuZ3JhcGguZ3JpZFNpemU9cGFyc2VGbG9hdChhLmdldEF0dHJpYnV0ZSgiZ3JpZFNpemUiKSl8fG14R3JhcGgucHJvdG90eXBlLmdyaWRTaXplO3RoaXMuZ3JhcGguZ3JhcGhIYW5kbGVyLmd1aWRlc0VuYWJsZWQ9IjAiIT1hLmdldEF0dHJpYnV0ZSgiZ3VpZGVzIik7dGhpcy5ncmFwaC5zZXRUb29sdGlwcygiMCIhPWEuZ2V0QXR0cmlidXRlKCJ0b29sdGlwcyIpKTt0aGlzLmdyYXBoLnNldENvbm5lY3RhYmxlKCIwIiE9YS5nZXRBdHRyaWJ1dGUoImNvbm5lY3QiKSk7dGhpcy5ncmFwaC5jb25uZWN0aW9uQXJyb3dzRW5hYmxlZD0iMCIhPWEuZ2V0QXR0cmlidXRlKCJhcnJvd3MiKTt0aGlzLmdyYXBoLmZvbGRpbmdFbmFibGVkPQoiMCIhPWEuZ2V0QXR0cmlidXRlKCJmb2xkIik7dGhpcy5pc0Nocm9tZWxlc3NWaWV3KCkmJnRoaXMuZ3JhcGguZm9sZGluZ0VuYWJsZWQmJih0aGlzLmdyYXBoLmZvbGRpbmdFbmFibGVkPSIxIj09dXJsUGFyYW1zLm5hdix0aGlzLmdyYXBoLmNlbGxSZW5kZXJlci5mb3JjZUNvbnRyb2xDbGlja0hhbmRsZXI9dGhpcy5ncmFwaC5mb2xkaW5nRW5hYmxlZCk7dmFyIGM9cGFyc2VGbG9hdChhLmdldEF0dHJpYnV0ZSgicGFnZVNjYWxlIikpOyFpc05hTihjKSYmMDxjP3RoaXMuZ3JhcGgucGFnZVNjYWxlPWM6dGhpcy5ncmFwaC5wYWdlU2NhbGU9bXhHcmFwaC5wcm90b3R5cGUucGFnZVNjYWxlO3RoaXMuZ3JhcGguaXNMaWdodGJveFZpZXcoKXx8dGhpcy5ncmFwaC5pc1ZpZXdlcigpP3RoaXMuZ3JhcGgucGFnZVZpc2libGU9ITE6KGM9YS5nZXRBdHRyaWJ1dGUoInBhZ2UiKSx0aGlzLmdyYXBoLnBhZ2VWaXNpYmxlPW51bGwhPWM/IjAiIT1jOnRoaXMuZ3JhcGguZGVmYXVsdFBhZ2VWaXNpYmxlKTsKdGhpcy5ncmFwaC5wYWdlQnJlYWtzVmlzaWJsZT10aGlzLmdyYXBoLnBhZ2VWaXNpYmxlO3RoaXMuZ3JhcGgucHJlZmVyUGFnZVNpemU9dGhpcy5ncmFwaC5wYWdlQnJlYWtzVmlzaWJsZTt2YXIgYz1wYXJzZUZsb2F0KGEuZ2V0QXR0cmlidXRlKCJwYWdlV2lkdGgiKSksZj1wYXJzZUZsb2F0KGEuZ2V0QXR0cmlidXRlKCJwYWdlSGVpZ2h0IikpO2lzTmFOKGMpfHxpc05hTihmKXx8KHRoaXMuZ3JhcGgucGFnZUZvcm1hdD1uZXcgbXhSZWN0YW5nbGUoMCwwLGMsZikpO2E9YS5nZXRBdHRyaWJ1dGUoImJhY2tncm91bmQiKTt0aGlzLmdyYXBoLmJhY2tncm91bmQ9bnVsbCE9YSYmMDxhLmxlbmd0aD9hOm51bGx9OwpFZGl0b3IucHJvdG90eXBlLnNldEdyYXBoWG1sPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe3ZhciBjPW5ldyBteENvZGVjKGEub3duZXJEb2N1bWVudCk7aWYoIm14R3JhcGhNb2RlbCI9PWEubm9kZU5hbWUpe3RoaXMuZ3JhcGgubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7dGhpcy5ncmFwaC5tb2RlbC5jbGVhcigpLHRoaXMuZ3JhcGgudmlldy5zY2FsZT0xLHRoaXMucmVhZEdyYXBoU3RhdGUoYSksdGhpcy51cGRhdGVHcmFwaENvbXBvbmVudHMoKSxjLmRlY29kZShhLHRoaXMuZ3JhcGguZ2V0TW9kZWwoKSl9ZmluYWxseXt0aGlzLmdyYXBoLm1vZGVsLmVuZFVwZGF0ZSgpfXRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJyZXNldEdyYXBoVmlldyIpKX1lbHNlIGlmKCJyb290Ij09YS5ub2RlTmFtZSl7dGhpcy5yZXNldEdyYXBoKCk7dmFyIGY9Yy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJteEdyYXBoTW9kZWwiKTtmLmFwcGVuZENoaWxkKGEpO2MuZGVjb2RlKGYsdGhpcy5ncmFwaC5nZXRNb2RlbCgpKTsKdGhpcy51cGRhdGVHcmFwaENvbXBvbmVudHMoKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgicmVzZXRHcmFwaFZpZXciKSl9ZWxzZSB0aHJvd3ttZXNzYWdlOm14UmVzb3VyY2VzLmdldCgiY2Fubm90T3BlbkZpbGUiKSxub2RlOmEsdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tZXNzYWdlfX07fWVsc2UgdGhpcy5yZXNldEdyYXBoKCksdGhpcy5ncmFwaC5tb2RlbC5jbGVhcigpLHRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJyZXNldEdyYXBoVmlldyIpKX07CkVkaXRvci5wcm90b3R5cGUuZ2V0R3JhcGhYbWw9ZnVuY3Rpb24oYSl7YT0obnVsbCE9YT9hOjEpPyhuZXcgbXhDb2RlYyhteFV0aWxzLmNyZWF0ZVhtbERvY3VtZW50KCkpKS5lbmNvZGUodGhpcy5ncmFwaC5nZXRNb2RlbCgpKTp0aGlzLmdyYXBoLmVuY29kZUNlbGxzKG14VXRpbHMuc29ydENlbGxzKHRoaXMuZ3JhcGgubW9kZWwuZ2V0VG9wbW9zdENlbGxzKHRoaXMuZ3JhcGguZ2V0U2VsZWN0aW9uQ2VsbHMoKSkpKTtpZigwIT10aGlzLmdyYXBoLnZpZXcudHJhbnNsYXRlLnh8fDAhPXRoaXMuZ3JhcGgudmlldy50cmFuc2xhdGUueSlhLnNldEF0dHJpYnV0ZSgiZHgiLE1hdGgucm91bmQoMTAwKnRoaXMuZ3JhcGgudmlldy50cmFuc2xhdGUueCkvMTAwKSxhLnNldEF0dHJpYnV0ZSgiZHkiLE1hdGgucm91bmQoMTAwKnRoaXMuZ3JhcGgudmlldy50cmFuc2xhdGUueSkvMTAwKTthLnNldEF0dHJpYnV0ZSgiZ3JpZCIsdGhpcy5ncmFwaC5pc0dyaWRFbmFibGVkKCk/IjEiOiIwIik7YS5zZXRBdHRyaWJ1dGUoImdyaWRTaXplIiwKdGhpcy5ncmFwaC5ncmlkU2l6ZSk7YS5zZXRBdHRyaWJ1dGUoImd1aWRlcyIsdGhpcy5ncmFwaC5ncmFwaEhhbmRsZXIuZ3VpZGVzRW5hYmxlZD8iMSI6IjAiKTthLnNldEF0dHJpYnV0ZSgidG9vbHRpcHMiLHRoaXMuZ3JhcGgudG9vbHRpcEhhbmRsZXIuaXNFbmFibGVkKCk/IjEiOiIwIik7YS5zZXRBdHRyaWJ1dGUoImNvbm5lY3QiLHRoaXMuZ3JhcGguY29ubmVjdGlvbkhhbmRsZXIuaXNFbmFibGVkKCk/IjEiOiIwIik7YS5zZXRBdHRyaWJ1dGUoImFycm93cyIsdGhpcy5ncmFwaC5jb25uZWN0aW9uQXJyb3dzRW5hYmxlZD8iMSI6IjAiKTthLnNldEF0dHJpYnV0ZSgiZm9sZCIsdGhpcy5ncmFwaC5mb2xkaW5nRW5hYmxlZD8iMSI6IjAiKTthLnNldEF0dHJpYnV0ZSgicGFnZSIsdGhpcy5ncmFwaC5wYWdlVmlzaWJsZT8iMSI6IjAiKTthLnNldEF0dHJpYnV0ZSgicGFnZVNjYWxlIix0aGlzLmdyYXBoLnBhZ2VTY2FsZSk7YS5zZXRBdHRyaWJ1dGUoInBhZ2VXaWR0aCIsdGhpcy5ncmFwaC5wYWdlRm9ybWF0LndpZHRoKTsKYS5zZXRBdHRyaWJ1dGUoInBhZ2VIZWlnaHQiLHRoaXMuZ3JhcGgucGFnZUZvcm1hdC5oZWlnaHQpO251bGwhPXRoaXMuZ3JhcGguYmFja2dyb3VuZCYmYS5zZXRBdHRyaWJ1dGUoImJhY2tncm91bmQiLHRoaXMuZ3JhcGguYmFja2dyb3VuZCk7cmV0dXJuIGF9O0VkaXRvci5wcm90b3R5cGUudXBkYXRlR3JhcGhDb21wb25lbnRzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5ncmFwaDtudWxsIT1hLmNvbnRhaW5lciYmKGEudmlldy52YWxpZGF0ZUJhY2tncm91bmQoKSxhLmNvbnRhaW5lci5zdHlsZS5vdmVyZmxvdz1hLnNjcm9sbGJhcnM/ImF1dG8iOnRoaXMuZGVmYXVsdEdyYXBoT3ZlcmZsb3csdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInVwZGF0ZUdyYXBoQ29tcG9uZW50cyIpKSl9O0VkaXRvci5wcm90b3R5cGUuc2V0TW9kaWZpZWQ9ZnVuY3Rpb24oYSl7dGhpcy5tb2RpZmllZD1hfTsKRWRpdG9yLnByb3RvdHlwZS5zZXRGaWxlbmFtZT1mdW5jdGlvbihhKXt0aGlzLmZpbGVuYW1lPWF9OwpFZGl0b3IucHJvdG90eXBlLmNyZWF0ZVVuZG9NYW5hZ2VyPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5ncmFwaCxjPW5ldyBteFVuZG9NYW5hZ2VyO3RoaXMudW5kb0xpc3RlbmVyPWZ1bmN0aW9uKGEsZil7Yy51bmRvYWJsZUVkaXRIYXBwZW5lZChmLmdldFByb3BlcnR5KCJlZGl0IikpfTt2YXIgZj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGMpe3RoaXMudW5kb0xpc3RlbmVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pO2EuZ2V0TW9kZWwoKS5hZGRMaXN0ZW5lcihteEV2ZW50LlVORE8sZik7YS5nZXRWaWV3KCkuYWRkTGlzdGVuZXIobXhFdmVudC5VTkRPLGYpO2Y9ZnVuY3Rpb24oZCxjKXt2YXIgZj1hLmdldFNlbGVjdGlvbkNlbGxzRm9yQ2hhbmdlcyhjLmdldFByb3BlcnR5KCJlZGl0IikuY2hhbmdlcyxmdW5jdGlvbihhKXtyZXR1cm4hKGEgaW5zdGFuY2VvZiBteENoaWxkQ2hhbmdlKX0pO2lmKDA8Zi5sZW5ndGgpe2EuZ2V0TW9kZWwoKTtmb3IodmFyIG09W10sYj0wO2I8CmYubGVuZ3RoO2IrKyludWxsIT1hLnZpZXcuZ2V0U3RhdGUoZltiXSkmJm0ucHVzaChmW2JdKTthLnNldFNlbGVjdGlvbkNlbGxzKG0pfX07Yy5hZGRMaXN0ZW5lcihteEV2ZW50LlVORE8sZik7Yy5hZGRMaXN0ZW5lcihteEV2ZW50LlJFRE8sZik7cmV0dXJuIGN9O0VkaXRvci5wcm90b3R5cGUuaW5pdFN0ZW5jaWxSZWdpc3RyeT1mdW5jdGlvbigpe307RWRpdG9yLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5ncmFwaCYmKHRoaXMuZ3JhcGguZGVzdHJveSgpLHRoaXMuZ3JhcGg9bnVsbCl9O09wZW5GaWxlPWZ1bmN0aW9uKGEpe3RoaXMuY29uc3VtZXI9dGhpcy5wcm9kdWNlcj1udWxsO3RoaXMuZG9uZT1hO3RoaXMuYXJncz1udWxsfTtPcGVuRmlsZS5wcm90b3R5cGUuc2V0Q29uc3VtZXI9ZnVuY3Rpb24oYSl7dGhpcy5jb25zdW1lcj1hO3RoaXMuZXhlY3V0ZSgpfTsKT3BlbkZpbGUucHJvdG90eXBlLnNldERhdGE9ZnVuY3Rpb24oKXt0aGlzLmFyZ3M9YXJndW1lbnRzO3RoaXMuZXhlY3V0ZSgpfTtPcGVuRmlsZS5wcm90b3R5cGUuZXJyb3I9ZnVuY3Rpb24oYSl7dGhpcy5jYW5jZWwoITApO214VXRpbHMuYWxlcnQoYSl9O09wZW5GaWxlLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5jb25zdW1lciYmbnVsbCE9dGhpcy5hcmdzJiYodGhpcy5jYW5jZWwoITEpLHRoaXMuY29uc3VtZXIuYXBwbHkodGhpcyx0aGlzLmFyZ3MpKX07T3BlbkZpbGUucHJvdG90eXBlLmNhbmNlbD1mdW5jdGlvbihhKXtudWxsIT10aGlzLmRvbmUmJnRoaXMuZG9uZShudWxsIT1hP2E6ITApfTsKZnVuY3Rpb24gRGlhbG9nKGEsYyxmLGQsbSxrLHEsYixlLGcscCl7dmFyIGw9MDtteENsaWVudC5JU19WTUwmJihudWxsPT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fDg+ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSYmKGw9ODApO2YrPWw7ZCs9bDt2YXIgbj1mLHY9ZCx0PW14VXRpbHMuZ2V0RG9jdW1lbnRTaXplKCk7bnVsbCE9d2luZG93LmlubmVySGVpZ2h0JiYodC5oZWlnaHQ9d2luZG93LmlubmVySGVpZ2h0KTt2YXIgeT10LmhlaWdodCx4PU1hdGgubWF4KDEsTWF0aC5yb3VuZCgodC53aWR0aC1mLTY0KS8yKSksRT1NYXRoLm1heCgxLE1hdGgucm91bmQoKHktZC1hLmZvb3RlckhlaWdodCkvMykpO214Q2xpZW50LklTX1FVSVJLU3x8KGMuc3R5bGUubWF4SGVpZ2h0PSIxMDAlIik7Zj1udWxsIT1kb2N1bWVudC5ib2R5P01hdGgubWluKGYsZG9jdW1lbnQuYm9keS5zY3JvbGxXaWR0aC02NCk6ZjtkPU1hdGgubWluKGQseS02NCk7MDxhLmRpYWxvZ3MubGVuZ3RoJiYodGhpcy56SW5kZXgrPQoyKmEuZGlhbG9ncy5sZW5ndGgpO251bGw9PXRoaXMuYmcmJih0aGlzLmJnPWEuY3JlYXRlRGl2KCJiYWNrZ3JvdW5kIiksdGhpcy5iZy5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiLHRoaXMuYmcuc3R5bGUuYmFja2dyb3VuZD1EaWFsb2cuYmFja2Ryb3BDb2xvcix0aGlzLmJnLnN0eWxlLmhlaWdodD15KyJweCIsdGhpcy5iZy5zdHlsZS5yaWdodD0iMHB4Iix0aGlzLmJnLnN0eWxlLnpJbmRleD10aGlzLnpJbmRleC0yLG14VXRpbHMuc2V0T3BhY2l0eSh0aGlzLmJnLHRoaXMuYmdPcGFjaXR5KSxteENsaWVudC5JU19RVUlSS1MmJm5ldyBteERpdlJlc2l6ZXIodGhpcy5iZykpO3Q9bXhVdGlscy5nZXREb2N1bWVudFNjcm9sbE9yaWdpbihkb2N1bWVudCk7dGhpcy5iZy5zdHlsZS5sZWZ0PXQueCsicHgiO3RoaXMuYmcuc3R5bGUudG9wPXQueSsicHgiO3grPXQueDtFKz10Lnk7bSYmZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmJnKTt2YXIgQT1hLmNyZWF0ZURpdihlPyJnZVRyYW5zRGlhbG9nIjoKImdlRGlhbG9nIik7bT10aGlzLmdldFBvc2l0aW9uKHgsRSxmLGQpO3g9bS54O0U9bS55O0Euc3R5bGUud2lkdGg9ZisicHgiO0Euc3R5bGUuaGVpZ2h0PWQrInB4IjtBLnN0eWxlLmxlZnQ9eCsicHgiO0Euc3R5bGUudG9wPUUrInB4IjtBLnN0eWxlLnpJbmRleD10aGlzLnpJbmRleDtBLmFwcGVuZENoaWxkKGMpO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoQSk7IWImJmMuY2xpZW50SGVpZ2h0PkEuY2xpZW50SGVpZ2h0LTY0JiYoYy5zdHlsZS5vdmVyZmxvd1k9ImF1dG8iKTtpZihrJiYoaz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKSxrLnNldEF0dHJpYnV0ZSgic3JjIixEaWFsb2cucHJvdG90eXBlLmNsb3NlSW1hZ2UpLGsuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJjbG9zZSIpKSxrLmNsYXNzTmFtZT0iZ2VEaWFsb2dDbG9zZSIsay5zdHlsZS50b3A9RSsxNCsicHgiLGsuc3R5bGUubGVmdD14K2YrMzgtbCsicHgiLGsuc3R5bGUuekluZGV4PQp0aGlzLnpJbmRleCxteEV2ZW50LmFkZExpc3RlbmVyKGssImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2EuaGlkZURpYWxvZyghMCl9KSksZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChrKSx0aGlzLmRpYWxvZ0ltZz1rLCFwKSl7dmFyIEM9ITE7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKHRoaXMuYmcsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7Qz0hMH0pLG51bGwsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7QyYmKGEuaGlkZURpYWxvZyghMCksQz0hMSl9KSl9dGhpcy5yZXNpemVMaXN0ZW5lcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2lmKG51bGwhPWcpe3ZhciBlPWcoKTtudWxsIT1lJiYobj1mPWUudyx2PWQ9ZS5oKX1lPW14VXRpbHMuZ2V0RG9jdW1lbnRTaXplKCk7eT1lLmhlaWdodDt0aGlzLmJnLnN0eWxlLmhlaWdodD15KyJweCI7eD1NYXRoLm1heCgxLE1hdGgucm91bmQoKGUud2lkdGgtZi02NCkvMikpO0U9TWF0aC5tYXgoMSwKTWF0aC5yb3VuZCgoeS1kLWEuZm9vdGVySGVpZ2h0KS8zKSk7Zj1udWxsIT1kb2N1bWVudC5ib2R5P01hdGgubWluKG4sZG9jdW1lbnQuYm9keS5zY3JvbGxXaWR0aC02NCk6bjtkPU1hdGgubWluKHYseS02NCk7ZT10aGlzLmdldFBvc2l0aW9uKHgsRSxmLGQpO3g9ZS54O0U9ZS55O0Euc3R5bGUubGVmdD14KyJweCI7QS5zdHlsZS50b3A9RSsicHgiO0Euc3R5bGUud2lkdGg9ZisicHgiO0Euc3R5bGUuaGVpZ2h0PWQrInB4IjshYiYmYy5jbGllbnRIZWlnaHQ+QS5jbGllbnRIZWlnaHQtNjQmJihjLnN0eWxlLm92ZXJmbG93WT0iYXV0byIpO251bGwhPXRoaXMuZGlhbG9nSW1nJiYodGhpcy5kaWFsb2dJbWcuc3R5bGUudG9wPUUrMTQrInB4Iix0aGlzLmRpYWxvZ0ltZy5zdHlsZS5sZWZ0PXgrZiszOC1sKyJweCIpfSk7bXhFdmVudC5hZGRMaXN0ZW5lcih3aW5kb3csInJlc2l6ZSIsdGhpcy5yZXNpemVMaXN0ZW5lcik7dGhpcy5vbkRpYWxvZ0Nsb3NlPXE7dGhpcy5jb250YWluZXI9CkE7YS5lZGl0b3IuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJzaG93RGlhbG9nIikpfURpYWxvZy5iYWNrZHJvcENvbG9yPSJ3aGl0ZSI7RGlhbG9nLnByb3RvdHlwZS56SW5kZXg9bXhQb3B1cE1lbnUucHJvdG90eXBlLnpJbmRleC0xOwpEaWFsb2cucHJvdG90eXBlLm5vQ29sb3JJbWFnZT1teENsaWVudC5JU19TVkc/ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkFBQUFBUUNBTUFBQUFvTFE5VEFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeUJwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVNQzFqTURZd0lEWXhMakV6TkRjM055d2dNakF4TUM4d01pOHhNaTB4Tnpvek1qb3dNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5UTlNCWGFXNWtiM2R6SWlCNGJYQk5UVHBKYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2tFelJEbEJNVVV3T0RZeE1URXhSVEZDTXpBNFJEZERNakpCTUVNeFJETTNJaUI0YlhCTlRUcEViMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPa0V6UkRsQk1VVXhPRFl4TVRFeFJURkNNekE0UkRkRE1qSkJNRU14UkRNM0lqNGdQSGh0Y0UxTk9rUmxjbWwyWldSR2NtOXRJSE4wVW1WbU9tbHVjM1JoYm1ObFNVUTlJbmh0Y0M1cGFXUTZRVE5FT1VFeFJFVTROakV4TVRGRk1VSXpNRGhFTjBNeU1rRXdRekZFTXpjaUlITjBVbVZtT21SdlkzVnRaVzUwU1VROUluaHRjQzVrYVdRNlFUTkVPVUV4UkVZNE5qRXhNVEZGTVVJek1EaEVOME15TWtFd1F6RkVNemNpTHo0Z1BDOXlaR1k2UkdWelkzSnBjSFJwYjI0K0lEd3ZjbVJtT2xKRVJqNGdQQzk0T25odGNHMWxkR0UrSUR3L2VIQmhZMnRsZENCbGJtUTlJbklpUHo1eGgzZm1BQUFBQmxCTVZFWC8vLy9Nek13NDZxcURBQUFBR0VsRVFWUjQybUpnZ0FKR0tHQVlJSUdCdGg4S0FBSU1BRVVRQUlFbG5MdVFBQUFBQUVsRlRrU3VRbUNDIjpJTUFHRV9QQVRIKwoiL25vY29sb3IucG5nIjtEaWFsb2cucHJvdG90eXBlLmNsb3NlSW1hZ2U9bXhDbGllbnQuSVNfU1ZHPyJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFrQUFBQUpBUU1BQUFEYVg1UlRBQUFBQmxCTVZFVjdtcjMvLy8rd2tzc3BBQUFBQW5SU1RsUC9BT1czTUVvQUFBQWRTVVJCVkFnZFk5alh3Q0REd05EUndIQ3dnZUV4bUFTeWdTTDdHZ0IxMlFpcU5IWlpJd0FBQUFCSlJVNUVya0pnZ2c9PSI6SU1BR0VfUEFUSCsiL2Nsb3NlLnBuZyI7CkRpYWxvZy5wcm90b3R5cGUuY2xlYXJJbWFnZT1teENsaWVudC5JU19TVkc/ImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaERRQUtBSUFCQU1EQXdQLy8veUgvQzFoTlVDQkVZWFJoV0UxUVBEOTRjR0ZqYTJWMElHSmxaMmx1UFNMdnU3OGlJR2xrUFNKWE5VMHdUWEJEWldocFNIcHlaVk42VGxSamVtdGpPV1FpUHo0Z1BIZzZlRzF3YldWMFlTQjRiV3h1Y3pwNFBTSmhaRzlpWlRwdWN6cHRaWFJoTHlJZ2VEcDRiWEIwYXowaVFXUnZZbVVnV0UxUUlFTnZjbVVnTlM0d0xXTXdOakFnTmpFdU1UTTBOemMzTENBeU1ERXdMekF5THpFeUxURTNPak15T2pBd0lDQWdJQ0FnSUNBaVBpQThjbVJtT2xKRVJpQjRiV3h1Y3pweVpHWTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1Rrdk1ESXZNakl0Y21SbUxYTjViblJoZUMxdWN5TWlQaUE4Y21SbU9rUmxjMk55YVhCMGFXOXVJSEprWmpwaFltOTFkRDBpSWlCNGJXeHVjenA0YlhBOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOGlJSGh0Ykc1ek9uaHRjRTFOUFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdmJXMHZJaUI0Yld4dWN6cHpkRkpsWmowaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wzTlVlWEJsTDFKbGMyOTFjbU5sVW1WbUl5SWdlRzF3T2tOeVpXRjBiM0pVYjI5c1BTSkJaRzlpWlNCUWFHOTBiM05vYjNBZ1ExTTFJRmRwYm1SdmQzTWlJSGh0Y0UxTk9rbHVjM1JoYm1ObFNVUTlJbmh0Y0M1cGFXUTZPVUl6T0VNMU56STROakV5TVRGRk1VRXpNa05ETVVFM05qWkVSREUyUWpJaUlIaHRjRTFOT2tSdlkzVnRaVzUwU1VROUluaHRjQzVrYVdRNk9VSXpPRU0xTnpNNE5qRXlNVEZGTVVFek1rTkRNVUUzTmpaRVJERTJRaklpUGlBOGVHMXdUVTA2UkdWeWFYWmxaRVp5YjIwZ2MzUlNaV1k2YVc1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvNVFqTTRRelUzTURnMk1USXhNVVV4UVRNeVEwTXhRVGMyTmtSRU1UWkNNaUlnYzNSU1pXWTZaRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG81UWpNNFF6VTNNVGcyTVRJeE1VVXhRVE15UTBNeFFUYzJOa1JFTVRaQ01pSXZQaUE4TDNKa1pqcEVaWE5qY21sd2RHbHZiajRnUEM5eVpHWTZVa1JHUGlBOEwzZzZlRzF3YldWMFlUNGdQRDk0Y0dGamEyVjBJR1Z1WkQwaWNpSS9QZ0gvL3YzOCsvcjUrUGYyOWZUejh2SHc3Kzd0N092cTZlam41dVhrNCtMaDROL2UzZHpiMnRuWTE5YlYxTlBTMGREUHpzM015OHJKeU1mR3hjVER3c0hBdjc2OXZMdTZ1YmkzdHJXMHM3S3hzSyt1cmF5cnFxbW9wNmFscEtPaW9hQ2ZucDJjbTVxWm1KZVdsWlNUa3BHUWo0Nk5qSXVLaVlpSGhvV0VnNEtCZ0g5K2ZYeDdlbmw0ZDNaMWRITnljWEJ2Ym0xc2EycHBhR2RtWldSalltRmdYMTVkWEZ0YVdWaFhWbFZVVTFKUlVFOU9UVXhMU2tsSVIwWkZSRU5DUVVBL1BqMDhPem81T0RjMk5UUXpNakV3THk0dExDc3FLU2duSmlVa0l5SWhJQjhlSFJ3Ykdoa1lGeFlWRkJNU0VSQVBEZzBNQ3dvSkNBY0dCUVFEQWdFQUFDSDVCQUVBQUFFQUxBQUFBQUFOQUFvQUFBSVhUR0NKZWJEOWpFT1RxUmx0dFhkckIzMlBKMm5jeVJRQU93PT0iOklNQUdFX1BBVEgrCiIvY2xlYXIuZ2lmIjsKRGlhbG9nLnByb3RvdHlwZS5sb2NrZWRJbWFnZT1teENsaWVudC5JU19TVkc/ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQXdBQUFBTUNBTUFBQUJocTZ6VkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeUpwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVNQzFqTURZd0lEWXhMakV6TkRjM055d2dNakF4TUM4d01pOHhNaTB4Tnpvek1qb3dNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5UTlNCTllXTnBiblJ2YzJnaUlIaHRjRTFOT2tsdWMzUmhibU5sU1VROUluaHRjQzVwYVdRNk16ZERNRFpDT0RFeE56SXhNVEZGTlVJMFJUazVOVGc0T1RjeU1VVXlPREVpSUhodGNFMU5Pa1J2WTNWdFpXNTBTVVE5SW5odGNDNWthV1E2TXpkRE1EWkNPREl4TnpJeE1URkZOVUkwUlRrNU5UZzRPVGN5TVVVeU9ERWlQaUE4ZUcxd1RVMDZSR1Z5YVhabFpFWnliMjBnYzNSU1pXWTZhVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG96TjBNd05rSTNSakUzTWpFeE1VVTFRalJGT1RrMU9EZzVOekl4UlRJNE1TSWdjM1JTWldZNlpHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEb3pOME13TmtJNE1ERTNNakV4TVVVMVFqUkZPVGsxT0RnNU56SXhSVEk0TVNJdlBpQThMM0prWmpwRVpYTmpjbWx3ZEdsdmJqNGdQQzl5WkdZNlVrUkdQaUE4TDNnNmVHMXdiV1YwWVQ0Z1BEOTRjR0ZqYTJWMElHVnVaRDBpY2lJL1B2cU1DRllBQUFBVlVFeFVSWm1abWIrL3Y3S3lzcXlzck16TXpMR3hzZi8vLzRnOE4xY0FBQUFIZEZKT1UvLy8vLy8vL3dBYVN3TkdBQUFBUEVsRVFWUjQybFRNUVE0QUlRZ0V3VWEwLy85a1RRaXJPd2VZT2dEcUFNYlpVcjEwQUdsQXd4NC9CSjJRSjRVMEw1YnJZam92dnB2MzJ4WmdBSFphQVRGdE1idTRBQUFBQUVsRlRrU3VRbUNDIjpJTUFHRV9QQVRIKwoiL2xvY2tlZC5wbmciOwpEaWFsb2cucHJvdG90eXBlLnVubG9ja2VkSW1hZ2U9bXhDbGllbnQuSVNfU1ZHPyJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUF3QUFBQU1DQU1BQUFCaHE2elZBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlKcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1TUMxak1EWXdJRFl4TGpFek5EYzNOeXdnTWpBeE1DOHdNaTh4TWkweE56b3pNam93TUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVOVE5TQk5ZV05wYm5SdmMyZ2lJSGh0Y0UxTk9rbHVjM1JoYm1ObFNVUTlJbmh0Y0M1cGFXUTZNemRETURaQ04wUXhOekl4TVRGRk5VSTBSVGs1TlRnNE9UY3lNVVV5T0RFaUlIaHRjRTFOT2tSdlkzVnRaVzUwU1VROUluaHRjQzVrYVdRNk16ZERNRFpDTjBVeE56SXhNVEZGTlVJMFJUazVOVGc0T1RjeU1VVXlPREVpUGlBOGVHMXdUVTA2UkdWeWFYWmxaRVp5YjIwZ2MzUlNaV1k2YVc1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvek4wTXdOa0kzUWpFM01qRXhNVVUxUWpSRk9UazFPRGc1TnpJeFJUSTRNU0lnYzNSU1pXWTZaRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG96TjBNd05rSTNRekUzTWpFeE1VVTFRalJGT1RrMU9EZzVOekl4UlRJNE1TSXZQaUE4TDNKa1pqcEVaWE5qY21sd2RHbHZiajRnUEM5eVpHWTZVa1JHUGlBOEwzZzZlRzF3YldWMFlUNGdQRDk0Y0dGamEyVjBJR1Z1WkQwaWNpSS9Qa0tNcFZ3QUFBQVlVRXhVUlptWm1iS3lzcisvdjZ5c3JPWGw1Y3pNekxHeHNmLy8vekhONWx3QUFBQUlkRkpPVS8vLy8vLy8vLzhBM29POVdRQUFBRHhKUkVGVWVOcFV6RkVTQUNBRUJOQlZzZmUvY1pKVSs4TXpzOENJQUJDaWR0ZkdPbmRuWXNUNDBIRFNpQ2NiUGRvSm8xMG85YUk2NzdjcHdBQ1JvQUYzZEZObHN3QUFBQUJKUlU1RXJrSmdnZz09IjpJTUFHRV9QQVRIKwoiL3VubG9ja2VkLnBuZyI7RGlhbG9nLnByb3RvdHlwZS5iZ09wYWNpdHk9ODA7RGlhbG9nLnByb3RvdHlwZS5nZXRQb3NpdGlvbj1mdW5jdGlvbihhLGMpe3JldHVybiBuZXcgbXhQb2ludChhLGMpfTtEaWFsb2cucHJvdG90eXBlLmNsb3NlPWZ1bmN0aW9uKGEsYyl7aWYobnVsbCE9dGhpcy5vbkRpYWxvZ0Nsb3NlKXtpZigwPT10aGlzLm9uRGlhbG9nQ2xvc2UoYSxjKSlyZXR1cm4hMTt0aGlzLm9uRGlhbG9nQ2xvc2U9bnVsbH1udWxsIT10aGlzLmRpYWxvZ0ltZyYmKHRoaXMuZGlhbG9nSW1nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kaWFsb2dJbWcpLHRoaXMuZGlhbG9nSW1nPW51bGwpO251bGwhPXRoaXMuYmcmJm51bGwhPXRoaXMuYmcucGFyZW50Tm9kZSYmdGhpcy5iZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuYmcpO214RXZlbnQucmVtb3ZlTGlzdGVuZXIod2luZG93LCJyZXNpemUiLHRoaXMucmVzaXplTGlzdGVuZXIpO3RoaXMuY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jb250YWluZXIpfTsKdmFyIEVycm9yRGlhbG9nPWZ1bmN0aW9uKGEsYyxmLGQsbSxrLHEsYixlLGcscCl7ZT1udWxsIT1lP2U6ITA7dmFyIGw9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7bC5zdHlsZS50ZXh0QWxpZ249ImNlbnRlciI7aWYobnVsbCE9Yyl7dmFyIG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7bi5zdHlsZS5wYWRkaW5nPSIwcHgiO24uc3R5bGUubWFyZ2luPSIwcHgiO24uc3R5bGUuZm9udFNpemU9IjE4cHgiO24uc3R5bGUucGFkZGluZ0JvdHRvbT0iMTZweCI7bi5zdHlsZS5tYXJnaW5Cb3R0b209IjEwcHgiO24uc3R5bGUuYm9yZGVyQm90dG9tPSIxcHggc29saWQgI2MwYzBjMCI7bi5zdHlsZS5jb2xvcj0iZ3JheSI7bi5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiO24uc3R5bGUudGV4dE92ZXJmbG93PSJlbGxpcHNpcyI7bi5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjtteFV0aWxzLndyaXRlKG4sYyk7bi5zZXRBdHRyaWJ1dGUoInRpdGxlIixjKTtsLmFwcGVuZENoaWxkKG4pfWM9CmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Muc3R5bGUubGluZUhlaWdodD0iMS4yZW0iO2Muc3R5bGUucGFkZGluZz0iNnB4IjtjLmlubmVySFRNTD1mO2wuYXBwZW5kQ2hpbGQoYyk7Zj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtmLnN0eWxlLm1hcmdpblRvcD0iMTJweCI7Zi5zdHlsZS50ZXh0QWxpZ249ImNlbnRlciI7bnVsbCE9ayYmKGM9bXhVdGlscy5idXR0b24obXhSZXNvdXJjZXMuZ2V0KCJ0cnlBZ2FpbiIpLGZ1bmN0aW9uKCl7YS5oaWRlRGlhbG9nKCk7aygpfSksYy5jbGFzc05hbWU9ImdlQnRuIixmLmFwcGVuZENoaWxkKGMpLGYuc3R5bGUudGV4dEFsaWduPSJjZW50ZXIiKTtudWxsIT1nJiYoZz1teFV0aWxzLmJ1dHRvbihnLGZ1bmN0aW9uKCl7bnVsbCE9cCYmcCgpfSksZy5jbGFzc05hbWU9ImdlQnRuIixmLmFwcGVuZENoaWxkKGcpKTt2YXIgdj1teFV0aWxzLmJ1dHRvbihkLGZ1bmN0aW9uKCl7ZSYmYS5oaWRlRGlhbG9nKCk7bnVsbCE9bSYmbSgpfSk7CnYuY2xhc3NOYW1lPSJnZUJ0biI7Zi5hcHBlbmRDaGlsZCh2KTtudWxsIT1xJiYoZD1teFV0aWxzLmJ1dHRvbihxLGZ1bmN0aW9uKCl7ZSYmYS5oaWRlRGlhbG9nKCk7bnVsbCE9YiYmYigpfSksZC5jbGFzc05hbWU9ImdlQnRuIGdlUHJpbWFyeUJ0biIsZi5hcHBlbmRDaGlsZChkKSk7dGhpcy5pbml0PWZ1bmN0aW9uKCl7di5mb2N1cygpfTtsLmFwcGVuZENoaWxkKGYpO3RoaXMuY29udGFpbmVyPWx9LFByaW50RGlhbG9nPWZ1bmN0aW9uKGEsYyl7dGhpcy5jcmVhdGUoYSxjKX07ClByaW50RGlhbG9nLnByb3RvdHlwZS5jcmVhdGU9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYyhhKXt2YXIgZT1iLmNoZWNrZWR8fGcuY2hlY2tlZCxkPXBhcnNlSW50KGwudmFsdWUpLzEwMDtpc05hTihkKSYmKGQ9MSxsLnZhbHVlPSIxMDAlIik7dmFyIGQ9Ljc1KmQsYz1mLnBhZ2VGb3JtYXR8fG14Q29uc3RhbnRzLlBBR0VfRk9STUFUX0E0X1BPUlRSQUlULG49MS9mLnBhZ2VTY2FsZTtpZihlKXt2YXIgaz1iLmNoZWNrZWQ/MTpwYXJzZUludChwLnZhbHVlKTtpc05hTihrKXx8KG49bXhVdGlscy5nZXRTY2FsZUZvclBhZ2VDb3VudChrLGYsYykpfWYuZ2V0R3JhcGhCb3VuZHMoKTt2YXIgdj1rPTAsYz1teFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlKGMpO2Mud2lkdGg9TWF0aC5jZWlsKGMud2lkdGgqZCk7Yy5oZWlnaHQ9TWF0aC5jZWlsKGMuaGVpZ2h0KmQpO24qPWQ7IWUmJmYucGFnZVZpc2libGU/KGQ9Zi5nZXRQYWdlTGF5b3V0KCksay09ZC54KmMud2lkdGgsdi09ZC55KmMuaGVpZ2h0KToKZT0hMDtlPVByaW50RGlhbG9nLmNyZWF0ZVByaW50UHJldmlldyhmLG4sYywwLGssdixlKTtlLm9wZW4oKTthJiZQcmludERpYWxvZy5wcmludFByZXZpZXcoZSl9dmFyIGY9YS5lZGl0b3IuZ3JhcGgsZCxtLGs9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGFibGUiKTtrLnN0eWxlLndpZHRoPSIxMDAlIjtrLnN0eWxlLmhlaWdodD0iMTAwJSI7dmFyIHE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGJvZHkiKTtkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRyIik7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTtiLnNldEF0dHJpYnV0ZSgidHlwZSIsImNoZWNrYm94Iik7bT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpO20uc2V0QXR0cmlidXRlKCJjb2xzcGFuIiwiMiIpO20uc3R5bGUuZm9udFNpemU9IjEwcHQiO20uYXBwZW5kQ2hpbGQoYik7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3BhbiIpO214VXRpbHMud3JpdGUoZSwiICIrbXhSZXNvdXJjZXMuZ2V0KCJmaXRQYWdlIikpOwptLmFwcGVuZENoaWxkKGUpO214RXZlbnQuYWRkTGlzdGVuZXIoZSwiY2xpY2siLGZ1bmN0aW9uKGEpe2IuY2hlY2tlZD0hYi5jaGVja2VkO2cuY2hlY2tlZD0hYi5jaGVja2VkO214RXZlbnQuY29uc3VtZShhKX0pO214RXZlbnQuYWRkTGlzdGVuZXIoYiwiY2hhbmdlIixmdW5jdGlvbigpe2cuY2hlY2tlZD0hYi5jaGVja2VkfSk7ZC5hcHBlbmRDaGlsZChtKTtxLmFwcGVuZENoaWxkKGQpO2Q9ZC5jbG9uZU5vZGUoITEpO3ZhciBnPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7Zy5zZXRBdHRyaWJ1dGUoInR5cGUiLCJjaGVja2JveCIpO209ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKTttLnN0eWxlLmZvbnRTaXplPSIxMHB0IjttLmFwcGVuZENoaWxkKGcpO2U9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3BhbiIpO214VXRpbHMud3JpdGUoZSwiICIrbXhSZXNvdXJjZXMuZ2V0KCJwb3N0ZXJQcmludCIpKyI6Iik7bS5hcHBlbmRDaGlsZChlKTtteEV2ZW50LmFkZExpc3RlbmVyKGUsCiJjbGljayIsZnVuY3Rpb24oYSl7Zy5jaGVja2VkPSFnLmNoZWNrZWQ7Yi5jaGVja2VkPSFnLmNoZWNrZWQ7bXhFdmVudC5jb25zdW1lKGEpfSk7ZC5hcHBlbmRDaGlsZChtKTt2YXIgcD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpO3Auc2V0QXR0cmlidXRlKCJ2YWx1ZSIsIjEiKTtwLnNldEF0dHJpYnV0ZSgidHlwZSIsIm51bWJlciIpO3Auc2V0QXR0cmlidXRlKCJtaW4iLCIxIik7cC5zZXRBdHRyaWJ1dGUoInNpemUiLCI0Iik7cC5zZXRBdHRyaWJ1dGUoImRpc2FibGVkIiwiZGlzYWJsZWQiKTtwLnN0eWxlLndpZHRoPSI1MHB4IjttPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRkIik7bS5zdHlsZS5mb250U2l6ZT0iMTBwdCI7bS5hcHBlbmRDaGlsZChwKTtteFV0aWxzLndyaXRlKG0sIiAiK214UmVzb3VyY2VzLmdldCgicGFnZXMiKSsiIChtYXgpIik7ZC5hcHBlbmRDaGlsZChtKTtxLmFwcGVuZENoaWxkKGQpO214RXZlbnQuYWRkTGlzdGVuZXIoZywiY2hhbmdlIiwKZnVuY3Rpb24oKXtnLmNoZWNrZWQ/cC5yZW1vdmVBdHRyaWJ1dGUoImRpc2FibGVkIik6cC5zZXRBdHRyaWJ1dGUoImRpc2FibGVkIiwiZGlzYWJsZWQiKTtiLmNoZWNrZWQ9IWcuY2hlY2tlZH0pO2Q9ZC5jbG9uZU5vZGUoITEpO209ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKTtteFV0aWxzLndyaXRlKG0sbXhSZXNvdXJjZXMuZ2V0KCJwYWdlU2NhbGUiKSsiOiIpO2QuYXBwZW5kQ2hpbGQobSk7bT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpO3ZhciBsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7bC5zZXRBdHRyaWJ1dGUoInZhbHVlIiwiMTAwICUiKTtsLnNldEF0dHJpYnV0ZSgic2l6ZSIsIjUiKTtsLnN0eWxlLndpZHRoPSI1MHB4IjttLmFwcGVuZENoaWxkKGwpO2QuYXBwZW5kQ2hpbGQobSk7cS5hcHBlbmRDaGlsZChkKTtkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRyIik7bT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpO20uY29sU3Bhbj0yOwptLnN0eWxlLnBhZGRpbmdUb3A9IjIwcHgiO20uc2V0QXR0cmlidXRlKCJhbGlnbiIsInJpZ2h0Iik7ZT1teFV0aWxzLmJ1dHRvbihteFJlc291cmNlcy5nZXQoImNhbmNlbCIpLGZ1bmN0aW9uKCl7YS5oaWRlRGlhbG9nKCl9KTtlLmNsYXNzTmFtZT0iZ2VCdG4iO2EuZWRpdG9yLmNhbmNlbEZpcnN0JiZtLmFwcGVuZENoaWxkKGUpO2lmKFByaW50RGlhbG9nLnByZXZpZXdFbmFibGVkKXt2YXIgbj1teFV0aWxzLmJ1dHRvbihteFJlc291cmNlcy5nZXQoInByZXZpZXciKSxmdW5jdGlvbigpe2EuaGlkZURpYWxvZygpO2MoITEpfSk7bi5jbGFzc05hbWU9ImdlQnRuIjttLmFwcGVuZENoaWxkKG4pfW49bXhVdGlscy5idXR0b24obXhSZXNvdXJjZXMuZ2V0KFByaW50RGlhbG9nLnByZXZpZXdFbmFibGVkPyJwcmludCI6Im9rIiksZnVuY3Rpb24oKXthLmhpZGVEaWFsb2coKTtjKCEwKX0pO24uY2xhc3NOYW1lPSJnZUJ0biBnZVByaW1hcnlCdG4iO20uYXBwZW5kQ2hpbGQobik7YS5lZGl0b3IuY2FuY2VsRmlyc3R8fAptLmFwcGVuZENoaWxkKGUpO2QuYXBwZW5kQ2hpbGQobSk7cS5hcHBlbmRDaGlsZChkKTtrLmFwcGVuZENoaWxkKHEpO3RoaXMuY29udGFpbmVyPWt9O1ByaW50RGlhbG9nLnByaW50UHJldmlldz1mdW5jdGlvbihhKXt0cnl7aWYobnVsbCE9YS53bmQpe3ZhciBjPWZ1bmN0aW9uKCl7YS53bmQuZm9jdXMoKTthLnduZC5wcmludCgpO2Eud25kLmNsb3NlKCl9O214Q2xpZW50LklTX0dDP3dpbmRvdy5zZXRUaW1lb3V0KGMsNTAwKTpjKCl9fWNhdGNoKGYpe319OwpQcmludERpYWxvZy5jcmVhdGVQcmludFByZXZpZXc9ZnVuY3Rpb24oYSxjLGYsZCxtLGsscSl7Yz1uZXcgbXhQcmludFByZXZpZXcoYSxjLGYsZCxtLGspO2MudGl0bGU9bXhSZXNvdXJjZXMuZ2V0KCJwcmV2aWV3Iik7Yy5wcmludEJhY2tncm91bmRJbWFnZT0hMDtjLmF1dG9PcmlnaW49cTthPWEuYmFja2dyb3VuZDtpZihudWxsPT1hfHwiIj09YXx8YT09bXhDb25zdGFudHMuTk9ORSlhPSIjZmZmZmZmIjtjLmJhY2tncm91bmRDb2xvcj1hO3ZhciBiPWMud3JpdGVIZWFkO2Mud3JpdGVIZWFkPWZ1bmN0aW9uKGEpe2IuYXBwbHkodGhpcyxhcmd1bWVudHMpO2Eud3JpdGVsbignPHN0eWxlIHR5cGU9InRleHQvY3NzIj4nKTthLndyaXRlbG4oIkBtZWRpYSBzY3JlZW4geyIpO2Eud3JpdGVsbigiICBib2R5ID4gZGl2IHsgcGFkZGluZzozMHB4O2JveC1zaXppbmc6Y29udGVudC1ib3g7IH0iKTthLndyaXRlbG4oIn0iKTthLndyaXRlbG4oIjwvc3R5bGU+Iil9O3JldHVybiBjfTsKUHJpbnREaWFsb2cucHJldmlld0VuYWJsZWQ9ITA7CnZhciBQYWdlU2V0dXBEaWFsb2c9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYygpe251bGw9PXB8fHA9PW14Q29uc3RhbnRzLk5PTkU/KGcuc3R5bGUuYmFja2dyb3VuZENvbG9yPSIiLGcuc3R5bGUuYmFja2dyb3VuZEltYWdlPSJ1cmwoJyIrRGlhbG9nLnByb3RvdHlwZS5ub0NvbG9ySW1hZ2UrIicpIik6KGcuc3R5bGUuYmFja2dyb3VuZENvbG9yPXAsZy5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2U9IiIpfWZ1bmN0aW9uIGYoKXtudWxsPT12PyhuLnJlbW92ZUF0dHJpYnV0ZSgidGl0bGUiKSxuLnN0eWxlLmZvbnRTaXplPSIiLG4uaW5uZXJIVE1MPW14VXRpbHMuaHRtbEVudGl0aWVzKG14UmVzb3VyY2VzLmdldCgiY2hhbmdlIikpKyIuLi4iKToobi5zZXRBdHRyaWJ1dGUoInRpdGxlIix2LnNyYyksbi5zdHlsZS5mb250U2l6ZT0iMTFweCIsbi5pbm5lckhUTUw9bXhVdGlscy5odG1sRW50aXRpZXModi5zcmMuc3Vic3RyaW5nKDAsNDIpKSsiLi4uIil9dmFyIGQ9YS5lZGl0b3IuZ3JhcGgsbSwKayxxPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRhYmxlIik7cS5zdHlsZS53aWR0aD0iMTAwJSI7cS5zdHlsZS5oZWlnaHQ9IjEwMCUiO3ZhciBiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRib2R5Iik7bT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ciIpO2s9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKTtrLnN0eWxlLnZlcnRpY2FsQWxpZ249InRvcCI7ay5zdHlsZS5mb250U2l6ZT0iMTBwdCI7bXhVdGlscy53cml0ZShrLG14UmVzb3VyY2VzLmdldCgicGFwZXJTaXplIikrIjoiKTttLmFwcGVuZENoaWxkKGspO2s9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKTtrLnN0eWxlLnZlcnRpY2FsQWxpZ249InRvcCI7ay5zdHlsZS5mb250U2l6ZT0iMTBwdCI7dmFyIGU9UGFnZVNldHVwRGlhbG9nLmFkZFBhZ2VGb3JtYXRQYW5lbChrLCJwYWdlc2V0dXBkaWFsb2ciLGQucGFnZUZvcm1hdCk7bS5hcHBlbmRDaGlsZChrKTtiLmFwcGVuZENoaWxkKG0pO209ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidHIiKTsKaz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpO214VXRpbHMud3JpdGUoayxteFJlc291cmNlcy5nZXQoImJhY2tncm91bmQiKSsiOiIpO20uYXBwZW5kQ2hpbGQoayk7az1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpO2suc3R5bGUud2hpdGVTcGFjZT0ibm93cmFwIjtkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpLnNldEF0dHJpYnV0ZSgidHlwZSIsInRleHQiKTt2YXIgZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJidXR0b24iKTtnLnN0eWxlLndpZHRoPSIxOHB4IjtnLnN0eWxlLmhlaWdodD0iMThweCI7Zy5zdHlsZS5tYXJnaW5SaWdodD0iMjBweCI7Zy5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb249ImNlbnRlciBjZW50ZXIiO2cuc3R5bGUuYmFja2dyb3VuZFJlcGVhdD0ibm8tcmVwZWF0Ijt2YXIgcD1kLmJhY2tncm91bmQ7YygpO214RXZlbnQuYWRkTGlzdGVuZXIoZywiY2xpY2siLGZ1bmN0aW9uKGIpe2EucGlja0NvbG9yKHB8fCJub25lIixmdW5jdGlvbihhKXtwPQphO2MoKX0pO214RXZlbnQuY29uc3VtZShiKX0pO2suYXBwZW5kQ2hpbGQoZyk7bXhVdGlscy53cml0ZShrLG14UmVzb3VyY2VzLmdldCgiZ3JpZFNpemUiKSsiOiIpO3ZhciBsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7bC5zZXRBdHRyaWJ1dGUoInR5cGUiLCJudW1iZXIiKTtsLnNldEF0dHJpYnV0ZSgibWluIiwiMCIpO2wuc3R5bGUud2lkdGg9IjQwcHgiO2wuc3R5bGUubWFyZ2luTGVmdD0iNnB4IjtsLnZhbHVlPWQuZ2V0R3JpZFNpemUoKTtrLmFwcGVuZENoaWxkKGwpO214RXZlbnQuYWRkTGlzdGVuZXIobCwiY2hhbmdlIixmdW5jdGlvbigpe3ZhciBhPXBhcnNlSW50KGwudmFsdWUpO2wudmFsdWU9TWF0aC5tYXgoMSxpc05hTihhKT9kLmdldEdyaWRTaXplKCk6YSl9KTttLmFwcGVuZENoaWxkKGspO2IuYXBwZW5kQ2hpbGQobSk7bT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ciIpO2s9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKTtteFV0aWxzLndyaXRlKGssCm14UmVzb3VyY2VzLmdldCgiaW1hZ2UiKSsiOiIpO20uYXBwZW5kQ2hpbGQoayk7az1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpO3ZhciBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImEiKTtuLnN0eWxlLnRleHREZWNvcmF0aW9uPSJ1bmRlcmxpbmUiO24uc3R5bGUuY3Vyc29yPSJwb2ludGVyIjtuLnN0eWxlLmNvbG9yPSIjYTBhMGEwIjt2YXIgdj1kLmJhY2tncm91bmRJbWFnZTtteEV2ZW50LmFkZExpc3RlbmVyKG4sImNsaWNrIixmdW5jdGlvbihiKXthLnNob3dCYWNrZ3JvdW5kSW1hZ2VEaWFsb2coZnVuY3Rpb24oYSxiKXtifHwodj1hLGYoKSl9LHYpO214RXZlbnQuY29uc3VtZShiKX0pO2YoKTtrLmFwcGVuZENoaWxkKG4pO20uYXBwZW5kQ2hpbGQoayk7Yi5hcHBlbmRDaGlsZChtKTttPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRyIik7az1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpO2suY29sU3Bhbj0yO2suc3R5bGUucGFkZGluZ1RvcD0iMTZweCI7ay5zZXRBdHRyaWJ1dGUoImFsaWduIiwKInJpZ2h0Iik7dmFyIHQ9bXhVdGlscy5idXR0b24obXhSZXNvdXJjZXMuZ2V0KCJjYW5jZWwiKSxmdW5jdGlvbigpe2EuaGlkZURpYWxvZygpfSk7dC5jbGFzc05hbWU9ImdlQnRuIjthLmVkaXRvci5jYW5jZWxGaXJzdCYmay5hcHBlbmRDaGlsZCh0KTt2YXIgeT1teFV0aWxzLmJ1dHRvbihteFJlc291cmNlcy5nZXQoImFwcGx5IiksZnVuY3Rpb24oKXthLmhpZGVEaWFsb2coKTt2YXIgYj1wYXJzZUludChsLnZhbHVlKTtpc05hTihiKXx8ZC5ncmlkU2l6ZT09PWJ8fGQuc2V0R3JpZFNpemUoYik7Yj1uZXcgQ2hhbmdlUGFnZVNldHVwKGEscCx2LGUuZ2V0KCkpO2IuaWdub3JlQ29sb3I9ZC5iYWNrZ3JvdW5kPT1wO2IuaWdub3JlSW1hZ2U9KG51bGwhPWQuYmFja2dyb3VuZEltYWdlP2QuYmFja2dyb3VuZEltYWdlLnNyYzpudWxsKT09PShudWxsIT12P3Yuc3JjOm51bGwpO2QucGFnZUZvcm1hdC53aWR0aD09Yi5wcmV2aW91c0Zvcm1hdC53aWR0aCYmZC5wYWdlRm9ybWF0LmhlaWdodD09CmIucHJldmlvdXNGb3JtYXQuaGVpZ2h0JiZiLmlnbm9yZUNvbG9yJiZiLmlnbm9yZUltYWdlfHxkLm1vZGVsLmV4ZWN1dGUoYil9KTt5LmNsYXNzTmFtZT0iZ2VCdG4gZ2VQcmltYXJ5QnRuIjtrLmFwcGVuZENoaWxkKHkpO2EuZWRpdG9yLmNhbmNlbEZpcnN0fHxrLmFwcGVuZENoaWxkKHQpO20uYXBwZW5kQ2hpbGQoayk7Yi5hcHBlbmRDaGlsZChtKTtxLmFwcGVuZENoaWxkKGIpO3RoaXMuY29udGFpbmVyPXF9OwpQYWdlU2V0dXBEaWFsb2cuYWRkUGFnZUZvcm1hdFBhbmVsPWZ1bmN0aW9uKGEsYyxmLGQpe2Z1bmN0aW9uIG0oYSxkLGMpe2lmKGN8fGwhPWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQmJm4hPWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpe2E9ITE7Zm9yKGQ9MDtkPHQubGVuZ3RoO2QrKyljPXRbZF0sQT8iY3VzdG9tIj09Yy5rZXkmJihiLnZhbHVlPWMua2V5LEE9ITEpOm51bGwhPWMuZm9ybWF0JiYoImE0Ij09Yy5rZXk/ODI2PT1mLndpZHRoPyhmPW14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUoZiksZi53aWR0aD04MjcpOjgyNj09Zi5oZWlnaHQmJihmPW14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUoZiksZi5oZWlnaHQ9ODI3KToiYTUiPT1jLmtleSYmKDU4ND09Zi53aWR0aD8oZj1teFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlKGYpLGYud2lkdGg9NTgzKTo1ODQ9PWYuaGVpZ2h0JiYoZj1teFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlKGYpLGYuaGVpZ2h0PTU4MykpLGYud2lkdGg9PWMuZm9ybWF0LndpZHRoJiYKZi5oZWlnaHQ9PWMuZm9ybWF0LmhlaWdodD8oYi52YWx1ZT1jLmtleSxrLnNldEF0dHJpYnV0ZSgiY2hlY2tlZCIsImNoZWNrZWQiKSxrLmRlZmF1bHRDaGVja2VkPSEwLGsuY2hlY2tlZD0hMCxxLnJlbW92ZUF0dHJpYnV0ZSgiY2hlY2tlZCIpLHEuZGVmYXVsdENoZWNrZWQ9ITEscS5jaGVja2VkPSExLGE9ITApOmYud2lkdGg9PWMuZm9ybWF0LmhlaWdodCYmZi5oZWlnaHQ9PWMuZm9ybWF0LndpZHRoJiYoYi52YWx1ZT1jLmtleSxrLnJlbW92ZUF0dHJpYnV0ZSgiY2hlY2tlZCIpLGsuZGVmYXVsdENoZWNrZWQ9ITEsay5jaGVja2VkPSExLHEuc2V0QXR0cmlidXRlKCJjaGVja2VkIiwiY2hlY2tlZCIpLHEuZGVmYXVsdENoZWNrZWQ9ITAsYT1xLmNoZWNrZWQ9ITApKTthPyhlLnN0eWxlLmRpc3BsYXk9IiIscC5zdHlsZS5kaXNwbGF5PSJub25lIik6KGwudmFsdWU9Zi53aWR0aC8xMDAsbi52YWx1ZT1mLmhlaWdodC8xMDAsay5zZXRBdHRyaWJ1dGUoImNoZWNrZWQiLCJjaGVja2VkIiksCmIudmFsdWU9ImN1c3RvbSIsZS5zdHlsZS5kaXNwbGF5PSJub25lIixwLnN0eWxlLmRpc3BsYXk9IiIpfX1jPSJmb3JtYXQtIitjO3ZhciBrPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7ay5zZXRBdHRyaWJ1dGUoIm5hbWUiLGMpO2suc2V0QXR0cmlidXRlKCJ0eXBlIiwicmFkaW8iKTtrLnNldEF0dHJpYnV0ZSgidmFsdWUiLCJwb3J0cmFpdCIpO3ZhciBxPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7cS5zZXRBdHRyaWJ1dGUoIm5hbWUiLGMpO3Euc2V0QXR0cmlidXRlKCJ0eXBlIiwicmFkaW8iKTtxLnNldEF0dHJpYnV0ZSgidmFsdWUiLCJsYW5kc2NhcGUiKTt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzZWxlY3QiKTtiLnN0eWxlLm1hcmdpbkJvdHRvbT0iOHB4IjtiLnN0eWxlLndpZHRoPSIyMDJweCI7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7ZS5zdHlsZS5tYXJnaW5MZWZ0PSI0cHgiO2Uuc3R5bGUud2lkdGg9IjIxMHB4IjsKZS5zdHlsZS5oZWlnaHQ9IjI0cHgiO2suc3R5bGUubWFyZ2luUmlnaHQ9IjZweCI7ZS5hcHBlbmRDaGlsZChrKTtjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNwYW4iKTtjLnN0eWxlLm1heFdpZHRoPSIxMDBweCI7bXhVdGlscy53cml0ZShjLG14UmVzb3VyY2VzLmdldCgicG9ydHJhaXQiKSk7ZS5hcHBlbmRDaGlsZChjKTtxLnN0eWxlLm1hcmdpbkxlZnQ9IjEwcHgiO3Euc3R5bGUubWFyZ2luUmlnaHQ9IjZweCI7ZS5hcHBlbmRDaGlsZChxKTt2YXIgZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIik7Zy5zdHlsZS53aWR0aD0iMTAwcHgiO214VXRpbHMud3JpdGUoZyxteFJlc291cmNlcy5nZXQoImxhbmRzY2FwZSIpKTtlLmFwcGVuZENoaWxkKGcpO3ZhciBwPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO3Auc3R5bGUubWFyZ2luTGVmdD0iNHB4IjtwLnN0eWxlLndpZHRoPSIyMTBweCI7cC5zdHlsZS5oZWlnaHQ9IjI0cHgiO3ZhciBsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7Cmwuc2V0QXR0cmlidXRlKCJzaXplIiwiNyIpO2wuc3R5bGUudGV4dEFsaWduPSJyaWdodCI7cC5hcHBlbmRDaGlsZChsKTtteFV0aWxzLndyaXRlKHAsIiBpbiB4ICIpO3ZhciBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7bi5zZXRBdHRyaWJ1dGUoInNpemUiLCI3Iik7bi5zdHlsZS50ZXh0QWxpZ249InJpZ2h0IjtwLmFwcGVuZENoaWxkKG4pO214VXRpbHMud3JpdGUocCwiIGluIik7ZS5zdHlsZS5kaXNwbGF5PSJub25lIjtwLnN0eWxlLmRpc3BsYXk9Im5vbmUiO2Zvcih2YXIgdj17fSx0PVBhZ2VTZXR1cERpYWxvZy5nZXRGb3JtYXRzKCkseT0wO3k8dC5sZW5ndGg7eSsrKXt2YXIgeD10W3ldO3ZbeC5rZXldPXg7dmFyIEU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgib3B0aW9uIik7RS5zZXRBdHRyaWJ1dGUoInZhbHVlIix4LmtleSk7bXhVdGlscy53cml0ZShFLHgudGl0bGUpO2IuYXBwZW5kQ2hpbGQoRSl9dmFyIEE9ITE7bSgpO2EuYXBwZW5kQ2hpbGQoYik7bXhVdGlscy5icihhKTsKYS5hcHBlbmRDaGlsZChlKTthLmFwcGVuZENoaWxkKHApO3ZhciBDPWYsej1mdW5jdGlvbihhLGMpe3ZhciBnPXZbYi52YWx1ZV07bnVsbCE9Zy5mb3JtYXQ/KGwudmFsdWU9Zy5mb3JtYXQud2lkdGgvMTAwLG4udmFsdWU9Zy5mb3JtYXQuaGVpZ2h0LzEwMCxwLnN0eWxlLmRpc3BsYXk9Im5vbmUiLGUuc3R5bGUuZGlzcGxheT0iIik6KGUuc3R5bGUuZGlzcGxheT0ibm9uZSIscC5zdHlsZS5kaXNwbGF5PSIiKTtnPXBhcnNlRmxvYXQobC52YWx1ZSk7aWYoaXNOYU4oZyl8fDA+PWcpbC52YWx1ZT1mLndpZHRoLzEwMDtnPXBhcnNlRmxvYXQobi52YWx1ZSk7aWYoaXNOYU4oZyl8fDA+PWcpbi52YWx1ZT1mLmhlaWdodC8xMDA7Zz1uZXcgbXhSZWN0YW5nbGUoMCwwLE1hdGguZmxvb3IoMTAwKnBhcnNlRmxvYXQobC52YWx1ZSkpLE1hdGguZmxvb3IoMTAwKnBhcnNlRmxvYXQobi52YWx1ZSkpKTsiY3VzdG9tIiE9Yi52YWx1ZSYmcS5jaGVja2VkJiYoZz1uZXcgbXhSZWN0YW5nbGUoMCwwLApnLmhlaWdodCxnLndpZHRoKSk7YyYmQXx8Zy53aWR0aD09Qy53aWR0aCYmZy5oZWlnaHQ9PUMuaGVpZ2h0fHwoQz1nLG51bGwhPWQmJmQoQykpfTtteEV2ZW50LmFkZExpc3RlbmVyKGMsImNsaWNrIixmdW5jdGlvbihhKXtrLmNoZWNrZWQ9ITA7eihhKTtteEV2ZW50LmNvbnN1bWUoYSl9KTtteEV2ZW50LmFkZExpc3RlbmVyKGcsImNsaWNrIixmdW5jdGlvbihhKXtxLmNoZWNrZWQ9ITA7eihhKTtteEV2ZW50LmNvbnN1bWUoYSl9KTtteEV2ZW50LmFkZExpc3RlbmVyKGwsImJsdXIiLHopO214RXZlbnQuYWRkTGlzdGVuZXIobCwiY2xpY2siLHopO214RXZlbnQuYWRkTGlzdGVuZXIobiwiYmx1ciIseik7bXhFdmVudC5hZGRMaXN0ZW5lcihuLCJjbGljayIseik7bXhFdmVudC5hZGRMaXN0ZW5lcihxLCJjaGFuZ2UiLHopO214RXZlbnQuYWRkTGlzdGVuZXIoaywiY2hhbmdlIix6KTtteEV2ZW50LmFkZExpc3RlbmVyKGIsImNoYW5nZSIsZnVuY3Rpb24oYSl7QT0iY3VzdG9tIj09Yi52YWx1ZTsKeihhLCEwKX0pO3ooKTtyZXR1cm57c2V0OmZ1bmN0aW9uKGEpe2Y9YTttKG51bGwsbnVsbCwhMCl9LGdldDpmdW5jdGlvbigpe3JldHVybiBDfSx3aWR0aElucHV0OmwsaGVpZ2h0SW5wdXQ6bn19OwpQYWdlU2V0dXBEaWFsb2cuZ2V0Rm9ybWF0cz1mdW5jdGlvbigpe3JldHVyblt7a2V5OiJsZXR0ZXIiLHRpdGxlOidVUy1MZXR0ZXIgKDgsNSIgeCAxMSIpJyxmb3JtYXQ6bXhDb25zdGFudHMuUEFHRV9GT1JNQVRfTEVUVEVSX1BPUlRSQUlUfSx7a2V5OiJsZWdhbCIsdGl0bGU6J1VTLUxlZ2FsICg4LDUiIHggMTQiKScsZm9ybWF0Om5ldyBteFJlY3RhbmdsZSgwLDAsODUwLDE0MDApfSx7a2V5OiJ0YWJsb2lkIix0aXRsZTonVVMtVGFibG9pZCAoMTEiIHggMTciKScsZm9ybWF0Om5ldyBteFJlY3RhbmdsZSgwLDAsMTEwMCwxNzAwKX0se2tleToiZXhlY3V0aXZlIix0aXRsZTonVVMtRXhlY3V0aXZlICg3IiB4IDEwIiknLGZvcm1hdDpuZXcgbXhSZWN0YW5nbGUoMCwwLDcwMCwxRTMpfSx7a2V5OiJhMCIsdGl0bGU6IkEwICg4NDEgbW0geCAxMTg5IG1tKSIsZm9ybWF0Om5ldyBteFJlY3RhbmdsZSgwLDAsMzMwMCw0NjgxKX0se2tleToiYTEiLHRpdGxlOiJBMSAoNTk0IG1tIHggODQxIG1tKSIsCmZvcm1hdDpuZXcgbXhSZWN0YW5nbGUoMCwwLDIzMzksMzMwMCl9LHtrZXk6ImEyIix0aXRsZToiQTIgKDQyMCBtbSB4IDU5NCBtbSkiLGZvcm1hdDpuZXcgbXhSZWN0YW5nbGUoMCwwLDE2NTQsMjMzNil9LHtrZXk6ImEzIix0aXRsZToiQTMgKDI5NyBtbSB4IDQyMCBtbSkiLGZvcm1hdDpuZXcgbXhSZWN0YW5nbGUoMCwwLDExNjksMTY1NCl9LHtrZXk6ImE0Iix0aXRsZToiQTQgKDIxMCBtbSB4IDI5NyBtbSkiLGZvcm1hdDpteENvbnN0YW50cy5QQUdFX0ZPUk1BVF9BNF9QT1JUUkFJVH0se2tleToiYTUiLHRpdGxlOiJBNSAoMTQ4IG1tIHggMjEwIG1tKSIsZm9ybWF0Om5ldyBteFJlY3RhbmdsZSgwLDAsNTgzLDgyNyl9LHtrZXk6ImE2Iix0aXRsZToiQTYgKDEwNSBtbSB4IDE0OCBtbSkiLGZvcm1hdDpuZXcgbXhSZWN0YW5nbGUoMCwwLDQxMyw1ODMpfSx7a2V5OiJhNyIsdGl0bGU6IkE3ICg3NCBtbSB4IDEwNSBtbSkiLGZvcm1hdDpuZXcgbXhSZWN0YW5nbGUoMCwwLDI5MSw0MTMpfSwKe2tleToiYjQiLHRpdGxlOiJCNCAoMjUwIG1tIHggMzUzIG1tKSIsZm9ybWF0Om5ldyBteFJlY3RhbmdsZSgwLDAsOTgwLDEzOTApfSx7a2V5OiJiNSIsdGl0bGU6IkI1ICgxNzYgbW0geCAyNTAgbW0pIixmb3JtYXQ6bmV3IG14UmVjdGFuZ2xlKDAsMCw2OTAsOTgwKX0se2tleToiMTYtOSIsdGl0bGU6IjE2OjkgKDE2MDAgeCA5MDApIixmb3JtYXQ6bmV3IG14UmVjdGFuZ2xlKDAsMCwxNjAwLDkwMCl9LHtrZXk6IjE2LTEwIix0aXRsZToiMTY6MTAgKDE5MjAgeCAxMjAwKSIsZm9ybWF0Om5ldyBteFJlY3RhbmdsZSgwLDAsMTkyMCwxMjAwKX0se2tleToiNC0zIix0aXRsZToiNDozICgxNjAwIHggMTIwMCkiLGZvcm1hdDpuZXcgbXhSZWN0YW5nbGUoMCwwLDE2MDAsMTIwMCl9LHtrZXk6ImN1c3RvbSIsdGl0bGU6bXhSZXNvdXJjZXMuZ2V0KCJjdXN0b20iKSxmb3JtYXQ6bnVsbH1dfTsKdmFyIEZpbGVuYW1lRGlhbG9nPWZ1bmN0aW9uKGEsYyxmLGQsbSxrLHEsYixlLGcscCxsKXtlPW51bGwhPWU/ZTohMDt2YXIgbix2LHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGFibGUiKSx5PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRib2R5Iik7dC5zdHlsZS5tYXJnaW5Ub3A9IjhweCI7bj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ciIpO3Y9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKTt2LnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCI7di5zdHlsZS5mb250U2l6ZT0iMTBwdCI7di5zdHlsZS53aWR0aD1wPyI4MHB4IjoiMTIwcHgiO214VXRpbHMud3JpdGUodiwobXx8bXhSZXNvdXJjZXMuZ2V0KCJmaWxlbmFtZSIpKSsiOiIpO24uYXBwZW5kQ2hpbGQodik7dmFyIHg9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTt4LnNldEF0dHJpYnV0ZSgidmFsdWUiLGN8fCIiKTt4LnN0eWxlLm1hcmdpbkxlZnQ9IjRweCI7eC5zdHlsZS53aWR0aD1udWxsIT1sP2wrCiJweCI6IjE4MHB4Ijt2YXIgRT1teFV0aWxzLmJ1dHRvbihmLGZ1bmN0aW9uKCl7aWYobnVsbD09a3x8ayh4LnZhbHVlKSllJiZhLmhpZGVEaWFsb2coKSxkKHgudmFsdWUpfSk7RS5jbGFzc05hbWU9ImdlQnRuIGdlUHJpbWFyeUJ0biI7dGhpcy5pbml0PWZ1bmN0aW9uKCl7aWYobnVsbCE9bXx8bnVsbD09cSlpZih4LmZvY3VzKCksbXhDbGllbnQuSVNfR0N8fG14Q2xpZW50LklTX0ZGfHw1PD1kb2N1bWVudC5kb2N1bWVudE1vZGV8fG14Q2xpZW50LklTX1FVSVJLUz94LnNlbGVjdCgpOmRvY3VtZW50LmV4ZWNDb21tYW5kKCJzZWxlY3RBbGwiLCExLG51bGwpLEdyYXBoLmZpbGVTdXBwb3J0KXt2YXIgYT10LnBhcmVudE5vZGU7aWYobnVsbCE9YSl7dmFyIGI9bnVsbDtteEV2ZW50LmFkZExpc3RlbmVyKGEsImRyYWdsZWF2ZSIsZnVuY3Rpb24oYSl7bnVsbCE9YiYmKGIuc3R5bGUuYmFja2dyb3VuZENvbG9yPSIiLGI9bnVsbCk7YS5zdG9wUHJvcGFnYXRpb24oKTthLnByZXZlbnREZWZhdWx0KCl9KTsKbXhFdmVudC5hZGRMaXN0ZW5lcihhLCJkcmFnb3ZlciIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bnVsbD09YiYmKCFteENsaWVudC5JU19JRXx8MTA8ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSYmKGI9eCxiLnN0eWxlLmJhY2tncm91bmRDb2xvcj0iI2ViZjJmOSIpO2Euc3RvcFByb3BhZ2F0aW9uKCk7YS5wcmV2ZW50RGVmYXVsdCgpfSkpO214RXZlbnQuYWRkTGlzdGVuZXIoYSwiZHJvcCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bnVsbCE9YiYmKGIuc3R5bGUuYmFja2dyb3VuZENvbG9yPSIiLGI9bnVsbCk7MDw9bXhVdGlscy5pbmRleE9mKGEuZGF0YVRyYW5zZmVyLnR5cGVzLCJ0ZXh0L3VyaS1saXN0IikmJih4LnZhbHVlPWRlY29kZVVSSUNvbXBvbmVudChhLmRhdGFUcmFuc2Zlci5nZXREYXRhKCJ0ZXh0L3VyaS1saXN0IikpLEUuY2xpY2soKSk7YS5zdG9wUHJvcGFnYXRpb24oKTthLnByZXZlbnREZWZhdWx0KCl9KSl9fX07dj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpOwp2LnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCI7di5hcHBlbmRDaGlsZCh4KTtuLmFwcGVuZENoaWxkKHYpO2lmKG51bGwhPW18fG51bGw9PXEpeS5hcHBlbmRDaGlsZChuKSxudWxsIT1wJiYobnVsbCE9YS5lZGl0b3IuZGlhZ3JhbUZpbGVUeXBlcyYmKG49RmlsZW5hbWVEaWFsb2cuY3JlYXRlRmlsZVR5cGVzKGEseCxhLmVkaXRvci5kaWFncmFtRmlsZVR5cGVzKSxuLnN0eWxlLm1hcmdpbkxlZnQ9IjZweCIsbi5zdHlsZS53aWR0aD0iNzRweCIsdi5hcHBlbmRDaGlsZChuKSx4LnN0eWxlLndpZHRoPW51bGwhPWw/bC00MCsicHgiOiIxNDBweCIpLHYuYXBwZW5kQ2hpbGQoRmlsZW5hbWVEaWFsb2cuY3JlYXRlVHlwZUhpbnQoYSx4LHApKSk7bnVsbCE9cSYmKG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidHIiKSx2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRkIiksdi5jb2xTcGFuPTIsdi5hcHBlbmRDaGlsZChxKSxuLmFwcGVuZENoaWxkKHYpLHkuYXBwZW5kQ2hpbGQobikpO249CmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRyIik7dj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpO3YuY29sU3Bhbj0yO3Yuc3R5bGUucGFkZGluZ1RvcD0iMjBweCI7di5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiO3Yuc2V0QXR0cmlidXRlKCJhbGlnbiIsInJpZ2h0Iik7cD1teFV0aWxzLmJ1dHRvbihteFJlc291cmNlcy5nZXQoImNhbmNlbCIpLGZ1bmN0aW9uKCl7YS5oaWRlRGlhbG9nKCk7bnVsbCE9ZyYmZygpfSk7cC5jbGFzc05hbWU9ImdlQnRuIjthLmVkaXRvci5jYW5jZWxGaXJzdCYmdi5hcHBlbmRDaGlsZChwKTtudWxsIT1iJiYobD1teFV0aWxzLmJ1dHRvbihteFJlc291cmNlcy5nZXQoImhlbHAiKSxmdW5jdGlvbigpe2EuZWRpdG9yLmdyYXBoLm9wZW5MaW5rKGIpfSksbC5jbGFzc05hbWU9ImdlQnRuIix2LmFwcGVuZENoaWxkKGwpKTtteEV2ZW50LmFkZExpc3RlbmVyKHgsImtleXByZXNzIixmdW5jdGlvbihhKXsxMz09YS5rZXlDb2RlJiZFLmNsaWNrKCl9KTsKdi5hcHBlbmRDaGlsZChFKTthLmVkaXRvci5jYW5jZWxGaXJzdHx8di5hcHBlbmRDaGlsZChwKTtuLmFwcGVuZENoaWxkKHYpO3kuYXBwZW5kQ2hpbGQobik7dC5hcHBlbmRDaGlsZCh5KTt0aGlzLmNvbnRhaW5lcj10fTtGaWxlbmFtZURpYWxvZy5maWxlbmFtZUhlbHBMaW5rPW51bGw7CkZpbGVuYW1lRGlhbG9nLmNyZWF0ZVR5cGVIaW50PWZ1bmN0aW9uKGEsYyxmKXt2YXIgZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTtkLnN0eWxlLmNzc1RleHQ9InZlcnRpY2FsLWFsaWduOnRvcDtoZWlnaHQ6MTZweDt3aWR0aDoxNnB4O21hcmdpbi1sZWZ0OjRweDtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1wb3NpdGlvbjpjZW50ZXIgYm90dG9tO2N1cnNvcjpwb2ludGVyOyI7bXhVdGlscy5zZXRPcGFjaXR5KGQsNzApO3ZhciBtPWZ1bmN0aW9uKCl7ZC5zZXRBdHRyaWJ1dGUoInNyYyIsRWRpdG9yLmhlbHBJbWFnZSk7ZC5zZXRBdHRyaWJ1dGUoInRpdGxlIixteFJlc291cmNlcy5nZXQoImhlbHAiKSk7Zm9yKHZhciBhPTA7YTxmLmxlbmd0aDthKyspaWYoMDxmW2FdLmV4dC5sZW5ndGgmJmMudmFsdWUudG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcoYy52YWx1ZS5sZW5ndGgtZlthXS5leHQubGVuZ3RoLTEpPT0iLiIrZlthXS5leHQpe2Quc2V0QXR0cmlidXRlKCJzcmMiLApteENsaWVudC5pbWFnZUJhc2VQYXRoKyIvd2FybmluZy5wbmciKTtkLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldChmW2FdLnRpdGxlKSk7YnJlYWt9fTtteEV2ZW50LmFkZExpc3RlbmVyKGMsImtleXVwIixtKTtteEV2ZW50LmFkZExpc3RlbmVyKGMsImNoYW5nZSIsbSk7bXhFdmVudC5hZGRMaXN0ZW5lcihkLCJjbGljayIsZnVuY3Rpb24oYyl7dmFyIGY9ZC5nZXRBdHRyaWJ1dGUoInRpdGxlIik7ZC5nZXRBdHRyaWJ1dGUoInNyYyIpPT1FZGl0b3IuaGVscEltYWdlP2EuZWRpdG9yLmdyYXBoLm9wZW5MaW5rKEZpbGVuYW1lRGlhbG9nLmZpbGVuYW1lSGVscExpbmspOiIiIT1mJiZhLnNob3dFcnJvcihudWxsLGYsbXhSZXNvdXJjZXMuZ2V0KCJoZWxwIiksZnVuY3Rpb24oKXthLmVkaXRvci5ncmFwaC5vcGVuTGluayhGaWxlbmFtZURpYWxvZy5maWxlbmFtZUhlbHBMaW5rKX0sbnVsbCxteFJlc291cmNlcy5nZXQoIm9rIiksbnVsbCxudWxsLG51bGwsMzQwLDkwKTsKbXhFdmVudC5jb25zdW1lKGMpfSk7bSgpO3JldHVybiBkfTsKRmlsZW5hbWVEaWFsb2cuY3JlYXRlRmlsZVR5cGVzPWZ1bmN0aW9uKGEsYyxmKXt2YXIgZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzZWxlY3QiKTtmb3IoYT0wO2E8Zi5sZW5ndGg7YSsrKXt2YXIgbT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJvcHRpb24iKTttLnNldEF0dHJpYnV0ZSgidmFsdWUiLGEpO214VXRpbHMud3JpdGUobSxteFJlc291cmNlcy5nZXQoZlthXS5kZXNjcmlwdGlvbikrIiAoLiIrZlthXS5leHRlbnNpb24rIikiKTtkLmFwcGVuZENoaWxkKG0pfW14RXZlbnQuYWRkTGlzdGVuZXIoZCwiY2hhbmdlIixmdW5jdGlvbihhKXthPWZbZC52YWx1ZV0uZXh0ZW5zaW9uO3ZhciBrPWMudmFsdWUubGFzdEluZGV4T2YoIi4iKTswPGs/KGE9ZltkLnZhbHVlXS5leHRlbnNpb24sYy52YWx1ZT1jLnZhbHVlLnN1YnN0cmluZygwLGsrMSkrYSk6Yy52YWx1ZT1jLnZhbHVlKyIuIithOyJjcmVhdGVFdmVudCJpbiBkb2N1bWVudD8oYT1kb2N1bWVudC5jcmVhdGVFdmVudCgiSFRNTEV2ZW50cyIpLAphLmluaXRFdmVudCgiY2hhbmdlIiwhMSwhMCksYy5kaXNwYXRjaEV2ZW50KGEpKTpjLmZpcmVFdmVudCgib25jaGFuZ2UiKX0pO2E9ZnVuY3Rpb24oYSl7dmFyIGs9Yy52YWx1ZS5sYXN0SW5kZXhPZigiLiIpO2E9MDtpZigwPGspZm9yKHZhciBrPWMudmFsdWUudG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcoaysxKSxiPTA7YjxmLmxlbmd0aDtiKyspaWYoaz09ZltiXS5leHRlbnNpb24pe2E9YjticmVha31kLnZhbHVlPWF9O214RXZlbnQuYWRkTGlzdGVuZXIoYywiY2hhbmdlIixhKTtteEV2ZW50LmFkZExpc3RlbmVyKGMsImtleXVwIixhKTthKCk7cmV0dXJuIGR9OwooZnVuY3Rpb24oKXtteEdyYXBoVmlldy5wcm90b3R5cGUudmFsaWRhdGVCYWNrZ3JvdW5kUGFnZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ3JhcGg7aWYobnVsbCE9YS5jb250YWluZXImJiFhLnRyYW5zcGFyZW50QmFja2dyb3VuZCl7aWYoYS5wYWdlVmlzaWJsZSl7dmFyIGI9dGhpcy5nZXRCYWNrZ3JvdW5kUGFnZUJvdW5kcygpO2lmKG51bGw9PXRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZSl7Zm9yKHZhciBlPWEuY29udGFpbmVyLmZpcnN0Q2hpbGQ7bnVsbCE9ZSYmZS5ub2RlVHlwZSE9bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVDspZT1lLm5leHRTaWJsaW5nO251bGwhPWUmJih0aGlzLmJhY2tncm91bmRQYWdlU2hhcGU9dGhpcy5jcmVhdGVCYWNrZ3JvdW5kUGFnZVNoYXBlKGIpLHRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZS5zY2FsZT0xLHRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZS5pc1NoYWRvdz0hbXhDbGllbnQuSVNfUVVJUktTLHRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZS5kaWFsZWN0PQpteENvbnN0YW50cy5ESUFMRUNUX1NUUklDVEhUTUwsdGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlLmluaXQoYS5jb250YWluZXIpLGUuc3R5bGUucG9zaXRpb249ImFic29sdXRlIixhLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlLm5vZGUsZSksdGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlLnJlZHJhdygpLHRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZS5ub2RlLmNsYXNzTmFtZT0iZ2VCYWNrZ3JvdW5kUGFnZSIsbXhFdmVudC5hZGRMaXN0ZW5lcih0aGlzLmJhY2tncm91bmRQYWdlU2hhcGUubm9kZSwiZGJsY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe2EuZGJsQ2xpY2soYil9KSksbXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKHRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZS5ub2RlLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe2EuZmlyZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9ET1dOLG5ldyBteE1vdXNlRXZlbnQoYikpfSksCm14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe251bGwhPWEudG9vbHRpcEhhbmRsZXImJmEudG9vbHRpcEhhbmRsZXIuaXNIaWRlT25Ib3ZlcigpJiZhLnRvb2x0aXBIYW5kbGVyLmhpZGUoKTthLmlzTW91c2VEb3duJiYhbXhFdmVudC5pc0NvbnN1bWVkKGIpJiZhLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfTU9WRSxuZXcgbXhNb3VzZUV2ZW50KGIpKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe2EuZmlyZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9VUCxuZXcgbXhNb3VzZUV2ZW50KGIpKX0pKSl9ZWxzZSB0aGlzLmJhY2tncm91bmRQYWdlU2hhcGUuc2NhbGU9MSx0aGlzLmJhY2tncm91bmRQYWdlU2hhcGUuYm91bmRzPWIsdGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlLnJlZHJhdygpfWVsc2UgbnVsbCE9dGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlJiYodGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlLmRlc3Ryb3koKSx0aGlzLmJhY2tncm91bmRQYWdlU2hhcGU9Cm51bGwpO3RoaXMudmFsaWRhdGVCYWNrZ3JvdW5kU3R5bGVzKCl9fTtteEdyYXBoVmlldy5wcm90b3R5cGUudmFsaWRhdGVCYWNrZ3JvdW5kU3R5bGVzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5ncmFwaCxiPW51bGw9PWEuYmFja2dyb3VuZHx8YS5iYWNrZ3JvdW5kPT1teENvbnN0YW50cy5OT05FP2EuZGVmYXVsdFBhZ2VCYWNrZ3JvdW5kQ29sb3I6YS5iYWNrZ3JvdW5kLGU9bnVsbCE9YiYmdGhpcy5ncmlkQ29sb3IhPWIudG9Mb3dlckNhc2UoKT90aGlzLmdyaWRDb2xvcjoiI2ZmZmZmZiIsZD0ibm9uZSIsYz0iIjtpZihhLmlzR3JpZEVuYWJsZWQoKSl7Yz0xMDtteENsaWVudC5JU19TVkc/KGQ9dW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuY3JlYXRlU3ZnR3JpZChlKSkpLGQ9d2luZG93LmJ0b2E/YnRvYShkKTpCYXNlNjQuZW5jb2RlKGQsITApLGQ9InVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LCIrZCsiKSIsYz1hLmdyaWRTaXplKnRoaXMuc2NhbGUqdGhpcy5ncmlkU3RlcHMpOgpkPSJ1cmwoIit0aGlzLmdyaWRJbWFnZSsiKSI7dmFyIGY9ZT0wO251bGwhPWEudmlldy5iYWNrZ3JvdW5kUGFnZVNoYXBlJiYoZj10aGlzLmdldEJhY2tncm91bmRQYWdlQm91bmRzKCksZT0xK2YueCxmPTErZi55KTtjPS1NYXRoLnJvdW5kKGMtbXhVdGlscy5tb2QodGhpcy50cmFuc2xhdGUueCp0aGlzLnNjYWxlLWUsYykpKyJweCAiKy1NYXRoLnJvdW5kKGMtbXhVdGlscy5tb2QodGhpcy50cmFuc2xhdGUueSp0aGlzLnNjYWxlLWYsYykpKyJweCJ9ZT1hLnZpZXcuY2FudmFzO251bGwhPWUub3duZXJTVkdFbGVtZW50JiYoZT1lLm93bmVyU1ZHRWxlbWVudCk7bnVsbCE9YS52aWV3LmJhY2tncm91bmRQYWdlU2hhcGU/KGEudmlldy5iYWNrZ3JvdW5kUGFnZVNoYXBlLm5vZGUuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uPWMsYS52aWV3LmJhY2tncm91bmRQYWdlU2hhcGUubm9kZS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2U9ZCxhLnZpZXcuYmFja2dyb3VuZFBhZ2VTaGFwZS5ub2RlLnN0eWxlLmJhY2tncm91bmRDb2xvcj0KYixhLmNvbnRhaW5lci5jbGFzc05hbWU9ImdlRGlhZ3JhbUNvbnRhaW5lciBnZURpYWdyYW1CYWNrZHJvcCIsZS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2U9Im5vbmUiLGUuc3R5bGUuYmFja2dyb3VuZENvbG9yPSIiKTooYS5jb250YWluZXIuY2xhc3NOYW1lPSJnZURpYWdyYW1Db250YWluZXIiLGUuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uPWMsZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9YixlLnN0eWxlLmJhY2tncm91bmRJbWFnZT1kKX07bXhHcmFwaFZpZXcucHJvdG90eXBlLmNyZWF0ZVN2Z0dyaWQ9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXRoaXMuZ3JhcGguZ3JpZFNpemUqdGhpcy5zY2FsZTtiPHRoaXMubWluR3JpZFNpemU7KWIqPTI7Zm9yKHZhciBlPXRoaXMuZ3JpZFN0ZXBzKmIsZD1bXSxjPTE7Yzx0aGlzLmdyaWRTdGVwcztjKyspe3ZhciBmPWMqYjtkLnB1c2goIk0gMCAiK2YrIiBMICIrZSsiICIrZisiIE0gIitmKyIgMCBMICIrZisiICIrZSl9cmV0dXJuJzxzdmcgd2lkdGg9IicrCmUrJyIgaGVpZ2h0PSInK2UrJyIgeG1sbnM9IicrbXhDb25zdGFudHMuTlNfU1ZHKyciPjxkZWZzPjxwYXR0ZXJuIGlkPSJncmlkIiB3aWR0aD0iJytlKyciIGhlaWdodD0iJytlKyciIHBhdHRlcm5Vbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoIGQ9IicrZC5qb2luKCIgIikrJyIgZmlsbD0ibm9uZSIgc3Ryb2tlPSInK2ErJyIgb3BhY2l0eT0iMC4yIiBzdHJva2Utd2lkdGg9IjEiLz48cGF0aCBkPSJNICcrZSsiIDAgTCAwIDAgMCAiK2UrJyIgZmlsbD0ibm9uZSIgc3Ryb2tlPSInK2ErJyIgc3Ryb2tlLXdpZHRoPSIxIi8+PC9wYXR0ZXJuPjwvZGVmcz48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSJ1cmwoI2dyaWQpIi8+PC9zdmc+J307dmFyIGE9bXhHcmFwaC5wcm90b3R5cGUucGFuR3JhcGg7bXhHcmFwaC5wcm90b3R5cGUucGFuR3JhcGg9ZnVuY3Rpb24oZCxiKXthLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZihudWxsIT10aGlzLnNoaWZ0UHJldmlldzEpe3ZhciBlPQp0aGlzLnZpZXcuY2FudmFzO251bGwhPWUub3duZXJTVkdFbGVtZW50JiYoZT1lLm93bmVyU1ZHRWxlbWVudCk7dmFyIGM9dGhpcy5ncmlkU2l6ZSp0aGlzLnZpZXcuc2NhbGUqdGhpcy52aWV3LmdyaWRTdGVwcyxjPS1NYXRoLnJvdW5kKGMtbXhVdGlscy5tb2QodGhpcy52aWV3LnRyYW5zbGF0ZS54KnRoaXMudmlldy5zY2FsZStkLGMpKSsicHggIistTWF0aC5yb3VuZChjLW14VXRpbHMubW9kKHRoaXMudmlldy50cmFuc2xhdGUueSp0aGlzLnZpZXcuc2NhbGUrYixjKSkrInB4IjtlLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbj1jfX07bXhHcmFwaC5wcm90b3R5cGUudXBkYXRlUGFnZUJyZWFrcz1mdW5jdGlvbihhLGIsZSl7dmFyIGQ9dGhpcy52aWV3LnNjYWxlLGM9dGhpcy52aWV3LnRyYW5zbGF0ZSxmPXRoaXMucGFnZUZvcm1hdCxuPWQqdGhpcy5wYWdlU2NhbGUsaz10aGlzLnZpZXcuZ2V0QmFja2dyb3VuZFBhZ2VCb3VuZHMoKTtiPWsud2lkdGg7ZT1rLmhlaWdodDt2YXIgdD0KbmV3IG14UmVjdGFuZ2xlKGQqYy54LGQqYy55LGYud2lkdGgqbixmLmhlaWdodCpuKSx5PShhPWEmJk1hdGgubWluKHQud2lkdGgsdC5oZWlnaHQpPnRoaXMubWluUGFnZUJyZWFrRGlzdCk/TWF0aC5jZWlsKGUvdC5oZWlnaHQpLTE6MCxtPWE/TWF0aC5jZWlsKGIvdC53aWR0aCktMTowLHE9ay54K2IsQT1rLnkrZTtudWxsPT10aGlzLmhvcml6b250YWxQYWdlQnJlYWtzJiYwPHkmJih0aGlzLmhvcml6b250YWxQYWdlQnJlYWtzPVtdKTtudWxsPT10aGlzLnZlcnRpY2FsUGFnZUJyZWFrcyYmMDxtJiYodGhpcy52ZXJ0aWNhbFBhZ2VCcmVha3M9W10pO2E9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7aWYobnVsbCE9YSl7Zm9yKHZhciBiPWE9PXRoaXMuaG9yaXpvbnRhbFBhZ2VCcmVha3M/eTptLGU9MDtlPD1iO2UrKyl7dmFyIGQ9YT09dGhpcy5ob3Jpem9udGFsUGFnZUJyZWFrcz9bbmV3IG14UG9pbnQoTWF0aC5yb3VuZChrLngpLE1hdGgucm91bmQoay55KyhlKzEpKnQuaGVpZ2h0KSksCm5ldyBteFBvaW50KE1hdGgucm91bmQocSksTWF0aC5yb3VuZChrLnkrKGUrMSkqdC5oZWlnaHQpKV06W25ldyBteFBvaW50KE1hdGgucm91bmQoay54KyhlKzEpKnQud2lkdGgpLE1hdGgucm91bmQoay55KSksbmV3IG14UG9pbnQoTWF0aC5yb3VuZChrLngrKGUrMSkqdC53aWR0aCksTWF0aC5yb3VuZChBKSldO251bGwhPWFbZV0/KGFbZV0ucG9pbnRzPWQsYVtlXS5yZWRyYXcoKSk6KGQ9bmV3IG14UG9seWxpbmUoZCx0aGlzLnBhZ2VCcmVha0NvbG9yKSxkLmRpYWxlY3Q9dGhpcy5kaWFsZWN0LGQuaXNEYXNoZWQ9dGhpcy5wYWdlQnJlYWtEYXNoZWQsZC5wb2ludGVyRXZlbnRzPSExLGQuaW5pdCh0aGlzLnZpZXcuYmFja2dyb3VuZFBhbmUpLGQucmVkcmF3KCksYVtlXT1kKX1mb3IoZT1iO2U8YS5sZW5ndGg7ZSsrKWFbZV0uZGVzdHJveSgpO2Euc3BsaWNlKGIsYS5sZW5ndGgtYil9fSk7YSh0aGlzLmhvcml6b250YWxQYWdlQnJlYWtzKTthKHRoaXMudmVydGljYWxQYWdlQnJlYWtzKX07CnZhciBjPW14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5zaG91bGRSZW1vdmVDZWxsc0Zyb21QYXJlbnQ7bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnNob3VsZFJlbW92ZUNlbGxzRnJvbVBhcmVudD1mdW5jdGlvbihhLGIsZSl7Zm9yKHZhciBkPTA7ZDxiLmxlbmd0aDtkKyspaWYodGhpcy5ncmFwaC5nZXRNb2RlbCgpLmlzVmVydGV4KGJbZF0pKXt2YXIgZj10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShiW2RdKTtpZihudWxsIT1mJiZmLnJlbGF0aXZlKXJldHVybiExfXJldHVybiBjLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dmFyIGY9bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlTWFya2VyO214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZU1hcmtlcj1mdW5jdGlvbigpe3ZhciBhPWYuYXBwbHkodGhpcyxhcmd1bWVudHMpO2EuaW50ZXJzZWN0cz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiLGUpe3JldHVybiB0aGlzLmlzQ29ubmVjdGluZygpPwohMDpteENlbGxNYXJrZXIucHJvdG90eXBlLmludGVyc2VjdHMuYXBwbHkoYSxhcmd1bWVudHMpfSk7cmV0dXJuIGF9O214R3JhcGhWaWV3LnByb3RvdHlwZS5jcmVhdGVCYWNrZ3JvdW5kUGFnZVNoYXBlPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgbXhSZWN0YW5nbGVTaGFwZShhLCIjZmZmZmZmIix0aGlzLmdyYXBoLmRlZmF1bHRQYWdlQm9yZGVyQ29sb3IpfTtteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0QmFja2dyb3VuZFBhZ2VCb3VuZHM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdldEdyYXBoQm91bmRzKCksYj0wPGEud2lkdGg/YS54L3RoaXMuc2NhbGUtdGhpcy50cmFuc2xhdGUueDowLGU9MDxhLmhlaWdodD9hLnkvdGhpcy5zY2FsZS10aGlzLnRyYW5zbGF0ZS55OjAsZD10aGlzLmdyYXBoLnBhZ2VGb3JtYXQsYz10aGlzLmdyYXBoLnBhZ2VTY2FsZSxmPWQud2lkdGgqYyxkPWQuaGVpZ2h0KmMsYz1NYXRoLmZsb29yKE1hdGgubWluKDAsYikvZiksbj1NYXRoLmZsb29yKE1hdGgubWluKDAsCmUpL2QpO3JldHVybiBuZXcgbXhSZWN0YW5nbGUodGhpcy5zY2FsZSoodGhpcy50cmFuc2xhdGUueCtjKmYpLHRoaXMuc2NhbGUqKHRoaXMudHJhbnNsYXRlLnkrbipkKSx0aGlzLnNjYWxlKihNYXRoLmNlaWwoTWF0aC5tYXgoMSxiK2Eud2lkdGgvdGhpcy5zY2FsZSkvZiktYykqZix0aGlzLnNjYWxlKihNYXRoLmNlaWwoTWF0aC5tYXgoMSxlK2EuaGVpZ2h0L3RoaXMuc2NhbGUpL2QpLW4pKmQpfTt2YXIgZD1teEdyYXBoLnByb3RvdHlwZS5wYW5HcmFwaDtteEdyYXBoLnByb3RvdHlwZS5wYW5HcmFwaD1mdW5jdGlvbihhLGIpe2QuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuZGlhbGVjdD09bXhDb25zdGFudHMuRElBTEVDVF9TVkd8fG51bGw9PXRoaXMudmlldy5iYWNrZ3JvdW5kUGFnZVNoYXBlfHx0aGlzLnVzZVNjcm9sbGJhcnNGb3JQYW5uaW5nJiZteFV0aWxzLmhhc1Njcm9sbGJhcnModGhpcy5jb250YWluZXIpfHwodGhpcy52aWV3LmJhY2tncm91bmRQYWdlU2hhcGUubm9kZS5zdHlsZS5tYXJnaW5MZWZ0PQphKyJweCIsdGhpcy52aWV3LmJhY2tncm91bmRQYWdlU2hhcGUubm9kZS5zdHlsZS5tYXJnaW5Ub3A9YisicHgiKX07dmFyIG09bXhQb3B1cE1lbnUucHJvdG90eXBlLmFkZEl0ZW07bXhQb3B1cE1lbnUucHJvdG90eXBlLmFkZEl0ZW09ZnVuY3Rpb24oYSxiLGUsZCxjLGYpe3ZhciBnPW0uYXBwbHkodGhpcyxhcmd1bWVudHMpO251bGw9PWZ8fGZ8fG14RXZlbnQuYWRkTGlzdGVuZXIoZywibW91c2Vkb3duIixmdW5jdGlvbihhKXtteEV2ZW50LmNvbnN1bWUoYSl9KTtyZXR1cm4gZ307dmFyIGs9bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmlzUHJvcGFnYXRlU2VsZWN0aW9uQ2VsbDtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuaXNQcm9wYWdhdGVTZWxlY3Rpb25DZWxsPWZ1bmN0aW9uKGEsYixlKXt2YXIgZCxjPXRoaXMuZ3JhcGgubW9kZWwuZ2V0UGFyZW50KGEpO2lmKGIpcmV0dXJuIGQ9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoYSksIXRoaXMuZ3JhcGgubW9kZWwuaXNFZGdlKGEpJiYKIXRoaXMuZ3JhcGgubW9kZWwuaXNFZGdlKGMpJiYhdGhpcy5ncmFwaC5pc1NpYmxpbmdTZWxlY3RlZChhKSYmKG51bGw9PWR8fGQucmVsYXRpdmV8fCF0aGlzLmdyYXBoLmlzQ29udGFpbmVyKGMpfHx0aGlzLmdyYXBoLmlzUGFydChhKSk7ZD1rLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZih0aGlzLmdyYXBoLmlzVGFibGVDZWxsKGEpfHx0aGlzLmdyYXBoLmlzVGFibGVSb3coYSkpZD1jLHRoaXMuZ3JhcGguaXNUYWJsZShkKXx8KGQ9dGhpcy5ncmFwaC5tb2RlbC5nZXRQYXJlbnQoZCkpLGQ9IXRoaXMuZ3JhcGguc2VsZWN0aW9uQ2VsbHNIYW5kbGVyLmlzSGFuZGxlZChkKXx8dGhpcy5ncmFwaC5pc0NlbGxTZWxlY3RlZChkKSYmdGhpcy5ncmFwaC5pc1RvZ2dsZUV2ZW50KGUuZ2V0RXZlbnQoKSl8fHRoaXMuZ3JhcGguaXNDZWxsU2VsZWN0ZWQoYSkmJiF0aGlzLmdyYXBoLmlzVG9nZ2xlRXZlbnQoZS5nZXRFdmVudCgpKXx8dGhpcy5ncmFwaC5pc1RhYmxlQ2VsbChhKSYmdGhpcy5ncmFwaC5pc0NlbGxTZWxlY3RlZChjKTsKcmV0dXJuIGR9O214UG9wdXBNZW51SGFuZGxlci5wcm90b3R5cGUuZ2V0Q2VsbEZvclBvcHVwRXZlbnQ9ZnVuY3Rpb24oYSl7YT1hLmdldENlbGwoKTtmb3IodmFyIGI9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGQ9Yi5nZXRQYXJlbnQoYSksYz10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUoZCksZj10aGlzLmdyYXBoLmlzQ2VsbFNlbGVjdGVkKGEpO251bGwhPWMmJihiLmlzVmVydGV4KGQpfHxiLmlzRWRnZShkKSk7KXt2YXIgbD10aGlzLmdyYXBoLmlzQ2VsbFNlbGVjdGVkKGQpLGY9Znx8bDtpZihsfHwhZiYmKHRoaXMuZ3JhcGguaXNUYWJsZUNlbGwoYSl8fHRoaXMuZ3JhcGguaXNUYWJsZVJvdyhhKSkpYT1kO2Q9Yi5nZXRQYXJlbnQoZCl9cmV0dXJuIGF9fSkoKTtFZGl0b3JVaT1mdW5jdGlvbihhLGMsZil7bXhFdmVudFNvdXJjZS5jYWxsKHRoaXMpO3RoaXMuZGVzdHJveUZ1bmN0aW9ucz1bXTt0aGlzLmVkaXRvcj1hfHxuZXcgRWRpdG9yO3RoaXMuY29udGFpbmVyPWN8fGRvY3VtZW50LmJvZHk7dmFyIGQ9dGhpcy5lZGl0b3IuZ3JhcGg7ZC5saWdodGJveD1mO2QudXNlQ3NzVHJhbnNmb3JtcyYmKHRoaXMubGF6eVpvb21EZWxheT0wKTtteENsaWVudC5JU19TVkc/bXhQb3B1cE1lbnUucHJvdG90eXBlLnN1Ym1lbnVJbWFnZT0iZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQ1FBSkFJQUFBUC8vL3pNek15SDVCQUVBQUFBQUxBQUFBQUFKQUFrQUFBSVBoSThXZWJIc0hvcFNPVmdiMjZBQUFEcz0iOihuZXcgSW1hZ2UpLnNyYz1teFBvcHVwTWVudS5wcm90b3R5cGUuc3VibWVudUltYWdlO214Q2xpZW50LklTX1NWR3x8bnVsbD09bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY29ubmVjdEltYWdlfHwoKG5ldyBJbWFnZSkuc3JjPW14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmNvbm5lY3RJbWFnZS5zcmMpOwp0aGlzLmVkaXRvci5jaHJvbWVsZXNzJiYhdGhpcy5lZGl0b3IuZWRpdGFibGUmJih0aGlzLmZvb3RlckhlaWdodD0wLGQuaXNFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGQucGFubmluZ0hhbmRsZXIuaXNGb3JjZVBhbm5pbmdFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4hbXhFdmVudC5pc1BvcHVwVHJpZ2dlcihhLmdldEV2ZW50KCkpfSk7dGhpcy5hY3Rpb25zPW5ldyBBY3Rpb25zKHRoaXMpO3RoaXMubWVudXM9dGhpcy5jcmVhdGVNZW51cygpO2lmKCFkLnN0YW5kYWxvbmUpe3RoaXMuY3JlYXRlRGl2cygpO3RoaXMuY3JlYXRlVWkoKTt0aGlzLnJlZnJlc2goKTt2YXIgbT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsPT1hJiYoYT13aW5kb3cuZXZlbnQpO3JldHVybiBkLmlzRWRpdGluZygpfHxudWxsIT1hJiZ0aGlzLmlzU2VsZWN0aW9uQWxsb3dlZChhKX0pO3RoaXMuY29udGFpbmVyPT1kb2N1bWVudC5ib2R5JiYodGhpcy5tZW51YmFyQ29udGFpbmVyLm9uc2VsZWN0c3RhcnQ9Cm0sdGhpcy5tZW51YmFyQ29udGFpbmVyLm9ubW91c2Vkb3duPW0sdGhpcy50b29sYmFyQ29udGFpbmVyLm9uc2VsZWN0c3RhcnQ9bSx0aGlzLnRvb2xiYXJDb250YWluZXIub25tb3VzZWRvd249bSx0aGlzLmRpYWdyYW1Db250YWluZXIub25zZWxlY3RzdGFydD1tLHRoaXMuZGlhZ3JhbUNvbnRhaW5lci5vbm1vdXNlZG93bj1tLHRoaXMuc2lkZWJhckNvbnRhaW5lci5vbnNlbGVjdHN0YXJ0PW0sdGhpcy5zaWRlYmFyQ29udGFpbmVyLm9ubW91c2Vkb3duPW0sdGhpcy5mb3JtYXRDb250YWluZXIub25zZWxlY3RzdGFydD1tLHRoaXMuZm9ybWF0Q29udGFpbmVyLm9ubW91c2Vkb3duPW0sdGhpcy5mb290ZXJDb250YWluZXIub25zZWxlY3RzdGFydD1tLHRoaXMuZm9vdGVyQ29udGFpbmVyLm9ubW91c2Vkb3duPW0sbnVsbCE9dGhpcy50YWJDb250YWluZXImJih0aGlzLnRhYkNvbnRhaW5lci5vbnNlbGVjdHN0YXJ0PW0pKTshdGhpcy5lZGl0b3IuY2hyb21lbGVzc3x8dGhpcy5lZGl0b3IuZWRpdGFibGU/CihjPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe3ZhciBiPW14RXZlbnQuZ2V0U291cmNlKGEpO2lmKCJBIj09Yi5ub2RlTmFtZSlmb3IoO251bGwhPWI7KXtpZigiZ2VIaW50Ij09Yi5jbGFzc05hbWUpcmV0dXJuITA7Yj1iLnBhcmVudE5vZGV9fXJldHVybiBtKGEpfSxteENsaWVudC5JU19JRSYmKCJ1bmRlZmluZWQiPT09dHlwZW9mIGRvY3VtZW50LmRvY3VtZW50TW9kZXx8OT5kb2N1bWVudC5kb2N1bWVudE1vZGUpP214RXZlbnQuYWRkTGlzdGVuZXIodGhpcy5kaWFncmFtQ29udGFpbmVyLCJjb250ZXh0bWVudSIsYyk6dGhpcy5kaWFncmFtQ29udGFpbmVyLm9uY29udGV4dG1lbnU9Yyk6ZC5wYW5uaW5nSGFuZGxlci51c2VQb3B1cFRyaWdnZXI9ITE7ZC5pbml0KHRoaXMuZGlhZ3JhbUNvbnRhaW5lcik7bXhDbGllbnQuSVNfU1ZHJiZudWxsIT1kLnZpZXcuZ2V0RHJhd1BhbmUoKSYmKGM9ZC52aWV3LmdldERyYXdQYW5lKCkub3duZXJTVkdFbGVtZW50LG51bGwhPWMmJihjLnN0eWxlLnBvc2l0aW9uPQoiYWJzb2x1dGUiKSk7dGhpcy5ob3Zlckljb25zPXRoaXMuY3JlYXRlSG92ZXJJY29ucygpO2lmKG51bGwhPWQuZ3JhcGhIYW5kbGVyKXt2YXIgaz1kLmdyYXBoSGFuZGxlci5zdGFydDtkLmdyYXBoSGFuZGxlci5zdGFydD1mdW5jdGlvbigpe251bGwhPXguaG92ZXJJY29ucyYmeC5ob3Zlckljb25zLnJlc2V0KCk7ay5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fW14RXZlbnQuYWRkTGlzdGVuZXIodGhpcy5kaWFncmFtQ29udGFpbmVyLCJtb3VzZW1vdmUiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBiPW14VXRpbHMuZ2V0T2Zmc2V0KHRoaXMuZGlhZ3JhbUNvbnRhaW5lcik7MDxteEV2ZW50LmdldENsaWVudFgoYSktYi54LXRoaXMuZGlhZ3JhbUNvbnRhaW5lci5jbGllbnRXaWR0aHx8MDxteEV2ZW50LmdldENsaWVudFkoYSktYi55LXRoaXMuZGlhZ3JhbUNvbnRhaW5lci5jbGllbnRIZWlnaHQ/dGhpcy5kaWFncmFtQ29udGFpbmVyLnNldEF0dHJpYnV0ZSgidGl0bGUiLApteFJlc291cmNlcy5nZXQoInBhblRvb2x0aXAiKSk6dGhpcy5kaWFncmFtQ29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgidGl0bGUiKX0pKTt2YXIgcT0hMSxiPXRoaXMuaG92ZXJJY29ucy5pc1Jlc2V0RXZlbnQ7dGhpcy5ob3Zlckljb25zLmlzUmVzZXRFdmVudD1mdW5jdGlvbihhLGQpe3JldHVybiBxfHxiLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dGhpcy5rZXlkb3duSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXszMiE9YS53aGljaHx8ZC5pc0VkaXRpbmcoKT9teEV2ZW50LmlzQ29uc3VtZWQoYSl8fDI3IT1hLmtleUNvZGV8fHRoaXMuaGlkZURpYWxvZyhudWxsLCEwKToocT0hMCx0aGlzLmhvdmVySWNvbnMucmVzZXQoKSxkLmNvbnRhaW5lci5zdHlsZS5jdXJzb3I9Im1vdmUiLGQuaXNFZGl0aW5nKCl8fG14RXZlbnQuZ2V0U291cmNlKGEpIT1kLmNvbnRhaW5lcnx8bXhFdmVudC5jb25zdW1lKGEpKX0pO214RXZlbnQuYWRkTGlzdGVuZXIoZG9jdW1lbnQsCiJrZXlkb3duIix0aGlzLmtleWRvd25IYW5kbGVyKTt0aGlzLmtleXVwSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtkLmNvbnRhaW5lci5zdHlsZS5jdXJzb3I9IiI7cT0hMX0pO214RXZlbnQuYWRkTGlzdGVuZXIoZG9jdW1lbnQsImtleXVwIix0aGlzLmtleXVwSGFuZGxlcik7dmFyIGU9ZC5wYW5uaW5nSGFuZGxlci5pc0ZvcmNlUGFubmluZ0V2ZW50O2QucGFubmluZ0hhbmRsZXIuaXNGb3JjZVBhbm5pbmdFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHF8fG14RXZlbnQuaXNNb3VzZUV2ZW50KGEuZ2V0RXZlbnQoKSkmJih0aGlzLnVzZVBvcHVwVHJpZ2dlcnx8IW14RXZlbnQuaXNQb3B1cFRyaWdnZXIoYS5nZXRFdmVudCgpKSkmJighbXhFdmVudC5pc0NvbnRyb2xEb3duKGEuZ2V0RXZlbnQoKSkmJm14RXZlbnQuaXNSaWdodE1vdXNlQnV0dG9uKGEuZ2V0RXZlbnQoKSl8fG14RXZlbnQuaXNNaWRkbGVNb3VzZUJ1dHRvbihhLmdldEV2ZW50KCkpKX07CnZhciBnPWQuY2VsbEVkaXRvci5pc1N0b3BFZGl0aW5nRXZlbnQ7ZC5jZWxsRWRpdG9yLmlzU3RvcEVkaXRpbmdFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gZy5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fDEzPT1hLmtleUNvZGUmJighbXhDbGllbnQuSVNfU0YmJm14RXZlbnQuaXNDb250cm9sRG93bihhKXx8bXhDbGllbnQuSVNfTUFDJiZteEV2ZW50LmlzTWV0YURvd24oYSl8fG14Q2xpZW50LklTX1NGJiZteEV2ZW50LmlzU2hpZnREb3duKGEpKX07dmFyIHA9ZC5pc1pvb21XaGVlbEV2ZW50O2QuaXNab29tV2hlZWxFdmVudD1mdW5jdGlvbigpe3JldHVybiBxfHxwLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dmFyIGw9ITEsbj1udWxsLHY9bnVsbCx0PW51bGwseT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2lmKG51bGwhPXRoaXMudG9vbGJhciYmbCE9ZC5jZWxsRWRpdG9yLmlzQ29udGVudEVkaXRpbmcoKSl7Zm9yKHZhciBhPXRoaXMudG9vbGJhci5jb250YWluZXIuZmlyc3RDaGlsZCwKYj1bXTtudWxsIT1hOyl7dmFyIGU9YS5uZXh0U2libGluZzswPm14VXRpbHMuaW5kZXhPZih0aGlzLnRvb2xiYXIuc3RhdGljRWxlbWVudHMsYSkmJihhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSksYi5wdXNoKGEpKTthPWV9YT10aGlzLnRvb2xiYXIuZm9udE1lbnU7ZT10aGlzLnRvb2xiYXIuc2l6ZU1lbnU7aWYobnVsbD09dCl0aGlzLnRvb2xiYXIuY3JlYXRlVGV4dFRvb2xiYXIoKTtlbHNle2Zvcih2YXIgYz0wO2M8dC5sZW5ndGg7YysrKXRoaXMudG9vbGJhci5jb250YWluZXIuYXBwZW5kQ2hpbGQodFtjXSk7dGhpcy50b29sYmFyLmZvbnRNZW51PW47dGhpcy50b29sYmFyLnNpemVNZW51PXZ9bD1kLmNlbGxFZGl0b3IuaXNDb250ZW50RWRpdGluZygpO249YTt2PWU7dD1ifX0pLHg9dGhpcyxFPWQuY2VsbEVkaXRvci5zdGFydEVkaXRpbmc7ZC5jZWxsRWRpdG9yLnN0YXJ0RWRpdGluZz1mdW5jdGlvbigpe0UuYXBwbHkodGhpcyxhcmd1bWVudHMpO3koKTtpZihkLmNlbGxFZGl0b3IuaXNDb250ZW50RWRpdGluZygpKXt2YXIgYT0KITEsYj1mdW5jdGlvbigpe2F8fChhPSEwLHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Zm9yKHZhciBiPWQuZ2V0U2VsZWN0ZWRFbGVtZW50KCk7bnVsbCE9YiYmYi5ub2RlVHlwZSE9bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVDspYj1iLnBhcmVudE5vZGU7aWYobnVsbCE9YiYmKGI9bXhVdGlscy5nZXRDdXJyZW50U3R5bGUoYiksbnVsbCE9YiYmbnVsbCE9eC50b29sYmFyKSl7dmFyIGU9Yi5mb250RmFtaWx5OyInIj09ZS5jaGFyQXQoMCkmJihlPWUuc3Vic3RyaW5nKDEpKTsiJyI9PWUuY2hhckF0KGUubGVuZ3RoLTEpJiYoZT1lLnN1YnN0cmluZygwLGUubGVuZ3RoLTEpKTt4LnRvb2xiYXIuc2V0Rm9udE5hbWUoZSk7eC50b29sYmFyLnNldEZvbnRTaXplKHBhcnNlSW50KGIuZm9udFNpemUpKX1hPSExfSwwKSl9O214RXZlbnQuYWRkTGlzdGVuZXIoZC5jZWxsRWRpdG9yLnRleHRhcmVhLCJpbnB1dCIsYik7bXhFdmVudC5hZGRMaXN0ZW5lcihkLmNlbGxFZGl0b3IudGV4dGFyZWEsCiJ0b3VjaGVuZCIsYik7bXhFdmVudC5hZGRMaXN0ZW5lcihkLmNlbGxFZGl0b3IudGV4dGFyZWEsIm1vdXNldXAiLGIpO214RXZlbnQuYWRkTGlzdGVuZXIoZC5jZWxsRWRpdG9yLnRleHRhcmVhLCJrZXl1cCIsYik7YigpfX07dmFyIEE9ZC5jZWxsRWRpdG9yLnN0b3BFZGl0aW5nO2QuY2VsbEVkaXRvci5zdG9wRWRpdGluZz1mdW5jdGlvbihhLGIpe3RyeXtBLmFwcGx5KHRoaXMsYXJndW1lbnRzKSx5KCl9Y2F0Y2goQil7eC5oYW5kbGVFcnJvcihCKX19O2QuY29udGFpbmVyLnNldEF0dHJpYnV0ZSgidGFiaW5kZXgiLCIwIik7ZC5jb250YWluZXIuc3R5bGUuY3Vyc29yPSJkZWZhdWx0IjtpZih3aW5kb3cuc2VsZj09PXdpbmRvdy50b3AmJm51bGwhPWQuY29udGFpbmVyLnBhcmVudE5vZGUpdHJ5e2QuY29udGFpbmVyLmZvY3VzKCl9Y2F0Y2godSl7fXZhciBDPWQuZmlyZU1vdXNlRXZlbnQ7ZC5maXJlTW91c2VFdmVudD1mdW5jdGlvbihhLGIsZCl7YT09bXhFdmVudC5NT1VTRV9ET1dOJiYKdGhpcy5jb250YWluZXIuZm9jdXMoKTtDLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07ZC5wb3B1cE1lbnVIYW5kbGVyLmF1dG9FeHBhbmQ9ITA7bnVsbCE9dGhpcy5tZW51cyYmKGQucG9wdXBNZW51SGFuZGxlci5mYWN0b3J5TWV0aG9kPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYixkKXt0aGlzLm1lbnVzLmNyZWF0ZVBvcHVwTWVudShhLGIsZCl9KSk7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKGRvY3VtZW50LG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2QucG9wdXBNZW51SGFuZGxlci5oaWRlTWVudSgpfSkpO3RoaXMua2V5SGFuZGxlcj10aGlzLmNyZWF0ZUtleUhhbmRsZXIoYSk7dGhpcy5nZXRLZXlIYW5kbGVyPWZ1bmN0aW9uKCl7cmV0dXJuIGtleUhhbmRsZXJ9O3ZhciB6PSJyb3VuZGVkIHNoYWRvdyBnbGFzcyBkYXNoZWQgZGFzaFBhdHRlcm4gY29taWMgbGFiZWxCYWNrZ3JvdW5kQ29sb3IiLnNwbGl0KCIgIiksRD0ic2hhcGUgZWRnZVN0eWxlIGN1cnZlZCByb3VuZGVkIGVsYm93IGNvbWljIGp1bXBTdHlsZSBqdW1wU2l6ZSIuc3BsaXQoIiAiKTsKdGhpcy5zZXREZWZhdWx0U3R5bGU9ZnVuY3Rpb24oYSl7dHJ5e3ZhciBiPWQudmlldy5nZXRTdGF0ZShhKTtpZihudWxsIT1iKXt2YXIgZT1hLmNsb25lKCk7ZS5zdHlsZT0iIjt2YXIgYz1kLmdldENlbGxTdHlsZShlKTthPVtdO3ZhciBlPVtdLGc7Zm9yKGcgaW4gYi5zdHlsZSljW2ddIT1iLnN0eWxlW2ddJiYoYS5wdXNoKGIuc3R5bGVbZ10pLGUucHVzaChnKSk7Zm9yKHZhciBmPWQuZ2V0TW9kZWwoKS5nZXRTdHlsZShiLmNlbGwpLGw9bnVsbCE9Zj9mLnNwbGl0KCI7Iik6W10sZj0wO2Y8bC5sZW5ndGg7ZisrKXt2YXIgcD1sW2ZdLG49cC5pbmRleE9mKCI9Iik7aWYoMDw9bil7Zz1wLnN1YnN0cmluZygwLG4pO3ZhciB1PXAuc3Vic3RyaW5nKG4rMSk7bnVsbCE9Y1tnXSYmIm5vbmUiPT11JiYoYS5wdXNoKHUpLGUucHVzaChnKSl9fWQuZ2V0TW9kZWwoKS5pc0VkZ2UoYi5jZWxsKT9kLmN1cnJlbnRFZGdlU3R5bGU9e306ZC5jdXJyZW50VmVydGV4U3R5bGU9e307dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInN0eWxlQ2hhbmdlZCIsCiJrZXlzIixlLCJ2YWx1ZXMiLGEsImNlbGxzIixbYi5jZWxsXSkpfX1jYXRjaChaKXt0aGlzLmhhbmRsZUVycm9yKFopfX07dGhpcy5jbGVhckRlZmF1bHRTdHlsZT1mdW5jdGlvbigpe2QuY3VycmVudEVkZ2VTdHlsZT1teFV0aWxzLmNsb25lKGQuZGVmYXVsdEVkZ2VTdHlsZSk7ZC5jdXJyZW50VmVydGV4U3R5bGU9bXhVdGlscy5jbG9uZShkLmRlZmF1bHRWZXJ0ZXhTdHlsZSk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInN0eWxlQ2hhbmdlZCIsImtleXMiLFtdLCJ2YWx1ZXMiLFtdLCJjZWxscyIsW10pKX07dmFyIEc9WyJmb250RmFtaWx5IiwiZm9udFNpemUiLCJmb250Q29sb3IiXSxGPSJlZGdlU3R5bGUgc3RhcnRBcnJvdyBzdGFydEZpbGwgc3RhcnRTaXplIGVuZEFycm93IGVuZEZpbGwgZW5kU2l6ZSIuc3BsaXQoIiAiKSxIPVsic3RhcnRBcnJvdyBzdGFydEZpbGwgc3RhcnRTaXplIHNvdXJjZVBlcmltZXRlclNwYWNpbmcgZW5kQXJyb3cgZW5kRmlsbCBlbmRTaXplIHRhcmdldFBlcmltZXRlclNwYWNpbmciLnNwbGl0KCIgIiksClsic3Ryb2tlQ29sb3IiLCJzdHJva2VXaWR0aCJdLFsiZmlsbENvbG9yIiwiZ3JhZGllbnRDb2xvciJdLEcsWyJvcGFjaXR5Il0sWyJhbGlnbiJdLFsiaHRtbCJdXTtmb3IoYT0wO2E8SC5sZW5ndGg7YSsrKWZvcihjPTA7YzxIW2FdLmxlbmd0aDtjKyspei5wdXNoKEhbYV1bY10pO2ZvcihhPTA7YTxELmxlbmd0aDthKyspMD5teFV0aWxzLmluZGV4T2YoeixEW2FdKSYmei5wdXNoKERbYV0pO3ZhciBKPWZ1bmN0aW9uKGEsYil7dmFyIGU9ZC5nZXRNb2RlbCgpO2UuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBnPWFbY10sZjtpZihiKWY9WyJmb250U2l6ZSIsImZvbnRGYW1pbHkiLCJmb250Q29sb3IiXTtlbHNle3ZhciBsPWUuZ2V0U3R5bGUoZykscD1udWxsIT1sP2wuc3BsaXQoIjsiKTpbXTtmPXouc2xpY2UoKTtmb3IodmFyIG49MDtuPHAubGVuZ3RoO24rKyl7dmFyIHU9cFtuXSx0PXUuaW5kZXhPZigiPSIpO2lmKDA8PXQpe3ZhciBLPQp1LnN1YnN0cmluZygwLHQpLGs9bXhVdGlscy5pbmRleE9mKGYsSyk7MDw9ayYmZi5zcGxpY2UoaywxKTtmb3IodmFyIHk9MDt5PEgubGVuZ3RoO3krKyl7dmFyIHY9SFt5XTtpZigwPD1teFV0aWxzLmluZGV4T2YodixLKSlmb3IodmFyIG09MDttPHYubGVuZ3RoO20rKyl7dmFyIHg9bXhVdGlscy5pbmRleE9mKGYsdlttXSk7MDw9eCYmZi5zcGxpY2UoeCwxKX19fX19Zm9yKHZhciBxPWUuaXNFZGdlKGcpLEU9cT9kLmN1cnJlbnRFZGdlU3R5bGU6ZC5jdXJyZW50VmVydGV4U3R5bGUsQT1lLmdldFN0eWxlKGcpLG49MDtuPGYubGVuZ3RoO24rKyl7dmFyIEs9ZltuXSxDPUVbS107bnVsbD09Q3x8InNoYXBlIj09SyYmIXF8fHEmJiEoMD5teFV0aWxzLmluZGV4T2YoRCxLKSl8fChBPW14VXRpbHMuc2V0U3R5bGUoQSxLLEMpKX1lLnNldFN0eWxlKGcsQSl9fWZpbmFsbHl7ZS5lbmRVcGRhdGUoKX19O2QuYWRkTGlzdGVuZXIoImNlbGxzSW5zZXJ0ZWQiLGZ1bmN0aW9uKGEsYil7SihiLmdldFByb3BlcnR5KCJjZWxscyIpKX0pOwpkLmFkZExpc3RlbmVyKCJ0ZXh0SW5zZXJ0ZWQiLGZ1bmN0aW9uKGEsYil7SihiLmdldFByb3BlcnR5KCJjZWxscyIpLCEwKX0pO2QuY29ubmVjdGlvbkhhbmRsZXIuYWRkTGlzdGVuZXIobXhFdmVudC5DT05ORUNULGZ1bmN0aW9uKGEsYil7dmFyIGU9W2IuZ2V0UHJvcGVydHkoImNlbGwiKV07Yi5nZXRQcm9wZXJ0eSgidGVybWluYWxJbnNlcnRlZCIpJiZlLnB1c2goYi5nZXRQcm9wZXJ0eSgidGVybWluYWwiKSk7SihlKX0pO3RoaXMuYWRkTGlzdGVuZXIoInN0eWxlQ2hhbmdlZCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiKXt2YXIgZT1iLmdldFByb3BlcnR5KCJjZWxscyIpLGM9ITEsZz0hMTtpZigwPGUubGVuZ3RoKWZvcih2YXIgZj0wO2Y8ZS5sZW5ndGgmJihjPWQuZ2V0TW9kZWwoKS5pc1ZlcnRleChlW2ZdKXx8YywhKGc9ZC5nZXRNb2RlbCgpLmlzRWRnZShlW2ZdKXx8Zyl8fCFjKTtmKyspO2Vsc2UgZz1jPSEwO2Zvcih2YXIgZT1iLmdldFByb3BlcnR5KCJrZXlzIiksCmw9Yi5nZXRQcm9wZXJ0eSgidmFsdWVzIiksZj0wO2Y8ZS5sZW5ndGg7ZisrKXt2YXIgcD0wPD1teFV0aWxzLmluZGV4T2YoRyxlW2ZdKTtpZigic3Ryb2tlQ29sb3IiIT1lW2ZdfHxudWxsIT1sW2ZdJiYibm9uZSIhPWxbZl0paWYoMDw9bXhVdGlscy5pbmRleE9mKEQsZVtmXSkpZ3x8MDw9bXhVdGlscy5pbmRleE9mKEYsZVtmXSk/bnVsbD09bFtmXT9kZWxldGUgZC5jdXJyZW50RWRnZVN0eWxlW2VbZl1dOmQuY3VycmVudEVkZ2VTdHlsZVtlW2ZdXT1sW2ZdOmMmJjA8PW14VXRpbHMuaW5kZXhPZih6LGVbZl0pJiYobnVsbD09bFtmXT9kZWxldGUgZC5jdXJyZW50VmVydGV4U3R5bGVbZVtmXV06ZC5jdXJyZW50VmVydGV4U3R5bGVbZVtmXV09bFtmXSk7ZWxzZSBpZigwPD1teFV0aWxzLmluZGV4T2YoeixlW2ZdKSl7aWYoY3x8cCludWxsPT1sW2ZdP2RlbGV0ZSBkLmN1cnJlbnRWZXJ0ZXhTdHlsZVtlW2ZdXTpkLmN1cnJlbnRWZXJ0ZXhTdHlsZVtlW2ZdXT1sW2ZdO2lmKGd8fHB8fAowPD1teFV0aWxzLmluZGV4T2YoRixlW2ZdKSludWxsPT1sW2ZdP2RlbGV0ZSBkLmN1cnJlbnRFZGdlU3R5bGVbZVtmXV06ZC5jdXJyZW50RWRnZVN0eWxlW2VbZl1dPWxbZl19fW51bGwhPXRoaXMudG9vbGJhciYmKHRoaXMudG9vbGJhci5zZXRGb250TmFtZShkLmN1cnJlbnRWZXJ0ZXhTdHlsZS5mb250RmFtaWx5fHxNZW51cy5wcm90b3R5cGUuZGVmYXVsdEZvbnQpLHRoaXMudG9vbGJhci5zZXRGb250U2l6ZShkLmN1cnJlbnRWZXJ0ZXhTdHlsZS5mb250U2l6ZXx8TWVudXMucHJvdG90eXBlLmRlZmF1bHRGb250U2l6ZSksbnVsbCE9dGhpcy50b29sYmFyLmVkZ2VTdHlsZU1lbnUmJih0aGlzLnRvb2xiYXIuZWRnZVN0eWxlTWVudS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGl2IilbMF0uY2xhc3NOYW1lPSJvcnRob2dvbmFsRWRnZVN0eWxlIj09ZC5jdXJyZW50RWRnZVN0eWxlLmVkZ2VTdHlsZSYmIjEiPT1kLmN1cnJlbnRFZGdlU3R5bGUuY3VydmVkPyJnZVNwcml0ZSBnZVNwcml0ZS1jdXJ2ZWQiOgoic3RyYWlnaHQiPT1kLmN1cnJlbnRFZGdlU3R5bGUuZWRnZVN0eWxlfHwibm9uZSI9PWQuY3VycmVudEVkZ2VTdHlsZS5lZGdlU3R5bGV8fG51bGw9PWQuY3VycmVudEVkZ2VTdHlsZS5lZGdlU3R5bGU/ImdlU3ByaXRlIGdlU3ByaXRlLXN0cmFpZ2h0IjoiZW50aXR5UmVsYXRpb25FZGdlU3R5bGUiPT1kLmN1cnJlbnRFZGdlU3R5bGUuZWRnZVN0eWxlPyJnZVNwcml0ZSBnZVNwcml0ZS1lbnRpdHkiOiJlbGJvd0VkZ2VTdHlsZSI9PWQuY3VycmVudEVkZ2VTdHlsZS5lZGdlU3R5bGU/ImdlU3ByaXRlIGdlU3ByaXRlLSIrKCJ2ZXJ0aWNhbCI9PWQuY3VycmVudEVkZ2VTdHlsZS5lbGJvdz8idmVydGljYWxlbGJvdyI6Imhvcml6b250YWxlbGJvdyIpOiJpc29tZXRyaWNFZGdlU3R5bGUiPT1kLmN1cnJlbnRFZGdlU3R5bGUuZWRnZVN0eWxlPyJnZVNwcml0ZSBnZVNwcml0ZS0iKygidmVydGljYWwiPT1kLmN1cnJlbnRFZGdlU3R5bGUuZWxib3c/InZlcnRpY2FsaXNvbWV0cmljIjoiaG9yaXpvbnRhbGlzb21ldHJpYyIpOgoiZ2VTcHJpdGUgZ2VTcHJpdGUtb3J0aG9nb25hbCIpLG51bGwhPXRoaXMudG9vbGJhci5lZGdlU2hhcGVNZW51JiYodGhpcy50b29sYmFyLmVkZ2VTaGFwZU1lbnUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpWzBdLmNsYXNzTmFtZT0ibGluayI9PWQuY3VycmVudEVkZ2VTdHlsZS5zaGFwZT8iZ2VTcHJpdGUgZ2VTcHJpdGUtbGlua2VkZ2UiOiJmbGV4QXJyb3ciPT1kLmN1cnJlbnRFZGdlU3R5bGUuc2hhcGU/ImdlU3ByaXRlIGdlU3ByaXRlLWFycm93IjoiYXJyb3ciPT1kLmN1cnJlbnRFZGdlU3R5bGUuc2hhcGU/ImdlU3ByaXRlIGdlU3ByaXRlLXNpbXBsZWFycm93IjoiZ2VTcHJpdGUgZ2VTcHJpdGUtY29ubmVjdGlvbiIpLG51bGwhPXRoaXMudG9vbGJhci5saW5lU3RhcnRNZW51JiYodGhpcy50b29sYmFyLmxpbmVTdGFydE1lbnUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpWzBdLmNsYXNzTmFtZT10aGlzLmdldENzc0NsYXNzRm9yTWFya2VyKCJzdGFydCIsZC5jdXJyZW50RWRnZVN0eWxlLnNoYXBlLApkLmN1cnJlbnRFZGdlU3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1RBUlRBUlJPV10sbXhVdGlscy5nZXRWYWx1ZShkLmN1cnJlbnRFZGdlU3R5bGUsInN0YXJ0RmlsbCIsIjEiKSkpLG51bGwhPXRoaXMudG9vbGJhci5saW5lRW5kTWVudSYmKHRoaXMudG9vbGJhci5saW5lRW5kTWVudS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGl2IilbMF0uY2xhc3NOYW1lPXRoaXMuZ2V0Q3NzQ2xhc3NGb3JNYXJrZXIoImVuZCIsZC5jdXJyZW50RWRnZVN0eWxlLnNoYXBlLGQuY3VycmVudEVkZ2VTdHlsZVtteENvbnN0YW50cy5TVFlMRV9FTkRBUlJPV10sbXhVdGlscy5nZXRWYWx1ZShkLmN1cnJlbnRFZGdlU3R5bGUsImVuZEZpbGwiLCIxIikpKSl9KSk7bnVsbCE9dGhpcy50b29sYmFyJiYoYT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3ZhciBhPWQuY3VycmVudFZlcnRleFN0eWxlLmZvbnRGYW1pbHl8fCJIZWx2ZXRpY2EiLGI9U3RyaW5nKGQuY3VycmVudFZlcnRleFN0eWxlLmZvbnRTaXplfHwKIjEyIiksZT1kLmdldFZpZXcoKS5nZXRTdGF0ZShkLmdldFNlbGVjdGlvbkNlbGwoKSk7bnVsbCE9ZSYmKGE9ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9GT05URkFNSUxZXXx8YSxiPWUuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRk9OVFNJWkVdfHxiLDEwPGEubGVuZ3RoJiYoYT1hLnN1YnN0cmluZygwLDgpKyIuLi4iKSk7dGhpcy50b29sYmFyLnNldEZvbnROYW1lKGEpO3RoaXMudG9vbGJhci5zZXRGb250U2l6ZShiKX0pLGQuZ2V0U2VsZWN0aW9uTW9kZWwoKS5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSxhKSxkLmdldE1vZGVsKCkuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsYSkpO2QuYWRkTGlzdGVuZXIobXhFdmVudC5DRUxMU19BRERFRCxmdW5jdGlvbihhLGIpe3ZhciBlPWIuZ2V0UHJvcGVydHkoImNlbGxzIiksYz1iLmdldFByb3BlcnR5KCJwYXJlbnQiKTtkLmdldE1vZGVsKCkuaXNMYXllcihjKSYmIWQuaXNDZWxsVmlzaWJsZShjKSYmbnVsbCE9ZSYmMDxlLmxlbmd0aCYmCmQuZ2V0TW9kZWwoKS5zZXRWaXNpYmxlKGMsITApfSk7dGhpcy5nZXN0dXJlSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsIT10aGlzLmN1cnJlbnRNZW51JiZteEV2ZW50LmdldFNvdXJjZShhKSE9dGhpcy5jdXJyZW50TWVudS5kaXYmJnRoaXMuaGlkZUN1cnJlbnRNZW51KCl9KTtteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnMoZG9jdW1lbnQsdGhpcy5nZXN0dXJlSGFuZGxlcik7dGhpcy5yZXNpemVIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7d2luZG93LnNldFRpbWVvdXQobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtudWxsIT10aGlzLmVkaXRvci5ncmFwaCYmdGhpcy5yZWZyZXNoKCl9KSwwKX0pO214RXZlbnQuYWRkTGlzdGVuZXIod2luZG93LCJyZXNpemUiLHRoaXMucmVzaXplSGFuZGxlcik7dGhpcy5vcmllbnRhdGlvbkNoYW5nZUhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnJlZnJlc2goKX0pOwpteEV2ZW50LmFkZExpc3RlbmVyKHdpbmRvdywib3JpZW50YXRpb25jaGFuZ2UiLHRoaXMub3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyKTtteENsaWVudC5JU19JT1MmJiF3aW5kb3cubmF2aWdhdG9yLnN0YW5kYWxvbmUmJih0aGlzLnNjcm9sbEhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt3aW5kb3cuc2Nyb2xsVG8oMCwwKX0pLG14RXZlbnQuYWRkTGlzdGVuZXIod2luZG93LCJzY3JvbGwiLHRoaXMuc2Nyb2xsSGFuZGxlcikpO3RoaXMuZWRpdG9yLmFkZExpc3RlbmVyKCJyZXNldEdyYXBoVmlldyIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnJlc2V0U2Nyb2xsYmFycygpfSkpO3RoaXMuYWRkTGlzdGVuZXIoImdyaWRFbmFibGVkQ2hhbmdlZCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtkLnZpZXcudmFsaWRhdGVCYWNrZ3JvdW5kKCl9KSk7dGhpcy5hZGRMaXN0ZW5lcigiYmFja2dyb3VuZENvbG9yQ2hhbmdlZCIsbXhVdGlscy5iaW5kKHRoaXMsCmZ1bmN0aW9uKCl7ZC52aWV3LnZhbGlkYXRlQmFja2dyb3VuZCgpfSkpO2QuYWRkTGlzdGVuZXIoImdyaWRTaXplQ2hhbmdlZCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtkLmlzR3JpZEVuYWJsZWQoKSYmZC52aWV3LnZhbGlkYXRlQmFja2dyb3VuZCgpfSkpO3RoaXMuZWRpdG9yLnJlc2V0R3JhcGgoKX10aGlzLmluaXQoKTtkLnN0YW5kYWxvbmV8fHRoaXMub3BlbigpfTtteFV0aWxzLmV4dGVuZChFZGl0b3JVaSxteEV2ZW50U291cmNlKTtFZGl0b3JVaS5jb21wYWN0VWk9ITA7RWRpdG9yVWkucHJvdG90eXBlLnNwbGl0U2l6ZT1teENsaWVudC5JU19UT1VDSHx8bXhDbGllbnQuSVNfUE9JTlRFUj8xMjo4O0VkaXRvclVpLnByb3RvdHlwZS5tZW51YmFySGVpZ2h0PTMwO0VkaXRvclVpLnByb3RvdHlwZS5mb3JtYXRFbmFibGVkPSEwO0VkaXRvclVpLnByb3RvdHlwZS5mb3JtYXRXaWR0aD0yNDA7RWRpdG9yVWkucHJvdG90eXBlLnRvb2xiYXJIZWlnaHQ9Mzg7CkVkaXRvclVpLnByb3RvdHlwZS5mb290ZXJIZWlnaHQ9Mjg7RWRpdG9yVWkucHJvdG90eXBlLnNpZGViYXJGb290ZXJIZWlnaHQ9MzQ7RWRpdG9yVWkucHJvdG90eXBlLmhzcGxpdFBvc2l0aW9uPTY0MD49c2NyZWVuLndpZHRoPzExODoibGFyZ2UiIT11cmxQYXJhbXNbInNpZGViYXItZW50cmllcyJdPzIxMjoyNDA7RWRpdG9yVWkucHJvdG90eXBlLmFsbG93QW5pbWF0aW9uPSEwO0VkaXRvclVpLnByb3RvdHlwZS5saWdodGJveE1heEZpdFNjYWxlPTI7RWRpdG9yVWkucHJvdG90eXBlLmxpZ2h0Ym94VmVydGljYWxEaXZpZGVyPTQ7RWRpdG9yVWkucHJvdG90eXBlLmhzcGxpdENsaWNrRW5hYmxlZD0hMTsKRWRpdG9yVWkucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmVkaXRvci5ncmFwaDtpZighYS5zdGFuZGFsb25lKXtteEV2ZW50LmFkZExpc3RlbmVyKGEuY29udGFpbmVyLCJzY3JvbGwiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7YS50b29sdGlwSGFuZGxlci5oaWRlKCk7bnVsbCE9YS5jb25uZWN0aW9uSGFuZGxlciYmbnVsbCE9YS5jb25uZWN0aW9uSGFuZGxlci5jb25zdHJhaW50SGFuZGxlciYmYS5jb25uZWN0aW9uSGFuZGxlci5jb25zdHJhaW50SGFuZGxlci5yZXNldCgpfSkpO2EuYWRkTGlzdGVuZXIobXhFdmVudC5FU0NBUEUsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXthLnRvb2x0aXBIYW5kbGVyLmhpZGUoKTt2YXIgZD1hLmdldFJ1YmJlcmJhbmQoKTtudWxsIT1kJiZkLmNhbmNlbCgpfSkpO214RXZlbnQuYWRkTGlzdGVuZXIoYS5jb250YWluZXIsImtleWRvd24iLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMub25LZXlEb3duKGEpfSkpOwpteEV2ZW50LmFkZExpc3RlbmVyKGEuY29udGFpbmVyLCJrZXlwcmVzcyIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5vbktleVByZXNzKGEpfSkpO3RoaXMuYWRkVW5kb0xpc3RlbmVyKCk7dGhpcy5hZGRCZWZvcmVVbmxvYWRMaXN0ZW5lcigpO2EuZ2V0U2VsZWN0aW9uTW9kZWwoKS5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMudXBkYXRlQWN0aW9uU3RhdGVzKCl9KSk7YS5nZXRNb2RlbCgpLmFkZExpc3RlbmVyKG14RXZlbnQuQ0hBTkdFLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy51cGRhdGVBY3Rpb25TdGF0ZXMoKX0pKTt2YXIgYz1hLnNldERlZmF1bHRQYXJlbnQsZj10aGlzO3RoaXMuZWRpdG9yLmdyYXBoLnNldERlZmF1bHRQYXJlbnQ9ZnVuY3Rpb24oKXtjLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtmLnVwZGF0ZUFjdGlvblN0YXRlcygpfTthLmVkaXRMaW5rPWYuYWN0aW9ucy5nZXQoImVkaXRMaW5rIikuZnVuY3Q7CnRoaXMudXBkYXRlQWN0aW9uU3RhdGVzKCk7dGhpcy5pbml0Q2xpcGJvYXJkKCk7dGhpcy5pbml0Q2FudmFzKCk7bnVsbCE9dGhpcy5mb3JtYXQmJnRoaXMuZm9ybWF0LmluaXQoKX19O0VkaXRvclVpLnByb3RvdHlwZS5vbktleURvd249ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5lZGl0b3IuZ3JhcGg7OSE9YS53aGljaHx8IWMuaXNFbmFibGVkKCl8fG14RXZlbnQuaXNBbHREb3duKGEpfHxjLmlzRWRpdGluZygpJiZteEV2ZW50LmlzU2hpZnREb3duKGEpfHwoYy5pc0VkaXRpbmcoKT9jLnN0b3BFZGl0aW5nKCExKTpjLnNlbGVjdENlbGwoIW14RXZlbnQuaXNTaGlmdERvd24oYSkpLG14RXZlbnQuY29uc3VtZShhKSl9OwpFZGl0b3JVaS5wcm90b3R5cGUub25LZXlQcmVzcz1mdW5jdGlvbihhKXt2YXIgYz10aGlzLmVkaXRvci5ncmFwaDshdGhpcy5pc0ltbWVkaWF0ZUVkaXRpbmdFdmVudChhKXx8Yy5pc0VkaXRpbmcoKXx8Yy5pc1NlbGVjdGlvbkVtcHR5KCl8fDA9PT1hLndoaWNofHwyNz09PWEud2hpY2h8fG14RXZlbnQuaXNBbHREb3duKGEpfHxteEV2ZW50LmlzQ29udHJvbERvd24oYSl8fG14RXZlbnQuaXNNZXRhRG93bihhKXx8KGMuZXNjYXBlKCksYy5zdGFydEVkaXRpbmcoKSxteENsaWVudC5JU19GRiYmKGM9Yy5jZWxsRWRpdG9yLG51bGwhPWMudGV4dGFyZWEmJihjLnRleHRhcmVhLmlubmVySFRNTD1TdHJpbmcuZnJvbUNoYXJDb2RlKGEud2hpY2gpLGE9ZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSxhLnNlbGVjdE5vZGVDb250ZW50cyhjLnRleHRhcmVhKSxhLmNvbGxhcHNlKCExKSxjPXdpbmRvdy5nZXRTZWxlY3Rpb24oKSxjLnJlbW92ZUFsbFJhbmdlcygpLGMuYWRkUmFuZ2UoYSkpKSl9OwpFZGl0b3JVaS5wcm90b3R5cGUuaXNJbW1lZGlhdGVFZGl0aW5nRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuITB9OwpFZGl0b3JVaS5wcm90b3R5cGUuZ2V0Q3NzQ2xhc3NGb3JNYXJrZXI9ZnVuY3Rpb24oYSxjLGYsZCl7cmV0dXJuImZsZXhBcnJvdyI9PWM/bnVsbCE9ZiYmZiE9bXhDb25zdGFudHMuTk9ORT8iZ2VTcHJpdGUgZ2VTcHJpdGUtIithKyJibG9ja3RyYW5zIjoiZ2VTcHJpdGUgZ2VTcHJpdGUtbm9hcnJvdyI6ImJveCI9PWZ8fCJoYWxmQ2lyY2xlIj09Zj8iZ2VTcHJpdGUgZ2VTdmdTcHJpdGUgZ2VTcHJpdGUtIitmKygiZW5kIj09YT8iIGdlRmxpcFNwcml0ZSI6IiIpOmY9PW14Q29uc3RhbnRzLkFSUk9XX0NMQVNTSUM/IjEiPT1kPyJnZVNwcml0ZSBnZVNwcml0ZS0iK2ErImNsYXNzaWMiOiJnZVNwcml0ZSBnZVNwcml0ZS0iK2ErImNsYXNzaWN0cmFucyI6Zj09bXhDb25zdGFudHMuQVJST1dfQ0xBU1NJQ19USElOPyIxIj09ZD8iZ2VTcHJpdGUgZ2VTcHJpdGUtIithKyJjbGFzc2ljdGhpbiI6ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsiY2xhc3NpY3RoaW50cmFucyI6Zj09bXhDb25zdGFudHMuQVJST1dfT1BFTj8KImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsib3BlbiI6Zj09bXhDb25zdGFudHMuQVJST1dfT1BFTl9USElOPyJnZVNwcml0ZSBnZVNwcml0ZS0iK2ErIm9wZW50aGluIjpmPT1teENvbnN0YW50cy5BUlJPV19CTE9DSz8iMSI9PWQ/ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsiYmxvY2siOiJnZVNwcml0ZSBnZVNwcml0ZS0iK2ErImJsb2NrdHJhbnMiOmY9PW14Q29uc3RhbnRzLkFSUk9XX0JMT0NLX1RISU4/IjEiPT1kPyJnZVNwcml0ZSBnZVNwcml0ZS0iK2ErImJsb2NrdGhpbiI6ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsiYmxvY2t0aGludHJhbnMiOmY9PW14Q29uc3RhbnRzLkFSUk9XX09WQUw/IjEiPT1kPyJnZVNwcml0ZSBnZVNwcml0ZS0iK2ErIm92YWwiOiJnZVNwcml0ZSBnZVNwcml0ZS0iK2ErIm92YWx0cmFucyI6Zj09bXhDb25zdGFudHMuQVJST1dfRElBTU9ORD8iMSI9PWQ/ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsiZGlhbW9uZCI6ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsiZGlhbW9uZHRyYW5zIjoKZj09bXhDb25zdGFudHMuQVJST1dfRElBTU9ORF9USElOPyIxIj09ZD8iZ2VTcHJpdGUgZ2VTcHJpdGUtIithKyJ0aGluZGlhbW9uZCI6ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsidGhpbmRpYW1vbmR0cmFucyI6Im9wZW5Bc3luYyI9PWY/ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsib3BlbmFzeW5jIjoiZGFzaCI9PWY/ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsiZGFzaCI6ImNyb3NzIj09Zj8iZ2VTcHJpdGUgZ2VTcHJpdGUtIithKyJjcm9zcyI6ImFzeW5jIj09Zj8iMSI9PWQ/ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsiYXN5bmMiOiJnZVNwcml0ZSBnZVNwcml0ZS0iK2ErImFzeW5jdHJhbnMiOiJjaXJjbGUiPT1mfHwiY2lyY2xlUGx1cyI9PWY/IjEiPT1kfHwiY2lyY2xlIj09Zj8iZ2VTcHJpdGUgZ2VTcHJpdGUtIithKyJjaXJjbGUiOiJnZVNwcml0ZSBnZVNwcml0ZS0iK2ErImNpcmNsZXBsdXMiOiJFUm9uZSI9PWY/ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsiZXJvbmUiOiJFUm1hbmRPbmUiPT0KZj8iZ2VTcHJpdGUgZ2VTcHJpdGUtIithKyJlcm9uZXRvb25lIjoiRVJtYW55Ij09Zj8iZ2VTcHJpdGUgZ2VTcHJpdGUtIithKyJlcm1hbnkiOiJFUm9uZVRvTWFueSI9PWY/ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsiZXJvbmV0b21hbnkiOiJFUnplcm9Ub09uZSI9PWY/ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsiZXJvbmVvcHQiOiJFUnplcm9Ub01hbnkiPT1mPyJnZVNwcml0ZSBnZVNwcml0ZS0iK2ErImVybWFueW9wdCI6ImdlU3ByaXRlIGdlU3ByaXRlLW5vYXJyb3cifTtFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlTWVudXM9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07CkVkaXRvclVpLnByb3RvdHlwZS51cGRhdGVQYXN0ZUFjdGlvblN0YXRlcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZWRpdG9yLmdyYXBoLGM9dGhpcy5hY3Rpb25zLmdldCgicGFzdGUiKSxmPXRoaXMuYWN0aW9ucy5nZXQoInBhc3RlSGVyZSIpO2Muc2V0RW5hYmxlZCh0aGlzLmVkaXRvci5ncmFwaC5jZWxsRWRpdG9yLmlzQ29udGVudEVkaXRpbmcoKXx8IW14Q2xpcGJvYXJkLmlzRW1wdHkoKSYmYS5pc0VuYWJsZWQoKSYmIWEuaXNDZWxsTG9ja2VkKGEuZ2V0RGVmYXVsdFBhcmVudCgpKSk7Zi5zZXRFbmFibGVkKGMuaXNFbmFibGVkKCkpfTsKRWRpdG9yVWkucHJvdG90eXBlLmluaXRDbGlwYm9hcmQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGM9bXhDbGlwYm9hcmQuY3V0O214Q2xpcGJvYXJkLmN1dD1mdW5jdGlvbihkKXtkLmNlbGxFZGl0b3IuaXNDb250ZW50RWRpdGluZygpP2RvY3VtZW50LmV4ZWNDb21tYW5kKCJjdXQiLCExLG51bGwpOmMuYXBwbHkodGhpcyxhcmd1bWVudHMpO2EudXBkYXRlUGFzdGVBY3Rpb25TdGF0ZXMoKX07bXhDbGlwYm9hcmQuY29weT1mdW5jdGlvbihkKXt2YXIgYz1udWxsO2lmKGQuY2VsbEVkaXRvci5pc0NvbnRlbnRFZGl0aW5nKCkpZG9jdW1lbnQuZXhlY0NvbW1hbmQoImNvcHkiLCExLG51bGwpO2Vsc2V7Zm9yKHZhciBjPWN8fGQuZ2V0U2VsZWN0aW9uQ2VsbHMoKSxjPWQuZ2V0RXhwb3J0YWJsZUNlbGxzKGQubW9kZWwuZ2V0VG9wbW9zdENlbGxzKGMpKSxiPXt9LGU9ZC5jcmVhdGVDZWxsTG9va3VwKGMpLGc9ZC5jbG9uZUNlbGxzKGMsbnVsbCxiKSxmPW5ldyBteEdyYXBoTW9kZWwsbD1mLmdldENoaWxkQXQoZi5nZXRSb290KCksCjApLG49MDtuPGcubGVuZ3RoO24rKyl7Zi5hZGQobCxnW25dKTt2YXIgaz1kLnZpZXcuZ2V0U3RhdGUoY1tuXSk7aWYobnVsbCE9ayl7dmFyIHQ9ZC5nZXRDZWxsR2VvbWV0cnkoZ1tuXSk7bnVsbCE9dCYmdC5yZWxhdGl2ZSYmIWYuaXNFZGdlKGNbbl0pJiZudWxsPT1lW214T2JqZWN0SWRlbnRpdHkuZ2V0KGYuZ2V0UGFyZW50KGNbbl0pKV0mJih0Lm9mZnNldD1udWxsLHQucmVsYXRpdmU9ITEsdC54PWsueC9rLnZpZXcuc2NhbGUtay52aWV3LnRyYW5zbGF0ZS54LHQueT1rLnkvay52aWV3LnNjYWxlLWsudmlldy50cmFuc2xhdGUueSl9fWQudXBkYXRlQ3VzdG9tTGlua3MoZC5jcmVhdGVDZWxsTWFwcGluZyhiLGUpLGcpO214Q2xpcGJvYXJkLmluc2VydENvdW50PTE7bXhDbGlwYm9hcmQuc2V0Q2VsbHMoZyl9YS51cGRhdGVQYXN0ZUFjdGlvblN0YXRlcygpO3JldHVybiBjfTt2YXIgZj1teENsaXBib2FyZC5wYXN0ZTtteENsaXBib2FyZC5wYXN0ZT1mdW5jdGlvbihkKXt2YXIgYz0KbnVsbDtkLmNlbGxFZGl0b3IuaXNDb250ZW50RWRpdGluZygpP2RvY3VtZW50LmV4ZWNDb21tYW5kKCJwYXN0ZSIsITEsbnVsbCk6Yz1mLmFwcGx5KHRoaXMsYXJndW1lbnRzKTthLnVwZGF0ZVBhc3RlQWN0aW9uU3RhdGVzKCk7cmV0dXJuIGN9O3ZhciBkPXRoaXMuZWRpdG9yLmdyYXBoLmNlbGxFZGl0b3Iuc3RhcnRFZGl0aW5nO3RoaXMuZWRpdG9yLmdyYXBoLmNlbGxFZGl0b3Iuc3RhcnRFZGl0aW5nPWZ1bmN0aW9uKCl7ZC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YS51cGRhdGVQYXN0ZUFjdGlvblN0YXRlcygpfTt2YXIgbT10aGlzLmVkaXRvci5ncmFwaC5jZWxsRWRpdG9yLnN0b3BFZGl0aW5nO3RoaXMuZWRpdG9yLmdyYXBoLmNlbGxFZGl0b3Iuc3RvcEVkaXRpbmc9ZnVuY3Rpb24oZCxjKXttLmFwcGx5KHRoaXMsYXJndW1lbnRzKTthLnVwZGF0ZVBhc3RlQWN0aW9uU3RhdGVzKCl9O3RoaXMudXBkYXRlUGFzdGVBY3Rpb25TdGF0ZXMoKX07CkVkaXRvclVpLnByb3RvdHlwZS5sYXp5Wm9vbURlbGF5PTIwO0VkaXRvclVpLnByb3RvdHlwZS53aGVlbFpvb21EZWxheT00MDA7RWRpdG9yVWkucHJvdG90eXBlLmJ1dHRvblpvb21EZWxheT02MDA7CkVkaXRvclVpLnByb3RvdHlwZS5pbml0Q2FudmFzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lZGl0b3IuZ3JhcGg7YS50aW1lckF1dG9TY3JvbGw9ITA7YS5nZXRQYWdlUGFkZGluZz1mdW5jdGlvbigpe3JldHVybiBuZXcgbXhQb2ludChNYXRoLm1heCgwLE1hdGgucm91bmQoKGEuY29udGFpbmVyLm9mZnNldFdpZHRoLTM0KS9hLnZpZXcuc2NhbGUpKSxNYXRoLm1heCgwLE1hdGgucm91bmQoKGEuY29udGFpbmVyLm9mZnNldEhlaWdodC0zNCkvYS52aWV3LnNjYWxlKSkpfTthLnZpZXcuZ2V0QmFja2dyb3VuZFBhZ2VCb3VuZHM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoLmdldFBhZ2VMYXlvdXQoKSxiPXRoaXMuZ3JhcGguZ2V0UGFnZVNpemUoKTtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKHRoaXMuc2NhbGUqKHRoaXMudHJhbnNsYXRlLngrYS54KmIud2lkdGgpLHRoaXMuc2NhbGUqKHRoaXMudHJhbnNsYXRlLnkrYS55KmIuaGVpZ2h0KSx0aGlzLnNjYWxlKmEud2lkdGgqYi53aWR0aCwKdGhpcy5zY2FsZSphLmhlaWdodCpiLmhlaWdodCl9O2EuZ2V0UHJlZmVycmVkUGFnZVNpemU9ZnVuY3Rpb24oYSxiLGUpe2E9dGhpcy5nZXRQYWdlTGF5b3V0KCk7Yj10aGlzLmdldFBhZ2VTaXplKCk7cmV0dXJuIG5ldyBteFJlY3RhbmdsZSgwLDAsYS53aWR0aCpiLndpZHRoLGEuaGVpZ2h0KmIuaGVpZ2h0KX07dmFyIGM9bnVsbCxmPXRoaXM7aWYodGhpcy5lZGl0b3IuaXNDaHJvbWVsZXNzVmlldygpKXt0aGlzLmNocm9tZWxlc3NSZXNpemU9Yz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiLGUsZCxjKXtpZihudWxsIT1hLmNvbnRhaW5lciYmIWEuaXNWaWV3ZXIoKSl7ZD1udWxsIT1kP2Q6MDtjPW51bGwhPWM/YzowO3ZhciBnPWEucGFnZVZpc2libGU/YS52aWV3LmdldEJhY2tncm91bmRQYWdlQm91bmRzKCk6YS5nZXRHcmFwaEJvdW5kcygpLGY9bXhVdGlscy5oYXNTY3JvbGxiYXJzKGEuY29udGFpbmVyKSxsPWEudmlldy50cmFuc2xhdGUscD1hLnZpZXcuc2NhbGUsbj1teFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlKGcpOwpuLng9bi54L3AtbC54O24ueT1uLnkvcC1sLnk7bi53aWR0aC89cDtuLmhlaWdodC89cDt2YXIgbD1hLmNvbnRhaW5lci5zY3JvbGxUb3AsdT1hLmNvbnRhaW5lci5zY3JvbGxMZWZ0LHQ9bXhDbGllbnQuSVNfUVVJUktTfHw4PD1kb2N1bWVudC5kb2N1bWVudE1vZGU/MjA6MTQ7aWYoOD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHw5PT1kb2N1bWVudC5kb2N1bWVudE1vZGUpdCs9Mzt2YXIgQj1hLmNvbnRhaW5lci5vZmZzZXRXaWR0aC10LHQ9YS5jb250YWluZXIub2Zmc2V0SGVpZ2h0LXQ7Yj1iP01hdGgubWF4KC4zLE1hdGgubWluKGV8fDEsQi9uLndpZHRoKSk6cDtlPShCLWIqbi53aWR0aCkvMi9iO3ZhciBLPTA9PXRoaXMubGlnaHRib3hWZXJ0aWNhbERpdmlkZXI/MDoodC1iKm4uaGVpZ2h0KS90aGlzLmxpZ2h0Ym94VmVydGljYWxEaXZpZGVyL2I7ZiYmKGU9TWF0aC5tYXgoZSwwKSxLPU1hdGgubWF4KEssMCkpO2lmKGZ8fGcud2lkdGg8Qnx8Zy5oZWlnaHQ8dClhLnZpZXcuc2NhbGVBbmRUcmFuc2xhdGUoYiwKTWF0aC5mbG9vcihlLW4ueCksTWF0aC5mbG9vcihLLW4ueSkpLGEuY29udGFpbmVyLnNjcm9sbFRvcD1sKmIvcCxhLmNvbnRhaW5lci5zY3JvbGxMZWZ0PXUqYi9wO2Vsc2UgaWYoMCE9ZHx8MCE9YylnPWEudmlldy50cmFuc2xhdGUsYS52aWV3LnNldFRyYW5zbGF0ZShNYXRoLmZsb29yKGcueCtkL3ApLE1hdGguZmxvb3IoZy55K2MvcCkpfX0pO3RoaXMuY2hyb21lbGVzc1dpbmRvd1Jlc2l6ZT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuY2hyb21lbGVzc1Jlc2l6ZSghMSl9KTt2YXIgZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuY2hyb21lbGVzc1dpbmRvd1Jlc2l6ZSghMSl9KTtteEV2ZW50LmFkZExpc3RlbmVyKHdpbmRvdywicmVzaXplIixkKTt0aGlzLmRlc3Ryb3lGdW5jdGlvbnMucHVzaChmdW5jdGlvbigpe214RXZlbnQucmVtb3ZlTGlzdGVuZXIod2luZG93LCJyZXNpemUiLGQpfSk7dGhpcy5lZGl0b3IuYWRkTGlzdGVuZXIoInJlc2V0R3JhcGhWaWV3IiwKbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmNocm9tZWxlc3NSZXNpemUoITApfSkpO3RoaXMuYWN0aW9ucy5nZXQoInpvb21JbiIpLmZ1bmN0PW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe2Euem9vbUluKCk7dGhpcy5jaHJvbWVsZXNzUmVzaXplKCExKX0pO3RoaXMuYWN0aW9ucy5nZXQoInpvb21PdXQiKS5mdW5jdD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXthLnpvb21PdXQoKTt0aGlzLmNocm9tZWxlc3NSZXNpemUoITEpfSk7aWYoIjAiIT11cmxQYXJhbXMudG9vbGJhcil7dmFyIG09SlNPTi5wYXJzZShkZWNvZGVVUklDb21wb25lbnQodXJsUGFyYW1zWyJ0b29sYmFyLWNvbmZpZyJdfHwie30iKSk7dGhpcy5jaHJvbWVsZXNzVG9vbGJhcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTt0aGlzLmNocm9tZWxlc3NUb29sYmFyLnN0eWxlLnBvc2l0aW9uPSJmaXhlZCI7dGhpcy5jaHJvbWVsZXNzVG9vbGJhci5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjsKdGhpcy5jaHJvbWVsZXNzVG9vbGJhci5zdHlsZS5ib3hTaXppbmc9ImJvcmRlci1ib3giO3RoaXMuY2hyb21lbGVzc1Rvb2xiYXIuc3R5bGUud2hpdGVTcGFjZT0ibm93cmFwIjt0aGlzLmNocm9tZWxlc3NUb29sYmFyLnN0eWxlLmJhY2tncm91bmRDb2xvcj0iIzAwMDAwMCI7dGhpcy5jaHJvbWVsZXNzVG9vbGJhci5zdHlsZS5wYWRkaW5nPSIxMHB4IDEwcHggOHB4IDEwcHgiO3RoaXMuY2hyb21lbGVzc1Rvb2xiYXIuc3R5bGUubGVmdD1hLmlzVmlld2VyKCk/IjAiOiI1MCUiO214Q2xpZW50LklTX1ZNTHx8KG14VXRpbHMuc2V0UHJlZml4ZWRTdHlsZSh0aGlzLmNocm9tZWxlc3NUb29sYmFyLnN0eWxlLCJib3JkZXJSYWRpdXMiLCIyMHB4IiksbXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKHRoaXMuY2hyb21lbGVzc1Rvb2xiYXIuc3R5bGUsInRyYW5zaXRpb24iLCJvcGFjaXR5IDYwMG1zIGVhc2UtaW4tb3V0IikpO3ZhciBrPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGI9Cm14VXRpbHMuZ2V0Q3VycmVudFN0eWxlKGEuY29udGFpbmVyKTthLmlzVmlld2VyKCk/dGhpcy5jaHJvbWVsZXNzVG9vbGJhci5zdHlsZS50b3A9IjAiOnRoaXMuY2hyb21lbGVzc1Rvb2xiYXIuc3R5bGUuYm90dG9tPShudWxsIT1iP3BhcnNlSW50KGJbIm1hcmdpbi1ib3R0b20iXXx8MCk6MCkrKG51bGwhPXRoaXMudGFiQ29udGFpbmVyPzIwK3BhcnNlSW50KHRoaXMudGFiQ29udGFpbmVyLnN0eWxlLmhlaWdodCk6MjApKyJweCJ9KTt0aGlzLmVkaXRvci5hZGRMaXN0ZW5lcigicmVzZXRHcmFwaFZpZXciLGspO2soKTt2YXIgcT0wLGs9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiLGUpe3ErKzt2YXIgZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIik7ZC5zdHlsZS5wYWRkaW5nTGVmdD0iOHB4IjtkLnN0eWxlLnBhZGRpbmdSaWdodD0iOHB4IjtkLnN0eWxlLmN1cnNvcj0icG9pbnRlciI7bXhFdmVudC5hZGRMaXN0ZW5lcihkLCJjbGljayIsYSk7bnVsbCE9ZSYmZC5zZXRBdHRyaWJ1dGUoInRpdGxlIiwKZSk7YT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTthLnNldEF0dHJpYnV0ZSgiYm9yZGVyIiwiMCIpO2Euc2V0QXR0cmlidXRlKCJzcmMiLGIpO2QuYXBwZW5kQ2hpbGQoYSk7dGhpcy5jaHJvbWVsZXNzVG9vbGJhci5hcHBlbmRDaGlsZChkKTtyZXR1cm4gZH0pO251bGwhPW0uYmFja0J0biYmayhteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt3aW5kb3cubG9jYXRpb24uaHJlZj1tLmJhY2tCdG4udXJsO214RXZlbnQuY29uc3VtZShhKX0pLEVkaXRvci5iYWNrTGFyZ2VJbWFnZSxteFJlc291cmNlcy5nZXQoImJhY2siLG51bGwsIkJhY2siKSk7dmFyIGI9ayhteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmFjdGlvbnMuZ2V0KCJwcmV2aW91c1BhZ2UiKS5mdW5jdCgpO214RXZlbnQuY29uc3VtZShhKX0pLEVkaXRvci5wcmV2aW91c0xhcmdlSW1hZ2UsbXhSZXNvdXJjZXMuZ2V0KCJwcmV2aW91c1BhZ2UiKSksZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTsKZS5zdHlsZS5kaXNwbGF5PSJpbmxpbmUtYmxvY2siO2Uuc3R5bGUudmVydGljYWxBbGlnbj0idG9wIjtlLnN0eWxlLmZvbnRGYW1pbHk9IkhlbHZldGljYSxBcmlhbCI7ZS5zdHlsZS5tYXJnaW5Ub3A9IjhweCI7ZS5zdHlsZS5mb250U2l6ZT0iMTRweCI7ZS5zdHlsZS5jb2xvcj0iI2ZmZmZmZiI7dGhpcy5jaHJvbWVsZXNzVG9vbGJhci5hcHBlbmRDaGlsZChlKTt2YXIgZz1rKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuYWN0aW9ucy5nZXQoIm5leHRQYWdlIikuZnVuY3QoKTtteEV2ZW50LmNvbnN1bWUoYSl9KSxFZGl0b3IubmV4dExhcmdlSW1hZ2UsbXhSZXNvdXJjZXMuZ2V0KCJuZXh0UGFnZSIpKSxwPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5wYWdlcyYmMTx0aGlzLnBhZ2VzLmxlbmd0aCYmbnVsbCE9dGhpcy5jdXJyZW50UGFnZSYmKGUuaW5uZXJIVE1MPSIiLG14VXRpbHMud3JpdGUoZSxteFV0aWxzLmluZGV4T2YodGhpcy5wYWdlcywKdGhpcy5jdXJyZW50UGFnZSkrMSsiIC8gIit0aGlzLnBhZ2VzLmxlbmd0aCkpfSk7Yi5zdHlsZS5wYWRkaW5nTGVmdD0iMHB4IjtiLnN0eWxlLnBhZGRpbmdSaWdodD0iNHB4IjtnLnN0eWxlLnBhZGRpbmdMZWZ0PSI0cHgiO2cuc3R5bGUucGFkZGluZ1JpZ2h0PSIwcHgiO3ZhciBsPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5wYWdlcyYmMTx0aGlzLnBhZ2VzLmxlbmd0aCYmbnVsbCE9dGhpcy5jdXJyZW50UGFnZT8oZy5zdHlsZS5kaXNwbGF5PSIiLGIuc3R5bGUuZGlzcGxheT0iIixlLnN0eWxlLmRpc3BsYXk9ImlubGluZS1ibG9jayIpOihnLnN0eWxlLmRpc3BsYXk9Im5vbmUiLGIuc3R5bGUuZGlzcGxheT0ibm9uZSIsZS5zdHlsZS5kaXNwbGF5PSJub25lIik7cCgpfSk7dGhpcy5lZGl0b3IuYWRkTGlzdGVuZXIoInJlc2V0R3JhcGhWaWV3IixsKTt0aGlzLmVkaXRvci5hZGRMaXN0ZW5lcigicGFnZVNlbGVjdGVkIixwKTtrKG14VXRpbHMuYmluZCh0aGlzLApmdW5jdGlvbihhKXt0aGlzLmFjdGlvbnMuZ2V0KCJ6b29tT3V0IikuZnVuY3QoKTtteEV2ZW50LmNvbnN1bWUoYSl9KSxFZGl0b3Iuem9vbU91dExhcmdlSW1hZ2UsbXhSZXNvdXJjZXMuZ2V0KCJ6b29tT3V0IikrIiAoQWx0K01vdXNld2hlZWwpIik7ayhteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmFjdGlvbnMuZ2V0KCJ6b29tSW4iKS5mdW5jdCgpO214RXZlbnQuY29uc3VtZShhKX0pLEVkaXRvci56b29tSW5MYXJnZUltYWdlLG14UmVzb3VyY2VzLmdldCgiem9vbUluIikrIiAoQWx0K01vdXNld2hlZWwpIik7ayhteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXthLmlzTGlnaHRib3hWaWV3KCk/KDE9PWEudmlldy5zY2FsZT90aGlzLmxpZ2h0Ym94Rml0KCk6YS56b29tVG8oMSksdGhpcy5jaHJvbWVsZXNzUmVzaXplKCExKSk6dGhpcy5jaHJvbWVsZXNzUmVzaXplKCEwKTtteEV2ZW50LmNvbnN1bWUoYil9KSxFZGl0b3IuYWN0dWFsU2l6ZUxhcmdlSW1hZ2UsCm14UmVzb3VyY2VzLmdldCgiZml0IikpO3ZhciBuPW51bGwsdj1udWxsLHQ9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bnVsbCE9biYmKHdpbmRvdy5jbGVhclRpbWVvdXQobiksZmFkZVRoZWFkPW51bGwpO251bGwhPXYmJih3aW5kb3cuY2xlYXJUaW1lb3V0KHYpLGZhZGVUaGVhZDI9bnVsbCk7bj13aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe214VXRpbHMuc2V0T3BhY2l0eSh0aGlzLmNocm9tZWxlc3NUb29sYmFyLDApO249bnVsbDt2PXdpbmRvdy5zZXRUaW1lb3V0KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5jaHJvbWVsZXNzVG9vbGJhci5zdHlsZS5kaXNwbGF5PSJub25lIjt2PW51bGx9KSw2MDApfSksYXx8MjAwKX0pLHk9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bnVsbCE9biYmKHdpbmRvdy5jbGVhclRpbWVvdXQobiksZmFkZVRoZWFkPW51bGwpO251bGwhPXYmJih3aW5kb3cuY2xlYXJUaW1lb3V0KHYpLApmYWRlVGhlYWQyPW51bGwpO3RoaXMuY2hyb21lbGVzc1Rvb2xiYXIuc3R5bGUuZGlzcGxheT0iIjtteFV0aWxzLnNldE9wYWNpdHkodGhpcy5jaHJvbWVsZXNzVG9vbGJhcixhfHwzMCl9KTtpZigiMSI9PXVybFBhcmFtcy5sYXllcnMpe3RoaXMubGF5ZXJzRGlhbG9nPW51bGw7dmFyIHg9ayhteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXtpZihudWxsIT10aGlzLmxheWVyc0RpYWxvZyl0aGlzLmxheWVyc0RpYWxvZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubGF5ZXJzRGlhbG9nKSx0aGlzLmxheWVyc0RpYWxvZz1udWxsO2Vsc2V7dGhpcy5sYXllcnNEaWFsb2c9YS5jcmVhdGVMYXllcnNEaWFsb2coKTtteEV2ZW50LmFkZExpc3RlbmVyKHRoaXMubGF5ZXJzRGlhbG9nLCJtb3VzZWxlYXZlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMubGF5ZXJzRGlhbG9nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5sYXllcnNEaWFsb2cpO3RoaXMubGF5ZXJzRGlhbG9nPQpudWxsfSkpO3ZhciBlPXguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7bXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKHRoaXMubGF5ZXJzRGlhbG9nLnN0eWxlLCJib3JkZXJSYWRpdXMiLCI1cHgiKTt0aGlzLmxheWVyc0RpYWxvZy5zdHlsZS5wb3NpdGlvbj0iZml4ZWQiO3RoaXMubGF5ZXJzRGlhbG9nLnN0eWxlLmZvbnRGYW1pbHk9IkhlbHZldGljYSxBcmlhbCI7dGhpcy5sYXllcnNEaWFsb2cuc3R5bGUuYmFja2dyb3VuZENvbG9yPSIjMDAwMDAwIjt0aGlzLmxheWVyc0RpYWxvZy5zdHlsZS53aWR0aD0iMTYwcHgiO3RoaXMubGF5ZXJzRGlhbG9nLnN0eWxlLnBhZGRpbmc9IjRweCAycHggNHB4IDJweCI7dGhpcy5sYXllcnNEaWFsb2cuc3R5bGUuY29sb3I9IiNmZmZmZmYiO214VXRpbHMuc2V0T3BhY2l0eSh0aGlzLmxheWVyc0RpYWxvZyw3MCk7dGhpcy5sYXllcnNEaWFsb2cuc3R5bGUubGVmdD1lLmxlZnQrInB4Ijt0aGlzLmxheWVyc0RpYWxvZy5zdHlsZS5ib3R0b209cGFyc2VJbnQodGhpcy5jaHJvbWVsZXNzVG9vbGJhci5zdHlsZS5ib3R0b20pKwp0aGlzLmNocm9tZWxlc3NUb29sYmFyLm9mZnNldEhlaWdodCs0KyJweCI7ZT1teFV0aWxzLmdldEN1cnJlbnRTdHlsZSh0aGlzLmVkaXRvci5ncmFwaC5jb250YWluZXIpO3RoaXMubGF5ZXJzRGlhbG9nLnN0eWxlLnpJbmRleD1lLnpJbmRleDtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMubGF5ZXJzRGlhbG9nKX1teEV2ZW50LmNvbnN1bWUoYil9KSxFZGl0b3IubGF5ZXJzTGFyZ2VJbWFnZSxteFJlc291cmNlcy5nZXQoImxheWVycyIpKSxFPWEuZ2V0TW9kZWwoKTtFLmFkZExpc3RlbmVyKG14RXZlbnQuQ0hBTkdFLGZ1bmN0aW9uKCl7eC5zdHlsZS5kaXNwbGF5PTE8RS5nZXRDaGlsZENvdW50KEUucm9vdCk/IiI6Im5vbmUifSl9dGhpcy5hZGRDaHJvbWVsZXNzVG9vbGJhckl0ZW1zKGspO251bGw9PXRoaXMuZWRpdG9yLmVkaXRCdXR0b25MaW5rJiZudWxsPT10aGlzLmVkaXRvci5lZGl0QnV0dG9uRnVuY3x8ayhteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXtudWxsIT0KdGhpcy5lZGl0b3IuZWRpdEJ1dHRvbkZ1bmM/dGhpcy5lZGl0b3IuZWRpdEJ1dHRvbkZ1bmMoKToiX2JsYW5rIj09dGhpcy5lZGl0b3IuZWRpdEJ1dHRvbkxpbms/dGhpcy5lZGl0b3IuZWRpdEFzTmV3KHRoaXMuZ2V0RWRpdEJsYW5rWG1sKCkpOmEub3BlbkxpbmsodGhpcy5lZGl0b3IuZWRpdEJ1dHRvbkxpbmssImVkaXRXaW5kb3ciKTtteEV2ZW50LmNvbnN1bWUoYil9KSxFZGl0b3IuZWRpdExhcmdlSW1hZ2UsbXhSZXNvdXJjZXMuZ2V0KCJlZGl0IikpO2lmKG51bGwhPXRoaXMubGlnaHRib3hUb29sYmFyQWN0aW9ucylmb3IobD0wO2w8dGhpcy5saWdodGJveFRvb2xiYXJBY3Rpb25zLmxlbmd0aDtsKyspe3ZhciBBPXRoaXMubGlnaHRib3hUb29sYmFyQWN0aW9uc1tsXTtrKEEuZm4sQS5pY29uLEEudG9vbHRpcCl9bnVsbCE9bS5yZWZyZXNoQnRuJiZrKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe20ucmVmcmVzaEJ0bi51cmw/d2luZG93LmxvY2F0aW9uLmhyZWY9bS5yZWZyZXNoQnRuLnVybDoKd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO214RXZlbnQuY29uc3VtZShhKX0pLEVkaXRvci5yZWZyZXNoTGFyZ2VJbWFnZSxteFJlc291cmNlcy5nZXQoInJlZnJlc2giLG51bGwsIlJlZnJlc2giKSk7bnVsbCE9bS5mdWxsc2NyZWVuQnRuJiZ3aW5kb3cuc2VsZiE9PXdpbmRvdy50b3AmJmsobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7bS5mdWxsc2NyZWVuQnRuLnVybD9hLm9wZW5MaW5rKG0uZnVsbHNjcmVlbkJ0bi51cmwpOmEub3Blbkxpbmsod2luZG93LmxvY2F0aW9uLmhyZWYpO214RXZlbnQuY29uc3VtZShiKX0pLEVkaXRvci5mdWxsc2NyZWVuTGFyZ2VJbWFnZSxteFJlc291cmNlcy5nZXQoIm9wZW5Jbk5ld1dpbmRvdyIsbnVsbCwiT3BlbiBpbiBOZXcgV2luZG93IikpOyhtLmNsb3NlQnRuJiZ3aW5kb3cuc2VsZj09PXdpbmRvdy50b3B8fGEubGlnaHRib3gmJigiMSI9PXVybFBhcmFtcy5jbG9zZXx8dGhpcy5jb250YWluZXIhPWRvY3VtZW50LmJvZHkpKSYmayhteFV0aWxzLmJpbmQodGhpcywKZnVuY3Rpb24oYSl7IjEiPT11cmxQYXJhbXMuY2xvc2V8fG0uY2xvc2VCdG4/d2luZG93LmNsb3NlKCk6KHRoaXMuZGVzdHJveSgpLG14RXZlbnQuY29uc3VtZShhKSl9KSxFZGl0b3IuY2xvc2VMYXJnZUltYWdlLG14UmVzb3VyY2VzLmdldCgiY2xvc2UiKSsiIChFc2NhcGUpIik7dGhpcy5jaHJvbWVsZXNzVG9vbGJhci5zdHlsZS5kaXNwbGF5PSJub25lIjthLmlzVmlld2VyKCl8fG14VXRpbHMuc2V0UHJlZml4ZWRTdHlsZSh0aGlzLmNocm9tZWxlc3NUb29sYmFyLnN0eWxlLCJ0cmFuc2Zvcm0iLCJ0cmFuc2xhdGUoLTUwJSwwKSIpO2EuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuY2hyb21lbGVzc1Rvb2xiYXIpO214RXZlbnQuYWRkTGlzdGVuZXIoYS5jb250YWluZXIsbXhDbGllbnQuSVNfUE9JTlRFUj8icG9pbnRlcm1vdmUiOiJtb3VzZW1vdmUiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe214RXZlbnQuaXNUb3VjaEV2ZW50KGEpfHwobXhFdmVudC5pc1NoaWZ0RG93bihhKXx8CnkoMzApLHQoKSl9KSk7bXhFdmVudC5hZGRMaXN0ZW5lcih0aGlzLmNocm9tZWxlc3NUb29sYmFyLG14Q2xpZW50LklTX1BPSU5URVI/InBvaW50ZXJtb3ZlIjoibW91c2Vtb3ZlIixmdW5jdGlvbihhKXtteEV2ZW50LmNvbnN1bWUoYSl9KTtteEV2ZW50LmFkZExpc3RlbmVyKHRoaXMuY2hyb21lbGVzc1Rvb2xiYXIsIm1vdXNlZW50ZXIiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe214RXZlbnQuaXNTaGlmdERvd24oYSk/dCgpOnkoMTAwKX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKHRoaXMuY2hyb21lbGVzc1Rvb2xiYXIsIm1vdXNlbW92ZSIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bXhFdmVudC5pc1NoaWZ0RG93bihhKT90KCk6eSgxMDApO214RXZlbnQuY29uc3VtZShhKX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKHRoaXMuY2hyb21lbGVzc1Rvb2xiYXIsIm1vdXNlbGVhdmUiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe214RXZlbnQuaXNUb3VjaEV2ZW50KGEpfHwKeSgzMCl9KSk7dmFyIEM9YS5nZXRUb2xlcmFuY2UoKTthLmFkZE1vdXNlTGlzdGVuZXIoe3N0YXJ0WDowLHN0YXJ0WTowLHNjcm9sbExlZnQ6MCxzY3JvbGxUb3A6MCxtb3VzZURvd246ZnVuY3Rpb24oYixlKXt0aGlzLnN0YXJ0WD1lLmdldEdyYXBoWCgpO3RoaXMuc3RhcnRZPWUuZ2V0R3JhcGhZKCk7dGhpcy5zY3JvbGxMZWZ0PWEuY29udGFpbmVyLnNjcm9sbExlZnQ7dGhpcy5zY3JvbGxUb3A9YS5jb250YWluZXIuc2Nyb2xsVG9wfSxtb3VzZU1vdmU6ZnVuY3Rpb24oYSxiKXt9LG1vdXNlVXA6ZnVuY3Rpb24oYixlKXtteEV2ZW50LmlzVG91Y2hFdmVudChlLmdldEV2ZW50KCkpJiZNYXRoLmFicyh0aGlzLnNjcm9sbExlZnQtYS5jb250YWluZXIuc2Nyb2xsTGVmdCk8QyYmTWF0aC5hYnModGhpcy5zY3JvbGxUb3AtYS5jb250YWluZXIuc2Nyb2xsVG9wKTxDJiZNYXRoLmFicyh0aGlzLnN0YXJ0WC1lLmdldEdyYXBoWCgpKTxDJiZNYXRoLmFicyh0aGlzLnN0YXJ0WS1lLmdldEdyYXBoWSgpKTwKQyYmKDA8cGFyc2VGbG9hdChmLmNocm9tZWxlc3NUb29sYmFyLnN0eWxlLm9wYWNpdHl8fDApP3QoKTp5KDMwKSl9fSl9dGhpcy5lZGl0b3IuZWRpdGFibGV8fHRoaXMuYWRkQ2hyb21lbGVzc0NsaWNrSGFuZGxlcigpfWVsc2UgaWYodGhpcy5lZGl0b3IuZXh0ZW5kQ2FudmFzKXt2YXIgej1hLnZpZXcudmFsaWRhdGU7YS52aWV3LnZhbGlkYXRlPWZ1bmN0aW9uKCl7aWYobnVsbCE9dGhpcy5ncmFwaC5jb250YWluZXImJm14VXRpbHMuaGFzU2Nyb2xsYmFycyh0aGlzLmdyYXBoLmNvbnRhaW5lcikpe3ZhciBhPXRoaXMuZ3JhcGguZ2V0UGFnZVBhZGRpbmcoKSxiPXRoaXMuZ3JhcGguZ2V0UGFnZVNpemUoKTt0aGlzLnRyYW5zbGF0ZS54PWEueC0odGhpcy54MHx8MCkqYi53aWR0aDt0aGlzLnRyYW5zbGF0ZS55PWEueS0odGhpcy55MHx8MCkqYi5oZWlnaHR9ei5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2lmKCFhLmlzVmlld2VyKCkpe3ZhciBEPWEuc2l6ZURpZENoYW5nZTthLnNpemVEaWRDaGFuZ2U9CmZ1bmN0aW9uKCl7aWYobnVsbCE9dGhpcy5jb250YWluZXImJm14VXRpbHMuaGFzU2Nyb2xsYmFycyh0aGlzLmNvbnRhaW5lcikpe3ZhciBiPXRoaXMuZ2V0UGFnZUxheW91dCgpLGU9dGhpcy5nZXRQYWdlUGFkZGluZygpLGQ9dGhpcy5nZXRQYWdlU2l6ZSgpLGM9TWF0aC5jZWlsKDIqZS54K2Iud2lkdGgqZC53aWR0aCksZz1NYXRoLmNlaWwoMiplLnkrYi5oZWlnaHQqZC5oZWlnaHQpLGY9YS5taW5pbXVtR3JhcGhTaXplO2lmKG51bGw9PWZ8fGYud2lkdGghPWN8fGYuaGVpZ2h0IT1nKWEubWluaW11bUdyYXBoU2l6ZT1uZXcgbXhSZWN0YW5nbGUoMCwwLGMsZyk7Yz1lLngtYi54KmQud2lkdGg7ZT1lLnktYi55KmQuaGVpZ2h0O3RoaXMuYXV0b1RyYW5zbGF0ZXx8dGhpcy52aWV3LnRyYW5zbGF0ZS54PT1jJiZ0aGlzLnZpZXcudHJhbnNsYXRlLnk9PWU/RC5hcHBseSh0aGlzLGFyZ3VtZW50cyk6KHRoaXMuYXV0b1RyYW5zbGF0ZT0hMCx0aGlzLnZpZXcueDA9Yi54LHRoaXMudmlldy55MD0KYi55LGI9YS52aWV3LnRyYW5zbGF0ZS54LGQ9YS52aWV3LnRyYW5zbGF0ZS55LGEudmlldy5zZXRUcmFuc2xhdGUoYyxlKSxhLmNvbnRhaW5lci5zY3JvbGxMZWZ0Kz1NYXRoLnJvdW5kKChjLWIpKmEudmlldy5zY2FsZSksYS5jb250YWluZXIuc2Nyb2xsVG9wKz1NYXRoLnJvdW5kKChlLWQpKmEudmlldy5zY2FsZSksdGhpcy5hdXRvVHJhbnNsYXRlPSExKX1lbHNlIHRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuU0laRSwiYm91bmRzIix0aGlzLmdldEdyYXBoQm91bmRzKCkpKX19fXZhciBHPWEudmlldy5nZXRCYWNrZ3JvdW5kUGFuZSgpLEY9YS52aWV3LmdldERyYXdQYW5lKCk7YS5jdW11bGF0aXZlWm9vbUZhY3Rvcj0xO3ZhciBIPW51bGwsSj1udWxsLHU9bnVsbCxLPW51bGwsQj1mdW5jdGlvbihiKXtudWxsIT1IJiZ3aW5kb3cuY2xlYXJUaW1lb3V0KEgpO3dpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5pc01vdXNlRG93bnx8KEg9d2luZG93LnNldFRpbWVvdXQobXhVdGlscy5iaW5kKHRoaXMsCmZ1bmN0aW9uKCl7YS5pc0Zhc3Rab29tRW5hYmxlZCgpJiYobnVsbCE9YS52aWV3LmJhY2tncm91bmRQYWdlU2hhcGUmJm51bGwhPWEudmlldy5iYWNrZ3JvdW5kUGFnZVNoYXBlLm5vZGUmJihteFV0aWxzLnNldFByZWZpeGVkU3R5bGUoYS52aWV3LmJhY2tncm91bmRQYWdlU2hhcGUubm9kZS5zdHlsZSwidHJhbnNmb3JtLW9yaWdpbiIsbnVsbCksbXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGEudmlldy5iYWNrZ3JvdW5kUGFnZVNoYXBlLm5vZGUuc3R5bGUsInRyYW5zZm9ybSIsbnVsbCkpLEYuc3R5bGUudHJhbnNmb3JtT3JpZ2luPSIiLEcuc3R5bGUudHJhbnNmb3JtT3JpZ2luPSIiLG14Q2xpZW50LklTX1NGPyhGLnN0eWxlLnRyYW5zZm9ybT0ic2NhbGUoMSkiLEcuc3R5bGUudHJhbnNmb3JtPSJzY2FsZSgxKSIsd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtGLnN0eWxlLnRyYW5zZm9ybT0iIjtHLnN0eWxlLnRyYW5zZm9ybT0iIn0sMCkpOihGLnN0eWxlLnRyYW5zZm9ybT0KIiIsRy5zdHlsZS50cmFuc2Zvcm09IiIpLGEudmlldy5nZXREZWNvcmF0b3JQYW5lKCkuc3R5bGUub3BhY2l0eT0iIixhLnZpZXcuZ2V0T3ZlcmxheVBhbmUoKS5zdHlsZS5vcGFjaXR5PSIiKTt2YXIgYj1uZXcgbXhQb2ludChhLmNvbnRhaW5lci5zY3JvbGxMZWZ0LGEuY29udGFpbmVyLnNjcm9sbFRvcCksZT1teFV0aWxzLmdldE9mZnNldChhLmNvbnRhaW5lciksZD1hLnZpZXcuc2NhbGUsZz0wLGw9MDtudWxsIT1KJiYoZz1hLmNvbnRhaW5lci5vZmZzZXRXaWR0aC8yLUoueCtlLngsbD1hLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQvMi1KLnkrZS55KTthLnpvb20oYS5jdW11bGF0aXZlWm9vbUZhY3Rvcik7YS52aWV3LnNjYWxlIT1kJiYobnVsbCE9dSYmKGcrPWIueC11LngsbCs9Yi55LXUueSksbnVsbCE9YyYmZi5jaHJvbWVsZXNzUmVzaXplKCExLG51bGwsZyooYS5jdW11bGF0aXZlWm9vbUZhY3Rvci0xKSxsKihhLmN1bXVsYXRpdmVab29tRmFjdG9yLTEpKSwhbXhVdGlscy5oYXNTY3JvbGxiYXJzKGEuY29udGFpbmVyKXx8CjA9PWcmJjA9PWx8fChhLmNvbnRhaW5lci5zY3JvbGxMZWZ0LT1nKihhLmN1bXVsYXRpdmVab29tRmFjdG9yLTEpLGEuY29udGFpbmVyLnNjcm9sbFRvcC09bCooYS5jdW11bGF0aXZlWm9vbUZhY3Rvci0xKSkpO251bGwhPUsmJkYuc2V0QXR0cmlidXRlKCJmaWx0ZXIiLEspO2EuY3VtdWxhdGl2ZVpvb21GYWN0b3I9MTtLPUo9dT1IPW51bGx9KSxudWxsIT1iP2I6YS5pc0Zhc3Rab29tRW5hYmxlZCgpP2Yud2hlZWxab29tRGVsYXk6Zi5sYXp5Wm9vbURlbGF5KSl9LDApfTthLmxhenlab29tPWZ1bmN0aW9uKGIsZSxkKXsoZT1lfHwhYS5zY3JvbGxiYXJzKSYmKEo9bmV3IG14UG9pbnQoYS5jb250YWluZXIub2Zmc2V0TGVmdCthLmNvbnRhaW5lci5jbGllbnRXaWR0aC8yLGEuY29udGFpbmVyLm9mZnNldFRvcCthLmNvbnRhaW5lci5jbGllbnRIZWlnaHQvMikpO2I/LjE1Pj10aGlzLnZpZXcuc2NhbGUqdGhpcy5jdW11bGF0aXZlWm9vbUZhY3Rvcj90aGlzLmN1bXVsYXRpdmVab29tRmFjdG9yKj0KKHRoaXMudmlldy5zY2FsZSsuMDUpL3RoaXMudmlldy5zY2FsZToodGhpcy5jdW11bGF0aXZlWm9vbUZhY3Rvcio9dGhpcy56b29tRmFjdG9yLHRoaXMuY3VtdWxhdGl2ZVpvb21GYWN0b3I9TWF0aC5yb3VuZCh0aGlzLnZpZXcuc2NhbGUqdGhpcy5jdW11bGF0aXZlWm9vbUZhY3RvcioyMCkvMjAvdGhpcy52aWV3LnNjYWxlKTouMTU+PXRoaXMudmlldy5zY2FsZSp0aGlzLmN1bXVsYXRpdmVab29tRmFjdG9yP3RoaXMuY3VtdWxhdGl2ZVpvb21GYWN0b3IqPSh0aGlzLnZpZXcuc2NhbGUtLjA1KS90aGlzLnZpZXcuc2NhbGU6KHRoaXMuY3VtdWxhdGl2ZVpvb21GYWN0b3IvPXRoaXMuem9vbUZhY3Rvcix0aGlzLmN1bXVsYXRpdmVab29tRmFjdG9yPU1hdGgucm91bmQodGhpcy52aWV3LnNjYWxlKnRoaXMuY3VtdWxhdGl2ZVpvb21GYWN0b3IqMjApLzIwL3RoaXMudmlldy5zY2FsZSk7dGhpcy5jdW11bGF0aXZlWm9vbUZhY3Rvcj1NYXRoLm1heCguMDUsTWF0aC5taW4odGhpcy52aWV3LnNjYWxlKgp0aGlzLmN1bXVsYXRpdmVab29tRmFjdG9yLDE2MCkpL3RoaXMudmlldy5zY2FsZTtpZihhLmlzRmFzdFpvb21FbmFibGVkKCkpe251bGw9PUsmJiIiIT1GLmdldEF0dHJpYnV0ZSgiZmlsdGVyIikmJihLPUYuZ2V0QXR0cmlidXRlKCJmaWx0ZXIiKSxGLnJlbW92ZUF0dHJpYnV0ZSgiZmlsdGVyIikpO3U9bmV3IG14UG9pbnQoYS5jb250YWluZXIuc2Nyb2xsTGVmdCxhLmNvbnRhaW5lci5zY3JvbGxUb3ApO2I9ZT9hLmNvbnRhaW5lci5zY3JvbGxMZWZ0K2EuY29udGFpbmVyLmNsaWVudFdpZHRoLzI6Si54K2EuY29udGFpbmVyLnNjcm9sbExlZnQtYS5jb250YWluZXIub2Zmc2V0TGVmdDt2YXIgYz1lP2EuY29udGFpbmVyLnNjcm9sbFRvcCthLmNvbnRhaW5lci5jbGllbnRIZWlnaHQvMjpKLnkrYS5jb250YWluZXIuc2Nyb2xsVG9wLWEuY29udGFpbmVyLm9mZnNldFRvcDtGLnN0eWxlLnRyYW5zZm9ybU9yaWdpbj1iKyJweCAiK2MrInB4IjtGLnN0eWxlLnRyYW5zZm9ybT0ic2NhbGUoIisKdGhpcy5jdW11bGF0aXZlWm9vbUZhY3RvcisiKSI7Ry5zdHlsZS50cmFuc2Zvcm1PcmlnaW49YisicHggIitjKyJweCI7Ry5zdHlsZS50cmFuc2Zvcm09InNjYWxlKCIrdGhpcy5jdW11bGF0aXZlWm9vbUZhY3RvcisiKSI7bnVsbCE9YS52aWV3LmJhY2tncm91bmRQYWdlU2hhcGUmJm51bGwhPWEudmlldy5iYWNrZ3JvdW5kUGFnZVNoYXBlLm5vZGUmJihiPWEudmlldy5iYWNrZ3JvdW5kUGFnZVNoYXBlLm5vZGUsbXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGIuc3R5bGUsInRyYW5zZm9ybS1vcmlnaW4iLChlP2EuY29udGFpbmVyLmNsaWVudFdpZHRoLzIrYS5jb250YWluZXIuc2Nyb2xsTGVmdC1iLm9mZnNldExlZnQrInB4IjpKLngrYS5jb250YWluZXIuc2Nyb2xsTGVmdC1iLm9mZnNldExlZnQtYS5jb250YWluZXIub2Zmc2V0TGVmdCsicHgiKSsiICIrKGU/YS5jb250YWluZXIuY2xpZW50SGVpZ2h0LzIrYS5jb250YWluZXIuc2Nyb2xsVG9wLWIub2Zmc2V0VG9wKyJweCI6Si55KwphLmNvbnRhaW5lci5zY3JvbGxUb3AtYi5vZmZzZXRUb3AtYS5jb250YWluZXIub2Zmc2V0VG9wKyJweCIpKSxteFV0aWxzLnNldFByZWZpeGVkU3R5bGUoYi5zdHlsZSwidHJhbnNmb3JtIiwic2NhbGUoIit0aGlzLmN1bXVsYXRpdmVab29tRmFjdG9yKyIpIikpO2Eudmlldy5nZXREZWNvcmF0b3JQYW5lKCkuc3R5bGUub3BhY2l0eT0iMCI7YS52aWV3LmdldE92ZXJsYXlQYW5lKCkuc3R5bGUub3BhY2l0eT0iMCI7bnVsbCE9Zi5ob3Zlckljb25zJiZmLmhvdmVySWNvbnMucmVzZXQoKX1CKGQpfTtteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnMoYS5jb250YWluZXIsZnVuY3Rpb24oYSl7bnVsbCE9SCYmd2luZG93LmNsZWFyVGltZW91dChIKX0sbnVsbCxmdW5jdGlvbihiKXsxIT1hLmN1bXVsYXRpdmVab29tRmFjdG9yJiZCKDApfSk7bXhFdmVudC5hZGRMaXN0ZW5lcihhLmNvbnRhaW5lciwic2Nyb2xsIixmdW5jdGlvbigpe0gmJiFhLmlzTW91c2VEb3duJiYxIT1hLmN1bXVsYXRpdmVab29tRmFjdG9yJiYKQigwKX0pO214RXZlbnQuYWRkTW91c2VXaGVlbExpc3RlbmVyKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIsZSxkKXtpZihudWxsPT10aGlzLmRpYWxvZ3N8fDA9PXRoaXMuZGlhbG9ncy5sZW5ndGgpaWYoIWEuc2Nyb2xsYmFycyYmYS5pc1Njcm9sbFdoZWVsRXZlbnQoYikpe2Q9YS52aWV3LmdldFRyYW5zbGF0ZSgpO3ZhciBjPTQwL2Eudmlldy5zY2FsZTtteEV2ZW50LmlzU2hpZnREb3duKGIpP2Eudmlldy5zZXRUcmFuc2xhdGUoZC54KyhlPy1jOmMpLGQueSk6YS52aWV3LnNldFRyYW5zbGF0ZShkLngsZC55KyhlP2M6LWMpKX1lbHNlIGlmKGR8fGEuaXNab29tV2hlZWxFdmVudChiKSlmb3IoZD1teEV2ZW50LmdldFNvdXJjZShiKTtudWxsIT1kOyl7aWYoZD09YS5jb250YWluZXIpcmV0dXJuIGEudG9vbHRpcEhhbmRsZXIuaGlkZVRvb2x0aXAoKSxKPW5ldyBteFBvaW50KG14RXZlbnQuZ2V0Q2xpZW50WChiKSxteEV2ZW50LmdldENsaWVudFkoYikpLGEubGF6eVpvb20oZSksCm14RXZlbnQuY29uc3VtZShiKSwhMTtkPWQucGFyZW50Tm9kZX19KSxhLmNvbnRhaW5lcik7YS5wYW5uaW5nSGFuZGxlci56b29tR3JhcGg9ZnVuY3Rpb24oYil7YS5jdW11bGF0aXZlWm9vbUZhY3Rvcj1iLnNjYWxlO2EubGF6eVpvb20oMDxiLnNjYWxlLCEwKTtteEV2ZW50LmNvbnN1bWUoYil9fTtFZGl0b3JVaS5wcm90b3R5cGUuYWRkQ2hyb21lbGVzc1Rvb2xiYXJJdGVtcz1mdW5jdGlvbihhKXthKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuYWN0aW9ucy5nZXQoInByaW50IikuZnVuY3QoKTtteEV2ZW50LmNvbnN1bWUoYSl9KSxFZGl0b3IucHJpbnRMYXJnZUltYWdlLG14UmVzb3VyY2VzLmdldCgicHJpbnQiKSl9OwpFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlVGVtcG9yYXJ5R3JhcGg9ZnVuY3Rpb24oYSl7YT1uZXcgR3JhcGgoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2IiksbnVsbCxudWxsLGEpO2EucmVzZXRWaWV3T25Sb290Q2hhbmdlPSExO2Euc2V0Q29ubmVjdGFibGUoITEpO2EuZ3JpZEVuYWJsZWQ9ITE7YS5hdXRvU2Nyb2xsPSExO2Euc2V0VG9vbHRpcHMoITEpO2Euc2V0RW5hYmxlZCghMSk7YS5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIjthLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO2EuY29udGFpbmVyLnN0eWxlLm92ZXJmbG93PSJoaWRkZW4iO2EuY29udGFpbmVyLnN0eWxlLmhlaWdodD0iMXB4IjthLmNvbnRhaW5lci5zdHlsZS53aWR0aD0iMXB4IjtyZXR1cm4gYX07CkVkaXRvclVpLnByb3RvdHlwZS5hZGRDaHJvbWVsZXNzQ2xpY2tIYW5kbGVyPWZ1bmN0aW9uKCl7dmFyIGE9dXJsUGFyYW1zLmhpZ2hsaWdodDtudWxsIT1hJiYwPGEubGVuZ3RoJiYoYT0iIyIrYSk7dGhpcy5lZGl0b3IuZ3JhcGguYWRkQ2xpY2tIYW5kbGVyKGEpfTtFZGl0b3JVaS5wcm90b3R5cGUudG9nZ2xlRm9ybWF0UGFuZWw9ZnVuY3Rpb24oYSl7YT1udWxsIT1hP2E6MD09dGhpcy5mb3JtYXRXaWR0aDtudWxsIT10aGlzLmZvcm1hdCYmKHRoaXMuZm9ybWF0V2lkdGg9YT8yNDA6MCx0aGlzLmZvcm1hdENvbnRhaW5lci5zdHlsZS5kaXNwbGF5PWE/IiI6Im5vbmUiLHRoaXMucmVmcmVzaCgpLHRoaXMuZm9ybWF0LnJlZnJlc2goKSx0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgiZm9ybWF0V2lkdGhDaGFuZ2VkIikpKX07CkVkaXRvclVpLnByb3RvdHlwZS5saWdodGJveEZpdD1mdW5jdGlvbihhKXtpZih0aGlzLmlzRGlhZ3JhbUVtcHR5KCkpdGhpcy5lZGl0b3IuZ3JhcGgudmlldy5zZXRTY2FsZSgxKTtlbHNle3ZhciBjPXVybFBhcmFtcy5ib3JkZXIsZj02MDtudWxsIT1jJiYoZj1wYXJzZUludChjKSk7dGhpcy5lZGl0b3IuZ3JhcGgubWF4Rml0U2NhbGU9dGhpcy5saWdodGJveE1heEZpdFNjYWxlO3RoaXMuZWRpdG9yLmdyYXBoLmZpdChmLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxhKTt0aGlzLmVkaXRvci5ncmFwaC5tYXhGaXRTY2FsZT1udWxsfX07RWRpdG9yVWkucHJvdG90eXBlLmlzRGlhZ3JhbUVtcHR5PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lZGl0b3IuZ3JhcGguZ2V0TW9kZWwoKTtyZXR1cm4gMT09YS5nZXRDaGlsZENvdW50KGEucm9vdCkmJjA9PWEuZ2V0Q2hpbGRDb3VudChhLmdldENoaWxkQXQoYS5yb290LDApKX07CkVkaXRvclVpLnByb3RvdHlwZS5pc1NlbGVjdGlvbkFsbG93ZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIlNFTEVDVCI9PW14RXZlbnQuZ2V0U291cmNlKGEpLm5vZGVOYW1lfHwiSU5QVVQiPT1teEV2ZW50LmdldFNvdXJjZShhKS5ub2RlTmFtZSYmbXhVdGlscy5pc0FuY2VzdG9yTm9kZSh0aGlzLmZvcm1hdENvbnRhaW5lcixteEV2ZW50LmdldFNvdXJjZShhKSl9O0VkaXRvclVpLnByb3RvdHlwZS5hZGRCZWZvcmVVbmxvYWRMaXN0ZW5lcj1mdW5jdGlvbigpe3dpbmRvdy5vbmJlZm9yZXVubG9hZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2lmKCF0aGlzLmVkaXRvci5pc0Nocm9tZWxlc3NWaWV3KCkpcmV0dXJuIHRoaXMub25CZWZvcmVVbmxvYWQoKX0pfTtFZGl0b3JVaS5wcm90b3R5cGUub25CZWZvcmVVbmxvYWQ9ZnVuY3Rpb24oKXtpZih0aGlzLmVkaXRvci5tb2RpZmllZClyZXR1cm4gbXhSZXNvdXJjZXMuZ2V0KCJhbGxDaGFuZ2VzTG9zdCIpfTsKRWRpdG9yVWkucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24oKXt0cnl7bnVsbCE9d2luZG93Lm9wZW5lciYmbnVsbCE9d2luZG93Lm9wZW5lci5vcGVuRmlsZSYmd2luZG93Lm9wZW5lci5vcGVuRmlsZS5zZXRDb25zdW1lcihteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGMpe3RyeXt2YXIgZj1teFV0aWxzLnBhcnNlWG1sKGEpO3RoaXMuZWRpdG9yLnNldEdyYXBoWG1sKGYuZG9jdW1lbnRFbGVtZW50KTt0aGlzLmVkaXRvci5zZXRNb2RpZmllZCghMSk7dGhpcy5lZGl0b3IudW5kb01hbmFnZXIuY2xlYXIoKTtudWxsIT1jJiYodGhpcy5lZGl0b3Iuc2V0RmlsZW5hbWUoYyksdGhpcy51cGRhdGVEb2N1bWVudFRpdGxlKCkpfWNhdGNoKGQpe214VXRpbHMuYWxlcnQobXhSZXNvdXJjZXMuZ2V0KCJpbnZhbGlkT3JNaXNzaW5nRmlsZSIpKyI6ICIrZC5tZXNzYWdlKX19KSl9Y2F0Y2goYSl7fXRoaXMuZWRpdG9yLmdyYXBoLnZpZXcudmFsaWRhdGUoKTt0aGlzLmVkaXRvci5ncmFwaC5zaXplRGlkQ2hhbmdlKCk7CnRoaXMuZWRpdG9yLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgicmVzZXRHcmFwaFZpZXciKSl9O0VkaXRvclVpLnByb3RvdHlwZS5zZXRDdXJyZW50TWVudT1mdW5jdGlvbihhLGMpe3RoaXMuY3VycmVudE1lbnVFbHQ9Yzt0aGlzLmN1cnJlbnRNZW51PWF9O0VkaXRvclVpLnByb3RvdHlwZS5yZXNldEN1cnJlbnRNZW51PWZ1bmN0aW9uKCl7dGhpcy5jdXJyZW50TWVudT10aGlzLmN1cnJlbnRNZW51RWx0PW51bGx9O0VkaXRvclVpLnByb3RvdHlwZS5oaWRlQ3VycmVudE1lbnU9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmN1cnJlbnRNZW51JiYodGhpcy5jdXJyZW50TWVudS5oaWRlTWVudSgpLHRoaXMucmVzZXRDdXJyZW50TWVudSgpKX07CkVkaXRvclVpLnByb3RvdHlwZS51cGRhdGVEb2N1bWVudFRpdGxlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lZGl0b3IuZ2V0T3JDcmVhdGVGaWxlbmFtZSgpO251bGwhPXRoaXMuZWRpdG9yLmFwcE5hbWUmJihhKz0iIC0gIit0aGlzLmVkaXRvci5hcHBOYW1lKTtkb2N1bWVudC50aXRsZT1hfTtFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlSG92ZXJJY29ucz1mdW5jdGlvbigpe3JldHVybiBuZXcgSG92ZXJJY29ucyh0aGlzLmVkaXRvci5ncmFwaCl9O0VkaXRvclVpLnByb3RvdHlwZS5yZWRvPWZ1bmN0aW9uKCl7dHJ5e3RoaXMuZWRpdG9yLmdyYXBoLmlzRWRpdGluZygpP2RvY3VtZW50LmV4ZWNDb21tYW5kKCJyZWRvIiwhMSxudWxsKTp0aGlzLmVkaXRvci51bmRvTWFuYWdlci5yZWRvKCl9Y2F0Y2goYSl7fX07CkVkaXRvclVpLnByb3RvdHlwZS51bmRvPWZ1bmN0aW9uKCl7dHJ5e3ZhciBhPXRoaXMuZWRpdG9yLmdyYXBoO2lmKGEuaXNFZGl0aW5nKCkpe3ZhciBjPWEuY2VsbEVkaXRvci50ZXh0YXJlYS5pbm5lckhUTUw7ZG9jdW1lbnQuZXhlY0NvbW1hbmQoInVuZG8iLCExLG51bGwpO2M9PWEuY2VsbEVkaXRvci50ZXh0YXJlYS5pbm5lckhUTUwmJihhLnN0b3BFZGl0aW5nKCEwKSx0aGlzLmVkaXRvci51bmRvTWFuYWdlci51bmRvKCkpfWVsc2UgdGhpcy5lZGl0b3IudW5kb01hbmFnZXIudW5kbygpfWNhdGNoKGYpe319O0VkaXRvclVpLnByb3RvdHlwZS5jYW5SZWRvPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRpdG9yLmdyYXBoLmlzRWRpdGluZygpfHx0aGlzLmVkaXRvci51bmRvTWFuYWdlci5jYW5SZWRvKCl9O0VkaXRvclVpLnByb3RvdHlwZS5jYW5VbmRvPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRpdG9yLmdyYXBoLmlzRWRpdGluZygpfHx0aGlzLmVkaXRvci51bmRvTWFuYWdlci5jYW5VbmRvKCl9OwpFZGl0b3JVaS5wcm90b3R5cGUuZ2V0RWRpdEJsYW5rWG1sPWZ1bmN0aW9uKCl7cmV0dXJuIG14VXRpbHMuZ2V0WG1sKHRoaXMuZWRpdG9yLmdldEdyYXBoWG1sKCkpfTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0VXJsPWZ1bmN0aW9uKGEpe2E9bnVsbCE9YT9hOndpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTt2YXIgYz0wPGEuaW5kZXhPZigiPyIpPzE6MCxmO2ZvcihmIGluIHVybFBhcmFtcylhPTA9PWM/YSsiPyI6YSsiJiIsYSs9ZisiPSIrdXJsUGFyYW1zW2ZdLGMrKztyZXR1cm4gYX07CkVkaXRvclVpLnByb3RvdHlwZS5zZXRTY3JvbGxiYXJzPWZ1bmN0aW9uKGEpe3ZhciBjPXRoaXMuZWRpdG9yLmdyYXBoLGY9Yy5jb250YWluZXIuc3R5bGUub3ZlcmZsb3c7Yy5zY3JvbGxiYXJzPWE7dGhpcy5lZGl0b3IudXBkYXRlR3JhcGhDb21wb25lbnRzKCk7ZiE9Yy5jb250YWluZXIuc3R5bGUub3ZlcmZsb3cmJihjLmNvbnRhaW5lci5zY3JvbGxUb3A9MCxjLmNvbnRhaW5lci5zY3JvbGxMZWZ0PTAsYy52aWV3LnNjYWxlQW5kVHJhbnNsYXRlKDEsMCwwKSx0aGlzLnJlc2V0U2Nyb2xsYmFycygpKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgic2Nyb2xsYmFyc0NoYW5nZWQiKSl9O0VkaXRvclVpLnByb3RvdHlwZS5oYXNTY3JvbGxiYXJzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRpdG9yLmdyYXBoLnNjcm9sbGJhcnN9OwpFZGl0b3JVaS5wcm90b3R5cGUucmVzZXRTY3JvbGxiYXJzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lZGl0b3IuZ3JhcGg7aWYoIXRoaXMuZWRpdG9yLmV4dGVuZENhbnZhcylhLmNvbnRhaW5lci5zY3JvbGxUb3A9MCxhLmNvbnRhaW5lci5zY3JvbGxMZWZ0PTAsbXhVdGlscy5oYXNTY3JvbGxiYXJzKGEuY29udGFpbmVyKXx8YS52aWV3LnNldFRyYW5zbGF0ZSgwLDApO2Vsc2UgaWYoIXRoaXMuZWRpdG9yLmlzQ2hyb21lbGVzc1ZpZXcoKSlpZihteFV0aWxzLmhhc1Njcm9sbGJhcnMoYS5jb250YWluZXIpKWlmKGEucGFnZVZpc2libGUpe3ZhciBjPWEuZ2V0UGFnZVBhZGRpbmcoKTthLmNvbnRhaW5lci5zY3JvbGxUb3A9TWF0aC5mbG9vcihjLnktdGhpcy5lZGl0b3IuaW5pdGlhbFRvcFNwYWNpbmcpLTE7YS5jb250YWluZXIuc2Nyb2xsTGVmdD1NYXRoLmZsb29yKE1hdGgubWluKGMueCwoYS5jb250YWluZXIuc2Nyb2xsV2lkdGgtYS5jb250YWluZXIuY2xpZW50V2lkdGgpLzIpKS0KMTtjPWEuZ2V0R3JhcGhCb3VuZHMoKTswPGMud2lkdGgmJjA8Yy5oZWlnaHQmJihjLng+YS5jb250YWluZXIuc2Nyb2xsTGVmdCsuOSphLmNvbnRhaW5lci5jbGllbnRXaWR0aCYmKGEuY29udGFpbmVyLnNjcm9sbExlZnQ9TWF0aC5taW4oYy54K2Mud2lkdGgtYS5jb250YWluZXIuY2xpZW50V2lkdGgsYy54LTEwKSksYy55PmEuY29udGFpbmVyLnNjcm9sbFRvcCsuOSphLmNvbnRhaW5lci5jbGllbnRIZWlnaHQmJihhLmNvbnRhaW5lci5zY3JvbGxUb3A9TWF0aC5taW4oYy55K2MuaGVpZ2h0LWEuY29udGFpbmVyLmNsaWVudEhlaWdodCxjLnktMTApKSl9ZWxzZXt2YXIgYz1hLmdldEdyYXBoQm91bmRzKCksZj1NYXRoLm1heChjLndpZHRoLGEuc2Nyb2xsVGlsZVNpemUud2lkdGgqYS52aWV3LnNjYWxlKTthLmNvbnRhaW5lci5zY3JvbGxUb3A9TWF0aC5mbG9vcihNYXRoLm1heCgwLGMueS1NYXRoLm1heCgyMCwoYS5jb250YWluZXIuY2xpZW50SGVpZ2h0LU1hdGgubWF4KGMuaGVpZ2h0LAphLnNjcm9sbFRpbGVTaXplLmhlaWdodCphLnZpZXcuc2NhbGUpKS80KSkpO2EuY29udGFpbmVyLnNjcm9sbExlZnQ9TWF0aC5mbG9vcihNYXRoLm1heCgwLGMueC1NYXRoLm1heCgwLChhLmNvbnRhaW5lci5jbGllbnRXaWR0aC1mKS8yKSkpfWVsc2V7dmFyIGM9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShhLnBhZ2VWaXNpYmxlP2Eudmlldy5nZXRCYWNrZ3JvdW5kUGFnZUJvdW5kcygpOmEuZ2V0R3JhcGhCb3VuZHMoKSksZj1hLnZpZXcudHJhbnNsYXRlLGQ9YS52aWV3LnNjYWxlO2MueD1jLngvZC1mLng7Yy55PWMueS9kLWYueTtjLndpZHRoLz1kO2MuaGVpZ2h0Lz1kO2Eudmlldy5zZXRUcmFuc2xhdGUoTWF0aC5mbG9vcihNYXRoLm1heCgwLChhLmNvbnRhaW5lci5jbGllbnRXaWR0aC1jLndpZHRoKS8yKS1jLngrMiksTWF0aC5mbG9vcigoYS5wYWdlVmlzaWJsZT8wOk1hdGgubWF4KDAsKGEuY29udGFpbmVyLmNsaWVudEhlaWdodC1jLmhlaWdodCkvNCkpLWMueSsxKSl9fTsKRWRpdG9yVWkucHJvdG90eXBlLnNldFBhZ2VWaXNpYmxlPWZ1bmN0aW9uKGEpe3ZhciBjPXRoaXMuZWRpdG9yLmdyYXBoLGY9bXhVdGlscy5oYXNTY3JvbGxiYXJzKGMuY29udGFpbmVyKSxkPTAsbT0wO2YmJihkPWMudmlldy50cmFuc2xhdGUueCpjLnZpZXcuc2NhbGUtYy5jb250YWluZXIuc2Nyb2xsTGVmdCxtPWMudmlldy50cmFuc2xhdGUueSpjLnZpZXcuc2NhbGUtYy5jb250YWluZXIuc2Nyb2xsVG9wKTtjLnBhZ2VWaXNpYmxlPWE7Yy5wYWdlQnJlYWtzVmlzaWJsZT1hO2MucHJlZmVyUGFnZVNpemU9YTtjLnZpZXcudmFsaWRhdGVCYWNrZ3JvdW5kKCk7ZiYmKGE9Yy5nZXRTZWxlY3Rpb25DZWxscygpLGMuY2xlYXJTZWxlY3Rpb24oKSxjLnNldFNlbGVjdGlvbkNlbGxzKGEpKTtjLnNpemVEaWRDaGFuZ2UoKTtmJiYoYy5jb250YWluZXIuc2Nyb2xsTGVmdD1jLnZpZXcudHJhbnNsYXRlLngqYy52aWV3LnNjYWxlLWQsYy5jb250YWluZXIuc2Nyb2xsVG9wPWMudmlldy50cmFuc2xhdGUueSoKYy52aWV3LnNjYWxlLW0pO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJwYWdlVmlld0NoYW5nZWQiKSl9O2Z1bmN0aW9uIENoYW5nZVBhZ2VTZXR1cChhLGMsZixkLG0pe3RoaXMudWk9YTt0aGlzLnByZXZpb3VzQ29sb3I9dGhpcy5jb2xvcj1jO3RoaXMucHJldmlvdXNJbWFnZT10aGlzLmltYWdlPWY7dGhpcy5wcmV2aW91c0Zvcm1hdD10aGlzLmZvcm1hdD1kO3RoaXMucHJldmlvdXNQYWdlU2NhbGU9dGhpcy5wYWdlU2NhbGU9bTt0aGlzLmlnbm9yZUltYWdlPXRoaXMuaWdub3JlQ29sb3I9ITF9CkNoYW5nZVBhZ2VTZXR1cC5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMudWkuZWRpdG9yLmdyYXBoO2lmKCF0aGlzLmlnbm9yZUNvbG9yKXt0aGlzLmNvbG9yPXRoaXMucHJldmlvdXNDb2xvcjt2YXIgYz1hLmJhY2tncm91bmQ7dGhpcy51aS5zZXRCYWNrZ3JvdW5kQ29sb3IodGhpcy5wcmV2aW91c0NvbG9yKTt0aGlzLnByZXZpb3VzQ29sb3I9Y310aGlzLmlnbm9yZUltYWdlfHwodGhpcy5pbWFnZT10aGlzLnByZXZpb3VzSW1hZ2UsYz1hLmJhY2tncm91bmRJbWFnZSx0aGlzLnVpLnNldEJhY2tncm91bmRJbWFnZSh0aGlzLnByZXZpb3VzSW1hZ2UpLHRoaXMucHJldmlvdXNJbWFnZT1jKTtudWxsIT10aGlzLnByZXZpb3VzRm9ybWF0JiYodGhpcy5mb3JtYXQ9dGhpcy5wcmV2aW91c0Zvcm1hdCxjPWEucGFnZUZvcm1hdCx0aGlzLnByZXZpb3VzRm9ybWF0LndpZHRoIT1jLndpZHRofHx0aGlzLnByZXZpb3VzRm9ybWF0LmhlaWdodCE9Yy5oZWlnaHQpJiYodGhpcy51aS5zZXRQYWdlRm9ybWF0KHRoaXMucHJldmlvdXNGb3JtYXQpLAp0aGlzLnByZXZpb3VzRm9ybWF0PWMpO251bGwhPXRoaXMuZm9sZGluZ0VuYWJsZWQmJnRoaXMuZm9sZGluZ0VuYWJsZWQhPXRoaXMudWkuZWRpdG9yLmdyYXBoLmZvbGRpbmdFbmFibGVkJiYodGhpcy51aS5zZXRGb2xkaW5nRW5hYmxlZCh0aGlzLmZvbGRpbmdFbmFibGVkKSx0aGlzLmZvbGRpbmdFbmFibGVkPSF0aGlzLmZvbGRpbmdFbmFibGVkKTtudWxsIT10aGlzLnByZXZpb3VzUGFnZVNjYWxlJiYoYT10aGlzLnVpLmVkaXRvci5ncmFwaC5wYWdlU2NhbGUsdGhpcy5wcmV2aW91c1BhZ2VTY2FsZSE9YSYmKHRoaXMudWkuc2V0UGFnZVNjYWxlKHRoaXMucHJldmlvdXNQYWdlU2NhbGUpLHRoaXMucHJldmlvdXNQYWdlU2NhbGU9YSkpfTsKKGZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14T2JqZWN0Q29kZWMobmV3IENoYW5nZVBhZ2VTZXR1cCxbInVpIiwicHJldmlvdXNDb2xvciIsInByZXZpb3VzSW1hZ2UiLCJwcmV2aW91c0Zvcm1hdCIsInByZXZpb3VzUGFnZVNjYWxlIl0pO2EuYWZ0ZXJEZWNvZGU9ZnVuY3Rpb24oYSxmLGQpe2QucHJldmlvdXNDb2xvcj1kLmNvbG9yO2QucHJldmlvdXNJbWFnZT1kLmltYWdlO2QucHJldmlvdXNGb3JtYXQ9ZC5mb3JtYXQ7ZC5wcmV2aW91c1BhZ2VTY2FsZT1kLnBhZ2VTY2FsZTtudWxsIT1kLmZvbGRpbmdFbmFibGVkJiYoZC5mb2xkaW5nRW5hYmxlZD0hZC5mb2xkaW5nRW5hYmxlZCk7cmV0dXJuIGR9O214Q29kZWNSZWdpc3RyeS5yZWdpc3RlcihhKX0pKCk7RWRpdG9yVWkucHJvdG90eXBlLnNldEJhY2tncm91bmRDb2xvcj1mdW5jdGlvbihhKXt0aGlzLmVkaXRvci5ncmFwaC5iYWNrZ3JvdW5kPWE7dGhpcy5lZGl0b3IuZ3JhcGgudmlldy52YWxpZGF0ZUJhY2tncm91bmQoKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgiYmFja2dyb3VuZENvbG9yQ2hhbmdlZCIpKX07CkVkaXRvclVpLnByb3RvdHlwZS5zZXRGb2xkaW5nRW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLmVkaXRvci5ncmFwaC5mb2xkaW5nRW5hYmxlZD1hO3RoaXMuZWRpdG9yLmdyYXBoLnZpZXcucmV2YWxpZGF0ZSgpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJmb2xkaW5nRW5hYmxlZENoYW5nZWQiKSl9O0VkaXRvclVpLnByb3RvdHlwZS5zZXRQYWdlRm9ybWF0PWZ1bmN0aW9uKGEpe3RoaXMuZWRpdG9yLmdyYXBoLnBhZ2VGb3JtYXQ9YTt0aGlzLmVkaXRvci5ncmFwaC5wYWdlVmlzaWJsZT8odGhpcy5lZGl0b3IuZ3JhcGgudmlldy52YWxpZGF0ZUJhY2tncm91bmQoKSx0aGlzLmVkaXRvci5ncmFwaC5zaXplRGlkQ2hhbmdlKCkpOnRoaXMuYWN0aW9ucy5nZXQoInBhZ2VWaWV3IikuZnVuY3QoKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgicGFnZUZvcm1hdENoYW5nZWQiKSl9OwpFZGl0b3JVaS5wcm90b3R5cGUuc2V0UGFnZVNjYWxlPWZ1bmN0aW9uKGEpe3RoaXMuZWRpdG9yLmdyYXBoLnBhZ2VTY2FsZT1hO3RoaXMuZWRpdG9yLmdyYXBoLnBhZ2VWaXNpYmxlPyh0aGlzLmVkaXRvci5ncmFwaC52aWV3LnZhbGlkYXRlQmFja2dyb3VuZCgpLHRoaXMuZWRpdG9yLmdyYXBoLnNpemVEaWRDaGFuZ2UoKSk6dGhpcy5hY3Rpb25zLmdldCgicGFnZVZpZXciKS5mdW5jdCgpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJwYWdlU2NhbGVDaGFuZ2VkIikpfTtFZGl0b3JVaS5wcm90b3R5cGUuc2V0R3JpZENvbG9yPWZ1bmN0aW9uKGEpe3RoaXMuZWRpdG9yLmdyYXBoLnZpZXcuZ3JpZENvbG9yPWE7dGhpcy5lZGl0b3IuZ3JhcGgudmlldy52YWxpZGF0ZUJhY2tncm91bmQoKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgiZ3JpZENvbG9yQ2hhbmdlZCIpKX07CkVkaXRvclVpLnByb3RvdHlwZS5hZGRVbmRvTGlzdGVuZXI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmFjdGlvbnMuZ2V0KCJ1bmRvIiksYz10aGlzLmFjdGlvbnMuZ2V0KCJyZWRvIiksZj10aGlzLmVkaXRvci51bmRvTWFuYWdlcixkPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7YS5zZXRFbmFibGVkKHRoaXMuY2FuVW5kbygpKTtjLnNldEVuYWJsZWQodGhpcy5jYW5SZWRvKCkpfSk7Zi5hZGRMaXN0ZW5lcihteEV2ZW50LkFERCxkKTtmLmFkZExpc3RlbmVyKG14RXZlbnQuVU5ETyxkKTtmLmFkZExpc3RlbmVyKG14RXZlbnQuUkVETyxkKTtmLmFkZExpc3RlbmVyKG14RXZlbnQuQ0xFQVIsZCk7dmFyIG09dGhpcy5lZGl0b3IuZ3JhcGguY2VsbEVkaXRvci5zdGFydEVkaXRpbmc7dGhpcy5lZGl0b3IuZ3JhcGguY2VsbEVkaXRvci5zdGFydEVkaXRpbmc9ZnVuY3Rpb24oKXttLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtkKCl9O3ZhciBrPXRoaXMuZWRpdG9yLmdyYXBoLmNlbGxFZGl0b3Iuc3RvcEVkaXRpbmc7CnRoaXMuZWRpdG9yLmdyYXBoLmNlbGxFZGl0b3Iuc3RvcEVkaXRpbmc9ZnVuY3Rpb24oYSxiKXtrLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtkKCl9O2QoKX07CkVkaXRvclVpLnByb3RvdHlwZS51cGRhdGVBY3Rpb25TdGF0ZXM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmVkaXRvci5ncmFwaCxjPSFhLmlzU2VsZWN0aW9uRW1wdHkoKSxmPSExLGQ9ITEsbT1hLmdldFNlbGVjdGlvbkNlbGxzKCk7aWYobnVsbCE9bSlmb3IodmFyIGs9MDtrPG0ubGVuZ3RoO2srKyl7dmFyIHE9bVtrXTthLmdldE1vZGVsKCkuaXNFZGdlKHEpJiYoZD0hMCk7YS5nZXRNb2RlbCgpLmlzVmVydGV4KHEpJiYoZj0hMCk7aWYoZCYmZilicmVha31tPSJjdXQgY29weSBib2xkIGl0YWxpYyB1bmRlcmxpbmUgZGVsZXRlIGR1cGxpY2F0ZSBlZGl0U3R5bGUgZWRpdFRvb2x0aXAgZWRpdExpbmsgYmFja2dyb3VuZENvbG9yIGJvcmRlckNvbG9yIGVkaXQgdG9Gcm9udCB0b0JhY2sgbG9ja1VubG9jayBzb2xpZCBkYXNoZWQgcGFzdGVTaXplIGRvdHRlZCBmaWxsQ29sb3IgZ3JhZGllbnRDb2xvciBzaGFkb3cgZm9udENvbG9yIGZvcm1hdHRlZFRleHQgcm91bmRlZCB0b2dnbGVSb3VuZGVkIHNoYXJwIHN0cm9rZUNvbG9yIi5zcGxpdCgiICIpO2ZvcihrPQowO2s8bS5sZW5ndGg7aysrKXRoaXMuYWN0aW9ucy5nZXQobVtrXSkuc2V0RW5hYmxlZChjKTt0aGlzLmFjdGlvbnMuZ2V0KCJzZXRBc0RlZmF1bHRTdHlsZSIpLnNldEVuYWJsZWQoMT09YS5nZXRTZWxlY3Rpb25Db3VudCgpKTt0aGlzLmFjdGlvbnMuZ2V0KCJjbGVhcldheXBvaW50cyIpLnNldEVuYWJsZWQoIWEuaXNTZWxlY3Rpb25FbXB0eSgpKTt0aGlzLmFjdGlvbnMuZ2V0KCJjb3B5U2l6ZSIpLnNldEVuYWJsZWQoMT09YS5nZXRTZWxlY3Rpb25Db3VudCgpKTt0aGlzLmFjdGlvbnMuZ2V0KCJ0dXJuIikuc2V0RW5hYmxlZCghYS5pc1NlbGVjdGlvbkVtcHR5KCkpO3RoaXMuYWN0aW9ucy5nZXQoImN1cnZlZCIpLnNldEVuYWJsZWQoZCk7dGhpcy5hY3Rpb25zLmdldCgicm90YXRpb24iKS5zZXRFbmFibGVkKGYpO3RoaXMuYWN0aW9ucy5nZXQoIndvcmRXcmFwIikuc2V0RW5hYmxlZChmKTt0aGlzLmFjdGlvbnMuZ2V0KCJhdXRvc2l6ZSIpLnNldEVuYWJsZWQoZik7ZD1mJiYxPT0KYS5nZXRTZWxlY3Rpb25Db3VudCgpO3RoaXMuYWN0aW9ucy5nZXQoImdyb3VwIikuc2V0RW5hYmxlZCgxPGEuZ2V0U2VsZWN0aW9uQ291bnQoKXx8ZCYmIWEuaXNDb250YWluZXIoYS5nZXRTZWxlY3Rpb25DZWxsKCkpKTt0aGlzLmFjdGlvbnMuZ2V0KCJ1bmdyb3VwIikuc2V0RW5hYmxlZCgxPT1hLmdldFNlbGVjdGlvbkNvdW50KCkmJigwPGEuZ2V0TW9kZWwoKS5nZXRDaGlsZENvdW50KGEuZ2V0U2VsZWN0aW9uQ2VsbCgpKXx8ZCYmYS5pc0NvbnRhaW5lcihhLmdldFNlbGVjdGlvbkNlbGwoKSkpKTt0aGlzLmFjdGlvbnMuZ2V0KCJyZW1vdmVGcm9tR3JvdXAiKS5zZXRFbmFibGVkKGQmJmEuZ2V0TW9kZWwoKS5pc1ZlcnRleChhLmdldE1vZGVsKCkuZ2V0UGFyZW50KGEuZ2V0U2VsZWN0aW9uQ2VsbCgpKSkpO2Eudmlldy5nZXRTdGF0ZShhLmdldFNlbGVjdGlvbkNlbGwoKSk7dGhpcy5tZW51cy5nZXQoIm5hdmlnYXRpb24iKS5zZXRFbmFibGVkKGN8fG51bGwhPWEudmlldy5jdXJyZW50Um9vdCk7CnRoaXMuYWN0aW9ucy5nZXQoImNvbGxhcHNpYmxlIikuc2V0RW5hYmxlZChmJiYoYS5pc0NvbnRhaW5lcihhLmdldFNlbGVjdGlvbkNlbGwoKSl8fDA8YS5tb2RlbC5nZXRDaGlsZENvdW50KGEuZ2V0U2VsZWN0aW9uQ2VsbCgpKSkpO3RoaXMuYWN0aW9ucy5nZXQoImhvbWUiKS5zZXRFbmFibGVkKG51bGwhPWEudmlldy5jdXJyZW50Um9vdCk7dGhpcy5hY3Rpb25zLmdldCgiZXhpdEdyb3VwIikuc2V0RW5hYmxlZChudWxsIT1hLnZpZXcuY3VycmVudFJvb3QpO3RoaXMuYWN0aW9ucy5nZXQoImVudGVyR3JvdXAiKS5zZXRFbmFibGVkKDE9PWEuZ2V0U2VsZWN0aW9uQ291bnQoKSYmYS5pc1ZhbGlkUm9vdChhLmdldFNlbGVjdGlvbkNlbGwoKSkpO2M9MT09YS5nZXRTZWxlY3Rpb25Db3VudCgpJiZhLmlzQ2VsbEZvbGRhYmxlKGEuZ2V0U2VsZWN0aW9uQ2VsbCgpKTt0aGlzLmFjdGlvbnMuZ2V0KCJleHBhbmQiKS5zZXRFbmFibGVkKGMpO3RoaXMuYWN0aW9ucy5nZXQoImNvbGxhcHNlIikuc2V0RW5hYmxlZChjKTsKdGhpcy5hY3Rpb25zLmdldCgiZWRpdExpbmsiKS5zZXRFbmFibGVkKDE9PWEuZ2V0U2VsZWN0aW9uQ291bnQoKSk7dGhpcy5hY3Rpb25zLmdldCgib3BlbkxpbmsiKS5zZXRFbmFibGVkKDE9PWEuZ2V0U2VsZWN0aW9uQ291bnQoKSYmbnVsbCE9YS5nZXRMaW5rRm9yQ2VsbChhLmdldFNlbGVjdGlvbkNlbGwoKSkpO3RoaXMuYWN0aW9ucy5nZXQoImd1aWRlcyIpLnNldEVuYWJsZWQoYS5pc0VuYWJsZWQoKSk7dGhpcy5hY3Rpb25zLmdldCgiZ3JpZCIpLnNldEVuYWJsZWQoIXRoaXMuZWRpdG9yLmNocm9tZWxlc3N8fHRoaXMuZWRpdG9yLmVkaXRhYmxlKTtjPWEuaXNFbmFibGVkKCkmJiFhLmlzQ2VsbExvY2tlZChhLmdldERlZmF1bHRQYXJlbnQoKSk7dGhpcy5tZW51cy5nZXQoImxheW91dCIpLnNldEVuYWJsZWQoYyk7dGhpcy5tZW51cy5nZXQoImluc2VydCIpLnNldEVuYWJsZWQoYyk7dGhpcy5tZW51cy5nZXQoImRpcmVjdGlvbiIpLnNldEVuYWJsZWQoYyYmZik7dGhpcy5tZW51cy5nZXQoImFsaWduIikuc2V0RW5hYmxlZChjJiYKZiYmMTxhLmdldFNlbGVjdGlvbkNvdW50KCkpO3RoaXMubWVudXMuZ2V0KCJkaXN0cmlidXRlIikuc2V0RW5hYmxlZChjJiZmJiYxPGEuZ2V0U2VsZWN0aW9uQ291bnQoKSk7dGhpcy5hY3Rpb25zLmdldCgic2VsZWN0VmVydGljZXMiKS5zZXRFbmFibGVkKGMpO3RoaXMuYWN0aW9ucy5nZXQoInNlbGVjdEVkZ2VzIikuc2V0RW5hYmxlZChjKTt0aGlzLmFjdGlvbnMuZ2V0KCJzZWxlY3RBbGwiKS5zZXRFbmFibGVkKGMpO3RoaXMuYWN0aW9ucy5nZXQoInNlbGVjdE5vbmUiKS5zZXRFbmFibGVkKGMpO3RoaXMudXBkYXRlUGFzdGVBY3Rpb25TdGF0ZXMoKX07RWRpdG9yVWkucHJvdG90eXBlLnplcm9PZmZzZXQ9bmV3IG14UG9pbnQoMCwwKTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0RGlhZ3JhbUNvbnRhaW5lck9mZnNldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnplcm9PZmZzZXR9OwpFZGl0b3JVaS5wcm90b3R5cGUucmVmcmVzaD1mdW5jdGlvbihhKXthPW51bGwhPWE/YTohMDt2YXIgYz1teENsaWVudC5JU19JRSYmKG51bGw9PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8NT09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSxmPXRoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoLGQ9dGhpcy5jb250YWluZXIuY2xpZW50SGVpZ2h0O3RoaXMuY29udGFpbmVyPT1kb2N1bWVudC5ib2R5JiYoZj1kb2N1bWVudC5ib2R5LmNsaWVudFdpZHRofHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsZD1jP2RvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0OmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpO3ZhciBtPTA7bXhDbGllbnQuSVNfSU9TJiYhd2luZG93Lm5hdmlnYXRvci5zdGFuZGFsb25lJiZ3aW5kb3cuaW5uZXJIZWlnaHQhPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQmJgoobT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LXdpbmRvdy5pbm5lckhlaWdodCx3aW5kb3cuc2Nyb2xsVG8oMCwwKSk7dmFyIGs9TWF0aC5tYXgoMCxNYXRoLm1pbih0aGlzLmhzcGxpdFBvc2l0aW9uLGYtdGhpcy5zcGxpdFNpemUtMjApKSxxPTA7bnVsbCE9dGhpcy5tZW51YmFyJiYodGhpcy5tZW51YmFyQ29udGFpbmVyLnN0eWxlLmhlaWdodD10aGlzLm1lbnViYXJIZWlnaHQrInB4IixxKz10aGlzLm1lbnViYXJIZWlnaHQpO251bGwhPXRoaXMudG9vbGJhciYmKHRoaXMudG9vbGJhckNvbnRhaW5lci5zdHlsZS50b3A9dGhpcy5tZW51YmFySGVpZ2h0KyJweCIsdGhpcy50b29sYmFyQ29udGFpbmVyLnN0eWxlLmhlaWdodD10aGlzLnRvb2xiYXJIZWlnaHQrInB4IixxKz10aGlzLnRvb2xiYXJIZWlnaHQpOzA8cSYmIW14Q2xpZW50LklTX1FVSVJLUyYmKHErPTEpO3ZhciBiPTA7aWYobnVsbCE9dGhpcy5zaWRlYmFyRm9vdGVyQ29udGFpbmVyKXt2YXIgZT0KdGhpcy5mb290ZXJIZWlnaHQrbSxiPU1hdGgubWF4KDAsTWF0aC5taW4oZC1xLWUsdGhpcy5zaWRlYmFyRm9vdGVySGVpZ2h0KSk7dGhpcy5zaWRlYmFyRm9vdGVyQ29udGFpbmVyLnN0eWxlLndpZHRoPWsrInB4Ijt0aGlzLnNpZGViYXJGb290ZXJDb250YWluZXIuc3R5bGUuaGVpZ2h0PWIrInB4Ijt0aGlzLnNpZGViYXJGb290ZXJDb250YWluZXIuc3R5bGUuYm90dG9tPWUrInB4In1lPW51bGwhPXRoaXMuZm9ybWF0P3RoaXMuZm9ybWF0V2lkdGg6MDt0aGlzLnNpZGViYXJDb250YWluZXIuc3R5bGUudG9wPXErInB4Ijt0aGlzLnNpZGViYXJDb250YWluZXIuc3R5bGUud2lkdGg9aysicHgiO3RoaXMuZm9ybWF0Q29udGFpbmVyLnN0eWxlLnRvcD1xKyJweCI7dGhpcy5mb3JtYXRDb250YWluZXIuc3R5bGUud2lkdGg9ZSsicHgiO3RoaXMuZm9ybWF0Q29udGFpbmVyLnN0eWxlLmRpc3BsYXk9bnVsbCE9dGhpcy5mb3JtYXQ/IiI6Im5vbmUiO3ZhciBnPXRoaXMuZ2V0RGlhZ3JhbUNvbnRhaW5lck9mZnNldCgpLApwPW51bGwhPXRoaXMuaHNwbGl0LnBhcmVudE5vZGU/ayt0aGlzLnNwbGl0U2l6ZTowO3RoaXMuZGlhZ3JhbUNvbnRhaW5lci5zdHlsZS5sZWZ0PXArZy54KyJweCI7dGhpcy5kaWFncmFtQ29udGFpbmVyLnN0eWxlLnRvcD1xK2cueSsicHgiO3RoaXMuZm9vdGVyQ29udGFpbmVyLnN0eWxlLmhlaWdodD10aGlzLmZvb3RlckhlaWdodCsicHgiO3RoaXMuaHNwbGl0LnN0eWxlLnRvcD10aGlzLnNpZGViYXJDb250YWluZXIuc3R5bGUudG9wO3RoaXMuaHNwbGl0LnN0eWxlLmJvdHRvbT10aGlzLmZvb3RlckhlaWdodCttKyJweCI7dGhpcy5oc3BsaXQuc3R5bGUubGVmdD1rKyJweCI7dGhpcy5mb290ZXJDb250YWluZXIuc3R5bGUuZGlzcGxheT0wPT10aGlzLmZvb3RlckhlaWdodD8ibm9uZSI6IiI7bnVsbCE9dGhpcy50YWJDb250YWluZXImJih0aGlzLnRhYkNvbnRhaW5lci5zdHlsZS5sZWZ0PXArInB4Iik7Yz8odGhpcy5tZW51YmFyQ29udGFpbmVyLnN0eWxlLndpZHRoPWYrInB4IiwKdGhpcy50b29sYmFyQ29udGFpbmVyLnN0eWxlLndpZHRoPXRoaXMubWVudWJhckNvbnRhaW5lci5zdHlsZS53aWR0aCxjPU1hdGgubWF4KDAsZC10aGlzLmZvb3RlckhlaWdodC10aGlzLm1lbnViYXJIZWlnaHQtdGhpcy50b29sYmFySGVpZ2h0KSx0aGlzLnNpZGViYXJDb250YWluZXIuc3R5bGUuaGVpZ2h0PWMtYisicHgiLHRoaXMuZm9ybWF0Q29udGFpbmVyLnN0eWxlLmhlaWdodD1jKyJweCIsdGhpcy5kaWFncmFtQ29udGFpbmVyLnN0eWxlLndpZHRoPW51bGwhPXRoaXMuaHNwbGl0LnBhcmVudE5vZGU/TWF0aC5tYXgoMCxmLWstdGhpcy5zcGxpdFNpemUtZSkrInB4IjpmKyJweCIsdGhpcy5mb290ZXJDb250YWluZXIuc3R5bGUud2lkdGg9dGhpcy5tZW51YmFyQ29udGFpbmVyLnN0eWxlLndpZHRoLGI9TWF0aC5tYXgoMCxkLXRoaXMuZm9vdGVySGVpZ2h0LXRoaXMubWVudWJhckhlaWdodC10aGlzLnRvb2xiYXJIZWlnaHQpLG51bGwhPXRoaXMudGFiQ29udGFpbmVyJiYodGhpcy50YWJDb250YWluZXIuc3R5bGUud2lkdGg9CnRoaXMuZGlhZ3JhbUNvbnRhaW5lci5zdHlsZS53aWR0aCx0aGlzLnRhYkNvbnRhaW5lci5zdHlsZS5ib3R0b209dGhpcy5mb290ZXJIZWlnaHQrbSsicHgiLGItPXRoaXMudGFiQ29udGFpbmVyLmNsaWVudEhlaWdodCksdGhpcy5kaWFncmFtQ29udGFpbmVyLnN0eWxlLmhlaWdodD1iKyJweCIsdGhpcy5oc3BsaXQuc3R5bGUuaGVpZ2h0PWIrInB4Iik6KDA8dGhpcy5mb290ZXJIZWlnaHQmJih0aGlzLmZvb3RlckNvbnRhaW5lci5zdHlsZS5ib3R0b209bSsicHgiKSx0aGlzLmRpYWdyYW1Db250YWluZXIuc3R5bGUucmlnaHQ9ZSsicHgiLGY9MCxudWxsIT10aGlzLnRhYkNvbnRhaW5lciYmKHRoaXMudGFiQ29udGFpbmVyLnN0eWxlLmJvdHRvbT10aGlzLmZvb3RlckhlaWdodCttKyJweCIsdGhpcy50YWJDb250YWluZXIuc3R5bGUucmlnaHQ9dGhpcy5kaWFncmFtQ29udGFpbmVyLnN0eWxlLnJpZ2h0LGY9dGhpcy50YWJDb250YWluZXIuY2xpZW50SGVpZ2h0KSx0aGlzLnNpZGViYXJDb250YWluZXIuc3R5bGUuYm90dG9tPQp0aGlzLmZvb3RlckhlaWdodCtiK20rInB4Iix0aGlzLmZvcm1hdENvbnRhaW5lci5zdHlsZS5ib3R0b209dGhpcy5mb290ZXJIZWlnaHQrbSsicHgiLHRoaXMuZGlhZ3JhbUNvbnRhaW5lci5zdHlsZS5ib3R0b209dGhpcy5mb290ZXJIZWlnaHQrbStmKyJweCIpO2EmJnRoaXMuZWRpdG9yLmdyYXBoLnNpemVEaWRDaGFuZ2UoKX07RWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZVRhYkNvbnRhaW5lcj1mdW5jdGlvbigpe3JldHVybiBudWxsfTsKRWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZURpdnM9ZnVuY3Rpb24oKXt0aGlzLm1lbnViYXJDb250YWluZXI9dGhpcy5jcmVhdGVEaXYoImdlTWVudWJhckNvbnRhaW5lciIpO3RoaXMudG9vbGJhckNvbnRhaW5lcj10aGlzLmNyZWF0ZURpdigiZ2VUb29sYmFyQ29udGFpbmVyIik7dGhpcy5zaWRlYmFyQ29udGFpbmVyPXRoaXMuY3JlYXRlRGl2KCJnZVNpZGViYXJDb250YWluZXIiKTt0aGlzLmZvcm1hdENvbnRhaW5lcj10aGlzLmNyZWF0ZURpdigiZ2VTaWRlYmFyQ29udGFpbmVyIGdlRm9ybWF0Q29udGFpbmVyIik7dGhpcy5kaWFncmFtQ29udGFpbmVyPXRoaXMuY3JlYXRlRGl2KCJnZURpYWdyYW1Db250YWluZXIiKTt0aGlzLmZvb3RlckNvbnRhaW5lcj10aGlzLmNyZWF0ZURpdigiZ2VGb290ZXJDb250YWluZXIiKTt0aGlzLmhzcGxpdD10aGlzLmNyZWF0ZURpdigiZ2VIc3BsaXQiKTt0aGlzLmhzcGxpdC5zZXRBdHRyaWJ1dGUoInRpdGxlIixteFJlc291cmNlcy5nZXQoImNvbGxhcHNlRXhwYW5kIikpOwp0aGlzLm1lbnViYXJDb250YWluZXIuc3R5bGUudG9wPSIwcHgiO3RoaXMubWVudWJhckNvbnRhaW5lci5zdHlsZS5sZWZ0PSIwcHgiO3RoaXMubWVudWJhckNvbnRhaW5lci5zdHlsZS5yaWdodD0iMHB4Ijt0aGlzLnRvb2xiYXJDb250YWluZXIuc3R5bGUubGVmdD0iMHB4Ijt0aGlzLnRvb2xiYXJDb250YWluZXIuc3R5bGUucmlnaHQ9IjBweCI7dGhpcy5zaWRlYmFyQ29udGFpbmVyLnN0eWxlLmxlZnQ9IjBweCI7dGhpcy5mb3JtYXRDb250YWluZXIuc3R5bGUucmlnaHQ9IjBweCI7dGhpcy5mb3JtYXRDb250YWluZXIuc3R5bGUuekluZGV4PSIxIjt0aGlzLmRpYWdyYW1Db250YWluZXIuc3R5bGUucmlnaHQ9KG51bGwhPXRoaXMuZm9ybWF0P3RoaXMuZm9ybWF0V2lkdGg6MCkrInB4Ijt0aGlzLmZvb3RlckNvbnRhaW5lci5zdHlsZS5sZWZ0PSIwcHgiO3RoaXMuZm9vdGVyQ29udGFpbmVyLnN0eWxlLnJpZ2h0PSIwcHgiO3RoaXMuZm9vdGVyQ29udGFpbmVyLnN0eWxlLmJvdHRvbT0KIjBweCI7dGhpcy5mb290ZXJDb250YWluZXIuc3R5bGUuekluZGV4PW14UG9wdXBNZW51LnByb3RvdHlwZS56SW5kZXgtMjt0aGlzLmhzcGxpdC5zdHlsZS53aWR0aD10aGlzLnNwbGl0U2l6ZSsicHgiO2lmKHRoaXMuc2lkZWJhckZvb3RlckNvbnRhaW5lcj10aGlzLmNyZWF0ZVNpZGViYXJGb290ZXJDb250YWluZXIoKSl0aGlzLnNpZGViYXJGb290ZXJDb250YWluZXIuc3R5bGUubGVmdD0iMHB4Ijt0aGlzLmVkaXRvci5jaHJvbWVsZXNzP3RoaXMuZGlhZ3JhbUNvbnRhaW5lci5zdHlsZS5ib3JkZXI9Im5vbmUiOnRoaXMudGFiQ29udGFpbmVyPXRoaXMuY3JlYXRlVGFiQ29udGFpbmVyKCl9O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVTaWRlYmFyRm9vdGVyQ29udGFpbmVyPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9OwpFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlVWk9ZnVuY3Rpb24oKXt0aGlzLm1lbnViYXI9dGhpcy5lZGl0b3IuY2hyb21lbGVzcz9udWxsOnRoaXMubWVudXMuY3JlYXRlTWVudWJhcih0aGlzLmNyZWF0ZURpdigiZ2VNZW51YmFyIikpO251bGwhPXRoaXMubWVudWJhciYmdGhpcy5tZW51YmFyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubWVudWJhci5jb250YWluZXIpO251bGwhPXRoaXMubWVudWJhciYmKHRoaXMuc3RhdHVzQ29udGFpbmVyPXRoaXMuY3JlYXRlU3RhdHVzQ29udGFpbmVyKCksdGhpcy5lZGl0b3IuYWRkTGlzdGVuZXIoInN0YXR1c0NoYW5nZWQiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5zZXRTdGF0dXNUZXh0KHRoaXMuZWRpdG9yLmdldFN0YXR1cygpKX0pKSx0aGlzLnNldFN0YXR1c1RleHQodGhpcy5lZGl0b3IuZ2V0U3RhdHVzKCkpLHRoaXMubWVudWJhci5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zdGF0dXNDb250YWluZXIpLHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubWVudWJhckNvbnRhaW5lcikpOwp0aGlzLnNpZGViYXI9dGhpcy5lZGl0b3IuY2hyb21lbGVzcz9udWxsOnRoaXMuY3JlYXRlU2lkZWJhcih0aGlzLnNpZGViYXJDb250YWluZXIpO251bGwhPXRoaXMuc2lkZWJhciYmdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zaWRlYmFyQ29udGFpbmVyKTt0aGlzLmZvcm1hdD10aGlzLmVkaXRvci5jaHJvbWVsZXNzfHwhdGhpcy5mb3JtYXRFbmFibGVkP251bGw6dGhpcy5jcmVhdGVGb3JtYXQodGhpcy5mb3JtYXRDb250YWluZXIpO251bGwhPXRoaXMuZm9ybWF0JiZ0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZvcm1hdENvbnRhaW5lcik7dmFyIGE9dGhpcy5lZGl0b3IuY2hyb21lbGVzcz9udWxsOnRoaXMuY3JlYXRlRm9vdGVyKCk7bnVsbCE9YSYmKHRoaXMuZm9vdGVyQ29udGFpbmVyLmFwcGVuZENoaWxkKGEpLHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZm9vdGVyQ29udGFpbmVyKSk7bnVsbCE9dGhpcy5zaWRlYmFyJiZ0aGlzLnNpZGViYXJGb290ZXJDb250YWluZXImJgp0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnNpZGViYXJGb290ZXJDb250YWluZXIpO3RoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZGlhZ3JhbUNvbnRhaW5lcik7bnVsbCE9dGhpcy5jb250YWluZXImJm51bGwhPXRoaXMudGFiQ29udGFpbmVyJiZ0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnRhYkNvbnRhaW5lcik7dGhpcy50b29sYmFyPXRoaXMuZWRpdG9yLmNocm9tZWxlc3M/bnVsbDp0aGlzLmNyZWF0ZVRvb2xiYXIodGhpcy5jcmVhdGVEaXYoImdlVG9vbGJhciIpKTtudWxsIT10aGlzLnRvb2xiYXImJih0aGlzLnRvb2xiYXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy50b29sYmFyLmNvbnRhaW5lciksdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy50b29sYmFyQ29udGFpbmVyKSk7bnVsbCE9dGhpcy5zaWRlYmFyJiYodGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5oc3BsaXQpLHRoaXMuYWRkU3BsaXRIYW5kbGVyKHRoaXMuaHNwbGl0LAohMCwwLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuaHNwbGl0UG9zaXRpb249YTt0aGlzLnJlZnJlc2goKX0pKSl9O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVTdGF0dXNDb250YWluZXI9ZnVuY3Rpb24oKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJhIik7YS5jbGFzc05hbWU9ImdlSXRlbSBnZVN0YXR1cyI7NDIwPnNjcmVlbi53aWR0aCYmKGEuc3R5bGUubWF4V2lkdGg9TWF0aC5tYXgoMjAsc2NyZWVuLndpZHRoLTMyMCkrInB4IixhLnN0eWxlLm92ZXJmbG93PSJoaWRkZW4iKTtyZXR1cm4gYX07RWRpdG9yVWkucHJvdG90eXBlLnNldFN0YXR1c1RleHQ9ZnVuY3Rpb24oYSl7dGhpcy5zdGF0dXNDb250YWluZXIuaW5uZXJIVE1MPWF9O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVUb29sYmFyPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgVG9vbGJhcih0aGlzLGEpfTsKRWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZVNpZGViYXI9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBTaWRlYmFyKHRoaXMsYSl9O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVGb3JtYXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBGb3JtYXQodGhpcyxhKX07RWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZUZvb3Rlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNyZWF0ZURpdigiZ2VGb290ZXIiKX07RWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZURpdj1mdW5jdGlvbihhKXt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtjLmNsYXNzTmFtZT1hO3JldHVybiBjfTsKRWRpdG9yVWkucHJvdG90eXBlLmFkZFNwbGl0SGFuZGxlcj1mdW5jdGlvbihhLGMsZixkKXtmdW5jdGlvbiBtKGEpe2lmKG51bGwhPXEpe3ZhciBsPW5ldyBteFBvaW50KG14RXZlbnQuZ2V0Q2xpZW50WChhKSxteEV2ZW50LmdldENsaWVudFkoYSkpO2QoTWF0aC5tYXgoMCxiKyhjP2wueC1xLng6cS55LWwueSktZikpO214RXZlbnQuY29uc3VtZShhKTtiIT1wKCkmJihlPSEwLGc9bnVsbCl9fWZ1bmN0aW9uIGsoYSl7bShhKTtxPWI9bnVsbH12YXIgcT1udWxsLGI9bnVsbCxlPSEwLGc9bnVsbDtteENsaWVudC5JU19QT0lOVEVSJiYoYS5zdHlsZS50b3VjaEFjdGlvbj0ibm9uZSIpO3ZhciBwPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGI9cGFyc2VJbnQoYz9hLnN0eWxlLmxlZnQ6YS5zdHlsZS5ib3R0b20pO2N8fChiPWIrZi10aGlzLmZvb3RlckhlaWdodCk7cmV0dXJuIGJ9KTtteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnMoYSxmdW5jdGlvbihhKXtxPW5ldyBteFBvaW50KG14RXZlbnQuZ2V0Q2xpZW50WChhKSwKbXhFdmVudC5nZXRDbGllbnRZKGEpKTtiPXAoKTtlPSExO214RXZlbnQuY29uc3VtZShhKX0pO214RXZlbnQuYWRkTGlzdGVuZXIoYSwiY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2lmKCFlJiZ0aGlzLmhzcGxpdENsaWNrRW5hYmxlZCl7dmFyIGI9bnVsbCE9Zz9nLWY6MDtnPXAoKTtkKGIpO214RXZlbnQuY29uc3VtZShhKX19KSk7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKGRvY3VtZW50LG51bGwsbSxrKTt0aGlzLmRlc3Ryb3lGdW5jdGlvbnMucHVzaChmdW5jdGlvbigpe214RXZlbnQucmVtb3ZlR2VzdHVyZUxpc3RlbmVycyhkb2N1bWVudCxudWxsLG0sayl9KX07CkVkaXRvclVpLnByb3RvdHlwZS5oYW5kbGVFcnJvcj1mdW5jdGlvbihhLGMsZixkLG0pe2E9bnVsbCE9YSYmbnVsbCE9YS5lcnJvcj9hLmVycm9yOmE7aWYobnVsbCE9YXx8bnVsbCE9Yyl7bT1teFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQoInVua25vd25FcnJvciIpKTt2YXIgaz1teFJlc291cmNlcy5nZXQoIm9rIik7Yz1udWxsIT1jP2M6bXhSZXNvdXJjZXMuZ2V0KCJlcnJvciIpO251bGwhPWEmJm51bGwhPWEubWVzc2FnZSYmKG09bXhVdGlscy5odG1sRW50aXRpZXMoYS5tZXNzYWdlKSk7dGhpcy5zaG93RXJyb3IoYyxtLGssZixudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsZD9mOm51bGwpfWVsc2UgbnVsbCE9ZiYmZigpfTsKRWRpdG9yVWkucHJvdG90eXBlLnNob3dFcnJvcj1mdW5jdGlvbihhLGMsZixkLG0sayxxLGIsZSxnLHAsbCxuKXthPW5ldyBFcnJvckRpYWxvZyh0aGlzLGEsYyxmfHxteFJlc291cmNlcy5nZXQoIm9rIiksZCxtLGsscSxsLGIsZSk7Yz1NYXRoLmNlaWwobnVsbCE9Yz9jLmxlbmd0aC81MDoxKTt0aGlzLnNob3dEaWFsb2coYS5jb250YWluZXIsZ3x8MzQwLHB8fDEwMCsyMCpjLCEwLCExLG4pO2EuaW5pdCgpfTtFZGl0b3JVaS5wcm90b3R5cGUuc2hvd0RpYWxvZz1mdW5jdGlvbihhLGMsZixkLG0sayxxLGIsZSxnKXt0aGlzLmVkaXRvci5ncmFwaC50b29sdGlwSGFuZGxlci5oaWRlVG9vbHRpcCgpO251bGw9PXRoaXMuZGlhbG9ncyYmKHRoaXMuZGlhbG9ncz1bXSk7dGhpcy5kaWFsb2c9bmV3IERpYWxvZyh0aGlzLGEsYyxmLGQsbSxrLHEsYixlLGcpO3RoaXMuZGlhbG9ncy5wdXNoKHRoaXMuZGlhbG9nKX07CkVkaXRvclVpLnByb3RvdHlwZS5oaWRlRGlhbG9nPWZ1bmN0aW9uKGEsYyl7aWYobnVsbCE9dGhpcy5kaWFsb2dzJiYwPHRoaXMuZGlhbG9ncy5sZW5ndGgpe3ZhciBmPXRoaXMuZGlhbG9ncy5wb3AoKTswPT1mLmNsb3NlKGEsYyk/dGhpcy5kaWFsb2dzLnB1c2goZik6KHRoaXMuZGlhbG9nPTA8dGhpcy5kaWFsb2dzLmxlbmd0aD90aGlzLmRpYWxvZ3NbdGhpcy5kaWFsb2dzLmxlbmd0aC0xXTpudWxsLHRoaXMuZWRpdG9yLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgiaGlkZURpYWxvZyIpKSxudWxsPT10aGlzLmRpYWxvZyYmImhpZGRlbiIhPXRoaXMuZWRpdG9yLmdyYXBoLmNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5JiZ3aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuZWRpdG9yLmdyYXBoLmlzRWRpdGluZygpJiZudWxsIT10aGlzLmVkaXRvci5ncmFwaC5jZWxsRWRpdG9yLnRleHRhcmVhP3RoaXMuZWRpdG9yLmdyYXBoLmNlbGxFZGl0b3IudGV4dGFyZWEuZm9jdXMoKToKKG14VXRpbHMuY2xlYXJTZWxlY3Rpb24oKSx0aGlzLmVkaXRvci5ncmFwaC5jb250YWluZXIuZm9jdXMoKSl9KSwwKSl9fTtFZGl0b3JVaS5wcm90b3R5cGUuY3RybEVudGVyPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lZGl0b3IuZ3JhcGg7aWYoYS5pc0VuYWJsZWQoKSl0cnl7Zm9yKHZhciBjPWEuZ2V0U2VsZWN0aW9uQ2VsbHMoKSxmPW5ldyBteERpY3Rpb25hcnksZD1bXSxtPTA7bTxjLmxlbmd0aDttKyspe3ZhciBrPWEuaXNUYWJsZUNlbGwoY1ttXSk/YS5tb2RlbC5nZXRQYXJlbnQoY1ttXSk6Y1ttXTtudWxsPT1rfHxmLmdldChrKXx8KGYucHV0KGssITApLGQucHVzaChrKSl9YS5zZXRTZWxlY3Rpb25DZWxscyhhLmR1cGxpY2F0ZUNlbGxzKGQsITEpKX1jYXRjaChxKXt0aGlzLmhhbmRsZUVycm9yKHEpfX07CkVkaXRvclVpLnByb3RvdHlwZS5waWNrQ29sb3I9ZnVuY3Rpb24oYSxjKXt2YXIgZj10aGlzLmVkaXRvci5ncmFwaCxkPWYuY2VsbEVkaXRvci5zYXZlU2VsZWN0aW9uKCksbT0yMjYrMTcqKE1hdGguY2VpbChDb2xvckRpYWxvZy5wcm90b3R5cGUucHJlc2V0Q29sb3JzLmxlbmd0aC8xMikrTWF0aC5jZWlsKENvbG9yRGlhbG9nLnByb3RvdHlwZS5kZWZhdWx0Q29sb3JzLmxlbmd0aC8xMikpLGs9bmV3IENvbG9yRGlhbG9nKHRoaXMsYXx8Im5vbmUiLGZ1bmN0aW9uKGEpe2YuY2VsbEVkaXRvci5yZXN0b3JlU2VsZWN0aW9uKGQpO2MoYSl9LGZ1bmN0aW9uKCl7Zi5jZWxsRWRpdG9yLnJlc3RvcmVTZWxlY3Rpb24oZCl9KTt0aGlzLnNob3dEaWFsb2coay5jb250YWluZXIsMjMwLG0sITAsITEpO2suaW5pdCgpfTsKRWRpdG9yVWkucHJvdG90eXBlLm9wZW5GaWxlPWZ1bmN0aW9uKCl7d2luZG93Lm9wZW5GaWxlPW5ldyBPcGVuRmlsZShteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmhpZGVEaWFsb2coYSl9KSk7dGhpcy5zaG93RGlhbG9nKChuZXcgT3BlbkRpYWxvZyh0aGlzKSkuY29udGFpbmVyLEVkaXRvci51c2VMb2NhbFN0b3JhZ2U/NjQwOjMyMCxFZGl0b3IudXNlTG9jYWxTdG9yYWdlPzQ4MDoyMjAsITAsITAsZnVuY3Rpb24oKXt3aW5kb3cub3BlbkZpbGU9bnVsbH0pfTsKRWRpdG9yVWkucHJvdG90eXBlLmV4dHJhY3RHcmFwaE1vZGVsRnJvbUh0bWw9ZnVuY3Rpb24oYSl7dmFyIGM9bnVsbDt0cnl7dmFyIGY9YS5pbmRleE9mKCImbHQ7bXhHcmFwaE1vZGVsICIpO2lmKDA8PWYpe3ZhciBkPWEubGFzdEluZGV4T2YoIiZsdDsvbXhHcmFwaE1vZGVsJmd0OyIpO2Q+ZiYmKGM9YS5zdWJzdHJpbmcoZixkKzIxKS5yZXBsYWNlKC8mZ3Q7L2csIj4iKS5yZXBsYWNlKC8mbHQ7L2csIjwiKS5yZXBsYWNlKC9cXCZxdW90Oy9nLCciJykucmVwbGFjZSgvXG4vZywiIikpfX1jYXRjaChtKXt9cmV0dXJuIGN9OwpFZGl0b3JVaS5wcm90b3R5cGUuZXh0cmFjdEdyYXBoTW9kZWxGcm9tRXZlbnQ9ZnVuY3Rpb24oYSl7dmFyIGM9bnVsbCxmPW51bGw7bnVsbCE9YSYmKGE9bnVsbCE9YS5kYXRhVHJhbnNmZXI/YS5kYXRhVHJhbnNmZXI6YS5jbGlwYm9hcmREYXRhLG51bGwhPWEmJigxMD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHwxMT09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlP2Y9YS5nZXREYXRhKCJUZXh0Iik6KGY9MDw9bXhVdGlscy5pbmRleE9mKGEudHlwZXMsInRleHQvaHRtbCIpP2EuZ2V0RGF0YSgidGV4dC9odG1sIik6bnVsbCxteFV0aWxzLmluZGV4T2YoYS50eXBlcyxudWxsPT1mfHwwPT1mLmxlbmd0aCkmJihmPWEuZ2V0RGF0YSgidGV4dC9wbGFpbiIpKSksbnVsbCE9ZiYmKGY9R3JhcGguemFwR3JlbWxpbnMobXhVdGlscy50cmltKGYpKSxhPXRoaXMuZXh0cmFjdEdyYXBoTW9kZWxGcm9tSHRtbChmKSxudWxsIT1hJiYoZj1hKSkpKTtudWxsIT1mJiZ0aGlzLmlzQ29tcGF0aWJsZVN0cmluZyhmKSYmCihjPWYpO3JldHVybiBjfTtFZGl0b3JVaS5wcm90b3R5cGUuaXNDb21wYXRpYmxlU3RyaW5nPWZ1bmN0aW9uKGEpe3JldHVybiExfTtFZGl0b3JVaS5wcm90b3R5cGUuc2F2ZUZpbGU9ZnVuY3Rpb24oYSl7YXx8bnVsbD09dGhpcy5lZGl0b3IuZmlsZW5hbWU/KGE9bmV3IEZpbGVuYW1lRGlhbG9nKHRoaXMsdGhpcy5lZGl0b3IuZ2V0T3JDcmVhdGVGaWxlbmFtZSgpLG14UmVzb3VyY2VzLmdldCgic2F2ZSIpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuc2F2ZShhKX0pLG51bGwsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7aWYobnVsbCE9YSYmMDxhLmxlbmd0aClyZXR1cm4hMDtteFV0aWxzLmNvbmZpcm0obXhSZXNvdXJjZXMuZ2V0KCJpbnZhbGlkTmFtZSIpKTtyZXR1cm4hMX0pKSx0aGlzLnNob3dEaWFsb2coYS5jb250YWluZXIsMzAwLDEwMCwhMCwhMCksYS5pbml0KCkpOnRoaXMuc2F2ZSh0aGlzLmVkaXRvci5nZXRPckNyZWF0ZUZpbGVuYW1lKCkpfTsKRWRpdG9yVWkucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSl7dGhpcy5lZGl0b3IuZ3JhcGguaXNFZGl0aW5nKCkmJnRoaXMuZWRpdG9yLmdyYXBoLnN0b3BFZGl0aW5nKCk7dmFyIGM9bXhVdGlscy5nZXRYbWwodGhpcy5lZGl0b3IuZ2V0R3JhcGhYbWwoKSk7dHJ5e2lmKEVkaXRvci51c2VMb2NhbFN0b3JhZ2Upe2lmKG51bGwhPWxvY2FsU3RvcmFnZS5nZXRJdGVtKGEpJiYhbXhVdGlscy5jb25maXJtKG14UmVzb3VyY2VzLmdldCgicmVwbGFjZUl0IixbYV0pKSlyZXR1cm47bG9jYWxTdG9yYWdlLnNldEl0ZW0oYSxjKTt0aGlzLmVkaXRvci5zZXRTdGF0dXMobXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KCJzYXZlZCIpKSsiICIrbmV3IERhdGUpfWVsc2UgaWYoYy5sZW5ndGg8TUFYX1JFUVVFU1RfU0laRSkobmV3IG14WG1sUmVxdWVzdChTQVZFX1VSTCwiZmlsZW5hbWU9IitlbmNvZGVVUklDb21wb25lbnQoYSkrIiZ4bWw9IitlbmNvZGVVUklDb21wb25lbnQoYykpKS5zaW11bGF0ZShkb2N1bWVudCwKIl9ibGFuayIpO2Vsc2V7bXhVdGlscy5hbGVydChteFJlc291cmNlcy5nZXQoImRyYXdpbmdUb29MYXJnZSIpKTtteFV0aWxzLnBvcHVwKGMpO3JldHVybn10aGlzLmVkaXRvci5zZXRNb2RpZmllZCghMSk7dGhpcy5lZGl0b3Iuc2V0RmlsZW5hbWUoYSk7dGhpcy51cGRhdGVEb2N1bWVudFRpdGxlKCl9Y2F0Y2goZil7dGhpcy5lZGl0b3Iuc2V0U3RhdHVzKG14VXRpbHMuaHRtbEVudGl0aWVzKG14UmVzb3VyY2VzLmdldCgiZXJyb3JTYXZpbmdGaWxlIikpKX19fTsKRWRpdG9yVWkucHJvdG90eXBlLmV4ZWN1dGVMYXlvdXQ9ZnVuY3Rpb24oYSxjLGYpe3ZhciBkPXRoaXMuZWRpdG9yLmdyYXBoO2lmKGQuaXNFbmFibGVkKCkpe2QuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXthKCl9Y2F0Y2gobSl7dGhyb3cgbTt9ZmluYWxseXt0aGlzLmFsbG93QW5pbWF0aW9uJiZjJiYobnVsbD09bmF2aWdhdG9yLnVzZXJBZ2VudHx8MD5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIkNhbWlubyIpKT8oYT1uZXcgbXhNb3JwaGluZyhkKSxhLmFkZExpc3RlbmVyKG14RXZlbnQuRE9ORSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2QuZ2V0TW9kZWwoKS5lbmRVcGRhdGUoKTtudWxsIT1mJiZmKCl9KSksYS5zdGFydEFuaW1hdGlvbigpKTooZC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpLG51bGwhPWYmJmYoKSl9fX07CkVkaXRvclVpLnByb3RvdHlwZS5zaG93SW1hZ2VEaWFsb2c9ZnVuY3Rpb24oYSxjLGYsZCl7ZD10aGlzLmVkaXRvci5ncmFwaC5jZWxsRWRpdG9yO3ZhciBtPWQuc2F2ZVNlbGVjdGlvbigpLGs9bXhVdGlscy5wcm9tcHQoYSxjKTtkLnJlc3RvcmVTZWxlY3Rpb24obSk7aWYobnVsbCE9ayYmMDxrLmxlbmd0aCl7dmFyIHE9bmV3IEltYWdlO3Eub25sb2FkPWZ1bmN0aW9uKCl7ZihrLHEud2lkdGgscS5oZWlnaHQpfTtxLm9uZXJyb3I9ZnVuY3Rpb24oKXtmKG51bGwpO214VXRpbHMuYWxlcnQobXhSZXNvdXJjZXMuZ2V0KCJmaWxlTm90Rm91bmQiKSl9O3Euc3JjPWt9ZWxzZSBmKG51bGwpfTtFZGl0b3JVaS5wcm90b3R5cGUuc2hvd0xpbmtEaWFsb2c9ZnVuY3Rpb24oYSxjLGYpe2E9bmV3IExpbmtEaWFsb2codGhpcyxhLGMsZik7dGhpcy5zaG93RGlhbG9nKGEuY29udGFpbmVyLDQyMCw5MCwhMCwhMCk7YS5pbml0KCl9OwpFZGl0b3JVaS5wcm90b3R5cGUuc2hvd0RhdGFEaWFsb2c9ZnVuY3Rpb24oYSl7bnVsbCE9YSYmKGE9bmV3IEVkaXREYXRhRGlhbG9nKHRoaXMsYSksdGhpcy5zaG93RGlhbG9nKGEuY29udGFpbmVyLDQ4MCw0MjAsITAsITEsbnVsbCwhMSksYS5pbml0KCkpfTsKRWRpdG9yVWkucHJvdG90eXBlLnNob3dCYWNrZ3JvdW5kSW1hZ2VEaWFsb2c9ZnVuY3Rpb24oYSxjKXthPW51bGwhPWE/YTpteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXthPW5ldyBDaGFuZ2VQYWdlU2V0dXAodGhpcyxudWxsLGEpO2EuaWdub3JlQ29sb3I9ITA7dGhpcy5lZGl0b3IuZ3JhcGgubW9kZWwuZXhlY3V0ZShhKX0pO3ZhciBmPW14VXRpbHMucHJvbXB0KG14UmVzb3VyY2VzLmdldCgiYmFja2dyb3VuZEltYWdlIiksbnVsbCE9Yz9jLnNyYzoiIik7bnVsbCE9ZiYmMDxmLmxlbmd0aD8oYz1uZXcgSW1hZ2UsYy5vbmxvYWQ9ZnVuY3Rpb24oKXthKG5ldyBteEltYWdlKGYsYy53aWR0aCxjLmhlaWdodCksITEpfSxjLm9uZXJyb3I9ZnVuY3Rpb24oKXthKG51bGwsITApO214VXRpbHMuYWxlcnQobXhSZXNvdXJjZXMuZ2V0KCJmaWxlTm90Rm91bmQiKSl9LGMuc3JjPWYpOmEobnVsbCl9OwpFZGl0b3JVaS5wcm90b3R5cGUuc2V0QmFja2dyb3VuZEltYWdlPWZ1bmN0aW9uKGEpe3RoaXMuZWRpdG9yLmdyYXBoLnNldEJhY2tncm91bmRJbWFnZShhKTt0aGlzLmVkaXRvci5ncmFwaC52aWV3LnZhbGlkYXRlQmFja2dyb3VuZEltYWdlKCk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImJhY2tncm91bmRJbWFnZUNoYW5nZWQiKSl9O0VkaXRvclVpLnByb3RvdHlwZS5jb25maXJtPWZ1bmN0aW9uKGEsYyxmKXtteFV0aWxzLmNvbmZpcm0oYSk/bnVsbCE9YyYmYygpOm51bGwhPWYmJmYoKX07CkVkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVPdXRsaW5lPWZ1bmN0aW9uKGEpe3ZhciBjPW5ldyBteE91dGxpbmUodGhpcy5lZGl0b3IuZ3JhcGgpO2MuYm9yZGVyPTIwO214RXZlbnQuYWRkTGlzdGVuZXIod2luZG93LCJyZXNpemUiLGZ1bmN0aW9uKCl7Yy51cGRhdGUoKX0pO3RoaXMuYWRkTGlzdGVuZXIoInBhZ2VGb3JtYXRDaGFuZ2VkIixmdW5jdGlvbigpe2MudXBkYXRlKCl9KTtyZXR1cm4gY307RWRpdG9yVWkucHJvdG90eXBlLmFsdFNoaWZ0QWN0aW9ucz17Njc6ImNsZWFyV2F5cG9pbnRzIiw2NToiY29ubmVjdGlvbkFycm93cyIsNzY6ImVkaXRMaW5rIiw4MDoiY29ubmVjdGlvblBvaW50cyIsODQ6ImVkaXRUb29sdGlwIiw4NjoicGFzdGVTaXplIiw4ODoiY29weVNpemUifTsKRWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZUtleUhhbmRsZXI9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYyhhLGUsYyl7cS5wdXNoKGZ1bmN0aW9uKCl7aWYoIWQuaXNTZWxlY3Rpb25FbXB0eSgpJiZkLmlzRW5hYmxlZCgpKWlmKGU9bnVsbCE9ZT9lOjEsYyl7ZC5nZXRNb2RlbCgpLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgYj1kLmdldFNlbGVjdGlvbkNlbGxzKCksZz0wO2c8Yi5sZW5ndGg7ZysrKWlmKGQuZ2V0TW9kZWwoKS5pc1ZlcnRleChiW2ddKSYmZC5pc0NlbGxSZXNpemFibGUoYltnXSkpe3ZhciBmPWQuZ2V0Q2VsbEdlb21ldHJ5KGJbZ10pO251bGwhPWYmJihmPWYuY2xvbmUoKSwzNz09YT9mLndpZHRoPU1hdGgubWF4KDAsZi53aWR0aC1lKTozOD09YT9mLmhlaWdodD1NYXRoLm1heCgwLGYuaGVpZ2h0LWUpOjM5PT1hP2Yud2lkdGgrPWU6NDA9PWEmJihmLmhlaWdodCs9ZSksZC5nZXRNb2RlbCgpLnNldEdlb21ldHJ5KGJbZ10sZikpfX1maW5hbGx5e2QuZ2V0TW9kZWwoKS5lbmRVcGRhdGUoKX19ZWxzZXt2YXIgbD0KZC5nZXRTZWxlY3Rpb25DZWxsKCksZj1kLm1vZGVsLmdldFBhcmVudChsKSxiPW51bGw7MT09ZC5nZXRTZWxlY3Rpb25Db3VudCgpJiZkLm1vZGVsLmlzVmVydGV4KGwpJiZudWxsIT1kLmxheW91dE1hbmFnZXImJiFkLmlzQ2VsbExvY2tlZChsKSYmKGI9ZC5sYXlvdXRNYW5hZ2VyLmdldExheW91dChmKSk7aWYobnVsbCE9YiYmYi5jb25zdHJ1Y3Rvcj09bXhTdGFja0xheW91dCliPWYuZ2V0SW5kZXgobCksMzc9PWF8fDM4PT1hP2QubW9kZWwuYWRkKGYsbCxNYXRoLm1heCgwLGItMSkpOjM5IT1hJiY0MCE9YXx8ZC5tb2RlbC5hZGQoZixsLE1hdGgubWluKGQubW9kZWwuZ2V0Q2hpbGRDb3VudChmKSxiKzEpKTtlbHNle2I9ZC5nZXRNb3ZhYmxlQ2VsbHMoZC5nZXRTZWxlY3Rpb25DZWxscygpKTtsPVtdO2ZvcihnPTA7ZzxiLmxlbmd0aDtnKyspZj1kLmdldEN1cnJlbnRDZWxsU3R5bGUoYltnXSksIjEiPT1teFV0aWxzLmdldFZhbHVlKGYsInBhcnQiLCIwIik/KGY9ZC5tb2RlbC5nZXRQYXJlbnQoYltnXSksCmQubW9kZWwuaXNWZXJ0ZXgoZikmJjA+bXhVdGlscy5pbmRleE9mKGIsZikmJmwucHVzaChmKSk6bC5wdXNoKGJbZ10pOzA8bC5sZW5ndGgmJihiPWY9MCwzNz09YT9mPS1lOjM4PT1hP2I9LWU6Mzk9PWE/Zj1lOjQwPT1hJiYoYj1lKSxkLm1vdmVDZWxscyhsLGYsYikpfX19KTtudWxsIT1iJiZ3aW5kb3cuY2xlYXJUaW1lb3V0KGIpO2I9d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtpZigwPHEubGVuZ3RoKXtkLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBhPTA7YTxxLmxlbmd0aDthKyspcVthXSgpO3E9W119ZmluYWxseXtkLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9fX0sMjAwKX12YXIgZj10aGlzLGQ9dGhpcy5lZGl0b3IuZ3JhcGgsbT1uZXcgbXhLZXlIYW5kbGVyKGQpLGs9bS5pc0V2ZW50SWdub3JlZDttLmlzRXZlbnRJZ25vcmVkPWZ1bmN0aW9uKGEpe3JldHVybiEobXhFdmVudC5pc1NoaWZ0RG93bihhKSYmOT09YS5rZXlDb2RlKSYmKCF0aGlzLmlzQ29udHJvbERvd24oYSl8fApteEV2ZW50LmlzU2hpZnREb3duKGEpfHw5MCE9YS5rZXlDb2RlJiY4OSE9YS5rZXlDb2RlJiYxODghPWEua2V5Q29kZSYmMTkwIT1hLmtleUNvZGUmJjg1IT1hLmtleUNvZGUpJiYoNjYhPWEua2V5Q29kZSYmNzMhPWEua2V5Q29kZXx8IXRoaXMuaXNDb250cm9sRG93bihhKXx8dGhpcy5ncmFwaC5jZWxsRWRpdG9yLmlzQ29udGVudEVkaXRpbmcoKSYmIW14Q2xpZW50LklTX0ZGJiYhbXhDbGllbnQuSVNfU0YpJiZrLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07bS5pc0VuYWJsZWRGb3JFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4hbXhFdmVudC5pc0NvbnN1bWVkKGEpJiZ0aGlzLmlzR3JhcGhFdmVudChhKSYmdGhpcy5pc0VuYWJsZWQoKSYmKG51bGw9PWYuZGlhbG9nc3x8MD09Zi5kaWFsb2dzLmxlbmd0aCl9O20uaXNDb250cm9sRG93bj1mdW5jdGlvbihhKXtyZXR1cm4gbXhFdmVudC5pc0NvbnRyb2xEb3duKGEpfHxteENsaWVudC5JU19NQUMmJmEubWV0YUtleX07dmFyIHE9W10sYj0KbnVsbCxlPXszNzpteENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVCwzODpteENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEgsMzk6bXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1QsNDA6bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIfSxnPW0uZ2V0RnVuY3Rpb247bXhLZXlIYW5kbGVyLnByb3RvdHlwZS5nZXRGdW5jdGlvbj1mdW5jdGlvbihhKXtpZihkLmlzRW5hYmxlZCgpKXtpZihteEV2ZW50LmlzU2hpZnREb3duKGEpJiZteEV2ZW50LmlzQWx0RG93bihhKSl7dmFyIGI9Zi5hY3Rpb25zLmdldChmLmFsdFNoaWZ0QWN0aW9uc1thLmtleUNvZGVdKTtpZihudWxsIT1iKXJldHVybiBiLmZ1bmN0fWlmKDk9PWEua2V5Q29kZSYmbXhFdmVudC5pc0FsdERvd24oYSkpcmV0dXJuIGQuY2VsbEVkaXRvci5pc0NvbnRlbnRFZGl0aW5nKCk/ZnVuY3Rpb24oKXtkb2N1bWVudC5leGVjQ29tbWFuZCgib3V0ZGVudCIsITEsbnVsbCl9Om14RXZlbnQuaXNTaGlmdERvd24oYSk/ZnVuY3Rpb24oKXtkLnNlbGVjdFBhcmVudENlbGwoKX06CmZ1bmN0aW9uKCl7ZC5zZWxlY3RDaGlsZENlbGwoKX07aWYobnVsbCE9ZVthLmtleUNvZGVdJiYhZC5pc1NlbGVjdGlvbkVtcHR5KCkpaWYoIXRoaXMuaXNDb250cm9sRG93bihhKSYmbXhFdmVudC5pc1NoaWZ0RG93bihhKSYmbXhFdmVudC5pc0FsdERvd24oYSkpe2lmKGQubW9kZWwuaXNWZXJ0ZXgoZC5nZXRTZWxlY3Rpb25DZWxsKCkpKXJldHVybiBmdW5jdGlvbigpe3ZhciBiPWQuY29ubmVjdFZlcnRleChkLmdldFNlbGVjdGlvbkNlbGwoKSxlW2Eua2V5Q29kZV0sZC5kZWZhdWx0RWRnZUxlbmd0aCxhLCEwKTtudWxsIT1iJiYwPGIubGVuZ3RoJiYoMT09Yi5sZW5ndGgmJmQubW9kZWwuaXNFZGdlKGJbMF0pP2Quc2V0U2VsZWN0aW9uQ2VsbChkLm1vZGVsLmdldFRlcm1pbmFsKGJbMF0sITEpKTpkLnNldFNlbGVjdGlvbkNlbGwoYltiLmxlbmd0aC0xXSksZC5zY3JvbGxDZWxsVG9WaXNpYmxlKGQuZ2V0U2VsZWN0aW9uQ2VsbCgpKSxudWxsIT1mLmhvdmVySWNvbnMmJmYuaG92ZXJJY29ucy51cGRhdGUoZC52aWV3LmdldFN0YXRlKGQuZ2V0U2VsZWN0aW9uQ2VsbCgpKSkpfX1lbHNlIHJldHVybiB0aGlzLmlzQ29udHJvbERvd24oYSk/CmZ1bmN0aW9uKCl7YyhhLmtleUNvZGUsbXhFdmVudC5pc1NoaWZ0RG93bihhKT9kLmdyaWRTaXplOm51bGwsITApfTpmdW5jdGlvbigpe2MoYS5rZXlDb2RlLG14RXZlbnQuaXNTaGlmdERvd24oYSk/ZC5ncmlkU2l6ZTpudWxsKX19cmV0dXJuIGcuYXBwbHkodGhpcyxhcmd1bWVudHMpfTttLmJpbmRBY3Rpb249bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiLGUsZCl7dmFyIGM9dGhpcy5hY3Rpb25zLmdldChlKTtudWxsIT1jJiYoZT1mdW5jdGlvbigpe2MuaXNFbmFibGVkKCkmJmMuZnVuY3QoKX0sYj9kP20uYmluZENvbnRyb2xTaGlmdEtleShhLGUpOm0uYmluZENvbnRyb2xLZXkoYSxlKTpkP20uYmluZFNoaWZ0S2V5KGEsZSk6bS5iaW5kS2V5KGEsZSkpfSk7dmFyIHA9dGhpcyxsPW0uZXNjYXBlO20uZXNjYXBlPWZ1bmN0aW9uKGEpe2wuYXBwbHkodGhpcyxhcmd1bWVudHMpfTttLmVudGVyPWZ1bmN0aW9uKCl7fTttLmJpbmRDb250cm9sU2hpZnRLZXkoMzYsZnVuY3Rpb24oKXtkLmV4aXRHcm91cCgpfSk7Cm0uYmluZENvbnRyb2xTaGlmdEtleSgzNSxmdW5jdGlvbigpe2QuZW50ZXJHcm91cCgpfSk7bS5iaW5kU2hpZnRLZXkoMzYsZnVuY3Rpb24oKXtkLmhvbWUoKX0pO20uYmluZEtleSgzNSxmdW5jdGlvbigpe2QucmVmcmVzaCgpfSk7bS5iaW5kQWN0aW9uKDEwNywhMCwiem9vbUluIik7bS5iaW5kQWN0aW9uKDEwOSwhMCwiem9vbU91dCIpO20uYmluZEFjdGlvbig4MCwhMCwicHJpbnQiKTttLmJpbmRBY3Rpb24oNzksITAsIm91dGxpbmUiLCEwKTtpZighdGhpcy5lZGl0b3IuY2hyb21lbGVzc3x8dGhpcy5lZGl0b3IuZWRpdGFibGUpbS5iaW5kQ29udHJvbEtleSgzNixmdW5jdGlvbigpe2QuaXNFbmFibGVkKCkmJmQuZm9sZENlbGxzKCEwKX0pLG0uYmluZENvbnRyb2xLZXkoMzUsZnVuY3Rpb24oKXtkLmlzRW5hYmxlZCgpJiZkLmZvbGRDZWxscyghMSl9KSxtLmJpbmRDb250cm9sS2V5KDEzLGZ1bmN0aW9uKCl7cC5jdHJsRW50ZXIoKX0pLG0uYmluZEFjdGlvbig4LCExLCJkZWxldGUiKSwKbS5iaW5kQWN0aW9uKDgsITAsImRlbGV0ZUFsbCIpLG0uYmluZEFjdGlvbig0NiwhMSwiZGVsZXRlIiksbS5iaW5kQWN0aW9uKDQ2LCEwLCJkZWxldGVBbGwiKSxtLmJpbmRBY3Rpb24oMzYsITEsInJlc2V0VmlldyIpLG0uYmluZEFjdGlvbig3MiwhMCwiZml0V2luZG93IiwhMCksbS5iaW5kQWN0aW9uKDc0LCEwLCJmaXRQYWdlIiksbS5iaW5kQWN0aW9uKDc0LCEwLCJmaXRUd29QYWdlcyIsITApLG0uYmluZEFjdGlvbig0OCwhMCwiY3VzdG9tWm9vbSIpLG0uYmluZEFjdGlvbig4MiwhMCwidHVybiIpLG0uYmluZEFjdGlvbig4MiwhMCwiY2xlYXJEZWZhdWx0U3R5bGUiLCEwKSxtLmJpbmRBY3Rpb24oODMsITAsInNhdmUiKSxtLmJpbmRBY3Rpb24oODMsITAsInNhdmVBcyIsITApLG0uYmluZEFjdGlvbig2NSwhMCwic2VsZWN0QWxsIiksbS5iaW5kQWN0aW9uKDY1LCEwLCJzZWxlY3ROb25lIiwhMCksbS5iaW5kQWN0aW9uKDczLCEwLCJzZWxlY3RWZXJ0aWNlcyIsITApLG0uYmluZEFjdGlvbig2OSwKITAsInNlbGVjdEVkZ2VzIiwhMCksbS5iaW5kQWN0aW9uKDY5LCEwLCJlZGl0U3R5bGUiKSxtLmJpbmRBY3Rpb24oNjYsITAsImJvbGQiKSxtLmJpbmRBY3Rpb24oNjYsITAsInRvQmFjayIsITApLG0uYmluZEFjdGlvbig3MCwhMCwidG9Gcm9udCIsITApLG0uYmluZEFjdGlvbig2OCwhMCwiZHVwbGljYXRlIiksbS5iaW5kQWN0aW9uKDY4LCEwLCJzZXRBc0RlZmF1bHRTdHlsZSIsITApLG0uYmluZEFjdGlvbig5MCwhMCwidW5kbyIpLG0uYmluZEFjdGlvbig4OSwhMCwiYXV0b3NpemUiLCEwKSxtLmJpbmRBY3Rpb24oODgsITAsImN1dCIpLG0uYmluZEFjdGlvbig2NywhMCwiY29weSIpLG0uYmluZEFjdGlvbig4NiwhMCwicGFzdGUiKSxtLmJpbmRBY3Rpb24oNzEsITAsImdyb3VwIiksbS5iaW5kQWN0aW9uKDc3LCEwLCJlZGl0RGF0YSIpLG0uYmluZEFjdGlvbig3MSwhMCwiZ3JpZCIsITApLG0uYmluZEFjdGlvbig3MywhMCwiaXRhbGljIiksbS5iaW5kQWN0aW9uKDc2LCEwLCJsb2NrVW5sb2NrIiksCm0uYmluZEFjdGlvbig3NiwhMCwibGF5ZXJzIiwhMCksbS5iaW5kQWN0aW9uKDgwLCEwLCJmb3JtYXRQYW5lbCIsITApLG0uYmluZEFjdGlvbig4NSwhMCwidW5kZXJsaW5lIiksbS5iaW5kQWN0aW9uKDg1LCEwLCJ1bmdyb3VwIiwhMCksbS5iaW5kQWN0aW9uKDE5MCwhMCwic3VwZXJzY3JpcHQiKSxtLmJpbmRBY3Rpb24oMTg4LCEwLCJzdWJzY3JpcHQiKSxtLmJpbmRBY3Rpb24oOSwhMSwiaW5kZW50IiwhMCksbS5iaW5kS2V5KDEzLGZ1bmN0aW9uKCl7ZC5pc0VuYWJsZWQoKSYmZC5zdGFydEVkaXRpbmdBdENlbGwoKX0pLG0uYmluZEtleSgxMTMsZnVuY3Rpb24oKXtkLmlzRW5hYmxlZCgpJiZkLnN0YXJ0RWRpdGluZ0F0Q2VsbCgpfSk7bXhDbGllbnQuSVNfV0lOP20uYmluZEFjdGlvbig4OSwhMCwicmVkbyIpOm0uYmluZEFjdGlvbig5MCwhMCwicmVkbyIsITApO3JldHVybiBtfTsKRWRpdG9yVWkucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmVkaXRvciYmKHRoaXMuZWRpdG9yLmRlc3Ryb3koKSx0aGlzLmVkaXRvcj1udWxsKTtudWxsIT10aGlzLm1lbnViYXImJih0aGlzLm1lbnViYXIuZGVzdHJveSgpLHRoaXMubWVudWJhcj1udWxsKTtudWxsIT10aGlzLnRvb2xiYXImJih0aGlzLnRvb2xiYXIuZGVzdHJveSgpLHRoaXMudG9vbGJhcj1udWxsKTtudWxsIT10aGlzLnNpZGViYXImJih0aGlzLnNpZGViYXIuZGVzdHJveSgpLHRoaXMuc2lkZWJhcj1udWxsKTtudWxsIT10aGlzLmtleUhhbmRsZXImJih0aGlzLmtleUhhbmRsZXIuZGVzdHJveSgpLHRoaXMua2V5SGFuZGxlcj1udWxsKTtudWxsIT10aGlzLmtleWRvd25IYW5kbGVyJiYobXhFdmVudC5yZW1vdmVMaXN0ZW5lcihkb2N1bWVudCwia2V5ZG93biIsdGhpcy5rZXlkb3duSGFuZGxlciksdGhpcy5rZXlkb3duSGFuZGxlcj1udWxsKTtudWxsIT10aGlzLmtleXVwSGFuZGxlciYmCihteEV2ZW50LnJlbW92ZUxpc3RlbmVyKGRvY3VtZW50LCJrZXl1cCIsdGhpcy5rZXl1cEhhbmRsZXIpLHRoaXMua2V5dXBIYW5kbGVyPW51bGwpO251bGwhPXRoaXMucmVzaXplSGFuZGxlciYmKG14RXZlbnQucmVtb3ZlTGlzdGVuZXIod2luZG93LCJyZXNpemUiLHRoaXMucmVzaXplSGFuZGxlciksdGhpcy5yZXNpemVIYW5kbGVyPW51bGwpO251bGwhPXRoaXMuZ2VzdHVyZUhhbmRsZXImJihteEV2ZW50LnJlbW92ZUdlc3R1cmVMaXN0ZW5lcnMoZG9jdW1lbnQsdGhpcy5nZXN0dXJlSGFuZGxlciksdGhpcy5nZXN0dXJlSGFuZGxlcj1udWxsKTtudWxsIT10aGlzLm9yaWVudGF0aW9uQ2hhbmdlSGFuZGxlciYmKG14RXZlbnQucmVtb3ZlTGlzdGVuZXIod2luZG93LCJvcmllbnRhdGlvbmNoYW5nZSIsdGhpcy5vcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIpLHRoaXMub3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyPW51bGwpO251bGwhPXRoaXMuc2Nyb2xsSGFuZGxlciYmKG14RXZlbnQucmVtb3ZlTGlzdGVuZXIod2luZG93LAoic2Nyb2xsIix0aGlzLnNjcm9sbEhhbmRsZXIpLHRoaXMuc2Nyb2xsSGFuZGxlcj1udWxsKTtpZihudWxsIT10aGlzLmRlc3Ryb3lGdW5jdGlvbnMpe2Zvcih2YXIgYT0wO2E8dGhpcy5kZXN0cm95RnVuY3Rpb25zLmxlbmd0aDthKyspdGhpcy5kZXN0cm95RnVuY3Rpb25zW2FdKCk7dGhpcy5kZXN0cm95RnVuY3Rpb25zPW51bGx9Zm9yKHZhciBjPVt0aGlzLm1lbnViYXJDb250YWluZXIsdGhpcy50b29sYmFyQ29udGFpbmVyLHRoaXMuc2lkZWJhckNvbnRhaW5lcix0aGlzLmZvcm1hdENvbnRhaW5lcix0aGlzLmRpYWdyYW1Db250YWluZXIsdGhpcy5mb290ZXJDb250YWluZXIsdGhpcy5jaHJvbWVsZXNzVG9vbGJhcix0aGlzLmhzcGxpdCx0aGlzLnNpZGViYXJGb290ZXJDb250YWluZXIsdGhpcy5sYXllcnNEaWFsb2ddLGE9MDthPGMubGVuZ3RoO2ErKyludWxsIT1jW2FdJiZudWxsIT1jW2FdLnBhcmVudE5vZGUmJmNbYV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjW2FdKX07InVuZGVmaW5lZCIhPT10eXBlb2YgaHRtbDQmJihodG1sNC5BVFRSSUJTWyJhOjp0YXJnZXQiXT0wLGh0bWw0LkFUVFJJQlNbInNvdXJjZTo6c3JjIl09MCxodG1sNC5BVFRSSUJTWyJ2aWRlbzo6c3JjIl09MCk7KGZ1bmN0aW9uKCl7dmFyIGE9W1sibmJzcCIsIjE2MCJdLFsic2h5IiwiMTczIl1dLGM9bXhVdGlscy5wYXJzZVhtbDtteFV0aWxzLnBhcnNlWG1sPWZ1bmN0aW9uKGYpe2Zvcih2YXIgZD0wO2Q8YS5sZW5ndGg7ZCsrKWY9Zi5yZXBsYWNlKG5ldyBSZWdFeHAoIiYiK2FbZF1bMF0rIjsiLCJnIiksIiYjIithW2RdWzFdKyI7Iik7cmV0dXJuIGMoZil9fSkoKTsKRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmd8fGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhKXthPVN0cmluZyhhKTsxPT09YS5sZW5ndGgmJihhPSIwIithKTtyZXR1cm4gYX1EYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFVUQ0Z1bGxZZWFyKCkrIi0iK2EodGhpcy5nZXRVVENNb250aCgpKzEpKyItIithKHRoaXMuZ2V0VVRDRGF0ZSgpKSsiVCIrYSh0aGlzLmdldFVUQ0hvdXJzKCkpKyI6IithKHRoaXMuZ2V0VVRDTWludXRlcygpKSsiOiIrYSh0aGlzLmdldFVUQ1NlY29uZHMoKSkrIi4iK1N0cmluZygodGhpcy5nZXRVVENNaWxsaXNlY29uZHMoKS8xRTMpLnRvRml4ZWQoMykpLnNsaWNlKDIsNSkrIloifX0oKTtEYXRlLm5vd3x8KERhdGUubm93PWZ1bmN0aW9uKCl7cmV0dXJuKG5ldyBEYXRlKS5nZXRUaW1lKCl9KTtteENvbnN0YW50cy5QT0lOVFM9MTtteENvbnN0YW50cy5NSUxMSU1FVEVSUz0yO214Q29uc3RhbnRzLklOQ0hFUz0zOwpteENvbnN0YW50cy5QSVhFTFNfUEVSX01NPTMuOTM3O214Q29uc3RhbnRzLlBJWEVMU19QRVJfSU5DSD0xMDA7bXhDb25zdGFudHMuU0hBRE9XX09QQUNJVFk9LjI1O214Q29uc3RhbnRzLlNIQURPV0NPTE9SPSIjMDAwMDAwIjtteENvbnN0YW50cy5WTUxfU0hBRE9XQ09MT1I9IiNkMGQwZDAiO214R3JhcGgucHJvdG90eXBlLnBhZ2VCcmVha0NvbG9yPSIjYzBjMGMwIjtteEdyYXBoLnByb3RvdHlwZS5wYWdlU2NhbGU9MTsoZnVuY3Rpb24oKXt0cnl7aWYobnVsbCE9bmF2aWdhdG9yJiZudWxsIT1uYXZpZ2F0b3IubGFuZ3VhZ2Upe3ZhciBhPW5hdmlnYXRvci5sYW5ndWFnZS50b0xvd2VyQ2FzZSgpO214R3JhcGgucHJvdG90eXBlLnBhZ2VGb3JtYXQ9ImVuLXVzIj09PWF8fCJlbi1jYSI9PT1hfHwiZXMtbXgiPT09YT9teENvbnN0YW50cy5QQUdFX0ZPUk1BVF9MRVRURVJfUE9SVFJBSVQ6bXhDb25zdGFudHMuUEFHRV9GT1JNQVRfQTRfUE9SVFJBSVR9fWNhdGNoKGMpe319KSgpOwpteFRleHQucHJvdG90eXBlLmJhc2VTcGFjaW5nVG9wPTU7bXhUZXh0LnByb3RvdHlwZS5iYXNlU3BhY2luZ0JvdHRvbT0xO214R3JhcGhNb2RlbC5wcm90b3R5cGUuaWdub3JlUmVsYXRpdmVFZGdlUGFyZW50PSExO214R3JhcGhWaWV3LnByb3RvdHlwZS5ncmlkSW1hZ2U9bXhDbGllbnQuSVNfU1ZHPyJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhDZ0FLQUpFQUFBQUFBUC8vLzh6TXpQLy8veUg1QkFFQUFBTUFMQUFBQUFBS0FBb0FBQUlKMUk2cHkrMFBvMndGQURzPSI6SU1BR0VfUEFUSCsiL2dyaWQuZ2lmIjtteEdyYXBoVmlldy5wcm90b3R5cGUuZ3JpZFN0ZXBzPTQ7bXhHcmFwaFZpZXcucHJvdG90eXBlLm1pbkdyaWRTaXplPTQ7bXhHcmFwaFZpZXcucHJvdG90eXBlLmRlZmF1bHRHcmlkQ29sb3I9IiNkMGQwZDAiO214R3JhcGhWaWV3LnByb3RvdHlwZS5ncmlkQ29sb3I9bXhHcmFwaFZpZXcucHJvdG90eXBlLmRlZmF1bHRHcmlkQ29sb3I7Cm14R3JhcGhWaWV3LnByb3RvdHlwZS51bml0PW14Q29uc3RhbnRzLlBPSU5UUztteEdyYXBoVmlldy5wcm90b3R5cGUuc2V0VW5pdD1mdW5jdGlvbihhKXt0aGlzLnVuaXQhPWEmJih0aGlzLnVuaXQ9YSx0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgidW5pdENoYW5nZWQiLCJ1bml0IixhKSkpfTtteFN2Z0NhbnZhczJELnByb3RvdHlwZS5mb0FsdFRleHQ9IltOb3Qgc3VwcG9ydGVkIGJ5IHZpZXdlcl0iO214U2hhcGUucHJvdG90eXBlLmdldENvbnN0cmFpbnRzPWZ1bmN0aW9uKGEsYyxmKXtyZXR1cm4gbnVsbH07CkdyYXBoPWZ1bmN0aW9uKGEsYyxmLGQsbSxrKXtteEdyYXBoLmNhbGwodGhpcyxhLGMsZixkKTt0aGlzLnRoZW1lcz1tfHx0aGlzLmRlZmF1bHRUaGVtZXM7dGhpcy5jdXJyZW50RWRnZVN0eWxlPW14VXRpbHMuY2xvbmUodGhpcy5kZWZhdWx0RWRnZVN0eWxlKTt0aGlzLmN1cnJlbnRWZXJ0ZXhTdHlsZT1teFV0aWxzLmNsb25lKHRoaXMuZGVmYXVsdFZlcnRleFN0eWxlKTt0aGlzLnN0YW5kYWxvbmU9bnVsbCE9az9rOiExO2E9dGhpcy5iYXNlVXJsO2M9YS5pbmRleE9mKCIvLyIpO3RoaXMuZG9tYWluUGF0aFVybD10aGlzLmRvbWFpblVybD0iIjswPGMmJihjPWEuaW5kZXhPZigiLyIsYysyKSwwPGMmJih0aGlzLmRvbWFpblVybD1hLnN1YnN0cmluZygwLGMpKSxjPWEubGFzdEluZGV4T2YoIi8iKSwwPGMmJih0aGlzLmRvbWFpblBhdGhVcmw9YS5zdWJzdHJpbmcoMCxjKzEpKSk7dGhpcy5pc0h0bWxMYWJlbD1mdW5jdGlvbihhKXthPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShhKTsKcmV0dXJuIG51bGwhPWE/IjEiPT1hLmh0bWx8fCJ3cmFwIj09YVtteENvbnN0YW50cy5TVFlMRV9XSElURV9TUEFDRV06ITF9O2lmKHRoaXMuZWRnZU1vZGUpe3ZhciBxPW51bGwsYj1udWxsLGU9bnVsbCxnPW51bGwscD0hMTt0aGlzLmFkZExpc3RlbmVyKG14RXZlbnQuRklSRV9NT1VTRV9FVkVOVCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGQpe2lmKCJtb3VzZURvd24iPT1kLmdldFByb3BlcnR5KCJldmVudE5hbWUiKSYmdGhpcy5pc0VuYWJsZWQoKSl7dmFyIGM9ZC5nZXRQcm9wZXJ0eSgiZXZlbnQiKSxmPWMuZ2V0U3RhdGUoKTtpZighbXhFdmVudC5pc0FsdERvd24oYy5nZXRFdmVudCgpKSYmbnVsbCE9ZilpZih0aGlzLm1vZGVsLmlzRWRnZShmLmNlbGwpKWlmKHE9bmV3IG14UG9pbnQoYy5nZXRHcmFwaFgoKSxjLmdldEdyYXBoWSgpKSxwPXRoaXMuaXNDZWxsU2VsZWN0ZWQoZi5jZWxsKSxlPWYsYj1jLG51bGwhPWYudGV4dCYmbnVsbCE9Zi50ZXh0LmJvdW5kaW5nQm94JiYKbXhVdGlscy5jb250YWlucyhmLnRleHQuYm91bmRpbmdCb3gsYy5nZXRHcmFwaFgoKSxjLmdldEdyYXBoWSgpKSlnPW14RXZlbnQuTEFCRUxfSEFORExFO2Vsc2V7dmFyIGw9dGhpcy5zZWxlY3Rpb25DZWxsc0hhbmRsZXIuZ2V0SGFuZGxlcihmLmNlbGwpO251bGwhPWwmJm51bGwhPWwuYmVuZHMmJjA8bC5iZW5kcy5sZW5ndGgmJihnPWwuZ2V0SGFuZGxlRm9yRXZlbnQoYykpfWVsc2UgaWYoIXRoaXMucGFubmluZ0hhbmRsZXIuaXNBY3RpdmUoKSYmKGw9dGhpcy5zZWxlY3Rpb25DZWxsc0hhbmRsZXIuZ2V0SGFuZGxlcihmLmNlbGwpLG51bGw9PWx8fG51bGw9PWwuZ2V0SGFuZGxlRm9yRXZlbnQoYykpKXt2YXIgbj1uZXcgbXhSZWN0YW5nbGUoYy5nZXRHcmFwaFgoKSxjLmdldEdyYXBoWSgpKTtuLmdyb3cobXhFdmVudC5pc1RvdWNoRXZlbnQoYy5nZXRFdmVudCgpKT9teFNoYXBlLnByb3RvdHlwZS5zdmdTdHJva2VUb2xlcmFuY2UtMTpteFNoYXBlLnByb3RvdHlwZS5zdmdTdHJva2VUb2xlcmFuY2UvCjIpO2lmKHRoaXMuaXNUYWJsZUNlbGwoZi5jZWxsKSl7dmFyIHU9dGhpcy5tb2RlbC5nZXRQYXJlbnQoZi5jZWxsKSxsPXRoaXMubW9kZWwuZ2V0UGFyZW50KHUpO2lmKG14VXRpbHMuaW50ZXJzZWN0cyhuLG5ldyBteFJlY3RhbmdsZShmLngsZi55LTEsZi53aWR0aCwxKSkmJnRoaXMubW9kZWwuZ2V0Q2hpbGRBdChsLDApIT11fHxteFV0aWxzLmludGVyc2VjdHMobixuZXcgbXhSZWN0YW5nbGUoZi54LGYueStmLmhlaWdodC0xLGYud2lkdGgsMSkpfHxteFV0aWxzLmludGVyc2VjdHMobixuZXcgbXhSZWN0YW5nbGUoZi54LTEsZi55LDEsZi5oZWlnaHQpKSYmdGhpcy5tb2RlbC5nZXRDaGlsZEF0KHUsMCkhPWYuY2VsbHx8bXhVdGlscy5pbnRlcnNlY3RzKG4sbmV3IG14UmVjdGFuZ2xlKGYueCtmLndpZHRoLTEsZi55LDEsZi5oZWlnaHQpKSlpZih1PXRoaXMuc2VsZWN0aW9uQ2VsbHNIYW5kbGVyLmlzSGFuZGxlZChsKSx0aGlzLnNlbGVjdENlbGxGb3JFdmVudChsLGMuZ2V0RXZlbnQoKSksCmw9dGhpcy5zZWxlY3Rpb25DZWxsc0hhbmRsZXIuZ2V0SGFuZGxlcihsKSxudWxsIT1sKXt2YXIgdD1sLmdldEhhbmRsZUZvckV2ZW50KGMpO251bGwhPXQmJihsLnN0YXJ0KGMuZ2V0R3JhcGhYKCksYy5nZXRHcmFwaFkoKSx0KSxsLmJsb2NrRGVsYXllZFNlbGVjdGlvbj0hdSxjLmNvbnN1bWUoKSl9fWZvcig7IWMuaXNDb25zdW1lZCgpJiZudWxsIT1mJiYodGhpcy5pc1RhYmxlQ2VsbChmLmNlbGwpfHx0aGlzLmlzVGFibGVSb3coZi5jZWxsKXx8dGhpcy5pc1RhYmxlKGYuY2VsbCkpOyl0aGlzLmlzU3dpbWxhbmUoZi5jZWxsKSYmKGw9dGhpcy5nZXRBY3R1YWxTdGFydFNpemUoZi5jZWxsKSwoMDxsLnh8fDA8bC53aWR0aCkmJm14VXRpbHMuaW50ZXJzZWN0cyhuLG5ldyBteFJlY3RhbmdsZShmLngrbC54LWwud2lkdGgtMSsoMD09bC54P2Yud2lkdGg6MCksZi55LDEsZi5oZWlnaHQpKXx8KDA8bC55fHwwPGwuaGVpZ2h0KSYmbXhVdGlscy5pbnRlcnNlY3RzKG4sbmV3IG14UmVjdGFuZ2xlKGYueCwKZi55K2wueS1sLmhlaWdodC0xKygwPT1sLnk/Zi5oZWlnaHQ6MCksZi53aWR0aCwxKSkpJiYodGhpcy5zZWxlY3RDZWxsRm9yRXZlbnQoZi5jZWxsLGMuZ2V0RXZlbnQoKSksbD10aGlzLnNlbGVjdGlvbkNlbGxzSGFuZGxlci5nZXRIYW5kbGVyKGYuY2VsbCksbnVsbCE9bCYmKHQ9bXhFdmVudC5DVVNUT01fSEFORExFLWwuY3VzdG9tSGFuZGxlcy5sZW5ndGgrMSxsLnN0YXJ0KGMuZ2V0R3JhcGhYKCksYy5nZXRHcmFwaFkoKSx0KSxjLmNvbnN1bWUoKSkpLGY9dGhpcy52aWV3LmdldFN0YXRlKHRoaXMubW9kZWwuZ2V0UGFyZW50KGYuY2VsbCkpfX19KSk7dGhpcy5hZGRNb3VzZUxpc3RlbmVyKHttb3VzZURvd246ZnVuY3Rpb24oYSxiKXt9LG1vdXNlTW92ZTpteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGQpe3ZhciBjPXRoaXMuc2VsZWN0aW9uQ2VsbHNIYW5kbGVyLmhhbmRsZXJzLm1hcCxmO2ZvcihmIGluIGMpaWYobnVsbCE9Y1tmXS5pbmRleClyZXR1cm47aWYodGhpcy5pc0VuYWJsZWQoKSYmCiF0aGlzLnBhbm5pbmdIYW5kbGVyLmlzQWN0aXZlKCkmJiFteEV2ZW50LmlzQWx0RG93bihkLmdldEV2ZW50KCkpKWlmKGY9dGhpcy50b2xlcmFuY2UsbnVsbCE9cSYmbnVsbCE9ZSYmbnVsbCE9Yil7aWYoYz1lLE1hdGguYWJzKHEueC1kLmdldEdyYXBoWCgpKT5mfHxNYXRoLmFicyhxLnktZC5nZXRHcmFwaFkoKSk+Zil7dGhpcy5pc0NlbGxTZWxlY3RlZChjLmNlbGwpfHx0aGlzLnNlbGVjdENlbGxGb3JFdmVudChjLmNlbGwsZC5nZXRFdmVudCgpKTt2YXIgbD10aGlzLnNlbGVjdGlvbkNlbGxzSGFuZGxlci5nZXRIYW5kbGVyKGMuY2VsbCk7aWYobnVsbCE9bCYmbnVsbCE9bC5iZW5kcyYmMDxsLmJlbmRzLmxlbmd0aCl7Zj1sLmdldEhhbmRsZUZvckV2ZW50KGIpO3ZhciBuPXRoaXMudmlldy5nZXRFZGdlU3R5bGUoYyksdT1uPT1teEVkZ2VTdHlsZS5FbnRpdHlSZWxhdGlvbjtwfHxnIT1teEV2ZW50LkxBQkVMX0hBTkRMRXx8KGY9Zyk7aWYodSYmMCE9ZiYmZiE9bC5iZW5kcy5sZW5ndGgtCjEmJmYhPW14RXZlbnQuTEFCRUxfSEFORExFKSF1fHxudWxsPT1jLnZpc2libGVTb3VyY2VTdGF0ZSYmbnVsbD09Yy52aXNpYmxlVGFyZ2V0U3RhdGV8fCh0aGlzLmdyYXBoSGFuZGxlci5yZXNldCgpLGQuY29uc3VtZSgpKTtlbHNlIGlmKGY9PW14RXZlbnQuTEFCRUxfSEFORExFfHwwPT1mfHxudWxsIT1jLnZpc2libGVTb3VyY2VTdGF0ZXx8Zj09bC5iZW5kcy5sZW5ndGgtMXx8bnVsbCE9Yy52aXNpYmxlVGFyZ2V0U3RhdGUpdXx8Zj09bXhFdmVudC5MQUJFTF9IQU5ETEV8fCh1PWMuYWJzb2x1dGVQb2ludHMsbnVsbCE9dSYmKG51bGw9PW4mJm51bGw9PWZ8fG49PW14RWRnZVN0eWxlLk9ydGhDb25uZWN0b3IpJiYoZj1nLG51bGw9PWYmJihmPW5ldyBteFJlY3RhbmdsZShxLngscS55KSxmLmdyb3cobXhFZGdlSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlSW1hZ2Uud2lkdGgvMiksbXhVdGlscy5jb250YWlucyhmLHVbMF0ueCx1WzBdLnkpP2Y9MDpteFV0aWxzLmNvbnRhaW5zKGYsdVt1Lmxlbmd0aC0KMV0ueCx1W3UubGVuZ3RoLTFdLnkpP2Y9bC5iZW5kcy5sZW5ndGgtMTpudWxsIT1uJiYoMj09dS5sZW5ndGh8fDM9PXUubGVuZ3RoJiYoMD09TWF0aC5yb3VuZCh1WzBdLngtdVsxXS54KSYmMD09TWF0aC5yb3VuZCh1WzFdLngtdVsyXS54KXx8MD09TWF0aC5yb3VuZCh1WzBdLnktdVsxXS55KSYmMD09TWF0aC5yb3VuZCh1WzFdLnktdVsyXS55KSkpP2Y9MjooZj1teFV0aWxzLmZpbmROZWFyZXN0U2VnbWVudChjLHEueCxxLnkpLGY9bnVsbD09bj9teEV2ZW50LlZJUlRVQUxfSEFORExFLWY6ZisxKSkpLG51bGw9PWYmJihmPW14RXZlbnQuVklSVFVBTF9IQU5ETEUpKSxsLnN0YXJ0KGQuZ2V0R3JhcGhYKCksZC5nZXRHcmFwaFgoKSxmKSxnPXE9Yj1lPW51bGwscD0hMSxkLmNvbnN1bWUoKSx0aGlzLmdyYXBoSGFuZGxlci5yZXNldCgpfX19ZWxzZSBpZihjPWQuZ2V0U3RhdGUoKSxudWxsIT1jKXtsPW51bGw7aWYodGhpcy5tb2RlbC5pc0VkZ2UoYy5jZWxsKSl7aWYoZj1uZXcgbXhSZWN0YW5nbGUoZC5nZXRHcmFwaFgoKSwKZC5nZXRHcmFwaFkoKSksZi5ncm93KG14RWRnZUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUltYWdlLndpZHRoLzIpLHU9Yy5hYnNvbHV0ZVBvaW50cyxudWxsIT11KWlmKG51bGwhPWMudGV4dCYmbnVsbCE9Yy50ZXh0LmJvdW5kaW5nQm94JiZteFV0aWxzLmNvbnRhaW5zKGMudGV4dC5ib3VuZGluZ0JveCxkLmdldEdyYXBoWCgpLGQuZ2V0R3JhcGhZKCkpKWw9Im1vdmUiO2Vsc2UgaWYobXhVdGlscy5jb250YWlucyhmLHVbMF0ueCx1WzBdLnkpfHxteFV0aWxzLmNvbnRhaW5zKGYsdVt1Lmxlbmd0aC0xXS54LHVbdS5sZW5ndGgtMV0ueSkpbD0icG9pbnRlciI7ZWxzZSBpZihudWxsIT1jLnZpc2libGVTb3VyY2VTdGF0ZXx8bnVsbCE9Yy52aXNpYmxlVGFyZ2V0U3RhdGUpZj10aGlzLnZpZXcuZ2V0RWRnZVN0eWxlKGMpLGw9ImNyb3NzaGFpciIsZiE9bXhFZGdlU3R5bGUuRW50aXR5UmVsYXRpb24mJnRoaXMuaXNPcnRob2dvbmFsKGMpJiYoZj1teFV0aWxzLmZpbmROZWFyZXN0U2VnbWVudChjLApkLmdldEdyYXBoWCgpLGQuZ2V0R3JhcGhZKCkpLGY8dS5sZW5ndGgtMSYmMDw9ZiYmKGw9MD09TWF0aC5yb3VuZCh1W2ZdLngtdVtmKzFdLngpPyJjb2wtcmVzaXplIjoicm93LXJlc2l6ZSIpKX1lbHNle2Y9bmV3IG14UmVjdGFuZ2xlKGQuZ2V0R3JhcGhYKCksZC5nZXRHcmFwaFkoKSk7Zi5ncm93KG14U2hhcGUucHJvdG90eXBlLnN2Z1N0cm9rZVRvbGVyYW5jZS8yKTtpZih0aGlzLmlzVGFibGVDZWxsKGMuY2VsbCkpaWYodT10aGlzLm1vZGVsLmdldFBhcmVudChjLmNlbGwpLG49dGhpcy5tb2RlbC5nZXRQYXJlbnQodSksbXhVdGlscy5pbnRlcnNlY3RzKGYsbmV3IG14UmVjdGFuZ2xlKGMueC0xLGMueSwxLGMuaGVpZ2h0KSkmJnRoaXMubW9kZWwuZ2V0Q2hpbGRBdCh1LDApIT1jLmNlbGx8fG14VXRpbHMuaW50ZXJzZWN0cyhmLG5ldyBteFJlY3RhbmdsZShjLngrYy53aWR0aC0xLGMueSwxLGMuaGVpZ2h0KSkpbD0iY29sLXJlc2l6ZSI7ZWxzZSBpZihteFV0aWxzLmludGVyc2VjdHMoZiwKbmV3IG14UmVjdGFuZ2xlKGMueCxjLnktMSxjLndpZHRoLDEpKSYmdGhpcy5tb2RlbC5nZXRDaGlsZEF0KG4sMCkhPXV8fG14VXRpbHMuaW50ZXJzZWN0cyhmLG5ldyBteFJlY3RhbmdsZShjLngsYy55K2MuaGVpZ2h0LTEsYy53aWR0aCwxKSkpbD0icm93LXJlc2l6ZSI7Zm9yKHU9YztudWxsPT1sJiZudWxsIT11JiYodGhpcy5pc1RhYmxlQ2VsbCh1LmNlbGwpfHx0aGlzLmlzVGFibGVSb3codS5jZWxsKXx8dGhpcy5pc1RhYmxlKHUuY2VsbCkpOyl0aGlzLmlzU3dpbWxhbmUodS5jZWxsKSYmKG49dGhpcy5nZXRBY3R1YWxTdGFydFNpemUodS5jZWxsKSwoMDxuLnh8fDA8bi53aWR0aCkmJm14VXRpbHMuaW50ZXJzZWN0cyhmLG5ldyBteFJlY3RhbmdsZSh1Lngrbi54LW4ud2lkdGgtMSsoMD09bi54P3Uud2lkdGg6MCksdS55LDEsdS5oZWlnaHQpKT9sPSJjb2wtcmVzaXplIjooMDxuLnl8fDA8bi5oZWlnaHQpJiZteFV0aWxzLmludGVyc2VjdHMoZixuZXcgbXhSZWN0YW5nbGUodS54LAp1Lnkrbi55LW4uaGVpZ2h0LTErKDA9PW4ueT91LmhlaWdodDowKSx1LndpZHRoLDEpKSYmKGw9InJvdy1yZXNpemUiKSksdT10aGlzLnZpZXcuZ2V0U3RhdGUodGhpcy5tb2RlbC5nZXRQYXJlbnQodS5jZWxsKSl9bnVsbCE9bCYmYy5zZXRDdXJzb3IobCl9fSksbW91c2VVcDpteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGQpe2c9cT1iPWU9bnVsbH0pfSl9dGhpcy5jZWxsUmVuZGVyZXIuZ2V0TGFiZWxWYWx1ZT1mdW5jdGlvbihhKXt2YXIgYj1teENlbGxSZW5kZXJlci5wcm90b3R5cGUuZ2V0TGFiZWxWYWx1ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YS52aWV3LmdyYXBoLmlzSHRtbExhYmVsKGEuY2VsbCkmJihiPTEhPWEuc3R5bGUuaHRtbD9teFV0aWxzLmh0bWxFbnRpdGllcyhiLCExKTphLnZpZXcuZ3JhcGguc2FuaXRpemVIdG1sKGIpKTtyZXR1cm4gYn07aWYoInVuZGVmaW5lZCIhPT10eXBlb2YgbXhWZXJ0ZXhIYW5kbGVyKXt0aGlzLnNldENvbm5lY3RhYmxlKCEwKTsKdGhpcy5zZXREcm9wRW5hYmxlZCghMCk7dGhpcy5zZXRQYW5uaW5nKCEwKTt0aGlzLnNldFRvb2x0aXBzKCEwKTt0aGlzLnNldEFsbG93TG9vcHMoITApO3RoaXMuYWxsb3dBdXRvUGFubmluZz0hMDt0aGlzLmNvbnN0cmFpbkNoaWxkcmVuPXRoaXMucmVzZXRFZGdlc09uQ29ubmVjdD0hMTt0aGlzLmNvbnN0cmFpblJlbGF0aXZlQ2hpbGRyZW49ITA7dGhpcy5ncmFwaEhhbmRsZXIuc2Nyb2xsT25Nb3ZlPSExO3RoaXMuZ3JhcGhIYW5kbGVyLnNjYWxlR3JpZD0hMDt0aGlzLmNvbm5lY3Rpb25IYW5kbGVyLnNldENyZWF0ZVRhcmdldCghMSk7dGhpcy5jb25uZWN0aW9uSGFuZGxlci5pbnNlcnRCZWZvcmVTb3VyY2U9ITA7dGhpcy5jb25uZWN0aW9uSGFuZGxlci5pc1ZhbGlkU291cmNlPWZ1bmN0aW9uKGEsYil7cmV0dXJuITF9O3RoaXMuYWx0ZXJuYXRlRWRnZVN0eWxlPSJ2ZXJ0aWNhbCI7bnVsbD09ZCYmdGhpcy5sb2FkU3R5bGVzaGVldCgpO3ZhciBsPXRoaXMuZ3JhcGhIYW5kbGVyLmdldEd1aWRlU3RhdGVzOwp0aGlzLmdyYXBoSGFuZGxlci5nZXRHdWlkZVN0YXRlcz1mdW5jdGlvbigpe3ZhciBhPWwuYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKHRoaXMuZ3JhcGgucGFnZVZpc2libGUpe2Zvcih2YXIgYj1bXSxlPXRoaXMuZ3JhcGgucGFnZUZvcm1hdCxkPXRoaXMuZ3JhcGgucGFnZVNjYWxlLGM9ZS53aWR0aCpkLGU9ZS5oZWlnaHQqZCxkPXRoaXMuZ3JhcGgudmlldy50cmFuc2xhdGUsZj10aGlzLmdyYXBoLnZpZXcuc2NhbGUsZz10aGlzLmdyYXBoLmdldFBhZ2VMYXlvdXQoKSxwPTA7cDxnLndpZHRoO3ArKyliLnB1c2gobmV3IG14UmVjdGFuZ2xlKCgoZy54K3ApKmMrZC54KSpmLChnLnkqZStkLnkpKmYsYypmLGUqZikpO2ZvcihwPTE7cDxnLmhlaWdodDtwKyspYi5wdXNoKG5ldyBteFJlY3RhbmdsZSgoZy54KmMrZC54KSpmLCgoZy55K3ApKmUrZC55KSpmLGMqZixlKmYpKTthPWIuY29uY2F0KGEpfXJldHVybiBhfTtteERyYWdTb3VyY2UucHJvdG90eXBlLmRyYWdFbGVtZW50WkluZGV4PQpteFBvcHVwTWVudS5wcm90b3R5cGUuekluZGV4O214R3VpZGUucHJvdG90eXBlLmdldEd1aWRlQ29sb3I9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbnVsbD09YS5jZWxsPyIjZmZhNTAwIjpteENvbnN0YW50cy5HVUlERV9DT0xPUn07dGhpcy5ncmFwaEhhbmRsZXIuY3JlYXRlUHJldmlld1NoYXBlPWZ1bmN0aW9uKGEpe3RoaXMucHJldmlld0NvbG9yPSIjMDAwMDAwIj09dGhpcy5ncmFwaC5iYWNrZ3JvdW5kPyIjZmZmZmZmIjpteEdyYXBoSGFuZGxlci5wcm90b3R5cGUucHJldmlld0NvbG9yO3JldHVybiBteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlUHJldmlld1NoYXBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dmFyIG49dGhpcy5ncmFwaEhhbmRsZXIuZ2V0Q2VsbHM7dGhpcy5ncmFwaEhhbmRsZXIuZ2V0Q2VsbHM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPW4uYXBwbHkodGhpcyxhcmd1bWVudHMpLGU9bmV3IG14RGljdGlvbmFyeSxkPVtdLGM9MDtjPGIubGVuZ3RoO2MrKyl7dmFyIGY9CnRoaXMuZ3JhcGguaXNUYWJsZVJvdyhiW2NdKSYmdGhpcy5ncmFwaC5pc0NlbGxTZWxlY3RlZChiW2NdKT9iW2NdOnRoaXMuZ3JhcGguZ2V0Q29tcG9zaXRlUGFyZW50KGJbY10pO251bGw9PWZ8fGUuZ2V0KGYpfHwoZS5wdXQoZiwhMCksZC5wdXNoKGYpKX1yZXR1cm4gZH07dmFyIHY9dGhpcy5ncmFwaEhhbmRsZXIuc3RhcnQ7dGhpcy5ncmFwaEhhbmRsZXIuc3RhcnQ9ZnVuY3Rpb24oYSxiLGUsZCl7YT10aGlzLmdyYXBoLmdldENvbXBvc2l0ZVBhcmVudChhKTt2LmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dGhpcy5jb25uZWN0aW9uSGFuZGxlci5jcmVhdGVUYXJnZXRWZXJ0ZXg9ZnVuY3Rpb24oYSxiKXtiPXRoaXMuZ3JhcGguZ2V0Q29tcG9zaXRlUGFyZW50KGIpO3JldHVybiBteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVUYXJnZXRWZXJ0ZXguYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgdD1uZXcgbXhSdWJiZXJiYW5kKHRoaXMpO3RoaXMuZ2V0UnViYmVyYmFuZD0KZnVuY3Rpb24oKXtyZXR1cm4gdH07dmFyIHk9KG5ldyBEYXRlKS5nZXRUaW1lKCkseD0wLEU9dGhpcy5jb25uZWN0aW9uSGFuZGxlci5tb3VzZU1vdmU7dGhpcy5jb25uZWN0aW9uSGFuZGxlci5tb3VzZU1vdmU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmN1cnJlbnRTdGF0ZTtFLmFwcGx5KHRoaXMsYXJndW1lbnRzKTthIT10aGlzLmN1cnJlbnRTdGF0ZT8oeT0obmV3IERhdGUpLmdldFRpbWUoKSx4PTApOng9KG5ldyBEYXRlKS5nZXRUaW1lKCkteX07dmFyIEE9dGhpcy5jb25uZWN0aW9uSGFuZGxlci5pc091dGxpbmVDb25uZWN0RXZlbnQ7dGhpcy5jb25uZWN0aW9uSGFuZGxlci5pc091dGxpbmVDb25uZWN0RXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPXRoaXMuY3VycmVudFN0YXRlJiZhLmdldFN0YXRlKCk9PXRoaXMuY3VycmVudFN0YXRlJiYyRTM8eHx8KG51bGw9PXRoaXMuY3VycmVudFN0YXRlfHwiMCIhPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5jdXJyZW50U3RhdGUuc3R5bGUsCiJvdXRsaW5lQ29ubmVjdCIsIjEiKSkmJkEuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgQz10aGlzLmlzVG9nZ2xlRXZlbnQ7dGhpcy5pc1RvZ2dsZUV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiBDLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8IW14Q2xpZW50LklTX0NIUk9NRU9TJiZteEV2ZW50LmlzU2hpZnREb3duKGEpfTt2YXIgej10LmlzRm9yY2VSdWJiZXJiYW5kRXZlbnQ7dC5pc0ZvcmNlUnViYmVyYmFuZEV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiB6LmFwcGx5KHRoaXMsYXJndW1lbnRzKSYmIW14RXZlbnQuaXNTaGlmdERvd24oYS5nZXRFdmVudCgpKSYmIW14RXZlbnQuaXNDb250cm9sRG93bihhLmdldEV2ZW50KCkpfHxteENsaWVudC5JU19DSFJPTUVPUyYmbXhFdmVudC5pc1NoaWZ0RG93bihhLmdldEV2ZW50KCkpfHxteFV0aWxzLmhhc1Njcm9sbGJhcnModGhpcy5ncmFwaC5jb250YWluZXIpJiZteENsaWVudC5JU19GRiYmbXhDbGllbnQuSVNfV0lOJiZudWxsPT1hLmdldFN0YXRlKCkmJgpteEV2ZW50LmlzVG91Y2hFdmVudChhLmdldEV2ZW50KCkpfTt2YXIgRD1udWxsO3RoaXMucGFubmluZ0hhbmRsZXIuYWRkTGlzdGVuZXIobXhFdmVudC5QQU5fU1RBUlQsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmlzRW5hYmxlZCgpJiYoRD10aGlzLmNvbnRhaW5lci5zdHlsZS5jdXJzb3IsdGhpcy5jb250YWluZXIuc3R5bGUuY3Vyc29yPSJtb3ZlIil9KSk7dGhpcy5wYW5uaW5nSGFuZGxlci5hZGRMaXN0ZW5lcihteEV2ZW50LlBBTl9FTkQsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmlzRW5hYmxlZCgpJiYodGhpcy5jb250YWluZXIuc3R5bGUuY3Vyc29yPUQpfSkpO3RoaXMucG9wdXBNZW51SGFuZGxlci5hdXRvRXhwYW5kPSEwO3RoaXMucG9wdXBNZW51SGFuZGxlci5pc1NlbGVjdE9uUG9wdXA9ZnVuY3Rpb24oYSl7cmV0dXJuIG14RXZlbnQuaXNNb3VzZUV2ZW50KGEuZ2V0RXZlbnQoKSl9O3ZhciBHPXRoaXMuY2xpY2s7dGhpcy5jbGljaz0KZnVuY3Rpb24oYSl7dmFyIGI9bnVsbD09YS5zdGF0ZSYmbnVsbCE9YS5zb3VyY2VTdGF0ZSYmdGhpcy5pc0NlbGxMb2NrZWQoYS5zb3VyY2VTdGF0ZS5jZWxsKTtpZih0aGlzLmlzRW5hYmxlZCgpJiYhYnx8YS5pc0NvbnN1bWVkKCkpcmV0dXJuIEcuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciBlPWI/YS5zb3VyY2VTdGF0ZS5jZWxsOmEuZ2V0Q2VsbCgpO251bGwhPWUmJihlPXRoaXMuZ2V0Q2xpY2thYmxlTGlua0ZvckNlbGwoZSksbnVsbCE9ZSYmKHRoaXMuaXNDdXN0b21MaW5rKGUpP3RoaXMuY3VzdG9tTGlua0NsaWNrZWQoZSk6dGhpcy5vcGVuTGluayhlKSkpO3RoaXMuaXNFbmFibGVkKCkmJmImJnRoaXMuY2xlYXJTZWxlY3Rpb24oKX07dGhpcy50b29sdGlwSGFuZGxlci5nZXRTdGF0ZUZvckV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiBhLnNvdXJjZVN0YXRlfTt0aGlzLmdldEN1cnNvckZvck1vdXNlRXZlbnQ9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbD09YS5zdGF0ZSYmbnVsbCE9CmEuc291cmNlU3RhdGUmJnRoaXMuaXNDZWxsTG9ja2VkKGEuc291cmNlU3RhdGUuY2VsbCk7cmV0dXJuIHRoaXMuZ2V0Q3Vyc29yRm9yQ2VsbChiP2Euc291cmNlU3RhdGUuY2VsbDphLmdldENlbGwoKSl9O3ZhciBGPXRoaXMuZ2V0Q3Vyc29yRm9yQ2VsbDt0aGlzLmdldEN1cnNvckZvckNlbGw9ZnVuY3Rpb24oYSl7aWYoIXRoaXMuaXNFbmFibGVkKCl8fHRoaXMuaXNDZWxsTG9ja2VkKGEpKXtpZihudWxsIT10aGlzLmdldENsaWNrYWJsZUxpbmtGb3JDZWxsKGEpKXJldHVybiJwb2ludGVyIjtpZih0aGlzLmlzQ2VsbExvY2tlZChhKSlyZXR1cm4iZGVmYXVsdCJ9cmV0dXJuIEYuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt0aGlzLnNlbGVjdFJlZ2lvbj1mdW5jdGlvbihhLGIpe3ZhciBlPXRoaXMuZ2V0QWxsQ2VsbHMoYS54LGEueSxhLndpZHRoLGEuaGVpZ2h0KTt0aGlzLnNlbGVjdENlbGxzRm9yRXZlbnQoZSxiKTtyZXR1cm4gZX07dGhpcy5nZXRBbGxDZWxscz1mdW5jdGlvbihhLApiLGUsZCxjLGYpe2Y9bnVsbCE9Zj9mOltdO2lmKDA8ZXx8MDxkKXt2YXIgZz10aGlzLmdldE1vZGVsKCksbD1hK2UscD1iK2Q7bnVsbD09YyYmKGM9dGhpcy5nZXRDdXJyZW50Um9vdCgpLG51bGw9PWMmJihjPWcuZ2V0Um9vdCgpKSk7aWYobnVsbCE9Yylmb3IodmFyIG49Zy5nZXRDaGlsZENvdW50KGMpLHU9MDt1PG47dSsrKXt2YXIgdD1nLmdldENoaWxkQXQoYyx1KSxCPXRoaXMudmlldy5nZXRTdGF0ZSh0KTtpZihudWxsIT1CJiZ0aGlzLmlzQ2VsbFZpc2libGUodCkmJiIxIiE9bXhVdGlscy5nZXRWYWx1ZShCLnN0eWxlLCJsb2NrZWQiLCIwIikpe3ZhciBrPW14VXRpbHMuZ2V0VmFsdWUoQi5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTil8fDA7MCE9ayYmKEI9bXhVdGlscy5nZXRCb3VuZGluZ0JveChCLGspKTsoZy5pc0VkZ2UodCl8fGcuaXNWZXJ0ZXgodCkpJiZCLng+PWEmJkIueStCLmhlaWdodDw9cCYmQi55Pj1iJiZCLngrQi53aWR0aDw9bCYmZi5wdXNoKHQpOwp0aGlzLmdldEFsbENlbGxzKGEsYixlLGQsdCxmKX19fXJldHVybiBmfTt2YXIgSD10aGlzLmdyYXBoSGFuZGxlci5zaG91bGRSZW1vdmVDZWxsc0Zyb21QYXJlbnQ7dGhpcy5ncmFwaEhhbmRsZXIuc2hvdWxkUmVtb3ZlQ2VsbHNGcm9tUGFyZW50PWZ1bmN0aW9uKGEsYixlKXtyZXR1cm4gdGhpcy5ncmFwaC5pc0NlbGxTZWxlY3RlZChhKT8hMTpILmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dGhpcy5pc0NlbGxMb2NrZWQ9ZnVuY3Rpb24oYSl7Zm9yKGE9dGhpcy52aWV3LmdldFN0YXRlKGEpO251bGwhPWE7KXtpZigiMSI9PW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSwibG9ja2VkIiwiMCIpKXJldHVybiEwO2E9dGhpcy52aWV3LmdldFN0YXRlKHRoaXMubW9kZWwuZ2V0UGFyZW50KGEuY2VsbCkpfXJldHVybiExfTt2YXIgSj1udWxsO3RoaXMuYWRkTGlzdGVuZXIobXhFdmVudC5GSVJFX01PVVNFX0VWRU5ULG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYil7aWYoIm1vdXNlRG93biI9PQpiLmdldFByb3BlcnR5KCJldmVudE5hbWUiKSl7dmFyIGU9Yi5nZXRQcm9wZXJ0eSgiZXZlbnQiKS5nZXRTdGF0ZSgpO0o9bnVsbD09ZXx8dGhpcy5pc1NlbGVjdGlvbkVtcHR5KCl8fHRoaXMuaXNDZWxsU2VsZWN0ZWQoZS5jZWxsKT9udWxsOnRoaXMuZ2V0U2VsZWN0aW9uQ2VsbHMoKX19KSk7dGhpcy5hZGRMaXN0ZW5lcihteEV2ZW50LlRBUF9BTkRfSE9MRCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIpe2lmKCFteEV2ZW50LmlzTXVsdGlUb3VjaEV2ZW50KGIpKXt2YXIgZT1iLmdldFByb3BlcnR5KCJldmVudCIpLGQ9Yi5nZXRQcm9wZXJ0eSgiY2VsbCIpO251bGw9PWQ/KGU9bXhVdGlscy5jb252ZXJ0UG9pbnQodGhpcy5jb250YWluZXIsbXhFdmVudC5nZXRDbGllbnRYKGUpLG14RXZlbnQuZ2V0Q2xpZW50WShlKSksdC5zdGFydChlLngsZS55KSk6bnVsbCE9Sj90aGlzLmFkZFNlbGVjdGlvbkNlbGxzKEopOjE8dGhpcy5nZXRTZWxlY3Rpb25Db3VudCgpJiZ0aGlzLmlzQ2VsbFNlbGVjdGVkKGQpJiYKdGhpcy5yZW1vdmVTZWxlY3Rpb25DZWxsKGQpO0o9bnVsbDtiLmNvbnN1bWUoKX19KSk7dGhpcy5jb25uZWN0aW9uSGFuZGxlci5zZWxlY3RDZWxscz1mdW5jdGlvbihhLGIpe3RoaXMuZ3JhcGguc2V0U2VsZWN0aW9uQ2VsbChifHxhKX07dGhpcy5jb25uZWN0aW9uSGFuZGxlci5jb25zdHJhaW50SGFuZGxlci5pc1N0YXRlSWdub3JlZD1mdW5jdGlvbihhLGIpe3ZhciBlPWEudmlldy5ncmFwaDtyZXR1cm4gYiYmKGUuaXNDZWxsU2VsZWN0ZWQoYS5jZWxsKXx8ZS5pc1RhYmxlUm93KGEuY2VsbCkmJmUuc2VsZWN0aW9uQ2VsbHNIYW5kbGVyLmlzSGFuZGxlZChlLm1vZGVsLmdldFBhcmVudChhLmNlbGwpKSl9O3RoaXMuc2VsZWN0aW9uTW9kZWwuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNvbm5lY3Rpb25IYW5kbGVyLmNvbnN0cmFpbnRIYW5kbGVyO251bGwhPWEuY3VycmVudEZvY3VzJiZhLmlzU3RhdGVJZ25vcmVkKGEuY3VycmVudEZvY3VzLAohMCkmJihhLmN1cnJlbnRGb2N1cz1udWxsLGEuY29uc3RyYWludHM9bnVsbCxhLmRlc3Ryb3lJY29ucygpKTthLmRlc3Ryb3lGb2N1c0hpZ2hsaWdodCgpfSkpO0dyYXBoLnRvdWNoU3R5bGUmJnRoaXMuaW5pdFRvdWNoKCk7dmFyIHU9dGhpcy51cGRhdGVNb3VzZUV2ZW50O3RoaXMudXBkYXRlTW91c2VFdmVudD1mdW5jdGlvbihhKXthPXUuYXBwbHkodGhpcyxhcmd1bWVudHMpO251bGwhPWEuc3RhdGUmJnRoaXMuaXNDZWxsTG9ja2VkKGEuZ2V0Q2VsbCgpKSYmKGEuc3RhdGU9bnVsbCk7cmV0dXJuIGF9fXRoaXMuY3VycmVudFRyYW5zbGF0ZT1uZXcgbXhQb2ludCgwLDApfTtHcmFwaC50b3VjaFN0eWxlPW14Q2xpZW50LklTX1RPVUNIfHxteENsaWVudC5JU19GRiYmbXhDbGllbnQuSVNfV0lOfHwwPG5hdmlnYXRvci5tYXhUb3VjaFBvaW50c3x8MDxuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50c3x8bnVsbD09d2luZG93LnVybFBhcmFtc3x8IjEiPT11cmxQYXJhbXMudG91Y2g7CkdyYXBoLmZpbGVTdXBwb3J0PW51bGwhPXdpbmRvdy5GaWxlJiZudWxsIT13aW5kb3cuRmlsZVJlYWRlciYmbnVsbCE9d2luZG93LkZpbGVMaXN0JiYobnVsbD09d2luZG93LnVybFBhcmFtc3x8IjAiIT11cmxQYXJhbXMuZmlsZXN1cHBvcnQpO0dyYXBoLmxpbmVKdW1wc0VuYWJsZWQ9ITA7R3JhcGguZGVmYXVsdEp1bXBTaXplPTY7R3JhcGgubWluVGFibGVDb2x1bW5XaWR0aD0yMDtHcmFwaC5taW5UYWJsZVJvd0hlaWdodD0yMDtHcmFwaC5mb3JlaWduT2JqZWN0V2FybmluZ1RleHQ9IlZpZXdlciBkb2VzIG5vdCBzdXBwb3J0IGZ1bGwgU1ZHIDEuMSI7R3JhcGguZm9yZWlnbk9iamVjdFdhcm5pbmdMaW5rPSJodHRwczovL2Rlc2suZHJhdy5pby9zdXBwb3J0L3NvbHV0aW9ucy9hcnRpY2xlcy8xNjAwMDA0MjQ4NyI7CkdyYXBoLmNyZWF0ZVN2Z0ltYWdlPWZ1bmN0aW9uKGEsYyxmLGQsbSl7Zj11bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoJzwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iJythKydweCIgaGVpZ2h0PSInK2MrJ3B4IiAnKyhudWxsIT1kJiZudWxsIT1tPyd2aWV3Qm94PSIwIDAgJytkKyIgIittKyciICc6IiIpKyd2ZXJzaW9uPSIxLjEiPicrZisiPC9zdmc+IikpO3JldHVybiBuZXcgbXhJbWFnZSgiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwiKyh3aW5kb3cuYnRvYT9idG9hKGYpOkJhc2U2NC5lbmNvZGUoZiwhMCkpLGEsYyl9OwpHcmFwaC56YXBHcmVtbGlucz1mdW5jdGlvbihhKXtmb3IodmFyIGM9W10sZj0wO2Y8YS5sZW5ndGg7ZisrKXt2YXIgZD1hLmNoYXJDb2RlQXQoZik7KDMyPD1kfHw5PT1kfHwxMD09ZHx8MTM9PWQpJiY2NTUzNSE9ZCYmNjU1MzQhPWQmJmMucHVzaChhLmNoYXJBdChmKSl9cmV0dXJuIGMuam9pbigiIil9O0dyYXBoLnN0cmluZ1RvQnl0ZXM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBjPUFycmF5KGEubGVuZ3RoKSxmPTA7ZjxhLmxlbmd0aDtmKyspY1tmXT1hLmNoYXJDb2RlQXQoZik7cmV0dXJuIGN9O0dyYXBoLmJ5dGVzVG9TdHJpbmc9ZnVuY3Rpb24oYSl7Zm9yKHZhciBjPUFycmF5KGEubGVuZ3RoKSxmPTA7ZjxhLmxlbmd0aDtmKyspY1tmXT1TdHJpbmcuZnJvbUNoYXJDb2RlKGFbZl0pO3JldHVybiBjLmpvaW4oIiIpfTtHcmFwaC5jb21wcmVzc05vZGU9ZnVuY3Rpb24oYSxjKXt2YXIgZj1teFV0aWxzLmdldFhtbChhKTtyZXR1cm4gR3JhcGguY29tcHJlc3MoYz9mOkdyYXBoLnphcEdyZW1saW5zKGYpKX07CkdyYXBoLmNvbXByZXNzPWZ1bmN0aW9uKGEsYyl7aWYobnVsbD09YXx8MD09YS5sZW5ndGh8fCJ1bmRlZmluZWQiPT09dHlwZW9mIHBha28pcmV0dXJuIGE7dmFyIGY9Yz9wYWtvLmRlZmxhdGUoZW5jb2RlVVJJQ29tcG9uZW50KGEpLHt0bzoic3RyaW5nIn0pOnBha28uZGVmbGF0ZVJhdyhlbmNvZGVVUklDb21wb25lbnQoYSkse3RvOiJzdHJpbmcifSk7cmV0dXJuIHdpbmRvdy5idG9hP2J0b2EoZik6QmFzZTY0LmVuY29kZShmLCEwKX07R3JhcGguZGVjb21wcmVzcz1mdW5jdGlvbihhLGMsZil7aWYobnVsbD09YXx8MD09YS5sZW5ndGh8fCJ1bmRlZmluZWQiPT09dHlwZW9mIHBha28pcmV0dXJuIGE7YT13aW5kb3cuYXRvYj9hdG9iKGEpOkJhc2U2NC5kZWNvZGUoYSwhMCk7Yz1kZWNvZGVVUklDb21wb25lbnQoYz9wYWtvLmluZmxhdGUoYSx7dG86InN0cmluZyJ9KTpwYWtvLmluZmxhdGVSYXcoYSx7dG86InN0cmluZyJ9KSk7cmV0dXJuIGY/YzpHcmFwaC56YXBHcmVtbGlucyhjKX07CkdyYXBoLnJlbW92ZVBhc3RlRm9ybWF0dGluZz1mdW5jdGlvbihhKXtmb3IoO251bGwhPWE7KW51bGwhPWEuZmlyc3RDaGlsZCYmR3JhcGgucmVtb3ZlUGFzdGVGb3JtYXR0aW5nKGEuZmlyc3RDaGlsZCksYS5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVCYmbnVsbCE9YS5zdHlsZSYmKGEuc3R5bGUud2hpdGVTcGFjZT0iIiwiIzAwMDAwMCI9PWEuc3R5bGUuY29sb3ImJihhLnN0eWxlLmNvbG9yPSIiKSksYT1hLm5leHRTaWJsaW5nfTtHcmFwaC5zYW5pdGl6ZUh0bWw9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gaHRtbF9zYW5pdGl6ZShhLGZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiYiamF2YXNjcmlwdDoiIT09YS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDAsMTEpP2E6bnVsbH0sZnVuY3Rpb24oYSl7cmV0dXJuIGF9KX07R3JhcGguaXNMaW5rPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiZHcmFwaC5saW5rUGF0dGVybi50ZXN0KGEpfTsKR3JhcGgubGlua1BhdHRlcm49L14oaHR0cHM/OlwvXC8pPygoKFthLXpcZF0oW2EtelxkLV0qW2EtelxkXSkqKVwuKStbYS16XXsyLH18KChcZHsxLDN9XC4pezN9XGR7MSwzfSkpKFw6XGQrKT8oXC9bLWEtelxkJV8ufitdKikqKFw/WzsmYS16XGQlXy5+Kz0tXSopPyhcI1stYS16XGRfXSopPyQvaTtteFV0aWxzLmV4dGVuZChHcmFwaCxteEdyYXBoKTtHcmFwaC5wcm90b3R5cGUubWluRml0U2NhbGU9bnVsbDtHcmFwaC5wcm90b3R5cGUubWF4Rml0U2NhbGU9bnVsbDtHcmFwaC5wcm90b3R5cGUubGlua1BvbGljeT0iZnJhbWUiPT11cmxQYXJhbXMudGFyZ2V0PyJibGFuayI6dXJsUGFyYW1zLnRhcmdldHx8ImF1dG8iO0dyYXBoLnByb3RvdHlwZS5saW5rVGFyZ2V0PSJmcmFtZSI9PXVybFBhcmFtcy50YXJnZXQ/Il9zZWxmIjoiX2JsYW5rIjtHcmFwaC5wcm90b3R5cGUubGlua1JlbGF0aW9uPSJub2ZvbGxvdyBub29wZW5lciBub3JlZmVycmVyIjsKR3JhcGgucHJvdG90eXBlLmRlZmF1bHRTY3JvbGxiYXJzPSFteENsaWVudC5JU19JT1M7R3JhcGgucHJvdG90eXBlLmRlZmF1bHRQYWdlVmlzaWJsZT0hMDtHcmFwaC5wcm90b3R5cGUubGlnaHRib3g9ITE7R3JhcGgucHJvdG90eXBlLmRlZmF1bHRQYWdlQmFja2dyb3VuZENvbG9yPSIjZmZmZmZmIjtHcmFwaC5wcm90b3R5cGUuZGVmYXVsdFBhZ2VCb3JkZXJDb2xvcj0iI2ZmZmZmZiI7R3JhcGgucHJvdG90eXBlLnNjcm9sbFRpbGVTaXplPW5ldyBteFJlY3RhbmdsZSgwLDAsNDAwLDQwMCk7R3JhcGgucHJvdG90eXBlLnRyYW5zcGFyZW50QmFja2dyb3VuZD0hMDtHcmFwaC5wcm90b3R5cGUuc2VsZWN0UGFyZW50QWZ0ZXJEZWxldGU9ITE7R3JhcGgucHJvdG90eXBlLmRlZmF1bHRFZGdlTGVuZ3RoPTgwO0dyYXBoLnByb3RvdHlwZS5lZGdlTW9kZT0hMTtHcmFwaC5wcm90b3R5cGUuY29ubmVjdGlvbkFycm93c0VuYWJsZWQ9ITA7CkdyYXBoLnByb3RvdHlwZS5wbGFjZWhvbGRlclBhdHRlcm49UmVnRXhwKCIlKGRhdGV7Lip9fFteJV57Xn1dKyklIiwiZyIpO0dyYXBoLnByb3RvdHlwZS5hYnNvbHV0ZVVybFBhdHRlcm49L14oPzpbYS16XSs6KT9cL1wvL2k7R3JhcGgucHJvdG90eXBlLmRlZmF1bHRUaGVtZU5hbWU9ImRlZmF1bHQiO0dyYXBoLnByb3RvdHlwZS5kZWZhdWx0VGhlbWVzPXt9O0dyYXBoLnByb3RvdHlwZS5iYXNlVXJsPW51bGwhPXVybFBhcmFtcy5iYXNlP2RlY29kZVVSSUNvbXBvbmVudCh1cmxQYXJhbXMuYmFzZSk6KHdpbmRvdyE9d2luZG93LnRvcD9kb2N1bWVudC5yZWZlcnJlcjpkb2N1bWVudC5sb2NhdGlvbi50b1N0cmluZygpKS5zcGxpdCgiIyIpWzBdO0dyYXBoLnByb3RvdHlwZS5lZGl0QWZ0ZXJJbnNlcnQ9ITE7R3JhcGgucHJvdG90eXBlLmJ1aWx0SW5Qcm9wZXJ0aWVzPVsibGFiZWwiLCJ0b29sdGlwIiwicGxhY2Vob2xkZXJzIiwicGxhY2Vob2xkZXIiXTsKR3JhcGgucHJvdG90eXBlLnN0YW5kYWxvbmU9ITE7CkdyYXBoLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKGEpe214R3JhcGgucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuY2VsbFJlbmRlcmVyLmluaXRpYWxpemVMYWJlbD1mdW5jdGlvbihhLGYpe214Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5pbml0aWFsaXplTGFiZWwuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciBkPWEudmlldy5ncmFwaC50b2xlcmFuY2UsYz0hMCxrPW51bGwscT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtjPSEwO2s9bmV3IG14UG9pbnQobXhFdmVudC5nZXRDbGllbnRYKGEpLG14RXZlbnQuZ2V0Q2xpZW50WShhKSl9KSxiPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2M9YyYmbnVsbCE9ayYmTWF0aC5hYnMoay54LW14RXZlbnQuZ2V0Q2xpZW50WChhKSk8ZCYmTWF0aC5hYnMoay55LW14RXZlbnQuZ2V0Q2xpZW50WShhKSk8ZH0pLGU9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7aWYoYylmb3IodmFyIGU9bXhFdmVudC5nZXRTb3VyY2UoYik7bnVsbCE9CmUmJmUhPWYubm9kZTspe2lmKCJhIj09ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKXthLnZpZXcuZ3JhcGgubGFiZWxMaW5rQ2xpY2tlZChhLGUsYik7YnJlYWt9ZT1lLnBhcmVudE5vZGV9fSk7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKGYubm9kZSxxLGIsZSk7bXhFdmVudC5hZGRMaXN0ZW5lcihmLm5vZGUsImNsaWNrIixmdW5jdGlvbihhKXtteEV2ZW50LmNvbnN1bWUoYSl9KX07dGhpcy5pbml0TGF5b3V0TWFuYWdlcigpfTsKKGZ1bmN0aW9uKCl7R3JhcGgucHJvdG90eXBlLnVzZUNzc1RyYW5zZm9ybXM9ITE7R3JhcGgucHJvdG90eXBlLmN1cnJlbnRTY2FsZT0xO0dyYXBoLnByb3RvdHlwZS5jdXJyZW50VHJhbnNsYXRlPW5ldyBteFBvaW50KDAsMCk7R3JhcGgucHJvdG90eXBlLmdldFN0YXJ0RWRpdGluZ0NlbGw9ZnVuY3Rpb24oYSxjKXt2YXIgZD10aGlzLmdldENlbGxTdHlsZShhKSxkPXBhcnNlSW50KG14VXRpbHMuZ2V0VmFsdWUoZCxteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkUsMCkpO3RoaXMuaXNUYWJsZShhKSYmKCF0aGlzLmlzU3dpbWxhbmUoYSl8fDA9PWQpJiYiIj09dGhpcy5nZXRMYWJlbChhKSYmMDx0aGlzLm1vZGVsLmdldENoaWxkQ291bnQoYSkmJihhPXRoaXMubW9kZWwuZ2V0Q2hpbGRBdChhLDApLGQ9dGhpcy5nZXRDZWxsU3R5bGUoYSksZD1wYXJzZUludChteFV0aWxzLmdldFZhbHVlKGQsbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFLDApKSk7aWYodGhpcy5pc1RhYmxlUm93KGEpJiYKKCF0aGlzLmlzU3dpbWxhbmUoYSl8fDA9PWQpJiYiIj09dGhpcy5nZXRMYWJlbChhKSYmMDx0aGlzLm1vZGVsLmdldENoaWxkQ291bnQoYSkpZm9yKGQ9MDtkPHRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChhKTtkKyspe3ZhciBmPXRoaXMubW9kZWwuZ2V0Q2hpbGRBdChhLGQpO2lmKHRoaXMuaXNDZWxsRWRpdGFibGUoZikpe2E9ZjticmVha319cmV0dXJuIGF9O0dyYXBoLnByb3RvdHlwZS5pc0Zhc3Rab29tRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiJub2NzcyIhPXVybFBhcmFtcy56b29tJiYhbXhDbGllbnQuTk9fRk8mJiFteENsaWVudC5JU19FREdFJiYhdGhpcy51c2VDc3NUcmFuc2Zvcm1zJiZ0aGlzLmlzQ3NzVHJhbnNmb3Jtc1N1cHBvcnRlZCgpfTtHcmFwaC5wcm90b3R5cGUuaXNDc3NUcmFuc2Zvcm1zU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlhbGVjdD09bXhDb25zdGFudHMuRElBTEVDVF9TVkcmJiFteENsaWVudC5OT19GTyYmKCF0aGlzLmxpZ2h0Ym94fHwKIW14Q2xpZW50LklTX1NGKX07R3JhcGgucHJvdG90eXBlLmdldENlbGxBdD1mdW5jdGlvbihhLGMsZixxLGIsZSl7dGhpcy51c2VDc3NUcmFuc2Zvcm1zJiYoYT1hL3RoaXMuY3VycmVudFNjYWxlLXRoaXMuY3VycmVudFRyYW5zbGF0ZS54LGM9Yy90aGlzLmN1cnJlbnRTY2FsZS10aGlzLmN1cnJlbnRUcmFuc2xhdGUueSk7cmV0dXJuIHRoaXMuZ2V0U2NhbGVkQ2VsbEF0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX07R3JhcGgucHJvdG90eXBlLmdldFNjYWxlZENlbGxBdD1mdW5jdGlvbihhLGMsZixxLGIsZSl7cT1udWxsIT1xP3E6ITA7Yj1udWxsIT1iP2I6ITA7bnVsbD09ZiYmKGY9dGhpcy5nZXRDdXJyZW50Um9vdCgpLG51bGw9PWYmJihmPXRoaXMuZ2V0TW9kZWwoKS5nZXRSb290KCkpKTtpZihudWxsIT1mKWZvcih2YXIgZD10aGlzLm1vZGVsLmdldENoaWxkQ291bnQoZiktMTswPD1kO2QtLSl7dmFyIHA9dGhpcy5tb2RlbC5nZXRDaGlsZEF0KGYsZCksbD10aGlzLmdldFNjYWxlZENlbGxBdChhLApjLHAscSxiLGUpO2lmKG51bGwhPWwpcmV0dXJuIGw7aWYodGhpcy5pc0NlbGxWaXNpYmxlKHApJiYoYiYmdGhpcy5tb2RlbC5pc0VkZ2UocCl8fHEmJnRoaXMubW9kZWwuaXNWZXJ0ZXgocCkpJiYobD10aGlzLnZpZXcuZ2V0U3RhdGUocCksbnVsbCE9bCYmKG51bGw9PWV8fCFlKGwsYSxjKSkmJnRoaXMuaW50ZXJzZWN0cyhsLGEsYykpKXJldHVybiBwfXJldHVybiBudWxsfTtHcmFwaC5wcm90b3R5cGUuaXNSZWN1cnNpdmVWZXJ0ZXhSZXNpemU9ZnVuY3Rpb24oYSl7cmV0dXJuIXRoaXMuaXNTd2ltbGFuZShhLmNlbGwpJiYwPHRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChhLmNlbGwpJiYhdGhpcy5pc0NlbGxDb2xsYXBzZWQoYS5jZWxsKSYmIjEiPT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsInJlY3Vyc2l2ZVJlc2l6ZSIsIjEiKSYmbnVsbD09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLCJjaGlsZExheW91dCIsbnVsbCl9O0dyYXBoLnByb3RvdHlwZS5pc1BhcnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIjEiPT0KbXhVdGlscy5nZXRWYWx1ZSh0aGlzLmdldEN1cnJlbnRDZWxsU3R5bGUoYSksInBhcnQiLCIwIil8fHRoaXMuaXNUYWJsZUNlbGwoYSl8fHRoaXMuaXNUYWJsZVJvdyhhKX07R3JhcGgucHJvdG90eXBlLmdldENvbXBvc2l0ZVBhcmVudD1mdW5jdGlvbihhKXtmb3IoO3RoaXMuaXNQYXJ0KGEpOyl7dmFyIGQ9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYSk7aWYoIXRoaXMubW9kZWwuaXNWZXJ0ZXgoZCkpYnJlYWs7YT1kfXJldHVybiBhfTtteENlbGxIaWdobGlnaHQucHJvdG90eXBlLmdldFN0cm9rZVdpZHRoPWZ1bmN0aW9uKGEpe2E9dGhpcy5zdHJva2VXaWR0aDt0aGlzLmdyYXBoLnVzZUNzc1RyYW5zZm9ybXMmJihhLz10aGlzLmdyYXBoLmN1cnJlbnRTY2FsZSk7cmV0dXJuIGF9O214R3JhcGhWaWV3LnByb3RvdHlwZS5nZXRHcmFwaEJvdW5kcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ3JhcGhCb3VuZHM7aWYodGhpcy5ncmFwaC51c2VDc3NUcmFuc2Zvcm1zKXZhciBjPXRoaXMuZ3JhcGguY3VycmVudFRyYW5zbGF0ZSwKZj10aGlzLmdyYXBoLmN1cnJlbnRTY2FsZSxhPW5ldyBteFJlY3RhbmdsZSgoYS54K2MueCkqZiwoYS55K2MueSkqZixhLndpZHRoKmYsYS5oZWlnaHQqZik7cmV0dXJuIGF9O214R3JhcGhWaWV3LnByb3RvdHlwZS52aWV3U3RhdGVDaGFuZ2VkPWZ1bmN0aW9uKCl7dGhpcy5ncmFwaC51c2VDc3NUcmFuc2Zvcm1zP3RoaXMudmFsaWRhdGUoKTp0aGlzLnJldmFsaWRhdGUoKTt0aGlzLmdyYXBoLnNpemVEaWRDaGFuZ2UoKX07dmFyIGE9bXhHcmFwaFZpZXcucHJvdG90eXBlLnZhbGlkYXRlO214R3JhcGhWaWV3LnByb3RvdHlwZS52YWxpZGF0ZT1mdW5jdGlvbihjKXt0aGlzLmdyYXBoLnVzZUNzc1RyYW5zZm9ybXMmJih0aGlzLmdyYXBoLmN1cnJlbnRTY2FsZT10aGlzLnNjYWxlLHRoaXMuZ3JhcGguY3VycmVudFRyYW5zbGF0ZS54PXRoaXMudHJhbnNsYXRlLngsdGhpcy5ncmFwaC5jdXJyZW50VHJhbnNsYXRlLnk9dGhpcy50cmFuc2xhdGUueSx0aGlzLnNjYWxlPTEsdGhpcy50cmFuc2xhdGUueD0KMCx0aGlzLnRyYW5zbGF0ZS55PTApO2EuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuZ3JhcGgudXNlQ3NzVHJhbnNmb3JtcyYmKHRoaXMuZ3JhcGgudXBkYXRlQ3NzVHJhbnNmb3JtKCksdGhpcy5zY2FsZT10aGlzLmdyYXBoLmN1cnJlbnRTY2FsZSx0aGlzLnRyYW5zbGF0ZS54PXRoaXMuZ3JhcGguY3VycmVudFRyYW5zbGF0ZS54LHRoaXMudHJhbnNsYXRlLnk9dGhpcy5ncmFwaC5jdXJyZW50VHJhbnNsYXRlLnkpfTtHcmFwaC5wcm90b3R5cGUudXBkYXRlQ3NzVHJhbnNmb3JtPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy52aWV3LmdldERyYXdQYW5lKCk7aWYobnVsbCE9YSlpZihhPWEucGFyZW50Tm9kZSx0aGlzLnVzZUNzc1RyYW5zZm9ybXMpe3ZhciBjPWEuZ2V0QXR0cmlidXRlKCJ0cmFuc2Zvcm0iKTthLnNldEF0dHJpYnV0ZSgidHJhbnNmb3JtT3JpZ2luIiwiMCAwIik7dmFyIGY9TWF0aC5yb3VuZCgxMDAqdGhpcy5jdXJyZW50U2NhbGUpLzEwMDthLnNldEF0dHJpYnV0ZSgidHJhbnNmb3JtIiwKInNjYWxlKCIrZisiLCIrZisiKXRyYW5zbGF0ZSgiK01hdGgucm91bmQoMTAwKnRoaXMuY3VycmVudFRyYW5zbGF0ZS54KS8xMDArIiwiK01hdGgucm91bmQoMTAwKnRoaXMuY3VycmVudFRyYW5zbGF0ZS55KS8xMDArIikiKTtpZihjIT1hLmdldEF0dHJpYnV0ZSgidHJhbnNmb3JtIikpdHJ5e2lmKG14Q2xpZW50LklTX0VER0Upe3ZhciBxPWEuc3R5bGUuZGlzcGxheTthLnN0eWxlLmRpc3BsYXk9Im5vbmUiO2EuZ2V0QkJveCgpO2Euc3R5bGUuZGlzcGxheT1xfX1jYXRjaChiKXt9fWVsc2UgYS5yZW1vdmVBdHRyaWJ1dGUoInRyYW5zZm9ybU9yaWdpbiIpLGEucmVtb3ZlQXR0cmlidXRlKCJ0cmFuc2Zvcm0iKX07dmFyIGM9bXhHcmFwaFZpZXcucHJvdG90eXBlLnZhbGlkYXRlQmFja2dyb3VuZFBhZ2U7bXhHcmFwaFZpZXcucHJvdG90eXBlLnZhbGlkYXRlQmFja2dyb3VuZFBhZ2U9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoLnVzZUNzc1RyYW5zZm9ybXMsZj10aGlzLnNjYWxlLAprPXRoaXMudHJhbnNsYXRlO2EmJih0aGlzLnNjYWxlPXRoaXMuZ3JhcGguY3VycmVudFNjYWxlLHRoaXMudHJhbnNsYXRlPXRoaXMuZ3JhcGguY3VycmVudFRyYW5zbGF0ZSk7Yy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YSYmKHRoaXMuc2NhbGU9Zix0aGlzLnRyYW5zbGF0ZT1rKX07dmFyIGY9bXhHcmFwaC5wcm90b3R5cGUudXBkYXRlUGFnZUJyZWFrcztteEdyYXBoLnByb3RvdHlwZS51cGRhdGVQYWdlQnJlYWtzPWZ1bmN0aW9uKGEsYyxrKXt2YXIgZD10aGlzLnVzZUNzc1RyYW5zZm9ybXMsYj10aGlzLnZpZXcuc2NhbGUsZT10aGlzLnZpZXcudHJhbnNsYXRlO2QmJih0aGlzLnZpZXcuc2NhbGU9MSx0aGlzLnZpZXcudHJhbnNsYXRlPW5ldyBteFBvaW50KDAsMCksdGhpcy51c2VDc3NUcmFuc2Zvcm1zPSExKTtmLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtkJiYodGhpcy52aWV3LnNjYWxlPWIsdGhpcy52aWV3LnRyYW5zbGF0ZT1lLHRoaXMudXNlQ3NzVHJhbnNmb3Jtcz0hMCl9fSkoKTsKR3JhcGgucHJvdG90eXBlLmlzTGlnaHRib3hWaWV3PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGlnaHRib3h9O0dyYXBoLnByb3RvdHlwZS5pc1ZpZXdlcj1mdW5jdGlvbigpe3JldHVybiExfTtHcmFwaC5wcm90b3R5cGUubGFiZWxMaW5rQ2xpY2tlZD1mdW5jdGlvbihhLGMsZil7Yz1jLmdldEF0dHJpYnV0ZSgiaHJlZiIpO2lmKG51bGwhPWMmJiF0aGlzLmlzQ3VzdG9tTGluayhjKSYmKG14RXZlbnQuaXNMZWZ0TW91c2VCdXR0b24oZikmJiFteEV2ZW50LmlzUG9wdXBUcmlnZ2VyKGYpfHxteEV2ZW50LmlzVG91Y2hFdmVudChmKSkpe2lmKCF0aGlzLmlzRW5hYmxlZCgpfHx0aGlzLmlzQ2VsbExvY2tlZChhLmNlbGwpKWE9dGhpcy5pc0JsYW5rTGluayhjKT90aGlzLmxpbmtUYXJnZXQ6Il90b3AiLHRoaXMub3BlbkxpbmsodGhpcy5nZXRBYnNvbHV0ZVVybChjKSxhKTtteEV2ZW50LmNvbnN1bWUoZil9fTsKR3JhcGgucHJvdG90eXBlLm9wZW5MaW5rPWZ1bmN0aW9uKGEsYyxmKXt2YXIgZD13aW5kb3c7dHJ5e2lmKCJfc2VsZiI9PWMmJndpbmRvdyE9d2luZG93LnRvcCl3aW5kb3cubG9jYXRpb24uaHJlZj1hO2Vsc2UgaWYoYS5zdWJzdHJpbmcoMCx0aGlzLmJhc2VVcmwubGVuZ3RoKT09dGhpcy5iYXNlVXJsJiYiIyI9PWEuY2hhckF0KHRoaXMuYmFzZVVybC5sZW5ndGgpJiYiX3RvcCI9PWMmJndpbmRvdz09d2luZG93LnRvcCl7dmFyIG09YS5zcGxpdCgiIyIpWzFdO3dpbmRvdy5sb2NhdGlvbi5oYXNoPT0iIyIrbSYmKHdpbmRvdy5sb2NhdGlvbi5oYXNoPSIiKTt3aW5kb3cubG9jYXRpb24uaGFzaD1tfWVsc2UgZD13aW5kb3cub3BlbihhLG51bGwhPWM/YzoiX2JsYW5rIiksbnVsbD09ZHx8Znx8KGQub3BlbmVyPW51bGwpfWNhdGNoKGspe31yZXR1cm4gZH07CkdyYXBoLnByb3RvdHlwZS5nZXRMaW5rVGl0bGU9ZnVuY3Rpb24oYSl7cmV0dXJuIGEuc3Vic3RyaW5nKGEubGFzdEluZGV4T2YoIi8iKSsxKX07R3JhcGgucHJvdG90eXBlLmlzQ3VzdG9tTGluaz1mdW5jdGlvbihhKXtyZXR1cm4iZGF0YToiPT1hLnN1YnN0cmluZygwLDUpfTtHcmFwaC5wcm90b3R5cGUuY3VzdG9tTGlua0NsaWNrZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuITF9O0dyYXBoLnByb3RvdHlwZS5pc0V4dGVybmFsUHJvdG9jb2w9ZnVuY3Rpb24oYSl7cmV0dXJuIm1haWx0bzoiPT09YS5zdWJzdHJpbmcoMCw3KX07R3JhcGgucHJvdG90eXBlLmlzQmxhbmtMaW5rPWZ1bmN0aW9uKGEpe3JldHVybiF0aGlzLmlzRXh0ZXJuYWxQcm90b2NvbChhKSYmKCJibGFuayI9PT10aGlzLmxpbmtQb2xpY3l8fCJzZWxmIiE9PXRoaXMubGlua1BvbGljeSYmIXRoaXMuaXNSZWxhdGl2ZVVybChhKSYmYS5zdWJzdHJpbmcoMCx0aGlzLmRvbWFpblVybC5sZW5ndGgpIT09dGhpcy5kb21haW5VcmwpfTsKR3JhcGgucHJvdG90eXBlLmlzUmVsYXRpdmVVcmw9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEmJiF0aGlzLmFic29sdXRlVXJsUGF0dGVybi50ZXN0KGEpJiYiZGF0YToiIT09YS5zdWJzdHJpbmcoMCw1KSYmIXRoaXMuaXNFeHRlcm5hbFByb3RvY29sKGEpfTtHcmFwaC5wcm90b3R5cGUuZ2V0QWJzb2x1dGVVcmw9ZnVuY3Rpb24oYSl7bnVsbCE9YSYmdGhpcy5pc1JlbGF0aXZlVXJsKGEpJiYoYT0iIyI9PWEuY2hhckF0KDApP3RoaXMuYmFzZVVybCthOiIvIj09YS5jaGFyQXQoMCk/dGhpcy5kb21haW5VcmwrYTp0aGlzLmRvbWFpblBhdGhVcmwrYSk7cmV0dXJuIGF9OwpHcmFwaC5wcm90b3R5cGUuaW5pdExheW91dE1hbmFnZXI9ZnVuY3Rpb24oKXt0aGlzLmxheW91dE1hbmFnZXI9bmV3IG14TGF5b3V0TWFuYWdlcih0aGlzKTt0aGlzLmxheW91dE1hbmFnZXIuaGFzTGF5b3V0PWZ1bmN0aW9uKGEsYyl7cmV0dXJuIG51bGwhPXRoaXMuZ3JhcGguZ2V0Q2VsbFN0eWxlKGEpLmNoaWxkTGF5b3V0fTt0aGlzLmxheW91dE1hbmFnZXIuZ2V0TGF5b3V0PWZ1bmN0aW9uKGEsYyl7dmFyIGY9dGhpcy5ncmFwaC5tb2RlbC5nZXRQYXJlbnQoYSk7aWYoYyE9bXhFdmVudC5CRUdJTl9VUERBVEV8fHRoaXMuaGFzTGF5b3V0KGYsYykpe2Y9dGhpcy5ncmFwaC5nZXRDZWxsU3R5bGUoYSk7aWYoInN0YWNrTGF5b3V0Ij09Zi5jaGlsZExheW91dCl7dmFyIGQ9bmV3IG14U3RhY2tMYXlvdXQodGhpcy5ncmFwaCwhMCk7ZC5yZXNpemVQYXJlbnRNYXg9IjEiPT1teFV0aWxzLmdldFZhbHVlKGYsInJlc2l6ZVBhcmVudE1heCIsIjEiKTtkLmhvcml6b250YWw9IjEiPT1teFV0aWxzLmdldFZhbHVlKGYsCiJob3Jpem9udGFsU3RhY2siLCIxIik7ZC5yZXNpemVQYXJlbnQ9IjEiPT1teFV0aWxzLmdldFZhbHVlKGYsInJlc2l6ZVBhcmVudCIsIjEiKTtkLnJlc2l6ZUxhc3Q9IjEiPT1teFV0aWxzLmdldFZhbHVlKGYsInJlc2l6ZUxhc3QiLCIwIik7ZC5zcGFjaW5nPWYuc3RhY2tTcGFjaW5nfHxkLnNwYWNpbmc7ZC5ib3JkZXI9Zi5zdGFja0JvcmRlcnx8ZC5ib3JkZXI7ZC5tYXJnaW5MZWZ0PWYubWFyZ2luTGVmdHx8MDtkLm1hcmdpblJpZ2h0PWYubWFyZ2luUmlnaHR8fDA7ZC5tYXJnaW5Ub3A9Zi5tYXJnaW5Ub3B8fDA7ZC5tYXJnaW5Cb3R0b209Zi5tYXJnaW5Cb3R0b218fDA7ZC5maWxsPSEwO3JldHVybiBkfWlmKCJ0cmVlTGF5b3V0Ij09Zi5jaGlsZExheW91dClyZXR1cm4gZD1uZXcgbXhDb21wYWN0VHJlZUxheW91dCh0aGlzLmdyYXBoKSxkLmhvcml6b250YWw9IjEiPT1teFV0aWxzLmdldFZhbHVlKGYsImhvcml6b250YWxUcmVlIiwiMSIpLGQucmVzaXplUGFyZW50PSIxIj09bXhVdGlscy5nZXRWYWx1ZShmLAoicmVzaXplUGFyZW50IiwiMSIpLGQuZ3JvdXBQYWRkaW5nPW14VXRpbHMuZ2V0VmFsdWUoZiwicGFyZW50UGFkZGluZyIsMjApLGQubGV2ZWxEaXN0YW5jZT1teFV0aWxzLmdldFZhbHVlKGYsInRyZWVMZXZlbERpc3RhbmNlIiwzMCksZC5tYWludGFpblBhcmVudExvY2F0aW9uPSEwLGQuZWRnZVJvdXRpbmc9ITEsZC5yZXNldEVkZ2VzPSExLGQ7aWYoImZsb3dMYXlvdXQiPT1mLmNoaWxkTGF5b3V0KXJldHVybiBkPW5ldyBteEhpZXJhcmNoaWNhbExheW91dCh0aGlzLmdyYXBoLG14VXRpbHMuZ2V0VmFsdWUoZiwiZmxvd09yaWVudGF0aW9uIixteENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVCkpLGQucmVzaXplUGFyZW50PSIxIj09bXhVdGlscy5nZXRWYWx1ZShmLCJyZXNpemVQYXJlbnQiLCIxIiksZC5wYXJlbnRCb3JkZXI9bXhVdGlscy5nZXRWYWx1ZShmLCJwYXJlbnRQYWRkaW5nIiwyMCksZC5tYWludGFpblBhcmVudExvY2F0aW9uPSEwLGQuaW50cmFDZWxsU3BhY2luZz1teFV0aWxzLmdldFZhbHVlKGYsCiJpbnRyYUNlbGxTcGFjaW5nIixteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUuaW50cmFDZWxsU3BhY2luZyksZC5pbnRlclJhbmtDZWxsU3BhY2luZz1teFV0aWxzLmdldFZhbHVlKGYsImludGVyUmFua0NlbGxTcGFjaW5nIixteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUuaW50ZXJSYW5rQ2VsbFNwYWNpbmcpLGQuaW50ZXJIaWVyYXJjaHlTcGFjaW5nPW14VXRpbHMuZ2V0VmFsdWUoZiwiaW50ZXJIaWVyYXJjaHlTcGFjaW5nIixteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUuaW50ZXJIaWVyYXJjaHlTcGFjaW5nKSxkLnBhcmFsbGVsRWRnZVNwYWNpbmc9bXhVdGlscy5nZXRWYWx1ZShmLCJwYXJhbGxlbEVkZ2VTcGFjaW5nIixteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUucGFyYWxsZWxFZGdlU3BhY2luZyksZDtpZigiY2lyY2xlTGF5b3V0Ij09Zi5jaGlsZExheW91dClyZXR1cm4gbmV3IG14Q2lyY2xlTGF5b3V0KHRoaXMuZ3JhcGgpO2lmKCJvcmdhbmljTGF5b3V0Ij09CmYuY2hpbGRMYXlvdXQpcmV0dXJuIG5ldyBteEZhc3RPcmdhbmljTGF5b3V0KHRoaXMuZ3JhcGgpO2lmKCJ0YWJsZUxheW91dCI9PWYuY2hpbGRMYXlvdXQpcmV0dXJuIG5ldyBUYWJsZUxheW91dCh0aGlzLmdyYXBoKX1yZXR1cm4gbnVsbH19O0dyYXBoLnByb3RvdHlwZS5nZXRQYWdlU2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhZ2VWaXNpYmxlP25ldyBteFJlY3RhbmdsZSgwLDAsdGhpcy5wYWdlRm9ybWF0LndpZHRoKnRoaXMucGFnZVNjYWxlLHRoaXMucGFnZUZvcm1hdC5oZWlnaHQqdGhpcy5wYWdlU2NhbGUpOnRoaXMuc2Nyb2xsVGlsZVNpemV9OwpHcmFwaC5wcm90b3R5cGUuZ2V0UGFnZUxheW91dD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0UGFnZVNpemUoKSxjPXRoaXMuZ2V0R3JhcGhCb3VuZHMoKTtpZigwPT1jLndpZHRofHwwPT1jLmhlaWdodClyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKDAsMCwxLDEpO3ZhciBmPU1hdGguZmxvb3IoTWF0aC5jZWlsKGMueC90aGlzLnZpZXcuc2NhbGUtdGhpcy52aWV3LnRyYW5zbGF0ZS54KS9hLndpZHRoKSxkPU1hdGguZmxvb3IoTWF0aC5jZWlsKGMueS90aGlzLnZpZXcuc2NhbGUtdGhpcy52aWV3LnRyYW5zbGF0ZS55KS9hLmhlaWdodCk7cmV0dXJuIG5ldyBteFJlY3RhbmdsZShmLGQsTWF0aC5jZWlsKChNYXRoLmZsb29yKChjLngrYy53aWR0aCkvdGhpcy52aWV3LnNjYWxlKS10aGlzLnZpZXcudHJhbnNsYXRlLngpL2Eud2lkdGgpLWYsTWF0aC5jZWlsKChNYXRoLmZsb29yKChjLnkrYy5oZWlnaHQpL3RoaXMudmlldy5zY2FsZSktdGhpcy52aWV3LnRyYW5zbGF0ZS55KS9hLmhlaWdodCktCmQpfTtHcmFwaC5wcm90b3R5cGUuc2FuaXRpemVIdG1sPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIEdyYXBoLnNhbml0aXplSHRtbChhLGMpfTtHcmFwaC5wcm90b3R5cGUudXBkYXRlUGxhY2Vob2xkZXJzPWZ1bmN0aW9uKCl7dmFyIGE9ITEsYztmb3IoYyBpbiB0aGlzLm1vZGVsLmNlbGxzKXt2YXIgZj10aGlzLm1vZGVsLmNlbGxzW2NdO3RoaXMuaXNSZXBsYWNlUGxhY2Vob2xkZXJzKGYpJiYodGhpcy52aWV3LmludmFsaWRhdGUoZiwhMSwhMSksYT0hMCl9YSYmdGhpcy52aWV3LnZhbGlkYXRlKCl9O0dyYXBoLnByb3RvdHlwZS5pc1JlcGxhY2VQbGFjZWhvbGRlcnM9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEudmFsdWUmJiJvYmplY3QiPT10eXBlb2YgYS52YWx1ZSYmIjEiPT1hLnZhbHVlLmdldEF0dHJpYnV0ZSgicGxhY2Vob2xkZXJzIil9OwpHcmFwaC5wcm90b3R5cGUuaXNab29tV2hlZWxFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gbXhFdmVudC5pc0FsdERvd24oYSl8fG14RXZlbnQuaXNNZXRhRG93bihhKSYmbXhDbGllbnQuSVNfTUFDfHxteEV2ZW50LmlzQ29udHJvbERvd24oYSl9O0dyYXBoLnByb3RvdHlwZS5pc1Njcm9sbFdoZWVsRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIXRoaXMuaXNab29tV2hlZWxFdmVudChhKX07R3JhcGgucHJvdG90eXBlLmlzVHJhbnNwYXJlbnRDbGlja0V2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiBteEV2ZW50LmlzQWx0RG93bihhKXx8bXhDbGllbnQuSVNfQ0hST01FT1MmJm14RXZlbnQuaXNTaGlmdERvd24oYSl9O0dyYXBoLnByb3RvdHlwZS5pc0lnbm9yZVRlcm1pbmFsRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG14RXZlbnQuaXNTaGlmdERvd24oYSkmJm14RXZlbnQuaXNDb250cm9sRG93bihhKX07CkdyYXBoLnByb3RvdHlwZS5pc1NwbGl0VGFyZ2V0PWZ1bmN0aW9uKGEsYyxmKXtyZXR1cm4hdGhpcy5tb2RlbC5pc0VkZ2UoY1swXSkmJiFteEV2ZW50LmlzQWx0RG93bihmKSYmIW14RXZlbnQuaXNTaGlmdERvd24oZikmJm14R3JhcGgucHJvdG90eXBlLmlzU3BsaXRUYXJnZXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtHcmFwaC5wcm90b3R5cGUuZ2V0TGFiZWw9ZnVuY3Rpb24oYSl7dmFyIGM9bXhHcmFwaC5wcm90b3R5cGUuZ2V0TGFiZWwuYXBwbHkodGhpcyxhcmd1bWVudHMpO251bGwhPWMmJnRoaXMuaXNSZXBsYWNlUGxhY2Vob2xkZXJzKGEpJiZudWxsPT1hLmdldEF0dHJpYnV0ZSgicGxhY2Vob2xkZXIiKSYmKGM9dGhpcy5yZXBsYWNlUGxhY2Vob2xkZXJzKGEsYykpO3JldHVybiBjfTsKR3JhcGgucHJvdG90eXBlLmlzTGFiZWxNb3ZhYmxlPWZ1bmN0aW9uKGEpe3ZhciBjPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShhKTtyZXR1cm4hdGhpcy5pc0NlbGxMb2NrZWQoYSkmJih0aGlzLm1vZGVsLmlzRWRnZShhKSYmdGhpcy5lZGdlTGFiZWxzTW92YWJsZXx8dGhpcy5tb2RlbC5pc1ZlcnRleChhKSYmKHRoaXMudmVydGV4TGFiZWxzTW92YWJsZXx8IjEiPT1teFV0aWxzLmdldFZhbHVlKGMsImxhYmVsTW92YWJsZSIsIjAiKSkpfTtHcmFwaC5wcm90b3R5cGUuc2V0R3JpZFNpemU9ZnVuY3Rpb24oYSl7dGhpcy5ncmlkU2l6ZT1hO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJncmlkU2l6ZUNoYW5nZWQiKSl9OwpHcmFwaC5wcm90b3R5cGUuZ2V0Q2xpY2thYmxlTGlua0ZvckNlbGw9ZnVuY3Rpb24oYSl7ZG97dmFyIGM9dGhpcy5nZXRMaW5rRm9yQ2VsbChhKTtpZihudWxsIT1jKXJldHVybiBjO2E9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYSl9d2hpbGUobnVsbCE9YSk7cmV0dXJuIG51bGx9O0dyYXBoLnByb3RvdHlwZS5nZXRHbG9iYWxWYXJpYWJsZT1mdW5jdGlvbihhKXt2YXIgYz1udWxsOyJkYXRlIj09YT9jPShuZXcgRGF0ZSkudG9Mb2NhbGVEYXRlU3RyaW5nKCk6InRpbWUiPT1hP2M9KG5ldyBEYXRlKS50b0xvY2FsZVRpbWVTdHJpbmcoKToidGltZXN0YW1wIj09YT9jPShuZXcgRGF0ZSkudG9Mb2NhbGVTdHJpbmcoKToiZGF0ZXsiPT1hLnN1YnN0cmluZygwLDUpJiYoYT1hLnN1YnN0cmluZyg1LGEubGVuZ3RoLTEpLGM9dGhpcy5mb3JtYXREYXRlKG5ldyBEYXRlLGEpKTtyZXR1cm4gY307CkdyYXBoLnByb3RvdHlwZS5mb3JtYXREYXRlPWZ1bmN0aW9uKGEsYyxmKXtudWxsPT10aGlzLmRhdGVGb3JtYXRDYWNoZSYmKHRoaXMuZGF0ZUZvcm1hdENhY2hlPXtpMThuOntkYXlOYW1lczoiU3VuIE1vbiBUdWUgV2VkIFRodSBGcmkgU2F0IFN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5Ii5zcGxpdCgiICIpLG1vbnRoTmFtZXM6IkphbiBGZWIgTWFyIEFwciBNYXkgSnVuIEp1bCBBdWcgU2VwIE9jdCBOb3YgRGVjIEphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXIiLnNwbGl0KCIgIil9LG1hc2tzOnsiZGVmYXVsdCI6ImRkZCBtbW0gZGQgeXl5eSBISDpNTTpzcyIsc2hvcnREYXRlOiJtL2QveXkiLG1lZGl1bURhdGU6Im1tbSBkLCB5eXl5Iixsb25nRGF0ZToibW1tbSBkLCB5eXl5IixmdWxsRGF0ZToiZGRkZCwgbW1tbSBkLCB5eXl5IiwKc2hvcnRUaW1lOiJoOk1NIFRUIixtZWRpdW1UaW1lOiJoOk1NOnNzIFRUIixsb25nVGltZToiaDpNTTpzcyBUVCBaIixpc29EYXRlOiJ5eXl5LW1tLWRkIixpc29UaW1lOiJISDpNTTpzcyIsaXNvRGF0ZVRpbWU6Inl5eXktbW0tZGQnVCdISDpNTTpzcyIsaXNvVXRjRGF0ZVRpbWU6IlVUQzp5eXl5LW1tLWRkJ1QnSEg6TU06c3MnWicifX0pO3ZhciBkPXRoaXMuZGF0ZUZvcm1hdENhY2hlLG09L1xiKD86W1BNQ0VBXVtTRFBdVHwoPzpQYWNpZmljfE1vdW50YWlufENlbnRyYWx8RWFzdGVybnxBdGxhbnRpYykgKD86U3RhbmRhcmR8RGF5bGlnaHR8UHJldmFpbGluZykgVGltZXwoPzpHTVR8VVRDKSg/OlstK11cZHs0fSk/KVxiL2csaz0vW14tK1xkQS1aXS9nLHE9ZnVuY3Rpb24oYSxiKXthPVN0cmluZyhhKTtmb3IoYj1ifHwyO2EubGVuZ3RoPGI7KWE9IjAiK2E7cmV0dXJuIGF9OzEhPWFyZ3VtZW50cy5sZW5ndGh8fCJbb2JqZWN0IFN0cmluZ10iIT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSl8fAovXGQvLnRlc3QoYSl8fChjPWEsYT12b2lkIDApO2E9YT9uZXcgRGF0ZShhKTpuZXcgRGF0ZTtpZihpc05hTihhKSl0aHJvdyBTeW50YXhFcnJvcigiaW52YWxpZCBkYXRlIik7Yz1TdHJpbmcoZC5tYXNrc1tjXXx8Y3x8ZC5tYXNrc1siZGVmYXVsdCJdKTsiVVRDOiI9PWMuc2xpY2UoMCw0KSYmKGM9Yy5zbGljZSg0KSxmPSEwKTt2YXIgYj1mPyJnZXRVVEMiOiJnZXQiLGU9YVtiKyJEYXRlIl0oKSxnPWFbYisiRGF5Il0oKSxwPWFbYisiTW9udGgiXSgpLGw9YVtiKyJGdWxsWWVhciJdKCksbj1hW2IrIkhvdXJzIl0oKSx2PWFbYisiTWludXRlcyJdKCksdD1hW2IrIlNlY29uZHMiXSgpLGI9YVtiKyJNaWxsaXNlY29uZHMiXSgpLHk9Zj8wOmEuZ2V0VGltZXpvbmVPZmZzZXQoKSx4PXtkOmUsZGQ6cShlKSxkZGQ6ZC5pMThuLmRheU5hbWVzW2ddLGRkZGQ6ZC5pMThuLmRheU5hbWVzW2crN10sbTpwKzEsbW06cShwKzEpLG1tbTpkLmkxOG4ubW9udGhOYW1lc1twXSxtbW1tOmQuaTE4bi5tb250aE5hbWVzW3ArCjEyXSx5eTpTdHJpbmcobCkuc2xpY2UoMikseXl5eTpsLGg6biUxMnx8MTIsaGg6cShuJTEyfHwxMiksSDpuLEhIOnEobiksTTp2LE1NOnEodiksczp0LHNzOnEodCksbDpxKGIsMyksTDpxKDk5PGI/TWF0aC5yb3VuZChiLzEwKTpiKSx0OjEyPm4/ImEiOiJwIix0dDoxMj5uPyJhbSI6InBtIixUOjEyPm4/IkEiOiJQIixUVDoxMj5uPyJBTSI6IlBNIixaOmY/IlVUQyI6KFN0cmluZyhhKS5tYXRjaChtKXx8WyIiXSkucG9wKCkucmVwbGFjZShrLCIiKSxvOigwPHk/Ii0iOiIrIikrcSgxMDAqTWF0aC5mbG9vcihNYXRoLmFicyh5KS82MCkrTWF0aC5hYnMoeSklNjAsNCksUzpbInRoIiwic3QiLCJuZCIsInJkIl1bMzxlJTEwPzA6KDEwIT1lJTEwMC1lJTEwKSplJTEwXX07cmV0dXJuIGMucmVwbGFjZSgvZHsxLDR9fG17MSw0fXx5eSg/Onl5KT98KFtIaE1zVHRdKVwxP3xbTGxvU1pdfCJbXiJdKiJ8J1teJ10qJy9nLGZ1bmN0aW9uKGEpe3JldHVybiBhIGluIHg/eFthXTphLnNsaWNlKDEsCmEubGVuZ3RoLTEpfSl9OwpHcmFwaC5wcm90b3R5cGUuY3JlYXRlTGF5ZXJzRGlhbG9nPWZ1bmN0aW9uKCl7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7YS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO2Zvcih2YXIgYz10aGlzLmdldE1vZGVsKCksZj1jLmdldENoaWxkQ291bnQoYy5yb290KSxkPTA7ZDxmO2QrKylteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihkKXt2YXIgZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtmLnN0eWxlLm92ZXJmbG93PSJoaWRkZW4iO2Yuc3R5bGUudGV4dE92ZXJmbG93PSJlbGxpcHNpcyI7Zi5zdHlsZS5wYWRkaW5nPSIycHgiO2Yuc3R5bGUud2hpdGVTcGFjZT0ibm93cmFwIjt2YXIgbT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpO20uc3R5bGUuZGlzcGxheT0iaW5saW5lLWJsb2NrIjttLnNldEF0dHJpYnV0ZSgidHlwZSIsImNoZWNrYm94Iik7Yy5pc1Zpc2libGUoZCkmJihtLnNldEF0dHJpYnV0ZSgiY2hlY2tlZCIsImNoZWNrZWQiKSwKbS5kZWZhdWx0Q2hlY2tlZD0hMCk7Zi5hcHBlbmRDaGlsZChtKTt2YXIgYj10aGlzLmNvbnZlcnRWYWx1ZVRvU3RyaW5nKGQpfHxteFJlc291cmNlcy5nZXQoImJhY2tncm91bmQiKXx8IkJhY2tncm91bmQiO2Yuc2V0QXR0cmlidXRlKCJ0aXRsZSIsYik7bXhVdGlscy53cml0ZShmLGIpO2EuYXBwZW5kQ2hpbGQoZik7bXhFdmVudC5hZGRMaXN0ZW5lcihtLCJjbGljayIsZnVuY3Rpb24oKXtudWxsIT1tLmdldEF0dHJpYnV0ZSgiY2hlY2tlZCIpP20ucmVtb3ZlQXR0cmlidXRlKCJjaGVja2VkIik6bS5zZXRBdHRyaWJ1dGUoImNoZWNrZWQiLCJjaGVja2VkIik7Yy5zZXRWaXNpYmxlKGQsbS5jaGVja2VkKX0pfSkoYy5nZXRDaGlsZEF0KGMucm9vdCxkKSk7cmV0dXJuIGF9OwpHcmFwaC5wcm90b3R5cGUucmVwbGFjZVBsYWNlaG9sZGVycz1mdW5jdGlvbihhLGMpe3ZhciBmPVtdO2lmKG51bGwhPWMpe2Zvcih2YXIgZD0wO21hdGNoPXRoaXMucGxhY2Vob2xkZXJQYXR0ZXJuLmV4ZWMoYyk7KXt2YXIgbT1tYXRjaFswXTtpZigyPG0ubGVuZ3RoJiYiJWxhYmVsJSIhPW0mJiIldG9vbHRpcCUiIT1tKXt2YXIgaz1udWxsO2lmKG1hdGNoLmluZGV4PmQmJiIlIj09Yy5jaGFyQXQobWF0Y2guaW5kZXgtMSkpaz1tLnN1YnN0cmluZygxKTtlbHNle3ZhciBxPW0uc3Vic3RyaW5nKDEsbS5sZW5ndGgtMSk7aWYoImlkIj09cSlrPWEuaWQ7ZWxzZSBpZigwPnEuaW5kZXhPZigieyIpKWZvcih2YXIgYj1hO251bGw9PWsmJm51bGwhPWI7KW51bGwhPWIudmFsdWUmJiJvYmplY3QiPT10eXBlb2YgYi52YWx1ZSYmKGs9Yi5oYXNBdHRyaWJ1dGUocSk/bnVsbCE9Yi5nZXRBdHRyaWJ1dGUocSk/Yi5nZXRBdHRyaWJ1dGUocSk6IiI6bnVsbCksYj10aGlzLm1vZGVsLmdldFBhcmVudChiKTsKbnVsbD09ayYmKGs9dGhpcy5nZXRHbG9iYWxWYXJpYWJsZShxKSl9Zi5wdXNoKGMuc3Vic3RyaW5nKGQsbWF0Y2guaW5kZXgpKyhudWxsIT1rP2s6bSkpO2Q9bWF0Y2guaW5kZXgrbS5sZW5ndGh9fWYucHVzaChjLnN1YnN0cmluZyhkKSl9cmV0dXJuIGYuam9pbigiIil9O0dyYXBoLnByb3RvdHlwZS5yZXN0b3JlU2VsZWN0aW9uPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEmJjA8YS5sZW5ndGgpe2Zvcih2YXIgYz1bXSxmPTA7ZjxhLmxlbmd0aDtmKyspe3ZhciBkPXRoaXMubW9kZWwuZ2V0Q2VsbChhW2ZdLmlkKTtudWxsIT1kJiZjLnB1c2goZCl9dGhpcy5zZXRTZWxlY3Rpb25DZWxscyhjKX1lbHNlIHRoaXMuY2xlYXJTZWxlY3Rpb24oKX07CkdyYXBoLnByb3RvdHlwZS5zZWxlY3RDZWxsc0ZvckNvbm5lY3RWZXJ0ZXg9ZnVuY3Rpb24oYSxjLGYpezI9PWEubGVuZ3RoJiZ0aGlzLm1vZGVsLmlzVmVydGV4KGFbMV0pPyh0aGlzLnNldFNlbGVjdGlvbkNlbGwoYVsxXSksdGhpcy5zY3JvbGxDZWxsVG9WaXNpYmxlKGFbMV0pLG51bGwhPWYmJihteEV2ZW50LmlzVG91Y2hFdmVudChjKT9mLnVwZGF0ZShmLmdldFN0YXRlKHRoaXMudmlldy5nZXRTdGF0ZShhWzFdKSkpOmYucmVzZXQoKSkpOnRoaXMuc2V0U2VsZWN0aW9uQ2VsbHMoYSl9OwpHcmFwaC5wcm90b3R5cGUuY29ubmVjdFZlcnRleD1mdW5jdGlvbihhLGMsZixkLG0sayl7aWYoYS5nZW9tZXRyeS5yZWxhdGl2ZSYmdGhpcy5tb2RlbC5pc0VkZ2UoYS5wYXJlbnQpKXJldHVybltdO2s9az9rOiExO3ZhciBxPXRoaXMuZ2V0Q29tcG9zaXRlUGFyZW50KGEpLGI9YS5nZW9tZXRyeS5yZWxhdGl2ZSYmbnVsbCE9YS5wYXJlbnQuZ2VvbWV0cnk/bmV3IG14UG9pbnQoYS5wYXJlbnQuZ2VvbWV0cnkud2lkdGgqYS5nZW9tZXRyeS54LGEucGFyZW50Lmdlb21ldHJ5LmhlaWdodCphLmdlb21ldHJ5LnkpOm5ldyBteFBvaW50KHEuZ2VvbWV0cnkueCxxLmdlb21ldHJ5LnkpO2M9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSD8oYi54Kz1xLmdlb21ldHJ5LndpZHRoLzIsYi55LT1mKTpjPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEg/KGIueCs9cS5nZW9tZXRyeS53aWR0aC8yLGIueSs9cS5nZW9tZXRyeS5oZWlnaHQrZik6KGIueD1jPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVD8KYi54LWY6Yi54KyhxLmdlb21ldHJ5LndpZHRoK2YpLGIueSs9cS5nZW9tZXRyeS5oZWlnaHQvMik7Zj10aGlzLnZpZXcuZ2V0U3RhdGUodGhpcy5tb2RlbC5nZXRQYXJlbnQoYSkpO3ZhciBxPXRoaXMudmlldy5zY2FsZSxlPXRoaXMudmlldy50cmFuc2xhdGUsZz1lLngqcSxlPWUueSpxO251bGwhPWYmJnRoaXMubW9kZWwuaXNWZXJ0ZXgoZi5jZWxsKSYmKGc9Zi54LGU9Zi55KTt0aGlzLm1vZGVsLmlzVmVydGV4KGEucGFyZW50KSYmYS5nZW9tZXRyeS5yZWxhdGl2ZSYmKGIueCs9YS5wYXJlbnQuZ2VvbWV0cnkueCxiLnkrPWEucGFyZW50Lmdlb21ldHJ5LnkpO2s9a3x8bXhFdmVudC5pc0NvbnRyb2xEb3duKGQpJiYhbT9udWxsOnRoaXMuZ2V0Q2VsbEF0KGcrYi54KnEsZStiLnkqcSk7dGhpcy5tb2RlbC5pc0FuY2VzdG9yKGssYSkmJihrPW51bGwpO2ZvcihmPWs7bnVsbCE9Zjspe2lmKHRoaXMuaXNDZWxsTG9ja2VkKGYpKXtrPW51bGw7YnJlYWt9Zj10aGlzLm1vZGVsLmdldFBhcmVudChmKX1udWxsIT0KayYmKGY9dGhpcy52aWV3LmdldFN0YXRlKGEpLHE9dGhpcy52aWV3LmdldFN0YXRlKGspLG51bGwhPWYmJm51bGwhPXEmJm14VXRpbHMuaW50ZXJzZWN0cyhmLHEpJiYoaz1udWxsKSk7aWYobT0hbXhFdmVudC5pc1NoaWZ0RG93bihkKXx8bSljPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEg/Yi55LT1hLmdlb21ldHJ5LmhlaWdodC8yOmM9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSD9iLnkrPWEuZ2VvbWV0cnkuaGVpZ2h0LzI6Yi54PWM9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUP2IueC1hLmdlb21ldHJ5LndpZHRoLzI6Yi54K2EuZ2VvbWV0cnkud2lkdGgvMjtudWxsPT1rfHx0aGlzLmlzQ2VsbENvbm5lY3RhYmxlKGspfHx0aGlzLmlzU3dpbWxhbmUoayl8fChmPXRoaXMuZ2V0TW9kZWwoKS5nZXRQYXJlbnQoayksdGhpcy5nZXRNb2RlbCgpLmlzVmVydGV4KGYpJiZ0aGlzLmlzQ2VsbENvbm5lY3RhYmxlKGYpJiYoaz1mKSk7aWYoaz09YXx8dGhpcy5tb2RlbC5pc0VkZ2Uoayl8fAohdGhpcy5pc0NlbGxDb25uZWN0YWJsZShrKSYmIXRoaXMuaXNTd2ltbGFuZShrKSlrPW51bGw7Zj1bXTt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e3ZhciBwPW51bGwhPWsmJnRoaXMuaXNTd2ltbGFuZShrKSxxPXA/bnVsbDprO2lmKG51bGw9PXEmJm0pe2Zvcih2YXIgZz1hLGw9dGhpcy5nZXRDZWxsR2VvbWV0cnkoYSk7bnVsbCE9bCYmbC5yZWxhdGl2ZTspZz10aGlzLmdldE1vZGVsKCkuZ2V0UGFyZW50KGcpLGw9dGhpcy5nZXRDZWxsR2VvbWV0cnkoZyk7Zz10aGlzLmdldENvbXBvc2l0ZVBhcmVudChnKTtxPXRoaXMuZHVwbGljYXRlQ2VsbHMoW2ddLCExKVswXTtsPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KHEpO251bGwhPWwmJihsLng9Yi54LWwud2lkdGgvMixsLnk9Yi55LWwuaGVpZ2h0LzIpO3AmJih0aGlzLmFkZENlbGxzKFtxXSxrLG51bGwsbnVsbCxudWxsLCEwKSxrPW51bGwpfXA9bnVsbDtudWxsIT10aGlzLmxheW91dE1hbmFnZXImJihwPXRoaXMubGF5b3V0TWFuYWdlci5nZXRMYXlvdXQodGhpcy5tb2RlbC5nZXRQYXJlbnQoYSkpKTsKdmFyIG49bXhFdmVudC5pc0NvbnRyb2xEb3duKGQpJiZtfHxudWxsPT1rJiZudWxsIT1wJiZwLmNvbnN0cnVjdG9yPT1teFN0YWNrTGF5b3V0P251bGw6dGhpcy5pbnNlcnRFZGdlKHRoaXMubW9kZWwuZ2V0UGFyZW50KGEpLG51bGwsIiIsYSxxLHRoaXMuY3JlYXRlQ3VycmVudEVkZ2VTdHlsZSgpKTtpZihudWxsIT1uJiZ0aGlzLmNvbm5lY3Rpb25IYW5kbGVyLmluc2VydEJlZm9yZVNvdXJjZSl7dmFyIHY9bnVsbDtmb3IoZD1hO251bGwhPWQucGFyZW50JiZudWxsIT1kLmdlb21ldHJ5JiZkLmdlb21ldHJ5LnJlbGF0aXZlJiZkLnBhcmVudCE9bi5wYXJlbnQ7KWQ9dGhpcy5tb2RlbC5nZXRQYXJlbnQoZCk7bnVsbCE9ZCYmbnVsbCE9ZC5wYXJlbnQmJmQucGFyZW50PT1uLnBhcmVudCYmKHY9ZC5wYXJlbnQuZ2V0SW5kZXgoZCksdGhpcy5tb2RlbC5hZGQoZC5wYXJlbnQsbix2KSl9bnVsbD09ayYmbnVsbCE9cSYmbnVsbCE9cCYmbnVsbCE9YS5wYXJlbnQmJnAuY29uc3RydWN0b3I9PQpteFN0YWNrTGF5b3V0JiZjPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVCYmKHY9YS5wYXJlbnQuZ2V0SW5kZXgoYSksdGhpcy5tb2RlbC5hZGQoYS5wYXJlbnQscSx2KSk7bnVsbCE9biYmZi5wdXNoKG4pO251bGw9PWsmJm51bGwhPXEmJmYucHVzaChxKTtudWxsPT1xJiZudWxsIT1uJiZuLmdlb21ldHJ5LnNldFRlcm1pbmFsUG9pbnQoYiwhMSk7bnVsbCE9biYmdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImNlbGxzSW5zZXJ0ZWQiLCJjZWxscyIsW25dKSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfXJldHVybiBmfTsKR3JhcGgucHJvdG90eXBlLmdldEluZGV4YWJsZVRleHQ9ZnVuY3Rpb24oKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxjPVtdLGYsZDtmb3IoZCBpbiB0aGlzLm1vZGVsLmNlbGxzKWlmKGY9dGhpcy5tb2RlbC5jZWxsc1tkXSx0aGlzLm1vZGVsLmlzVmVydGV4KGYpfHx0aGlzLm1vZGVsLmlzRWRnZShmKSl0aGlzLmlzSHRtbExhYmVsKGYpPyhhLmlubmVySFRNTD10aGlzLnNhbml0aXplSHRtbCh0aGlzLmdldExhYmVsKGYpKSxmPW14VXRpbHMuZXh0cmFjdFRleHRXaXRoV2hpdGVzcGFjZShbYV0pKTpmPXRoaXMuZ2V0TGFiZWwoZiksZj1teFV0aWxzLnRyaW0oZi5yZXBsYWNlKC9bXHgwMC1ceDFGXHg3Ri1ceDlGXXxccysvZywiICIpKSwwPGYubGVuZ3RoJiZjLnB1c2goZik7cmV0dXJuIGMuam9pbigiICIpfTsKR3JhcGgucHJvdG90eXBlLmNvbnZlcnRWYWx1ZVRvU3RyaW5nPWZ1bmN0aW9uKGEpe3ZhciBjPXRoaXMubW9kZWwuZ2V0VmFsdWUoYSk7aWYobnVsbCE9YyYmIm9iamVjdCI9PXR5cGVvZiBjKXtpZih0aGlzLmlzUmVwbGFjZVBsYWNlaG9sZGVycyhhKSYmbnVsbCE9YS5nZXRBdHRyaWJ1dGUoInBsYWNlaG9sZGVyIikpe2Zvcih2YXIgYz1hLmdldEF0dHJpYnV0ZSgicGxhY2Vob2xkZXIiKSxmPWEsZD1udWxsO251bGw9PWQmJm51bGwhPWY7KW51bGwhPWYudmFsdWUmJiJvYmplY3QiPT10eXBlb2YgZi52YWx1ZSYmKGQ9Zi5oYXNBdHRyaWJ1dGUoYyk/bnVsbCE9Zi5nZXRBdHRyaWJ1dGUoYyk/Zi5nZXRBdHRyaWJ1dGUoYyk6IiI6bnVsbCksZj10aGlzLm1vZGVsLmdldFBhcmVudChmKTtyZXR1cm4gZHx8IiJ9cmV0dXJuIGMuZ2V0QXR0cmlidXRlKCJsYWJlbCIpfHwiIn1yZXR1cm4gbXhHcmFwaC5wcm90b3R5cGUuY29udmVydFZhbHVlVG9TdHJpbmcuYXBwbHkodGhpcyxhcmd1bWVudHMpfTsKR3JhcGgucHJvdG90eXBlLmdldExpbmtzRm9yU3RhdGU9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEmJm51bGwhPWEudGV4dCYmbnVsbCE9YS50ZXh0Lm5vZGU/YS50ZXh0Lm5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImEiKTpudWxsfTtHcmFwaC5wcm90b3R5cGUuZ2V0TGlua0ZvckNlbGw9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEudmFsdWUmJiJvYmplY3QiPT10eXBlb2YgYS52YWx1ZT8oYT1hLnZhbHVlLmdldEF0dHJpYnV0ZSgibGluayIpLG51bGwhPWEmJiJqYXZhc2NyaXB0OiI9PT1hLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDAsMTEpJiYoYT1hLnN1YnN0cmluZygxMSkpLGEpOm51bGx9OwpHcmFwaC5wcm90b3R5cGUuZ2V0Q2VsbFN0eWxlPWZ1bmN0aW9uKGEpe3ZhciBjPW14R3JhcGgucHJvdG90eXBlLmdldENlbGxTdHlsZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYobnVsbCE9YSYmbnVsbCE9dGhpcy5sYXlvdXRNYW5hZ2VyKXt2YXIgZj10aGlzLm1vZGVsLmdldFBhcmVudChhKTt0aGlzLm1vZGVsLmlzVmVydGV4KGYpJiZ0aGlzLmlzQ2VsbENvbGxhcHNlZChhKSYmKGY9dGhpcy5sYXlvdXRNYW5hZ2VyLmdldExheW91dChmKSxudWxsIT1mJiZmLmNvbnN0cnVjdG9yPT1teFN0YWNrTGF5b3V0JiYoY1tteENvbnN0YW50cy5TVFlMRV9IT1JJWk9OVEFMXT0hZi5ob3Jpem9udGFsKSl9cmV0dXJuIGN9OwpHcmFwaC5wcm90b3R5cGUudXBkYXRlQWx0ZXJuYXRlQm91bmRzPWZ1bmN0aW9uKGEsYyxmKXtpZihudWxsIT1hJiZudWxsIT1jJiZudWxsIT10aGlzLmxheW91dE1hbmFnZXImJm51bGwhPWMuYWx0ZXJuYXRlQm91bmRzKXt2YXIgZD10aGlzLmxheW91dE1hbmFnZXIuZ2V0TGF5b3V0KHRoaXMubW9kZWwuZ2V0UGFyZW50KGEpKTtudWxsIT1kJiZkLmNvbnN0cnVjdG9yPT1teFN0YWNrTGF5b3V0JiYoZC5ob3Jpem9udGFsP2MuYWx0ZXJuYXRlQm91bmRzLmhlaWdodD0wOmMuYWx0ZXJuYXRlQm91bmRzLndpZHRoPTApfW14R3JhcGgucHJvdG90eXBlLnVwZGF0ZUFsdGVybmF0ZUJvdW5kcy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O0dyYXBoLnByb3RvdHlwZS5pc01vdmVDZWxsc0V2ZW50PWZ1bmN0aW9uKGEsYyl7cmV0dXJuIG14RXZlbnQuaXNTaGlmdERvd24oYSl8fCIxIj09bXhVdGlscy5nZXRWYWx1ZShjLnN0eWxlLCJtb3ZlQ2VsbHMiLCIwIil9OwpHcmFwaC5wcm90b3R5cGUuZm9sZENlbGxzPWZ1bmN0aW9uKGEsYyxmLGQsbSl7Yz1udWxsIT1jP2M6ITE7bnVsbD09ZiYmKGY9dGhpcy5nZXRGb2xkYWJsZUNlbGxzKHRoaXMuZ2V0U2VsZWN0aW9uQ2VsbHMoKSxhKSk7aWYobnVsbCE9Zil7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtpZihteEdyYXBoLnByb3RvdHlwZS5mb2xkQ2VsbHMuYXBwbHkodGhpcyxhcmd1bWVudHMpLG51bGwhPXRoaXMubGF5b3V0TWFuYWdlcilmb3IodmFyIGs9MDtrPGYubGVuZ3RoO2srKyl7dmFyIHE9dGhpcy52aWV3LmdldFN0YXRlKGZba10pLGI9dGhpcy5nZXRDZWxsR2VvbWV0cnkoZltrXSk7aWYobnVsbCE9cSYmbnVsbCE9Yil7dmFyIGU9TWF0aC5yb3VuZChiLndpZHRoLXEud2lkdGgvdGhpcy52aWV3LnNjYWxlKSxnPU1hdGgucm91bmQoYi5oZWlnaHQtcS5oZWlnaHQvdGhpcy52aWV3LnNjYWxlKTtpZigwIT1nfHwwIT1lKXt2YXIgcD10aGlzLm1vZGVsLmdldFBhcmVudChmW2tdKSxsPXRoaXMubGF5b3V0TWFuYWdlci5nZXRMYXlvdXQocCk7Cm51bGw9PWw/bnVsbCE9bSYmdGhpcy5pc01vdmVDZWxsc0V2ZW50KG0scSkmJnRoaXMubW92ZVNpYmxpbmdzKHEscCxlLGcpOm51bGwhPW0mJm14RXZlbnQuaXNBbHREb3duKG0pfHxsLmNvbnN0cnVjdG9yIT1teFN0YWNrTGF5b3V0fHxsLnJlc2l6ZUxhc3R8fHRoaXMucmVzaXplUGFyZW50U3RhY2tzKHAsbCxlLGcpfX19fWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX10aGlzLmlzRW5hYmxlZCgpJiZ0aGlzLnNldFNlbGVjdGlvbkNlbGxzKGYpfX07CkdyYXBoLnByb3RvdHlwZS5tb3ZlU2libGluZ3M9ZnVuY3Rpb24oYSxjLGYsZCl7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgbT10aGlzLmdldENlbGxzQmV5b25kKGEueCxhLnksYywhMCwhMCk7Zm9yKGM9MDtjPG0ubGVuZ3RoO2MrKylpZihtW2NdIT1hLmNlbGwpe3ZhciBrPXRoaXMudmlldy5nZXRTdGF0ZShtW2NdKSxxPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KG1bY10pO251bGwhPWsmJm51bGwhPXEmJihxPXEuY2xvbmUoKSxxLnRyYW5zbGF0ZShNYXRoLnJvdW5kKGYqTWF0aC5tYXgoMCxNYXRoLm1pbigxLChrLngtYS54KS9hLndpZHRoKSkpLE1hdGgucm91bmQoZCpNYXRoLm1heCgwLE1hdGgubWluKDEsKGsueS1hLnkpL2EuaGVpZ2h0KSkpKSx0aGlzLm1vZGVsLnNldEdlb21ldHJ5KG1bY10scSkpfX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9fTsKR3JhcGgucHJvdG90eXBlLnJlc2l6ZVBhcmVudFN0YWNrcz1mdW5jdGlvbihhLGMsZixkKXtpZihudWxsIT10aGlzLmxheW91dE1hbmFnZXImJm51bGwhPWMmJmMuY29uc3RydWN0b3I9PW14U3RhY2tMYXlvdXQmJiFjLnJlc2l6ZUxhc3Qpe3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBtPWMuaG9yaXpvbnRhbDtudWxsIT1hJiZudWxsIT1jJiZjLmNvbnN0cnVjdG9yPT1teFN0YWNrTGF5b3V0JiZjLmhvcml6b250YWw9PW0mJiFjLnJlc2l6ZUxhc3Q7KXt2YXIgaz10aGlzLmdldENlbGxHZW9tZXRyeShhKSxxPXRoaXMudmlldy5nZXRTdGF0ZShhKTtudWxsIT1xJiZudWxsIT1rJiYoaz1rLmNsb25lKCksYy5ob3Jpem9udGFsP2sud2lkdGgrPWYrTWF0aC5taW4oMCxxLndpZHRoL3RoaXMudmlldy5zY2FsZS1rLndpZHRoKTprLmhlaWdodCs9ZCtNYXRoLm1pbigwLHEuaGVpZ2h0L3RoaXMudmlldy5zY2FsZS1rLmhlaWdodCksdGhpcy5tb2RlbC5zZXRHZW9tZXRyeShhLAprKSk7YT10aGlzLm1vZGVsLmdldFBhcmVudChhKTtjPXRoaXMubGF5b3V0TWFuYWdlci5nZXRMYXlvdXQoYSl9fWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX19fTtHcmFwaC5wcm90b3R5cGUuaXNDb250YWluZXI9ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpO3JldHVybiB0aGlzLmlzU3dpbWxhbmUoYSk/IjAiIT1jLmNvbnRhaW5lcjoiMSI9PWMuY29udGFpbmVyfTtHcmFwaC5wcm90b3R5cGUuaXNDZWxsQ29ubmVjdGFibGU9ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpO3JldHVybiBudWxsIT1jLmNvbm5lY3RhYmxlPyIwIiE9Yy5jb25uZWN0YWJsZTpteEdyYXBoLnByb3RvdHlwZS5pc0NlbGxDb25uZWN0YWJsZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9OwpHcmFwaC5wcm90b3R5cGUuaXNMYWJlbE1vdmFibGU9ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpO3JldHVybiBudWxsIT1jLm1vdmFibGVMYWJlbD8iMCIhPWMubW92YWJsZUxhYmVsOm14R3JhcGgucHJvdG90eXBlLmlzTGFiZWxNb3ZhYmxlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07R3JhcGgucHJvdG90eXBlLnNlbGVjdEFsbD1mdW5jdGlvbihhKXthPWF8fHRoaXMuZ2V0RGVmYXVsdFBhcmVudCgpO3RoaXMuaXNDZWxsTG9ja2VkKGEpfHxteEdyYXBoLnByb3RvdHlwZS5zZWxlY3RBbGwuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtHcmFwaC5wcm90b3R5cGUuc2VsZWN0Q2VsbHM9ZnVuY3Rpb24oYSxjLGYpe2Y9Znx8dGhpcy5nZXREZWZhdWx0UGFyZW50KCk7dGhpcy5pc0NlbGxMb2NrZWQoZil8fG14R3JhcGgucHJvdG90eXBlLnNlbGVjdENlbGxzLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07CkdyYXBoLnByb3RvdHlwZS5nZXRTd2ltbGFuZUF0PWZ1bmN0aW9uKGEsYyxmKXt2YXIgZD1teEdyYXBoLnByb3RvdHlwZS5nZXRTd2ltbGFuZUF0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLmlzQ2VsbExvY2tlZChkKSYmKGQ9bnVsbCk7cmV0dXJuIGR9O0dyYXBoLnByb3RvdHlwZS5pc0NlbGxGb2xkYWJsZT1mdW5jdGlvbihhKXt2YXIgYz10aGlzLmdldEN1cnJlbnRDZWxsU3R5bGUoYSk7cmV0dXJuIHRoaXMuZm9sZGluZ0VuYWJsZWQmJigiMSI9PWMudHJlZUZvbGRpbmd8fCF0aGlzLmlzQ2VsbExvY2tlZChhKSYmKHRoaXMuaXNDb250YWluZXIoYSkmJiIwIiE9Yy5jb2xsYXBzaWJsZXx8IXRoaXMuaXNDb250YWluZXIoYSkmJiIxIj09Yy5jb2xsYXBzaWJsZSkpfTtHcmFwaC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmlzRWRpdGluZygpJiZ0aGlzLnN0b3BFZGl0aW5nKCEwKTt0aGlzLmVzY2FwZSgpO3RoaXMuaXNTZWxlY3Rpb25FbXB0eSgpfHx0aGlzLmNsZWFyU2VsZWN0aW9uKCl9OwpHcmFwaC5wcm90b3R5cGUuem9vbT1mdW5jdGlvbihhLGMpe2E9TWF0aC5tYXgoLjAxLE1hdGgubWluKHRoaXMudmlldy5zY2FsZSphLDE2MCkpL3RoaXMudmlldy5zY2FsZTtteEdyYXBoLnByb3RvdHlwZS56b29tLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07R3JhcGgucHJvdG90eXBlLnpvb21Jbj1mdW5jdGlvbigpey4xNT50aGlzLnZpZXcuc2NhbGU/dGhpcy56b29tKCh0aGlzLnZpZXcuc2NhbGUrLjAxKS90aGlzLnZpZXcuc2NhbGUpOnRoaXMuem9vbShNYXRoLnJvdW5kKHRoaXMudmlldy5zY2FsZSp0aGlzLnpvb21GYWN0b3IqMjApLzIwL3RoaXMudmlldy5zY2FsZSl9O0dyYXBoLnByb3RvdHlwZS56b29tT3V0PWZ1bmN0aW9uKCl7LjE1Pj10aGlzLnZpZXcuc2NhbGU/dGhpcy56b29tKCh0aGlzLnZpZXcuc2NhbGUtLjAxKS90aGlzLnZpZXcuc2NhbGUpOnRoaXMuem9vbShNYXRoLnJvdW5kKDEvdGhpcy56b29tRmFjdG9yKnRoaXMudmlldy5zY2FsZSoyMCkvMjAvdGhpcy52aWV3LnNjYWxlKX07CkdyYXBoLnByb3RvdHlwZS5nZXRUb29sdGlwRm9yQ2VsbD1mdW5jdGlvbihhKXt2YXIgYz0iIjtpZihteFV0aWxzLmlzTm9kZShhLnZhbHVlKSl7dmFyIGY9YS52YWx1ZS5nZXRBdHRyaWJ1dGUoInRvb2x0aXAiKTtpZihudWxsIT1mKW51bGwhPWYmJnRoaXMuaXNSZXBsYWNlUGxhY2Vob2xkZXJzKGEpJiYoZj10aGlzLnJlcGxhY2VQbGFjZWhvbGRlcnMoYSxmKSksYz10aGlzLnNhbml0aXplSHRtbChmKTtlbHNle2Y9dGhpcy5idWlsdEluUHJvcGVydGllczthPWEudmFsdWUuYXR0cmlidXRlczt2YXIgZD1bXTt0aGlzLmlzRW5hYmxlZCgpJiZmLnB1c2goImxpbmsiKTtmb3IodmFyIG09MDttPGEubGVuZ3RoO20rKykwPm14VXRpbHMuaW5kZXhPZihmLGFbbV0ubm9kZU5hbWUpJiYwPGFbbV0ubm9kZVZhbHVlLmxlbmd0aCYmZC5wdXNoKHtuYW1lOmFbbV0ubm9kZU5hbWUsdmFsdWU6YVttXS5ub2RlVmFsdWV9KTtkLnNvcnQoZnVuY3Rpb24oYSxjKXtyZXR1cm4gYS5uYW1lPGMubmFtZT8KLTE6YS5uYW1lPmMubmFtZT8xOjB9KTtmb3IobT0wO208ZC5sZW5ndGg7bSsrKSJsaW5rIj09ZFttXS5uYW1lJiZ0aGlzLmlzQ3VzdG9tTGluayhkW21dLnZhbHVlKXx8KGMrPSgibGluayIhPWRbbV0ubmFtZT8iPGI+IitkW21dLm5hbWUrIjo8L2I+ICI6IiIpK214VXRpbHMuaHRtbEVudGl0aWVzKGRbbV0udmFsdWUpKyJcbiIpOzA8Yy5sZW5ndGgmJihjPWMuc3Vic3RyaW5nKDAsYy5sZW5ndGgtMSksbXhDbGllbnQuSVNfU1ZHJiYoYz0nPGRpdiBzdHlsZT0ibWF4LXdpZHRoOjM2MHB4OyI+JytjKyI8L2Rpdj4iKSl9fXJldHVybiBjfTtHcmFwaC5wcm90b3R5cGUuc3RyaW5nVG9CeXRlcz1mdW5jdGlvbihhKXtyZXR1cm4gR3JhcGguc3RyaW5nVG9CeXRlcyhhKX07R3JhcGgucHJvdG90eXBlLmJ5dGVzVG9TdHJpbmc9ZnVuY3Rpb24oYSl7cmV0dXJuIEdyYXBoLmJ5dGVzVG9TdHJpbmcoYSl9O0dyYXBoLnByb3RvdHlwZS5jb21wcmVzc05vZGU9ZnVuY3Rpb24oYSl7cmV0dXJuIEdyYXBoLmNvbXByZXNzTm9kZShhKX07CkdyYXBoLnByb3RvdHlwZS5jb21wcmVzcz1mdW5jdGlvbihhLGMpe3JldHVybiBHcmFwaC5jb21wcmVzcyhhLGMpfTtHcmFwaC5wcm90b3R5cGUuZGVjb21wcmVzcz1mdW5jdGlvbihhLGMpe3JldHVybiBHcmFwaC5kZWNvbXByZXNzKGEsYyl9O0dyYXBoLnByb3RvdHlwZS56YXBHcmVtbGlucz1mdW5jdGlvbihhKXtyZXR1cm4gR3JhcGguemFwR3JlbWxpbnMoYSl9O0hvdmVySWNvbnM9ZnVuY3Rpb24oYSl7dGhpcy5ncmFwaD1hO3RoaXMuaW5pdCgpfTtIb3Zlckljb25zLnByb3RvdHlwZS5hcnJvd1NwYWNpbmc9MjtIb3Zlckljb25zLnByb3RvdHlwZS51cGRhdGVEZWxheT01MDA7SG92ZXJJY29ucy5wcm90b3R5cGUuYWN0aXZhdGlvbkRlbGF5PTE0MDtIb3Zlckljb25zLnByb3RvdHlwZS5jdXJyZW50U3RhdGU9bnVsbDtIb3Zlckljb25zLnByb3RvdHlwZS5hY3RpdmVBcnJvdz1udWxsO0hvdmVySWNvbnMucHJvdG90eXBlLmluYWN0aXZlT3BhY2l0eT0xNTsKSG92ZXJJY29ucy5wcm90b3R5cGUuY3NzQ3Vyc29yPSJjb3B5IjtIb3Zlckljb25zLnByb3RvdHlwZS5jaGVja0NvbGxpc2lvbnM9ITA7SG92ZXJJY29ucy5wcm90b3R5cGUuYXJyb3dGaWxsPSIjMjliNmYyIjtIb3Zlckljb25zLnByb3RvdHlwZS50cmlhbmdsZVVwPW14Q2xpZW50LklTX1NWRz9HcmFwaC5jcmVhdGVTdmdJbWFnZSgxOCwyOCwnPHBhdGggZD0ibSA2IDI2IEwgMTIgMjYgTCAxMiAxMiBMIDE4IDEyIEwgOSAxIEwgMSAxMiBMIDYgMTIgeiIgc3Ryb2tlPSIjZmZmIiBmaWxsPSInK0hvdmVySWNvbnMucHJvdG90eXBlLmFycm93RmlsbCsnIi8+Jyk6bmV3IG14SW1hZ2UoSU1BR0VfUEFUSCsiL3RyaWFuZ2xlLXVwLnBuZyIsMjYsMTQpOwpIb3Zlckljb25zLnByb3RvdHlwZS50cmlhbmdsZVJpZ2h0PW14Q2xpZW50LklTX1NWRz9HcmFwaC5jcmVhdGVTdmdJbWFnZSgyNiwxOCwnPHBhdGggZD0ibSAxIDYgTCAxNCA2IEwgMTQgMSBMIDI2IDkgTCAxNCAxOCBMIDE0IDEyIEwgMSAxMiB6IiBzdHJva2U9IiNmZmYiIGZpbGw9IicrSG92ZXJJY29ucy5wcm90b3R5cGUuYXJyb3dGaWxsKyciLz4nKTpuZXcgbXhJbWFnZShJTUFHRV9QQVRIKyIvdHJpYW5nbGUtcmlnaHQucG5nIiwxNCwyNik7SG92ZXJJY29ucy5wcm90b3R5cGUudHJpYW5nbGVEb3duPW14Q2xpZW50LklTX1NWRz9HcmFwaC5jcmVhdGVTdmdJbWFnZSgxOCwyNiwnPHBhdGggZD0ibSA2IDEgTCA2IDE0IEwgMSAxNCBMIDkgMjYgTCAxOCAxNCBMIDEyIDE0IEwgMTIgMSB6IiBzdHJva2U9IiNmZmYiIGZpbGw9IicrSG92ZXJJY29ucy5wcm90b3R5cGUuYXJyb3dGaWxsKyciLz4nKTpuZXcgbXhJbWFnZShJTUFHRV9QQVRIKyIvdHJpYW5nbGUtZG93bi5wbmciLDI2LDE0KTsKSG92ZXJJY29ucy5wcm90b3R5cGUudHJpYW5nbGVMZWZ0PW14Q2xpZW50LklTX1NWRz9HcmFwaC5jcmVhdGVTdmdJbWFnZSgyOCwxOCwnPHBhdGggZD0ibSAxIDkgTCAxMiAxIEwgMTIgNiBMIDI2IDYgTCAyNiAxMiBMIDEyIDEyIEwgMTIgMTggeiIgc3Ryb2tlPSIjZmZmIiBmaWxsPSInK0hvdmVySWNvbnMucHJvdG90eXBlLmFycm93RmlsbCsnIi8+Jyk6bmV3IG14SW1hZ2UoSU1BR0VfUEFUSCsiL3RyaWFuZ2xlLWxlZnQucG5nIiwxNCwyNik7SG92ZXJJY29ucy5wcm90b3R5cGUucm91bmREcm9wPW14Q2xpZW50LklTX1NWRz9HcmFwaC5jcmVhdGVTdmdJbWFnZSgyNiwyNiwnPGNpcmNsZSBjeD0iMTMiIGN5PSIxMyIgcj0iMTIiIHN0cm9rZT0iI2ZmZiIgZmlsbD0iJytIb3Zlckljb25zLnByb3RvdHlwZS5hcnJvd0ZpbGwrJyIvPicpOm5ldyBteEltYWdlKElNQUdFX1BBVEgrIi9yb3VuZC1kcm9wLnBuZyIsMjYsMjYpOwpIb3Zlckljb25zLnByb3RvdHlwZS5yZWZyZXNoVGFyZ2V0PW5ldyBteEltYWdlKG14Q2xpZW50LklTX1NWRz8iZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJZ2QybGtkR2c5SWpNMmNIZ2lJR2hsYVdkb2REMGlNelp3ZUNJK1BHVnNiR2x3YzJVZ1ptbHNiRDBpSXpJNVlqWm1NaUlnWTNnOUlqRXlJaUJqZVQwaU1USWlJSEo0UFNJeE1pSWdjbms5SWpFeUlpOCtQSEJoZEdnZ2RISmhibk5tYjNKdFBTSnpZMkZzWlNnd0xqZ3BJSFJ5WVc1emJHRjBaU2d5TGpRc0lESXVOQ2tpSUhOMGNtOXJaVDBpSTJabVppSWdabWxzYkQwaUkyWm1aaUlnWkQwaVRURXlJRFoyTTJ3MExUUXROQzAwZGpOakxUUXVORElnTUMwNElETXVOVGd0T0NBNElEQWdNUzQxTnk0ME5pQXpMakF6SURFdU1qUWdOQzR5Tmt3MkxqY2dNVFF1T0dNdExqUTFMUzQ0TXkwdU55MHhMamM1TFM0M0xUSXVPQ0F3TFRNdU16RWdNaTQyT1MwMklEWXRObnB0Tmk0M05pQXhMamMwVERFM0xqTWdPUzR5WXk0ME5DNDROQzQzSURFdU56a3VOeUF5TGpnZ01DQXpMak14TFRJdU5qa2dOaTAySURaMkxUTnNMVFFnTkNBMElEUjJMVE5qTkM0ME1pQXdJRGd0TXk0MU9DQTRMVGdnTUMweExqVTNMUzQwTmkwekxqQXpMVEV1TWpRdE5DNHlObm9pTHo0OGNHRjBhQ0JrUFNKTk1DQXdhREkwZGpJMFNEQjZJaUJtYVd4c1BTSnViMjVsSWk4K1BDOXpkbWMrQ2c9PSI6CklNQUdFX1BBVEgrIi9yZWZyZXNoLnBuZyIsMzgsMzgpO0hvdmVySWNvbnMucHJvdG90eXBlLnRvbGVyYW5jZT1teENsaWVudC5JU19UT1VDSD82OjA7CkhvdmVySWNvbnMucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oKXt0aGlzLmFycm93VXA9dGhpcy5jcmVhdGVBcnJvdyh0aGlzLnRyaWFuZ2xlVXAsbXhSZXNvdXJjZXMuZ2V0KCJwbHVzVG9vbHRpcCIpKTt0aGlzLmFycm93UmlnaHQ9dGhpcy5jcmVhdGVBcnJvdyh0aGlzLnRyaWFuZ2xlUmlnaHQsbXhSZXNvdXJjZXMuZ2V0KCJwbHVzVG9vbHRpcCIpKTt0aGlzLmFycm93RG93bj10aGlzLmNyZWF0ZUFycm93KHRoaXMudHJpYW5nbGVEb3duLG14UmVzb3VyY2VzLmdldCgicGx1c1Rvb2x0aXAiKSk7dGhpcy5hcnJvd0xlZnQ9dGhpcy5jcmVhdGVBcnJvdyh0aGlzLnRyaWFuZ2xlTGVmdCxteFJlc291cmNlcy5nZXQoInBsdXNUb29sdGlwIikpO3RoaXMuZWx0cz1bdGhpcy5hcnJvd1VwLHRoaXMuYXJyb3dSaWdodCx0aGlzLmFycm93RG93bix0aGlzLmFycm93TGVmdF07dGhpcy5yZXNldEhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnJlc2V0KCl9KTt0aGlzLnJlcGFpbnRIYW5kbGVyPQpteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMucmVwYWludCgpfSk7dGhpcy5ncmFwaC5zZWxlY3Rpb25Nb2RlbC5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSx0aGlzLnJlc2V0SGFuZGxlcik7dGhpcy5ncmFwaC5tb2RlbC5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSx0aGlzLnJlcGFpbnRIYW5kbGVyKTt0aGlzLmdyYXBoLnZpZXcuYWRkTGlzdGVuZXIobXhFdmVudC5TQ0FMRV9BTkRfVFJBTlNMQVRFLHRoaXMucmVwYWludEhhbmRsZXIpO3RoaXMuZ3JhcGgudmlldy5hZGRMaXN0ZW5lcihteEV2ZW50LlRSQU5TTEFURSx0aGlzLnJlcGFpbnRIYW5kbGVyKTt0aGlzLmdyYXBoLnZpZXcuYWRkTGlzdGVuZXIobXhFdmVudC5TQ0FMRSx0aGlzLnJlcGFpbnRIYW5kbGVyKTt0aGlzLmdyYXBoLnZpZXcuYWRkTGlzdGVuZXIobXhFdmVudC5ET1dOLHRoaXMucmVwYWludEhhbmRsZXIpO3RoaXMuZ3JhcGgudmlldy5hZGRMaXN0ZW5lcihteEV2ZW50LlVQLHRoaXMucmVwYWludEhhbmRsZXIpOwp0aGlzLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuUk9PVCx0aGlzLnJlcGFpbnRIYW5kbGVyKTt0aGlzLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuRVNDQVBFLHRoaXMucmVzZXRIYW5kbGVyKTtteEV2ZW50LmFkZExpc3RlbmVyKHRoaXMuZ3JhcGguY29udGFpbmVyLCJzY3JvbGwiLHRoaXMucmVzZXRIYW5kbGVyKTt0aGlzLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuRVNDQVBFLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5tb3VzZURvd25Qb2ludD1udWxsfSkpO214RXZlbnQuYWRkTGlzdGVuZXIodGhpcy5ncmFwaC5jb250YWluZXIsIm1vdXNlbGVhdmUiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe251bGwhPWEucmVsYXRlZFRhcmdldCYmbXhFdmVudC5nZXRTb3VyY2UoYSk9PXRoaXMuZ3JhcGguY29udGFpbmVyJiZ0aGlzLnNldERpc3BsYXkoIm5vbmUiKX0pKTt0aGlzLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuU1RBUlRfRURJVElORywKbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5yZXNldCgpfSkpO3ZhciBhPXRoaXMuZ3JhcGguY2xpY2s7dGhpcy5ncmFwaC5jbGljaz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihjKXthLmFwcGx5KHRoaXMuZ3JhcGgsYXJndW1lbnRzKTtudWxsPT10aGlzLmN1cnJlbnRTdGF0ZXx8dGhpcy5ncmFwaC5pc0NlbGxTZWxlY3RlZCh0aGlzLmN1cnJlbnRTdGF0ZS5jZWxsKXx8IW14RXZlbnQuaXNUb3VjaEV2ZW50KGMuZ2V0RXZlbnQoKSl8fHRoaXMuZ3JhcGgubW9kZWwuaXNWZXJ0ZXgoYy5nZXRDZWxsKCkpfHx0aGlzLnJlc2V0KCl9KTt2YXIgYz0hMTt0aGlzLmdyYXBoLmFkZE1vdXNlTGlzdGVuZXIoe21vdXNlRG93bjpteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGQpe2M9ITE7dmFyIGY9ZC5nZXRFdmVudCgpO2lmKHRoaXMuaXNSZXNldEV2ZW50KGYpKXRoaXMucmVzZXQoKTtlbHNlIGlmKCF0aGlzLmlzQWN0aXZlKCkpe3ZhciBrPXRoaXMuZ2V0U3RhdGUoZC5nZXRTdGF0ZSgpKTsKbnVsbD09ayYmbXhFdmVudC5pc1RvdWNoRXZlbnQoZil8fHRoaXMudXBkYXRlKGspfXRoaXMuc2V0RGlzcGxheSgibm9uZSIpfSksbW91c2VNb3ZlOm14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsZCl7dmFyIGY9ZC5nZXRFdmVudCgpO3RoaXMuaXNSZXNldEV2ZW50KGYpP3RoaXMucmVzZXQoKTp0aGlzLmdyYXBoLmlzTW91c2VEb3dufHxteEV2ZW50LmlzVG91Y2hFdmVudChmKXx8dGhpcy51cGRhdGUodGhpcy5nZXRTdGF0ZShkLmdldFN0YXRlKCkpLGQuZ2V0R3JhcGhYKCksZC5nZXRHcmFwaFkoKSk7bnVsbCE9dGhpcy5ncmFwaC5jb25uZWN0aW9uSGFuZGxlciYmbnVsbCE9dGhpcy5ncmFwaC5jb25uZWN0aW9uSGFuZGxlci5zaGFwZSYmKGM9ITApfSksbW91c2VVcDpteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGQpe3ZhciBmPWQuZ2V0RXZlbnQoKTtteFV0aWxzLmNvbnZlcnRQb2ludCh0aGlzLmdyYXBoLmNvbnRhaW5lcixteEV2ZW50LmdldENsaWVudFgoZiksbXhFdmVudC5nZXRDbGllbnRZKGYpKTsKdGhpcy5pc1Jlc2V0RXZlbnQoZik/dGhpcy5yZXNldCgpOnRoaXMuaXNBY3RpdmUoKSYmIWMmJm51bGwhPXRoaXMubW91c2VEb3duUG9pbnQ/dGhpcy5jbGljayh0aGlzLmN1cnJlbnRTdGF0ZSx0aGlzLmdldERpcmVjdGlvbigpLGQpOnRoaXMuaXNBY3RpdmUoKT8xPT10aGlzLmdyYXBoLmdldFNlbGVjdGlvbkNvdW50KCkmJnRoaXMuZ3JhcGgubW9kZWwuaXNFZGdlKHRoaXMuZ3JhcGguZ2V0U2VsZWN0aW9uQ2VsbCgpKT90aGlzLnJlc2V0KCk6dGhpcy51cGRhdGUodGhpcy5nZXRTdGF0ZSh0aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUodGhpcy5ncmFwaC5nZXRDZWxsQXQoZC5nZXRHcmFwaFgoKSxkLmdldEdyYXBoWSgpKSkpKTpteEV2ZW50LmlzVG91Y2hFdmVudChmKXx8bnVsbCE9dGhpcy5iYm94JiZteFV0aWxzLmNvbnRhaW5zKHRoaXMuYmJveCxkLmdldEdyYXBoWCgpLGQuZ2V0R3JhcGhZKCkpPyh0aGlzLnNldERpc3BsYXkoIiIpLHRoaXMucmVwYWludCgpKTpteEV2ZW50LmlzVG91Y2hFdmVudChmKXx8CnRoaXMucmVzZXQoKTtjPSExO3RoaXMucmVzZXRBY3RpdmVBcnJvdygpfSl9KX07SG92ZXJJY29ucy5wcm90b3R5cGUuaXNSZXNldEV2ZW50PWZ1bmN0aW9uKGEsYyl7cmV0dXJuIG14RXZlbnQuaXNBbHREb3duKGEpfHxudWxsPT10aGlzLmFjdGl2ZUFycm93JiZteEV2ZW50LmlzU2hpZnREb3duKGEpfHxteEV2ZW50LmlzTWV0YURvd24oYSl8fG14RXZlbnQuaXNQb3B1cFRyaWdnZXIoYSkmJiFteEV2ZW50LmlzQ29udHJvbERvd24oYSl9OwpIb3Zlckljb25zLnByb3RvdHlwZS5jcmVhdGVBcnJvdz1mdW5jdGlvbihhLGMpe3ZhciBmPW51bGw7bXhDbGllbnQuSVNfSUUmJiFteENsaWVudC5JU19TVkc/KG14Q2xpZW50LklTX0lFNiYmIkNTUzFDb21wYXQiIT1kb2N1bWVudC5jb21wYXRNb2RlPyhmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobXhDbGllbnQuVk1MX1BSRUZJWCsiOmltYWdlIiksZi5zZXRBdHRyaWJ1dGUoInNyYyIsYS5zcmMpLGYuc3R5bGUuYm9yZGVyU3R5bGU9Im5vbmUiKTooZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxmLnN0eWxlLmJhY2tncm91bmRJbWFnZT0idXJsKCIrYS5zcmMrIikiLGYuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uPSJjZW50ZXIiLGYuc3R5bGUuYmFja2dyb3VuZFJlcGVhdD0ibm8tcmVwZWF0IiksZi5zdHlsZS53aWR0aD1hLndpZHRoKzQrInB4IixmLnN0eWxlLmhlaWdodD1hLmhlaWdodCs0KyJweCIsZi5zdHlsZS5kaXNwbGF5PW14Q2xpZW50LklTX1FVSVJLUz8iaW5saW5lIjoKImlubGluZS1ibG9jayIpOihmPW14VXRpbHMuY3JlYXRlSW1hZ2UoYS5zcmMpLGYuc3R5bGUud2lkdGg9YS53aWR0aCsicHgiLGYuc3R5bGUuaGVpZ2h0PWEuaGVpZ2h0KyJweCIsZi5zdHlsZS5wYWRkaW5nPXRoaXMudG9sZXJhbmNlKyJweCIpO251bGwhPWMmJmYuc2V0QXR0cmlidXRlKCJ0aXRsZSIsYyk7Zi5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO2Yuc3R5bGUuY3Vyc29yPXRoaXMuY3NzQ3Vyc29yO214RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyhmLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe251bGw9PXRoaXMuY3VycmVudFN0YXRlfHx0aGlzLmlzUmVzZXRFdmVudChhKXx8KHRoaXMubW91c2VEb3duUG9pbnQ9bXhVdGlscy5jb252ZXJ0UG9pbnQodGhpcy5ncmFwaC5jb250YWluZXIsbXhFdmVudC5nZXRDbGllbnRYKGEpLG14RXZlbnQuZ2V0Q2xpZW50WShhKSksdGhpcy5kcmFnKGEsdGhpcy5tb3VzZURvd25Qb2ludC54LHRoaXMubW91c2VEb3duUG9pbnQueSksCnRoaXMuYWN0aXZlQXJyb3c9Zix0aGlzLnNldERpc3BsYXkoIm5vbmUiKSxteEV2ZW50LmNvbnN1bWUoYSkpfSkpO214RXZlbnQucmVkaXJlY3RNb3VzZUV2ZW50cyhmLHRoaXMuZ3JhcGgsdGhpcy5jdXJyZW50U3RhdGUpO214RXZlbnQuYWRkTGlzdGVuZXIoZiwibW91c2VlbnRlciIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bXhFdmVudC5pc01vdXNlRXZlbnQoYSkmJihudWxsIT10aGlzLmFjdGl2ZUFycm93JiZ0aGlzLmFjdGl2ZUFycm93IT1mJiZteFV0aWxzLnNldE9wYWNpdHkodGhpcy5hY3RpdmVBcnJvdyx0aGlzLmluYWN0aXZlT3BhY2l0eSksdGhpcy5ncmFwaC5jb25uZWN0aW9uSGFuZGxlci5jb25zdHJhaW50SGFuZGxlci5yZXNldCgpLG14VXRpbHMuc2V0T3BhY2l0eShmLDEwMCksdGhpcy5hY3RpdmVBcnJvdz1mKX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKGYsIm1vdXNlbGVhdmUiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuZ3JhcGguaXNNb3VzZURvd258fAp0aGlzLnJlc2V0QWN0aXZlQXJyb3coKX0pKTtyZXR1cm4gZn07SG92ZXJJY29ucy5wcm90b3R5cGUucmVzZXRBY3RpdmVBcnJvdz1mdW5jdGlvbigpe251bGwhPXRoaXMuYWN0aXZlQXJyb3cmJihteFV0aWxzLnNldE9wYWNpdHkodGhpcy5hY3RpdmVBcnJvdyx0aGlzLmluYWN0aXZlT3BhY2l0eSksdGhpcy5hY3RpdmVBcnJvdz1udWxsKX07SG92ZXJJY29ucy5wcm90b3R5cGUuZ2V0RGlyZWN0aW9uPWZ1bmN0aW9uKCl7dmFyIGE9bXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1Q7dGhpcy5hY3RpdmVBcnJvdz09dGhpcy5hcnJvd1VwP2E9bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIOnRoaXMuYWN0aXZlQXJyb3c9PXRoaXMuYXJyb3dEb3duP2E9bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIOnRoaXMuYWN0aXZlQXJyb3c9PXRoaXMuYXJyb3dMZWZ0JiYoYT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVCk7cmV0dXJuIGF9OwpIb3Zlckljb25zLnByb3RvdHlwZS52aXNpdE5vZGVzPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYz0wO2M8dGhpcy5lbHRzLmxlbmd0aDtjKyspbnVsbCE9dGhpcy5lbHRzW2NdJiZhKHRoaXMuZWx0c1tjXSl9O0hvdmVySWNvbnMucHJvdG90eXBlLnJlbW92ZU5vZGVzPWZ1bmN0aW9uKCl7dGhpcy52aXNpdE5vZGVzKGZ1bmN0aW9uKGEpe251bGwhPWEucGFyZW50Tm9kZSYmYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpfSl9O0hvdmVySWNvbnMucHJvdG90eXBlLnNldERpc3BsYXk9ZnVuY3Rpb24oYSl7dGhpcy52aXNpdE5vZGVzKGZ1bmN0aW9uKGMpe2Muc3R5bGUuZGlzcGxheT1hfSl9O0hvdmVySWNvbnMucHJvdG90eXBlLmlzQWN0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuYWN0aXZlQXJyb3cmJm51bGwhPXRoaXMuY3VycmVudFN0YXRlfTsKSG92ZXJJY29ucy5wcm90b3R5cGUuZHJhZz1mdW5jdGlvbihhLGMsZil7dGhpcy5ncmFwaC5wb3B1cE1lbnVIYW5kbGVyLmhpZGVNZW51KCk7dGhpcy5ncmFwaC5zdG9wRWRpdGluZyghMSk7bnVsbCE9dGhpcy5jdXJyZW50U3RhdGUmJih0aGlzLmdyYXBoLmNvbm5lY3Rpb25IYW5kbGVyLnN0YXJ0KHRoaXMuY3VycmVudFN0YXRlLGMsZiksdGhpcy5ncmFwaC5pc01vdXNlVHJpZ2dlcj1teEV2ZW50LmlzTW91c2VFdmVudChhKSx0aGlzLmdyYXBoLmlzTW91c2VEb3duPSEwLGM9dGhpcy5ncmFwaC5zZWxlY3Rpb25DZWxsc0hhbmRsZXIuZ2V0SGFuZGxlcih0aGlzLmN1cnJlbnRTdGF0ZS5jZWxsKSxudWxsIT1jJiZjLnNldEhhbmRsZXNWaXNpYmxlKCExKSxjPXRoaXMuZ3JhcGguY29ubmVjdGlvbkhhbmRsZXIuZWRnZVN0YXRlLG51bGwhPWEmJm14RXZlbnQuaXNTaGlmdERvd24oYSkmJm14RXZlbnQuaXNDb250cm9sRG93bihhKSYmbnVsbCE9YyYmIm9ydGhvZ29uYWxFZGdlU3R5bGUiPT09Cm14VXRpbHMuZ2V0VmFsdWUoYy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9FREdFLG51bGwpJiYoYT10aGlzLmdldERpcmVjdGlvbigpLGMuY2VsbC5zdHlsZT1teFV0aWxzLnNldFN0eWxlKGMuY2VsbC5zdHlsZSwic291cmNlUG9ydENvbnN0cmFpbnQiLGEpLGMuc3R5bGUuc291cmNlUG9ydENvbnN0cmFpbnQ9YSkpfTtIb3Zlckljb25zLnByb3RvdHlwZS5nZXRTdGF0ZUF0PWZ1bmN0aW9uKGEsYyxmKXtyZXR1cm4gdGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKHRoaXMuZ3JhcGguZ2V0Q2VsbEF0KGMsZikpfTsKSG92ZXJJY29ucy5wcm90b3R5cGUuY2xpY2s9ZnVuY3Rpb24oYSxjLGYpe3ZhciBkPWYuZ2V0RXZlbnQoKSxtPWYuZ2V0R3JhcGhYKCksaz1mLmdldEdyYXBoWSgpLG09dGhpcy5nZXRTdGF0ZUF0KGEsbSxrKTtudWxsPT1tfHwhdGhpcy5ncmFwaC5tb2RlbC5pc0VkZ2UobS5jZWxsKXx8bXhFdmVudC5pc0NvbnRyb2xEb3duKGQpfHxtLmdldFZpc2libGVUZXJtaW5hbFN0YXRlKCEwKSE9YSYmbS5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZSghMSkhPWE/bnVsbCE9YSYmdGhpcy5ncmFwaC5zZWxlY3RDZWxsc0ZvckNvbm5lY3RWZXJ0ZXgodGhpcy5ncmFwaC5jb25uZWN0VmVydGV4KGEuY2VsbCxjLHRoaXMuZ3JhcGguZGVmYXVsdEVkZ2VMZW5ndGgsZCksZCx0aGlzKToodGhpcy5ncmFwaC5zZXRTZWxlY3Rpb25DZWxsKG0uY2VsbCksdGhpcy5yZXNldCgpKTtmLmNvbnN1bWUoKX07CkhvdmVySWNvbnMucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKGEpe251bGwhPWEmJiFhfHxudWxsPT10aGlzLnVwZGF0ZVRocmVhZHx8d2luZG93LmNsZWFyVGltZW91dCh0aGlzLnVwZGF0ZVRocmVhZCk7dGhpcy5hY3RpdmVBcnJvdz10aGlzLmN1cnJlbnRTdGF0ZT10aGlzLm1vdXNlRG93blBvaW50PW51bGw7dGhpcy5yZW1vdmVOb2RlcygpO3RoaXMuYmJveD1udWxsfTsKSG92ZXJJY29ucy5wcm90b3R5cGUucmVwYWludD1mdW5jdGlvbigpe3RoaXMuYmJveD1udWxsO2lmKG51bGwhPXRoaXMuY3VycmVudFN0YXRlKXt0aGlzLmN1cnJlbnRTdGF0ZT10aGlzLmdldFN0YXRlKHRoaXMuY3VycmVudFN0YXRlKTtpZihudWxsIT10aGlzLmN1cnJlbnRTdGF0ZSYmdGhpcy5ncmFwaC5tb2RlbC5pc1ZlcnRleCh0aGlzLmN1cnJlbnRTdGF0ZS5jZWxsKSYmdGhpcy5ncmFwaC5pc0NlbGxDb25uZWN0YWJsZSh0aGlzLmN1cnJlbnRTdGF0ZS5jZWxsKSl7dmFyIGE9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZSh0aGlzLmN1cnJlbnRTdGF0ZSk7bnVsbCE9dGhpcy5jdXJyZW50U3RhdGUuc2hhcGUmJm51bGwhPXRoaXMuY3VycmVudFN0YXRlLnNoYXBlLmJvdW5kaW5nQm94JiYoYT1teFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlKHRoaXMuY3VycmVudFN0YXRlLnNoYXBlLmJvdW5kaW5nQm94KSk7YS5ncm93KHRoaXMuZ3JhcGgudG9sZXJhbmNlKTthLmdyb3codGhpcy5hcnJvd1NwYWNpbmcpOwp2YXIgYz10aGlzLmdyYXBoLnNlbGVjdGlvbkNlbGxzSGFuZGxlci5nZXRIYW5kbGVyKHRoaXMuY3VycmVudFN0YXRlLmNlbGwpO3RoaXMuZ3JhcGguaXNUYWJsZVJvdyh0aGlzLmN1cnJlbnRTdGF0ZS5jZWxsKSYmKGM9dGhpcy5ncmFwaC5zZWxlY3Rpb25DZWxsc0hhbmRsZXIuZ2V0SGFuZGxlcih0aGlzLmdyYXBoLm1vZGVsLmdldFBhcmVudCh0aGlzLmN1cnJlbnRTdGF0ZS5jZWxsKSkpO3ZhciBmPW51bGw7bnVsbCE9YyYmKGEueC09Yy5ob3Jpem9udGFsT2Zmc2V0LzIsYS55LT1jLnZlcnRpY2FsT2Zmc2V0LzIsYS53aWR0aCs9Yy5ob3Jpem9udGFsT2Zmc2V0LGEuaGVpZ2h0Kz1jLnZlcnRpY2FsT2Zmc2V0LG51bGwhPWMucm90YXRpb25TaGFwZSYmbnVsbCE9Yy5yb3RhdGlvblNoYXBlLm5vZGUmJiJoaWRkZW4iIT1jLnJvdGF0aW9uU2hhcGUubm9kZS5zdHlsZS52aXNpYmlsaXR5JiYibm9uZSIhPWMucm90YXRpb25TaGFwZS5ub2RlLnN0eWxlLmRpc3BsYXkmJm51bGwhPWMucm90YXRpb25TaGFwZS5ib3VuZGluZ0JveCYmCihmPWMucm90YXRpb25TaGFwZS5ib3VuZGluZ0JveCkpO2M9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxlLGMpe2lmKG51bGwhPWYpe3ZhciBiPW5ldyBteFJlY3RhbmdsZShlLGMsYS5jbGllbnRXaWR0aCxhLmNsaWVudEhlaWdodCk7bXhVdGlscy5pbnRlcnNlY3RzKGIsZikmJihhPT10aGlzLmFycm93VXA/Yy09Yi55K2IuaGVpZ2h0LWYueTphPT10aGlzLmFycm93UmlnaHQ/ZSs9Zi54K2Yud2lkdGgtYi54OmE9PXRoaXMuYXJyb3dEb3duP2MrPWYueStmLmhlaWdodC1iLnk6YT09dGhpcy5hcnJvd0xlZnQmJihlLT1iLngrYi53aWR0aC1mLngpKX1hLnN0eWxlLmxlZnQ9ZSsicHgiO2Euc3R5bGUudG9wPWMrInB4IjtteFV0aWxzLnNldE9wYWNpdHkoYSx0aGlzLmluYWN0aXZlT3BhY2l0eSl9KTtjKHRoaXMuYXJyb3dVcCxNYXRoLnJvdW5kKHRoaXMuY3VycmVudFN0YXRlLmdldENlbnRlclgoKS10aGlzLnRyaWFuZ2xlVXAud2lkdGgvMi10aGlzLnRvbGVyYW5jZSksTWF0aC5yb3VuZChhLnktCnRoaXMudHJpYW5nbGVVcC5oZWlnaHQtdGhpcy50b2xlcmFuY2UpKTtjKHRoaXMuYXJyb3dSaWdodCxNYXRoLnJvdW5kKGEueCthLndpZHRoLXRoaXMudG9sZXJhbmNlKSxNYXRoLnJvdW5kKHRoaXMuY3VycmVudFN0YXRlLmdldENlbnRlclkoKS10aGlzLnRyaWFuZ2xlUmlnaHQuaGVpZ2h0LzItdGhpcy50b2xlcmFuY2UpKTtjKHRoaXMuYXJyb3dEb3duLHBhcnNlSW50KHRoaXMuYXJyb3dVcC5zdHlsZS5sZWZ0KSxNYXRoLnJvdW5kKGEueSthLmhlaWdodC10aGlzLnRvbGVyYW5jZSkpO2ModGhpcy5hcnJvd0xlZnQsTWF0aC5yb3VuZChhLngtdGhpcy50cmlhbmdsZUxlZnQud2lkdGgtdGhpcy50b2xlcmFuY2UpLHBhcnNlSW50KHRoaXMuYXJyb3dSaWdodC5zdHlsZS50b3ApKTtpZih0aGlzLmNoZWNrQ29sbGlzaW9ucyl7dmFyIGM9dGhpcy5ncmFwaC5nZXRDZWxsQXQoYS54K2Eud2lkdGgrdGhpcy50cmlhbmdsZVJpZ2h0LndpZHRoLzIsdGhpcy5jdXJyZW50U3RhdGUuZ2V0Q2VudGVyWSgpKSwKZD10aGlzLmdyYXBoLmdldENlbGxBdChhLngtdGhpcy50cmlhbmdsZUxlZnQud2lkdGgvMix0aGlzLmN1cnJlbnRTdGF0ZS5nZXRDZW50ZXJZKCkpLG09dGhpcy5ncmFwaC5nZXRDZWxsQXQodGhpcy5jdXJyZW50U3RhdGUuZ2V0Q2VudGVyWCgpLGEueS10aGlzLnRyaWFuZ2xlVXAuaGVpZ2h0LzIpLGE9dGhpcy5ncmFwaC5nZXRDZWxsQXQodGhpcy5jdXJyZW50U3RhdGUuZ2V0Q2VudGVyWCgpLGEueSthLmhlaWdodCt0aGlzLnRyaWFuZ2xlRG93bi5oZWlnaHQvMik7bnVsbCE9YyYmYz09ZCYmZD09bSYmbT09YSYmKGE9bT1kPWM9bnVsbCk7dmFyIGs9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkodGhpcy5jdXJyZW50U3RhdGUuY2VsbCkscT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGUpe3ZhciBiPXRoaXMuZ3JhcGgubW9kZWwuaXNWZXJ0ZXgoYSkmJnRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGEpO251bGw9PWF8fHRoaXMuZ3JhcGgubW9kZWwuaXNBbmNlc3RvcihhLAp0aGlzLmN1cnJlbnRTdGF0ZS5jZWxsKXx8dGhpcy5ncmFwaC5pc1N3aW1sYW5lKGEpfHwhKG51bGw9PWJ8fG51bGw9PWt8fGIuaGVpZ2h0PDMqay5oZWlnaHQmJmIud2lkdGg8MyprLndpZHRoKT9lLnN0eWxlLnZpc2liaWxpdHk9InZpc2libGUiOmUuc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIn0pO3EoYyx0aGlzLmFycm93UmlnaHQpO3EoZCx0aGlzLmFycm93TGVmdCk7cShtLHRoaXMuYXJyb3dVcCk7cShhLHRoaXMuYXJyb3dEb3duKX1lbHNlIHRoaXMuYXJyb3dMZWZ0LnN0eWxlLnZpc2liaWxpdHk9InZpc2libGUiLHRoaXMuYXJyb3dSaWdodC5zdHlsZS52aXNpYmlsaXR5PSJ2aXNpYmxlIix0aGlzLmFycm93VXAuc3R5bGUudmlzaWJpbGl0eT0idmlzaWJsZSIsdGhpcy5hcnJvd0Rvd24uc3R5bGUudmlzaWJpbGl0eT0idmlzaWJsZSI7dGhpcy5ncmFwaC50b29sdGlwSGFuZGxlci5pc0VuYWJsZWQoKT8odGhpcy5hcnJvd0xlZnQuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJwbHVzVG9vbHRpcCIpKSwKdGhpcy5hcnJvd1JpZ2h0LnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgicGx1c1Rvb2x0aXAiKSksdGhpcy5hcnJvd1VwLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgicGx1c1Rvb2x0aXAiKSksdGhpcy5hcnJvd0Rvd24uc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJwbHVzVG9vbHRpcCIpKSk6KHRoaXMuYXJyb3dMZWZ0LnJlbW92ZUF0dHJpYnV0ZSgidGl0bGUiKSx0aGlzLmFycm93UmlnaHQucmVtb3ZlQXR0cmlidXRlKCJ0aXRsZSIpLHRoaXMuYXJyb3dVcC5yZW1vdmVBdHRyaWJ1dGUoInRpdGxlIiksdGhpcy5hcnJvd0Rvd24ucmVtb3ZlQXR0cmlidXRlKCJ0aXRsZSIpKX1lbHNlIHRoaXMucmVzZXQoKTtudWxsIT10aGlzLmN1cnJlbnRTdGF0ZSYmKHRoaXMuYmJveD10aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpLG51bGwhPXRoaXMuYmJveCYmdGhpcy5iYm94Lmdyb3coMTApKX19OwpIb3Zlckljb25zLnByb3RvdHlwZS5jb21wdXRlQm91bmRpbmdCb3g9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoLm1vZGVsLmlzRWRnZSh0aGlzLmN1cnJlbnRTdGF0ZS5jZWxsKT9udWxsOm14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUodGhpcy5jdXJyZW50U3RhdGUpO3RoaXMudmlzaXROb2RlcyhmdW5jdGlvbihjKXtudWxsIT1jLnBhcmVudE5vZGUmJihjPW5ldyBteFJlY3RhbmdsZShjLm9mZnNldExlZnQsYy5vZmZzZXRUb3AsYy5vZmZzZXRXaWR0aCxjLm9mZnNldEhlaWdodCksbnVsbD09YT9hPWM6YS5hZGQoYykpfSk7cmV0dXJuIGF9OwpIb3Zlckljb25zLnByb3RvdHlwZS5nZXRTdGF0ZT1mdW5jdGlvbihhKXtpZihudWxsIT1hKWlmKGE9YS5jZWxsLHRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5jb250YWlucyhhKSl7aWYodGhpcy5ncmFwaC5nZXRNb2RlbCgpLmlzVmVydGV4KGEpJiYhdGhpcy5ncmFwaC5pc0NlbGxDb25uZWN0YWJsZShhKSl7dmFyIGM9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldFBhcmVudChhKTt0aGlzLmdyYXBoLmdldE1vZGVsKCkuaXNWZXJ0ZXgoYykmJnRoaXMuZ3JhcGguaXNDZWxsQ29ubmVjdGFibGUoYykmJihhPWMpfWlmKHRoaXMuZ3JhcGguaXNDZWxsTG9ja2VkKGEpfHx0aGlzLmdyYXBoLm1vZGVsLmlzRWRnZShhKSlhPW51bGw7YT10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUoYSk7bnVsbCE9YSYmbnVsbD09YS5zdHlsZSYmKGE9bnVsbCl9ZWxzZSBhPW51bGw7cmV0dXJuIGF9OwpIb3Zlckljb25zLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSxjLGYpe2lmKCF0aGlzLmdyYXBoLmNvbm5lY3Rpb25BcnJvd3NFbmFibGVkfHxudWxsIT1hJiYiMCI9PW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSwiYWxsb3dBcnJvd3MiLCIxIikpdGhpcy5yZXNldCgpO2Vsc2V7bnVsbCE9YSYmbnVsbCE9YS5jZWxsLmdlb21ldHJ5JiZhLmNlbGwuZ2VvbWV0cnkucmVsYXRpdmUmJnRoaXMuZ3JhcGgubW9kZWwuaXNFZGdlKGEuY2VsbC5wYXJlbnQpJiYoYT1udWxsKTt2YXIgZD1udWxsO3RoaXMucHJldiE9YXx8dGhpcy5pc0FjdGl2ZSgpPyh0aGlzLnN0YXJ0VGltZT0obmV3IERhdGUpLmdldFRpbWUoKSx0aGlzLnByZXY9YSxkPTAsbnVsbCE9dGhpcy51cGRhdGVUaHJlYWQmJndpbmRvdy5jbGVhclRpbWVvdXQodGhpcy51cGRhdGVUaHJlYWQpLG51bGwhPWEmJih0aGlzLnVwZGF0ZVRocmVhZD13aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuaXNBY3RpdmUoKXx8CnRoaXMuZ3JhcGguaXNNb3VzZURvd258fHRoaXMuZ3JhcGgucGFubmluZ0hhbmRsZXIuaXNBY3RpdmUoKXx8KHRoaXMucHJldj1hLHRoaXMudXBkYXRlKGEsYyxmKSl9KSx0aGlzLnVwZGF0ZURlbGF5KzEwKSkpOm51bGwhPXRoaXMuc3RhcnRUaW1lJiYoZD0obmV3IERhdGUpLmdldFRpbWUoKS10aGlzLnN0YXJ0VGltZSk7dGhpcy5zZXREaXNwbGF5KCIiKTtudWxsIT10aGlzLmN1cnJlbnRTdGF0ZSYmdGhpcy5jdXJyZW50U3RhdGUhPWEmJmQ8dGhpcy5hY3RpdmF0aW9uRGVsYXkmJm51bGwhPXRoaXMuYmJveCYmIW14VXRpbHMuY29udGFpbnModGhpcy5iYm94LGMsZik/dGhpcy5yZXNldCghMSk6KG51bGwhPXRoaXMuY3VycmVudFN0YXRlfHxkPnRoaXMuYWN0aXZhdGlvbkRlbGF5KSYmdGhpcy5jdXJyZW50U3RhdGUhPWEmJihkPnRoaXMudXBkYXRlRGVsYXkmJm51bGwhPWF8fG51bGw9PXRoaXMuYmJveHx8bnVsbD09Y3x8bnVsbD09Znx8IW14VXRpbHMuY29udGFpbnModGhpcy5iYm94LApjLGYpKSYmKG51bGwhPWEmJnRoaXMuZ3JhcGguaXNFbmFibGVkKCk/KHRoaXMucmVtb3ZlTm9kZXMoKSx0aGlzLnNldEN1cnJlbnRTdGF0ZShhKSx0aGlzLnJlcGFpbnQoKSx0aGlzLmdyYXBoLmNvbm5lY3Rpb25IYW5kbGVyLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRGb2N1cyE9YSYmdGhpcy5ncmFwaC5jb25uZWN0aW9uSGFuZGxlci5jb25zdHJhaW50SGFuZGxlci5yZXNldCgpKTp0aGlzLnJlc2V0KCkpfX07CkhvdmVySWNvbnMucHJvdG90eXBlLnNldEN1cnJlbnRTdGF0ZT1mdW5jdGlvbihhKXsiZWFzdHdlc3QiIT1hLnN0eWxlLnBvcnRDb25zdHJhaW50JiYodGhpcy5ncmFwaC5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5hcnJvd1VwKSx0aGlzLmdyYXBoLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmFycm93RG93bikpO3RoaXMuZ3JhcGguY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuYXJyb3dSaWdodCk7dGhpcy5ncmFwaC5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5hcnJvd0xlZnQpO3RoaXMuY3VycmVudFN0YXRlPWF9O0dyYXBoLnByb3RvdHlwZS5jcmVhdGVQYXJlbnQ9ZnVuY3Rpb24oYSxjLGYsZCxtKXthPXRoaXMuY2xvbmVDZWxsKGEpO2Zvcih2YXIgaz0wO2s8ZjtrKyspe3ZhciBxPXRoaXMuY2xvbmVDZWxsKGMpLGI9dGhpcy5nZXRDZWxsR2VvbWV0cnkocSk7bnVsbCE9YiYmKGIueCs9aypkLGIueSs9ayptKTthLmluc2VydChxKX1yZXR1cm4gYX07CkdyYXBoLnByb3RvdHlwZS5jcmVhdGVUYWJsZT1mdW5jdGlvbihhLGMsZixkLG0sayxxLGIsZSl7Zj1udWxsIT1mP2Y6NjA7ZD1udWxsIT1kP2Q6NDA7az1udWxsIT1rP2s6MzA7Yj1udWxsIT1iP2I6InNoYXBlPXBhcnRpYWxSZWN0YW5nbGU7aHRtbD0xO3doaXRlU3BhY2U9d3JhcDtjb2xsYXBzaWJsZT0wO2Ryb3BUYXJnZXQ9MDtwb2ludGVyRXZlbnRzPTA7ZmlsbENvbG9yPW5vbmU7dG9wPTA7bGVmdD0wO2JvdHRvbT0wO3JpZ2h0PTA7cG9pbnRzPVtbMCwwLjVdLFsxLDAuNV1dO3BvcnRDb25zdHJhaW50PWVhc3R3ZXN0OyI7ZT1udWxsIT1lP2U6InNoYXBlPXBhcnRpYWxSZWN0YW5nbGU7aHRtbD0xO3doaXRlU3BhY2U9d3JhcDtjb25uZWN0YWJsZT0wO292ZXJmbG93PWhpZGRlbjtmaWxsQ29sb3I9bm9uZTt0b3A9MDtsZWZ0PTA7Ym90dG9tPTA7cmlnaHQ9MDsiO3JldHVybiB0aGlzLmNyZWF0ZVBhcmVudCh0aGlzLmNyZWF0ZVZlcnRleChudWxsLG51bGwsbnVsbCE9bT9tOiIiLAowLDAsYypmLGEqZCsobnVsbCE9bT9rOjApLG51bGwhPXE/cToic2hhcGU9dGFibGU7aHRtbD0xO3doaXRlU3BhY2U9d3JhcDtzdGFydFNpemU9IisobnVsbCE9bT9rOiIwIikrIjtjb250YWluZXI9MTtjb2xsYXBzaWJsZT0wO2NoaWxkTGF5b3V0PXRhYmxlTGF5b3V0OyIpLHRoaXMuY3JlYXRlUGFyZW50KHRoaXMuY3JlYXRlVmVydGV4KG51bGwsbnVsbCwiIiwwLDAsYypmLGQsYiksdGhpcy5jcmVhdGVWZXJ0ZXgobnVsbCxudWxsLCIiLDAsMCxmLGQsZSksYyxmLDApLGEsMCxkKX07CkdyYXBoLnByb3RvdHlwZS5zZXRUYWJsZVZhbHVlcz1mdW5jdGlvbihhLGMsZil7Zm9yKHZhciBkPXRoaXMubW9kZWwuZ2V0Q2hpbGRDZWxscyhhLCEwKSxtPTA7bTxkLmxlbmd0aDttKyspaWYobnVsbCE9ZiYmKGRbbV0udmFsdWU9ZlttXSksbnVsbCE9Yylmb3IodmFyIGs9dGhpcy5tb2RlbC5nZXRDaGlsZENlbGxzKGRbbV0sITApLHE9MDtxPGsubGVuZ3RoO3ErKyludWxsIT1jW21dW3FdJiYoa1txXS52YWx1ZT1jW21dW3FdKTtyZXR1cm4gYX07CkdyYXBoLnByb3RvdHlwZS5jcmVhdGVDcm9zc0Z1bmN0aW9uYWxTd2ltbGFuZT1mdW5jdGlvbihhLGMsZixkLG0sayxxLGIsZSl7Zj1udWxsIT1mP2Y6MTIwO2Q9bnVsbCE9ZD9kOjEyMDttPW51bGwhPW0/bTo0MDtxPW51bGwhPXE/cToic3dpbWxhbmU7aG9yaXpvbnRhbD0wO3BvaW50cz1bWzAsMC41XSxbMSwwLjVdXTtwb3J0Q29uc3RyYWludD1lYXN0d2VzdDtzdGFydFNpemU9IittKyI7aHRtbD0xO3doaXRlU3BhY2U9d3JhcDtjb2xsYXBzaWJsZT0wO3JlY3Vyc2l2ZVJlc2l6ZT0wO2V4cGFuZD0wO3BvaW50ZXJFdmVudHM9MDsiO2I9bnVsbCE9Yj9iOiJzd2ltbGFuZTtjb25uZWN0YWJsZT0wO3N0YXJ0U2l6ZT00MDtodG1sPTE7d2hpdGVTcGFjZT13cmFwO2NvbGxhcHNpYmxlPTA7cmVjdXJzaXZlUmVzaXplPTA7ZXhwYW5kPTA7cG9pbnRlckV2ZW50cz0wOyI7ZT1udWxsIT1lP2U6InN3aW1sYW5lO2Nvbm5lY3RhYmxlPTA7c3RhcnRTaXplPTA7aHRtbD0xO3doaXRlU3BhY2U9d3JhcDtjb2xsYXBzaWJsZT0wO3JlY3Vyc2l2ZVJlc2l6ZT0wO2V4cGFuZD0wO3BvaW50ZXJFdmVudHM9MDsiOwptPXRoaXMuY3JlYXRlVmVydGV4KG51bGwsbnVsbCwiIiwwLDAsYypmLGEqZCxudWxsIT1rP2s6InNoYXBlPXRhYmxlO2NoaWxkTGF5b3V0PXRhYmxlTGF5b3V0O3Jvd0xpbmVzPTA7Y29sdW1uTGluZXM9MDtzdGFydFNpemU9IittKyI7aHRtbD0xO3doaXRlU3BhY2U9d3JhcDtjb2xsYXBzaWJsZT0wO3JlY3Vyc2l2ZVJlc2l6ZT0wO2V4cGFuZD0wO3BvaW50ZXJFdmVudHM9MDsiKTtrPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5nZXRDZWxsU3R5bGUobSksbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFLG14Q29uc3RhbnRzLkRFRkFVTFRfU1RBUlRTSVpFKTttLmdlb21ldHJ5LndpZHRoKz1rO20uZ2VvbWV0cnkuaGVpZ2h0Kz1rO3E9dGhpcy5jcmVhdGVWZXJ0ZXgobnVsbCxudWxsLCIiLDAsayxjKmYrayxkLHEpO20uaW5zZXJ0KHRoaXMuY3JlYXRlUGFyZW50KHEsdGhpcy5jcmVhdGVWZXJ0ZXgobnVsbCxudWxsLCIiLGssMCxmLGQsYiksYyxmLDApKTtyZXR1cm4gMTxhPyhxLmdlb21ldHJ5Lnk9CmQrayx0aGlzLmNyZWF0ZVBhcmVudChtLHRoaXMuY3JlYXRlUGFyZW50KHEsdGhpcy5jcmVhdGVWZXJ0ZXgobnVsbCxudWxsLCIiLGssMCxmLGQsZSksYyxmLDApLGEtMSwwLGQpKTptfTtHcmFwaC5wcm90b3R5cGUuaXNUYWJsZUNlbGw9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubW9kZWwuaXNWZXJ0ZXgoYSkmJnRoaXMuaXNUYWJsZVJvdyh0aGlzLm1vZGVsLmdldFBhcmVudChhKSl9O0dyYXBoLnByb3RvdHlwZS5pc1RhYmxlUm93PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLm1vZGVsLmlzVmVydGV4KGEpJiZ0aGlzLmlzVGFibGUodGhpcy5tb2RlbC5nZXRQYXJlbnQoYSkpfTtHcmFwaC5wcm90b3R5cGUuaXNUYWJsZT1mdW5jdGlvbihhKXthPXRoaXMuZ2V0Q2VsbFN0eWxlKGEpO3JldHVybiBudWxsIT1hJiYidGFibGVMYXlvdXQiPT1hLmNoaWxkTGF5b3V0fTsKR3JhcGgucHJvdG90eXBlLnNldFRhYmxlUm93SGVpZ2h0PWZ1bmN0aW9uKGEsYyxmKXtmPW51bGwhPWY/ZjohMDt2YXIgZD10aGlzLmdldE1vZGVsKCk7ZC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgbT10aGlzLmdldENlbGxHZW9tZXRyeShhKTtpZihudWxsIT1tKXttPW0uY2xvbmUoKTttLmhlaWdodCs9YztkLnNldEdlb21ldHJ5KGEsbSk7dmFyIGs9ZC5nZXRQYXJlbnQoYSkscT1kLmdldENoaWxkQ2VsbHMoaywhMCk7aWYoIWYpe3ZhciBiPW14VXRpbHMuaW5kZXhPZihxLGEpO2lmKGI8cS5sZW5ndGgtMSl7dmFyIGU9cVtiKzFdLGc9dGhpcy5nZXRDZWxsR2VvbWV0cnkoZSk7bnVsbCE9ZyYmKGc9Zy5jbG9uZSgpLGcueSs9YyxnLmhlaWdodC09YyxkLnNldEdlb21ldHJ5KGUsZykpfX12YXIgcD10aGlzLmdldENlbGxHZW9tZXRyeShrKTtudWxsIT1wJiYoZnx8KGY9YT09cVtxLmxlbmd0aC0xXSksZiYmKHA9cC5jbG9uZSgpLHAuaGVpZ2h0Kz1jLGQuc2V0R2VvbWV0cnkoayxwKSkpOwpudWxsIT10aGlzLmxheW91dE1hbmFnZXImJnRoaXMubGF5b3V0TWFuYWdlci5leGVjdXRlTGF5b3V0KGssITApfX1maW5hbGx5e2QuZW5kVXBkYXRlKCl9fTsKR3JhcGgucHJvdG90eXBlLnNldFRhYmxlQ29sdW1uV2lkdGg9ZnVuY3Rpb24oYSxjLGYpe2Y9bnVsbCE9Zj9mOiExO3ZhciBkPXRoaXMuZ2V0TW9kZWwoKSxtPWQuZ2V0UGFyZW50KGEpLGs9ZC5nZXRQYXJlbnQobSkscT1kLmdldENoaWxkQ2VsbHMobSwhMCk7YT1teFV0aWxzLmluZGV4T2YocSxhKTt2YXIgYj1hPT1xLmxlbmd0aC0xO2QuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBlPWQuZ2V0Q2hpbGRDZWxscyhrLCEwKSxnPTA7ZzxlLmxlbmd0aDtnKyspe3ZhciBtPWVbZ10scT1kLmdldENoaWxkQ2VsbHMobSwhMCkscD1xW2FdLGw9dGhpcy5nZXRDZWxsR2VvbWV0cnkocCk7bnVsbCE9bCYmKGw9bC5jbG9uZSgpLGwud2lkdGgrPWMsZC5zZXRHZW9tZXRyeShwLGwpKTthPHEubGVuZ3RoLTEmJihwPXFbYSsxXSxsPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KHApLG51bGwhPWwmJihsPWwuY2xvbmUoKSxsLngrPWMsZnx8KGwud2lkdGgtPWMpLGQuc2V0R2VvbWV0cnkocCxsKSkpfWlmKGJ8fApmKXt2YXIgbj10aGlzLmdldENlbGxHZW9tZXRyeShrKTtudWxsIT1uJiYobj1uLmNsb25lKCksbi53aWR0aCs9YyxkLnNldEdlb21ldHJ5KGssbikpfW51bGwhPXRoaXMubGF5b3V0TWFuYWdlciYmdGhpcy5sYXlvdXRNYW5hZ2VyLmV4ZWN1dGVMYXlvdXQoaywhMCl9ZmluYWxseXtkLmVuZFVwZGF0ZSgpfX07ZnVuY3Rpb24gVGFibGVMYXlvdXQoYSl7bXhHcmFwaExheW91dC5jYWxsKHRoaXMsYSl9VGFibGVMYXlvdXQucHJvdG90eXBlPW5ldyBteFN0YWNrTGF5b3V0O1RhYmxlTGF5b3V0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1UYWJsZUxheW91dDtUYWJsZUxheW91dC5wcm90b3R5cGUuaXNIb3Jpem9udGFsPWZ1bmN0aW9uKCl7cmV0dXJuITF9OwpUYWJsZUxheW91dC5wcm90b3R5cGUuZ2V0U2l6ZT1mdW5jdGlvbihhLGMpe2Zvcih2YXIgZj0wLGQ9MDtkPGEubGVuZ3RoO2QrKylpZighdGhpcy5pc1ZlcnRleElnbm9yZWQoYVtkXSkpe3ZhciBtPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGFbZF0pO251bGwhPW0mJihmKz1jP20ud2lkdGg6bS5oZWlnaHQpfXJldHVybiBmfTtUYWJsZUxheW91dC5wcm90b3R5cGUuZ2V0Um93TGF5b3V0PWZ1bmN0aW9uKGEsYyl7Zm9yKHZhciBmPXRoaXMuZ3JhcGgubW9kZWwuZ2V0Q2hpbGRDZWxscyhhLCEwKSxkPXRoaXMuZ3JhcGguZ2V0QWN0dWFsU3RhcnRTaXplKGEsITApLG09dGhpcy5nZXRTaXplKGYsITApLGs9Yy1kLngtZC53aWR0aCxxPVtdLGQ9ZC54LGI9MDtiPGYubGVuZ3RoO2IrKyl7dmFyIGU9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoZltiXSk7bnVsbCE9ZSYmKGQrPWUud2lkdGgqay9tLHEucHVzaChNYXRoLnJvdW5kKGQpKSl9cmV0dXJuIHF9OwpUYWJsZUxheW91dC5wcm90b3R5cGUubGF5b3V0Um93PWZ1bmN0aW9uKGEsYyxmLGQpe3ZhciBtPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxrPW0uZ2V0Q2hpbGRDZWxscyhhLCEwKTthPXRoaXMuZ3JhcGguZ2V0QWN0dWFsU3RhcnRTaXplKGEsITApO3ZhciBxPWEueCxiPTA7bnVsbCE9YyYmKGM9Yy5zbGljZSgpLGMuc3BsaWNlKDAsMCxhLngpKTtmb3IodmFyIGU9MDtlPGsubGVuZ3RoO2UrKyl7dmFyIGc9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoa1tlXSk7bnVsbCE9ZyYmKGc9Zy5jbG9uZSgpLGcueT1hLnksZy5oZWlnaHQ9Zi1hLnktYS5oZWlnaHQsbnVsbCE9Yz8oZy54PWNbZV0sZy53aWR0aD1jW2UrMV0tZy54LGU9PWsubGVuZ3RoLTEmJmU8Yy5sZW5ndGgtMiYmKGcud2lkdGg9ZC1nLngtYS54LWEud2lkdGgpKTooZy54PXEscSs9Zy53aWR0aCxlPT1rLmxlbmd0aC0xP2cud2lkdGg9ZC1hLngtYS53aWR0aC1iOmIrPWcud2lkdGgpLG0uc2V0R2VvbWV0cnkoa1tlXSxnKSl9cmV0dXJuIGJ9OwpUYWJsZUxheW91dC5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihhKXtpZihudWxsIT1hKXt2YXIgYz10aGlzLmdyYXBoLmdldEFjdHVhbFN0YXJ0U2l6ZShhLCEwKSxmPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGEpLGQ9dGhpcy5ncmFwaC5nZXRDZWxsU3R5bGUoYSksbT0iMSI9PW14VXRpbHMuZ2V0VmFsdWUoZCwicmVzaXplTGFzdFJvdyIsIjAiKSxrPSIxIj09bXhVdGlscy5nZXRWYWx1ZShkLCJyZXNpemVMYXN0IiwiMCIpLGQ9IjEiPT1teFV0aWxzLmdldFZhbHVlKGQsImZpeGVkUm93cyIsIjAiKSxxPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxiPTA7cS5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgZT1mLmhlaWdodC1jLnktYy5oZWlnaHQsZz1mLndpZHRoLWMueC1jLndpZHRoLHA9cS5nZXRDaGlsZENlbGxzKGEsITApLGw9dGhpcy5nZXRTaXplKHAsITEpO2lmKDA8ZSYmMDxnJiYwPHAubGVuZ3RoJiYwPGwpe2lmKG0pe3ZhciBuPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KHBbcC5sZW5ndGgtCjFdKTtudWxsIT1uJiYobj1uLmNsb25lKCksbi5oZWlnaHQ9ZS1sK24uaGVpZ2h0LHEuc2V0R2VvbWV0cnkocFtwLmxlbmd0aC0xXSxuKSl9Zm9yKHZhciB2PWs/bnVsbDp0aGlzLmdldFJvd0xheW91dChwWzBdLGcpLHQ9Yy55LHk9MDt5PHAubGVuZ3RoO3krKyluPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KHBbeV0pLG51bGwhPW4mJihuPW4uY2xvbmUoKSxuLng9Yy54LG4ud2lkdGg9ZyxuLnk9TWF0aC5yb3VuZCh0KSx0PW18fGQ/dCtuLmhlaWdodDp0K24uaGVpZ2h0L2wqZSxuLmhlaWdodD1NYXRoLnJvdW5kKHQpLW4ueSxxLnNldEdlb21ldHJ5KHBbeV0sbikpLGI9TWF0aC5tYXgoYix0aGlzLmxheW91dFJvdyhwW3ldLHYsbi5oZWlnaHQsZykpO2QmJmU8bCYmKGY9Zi5jbG9uZSgpLGYuaGVpZ2h0PXQrYy5oZWlnaHQscS5zZXRHZW9tZXRyeShhLGYpKTtrJiZnPGIrR3JhcGgubWluVGFibGVDb2x1bW5XaWR0aCYmKGY9Zi5jbG9uZSgpLGYud2lkdGg9YitjLndpZHRoK2MueCsKR3JhcGgubWluVGFibGVDb2x1bW5XaWR0aCxxLnNldEdlb21ldHJ5KGEsZikpfX1maW5hbGx5e3EuZW5kVXBkYXRlKCl9fX07CihmdW5jdGlvbigpe3ZhciBhPW14R3JhcGhWaWV3LnByb3RvdHlwZS5yZXNldFZhbGlkYXRpb25TdGF0ZTtteEdyYXBoVmlldy5wcm90b3R5cGUucmVzZXRWYWxpZGF0aW9uU3RhdGU9ZnVuY3Rpb24oKXthLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLnZhbGlkRWRnZXM9W119O3ZhciBjPW14R3JhcGhWaWV3LnByb3RvdHlwZS52YWxpZGF0ZUNlbGxTdGF0ZTtteEdyYXBoVmlldy5wcm90b3R5cGUudmFsaWRhdGVDZWxsU3RhdGU9ZnVuY3Rpb24oYSxiKXtiPW51bGwhPWI/YjohMDt2YXIgZT10aGlzLmdldFN0YXRlKGEpO251bGwhPWUmJmImJnRoaXMuZ3JhcGgubW9kZWwuaXNFZGdlKGUuY2VsbCkmJm51bGwhPWUuc3R5bGUmJjEhPWUuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfQ1VSVkVEXSYmIWUuaW52YWxpZCYmdGhpcy51cGRhdGVMaW5lSnVtcHMoZSkmJnRoaXMuZ3JhcGguY2VsbFJlbmRlcmVyLnJlZHJhdyhlLCExLHRoaXMuaXNSZW5kZXJpbmcoKSk7ZT1jLmFwcGx5KHRoaXMsCmFyZ3VtZW50cyk7bnVsbCE9ZSYmYiYmdGhpcy5ncmFwaC5tb2RlbC5pc0VkZ2UoZS5jZWxsKSYmbnVsbCE9ZS5zdHlsZSYmMSE9ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9DVVJWRURdJiZ0aGlzLnZhbGlkRWRnZXMucHVzaChlKTtyZXR1cm4gZX07dmFyIGY9bXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmlzU2hhcGVJbnZhbGlkO214Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5pc1NoYXBlSW52YWxpZD1mdW5jdGlvbihhLGIpe3JldHVybiBmLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8bnVsbCE9YS5yb3V0ZWRQb2ludHMmJm51bGwhPWIucm91dGVkUG9pbnRzJiYhbXhVdGlscy5lcXVhbFBvaW50cyhiLnJvdXRlZFBvaW50cyxhLnJvdXRlZFBvaW50cyl9O3ZhciBkPW14R3JhcGhWaWV3LnByb3RvdHlwZS51cGRhdGVDZWxsU3RhdGU7bXhHcmFwaFZpZXcucHJvdG90eXBlLnVwZGF0ZUNlbGxTdGF0ZT1mdW5jdGlvbihhKXtkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLmdyYXBoLm1vZGVsLmlzRWRnZShhLmNlbGwpJiYKMSE9YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9DVVJWRURdJiZ0aGlzLnVwZGF0ZUxpbmVKdW1wcyhhKX07bXhHcmFwaFZpZXcucHJvdG90eXBlLnVwZGF0ZUxpbmVKdW1wcz1mdW5jdGlvbihhKXt2YXIgYj1hLmFic29sdXRlUG9pbnRzO2lmKEdyYXBoLmxpbmVKdW1wc0VuYWJsZWQpe3ZhciBlPW51bGwhPWEucm91dGVkUG9pbnRzLGM9bnVsbDtpZihudWxsIT1iJiZudWxsIT10aGlzLnZhbGlkRWRnZXMmJiJub25lIiE9PW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSwianVtcFN0eWxlIiwibm9uZSIpKXtmb3IodmFyIGQ9ZnVuY3Rpb24oYixlLGQpe3ZhciBmPW5ldyBteFBvaW50KGUsZCk7Zi50eXBlPWI7Yy5wdXNoKGYpO2Y9bnVsbCE9YS5yb3V0ZWRQb2ludHM/YS5yb3V0ZWRQb2ludHNbYy5sZW5ndGgtMV06bnVsbDtyZXR1cm4gbnVsbD09Znx8Zi50eXBlIT1ifHxmLnghPWV8fGYueSE9ZH0sZj0uNSp0aGlzLnNjYWxlLGU9ITEsYz1bXSx0PTA7dDxiLmxlbmd0aC0xO3QrKyl7Zm9yKHZhciB5PQpiW3QrMV0saz1iW3RdLG09W10scT1iW3QrMl07dDxiLmxlbmd0aC0yJiZteFV0aWxzLnB0U2VnRGlzdFNxKGsueCxrLnkscS54LHEueSx5LngseS55KTwxKnRoaXMuc2NhbGUqdGhpcy5zY2FsZTspeT1xLHQrKyxxPWJbdCsyXTtmb3IodmFyIGU9ZCgwLGsueCxrLnkpfHxlLEM9MDtDPHRoaXMudmFsaWRFZGdlcy5sZW5ndGg7QysrKXt2YXIgej10aGlzLnZhbGlkRWRnZXNbQ10sRD16LmFic29sdXRlUG9pbnRzO2lmKG51bGwhPUQmJm14VXRpbHMuaW50ZXJzZWN0cyhhLHopJiYiMSIhPXouc3R5bGUubm9KdW1wKWZvcih6PTA7ejxELmxlbmd0aC0xO3orKyl7Zm9yKHZhciBHPURbeisxXSxGPURbel0scT1EW3orMl07ejxELmxlbmd0aC0yJiZteFV0aWxzLnB0U2VnRGlzdFNxKEYueCxGLnkscS54LHEueSxHLngsRy55KTwxKnRoaXMuc2NhbGUqdGhpcy5zY2FsZTspRz1xLHorKyxxPURbeisyXTtxPW14VXRpbHMuaW50ZXJzZWN0aW9uKGsueCxrLnkseS54LHkueSxGLngsRi55LEcueCwKRy55KTtpZihudWxsIT1xJiYoTWF0aC5hYnMocS54LWsueCk+Znx8TWF0aC5hYnMocS55LWsueSk+ZikmJihNYXRoLmFicyhxLngteS54KT5mfHxNYXRoLmFicyhxLnkteS55KT5mKSYmKE1hdGguYWJzKHEueC1GLngpPmZ8fE1hdGguYWJzKHEueS1GLnkpPmYpJiYoTWF0aC5hYnMocS54LUcueCk+Znx8TWF0aC5hYnMocS55LUcueSk+Zikpe0c9cS54LWsueDtGPXEueS1rLnk7cT17ZGlzdFNxOkcqRytGKkYseDpxLngseTpxLnl9O2ZvcihHPTA7RzxtLmxlbmd0aDtHKyspaWYobVtHXS5kaXN0U3E+cS5kaXN0U3Epe20uc3BsaWNlKEcsMCxxKTtxPW51bGw7YnJlYWt9bnVsbD09cXx8MCE9bS5sZW5ndGgmJm1bbS5sZW5ndGgtMV0ueD09PXEueCYmbVttLmxlbmd0aC0xXS55PT09cS55fHxtLnB1c2gocSl9fX1mb3Ioej0wO3o8bS5sZW5ndGg7eisrKWU9ZCgxLG1bel0ueCxtW3pdLnkpfHxlfXE9YltiLmxlbmd0aC0xXTtlPWQoMCxxLngscS55KXx8ZX1hLnJvdXRlZFBvaW50cz1jO3JldHVybiBlfXJldHVybiExfTsKdmFyIG09bXhDb25uZWN0b3IucHJvdG90eXBlLnBhaW50TGluZTtteENvbm5lY3Rvci5wcm90b3R5cGUucGFpbnRMaW5lPWZ1bmN0aW9uKGEsYixjKXt0aGlzLnJvdXRlZFBvaW50cz1udWxsIT10aGlzLnN0YXRlP3RoaXMuc3RhdGUucm91dGVkUG9pbnRzOm51bGw7aWYodGhpcy5vdXRsaW5lfHxudWxsPT10aGlzLnN0YXRlfHxudWxsPT10aGlzLnN0eWxlfHxudWxsPT10aGlzLnN0YXRlLnJvdXRlZFBvaW50c3x8MD09dGhpcy5zdGF0ZS5yb3V0ZWRQb2ludHMubGVuZ3RoKW0uYXBwbHkodGhpcyxhcmd1bWVudHMpO2Vsc2V7dmFyIGU9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkUsbXhDb25zdGFudHMuTElORV9BUkNTSVpFKS8yLGQ9KHBhcnNlSW50KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwianVtcFNpemUiLEdyYXBoLmRlZmF1bHRKdW1wU2l6ZSkpLTIpLzIrdGhpcy5zdHJva2V3aWR0aCxmPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwKImp1bXBTdHlsZSIsIm5vbmUiKSxnPSEwLHA9bnVsbCxrPW51bGwscT1bXSxBPW51bGw7YS5iZWdpbigpO2Zvcih2YXIgQz0wO0M8dGhpcy5zdGF0ZS5yb3V0ZWRQb2ludHMubGVuZ3RoO0MrKyl7dmFyIHo9dGhpcy5zdGF0ZS5yb3V0ZWRQb2ludHNbQ10sRD1uZXcgbXhQb2ludCh6LngvdGhpcy5zY2FsZSx6LnkvdGhpcy5zY2FsZSk7MD09Qz9EPWJbMF06Qz09dGhpcy5zdGF0ZS5yb3V0ZWRQb2ludHMubGVuZ3RoLTEmJihEPWJbYi5sZW5ndGgtMV0pO3ZhciBHPSExO2lmKG51bGwhPXAmJjE9PXoudHlwZSl7dmFyIEY9dGhpcy5zdGF0ZS5yb3V0ZWRQb2ludHNbQysxXSx6PUYueC90aGlzLnNjYWxlLUQueCxGPUYueS90aGlzLnNjYWxlLUQueSx6PXoqeitGKkY7bnVsbD09QSYmKEE9bmV3IG14UG9pbnQoRC54LXAueCxELnktcC55KSxrPU1hdGguc3FydChBLngqQS54K0EueSpBLnkpLDA8az8oQS54PUEueCpkL2ssQS55PUEueSpkL2spOkE9bnVsbCk7ej5kKmQmJjA8ayYmKHo9cC54LQpELngsRj1wLnktRC55LHo9eip6K0YqRix6PmQqZCYmKEc9bmV3IG14UG9pbnQoRC54LUEueCxELnktQS55KSx6PW5ldyBteFBvaW50KEQueCtBLngsRC55K0EueSkscS5wdXNoKEcpLHRoaXMuYWRkUG9pbnRzKGEscSxjLGUsITEsbnVsbCxnKSxxPTA+TWF0aC5yb3VuZChBLngpfHwwPT1NYXRoLnJvdW5kKEEueCkmJjA+PU1hdGgucm91bmQoQS55KT8xOi0xLGc9ITEsInNoYXJwIj09Zj8oYS5saW5lVG8oRy54LUEueSpxLEcueStBLngqcSksYS5saW5lVG8oei54LUEueSpxLHoueStBLngqcSksYS5saW5lVG8oei54LHoueSkpOiJhcmMiPT1mPyhxKj0xLjMsYS5jdXJ2ZVRvKEcueC1BLnkqcSxHLnkrQS54KnEsei54LUEueSpxLHoueStBLngqcSx6Lngsei55KSk6KGEubW92ZVRvKHoueCx6LnkpLGc9ITApLHE9W3pdLEc9ITApKX1lbHNlIEE9bnVsbDtHfHwocS5wdXNoKEQpLHA9RCl9dGhpcy5hZGRQb2ludHMoYSxxLGMsZSwhMSxudWxsLGcpO2Euc3Ryb2tlKCl9fTt2YXIgaz1teEdyYXBoVmlldy5wcm90b3R5cGUudXBkYXRlRmxvYXRpbmdUZXJtaW5hbFBvaW50OwpteEdyYXBoVmlldy5wcm90b3R5cGUudXBkYXRlRmxvYXRpbmdUZXJtaW5hbFBvaW50PWZ1bmN0aW9uKGEsYixjLGQpe2lmKG51bGw9PWJ8fG51bGw9PWF8fCIxIiE9Yi5zdHlsZS5zbmFwVG9Qb2ludCYmIjEiIT1hLnN0eWxlLnNuYXBUb1BvaW50KWsuYXBwbHkodGhpcyxhcmd1bWVudHMpO2Vsc2V7Yj10aGlzLmdldFRlcm1pbmFsUG9ydChhLGIsZCk7dmFyIGU9dGhpcy5nZXROZXh0UG9pbnQoYSxjLGQpLGY9dGhpcy5ncmFwaC5pc09ydGhvZ29uYWwoYSksZz1teFV0aWxzLnRvUmFkaWFucyhOdW1iZXIoYi5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTl18fCIwIikpLGw9bmV3IG14UG9pbnQoYi5nZXRDZW50ZXJYKCksYi5nZXRDZW50ZXJZKCkpO2lmKDAhPWcpdmFyIHA9TWF0aC5jb3MoLWcpLG09TWF0aC5zaW4oLWcpLGU9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQoZSxwLG0sbCk7cD1wYXJzZUZsb2F0KGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfUEVSSU1FVEVSX1NQQUNJTkddfHwKMCk7cCs9cGFyc2VGbG9hdChhLnN0eWxlW2Q/bXhDb25zdGFudHMuU1RZTEVfU09VUkNFX1BFUklNRVRFUl9TUEFDSU5HOm14Q29uc3RhbnRzLlNUWUxFX1RBUkdFVF9QRVJJTUVURVJfU1BBQ0lOR118fDApO2U9dGhpcy5nZXRQZXJpbWV0ZXJQb2ludChiLGUsMD09ZyYmZixwKTswIT1nJiYocD1NYXRoLmNvcyhnKSxtPU1hdGguc2luKGcpLGU9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQoZSxwLG0sbCkpO2Euc2V0QWJzb2x1dGVUZXJtaW5hbFBvaW50KHRoaXMuc25hcFRvQW5jaG9yUG9pbnQoYSxiLGMsZCxlKSxkKX19O214R3JhcGhWaWV3LnByb3RvdHlwZS5zbmFwVG9BbmNob3JQb2ludD1mdW5jdGlvbihhLGIsYyxkLGYpe2lmKG51bGwhPWImJm51bGwhPWEpe2E9dGhpcy5ncmFwaC5nZXRBbGxDb25uZWN0aW9uQ29uc3RyYWludHMoYik7ZD1jPW51bGw7aWYobnVsbCE9YSlmb3IodmFyIGU9MDtlPGEubGVuZ3RoO2UrKyl7dmFyIGc9dGhpcy5ncmFwaC5nZXRDb25uZWN0aW9uUG9pbnQoYiwKYVtlXSk7aWYobnVsbCE9Zyl7dmFyIGw9KGcueC1mLngpKihnLngtZi54KSsoZy55LWYueSkqKGcueS1mLnkpO2lmKG51bGw9PWR8fGw8ZCljPWcsZD1sfX1udWxsIT1jJiYoZj1jKX1yZXR1cm4gZn07dmFyIHE9bXhTdGVuY2lsLnByb3RvdHlwZS5ldmFsdWF0ZVRleHRBdHRyaWJ1dGU7bXhTdGVuY2lsLnByb3RvdHlwZS5ldmFsdWF0ZVRleHRBdHRyaWJ1dGU9ZnVuY3Rpb24oYSxiLGMpe3ZhciBlPXEuYXBwbHkodGhpcyxhcmd1bWVudHMpOyIxIj09YS5nZXRBdHRyaWJ1dGUoInBsYWNlaG9sZGVycyIpJiZudWxsIT1jLnN0YXRlJiYoZT1jLnN0YXRlLnZpZXcuZ3JhcGgucmVwbGFjZVBsYWNlaG9sZGVycyhjLnN0YXRlLmNlbGwsZSkpO3JldHVybiBlfTt2YXIgYj1teENlbGxSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlU2hhcGU7bXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVNoYXBlPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEuc3R5bGUmJiJ1bmRlZmluZWQiIT09dHlwZW9mIHBha28pe3ZhciBlPQpteFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU0hBUEUsbnVsbCk7aWYobnVsbCE9ZSYmInN0cmluZyI9PT10eXBlb2YgZSYmInN0ZW5jaWwoIj09ZS5zdWJzdHJpbmcoMCw4KSl0cnl7dmFyIGM9ZS5zdWJzdHJpbmcoOCxlLmxlbmd0aC0xKSxkPW14VXRpbHMucGFyc2VYbWwoR3JhcGguZGVjb21wcmVzcyhjKSk7cmV0dXJuIG5ldyBteFNoYXBlKG5ldyBteFN0ZW5jaWwoZC5kb2N1bWVudEVsZW1lbnQpKX1jYXRjaChuKXtudWxsIT13aW5kb3cuY29uc29sZSYmY29uc29sZS5sb2coIkVycm9yIGluIHNoYXBlOiAiK24pfX1yZXR1cm4gYi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fSkoKTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXM9e307bXhTdGVuY2lsUmVnaXN0cnkuZHluYW1pY0xvYWRpbmc9ITA7bXhTdGVuY2lsUmVnaXN0cnkuYWxsb3dFdmFsPSEwO214U3RlbmNpbFJlZ2lzdHJ5LnBhY2thZ2VzPVtdOwpteFN0ZW5jaWxSZWdpc3RyeS5nZXRTdGVuY2lsPWZ1bmN0aW9uKGEpe3ZhciBjPW14U3RlbmNpbFJlZ2lzdHJ5LnN0ZW5jaWxzW2FdO2lmKG51bGw9PWMmJm51bGw9PW14Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXNbYV0mJm14U3RlbmNpbFJlZ2lzdHJ5LmR5bmFtaWNMb2FkaW5nKXt2YXIgZj1teFN0ZW5jaWxSZWdpc3RyeS5nZXRCYXNlbmFtZUZvclN0ZW5jaWwoYSk7aWYobnVsbCE9Zil7Yz1teFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXNbZl07aWYobnVsbCE9Yyl7aWYobnVsbD09bXhTdGVuY2lsUmVnaXN0cnkucGFja2FnZXNbZl0pe2Zvcih2YXIgZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgbT1jW2RdO2lmKCIueG1sIj09bS50b0xvd2VyQ2FzZSgpLnN1YnN0cmluZyhtLmxlbmd0aC00LG0ubGVuZ3RoKSlteFN0ZW5jaWxSZWdpc3RyeS5sb2FkU3RlbmNpbFNldChtLG51bGwpO2Vsc2UgaWYoIi5qcyI9PW0udG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcobS5sZW5ndGgtMyxtLmxlbmd0aCkpdHJ5e2lmKG14U3RlbmNpbFJlZ2lzdHJ5LmFsbG93RXZhbCl7dmFyIGs9Cm14VXRpbHMubG9hZChtKTtudWxsIT1rJiYyMDA8PWsuZ2V0U3RhdHVzKCkmJjI5OT49ay5nZXRTdGF0dXMoKSYmZXZhbC5jYWxsKHdpbmRvdyxrLmdldFRleHQoKSl9fWNhdGNoKHEpe251bGwhPXdpbmRvdy5jb25zb2xlJiZjb25zb2xlLmxvZygiZXJyb3IgaW4gZ2V0U3RlbmNpbDoiLG0scSl9fW14U3RlbmNpbFJlZ2lzdHJ5LnBhY2thZ2VzW2ZdPTF9fWVsc2UgZj1mLnJlcGxhY2UoIl8tXyIsIl8iKSxteFN0ZW5jaWxSZWdpc3RyeS5sb2FkU3RlbmNpbFNldChTVEVOQ0lMX1BBVEgrIi8iK2YrIi54bWwiLG51bGwpO2M9bXhTdGVuY2lsUmVnaXN0cnkuc3RlbmNpbHNbYV19fXJldHVybiBjfTsKbXhTdGVuY2lsUmVnaXN0cnkuZ2V0QmFzZW5hbWVGb3JTdGVuY2lsPWZ1bmN0aW9uKGEpe3ZhciBjPW51bGw7aWYobnVsbCE9YSYmInN0cmluZyI9PT10eXBlb2YgYSYmKGE9YS5zcGxpdCgiLiIpLDA8YS5sZW5ndGgmJiJteGdyYXBoIj09YVswXSkpZm9yKHZhciBjPWFbMV0sZj0yO2Y8YS5sZW5ndGgtMTtmKyspYys9Ii8iK2FbZl07cmV0dXJuIGN9OwpteFN0ZW5jaWxSZWdpc3RyeS5sb2FkU3RlbmNpbFNldD1mdW5jdGlvbihhLGMsZixkKXt2YXIgbT1teFN0ZW5jaWxSZWdpc3RyeS5wYWNrYWdlc1thXTtpZihudWxsIT1mJiZmfHxudWxsPT1tKXt2YXIgaz0hMTtpZihudWxsPT1tKXRyeXtpZihkKXtteFN0ZW5jaWxSZWdpc3RyeS5sb2FkU3RlbmNpbChhLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGQpe251bGwhPWQmJm51bGwhPWQuZG9jdW1lbnRFbGVtZW50JiYobXhTdGVuY2lsUmVnaXN0cnkucGFja2FnZXNbYV09ZCxrPSEwLG14U3RlbmNpbFJlZ2lzdHJ5LnBhcnNlU3RlbmNpbFNldChkLmRvY3VtZW50RWxlbWVudCxjLGspKX0pKTtyZXR1cm59bT1teFN0ZW5jaWxSZWdpc3RyeS5sb2FkU3RlbmNpbChhKTtteFN0ZW5jaWxSZWdpc3RyeS5wYWNrYWdlc1thXT1tO2s9ITB9Y2F0Y2gocSl7bnVsbCE9d2luZG93LmNvbnNvbGUmJmNvbnNvbGUubG9nKCJlcnJvciBpbiBsb2FkU3RlbmNpbFNldDoiLGEscSl9bnVsbCE9bSYmbnVsbCE9Cm0uZG9jdW1lbnRFbGVtZW50JiZteFN0ZW5jaWxSZWdpc3RyeS5wYXJzZVN0ZW5jaWxTZXQobS5kb2N1bWVudEVsZW1lbnQsYyxrKX19O214U3RlbmNpbFJlZ2lzdHJ5LmxvYWRTdGVuY2lsPWZ1bmN0aW9uKGEsYyl7aWYobnVsbCE9YylteFV0aWxzLmdldChhLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2MoMjAwPD1hLmdldFN0YXR1cygpJiYyOTk+PWEuZ2V0U3RhdHVzKCk/YS5nZXRYbWwoKTpudWxsKX0pKTtlbHNlIHJldHVybiBteFV0aWxzLmxvYWQoYSkuZ2V0WG1sKCl9O214U3RlbmNpbFJlZ2lzdHJ5LnBhcnNlU3RlbmNpbFNldHM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspbXhTdGVuY2lsUmVnaXN0cnkucGFyc2VTdGVuY2lsU2V0KG14VXRpbHMucGFyc2VYbWwoYVtjXSkuZG9jdW1lbnRFbGVtZW50KX07Cm14U3RlbmNpbFJlZ2lzdHJ5LnBhcnNlU3RlbmNpbFNldD1mdW5jdGlvbihhLGMsZil7aWYoInN0ZW5jaWxzIj09YS5ub2RlTmFtZSlmb3IodmFyIGQ9YS5maXJzdENoaWxkO251bGwhPWQ7KSJzaGFwZXMiPT1kLm5vZGVOYW1lJiZteFN0ZW5jaWxSZWdpc3RyeS5wYXJzZVN0ZW5jaWxTZXQoZCxjLGYpLGQ9ZC5uZXh0U2libGluZztlbHNle2Y9bnVsbCE9Zj9mOiEwO3ZhciBkPWEuZmlyc3RDaGlsZCxtPSIiO2E9YS5nZXRBdHRyaWJ1dGUoIm5hbWUiKTtmb3IobnVsbCE9YSYmKG09YSsiLiIpO251bGwhPWQ7KXtpZihkLm5vZGVUeXBlPT1teENvbnN0YW50cy5OT0RFVFlQRV9FTEVNRU5UJiYoYT1kLmdldEF0dHJpYnV0ZSgibmFtZSIpLG51bGwhPWEpKXt2YXIgbT1tLnRvTG93ZXJDYXNlKCksaz1hLnJlcGxhY2UoLyAvZywiXyIpO2YmJm14U3RlbmNpbFJlZ2lzdHJ5LmFkZFN0ZW5jaWwobStrLnRvTG93ZXJDYXNlKCksbmV3IG14U3RlbmNpbChkKSk7aWYobnVsbCE9Yyl7dmFyIHE9ZC5nZXRBdHRyaWJ1dGUoInciKSwKYj1kLmdldEF0dHJpYnV0ZSgiaCIpLHE9bnVsbD09cT84MDpwYXJzZUludChxLDEwKSxiPW51bGw9PWI/ODA6cGFyc2VJbnQoYiwxMCk7YyhtLGssYSxxLGIpfX1kPWQubmV4dFNpYmxpbmd9fX07CiJ1bmRlZmluZWQiIT10eXBlb2YgbXhWZXJ0ZXhIYW5kbGVyJiZmdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTthLmNsYXNzTmFtZT0iZ2VIaW50IjthLnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCI7YS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO3JldHVybiBhfWZ1bmN0aW9uIGMoYSxiKXtzd2l0Y2goYil7Y2FzZSBteENvbnN0YW50cy5QT0lOVFM6cmV0dXJuIGE7Y2FzZSBteENvbnN0YW50cy5NSUxMSU1FVEVSUzpyZXR1cm4oYS9teENvbnN0YW50cy5QSVhFTFNfUEVSX01NKS50b0ZpeGVkKDEpO2Nhc2UgbXhDb25zdGFudHMuSU5DSEVTOnJldHVybihhL214Q29uc3RhbnRzLlBJWEVMU19QRVJfSU5DSCkudG9GaXhlZCgyKX19bXhDb25zdGFudHMuSEFORExFX0ZJTExDT0xPUj0iIzI5YjZmMiI7bXhDb25zdGFudHMuSEFORExFX1NUUk9LRUNPTE9SPSIjMDA4OGNmIjtteENvbnN0YW50cy5WRVJURVhfU0VMRUNUSU9OX0NPTE9SPQoiIzAwYThmZiI7bXhDb25zdGFudHMuT1VUTElORV9DT0xPUj0iIzAwYThmZiI7bXhDb25zdGFudHMuT1VUTElORV9IQU5ETEVfRklMTENPTE9SPSIjOTljY2ZmIjtteENvbnN0YW50cy5PVVRMSU5FX0hBTkRMRV9TVFJPS0VDT0xPUj0iIzAwYThmZiI7bXhDb25zdGFudHMuQ09OTkVDVF9IQU5ETEVfRklMTENPTE9SPSIjY2VlN2ZmIjtteENvbnN0YW50cy5FREdFX1NFTEVDVElPTl9DT0xPUj0iIzAwYThmZiI7bXhDb25zdGFudHMuREVGQVVMVF9WQUxJRF9DT0xPUj0iIzAwYThmZiI7bXhDb25zdGFudHMuTEFCRUxfSEFORExFX0ZJTExDT0xPUj0iI2NlZTdmZiI7bXhDb25zdGFudHMuR1VJREVfQ09MT1I9IiMwMDg4Y2YiO214Q29uc3RhbnRzLkhJR0hMSUdIVF9PUEFDSVRZPTMwO214Q29uc3RhbnRzLkhJR0hMSUdIVF9TSVpFPTU7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuc25hcFRvVGVybWluYWxzPSEwO214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5ndWlkZXNFbmFibGVkPSEwO214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5yZW1vdmVFbXB0eVBhcmVudHM9CiEwO214UnViYmVyYmFuZC5wcm90b3R5cGUuZmFkZU91dD0hMDtteEd1aWRlLnByb3RvdHlwZS5pc0VuYWJsZWRGb3JFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4hbXhFdmVudC5pc0FsdERvd24oYSl9O3ZhciBmPW14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmlzQ3JlYXRlVGFyZ2V0O214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmlzQ3JlYXRlVGFyZ2V0PWZ1bmN0aW9uKGEpe3JldHVybiBteEV2ZW50LmlzQ29udHJvbERvd24oYSl8fGYuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtteENvbnN0cmFpbnRIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVIaWdobGlnaHRTaGFwZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBteEVsbGlwc2UobnVsbCx0aGlzLmhpZ2hsaWdodENvbG9yLHRoaXMuaGlnaGxpZ2h0Q29sb3IsMCk7YS5vcGFjaXR5PW14Q29uc3RhbnRzLkhJR0hMSUdIVF9PUEFDSVRZO3JldHVybiBhfTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5saXZlUHJldmlldz0KITA7bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY3Vyc29yPSJjcm9zc2hhaXIiO214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUVkZ2VTdGF0ZT1mdW5jdGlvbihhKXthPXRoaXMuZ3JhcGguY3JlYXRlQ3VycmVudEVkZ2VTdHlsZSgpO2E9dGhpcy5ncmFwaC5jcmVhdGVFZGdlKG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxhKTthPW5ldyBteENlbGxTdGF0ZSh0aGlzLmdyYXBoLnZpZXcsYSx0aGlzLmdyYXBoLmdldENlbGxTdHlsZShhKSk7Zm9yKHZhciBiIGluIHRoaXMuZ3JhcGguY3VycmVudEVkZ2VTdHlsZSlhLnN0eWxlW2JdPXRoaXMuZ3JhcGguY3VycmVudEVkZ2VTdHlsZVtiXTtyZXR1cm4gYX07dmFyIGQ9bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlU2hhcGU7bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlU2hhcGU9ZnVuY3Rpb24oKXt2YXIgYT1kLmFwcGx5KHRoaXMsYXJndW1lbnRzKTthLmlzRGFzaGVkPSIxIj09CnRoaXMuZ3JhcGguY3VycmVudEVkZ2VTdHlsZVtteENvbnN0YW50cy5TVFlMRV9EQVNIRURdO3JldHVybiBhfTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS51cGRhdGVQcmV2aWV3PWZ1bmN0aW9uKGEpe307dmFyIG09bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlTWFya2VyO214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZU1hcmtlcj1mdW5jdGlvbigpe3ZhciBhPW0uYXBwbHkodGhpcyxhcmd1bWVudHMpLGI9YS5nZXRDZWxsO2EuZ2V0Q2VsbD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt2YXIgZT1iLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLmVycm9yPW51bGw7cmV0dXJuIGV9KTtyZXR1cm4gYX07R3JhcGgucHJvdG90eXBlLmRlZmF1bHRWZXJ0ZXhTdHlsZT17fTtHcmFwaC5wcm90b3R5cGUuZGVmYXVsdEVkZ2VTdHlsZT17ZWRnZVN0eWxlOiJvcnRob2dvbmFsRWRnZVN0eWxlIixyb3VuZGVkOiIwIixqZXR0eVNpemU6ImF1dG8iLApvcnRob2dvbmFsTG9vcDoiMSJ9O0dyYXBoLnByb3RvdHlwZS5jcmVhdGVDdXJyZW50RWRnZVN0eWxlPWZ1bmN0aW9uKCl7dmFyIGE9ImVkZ2VTdHlsZT0iKyh0aGlzLmN1cnJlbnRFZGdlU3R5bGUuZWRnZVN0eWxlfHwibm9uZSIpKyI7IjtudWxsIT10aGlzLmN1cnJlbnRFZGdlU3R5bGUuc2hhcGUmJihhKz0ic2hhcGU9Iit0aGlzLmN1cnJlbnRFZGdlU3R5bGUuc2hhcGUrIjsiKTtudWxsIT10aGlzLmN1cnJlbnRFZGdlU3R5bGUuY3VydmVkJiYoYSs9ImN1cnZlZD0iK3RoaXMuY3VycmVudEVkZ2VTdHlsZS5jdXJ2ZWQrIjsiKTtudWxsIT10aGlzLmN1cnJlbnRFZGdlU3R5bGUucm91bmRlZCYmKGErPSJyb3VuZGVkPSIrdGhpcy5jdXJyZW50RWRnZVN0eWxlLnJvdW5kZWQrIjsiKTtudWxsIT10aGlzLmN1cnJlbnRFZGdlU3R5bGUuY29taWMmJihhKz0iY29taWM9Iit0aGlzLmN1cnJlbnRFZGdlU3R5bGUuY29taWMrIjsiKTtudWxsIT10aGlzLmN1cnJlbnRFZGdlU3R5bGUuanVtcFN0eWxlJiYKKGErPSJqdW1wU3R5bGU9Iit0aGlzLmN1cnJlbnRFZGdlU3R5bGUuanVtcFN0eWxlKyI7Iik7bnVsbCE9dGhpcy5jdXJyZW50RWRnZVN0eWxlLmp1bXBTaXplJiYoYSs9Imp1bXBTaXplPSIrdGhpcy5jdXJyZW50RWRnZVN0eWxlLmp1bXBTaXplKyI7Iik7bnVsbCE9dGhpcy5jdXJyZW50RWRnZVN0eWxlLm9ydGhvZ29uYWxMb29wP2ErPSJvcnRob2dvbmFsTG9vcD0iK3RoaXMuY3VycmVudEVkZ2VTdHlsZS5vcnRob2dvbmFsTG9vcCsiOyI6bnVsbCE9R3JhcGgucHJvdG90eXBlLmRlZmF1bHRFZGdlU3R5bGUub3J0aG9nb25hbExvb3AmJihhKz0ib3J0aG9nb25hbExvb3A9IitHcmFwaC5wcm90b3R5cGUuZGVmYXVsdEVkZ2VTdHlsZS5vcnRob2dvbmFsTG9vcCsiOyIpO251bGwhPXRoaXMuY3VycmVudEVkZ2VTdHlsZS5qZXR0eVNpemU/YSs9ImpldHR5U2l6ZT0iK3RoaXMuY3VycmVudEVkZ2VTdHlsZS5qZXR0eVNpemUrIjsiOm51bGwhPUdyYXBoLnByb3RvdHlwZS5kZWZhdWx0RWRnZVN0eWxlLmpldHR5U2l6ZSYmCihhKz0iamV0dHlTaXplPSIrR3JhcGgucHJvdG90eXBlLmRlZmF1bHRFZGdlU3R5bGUuamV0dHlTaXplKyI7Iik7ImVsYm93RWRnZVN0eWxlIj09dGhpcy5jdXJyZW50RWRnZVN0eWxlLmVkZ2VTdHlsZSYmbnVsbCE9dGhpcy5jdXJyZW50RWRnZVN0eWxlLmVsYm93JiYoYSs9ImVsYm93PSIrdGhpcy5jdXJyZW50RWRnZVN0eWxlLmVsYm93KyI7Iik7cmV0dXJuIGE9bnVsbCE9dGhpcy5jdXJyZW50RWRnZVN0eWxlLmh0bWw/YSsoImh0bWw9Iit0aGlzLmN1cnJlbnRFZGdlU3R5bGUuaHRtbCsiOyIpOmErImh0bWw9MTsifTtHcmFwaC5wcm90b3R5cGUuZ2V0UGFnZVBhZGRpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG14UG9pbnQoMCwwKX07R3JhcGgucHJvdG90eXBlLmxvYWRTdHlsZXNoZWV0PWZ1bmN0aW9uKCl7dmFyIGE9bnVsbCE9dGhpcy50aGVtZXM/dGhpcy50aGVtZXNbdGhpcy5kZWZhdWx0VGhlbWVOYW1lXTpteFN0eWxlUmVnaXN0cnkuZHluYW1pY0xvYWRpbmc/bXhVdGlscy5sb2FkKFNUWUxFX1BBVEgrCiIvZGVmYXVsdC54bWwiKS5nZXREb2N1bWVudEVsZW1lbnQoKTpudWxsO251bGwhPWEmJihuZXcgbXhDb2RlYyhhLm93bmVyRG9jdW1lbnQpKS5kZWNvZGUoYSx0aGlzLmdldFN0eWxlc2hlZXQoKSl9O0dyYXBoLnByb3RvdHlwZS5jcmVhdGVDZWxsTG9va3VwPWZ1bmN0aW9uKGEsYil7Yj1udWxsIT1iP2I6e307Zm9yKHZhciBlPTA7ZTxhLmxlbmd0aDtlKyspe3ZhciBjPWFbZV07YltteE9iamVjdElkZW50aXR5LmdldChjKV09Yy5nZXRJZCgpO2Zvcih2YXIgZD10aGlzLm1vZGVsLmdldENoaWxkQ291bnQoYyksZj0wO2Y8ZDtmKyspdGhpcy5jcmVhdGVDZWxsTG9va3VwKFt0aGlzLm1vZGVsLmdldENoaWxkQXQoYyxmKV0sYil9cmV0dXJuIGJ9O0dyYXBoLnByb3RvdHlwZS5jcmVhdGVDZWxsTWFwcGluZz1mdW5jdGlvbihhLGIsZSl7ZT1udWxsIT1lP2U6e307Zm9yKHZhciBjIGluIGEpe3ZhciBkPWJbY107bnVsbD09ZVtkXSYmKGVbZF09YVtjXS5nZXRJZCgpfHwiIil9cmV0dXJuIGV9OwpHcmFwaC5wcm90b3R5cGUuaW1wb3J0R3JhcGhNb2RlbD1mdW5jdGlvbihhLGIsZSxjKXtiPW51bGwhPWI/YjowO2U9bnVsbCE9ZT9lOjA7dmFyIGQ9bmV3IG14Q29kZWMoYS5vd25lckRvY3VtZW50KSxmPW5ldyBteEdyYXBoTW9kZWw7ZC5kZWNvZGUoYSxmKTthPVtdO3ZhciBkPXt9LGc9e30sbD1mLmdldENoaWxkcmVuKHRoaXMuY2xvbmVDZWxsKGYucm9vdCx0aGlzLmlzQ2xvbmVJbnZhbGlkRWRnZXMoKSxkKSk7aWYobnVsbCE9bCl7dmFyIHA9dGhpcy5jcmVhdGVDZWxsTG9va3VwKFtmLnJvb3RdKSxsPWwuc2xpY2UoKTt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e2lmKDEhPWwubGVuZ3RofHx0aGlzLmlzQ2VsbExvY2tlZCh0aGlzLmdldERlZmF1bHRQYXJlbnQoKSkpZm9yKGY9MDtmPGwubGVuZ3RoO2YrKyl7dmFyIHU9dGhpcy5tb2RlbC5nZXRDaGlsZHJlbih0aGlzLm1vdmVDZWxscyhbbFtmXV0sYixlLCExLHRoaXMubW9kZWwuZ2V0Um9vdCgpKVswXSk7bnVsbCE9dSYmCihhPWEuY29uY2F0KHUpKX1lbHNlIGE9dGhpcy5tb3ZlQ2VsbHMoZi5nZXRDaGlsZHJlbihsWzBdKSxiLGUsITEsdGhpcy5nZXREZWZhdWx0UGFyZW50KCkpLGdbZi5nZXRDaGlsZEF0KGYucm9vdCwwKS5nZXRJZCgpXT10aGlzLmdldERlZmF1bHRQYXJlbnQoKS5nZXRJZCgpO2lmKG51bGwhPWEmJih0aGlzLmNyZWF0ZUNlbGxNYXBwaW5nKGQscCxnKSx0aGlzLnVwZGF0ZUN1c3RvbUxpbmtzKGcsYSksYykpe3RoaXMuaXNHcmlkRW5hYmxlZCgpJiYoYj10aGlzLnNuYXAoYiksZT10aGlzLnNuYXAoZSkpO3ZhciBuPXRoaXMuZ2V0Qm91bmRpbmdCb3hGcm9tR2VvbWV0cnkoYSwhMCk7bnVsbCE9biYmdGhpcy5tb3ZlQ2VsbHMoYSxiLW4ueCxlLW4ueSl9fWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX19cmV0dXJuIGF9O0dyYXBoLnByb3RvdHlwZS5lbmNvZGVDZWxscz1mdW5jdGlvbihhKXtmb3IodmFyIGI9e30sZT10aGlzLmNsb25lQ2VsbHMoYSxudWxsLGIpLGM9bmV3IG14RGljdGlvbmFyeSwKZD0wO2Q8YS5sZW5ndGg7ZCsrKWMucHV0KGFbZF0sITApO2Zvcih2YXIgZj1uZXcgbXhDb2RlYyxnPW5ldyBteEdyYXBoTW9kZWwsbD1nLmdldENoaWxkQXQoZy5nZXRSb290KCksMCksZD0wO2Q8ZS5sZW5ndGg7ZCsrKXtnLmFkZChsLGVbZF0pO3ZhciBwPXRoaXMudmlldy5nZXRTdGF0ZShhW2RdKTtpZihudWxsIT1wKXt2YXIgdT10aGlzLmdldENlbGxHZW9tZXRyeShlW2RdKTtudWxsIT11JiZ1LnJlbGF0aXZlJiYhdGhpcy5tb2RlbC5pc0VkZ2UoYVtkXSkmJm51bGw9PWMuZ2V0KHRoaXMubW9kZWwuZ2V0UGFyZW50KGFbZF0pKSYmKHUub2Zmc2V0PW51bGwsdS5yZWxhdGl2ZT0hMSx1Lng9cC54L3Audmlldy5zY2FsZS1wLnZpZXcudHJhbnNsYXRlLngsdS55PXAueS9wLnZpZXcuc2NhbGUtcC52aWV3LnRyYW5zbGF0ZS55KX19dGhpcy51cGRhdGVDdXN0b21MaW5rcyh0aGlzLmNyZWF0ZUNlbGxNYXBwaW5nKGIsdGhpcy5jcmVhdGVDZWxsTG9va3VwKGEpKSxlKTtyZXR1cm4gZi5lbmNvZGUoZyl9OwpHcmFwaC5wcm90b3R5cGUuaXNTd2ltbGFuZT1mdW5jdGlvbihhLGIpe2lmKG51bGwhPWEmJnRoaXMubW9kZWwuZ2V0UGFyZW50KGEpIT10aGlzLm1vZGVsLmdldFJvb3QoKSYmIXRoaXMubW9kZWwuaXNFZGdlKGEpKXt2YXIgZT10aGlzLmdldEN1cnJlbnRDZWxsU3R5bGUoYSxiKVtteENvbnN0YW50cy5TVFlMRV9TSEFQRV07cmV0dXJuIGU9PW14Q29uc3RhbnRzLlNIQVBFX1NXSU1MQU5FfHwidGFibGUiPT1lfXJldHVybiExfTt2YXIgaz1HcmFwaC5wcm90b3R5cGUuaXNFeHRlbmRQYXJlbnQ7R3JhcGgucHJvdG90eXBlLmlzRXh0ZW5kUGFyZW50PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubW9kZWwuZ2V0UGFyZW50KGEpO2lmKG51bGwhPWIpe3ZhciBlPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShiKTtpZihudWxsIT1lLmV4cGFuZClyZXR1cm4iMCIhPWUuZXhwYW5kfXJldHVybiBrLmFwcGx5KHRoaXMsYXJndW1lbnRzKSYmKG51bGw9PWJ8fCF0aGlzLmlzVGFibGUoYikpfTt2YXIgcT0KR3JhcGgucHJvdG90eXBlLnNwbGl0RWRnZTtHcmFwaC5wcm90b3R5cGUuc3BsaXRFZGdlPWZ1bmN0aW9uKGEsYixlLGMsZCxmLGcsbCl7bnVsbD09bCYmKGw9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYSksdGhpcy5pc1RhYmxlKGwpfHx0aGlzLmlzVGFibGVSb3cobCkpJiYobD10aGlzLmdldENlbGxBdChmLGcsbnVsbCwhMCwhMSkpO3EuYXBwbHkodGhpcyxbYSxiLGUsYyxkLGYsZyxsXSl9O3ZhciBiPUdyYXBoLnByb3RvdHlwZS5zZWxlY3RDZWxsO0dyYXBoLnByb3RvdHlwZS5zZWxlY3RDZWxsPWZ1bmN0aW9uKGEsZSxjKXtpZihlfHxjKWIuYXBwbHkodGhpcyxhcmd1bWVudHMpO2Vsc2V7dmFyIGQ9dGhpcy5nZXRTZWxlY3Rpb25DZWxsKCksZj1udWxsLGc9W10sbD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXtpZihudWxsIT10aGlzLnZpZXcuZ2V0U3RhdGUoYikmJih0aGlzLm1vZGVsLmlzVmVydGV4KGIpfHx0aGlzLm1vZGVsLmlzRWRnZShiKSkpaWYoZy5wdXNoKGIpLGI9PQpkKWY9Zy5sZW5ndGgtMTtlbHNlIGlmKGEmJm51bGw9PWQmJjA8Zy5sZW5ndGh8fG51bGwhPWYmJmEmJmcubGVuZ3RoPmZ8fCFhJiYwPGYpcmV0dXJuO2Zvcih2YXIgZT0wO2U8dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGIpO2UrKylsKHRoaXMubW9kZWwuZ2V0Q2hpbGRBdChiLGUpKX0pO2wodGhpcy5tb2RlbC5yb290KTswPGcubGVuZ3RoJiYoZj1udWxsIT1mP214VXRpbHMubW9kKGYrKGE/MTotMSksZy5sZW5ndGgpOjAsdGhpcy5zZXRTZWxlY3Rpb25DZWxsKGdbZl0pKX19O3ZhciBlPUdyYXBoLnByb3RvdHlwZS5tb3ZlQ2VsbHM7R3JhcGgucHJvdG90eXBlLm1vdmVDZWxscz1mdW5jdGlvbihhLGIsYyxkLGYsZyxsKXtsPW51bGwhPWw/bDp7fTtmb3IodmFyIHA9MDtwPGEubGVuZ3RoO3ArKylpZihudWxsIT1mJiZ0aGlzLmlzVGFibGVSb3coYVtwXSkpe3ZhciB1PXRoaXMubW9kZWwuZ2V0UGFyZW50KGFbcF0pLG49dGhpcy5nZXRDZWxsR2VvbWV0cnkoYVtwXSk7aWYobnVsbCE9CnUmJm51bGwhPW4mJnRoaXMuaXNUYWJsZSh1KSYmdGhpcy5pc1RhYmxlKGYpJiYoZHx8dSE9Zikpe2lmKCFkKXt2YXIgdD10aGlzLmdldENlbGxHZW9tZXRyeSh1KTtudWxsIT10JiYodD10LmNsb25lKCksdC5oZWlnaHQtPW4uaGVpZ2h0LHRoaXMubW9kZWwuc2V0R2VvbWV0cnkodSx0KSl9dD10aGlzLmdldENlbGxHZW9tZXRyeShmKTtudWxsIT10JiYodD10LmNsb25lKCksdC5oZWlnaHQrPW4uaGVpZ2h0LHRoaXMubW9kZWwuc2V0R2VvbWV0cnkoZix0KSk7bj10aGlzLm1vZGVsLmdldENoaWxkQ2VsbHMoZiwhMCk7aWYoMDxuLmxlbmd0aClpZih1PXRoaXMubW9kZWwuZ2V0Q2hpbGRDZWxscyhhW3BdLCEwKSxuPXRoaXMubW9kZWwuZ2V0Q2hpbGRDZWxscyhuWzBdLCEwKS5sZW5ndGgtdS5sZW5ndGgsMDxuKWZvcih0PTA7dDxuO3QrKyl7dmFyIFQ9dGhpcy5jbG9uZUNlbGwodVt1Lmxlbmd0aC0xXSk7VC52YWx1ZT0iIjt0aGlzLm1vZGVsLmFkZChhW3BdLFQpfWVsc2UgaWYoMD5uKWZvcih0PQowO3Q+bjt0LS0pdGhpcy5tb2RlbC5yZW1vdmUodVt1Lmxlbmd0aC1uLTFdKX19cD1lLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtkJiZ0aGlzLnVwZGF0ZUN1c3RvbUxpbmtzKHRoaXMuY3JlYXRlQ2VsbE1hcHBpbmcobCx0aGlzLmNyZWF0ZUNlbGxMb29rdXAoYSkpLHApO3JldHVybiBwfTt2YXIgZz1HcmFwaC5wcm90b3R5cGUucmVtb3ZlQ2VsbHM7R3JhcGgucHJvdG90eXBlLnJlbW92ZUNlbGxzPWZ1bmN0aW9uKGEsYil7dmFyIGU9W107dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKylpZih0aGlzLmlzVGFibGVDZWxsKGFbY10pKXt2YXIgZD10aGlzLm1vZGVsLmdldFBhcmVudChhW2NdKSxmPXRoaXMubW9kZWwuZ2V0UGFyZW50KGQpOzE9PXRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChkKSYmMT09dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGYpPzA+bXhVdGlscy5pbmRleE9mKGEsZikmJjA+bXhVdGlscy5pbmRleE9mKGUsZikmJmUucHVzaChmKToKdGhpcy5sYWJlbENoYW5nZWQoYVtjXSwiIil9ZWxzZXtpZih0aGlzLmlzVGFibGVSb3coYVtjXSkmJihmPXRoaXMubW9kZWwuZ2V0UGFyZW50KGFbY10pLDA+bXhVdGlscy5pbmRleE9mKGEsZikmJjA+bXhVdGlscy5pbmRleE9mKGUsZikpKXtmb3IodmFyIGw9dGhpcy5tb2RlbC5nZXRDaGlsZENlbGxzKGYsITApLHA9MCx1PTA7dTxsLmxlbmd0aDt1KyspMDw9bXhVdGlscy5pbmRleE9mKGEsbFt1XSkmJnArKztwPT1sLmxlbmd0aCYmZS5wdXNoKGYpfWUucHVzaChhW2NdKX1lPWcuYXBwbHkodGhpcyxbZSxiXSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfXJldHVybiBlfTtHcmFwaC5wcm90b3R5cGUudXBkYXRlQ3VzdG9tTGlua3M9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGU9MDtlPGIubGVuZ3RoO2UrKyludWxsIT1iW2VdJiZ0aGlzLnVwZGF0ZUN1c3RvbUxpbmtzRm9yQ2VsbChhLGJbZV0pfTtHcmFwaC5wcm90b3R5cGUudXBkYXRlQ3VzdG9tTGlua3NGb3JDZWxsPWZ1bmN0aW9uKGEsCmIpe307R3JhcGgucHJvdG90eXBlLmdldEFsbENvbm5lY3Rpb25Db25zdHJhaW50cz1mdW5jdGlvbihhLGIpe2lmKG51bGwhPWEpe3ZhciBlPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSwicG9pbnRzIixudWxsKTtpZihudWxsIT1lKXt2YXIgYz1bXTt0cnl7Zm9yKHZhciBkPUpTT04ucGFyc2UoZSksZT0wO2U8ZC5sZW5ndGg7ZSsrKXt2YXIgZj1kW2VdO2MucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludChmWzBdLGZbMV0pLDI8Zi5sZW5ndGg/IjAiIT1mWzJdOiEwLG51bGwsMzxmLmxlbmd0aD9mWzNdOjAsNDxmLmxlbmd0aD9mWzRdOjApKX19Y2F0Y2goemEpe31yZXR1cm4gY31pZihudWxsIT1hLnNoYXBlJiZudWxsIT1hLnNoYXBlLmJvdW5kcyl7Zj1hLnNoYXBlLmRpcmVjdGlvbjtkPWEuc2hhcGUuYm91bmRzO2U9YS5zaGFwZS5zY2FsZTtjPWQud2lkdGgvZTtkPWQuaGVpZ2h0L2U7aWYoZj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIfHxmPT0KbXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIKWY9YyxjPWQsZD1mO2U9YS5zaGFwZS5nZXRDb25zdHJhaW50cyhhLnN0eWxlLGMsZCk7aWYobnVsbCE9ZSlyZXR1cm4gZTtpZihudWxsIT1hLnNoYXBlLnN0ZW5jaWwmJm51bGwhPWEuc2hhcGUuc3RlbmNpbC5jb25zdHJhaW50cylyZXR1cm4gYS5zaGFwZS5zdGVuY2lsLmNvbnN0cmFpbnRzO2lmKG51bGwhPWEuc2hhcGUuY29uc3RyYWludHMpcmV0dXJuIGEuc2hhcGUuY29uc3RyYWludHN9fXJldHVybiBudWxsfTtHcmFwaC5wcm90b3R5cGUuZmxpcEVkZ2U9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSl7dmFyIGI9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpLGI9bXhVdGlscy5nZXRWYWx1ZShiLG14Q29uc3RhbnRzLlNUWUxFX0VMQk9XLG14Q29uc3RhbnRzLkVMQk9XX0hPUklaT05UQUwpPT1teENvbnN0YW50cy5FTEJPV19IT1JJWk9OVEFMP214Q29uc3RhbnRzLkVMQk9XX1ZFUlRJQ0FMOm14Q29uc3RhbnRzLkVMQk9XX0hPUklaT05UQUw7CnRoaXMuc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9FTEJPVyxiLFthXSl9fTtHcmFwaC5wcm90b3R5cGUuaXNWYWxpZFJvb3Q9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChhKSxlPTAsYz0wO2M8YjtjKyspe3ZhciBkPXRoaXMubW9kZWwuZ2V0Q2hpbGRBdChhLGMpO3RoaXMubW9kZWwuaXNWZXJ0ZXgoZCkmJihkPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KGQpLG51bGw9PWR8fGQucmVsYXRpdmV8fGUrKyl9cmV0dXJuIDA8ZXx8dGhpcy5pc0NvbnRhaW5lcihhKX07R3JhcGgucHJvdG90eXBlLmlzVmFsaWREcm9wVGFyZ2V0PWZ1bmN0aW9uKGEsYixlKXtmb3IodmFyIGM9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpLGQ9ITAsZj0wO2Y8Yi5sZW5ndGgmJmQ7ZisrKWQ9ZCYmdGhpcy5pc1RhYmxlUm93KGJbZl0pO3JldHVybigiMSIhPW14VXRpbHMuZ2V0VmFsdWUoYywicGFydCIsIjAiKXx8dGhpcy5pc0NvbnRhaW5lcihhKSkmJiIwIiE9Cm14VXRpbHMuZ2V0VmFsdWUoYywiZHJvcFRhcmdldCIsIjEiKSYmKG14R3JhcGgucHJvdG90eXBlLmlzVmFsaWREcm9wVGFyZ2V0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpcy5pc0NvbnRhaW5lcihhKSkmJiF0aGlzLmlzVGFibGVSb3coYSkmJighdGhpcy5pc1RhYmxlKGEpfHxkKX07R3JhcGgucHJvdG90eXBlLmNyZWF0ZUdyb3VwQ2VsbD1mdW5jdGlvbigpe3ZhciBhPW14R3JhcGgucHJvdG90eXBlLmNyZWF0ZUdyb3VwQ2VsbC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YS5zZXRTdHlsZSgiZ3JvdXAiKTtyZXR1cm4gYX07R3JhcGgucHJvdG90eXBlLmlzRXh0ZW5kUGFyZW50c09uQWRkPWZ1bmN0aW9uKGEpe3ZhciBiPW14R3JhcGgucHJvdG90eXBlLmlzRXh0ZW5kUGFyZW50c09uQWRkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZihiJiZudWxsIT1hJiZudWxsIT10aGlzLmxheW91dE1hbmFnZXIpe3ZhciBlPXRoaXMubW9kZWwuZ2V0UGFyZW50KGEpO251bGwhPWUmJihlPXRoaXMubGF5b3V0TWFuYWdlci5nZXRMYXlvdXQoZSksCm51bGwhPWUmJmUuY29uc3RydWN0b3I9PW14U3RhY2tMYXlvdXQmJihiPSExKSl9cmV0dXJuIGJ9O0dyYXBoLnByb3RvdHlwZS5nZXRQcmVmZXJyZWRTaXplRm9yQ2VsbD1mdW5jdGlvbihhKXt2YXIgYj1teEdyYXBoLnByb3RvdHlwZS5nZXRQcmVmZXJyZWRTaXplRm9yQ2VsbC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbCE9YiYmKGIud2lkdGgrPTEwLGIuaGVpZ2h0Kz00LHRoaXMuZ3JpZEVuYWJsZWQmJihiLndpZHRoPXRoaXMuc25hcChiLndpZHRoKSxiLmhlaWdodD10aGlzLnNuYXAoYi5oZWlnaHQpKSk7cmV0dXJuIGJ9O0dyYXBoLnByb3RvdHlwZS50dXJuU2hhcGVzPWZ1bmN0aW9uKGEsYil7dmFyIGU9dGhpcy5nZXRNb2RlbCgpLGM9W107ZS5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGQ9MDtkPGEubGVuZ3RoO2QrKyl7dmFyIGY9YVtkXTtpZihlLmlzRWRnZShmKSl7dmFyIGc9ZS5nZXRUZXJtaW5hbChmLCEwKSxsPWUuZ2V0VGVybWluYWwoZiwhMSk7ZS5zZXRUZXJtaW5hbChmLApsLCEwKTtlLnNldFRlcm1pbmFsKGYsZywhMSk7dmFyIHA9ZS5nZXRHZW9tZXRyeShmKTtpZihudWxsIT1wKXtwPXAuY2xvbmUoKTtudWxsIT1wLnBvaW50cyYmcC5wb2ludHMucmV2ZXJzZSgpO3ZhciB1PXAuZ2V0VGVybWluYWxQb2ludCghMCksbj1wLmdldFRlcm1pbmFsUG9pbnQoITEpO3Auc2V0VGVybWluYWxQb2ludCh1LCExKTtwLnNldFRlcm1pbmFsUG9pbnQobiwhMCk7ZS5zZXRHZW9tZXRyeShmLHApO3ZhciB0PXRoaXMudmlldy5nZXRTdGF0ZShmKSxCPXRoaXMudmlldy5nZXRTdGF0ZShnKSxrPXRoaXMudmlldy5nZXRTdGF0ZShsKTtpZihudWxsIT10KXt2YXIgVD1udWxsIT1CP3RoaXMuZ2V0Q29ubmVjdGlvbkNvbnN0cmFpbnQodCxCLCEwKTpudWxsLG09bnVsbCE9az90aGlzLmdldENvbm5lY3Rpb25Db25zdHJhaW50KHQsaywhMSk6bnVsbDt0aGlzLnNldENvbm5lY3Rpb25Db25zdHJhaW50KGYsZywhMCxtKTt0aGlzLnNldENvbm5lY3Rpb25Db25zdHJhaW50KGYsbCwKITEsVCl9Yy5wdXNoKGYpfX1lbHNlIGlmKGUuaXNWZXJ0ZXgoZikmJihwPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KGYpLG51bGwhPXApKXtpZighdGhpcy5pc1RhYmxlKGYpJiYhdGhpcy5pc1RhYmxlUm93KGYpJiYhdGhpcy5pc1RhYmxlQ2VsbChmKSl7cD1wLmNsb25lKCk7cC54Kz1wLndpZHRoLzItcC5oZWlnaHQvMjtwLnkrPXAuaGVpZ2h0LzItcC53aWR0aC8yO3ZhciB5PXAud2lkdGg7cC53aWR0aD1wLmhlaWdodDtwLmhlaWdodD15O2Uuc2V0R2VvbWV0cnkoZixwKX12YXIgdj10aGlzLnZpZXcuZ2V0U3RhdGUoZik7aWYobnVsbCE9dil7dmFyIEs9W214Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNULG14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSCxteENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVCxteENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEhdLHg9bXhVdGlscy5nZXRWYWx1ZSh2LnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0RJUkVDVElPTixteENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVCk7CnRoaXMuc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9ESVJFQ1RJT04sS1tteFV0aWxzLm1vZChteFV0aWxzLmluZGV4T2YoSyx4KSsoYj8tMToxKSxLLmxlbmd0aCldLFtmXSl9Yy5wdXNoKGYpfX19ZmluYWxseXtlLmVuZFVwZGF0ZSgpfXJldHVybiBjfTtHcmFwaC5wcm90b3R5cGUuc3RlbmNpbEhhc1BsYWNlaG9sZGVycz1mdW5jdGlvbihhKXtpZihudWxsIT1hJiZudWxsIT1hLmZnTm9kZSlmb3IoYT1hLmZnTm9kZS5maXJzdENoaWxkO251bGwhPWE7KXtpZigidGV4dCI9PWEubm9kZU5hbWUmJiIxIj09YS5nZXRBdHRyaWJ1dGUoInBsYWNlaG9sZGVycyIpKXJldHVybiEwO2E9YS5uZXh0U2libGluZ31yZXR1cm4hMX07dmFyIHA9R3JhcGgucHJvdG90eXBlLnByb2Nlc3NDaGFuZ2U7R3JhcGgucHJvdG90eXBlLnByb2Nlc3NDaGFuZ2U9ZnVuY3Rpb24oYSl7aWYoYSBpbnN0YW5jZW9mIG14R2VvbWV0cnlDaGFuZ2UmJih0aGlzLmlzVGFibGVDZWxsKGEuY2VsbCl8fHRoaXMuaXNUYWJsZVJvdyhhLmNlbGwpKSYmCihudWxsPT1hLnByZXZpb3VzJiZudWxsIT1hLmdlb21ldHJ5fHxudWxsIT1hLnByZXZpb3VzJiYhYS5wcmV2aW91cy5lcXVhbHMoYS5nZW9tZXRyeSkpKXt2YXIgYj1hLmNlbGw7dGhpcy5pc1RhYmxlQ2VsbChiKSYmKGI9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYikpO3RoaXMuaXNUYWJsZVJvdyhiKSYmKGI9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYikpO3ZhciBlPXRoaXMudmlldy5nZXRTdGF0ZShiKTtudWxsIT1lJiZudWxsIT1lLnNoYXBlJiYodGhpcy52aWV3LmludmFsaWRhdGUoYiksZS5zaGFwZS5ib3VuZHM9bnVsbCl9cC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YSBpbnN0YW5jZW9mIG14VmFsdWVDaGFuZ2UmJm51bGwhPWEuY2VsbCYmbnVsbCE9YS5jZWxsLnZhbHVlJiYib2JqZWN0Ij09dHlwZW9mIGEuY2VsbC52YWx1ZSYmdGhpcy5pbnZhbGlkYXRlRGVzY2VuZGFudHNXaXRoUGxhY2Vob2xkZXJzKGEuY2VsbCl9O0dyYXBoLnByb3RvdHlwZS5pbnZhbGlkYXRlRGVzY2VuZGFudHNXaXRoUGxhY2Vob2xkZXJzPQpmdW5jdGlvbihhKXthPXRoaXMubW9kZWwuZ2V0RGVzY2VuZGFudHMoYSk7aWYoMDxhLmxlbmd0aClmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGU9dGhpcy52aWV3LmdldFN0YXRlKGFbYl0pO251bGwhPWUmJm51bGwhPWUuc2hhcGUmJm51bGwhPWUuc2hhcGUuc3RlbmNpbCYmdGhpcy5zdGVuY2lsSGFzUGxhY2Vob2xkZXJzKGUuc2hhcGUuc3RlbmNpbCk/dGhpcy5yZW1vdmVTdGF0ZUZvckNlbGwoYVtiXSk6dGhpcy5pc1JlcGxhY2VQbGFjZWhvbGRlcnMoYVtiXSkmJnRoaXMudmlldy5pbnZhbGlkYXRlKGFbYl0sITEsITEpfX07R3JhcGgucHJvdG90eXBlLnJlcGxhY2VFbGVtZW50PWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBlPWEub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KG51bGwhPWI/Yjoic3BhbiIpLGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYS5hdHRyaWJ1dGVzKTthdHRyPWMucG9wKCk7KWUuc2V0QXR0cmlidXRlKGF0dHIubm9kZU5hbWUsYXR0ci5ub2RlVmFsdWUpOwplLmlubmVySFRNTD1hLmlubmVySFRNTDthLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGUsYSl9O0dyYXBoLnByb3RvdHlwZS5wcm9jZXNzRWxlbWVudHM9ZnVuY3Rpb24oYSxiKXtpZihudWxsIT1hKWZvcih2YXIgZT1hLmdldEVsZW1lbnRzQnlUYWdOYW1lKCIqIiksYz0wO2M8ZS5sZW5ndGg7YysrKWIoZVtjXSl9O0dyYXBoLnByb3RvdHlwZS51cGRhdGVMYWJlbEVsZW1lbnRzPWZ1bmN0aW9uKGEsYixlKXthPW51bGwhPWE/YTp0aGlzLmdldFNlbGVjdGlvbkNlbGxzKCk7Zm9yKHZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLGQ9MDtkPGEubGVuZ3RoO2QrKylpZih0aGlzLmlzSHRtbExhYmVsKGFbZF0pKXt2YXIgZj10aGlzLmNvbnZlcnRWYWx1ZVRvU3RyaW5nKGFbZF0pO2lmKG51bGwhPWYmJjA8Zi5sZW5ndGgpe2MuaW5uZXJIVE1MPWY7Zm9yKHZhciBnPWMuZ2V0RWxlbWVudHNCeVRhZ05hbWUobnVsbCE9ZT9lOiIqIiksbD0wO2w8Zy5sZW5ndGg7bCsrKWIoZ1tsXSk7CmMuaW5uZXJIVE1MIT1mJiZ0aGlzLmNlbGxMYWJlbENoYW5nZWQoYVtkXSxjLmlubmVySFRNTCl9fX07R3JhcGgucHJvdG90eXBlLmNlbGxMYWJlbENoYW5nZWQ9ZnVuY3Rpb24oYSxiLGUpe2I9R3JhcGguemFwR3JlbWxpbnMoYik7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtpZihudWxsIT1hLnZhbHVlJiYib2JqZWN0Ij09dHlwZW9mIGEudmFsdWUpe2lmKHRoaXMuaXNSZXBsYWNlUGxhY2Vob2xkZXJzKGEpJiZudWxsIT1hLmdldEF0dHJpYnV0ZSgicGxhY2Vob2xkZXIiKSlmb3IodmFyIGM9YS5nZXRBdHRyaWJ1dGUoInBsYWNlaG9sZGVyIiksZD1hO251bGwhPWQ7KXtpZihkPT10aGlzLm1vZGVsLmdldFJvb3QoKXx8bnVsbCE9ZC52YWx1ZSYmIm9iamVjdCI9PXR5cGVvZiBkLnZhbHVlJiZkLmhhc0F0dHJpYnV0ZShjKSl7dGhpcy5zZXRBdHRyaWJ1dGVGb3JDZWxsKGQsYyxiKTticmVha31kPXRoaXMubW9kZWwuZ2V0UGFyZW50KGQpfXZhciBmPWEudmFsdWUuY2xvbmVOb2RlKCEwKTsKZi5zZXRBdHRyaWJ1dGUoImxhYmVsIixiKTtiPWZ9bXhHcmFwaC5wcm90b3R5cGUuY2VsbExhYmVsQ2hhbmdlZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX07R3JhcGgucHJvdG90eXBlLmNlbGxzUmVtb3ZlZD1mdW5jdGlvbihhKXtpZihudWxsIT1hKXtmb3IodmFyIGI9bmV3IG14RGljdGlvbmFyeSxlPTA7ZTxhLmxlbmd0aDtlKyspYi5wdXQoYVtlXSwhMCk7Zm9yKHZhciBjPVtdLGU9MDtlPGEubGVuZ3RoO2UrKyl7dmFyIGQ9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYVtlXSk7bnVsbD09ZHx8Yi5nZXQoZCl8fChiLnB1dChkLCEwKSxjLnB1c2goZCkpfWZvcihlPTA7ZTxjLmxlbmd0aDtlKyspaWYoZD10aGlzLnZpZXcuZ2V0U3RhdGUoY1tlXSksbnVsbCE9ZCYmKHRoaXMubW9kZWwuaXNFZGdlKGQuY2VsbCl8fHRoaXMubW9kZWwuaXNWZXJ0ZXgoZC5jZWxsKSkmJnRoaXMuaXNDZWxsRGVsZXRhYmxlKGQuY2VsbCkmJnRoaXMuaXNUcmFuc3BhcmVudFN0YXRlKGQpKXtmb3IodmFyIGY9CiEwLGc9MDtnPHRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChkLmNlbGwpJiZmO2crKyliLmdldCh0aGlzLm1vZGVsLmdldENoaWxkQXQoZC5jZWxsLGcpKXx8KGY9ITEpO2YmJmEucHVzaChkLmNlbGwpfX1teEdyYXBoLnByb3RvdHlwZS5jZWxsc1JlbW92ZWQuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtHcmFwaC5wcm90b3R5cGUucmVtb3ZlQ2VsbHNBZnRlclVuZ3JvdXA9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVtdLGU9MDtlPGEubGVuZ3RoO2UrKyl0aGlzLmlzQ2VsbERlbGV0YWJsZShhW2VdKSYmdGhpcy5pc1RyYW5zcGFyZW50U3RhdGUodGhpcy52aWV3LmdldFN0YXRlKGFbZV0pKSYmYi5wdXNoKGFbZV0pO2E9YjtteEdyYXBoLnByb3RvdHlwZS5yZW1vdmVDZWxsc0FmdGVyVW5ncm91cC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O0dyYXBoLnByb3RvdHlwZS5zZXRMaW5rRm9yQ2VsbD1mdW5jdGlvbihhLGIpe3RoaXMuc2V0QXR0cmlidXRlRm9yQ2VsbChhLCJsaW5rIixiKX07R3JhcGgucHJvdG90eXBlLnNldFRvb2x0aXBGb3JDZWxsPQpmdW5jdGlvbihhLGIpe3RoaXMuc2V0QXR0cmlidXRlRm9yQ2VsbChhLCJ0b29sdGlwIixiKX07R3JhcGgucHJvdG90eXBlLmdldEF0dHJpYnV0ZUZvckNlbGw9ZnVuY3Rpb24oYSxiLGUpe2E9bnVsbCE9YS52YWx1ZSYmIm9iamVjdCI9PT10eXBlb2YgYS52YWx1ZT9hLnZhbHVlLmdldEF0dHJpYnV0ZShiKTpudWxsO3JldHVybiBudWxsIT1hP2E6ZX07R3JhcGgucHJvdG90eXBlLnNldEF0dHJpYnV0ZUZvckNlbGw9ZnVuY3Rpb24oYSxiLGUpe3ZhciBjO251bGwhPWEudmFsdWUmJiJvYmplY3QiPT10eXBlb2YgYS52YWx1ZT9jPWEudmFsdWUuY2xvbmVOb2RlKCEwKTooYz1teFV0aWxzLmNyZWF0ZVhtbERvY3VtZW50KCkuY3JlYXRlRWxlbWVudCgiVXNlck9iamVjdCIpLGMuc2V0QXR0cmlidXRlKCJsYWJlbCIsYS52YWx1ZXx8IiIpKTtudWxsIT1lP2Muc2V0QXR0cmlidXRlKGIsZSk6Yy5yZW1vdmVBdHRyaWJ1dGUoYik7dGhpcy5tb2RlbC5zZXRWYWx1ZShhLGMpfTt2YXIgbD1HcmFwaC5wcm90b3R5cGUuZ2V0RHJvcFRhcmdldDsKR3JhcGgucHJvdG90eXBlLmdldERyb3BUYXJnZXQ9ZnVuY3Rpb24oYSxiLGUsYyl7dGhpcy5nZXRNb2RlbCgpO2lmKG14RXZlbnQuaXNBbHREb3duKGIpKXJldHVybiBudWxsO2Zvcih2YXIgZD0wO2Q8YS5sZW5ndGg7ZCsrKWlmKHRoaXMubW9kZWwuaXNFZGdlKHRoaXMubW9kZWwuZ2V0UGFyZW50KGFbZF0pKSlyZXR1cm4gbnVsbDtmb3IodmFyIGY9bC5hcHBseSh0aGlzLGFyZ3VtZW50cyksZz0hMCxkPTA7ZDxhLmxlbmd0aCYmZztkKyspZz1nJiZ0aGlzLmlzVGFibGVSb3coYVtkXSk7ZyYmKHRoaXMuaXNUYWJsZUNlbGwoZikmJihmPXRoaXMubW9kZWwuZ2V0UGFyZW50KGYpKSx0aGlzLmlzVGFibGVSb3coZikmJihmPXRoaXMubW9kZWwuZ2V0UGFyZW50KGYpKSx0aGlzLmlzVGFibGUoZil8fChmPW51bGwpKTtyZXR1cm4gZn07R3JhcGgucHJvdG90eXBlLmNsaWNrPWZ1bmN0aW9uKGEpe214R3JhcGgucHJvdG90eXBlLmNsaWNrLmNhbGwodGhpcyxhKTt0aGlzLmZpcnN0Q2xpY2tTdGF0ZT0KYS5nZXRTdGF0ZSgpO3RoaXMuZmlyc3RDbGlja1NvdXJjZT1hLmdldFNvdXJjZSgpfTtHcmFwaC5wcm90b3R5cGUuZGJsQ2xpY2s9ZnVuY3Rpb24oYSxiKXtpZih0aGlzLmlzRW5hYmxlZCgpKXt2YXIgZT1teFV0aWxzLmNvbnZlcnRQb2ludCh0aGlzLmNvbnRhaW5lcixteEV2ZW50LmdldENsaWVudFgoYSksbXhFdmVudC5nZXRDbGllbnRZKGEpKTtpZihudWxsIT1hJiYhdGhpcy5tb2RlbC5pc1ZlcnRleChiKSl7dmFyIGM9dGhpcy5tb2RlbC5pc0VkZ2UoYik/dGhpcy52aWV3LmdldFN0YXRlKGIpOm51bGwsZD1teEV2ZW50LmdldFNvdXJjZShhKTt0aGlzLmZpcnN0Q2xpY2tTdGF0ZSE9Y3x8dGhpcy5maXJzdENsaWNrU291cmNlIT1kfHxudWxsIT1jJiZudWxsIT1jLnRleHQmJm51bGwhPWMudGV4dC5ub2RlJiZudWxsIT1jLnRleHQuYm91bmRpbmdCb3gmJihteFV0aWxzLmNvbnRhaW5zKGMudGV4dC5ib3VuZGluZ0JveCxlLngsZS55KXx8bXhVdGlscy5pc0FuY2VzdG9yTm9kZShjLnRleHQubm9kZSwKbXhFdmVudC5nZXRTb3VyY2UoYSkpKXx8KG51bGwhPWN8fHRoaXMuaXNDZWxsTG9ja2VkKHRoaXMuZ2V0RGVmYXVsdFBhcmVudCgpKSkmJihudWxsPT1jfHx0aGlzLmlzQ2VsbExvY2tlZChjLmNlbGwpKXx8IShudWxsIT1jfHxteENsaWVudC5JU19WTUwmJmQ9PXRoaXMudmlldy5nZXRDYW52YXMoKXx8bXhDbGllbnQuSVNfU1ZHJiZkPT10aGlzLnZpZXcuZ2V0Q2FudmFzKCkub3duZXJTVkdFbGVtZW50KXx8KG51bGw9PWMmJihjPXRoaXMudmlldy5nZXRTdGF0ZSh0aGlzLmdldENlbGxBdChlLngsZS55KSkpLGI9dGhpcy5hZGRUZXh0KGUueCxlLnksYykpfW14R3JhcGgucHJvdG90eXBlLmRibENsaWNrLmNhbGwodGhpcyxhLGIpfX07R3JhcGgucHJvdG90eXBlLmdldEluc2VydFBvaW50PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRHcmlkU2l6ZSgpLGI9dGhpcy5jb250YWluZXIuc2Nyb2xsTGVmdC90aGlzLnZpZXcuc2NhbGUtdGhpcy52aWV3LnRyYW5zbGF0ZS54LGU9dGhpcy5jb250YWluZXIuc2Nyb2xsVG9wLwp0aGlzLnZpZXcuc2NhbGUtdGhpcy52aWV3LnRyYW5zbGF0ZS55O2lmKHRoaXMucGFnZVZpc2libGUpdmFyIGM9dGhpcy5nZXRQYWdlTGF5b3V0KCksZD10aGlzLmdldFBhZ2VTaXplKCksYj1NYXRoLm1heChiLGMueCpkLndpZHRoKSxlPU1hdGgubWF4KGUsYy55KmQuaGVpZ2h0KTtyZXR1cm4gbmV3IG14UG9pbnQodGhpcy5zbmFwKGIrYSksdGhpcy5zbmFwKGUrYSkpfTtHcmFwaC5wcm90b3R5cGUuZ2V0RnJlZUluc2VydFBvaW50PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy52aWV3LGI9dGhpcy5nZXRHcmFwaEJvdW5kcygpLGU9dGhpcy5nZXRJbnNlcnRQb2ludCgpLGM9dGhpcy5zbmFwKE1hdGgucm91bmQoTWF0aC5tYXgoZS54LGIueC9hLnNjYWxlLWEudHJhbnNsYXRlLngrKDA9PWIud2lkdGg/Mip0aGlzLmdyaWRTaXplOjApKSkpLGE9dGhpcy5zbmFwKE1hdGgucm91bmQoTWF0aC5tYXgoZS55LChiLnkrYi5oZWlnaHQpL2Euc2NhbGUtYS50cmFuc2xhdGUueSsyKnRoaXMuZ3JpZFNpemUpKSk7CnJldHVybiBuZXcgbXhQb2ludChjLGEpfTtHcmFwaC5wcm90b3R5cGUuZ2V0Q2VudGVySW5zZXJ0UG9pbnQ9ZnVuY3Rpb24oYSl7YT1udWxsIT1hP2E6bmV3IG14UmVjdGFuZ2xlO3JldHVybiBteFV0aWxzLmhhc1Njcm9sbGJhcnModGhpcy5jb250YWluZXIpP25ldyBteFBvaW50KHRoaXMuc25hcChNYXRoLnJvdW5kKCh0aGlzLmNvbnRhaW5lci5zY3JvbGxMZWZ0K3RoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoLzIpL3RoaXMudmlldy5zY2FsZS10aGlzLnZpZXcudHJhbnNsYXRlLngtYS53aWR0aC8yKSksdGhpcy5zbmFwKE1hdGgucm91bmQoKHRoaXMuY29udGFpbmVyLnNjcm9sbFRvcCt0aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQvMikvdGhpcy52aWV3LnNjYWxlLXRoaXMudmlldy50cmFuc2xhdGUueS1hLmhlaWdodC8yKSkpOm5ldyBteFBvaW50KHRoaXMuc25hcChNYXRoLnJvdW5kKHRoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoLzIvdGhpcy52aWV3LnNjYWxlLXRoaXMudmlldy50cmFuc2xhdGUueC0KYS53aWR0aC8yKSksdGhpcy5zbmFwKE1hdGgucm91bmQodGhpcy5jb250YWluZXIuY2xpZW50SGVpZ2h0LzIvdGhpcy52aWV3LnNjYWxlLXRoaXMudmlldy50cmFuc2xhdGUueS1hLmhlaWdodC8yKSkpfTtHcmFwaC5wcm90b3R5cGUuaXNNb3VzZUluc2VydFBvaW50PWZ1bmN0aW9uKCl7cmV0dXJuITF9O0dyYXBoLnByb3RvdHlwZS5hZGRUZXh0PWZ1bmN0aW9uKGEsYixlKXt2YXIgYz1uZXcgbXhDZWxsO2MudmFsdWU9IlRleHQiO2MuZ2VvbWV0cnk9bmV3IG14R2VvbWV0cnkoMCwwLDAsMCk7Yy52ZXJ0ZXg9ITA7aWYobnVsbCE9ZSYmdGhpcy5tb2RlbC5pc0VkZ2UoZS5jZWxsKSl7Yy5zdHlsZT0iZWRnZUxhYmVsO2h0bWw9MTthbGlnbj1jZW50ZXI7dmVydGljYWxBbGlnbj1taWRkbGU7cmVzaXphYmxlPTA7cG9pbnRzPVtdOyI7Yy5nZW9tZXRyeS5yZWxhdGl2ZT0hMDtjLmNvbm5lY3RhYmxlPSExO3ZhciBkPXRoaXMudmlldy5nZXRSZWxhdGl2ZVBvaW50KGUsYSxiKTtjLmdlb21ldHJ5Lng9Ck1hdGgucm91bmQoMUU0KmQueCkvMUU0O2MuZ2VvbWV0cnkueT1NYXRoLnJvdW5kKGQueSk7Yy5nZW9tZXRyeS5vZmZzZXQ9bmV3IG14UG9pbnQoMCwwKTt2YXIgZD10aGlzLnZpZXcuZ2V0UG9pbnQoZSxjLmdlb21ldHJ5KSxmPXRoaXMudmlldy5zY2FsZTtjLmdlb21ldHJ5Lm9mZnNldD1uZXcgbXhQb2ludChNYXRoLnJvdW5kKChhLWQueCkvZiksTWF0aC5yb3VuZCgoYi1kLnkpL2YpKX1lbHNlIGQ9dGhpcy52aWV3LnRyYW5zbGF0ZSxjLnN0eWxlPSJ0ZXh0O2h0bWw9MTthbGlnbj1jZW50ZXI7dmVydGljYWxBbGlnbj1taWRkbGU7cmVzaXphYmxlPTA7cG9pbnRzPVtdOyIsYy5nZW9tZXRyeS53aWR0aD00MCxjLmdlb21ldHJ5LmhlaWdodD0yMCxjLmdlb21ldHJ5Lng9TWF0aC5yb3VuZChhL3RoaXMudmlldy5zY2FsZSktZC54LShudWxsIT1lP2Uub3JpZ2luLng6MCksYy5nZW9tZXRyeS55PU1hdGgucm91bmQoYi90aGlzLnZpZXcuc2NhbGUpLWQueS0obnVsbCE9ZT9lLm9yaWdpbi55OgowKSxjLnN0eWxlKz0iYXV0b3NpemU9MTsiO3RoaXMuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXt0aGlzLmFkZENlbGxzKFtjXSxudWxsIT1lP2UuY2VsbDpudWxsKSx0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgidGV4dEluc2VydGVkIiwiY2VsbHMiLFtjXSkpLHRoaXMuYXV0b1NpemVDZWxsKGMpfWZpbmFsbHl7dGhpcy5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfXJldHVybiBjfTtHcmFwaC5wcm90b3R5cGUuYWRkQ2xpY2tIYW5kbGVyPWZ1bmN0aW9uKGEsYixlKXt2YXIgYz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3ZhciBhPXRoaXMuY29udGFpbmVyLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJhIik7aWYobnVsbCE9YSlmb3IodmFyIGU9MDtlPGEubGVuZ3RoO2UrKyl7dmFyIGM9dGhpcy5nZXRBYnNvbHV0ZVVybChhW2VdLmdldEF0dHJpYnV0ZSgiaHJlZiIpKTtudWxsIT1jJiYoYVtlXS5zZXRBdHRyaWJ1dGUoInJlbCIsdGhpcy5saW5rUmVsYXRpb24pLAphW2VdLnNldEF0dHJpYnV0ZSgiaHJlZiIsYyksbnVsbCE9YiYmbXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKGFbZV0sbnVsbCxudWxsLGIpKX19KTt0aGlzLm1vZGVsLmFkZExpc3RlbmVyKG14RXZlbnQuQ0hBTkdFLGMpO2MoKTt2YXIgZD10aGlzLmNvbnRhaW5lci5zdHlsZS5jdXJzb3IsZj10aGlzLmdldFRvbGVyYW5jZSgpLGc9dGhpcyxsPXtjdXJyZW50U3RhdGU6bnVsbCxjdXJyZW50TGluazpudWxsLGhpZ2hsaWdodDpudWxsIT1hJiYiIiE9YSYmYSE9bXhDb25zdGFudHMuTk9ORT9uZXcgbXhDZWxsSGlnaGxpZ2h0KGcsYSw0KTpudWxsLHN0YXJ0WDowLHN0YXJ0WTowLHNjcm9sbExlZnQ6MCxzY3JvbGxUb3A6MCx1cGRhdGVDdXJyZW50U3RhdGU6ZnVuY3Rpb24oYSl7dmFyIGI9YS5zb3VyY2VTdGF0ZTtpZihudWxsPT1ifHxudWxsPT1nLmdldExpbmtGb3JDZWxsKGIuY2VsbCkpYT1nLmdldENlbGxBdChhLmdldEdyYXBoWCgpLGEuZ2V0R3JhcGhZKCksbnVsbCxudWxsLG51bGwsCmZ1bmN0aW9uKGEsYixlKXtyZXR1cm4gbnVsbD09Zy5nZXRMaW5rRm9yQ2VsbChhLmNlbGwpfSksYj1nLnZpZXcuZ2V0U3RhdGUoYSk7YiE9dGhpcy5jdXJyZW50U3RhdGUmJihudWxsIT10aGlzLmN1cnJlbnRTdGF0ZSYmdGhpcy5jbGVhcigpLHRoaXMuY3VycmVudFN0YXRlPWIsbnVsbCE9dGhpcy5jdXJyZW50U3RhdGUmJnRoaXMuYWN0aXZhdGUodGhpcy5jdXJyZW50U3RhdGUpKX0sbW91c2VEb3duOmZ1bmN0aW9uKGEsYil7dGhpcy5zdGFydFg9Yi5nZXRHcmFwaFgoKTt0aGlzLnN0YXJ0WT1iLmdldEdyYXBoWSgpO3RoaXMuc2Nyb2xsTGVmdD1nLmNvbnRhaW5lci5zY3JvbGxMZWZ0O3RoaXMuc2Nyb2xsVG9wPWcuY29udGFpbmVyLnNjcm9sbFRvcDtudWxsPT10aGlzLmN1cnJlbnRMaW5rJiYiYXV0byI9PWcuY29udGFpbmVyLnN0eWxlLm92ZXJmbG93JiYoZy5jb250YWluZXIuc3R5bGUuY3Vyc29yPSJtb3ZlIik7dGhpcy51cGRhdGVDdXJyZW50U3RhdGUoYil9LG1vdXNlTW92ZTpmdW5jdGlvbihhLApiKXtpZihnLmlzTW91c2VEb3duKXtpZihudWxsIT10aGlzLmN1cnJlbnRMaW5rKXt2YXIgZT1NYXRoLmFicyh0aGlzLnN0YXJ0WC1iLmdldEdyYXBoWCgpKSxjPU1hdGguYWJzKHRoaXMuc3RhcnRZLWIuZ2V0R3JhcGhZKCkpOyhlPmZ8fGM+ZikmJnRoaXMuY2xlYXIoKX19ZWxzZXtmb3IoZT1iLmdldFNvdXJjZSgpO251bGwhPWUmJiJhIiE9ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOyllPWUucGFyZW50Tm9kZTtudWxsIT1lP3RoaXMuY2xlYXIoKToobnVsbCE9Zy50b29sdGlwSGFuZGxlciYmbnVsbCE9dGhpcy5jdXJyZW50TGluayYmbnVsbCE9dGhpcy5jdXJyZW50U3RhdGUmJmcudG9vbHRpcEhhbmRsZXIucmVzZXQoYiwhMCx0aGlzLmN1cnJlbnRTdGF0ZSksKG51bGw9PXRoaXMuY3VycmVudFN0YXRlfHxiLmdldFN0YXRlKCkhPXRoaXMuY3VycmVudFN0YXRlJiZudWxsIT1iLnNvdXJjZVN0YXRlfHwhZy5pbnRlcnNlY3RzKHRoaXMuY3VycmVudFN0YXRlLGIuZ2V0R3JhcGhYKCksCmIuZ2V0R3JhcGhZKCkpKSYmdGhpcy51cGRhdGVDdXJyZW50U3RhdGUoYikpfX0sbW91c2VVcDpmdW5jdGlvbihhLGMpe2Zvcih2YXIgZD1jLmdldFNvdXJjZSgpLGw9Yy5nZXRFdmVudCgpO251bGwhPWQmJiJhIiE9ZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOylkPWQucGFyZW50Tm9kZTtudWxsPT1kJiZNYXRoLmFicyh0aGlzLnNjcm9sbExlZnQtZy5jb250YWluZXIuc2Nyb2xsTGVmdCk8ZiYmTWF0aC5hYnModGhpcy5zY3JvbGxUb3AtZy5jb250YWluZXIuc2Nyb2xsVG9wKTxmJiYobnVsbD09Yy5zb3VyY2VTdGF0ZXx8IWMuaXNTb3VyY2UoYy5zb3VyY2VTdGF0ZS5jb250cm9sKSkmJigobXhFdmVudC5pc0xlZnRNb3VzZUJ1dHRvbihsKXx8bXhFdmVudC5pc01pZGRsZU1vdXNlQnV0dG9uKGwpKSYmIW14RXZlbnQuaXNQb3B1cFRyaWdnZXIobCl8fG14RXZlbnQuaXNUb3VjaEV2ZW50KGwpKSYmKG51bGwhPXRoaXMuY3VycmVudExpbms/KGQ9Zy5pc0JsYW5rTGluayh0aGlzLmN1cnJlbnRMaW5rKSwKImRhdGE6IiE9PXRoaXMuY3VycmVudExpbmsuc3Vic3RyaW5nKDAsNSkmJmR8fG51bGw9PWJ8fGIobCx0aGlzLmN1cnJlbnRMaW5rKSxteEV2ZW50LmlzQ29uc3VtZWQobCl8fChsPW14RXZlbnQuaXNNaWRkbGVNb3VzZUJ1dHRvbihsKT8iX2JsYW5rIjpkP2cubGlua1RhcmdldDoiX3RvcCIsZy5vcGVuTGluayh0aGlzLmN1cnJlbnRMaW5rLGwpLGMuY29uc3VtZSgpKSk6bnVsbCE9ZSYmIWMuaXNDb25zdW1lZCgpJiZNYXRoLmFicyh0aGlzLnNjcm9sbExlZnQtZy5jb250YWluZXIuc2Nyb2xsTGVmdCk8ZiYmTWF0aC5hYnModGhpcy5zY3JvbGxUb3AtZy5jb250YWluZXIuc2Nyb2xsVG9wKTxmJiZNYXRoLmFicyh0aGlzLnN0YXJ0WC1jLmdldEdyYXBoWCgpKTxmJiZNYXRoLmFicyh0aGlzLnN0YXJ0WS1jLmdldEdyYXBoWSgpKTxmJiZlKGMuZ2V0RXZlbnQoKSkpO3RoaXMuY2xlYXIoKX0sYWN0aXZhdGU6ZnVuY3Rpb24oYSl7dGhpcy5jdXJyZW50TGluaz1nLmdldEFic29sdXRlVXJsKGcuZ2V0TGlua0ZvckNlbGwoYS5jZWxsKSk7Cm51bGwhPXRoaXMuY3VycmVudExpbmsmJihnLmNvbnRhaW5lci5zdHlsZS5jdXJzb3I9InBvaW50ZXIiLG51bGwhPXRoaXMuaGlnaGxpZ2h0JiZ0aGlzLmhpZ2hsaWdodC5oaWdobGlnaHQoYSkpfSxjbGVhcjpmdW5jdGlvbigpe251bGwhPWcuY29udGFpbmVyJiYoZy5jb250YWluZXIuc3R5bGUuY3Vyc29yPWQpO3RoaXMuY3VycmVudExpbms9dGhpcy5jdXJyZW50U3RhdGU9bnVsbDtudWxsIT10aGlzLmhpZ2hsaWdodCYmdGhpcy5oaWdobGlnaHQuaGlkZSgpO251bGwhPWcudG9vbHRpcEhhbmRsZXImJmcudG9vbHRpcEhhbmRsZXIuaGlkZSgpfX07Zy5jbGljaz1mdW5jdGlvbihhKXt9O2cuYWRkTW91c2VMaXN0ZW5lcihsKTtteEV2ZW50LmFkZExpc3RlbmVyKGRvY3VtZW50LCJtb3VzZWxlYXZlIixmdW5jdGlvbihhKXtsLmNsZWFyKCl9KX07R3JhcGgucHJvdG90eXBlLmR1cGxpY2F0ZUNlbGxzPWZ1bmN0aW9uKGEsYil7YT1udWxsIT1hP2E6dGhpcy5nZXRTZWxlY3Rpb25DZWxscygpOwpiPW51bGwhPWI/YjohMDtmb3IodmFyIGU9MDtlPGEubGVuZ3RoO2UrKyl0aGlzLmlzVGFibGVDZWxsKGFbZV0pJiYoYVtlXT10aGlzLm1vZGVsLmdldFBhcmVudChhW2VdKSk7YT10aGlzLm1vZGVsLmdldFRvcG1vc3RDZWxscyhhKTt2YXIgYz10aGlzLmdldE1vZGVsKCksZD10aGlzLmdyaWRTaXplLGY9W107Yy5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGc9dGhpcy5jbG9uZUNlbGxzKGEsITEsbnVsbCwhMCksZT0wO2U8YS5sZW5ndGg7ZSsrKXt2YXIgbD1jLmdldFBhcmVudChhW2VdKSxwPXRoaXMubW92ZUNlbGxzKFtnW2VdXSxkLGQsITEpWzBdO2YucHVzaChwKTtpZihiKWMuYWRkKGwsZ1tlXSk7ZWxzZXt2YXIgdT1sLmdldEluZGV4KGFbZV0pO2MuYWRkKGwsZ1tlXSx1KzEpfWlmKHRoaXMuaXNUYWJsZShsKSl7dmFyIG49dGhpcy5nZXRDZWxsR2VvbWV0cnkoZ1tlXSksdD10aGlzLmdldENlbGxHZW9tZXRyeShsKTtudWxsIT1uJiZudWxsIT10JiYodD10LmNsb25lKCksdC5oZWlnaHQrPQpuLmhlaWdodCxjLnNldEdlb21ldHJ5KGwsdCkpfX19ZmluYWxseXtjLmVuZFVwZGF0ZSgpfXJldHVybiBmfTtHcmFwaC5wcm90b3R5cGUuaW5zZXJ0SW1hZ2U9ZnVuY3Rpb24oYSxiLGUpe2lmKG51bGwhPWEmJm51bGwhPXRoaXMuY2VsbEVkaXRvci50ZXh0YXJlYSl7Zm9yKHZhciBjPXRoaXMuY2VsbEVkaXRvci50ZXh0YXJlYS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiaW1nIiksZD1bXSxmPTA7ZjxjLmxlbmd0aDtmKyspZC5wdXNoKGNbZl0pO2RvY3VtZW50LmV4ZWNDb21tYW5kKCJpbnNlcnRpbWFnZSIsITEsYSk7YT10aGlzLmNlbGxFZGl0b3IudGV4dGFyZWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImltZyIpO2lmKGEubGVuZ3RoPT1kLmxlbmd0aCsxKWZvcihmPWEubGVuZ3RoLTE7MDw9ZjtmLS0paWYoMD09Znx8YVtmXSE9ZFtmLTFdKXthW2ZdLnNldEF0dHJpYnV0ZSgid2lkdGgiLGIpO2FbZl0uc2V0QXR0cmlidXRlKCJoZWlnaHQiLGUpO2JyZWFrfX19O0dyYXBoLnByb3RvdHlwZS5pbnNlcnRMaW5rPQpmdW5jdGlvbihhKXtpZihudWxsIT10aGlzLmNlbGxFZGl0b3IudGV4dGFyZWEpaWYoMD09YS5sZW5ndGgpZG9jdW1lbnQuZXhlY0NvbW1hbmQoInVubGluayIsITEpO2Vsc2UgaWYobXhDbGllbnQuSVNfRkYpe2Zvcih2YXIgYj10aGlzLmNlbGxFZGl0b3IudGV4dGFyZWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImEiKSxlPVtdLGM9MDtjPGIubGVuZ3RoO2MrKyllLnB1c2goYltjXSk7ZG9jdW1lbnQuZXhlY0NvbW1hbmQoImNyZWF0ZWxpbmsiLCExLG14VXRpbHMudHJpbShhKSk7Yj10aGlzLmNlbGxFZGl0b3IudGV4dGFyZWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImEiKTtpZihiLmxlbmd0aD09ZS5sZW5ndGgrMSlmb3IoYz1iLmxlbmd0aC0xOzA8PWM7Yy0tKWlmKGJbY10hPWVbYy0xXSl7Zm9yKGI9YltjXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYSIpOzA8Yi5sZW5ndGg7KXtmb3IoZT1iWzBdLnBhcmVudE5vZGU7bnVsbCE9YlswXS5maXJzdENoaWxkOyllLmluc2VydEJlZm9yZShiWzBdLmZpcnN0Q2hpbGQsCmJbMF0pO2UucmVtb3ZlQ2hpbGQoYlswXSl9YnJlYWt9fWVsc2UgZG9jdW1lbnQuZXhlY0NvbW1hbmQoImNyZWF0ZWxpbmsiLCExLG14VXRpbHMudHJpbShhKSl9O0dyYXBoLnByb3RvdHlwZS5pc0NlbGxSZXNpemFibGU9ZnVuY3Rpb24oYSl7dmFyIGI9bXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsUmVzaXphYmxlLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxlPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShhKTtyZXR1cm4hdGhpcy5pc1RhYmxlQ2VsbChhKSYmIXRoaXMuaXNUYWJsZVJvdyhhKSYmKGJ8fCIwIiE9bXhVdGlscy5nZXRWYWx1ZShlLG14Q29uc3RhbnRzLlNUWUxFX1JFU0laQUJMRSwiMSIpJiYid3JhcCI9PWVbbXhDb25zdGFudHMuU1RZTEVfV0hJVEVfU1BBQ0VdKX07R3JhcGgucHJvdG90eXBlLmRpc3RyaWJ1dGVDZWxscz1mdW5jdGlvbihhLGIpe251bGw9PWImJihiPXRoaXMuZ2V0U2VsZWN0aW9uQ2VsbHMoKSk7aWYobnVsbCE9YiYmMTxiLmxlbmd0aCl7Zm9yKHZhciBlPQpbXSxjPW51bGwsZD1udWxsLGY9MDtmPGIubGVuZ3RoO2YrKylpZih0aGlzLmdldE1vZGVsKCkuaXNWZXJ0ZXgoYltmXSkpe3ZhciBnPXRoaXMudmlldy5nZXRTdGF0ZShiW2ZdKTtpZihudWxsIT1nKXt2YXIgbD1hP2cuZ2V0Q2VudGVyWCgpOmcuZ2V0Q2VudGVyWSgpLGM9bnVsbCE9Yz9NYXRoLm1heChjLGwpOmwsZD1udWxsIT1kP01hdGgubWluKGQsbCk6bDtlLnB1c2goZyl9fWlmKDI8ZS5sZW5ndGgpe2Uuc29ydChmdW5jdGlvbihiLGUpe3JldHVybiBhP2IueC1lLng6Yi55LWUueX0pO2c9dGhpcy52aWV3LnRyYW5zbGF0ZTtsPXRoaXMudmlldy5zY2FsZTtkPWQvbC0oYT9nLng6Zy55KTtjPWMvbC0oYT9nLng6Zy55KTt0aGlzLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBwPShjLWQpLyhlLmxlbmd0aC0xKSxjPWQsZj0xO2Y8ZS5sZW5ndGgtMTtmKyspe3ZhciB1PXRoaXMudmlldy5nZXRTdGF0ZSh0aGlzLm1vZGVsLmdldFBhcmVudChlW2ZdLmNlbGwpKSwKbj10aGlzLmdldENlbGxHZW9tZXRyeShlW2ZdLmNlbGwpLGM9YytwO251bGwhPW4mJm51bGwhPXUmJihuPW4uY2xvbmUoKSxhP24ueD1NYXRoLnJvdW5kKGMtbi53aWR0aC8yKS11Lm9yaWdpbi54Om4ueT1NYXRoLnJvdW5kKGMtbi5oZWlnaHQvMiktdS5vcmlnaW4ueSx0aGlzLmdldE1vZGVsKCkuc2V0R2VvbWV0cnkoZVtmXS5jZWxsLG4pKX19ZmluYWxseXt0aGlzLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9fX1yZXR1cm4gYn07R3JhcGgucHJvdG90eXBlLmlzQ2xvbmVFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gbXhDbGllbnQuSVNfTUFDJiZteEV2ZW50LmlzTWV0YURvd24oYSl8fG14RXZlbnQuaXNDb250cm9sRG93bihhKX07R3JhcGgucHJvdG90eXBlLmNyZWF0ZVN2Z0ltYWdlRXhwb3J0PWZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14SW1hZ2VFeHBvcnQ7YS5nZXRMaW5rRm9yQ2VsbFN0YXRlPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuZ2V0TGlua0ZvckNlbGwoYS5jZWxsKX0pOwpyZXR1cm4gYX07R3JhcGgucHJvdG90eXBlLmdldFN2Zz1mdW5jdGlvbihhLGIsZSxjLGQsZixnLGwscCx1KXt2YXIgbj10aGlzLnVzZUNzc1RyYW5zZm9ybXM7biYmKHRoaXMudXNlQ3NzVHJhbnNmb3Jtcz0hMSx0aGlzLnZpZXcucmV2YWxpZGF0ZSgpLHRoaXMuc2l6ZURpZENoYW5nZSgpKTt0cnl7Yj1udWxsIT1iP2I6MTtlPW51bGwhPWU/ZTowO2Q9bnVsbCE9ZD9kOiEwO2Y9bnVsbCE9Zj9mOiEwO2c9bnVsbCE9Zz9nOiEwO3ZhciB0PWZ8fGM/dGhpcy5nZXRHcmFwaEJvdW5kcygpOnRoaXMuZ2V0Qm91bmRpbmdCb3godGhpcy5nZXRTZWxlY3Rpb25DZWxscygpKTtpZihudWxsPT10KXRocm93IEVycm9yKG14UmVzb3VyY2VzLmdldCgiZHJhd2luZ0VtcHR5IikpO3ZhciBCPXRoaXMudmlldy5zY2FsZSxrPW14VXRpbHMuY3JlYXRlWG1sRG9jdW1lbnQoKSxtPW51bGwhPWsuY3JlYXRlRWxlbWVudE5TP2suY3JlYXRlRWxlbWVudE5TKG14Q29uc3RhbnRzLk5TX1NWRywic3ZnIik6ay5jcmVhdGVFbGVtZW50KCJzdmciKTsKbnVsbCE9YSYmKG51bGwhPW0uc3R5bGU/bS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9YTptLnNldEF0dHJpYnV0ZSgic3R5bGUiLCJiYWNrZ3JvdW5kLWNvbG9yOiIrYSkpO251bGw9PWsuY3JlYXRlRWxlbWVudE5TPyhtLnNldEF0dHJpYnV0ZSgieG1sbnMiLG14Q29uc3RhbnRzLk5TX1NWRyksbS5zZXRBdHRyaWJ1dGUoInhtbG5zOnhsaW5rIixteENvbnN0YW50cy5OU19YTElOSykpOm0uc2V0QXR0cmlidXRlTlMoImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvIiwieG1sbnM6eGxpbmsiLG14Q29uc3RhbnRzLk5TX1hMSU5LKTthPWIvQjt2YXIgeT1NYXRoLm1heCgxLE1hdGguY2VpbCh0LndpZHRoKmEpKzIqZSkrKHU/NTowKSx2PU1hdGgubWF4KDEsTWF0aC5jZWlsKHQuaGVpZ2h0KmEpKzIqZSkrKHU/NTowKTttLnNldEF0dHJpYnV0ZSgidmVyc2lvbiIsIjEuMSIpO20uc2V0QXR0cmlidXRlKCJ3aWR0aCIseSsicHgiKTttLnNldEF0dHJpYnV0ZSgiaGVpZ2h0Iix2KyJweCIpOwptLnNldEF0dHJpYnV0ZSgidmlld0JveCIsKGQ/Ii0wLjUgLTAuNSI6IjAgMCIpKyIgIit5KyIgIit2KTtrLmFwcGVuZENoaWxkKG0pO3ZhciBLPW51bGwhPWsuY3JlYXRlRWxlbWVudE5TP2suY3JlYXRlRWxlbWVudE5TKG14Q29uc3RhbnRzLk5TX1NWRywiZyIpOmsuY3JlYXRlRWxlbWVudCgiZyIpO20uYXBwZW5kQ2hpbGQoSyk7dmFyIHg9dGhpcy5jcmVhdGVTdmdDYW52YXMoSyk7eC5mb09mZnNldD1kPy0uNTowO3gudGV4dE9mZnNldD1kPy0uNTowO3guaW1hZ2VPZmZzZXQ9ZD8tLjU6MDt4LnRyYW5zbGF0ZShNYXRoLmZsb29yKChlL2ItdC54KS9CKSxNYXRoLmZsb29yKChlL2ItdC55KS9CKSk7dmFyIHE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2IiksVD14LmdldEFsdGVybmF0ZVRleHQ7eC5nZXRBbHRlcm5hdGVUZXh0PWZ1bmN0aW9uKGEsYixlLGMsZCxmLGcsbCxwLHUsYmEsbix0KXtpZihudWxsIT1mJiYwPHRoaXMuc3RhdGUuZm9udFNpemUpdHJ5e214VXRpbHMuaXNOb2RlKGYpPwpmPWYuaW5uZXJUZXh0OihxLmlubmVySFRNTD1mLGY9bXhVdGlscy5leHRyYWN0VGV4dFdpdGhXaGl0ZXNwYWNlKHEuY2hpbGROb2RlcykpO2Zvcih2YXIgTWE9TWF0aC5jZWlsKDIqYy90aGlzLnN0YXRlLmZvbnRTaXplKSxCPVtdLGs9MCxtPTA7KDA9PU1hfHxrPE1hKSYmbTxmLmxlbmd0aDspe3ZhciB5PWYuY2hhckNvZGVBdChtKTtpZigxMD09eXx8MTM9PXkpe2lmKDA8aylicmVha31lbHNlIEIucHVzaChmLmNoYXJBdChtKSksMjU1PnkmJmsrKzttKyt9Qi5sZW5ndGg8Zi5sZW5ndGgmJjE8Zi5sZW5ndGgtQi5sZW5ndGgmJihmPW14VXRpbHMudHJpbShCLmpvaW4oIiIpKSsiLi4uIik7cmV0dXJuIGZ9Y2F0Y2goVWEpe3JldHVybiBULmFwcGx5KHRoaXMsYXJndW1lbnRzKX1lbHNlIHJldHVybiBULmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dmFyIHo9dGhpcy5iYWNrZ3JvdW5kSW1hZ2U7aWYobnVsbCE9eil7Yj1CL2I7dmFyIE09dGhpcy52aWV3LnRyYW5zbGF0ZSxJPW5ldyBteFJlY3RhbmdsZShNLngqCmIsTS55KmIsei53aWR0aCpiLHouaGVpZ2h0KmIpO214VXRpbHMuaW50ZXJzZWN0cyh0LEkpJiZ4LmltYWdlKE0ueCxNLnksei53aWR0aCx6LmhlaWdodCx6LnNyYywhMCl9eC5zY2FsZShhKTt4LnRleHRFbmFibGVkPWc7bD1udWxsIT1sP2w6dGhpcy5jcmVhdGVTdmdJbWFnZUV4cG9ydCgpO3ZhciBQPWwuZHJhd0NlbGxTdGF0ZSxFPWwuZ2V0TGlua0ZvckNlbGxTdGF0ZTtsLmdldExpbmtGb3JDZWxsU3RhdGU9ZnVuY3Rpb24oYSxiKXt2YXIgZT1FLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gbnVsbD09ZXx8YS52aWV3LmdyYXBoLmlzQ3VzdG9tTGluayhlKT9udWxsOmV9O2wuZHJhd0NlbGxTdGF0ZT1mdW5jdGlvbihhLGIpe2Zvcih2YXIgZT1hLnZpZXcuZ3JhcGgsYz1lLmlzQ2VsbFNlbGVjdGVkKGEuY2VsbCksZD1lLm1vZGVsLmdldFBhcmVudChhLmNlbGwpOyFmJiYhYyYmbnVsbCE9ZDspYz1lLmlzQ2VsbFNlbGVjdGVkKGQpLGQ9ZS5tb2RlbC5nZXRQYXJlbnQoZCk7KGZ8fApjKSYmUC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2wuZHJhd1N0YXRlKHRoaXMuZ2V0VmlldygpLmdldFN0YXRlKHRoaXMubW9kZWwucm9vdCkseCk7dGhpcy51cGRhdGVTdmdMaW5rcyhtLHAsITApO3RoaXMuYWRkRm9yZWlnbk9iamVjdFdhcm5pbmcoeCxtKTtyZXR1cm4gbX1maW5hbGx5e24mJih0aGlzLnVzZUNzc1RyYW5zZm9ybXM9ITAsdGhpcy52aWV3LnJldmFsaWRhdGUoKSx0aGlzLnNpemVEaWRDaGFuZ2UoKSl9fTtHcmFwaC5wcm90b3R5cGUuYWRkRm9yZWlnbk9iamVjdFdhcm5pbmc9ZnVuY3Rpb24oYSxiKXtpZigwPGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImZvcmVpZ25PYmplY3QiKS5sZW5ndGgpe3ZhciBlPWEuY3JlYXRlRWxlbWVudCgic3dpdGNoIiksYz1hLmNyZWF0ZUVsZW1lbnQoImciKTtjLnNldEF0dHJpYnV0ZSgicmVxdWlyZWRGZWF0dXJlcyIsImh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjRXh0ZW5zaWJpbGl0eSIpO3ZhciBkPWEuY3JlYXRlRWxlbWVudCgiYSIpOwpkLnNldEF0dHJpYnV0ZSgidHJhbnNmb3JtIiwidHJhbnNsYXRlKDAsLTUpIik7bnVsbD09ZC5zZXRBdHRyaWJ1dGVOU3x8Yi5vd25lckRvY3VtZW50IT1kb2N1bWVudCYmbnVsbD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlPyhkLnNldEF0dHJpYnV0ZSgieGxpbms6aHJlZiIsR3JhcGguZm9yZWlnbk9iamVjdFdhcm5pbmdMaW5rKSxkLnNldEF0dHJpYnV0ZSgidGFyZ2V0IiwiX2JsYW5rIikpOihkLnNldEF0dHJpYnV0ZU5TKG14Q29uc3RhbnRzLk5TX1hMSU5LLCJ4bGluazpocmVmIixHcmFwaC5mb3JlaWduT2JqZWN0V2FybmluZ0xpbmspLGQuc2V0QXR0cmlidXRlTlMobXhDb25zdGFudHMuTlNfWExJTkssInRhcmdldCIsIl9ibGFuayIpKTt2YXIgZj1hLmNyZWF0ZUVsZW1lbnQoInRleHQiKTtmLnNldEF0dHJpYnV0ZSgidGV4dC1hbmNob3IiLCJtaWRkbGUiKTtmLnNldEF0dHJpYnV0ZSgiZm9udC1zaXplIiwiMTBweCIpO2Yuc2V0QXR0cmlidXRlKCJ4IiwiNTAlIik7Zi5zZXRBdHRyaWJ1dGUoInkiLAoiMTAwJSIpO214VXRpbHMud3JpdGUoZixHcmFwaC5mb3JlaWduT2JqZWN0V2FybmluZ1RleHQpO2UuYXBwZW5kQ2hpbGQoYyk7ZC5hcHBlbmRDaGlsZChmKTtlLmFwcGVuZENoaWxkKGQpO2IuYXBwZW5kQ2hpbGQoZSl9fTtHcmFwaC5wcm90b3R5cGUudXBkYXRlU3ZnTGlua3M9ZnVuY3Rpb24oYSxiLGUpe2E9YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYSIpO2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKXt2YXIgZD1hW2NdLmdldEF0dHJpYnV0ZSgiaHJlZiIpO251bGw9PWQmJihkPWFbY10uZ2V0QXR0cmlidXRlKCJ4bGluazpocmVmIikpO251bGwhPWQmJihudWxsIT1iJiYvXmh0dHBzPzpcL1wvLy50ZXN0KGQpP2FbY10uc2V0QXR0cmlidXRlKCJ0YXJnZXQiLGIpOmUmJnRoaXMuaXNDdXN0b21MaW5rKGQpJiZhW2NdLnNldEF0dHJpYnV0ZSgiaHJlZiIsImphdmFzY3JpcHQ6dm9pZCgwKTsiKSl9fTtHcmFwaC5wcm90b3R5cGUuY3JlYXRlU3ZnQ2FudmFzPWZ1bmN0aW9uKGEpe2E9Cm5ldyBteFN2Z0NhbnZhczJEKGEpO2EucG9pbnRlckV2ZW50cz0hMDtyZXR1cm4gYX07R3JhcGgucHJvdG90eXBlLmdldFNlbGVjdGVkRWxlbWVudD1mdW5jdGlvbigpe3ZhciBhPW51bGw7aWYod2luZG93LmdldFNlbGVjdGlvbil7dmFyIGI9d2luZG93LmdldFNlbGVjdGlvbigpO2IuZ2V0UmFuZ2VBdCYmYi5yYW5nZUNvdW50JiYoYT1iLmdldFJhbmdlQXQoMCkuY29tbW9uQW5jZXN0b3JDb250YWluZXIpfWVsc2UgZG9jdW1lbnQuc2VsZWN0aW9uJiYoYT1kb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS5wYXJlbnRFbGVtZW50KCkpO3JldHVybiBhfTtHcmFwaC5wcm90b3R5cGUuZ2V0UGFyZW50QnlOYW1lPWZ1bmN0aW9uKGEsYixlKXtmb3IoO251bGwhPWEmJmEubm9kZU5hbWUhPWI7KXtpZihhPT1lKXJldHVybiBudWxsO2E9YS5wYXJlbnROb2RlfXJldHVybiBhfTtHcmFwaC5wcm90b3R5cGUuZ2V0UGFyZW50QnlOYW1lcz1mdW5jdGlvbihhLGIsZSl7Zm9yKDtudWxsIT0KYSYmISgwPD1teFV0aWxzLmluZGV4T2YoYixhLm5vZGVOYW1lKSk7KXtpZihhPT1lKXJldHVybiBudWxsO2E9YS5wYXJlbnROb2RlfXJldHVybiBhfTtHcmFwaC5wcm90b3R5cGUuc2VsZWN0Tm9kZT1mdW5jdGlvbihhKXt2YXIgYj1udWxsO2lmKHdpbmRvdy5nZXRTZWxlY3Rpb24pe2lmKGI9d2luZG93LmdldFNlbGVjdGlvbigpLGIuZ2V0UmFuZ2VBdCYmYi5yYW5nZUNvdW50KXt2YXIgZT1kb2N1bWVudC5jcmVhdGVSYW5nZSgpO2Uuc2VsZWN0Tm9kZShhKTtiLnJlbW92ZUFsbFJhbmdlcygpO2IuYWRkUmFuZ2UoZSl9fWVsc2UoYj1kb2N1bWVudC5zZWxlY3Rpb24pJiYiQ29udHJvbCIhPWIudHlwZSYmKGE9Yi5jcmVhdGVSYW5nZSgpLGEuY29sbGFwc2UoITApLGU9Yi5jcmVhdGVSYW5nZSgpLGUuc2V0RW5kUG9pbnQoIlN0YXJ0VG9TdGFydCIsYSksZS5zZWxlY3QoKSl9O0dyYXBoLnByb3RvdHlwZS5kZWxldGVDZWxscz1mdW5jdGlvbihhLGIpe3ZhciBlPW51bGw7aWYobnVsbCE9CmEmJjA8YS5sZW5ndGgpe3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBkPXRoaXMubW9kZWwuZ2V0UGFyZW50KGFbY10pO2lmKHRoaXMuaXNUYWJsZShkKSl7dmFyIGY9dGhpcy5nZXRDZWxsR2VvbWV0cnkoYVtjXSksZz10aGlzLmdldENlbGxHZW9tZXRyeShkKTtudWxsIT1mJiZudWxsIT1nJiYoZz1nLmNsb25lKCksZy5oZWlnaHQtPWYuaGVpZ2h0LHRoaXMubW9kZWwuc2V0R2VvbWV0cnkoZCxnKSl9fXZhciBsPXRoaXMuc2VsZWN0UGFyZW50QWZ0ZXJEZWxldGU/dGhpcy5tb2RlbC5nZXRQYXJlbnRzKGEpOm51bGw7dGhpcy5yZW1vdmVDZWxscyhhLGIpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX1pZihudWxsIT1sKWZvcihlPVtdLGM9MDtjPGwubGVuZ3RoO2MrKyl0aGlzLm1vZGVsLmNvbnRhaW5zKGxbY10pJiYodGhpcy5tb2RlbC5pc1ZlcnRleChsW2NdKXx8dGhpcy5tb2RlbC5pc0VkZ2UobFtjXSkpJiYKZS5wdXNoKGxbY10pfXJldHVybiBlfTtHcmFwaC5wcm90b3R5cGUuaW5zZXJ0VGFibGVDb2x1bW49ZnVuY3Rpb24oYSxiKXt2YXIgZT10aGlzLmdldE1vZGVsKCk7ZS5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgYz1hLGQ9MDtpZih0aGlzLmlzVGFibGVDZWxsKGEpKXZhciBmPWUuZ2V0UGFyZW50KGEpLGM9ZS5nZXRQYXJlbnQoZiksZD1teFV0aWxzLmluZGV4T2YoZS5nZXRDaGlsZENlbGxzKGYsITApLGEpO2Vsc2UgdGhpcy5pc1RhYmxlUm93KGEpP2M9ZS5nZXRQYXJlbnQoYSk6YT1lLmdldENoaWxkQ2VsbHMoYywhMClbMF0sYnx8KGQ9ZS5nZXRDaGlsZENlbGxzKGEsITApLmxlbmd0aC0xKTtmb3IodmFyIGc9ZS5nZXRDaGlsZENlbGxzKGMsITApLGw9R3JhcGgubWluVGFibGVDb2x1bW5XaWR0aCxmPTA7ZjxnLmxlbmd0aDtmKyspe3ZhciBwPWUuZ2V0Q2hpbGRDZWxscyhnW2ZdLCEwKVtkXSx1PWUuY2xvbmVDZWxsKHAsITEpLG49dGhpcy5nZXRDZWxsR2VvbWV0cnkodSk7dS52YWx1ZT0KbnVsbDtpZihudWxsIT1uKXt2YXIgbD1uLndpZHRoLHQ9dGhpcy5nZXRDZWxsR2VvbWV0cnkoZ1tmXSk7bnVsbCE9dCYmKG4uaGVpZ2h0PXQuaGVpZ2h0KX1lLmFkZChnW2ZdLHUsZCsoYj8wOjEpKX12YXIgQj10aGlzLmdldENlbGxHZW9tZXRyeShjKTtudWxsIT1CJiYoQj1CLmNsb25lKCksQi53aWR0aCs9bCxlLnNldEdlb21ldHJ5KGMsQikpfWZpbmFsbHl7ZS5lbmRVcGRhdGUoKX19O0dyYXBoLnByb3RvdHlwZS5pbnNlcnRUYWJsZVJvdz1mdW5jdGlvbihhLGIpe3ZhciBlPXRoaXMuZ2V0TW9kZWwoKTtlLmJlZ2luVXBkYXRlKCk7dHJ5e3ZhciBjPWEsZD1hO2lmKHRoaXMuaXNUYWJsZUNlbGwoYSkpZD1lLmdldFBhcmVudChhKSxjPWUuZ2V0UGFyZW50KGQpO2Vsc2UgaWYodGhpcy5pc1RhYmxlUm93KGEpKWM9ZS5nZXRQYXJlbnQoYSk7ZWxzZSB2YXIgZj1lLmdldENoaWxkQ2VsbHMoYywhMCksZD1mW2I/MDpmLmxlbmd0aC0xXTt2YXIgZz1lLmdldENoaWxkQ2VsbHMoZCwhMCksCmw9Yy5nZXRJbmRleChkKSxkPWUuY2xvbmVDZWxsKGQsITEpO2QudmFsdWU9bnVsbDt2YXIgcD10aGlzLmdldENlbGxHZW9tZXRyeShkKTtpZihudWxsIT1wKXtmb3IoZj0wO2Y8Zy5sZW5ndGg7ZisrKXthPWUuY2xvbmVDZWxsKGdbZl0sITEpO2QuaW5zZXJ0KGEpO2EudmFsdWU9bnVsbDt2YXIgdT10aGlzLmdldENlbGxHZW9tZXRyeShhKTtudWxsIT11JiYodS5oZWlnaHQ9cC5oZWlnaHQpfWUuYWRkKGMsZCxsKyhiPzA6MSkpO3ZhciBuPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KGMpO251bGwhPW4mJihuPW4uY2xvbmUoKSxuLmhlaWdodCs9cC5oZWlnaHQsZS5zZXRHZW9tZXRyeShjLG4pKX19ZmluYWxseXtlLmVuZFVwZGF0ZSgpfX07R3JhcGgucHJvdG90eXBlLmRlbGV0ZVRhYmxlQ29sdW1uPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ2V0TW9kZWwoKTtiLmJlZ2luVXBkYXRlKCk7dHJ5e3ZhciBlPWEsYz1hO3RoaXMuaXNUYWJsZUNlbGwoYSkmJihjPWIuZ2V0UGFyZW50KGEpKTt0aGlzLmlzVGFibGVSb3coYykmJgooZT1iLmdldFBhcmVudChjKSk7dmFyIGQ9Yi5nZXRDaGlsZENlbGxzKGUsITApO2lmKDA9PWQubGVuZ3RoKWIucmVtb3ZlKGUpO2Vsc2V7dGhpcy5pc1RhYmxlUm93KGMpfHwoYz1kWzBdKTt2YXIgZj1iLmdldENoaWxkQ2VsbHMoYywhMCk7aWYoMT49Zi5sZW5ndGgpYi5yZW1vdmUoZSk7ZWxzZXt2YXIgZz1mLmxlbmd0aC0xO3RoaXMuaXNUYWJsZUNlbGwoYSkmJihnPW14VXRpbHMuaW5kZXhPZihmLGEpKTtmb3IoYz1hPTA7YzxkLmxlbmd0aDtjKyspe3ZhciBsPWIuZ2V0Q2hpbGRDZWxscyhkW2NdLCEwKVtnXTtiLnJlbW92ZShsKTt2YXIgcD10aGlzLmdldENlbGxHZW9tZXRyeShsKTtudWxsIT1wJiYoYT1NYXRoLm1heChhLHAud2lkdGgpKX12YXIgdT10aGlzLmdldENlbGxHZW9tZXRyeShlKTtudWxsIT11JiYodT11LmNsb25lKCksdS53aWR0aC09YSxiLnNldEdlb21ldHJ5KGUsdSkpfX19ZmluYWxseXtiLmVuZFVwZGF0ZSgpfX07R3JhcGgucHJvdG90eXBlLmRlbGV0ZVRhYmxlUm93PQpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmdldE1vZGVsKCk7Yi5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgZT1hLGM9YTt0aGlzLmlzVGFibGVDZWxsKGEpJiYoYT1jPWIuZ2V0UGFyZW50KGEpKTt0aGlzLmlzVGFibGVSb3coYSkmJihlPWIuZ2V0UGFyZW50KGMpKTt2YXIgZD1iLmdldENoaWxkQ2VsbHMoZSwhMCk7aWYoMT49ZC5sZW5ndGgpYi5yZW1vdmUoZSk7ZWxzZXt0aGlzLmlzVGFibGVSb3coYyl8fChjPWRbZC5sZW5ndGgtMV0pO2IucmVtb3ZlKGMpO2E9MDt2YXIgZj10aGlzLmdldENlbGxHZW9tZXRyeShjKTtudWxsIT1mJiYoYT1mLmhlaWdodCk7dmFyIGc9dGhpcy5nZXRDZWxsR2VvbWV0cnkoZSk7bnVsbCE9ZyYmKGc9Zy5jbG9uZSgpLGcuaGVpZ2h0LT1hLGIuc2V0R2VvbWV0cnkoZSxnKSl9fWZpbmFsbHl7Yi5lbmRVcGRhdGUoKX19O0dyYXBoLnByb3RvdHlwZS5pbnNlcnRSb3c9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGU9YS50Qm9kaWVzWzBdLGM9ZS5yb3dzWzBdLmNlbGxzLApkPTAsZj0wO2Y8Yy5sZW5ndGg7ZisrKXZhciBnPWNbZl0uZ2V0QXR0cmlidXRlKCJjb2xzcGFuIiksZD1kKyhudWxsIT1nP3BhcnNlSW50KGcpOjEpO2U9ZS5pbnNlcnRSb3coYik7Zm9yKGY9MDtmPGQ7ZisrKW14VXRpbHMuYnIoZS5pbnNlcnRDZWxsKC0xKSk7cmV0dXJuIGUuY2VsbHNbMF19O0dyYXBoLnByb3RvdHlwZS5kZWxldGVSb3c9ZnVuY3Rpb24oYSxiKXthLnRCb2RpZXNbMF0uZGVsZXRlUm93KGIpfTtHcmFwaC5wcm90b3R5cGUuaW5zZXJ0Q29sdW1uPWZ1bmN0aW9uKGEsYil7dmFyIGU9YS50SGVhZDtpZihudWxsIT1lKWZvcih2YXIgYz0wO2M8ZS5yb3dzLmxlbmd0aDtjKyspe3ZhciBkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRoIik7ZS5yb3dzW2NdLmFwcGVuZENoaWxkKGQpO214VXRpbHMuYnIoZCl9ZT1hLnRCb2RpZXNbMF07Zm9yKGM9MDtjPGUucm93cy5sZW5ndGg7YysrKWQ9ZS5yb3dzW2NdLmluc2VydENlbGwoYiksbXhVdGlscy5icihkKTtyZXR1cm4gZS5yb3dzWzBdLmNlbGxzWzA8PQpiP2I6ZS5yb3dzWzBdLmNlbGxzLmxlbmd0aC0xXX07R3JhcGgucHJvdG90eXBlLmRlbGV0ZUNvbHVtbj1mdW5jdGlvbihhLGIpe2lmKDA8PWIpZm9yKHZhciBlPWEudEJvZGllc1swXS5yb3dzLGM9MDtjPGUubGVuZ3RoO2MrKyllW2NdLmNlbGxzLmxlbmd0aD5iJiZlW2NdLmRlbGV0ZUNlbGwoYil9O0dyYXBoLnByb3RvdHlwZS5wYXN0ZUh0bWxBdENhcmV0PWZ1bmN0aW9uKGEpe3ZhciBiO2lmKHdpbmRvdy5nZXRTZWxlY3Rpb24pe2lmKGI9d2luZG93LmdldFNlbGVjdGlvbigpLGIuZ2V0UmFuZ2VBdCYmYi5yYW5nZUNvdW50KXtiPWIuZ2V0UmFuZ2VBdCgwKTtiLmRlbGV0ZUNvbnRlbnRzKCk7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7ZS5pbm5lckhUTUw9YTthPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtmb3IodmFyIGM7Yz1lLmZpcnN0Q2hpbGQ7KWxhc3ROb2RlPWEuYXBwZW5kQ2hpbGQoYyk7Yi5pbnNlcnROb2RlKGEpfX1lbHNlKGI9ZG9jdW1lbnQuc2VsZWN0aW9uKSYmCiJDb250cm9sIiE9Yi50eXBlJiZiLmNyZWF0ZVJhbmdlKCkucGFzdGVIVE1MKGEpfTtHcmFwaC5wcm90b3R5cGUuY3JlYXRlTGlua0ZvckhpbnQ9ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBlKGEsYil7YS5sZW5ndGg+YiYmKGE9YS5zdWJzdHJpbmcoMCxNYXRoLnJvdW5kKGIvMikpKyIuLi4iK2Euc3Vic3RyaW5nKGEubGVuZ3RoLU1hdGgucm91bmQoYi80KSkpO3JldHVybiBhfWE9bnVsbCE9YT9hOiJqYXZhc2NyaXB0OnZvaWQoMCk7IjtpZihudWxsPT1ifHwwPT1iLmxlbmd0aCliPXRoaXMuaXNDdXN0b21MaW5rKGEpP3RoaXMuZ2V0TGlua1RpdGxlKGEpOmE7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYSIpO2Muc2V0QXR0cmlidXRlKCJyZWwiLHRoaXMubGlua1JlbGF0aW9uKTtjLnNldEF0dHJpYnV0ZSgiaHJlZiIsdGhpcy5nZXRBYnNvbHV0ZVVybChhKSk7Yy5zZXRBdHRyaWJ1dGUoInRpdGxlIixlKHRoaXMuaXNDdXN0b21MaW5rKGEpP3RoaXMuZ2V0TGlua1RpdGxlKGEpOgphLDgwKSk7bnVsbCE9dGhpcy5saW5rVGFyZ2V0JiZjLnNldEF0dHJpYnV0ZSgidGFyZ2V0Iix0aGlzLmxpbmtUYXJnZXQpO214VXRpbHMud3JpdGUoYyxlKGIsNDApKTt0aGlzLmlzQ3VzdG9tTGluayhhKSYmbXhFdmVudC5hZGRMaXN0ZW5lcihjLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7dGhpcy5jdXN0b21MaW5rQ2xpY2tlZChhKTtteEV2ZW50LmNvbnN1bWUoYil9KSk7cmV0dXJuIGN9O0dyYXBoLnByb3RvdHlwZS5pbml0VG91Y2g9ZnVuY3Rpb24oKXt0aGlzLmNvbm5lY3Rpb25IYW5kbGVyLm1hcmtlci5pc0VuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5ncmFwaC5jb25uZWN0aW9uSGFuZGxlci5maXJzdH07dGhpcy5hZGRMaXN0ZW5lcihteEV2ZW50LlNUQVJUX0VESVRJTkcsZnVuY3Rpb24oYSxiKXt0aGlzLnBvcHVwTWVudUhhbmRsZXIuaGlkZU1lbnUoKX0pO3ZhciBhPXRoaXMudXBkYXRlTW91c2VFdmVudDt0aGlzLnVwZGF0ZU1vdXNlRXZlbnQ9CmZ1bmN0aW9uKGIpe2I9YS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYobXhFdmVudC5pc1RvdWNoRXZlbnQoYi5nZXRFdmVudCgpKSYmbnVsbD09Yi5nZXRTdGF0ZSgpKXt2YXIgZT10aGlzLmdldENlbGxBdChiLmdyYXBoWCxiLmdyYXBoWSk7bnVsbCE9ZSYmdGhpcy5pc1N3aW1sYW5lKGUpJiZ0aGlzLmhpdHNTd2ltbGFuZUNvbnRlbnQoZSxiLmdyYXBoWCxiLmdyYXBoWSl8fChiLnN0YXRlPXRoaXMudmlldy5nZXRTdGF0ZShlKSxudWxsIT1iLnN0YXRlJiZudWxsIT1iLnN0YXRlLnNoYXBlJiYodGhpcy5jb250YWluZXIuc3R5bGUuY3Vyc29yPWIuc3RhdGUuc2hhcGUubm9kZS5zdHlsZS5jdXJzb3IpKX1udWxsPT1iLmdldFN0YXRlKCkmJnRoaXMuaXNFbmFibGVkKCkmJih0aGlzLmNvbnRhaW5lci5zdHlsZS5jdXJzb3I9ImRlZmF1bHQiKTtyZXR1cm4gYn07dmFyIGI9ITEsZT0hMSxjPSExLGQ9dGhpcy5maXJlTW91c2VFdmVudDt0aGlzLmZpcmVNb3VzZUV2ZW50PWZ1bmN0aW9uKGEsCmYsZyl7YT09bXhFdmVudC5NT1VTRV9ET1dOJiYoZj10aGlzLnVwZGF0ZU1vdXNlRXZlbnQoZiksYj10aGlzLmlzQ2VsbFNlbGVjdGVkKGYuZ2V0Q2VsbCgpKSxlPXRoaXMuaXNTZWxlY3Rpb25FbXB0eSgpLGM9dGhpcy5wb3B1cE1lbnVIYW5kbGVyLmlzTWVudVNob3dpbmcoKSk7ZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3RoaXMucG9wdXBNZW51SGFuZGxlci5tb3VzZVVwPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsZCl7dGhpcy5wb3B1cE1lbnVIYW5kbGVyLnBvcHVwVHJpZ2dlcj0hdGhpcy5pc0VkaXRpbmcoKSYmdGhpcy5pc0VuYWJsZWQoKSYmKG51bGw9PWQuZ2V0U3RhdGUoKXx8IWQuaXNTb3VyY2UoZC5nZXRTdGF0ZSgpLmNvbnRyb2wpKSYmKHRoaXMucG9wdXBNZW51SGFuZGxlci5wb3B1cFRyaWdnZXJ8fCFjJiYhbXhFdmVudC5pc01vdXNlRXZlbnQoZC5nZXRFdmVudCgpKSYmKGUmJm51bGw9PWQuZ2V0Q2VsbCgpJiZ0aGlzLmlzU2VsZWN0aW9uRW1wdHkoKXx8YiYmCnRoaXMuaXNDZWxsU2VsZWN0ZWQoZC5nZXRDZWxsKCkpKSk7bXhQb3B1cE1lbnVIYW5kbGVyLnByb3RvdHlwZS5tb3VzZVVwLmFwcGx5KHRoaXMucG9wdXBNZW51SGFuZGxlcixhcmd1bWVudHMpfSl9O214Q2VsbEVkaXRvci5wcm90b3R5cGUuaXNDb250ZW50RWRpdGluZz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZSh0aGlzLmVkaXRpbmdDZWxsKTtyZXR1cm4gbnVsbCE9YSYmMT09YS5zdHlsZS5odG1sfTtteENlbGxFZGl0b3IucHJvdG90eXBlLmlzVGFibGVTZWxlY3RlZD1mdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLmdyYXBoLmdldFBhcmVudEJ5TmFtZSh0aGlzLmdyYXBoLmdldFNlbGVjdGVkRWxlbWVudCgpLCJUQUJMRSIsdGhpcy50ZXh0YXJlYSl9O214Q2VsbEVkaXRvci5wcm90b3R5cGUuYWxpZ25UZXh0PWZ1bmN0aW9uKGEsYil7dmFyIGU9bnVsbCE9YiYmbXhFdmVudC5pc1NoaWZ0RG93bihiKTtpZihlfHxudWxsIT13aW5kb3cuZ2V0U2VsZWN0aW9uJiYKbnVsbCE9d2luZG93LmdldFNlbGVjdGlvbigpLmNvbnRhaW5zTm9kZSl7dmFyIGM9ITA7dGhpcy5ncmFwaC5wcm9jZXNzRWxlbWVudHModGhpcy50ZXh0YXJlYSxmdW5jdGlvbihhKXtlfHx3aW5kb3cuZ2V0U2VsZWN0aW9uKCkuY29udGFpbnNOb2RlKGEsITApPyhhLnJlbW92ZUF0dHJpYnV0ZSgiYWxpZ24iKSxhLnN0eWxlLnRleHRBbGlnbj1udWxsKTpjPSExfSk7YyYmdGhpcy5ncmFwaC5jZWxsRWRpdG9yLnNldEFsaWduKGEpfWRvY3VtZW50LmV4ZWNDb21tYW5kKCJqdXN0aWZ5IithLnRvTG93ZXJDYXNlKCksITEsbnVsbCl9O214Q2VsbEVkaXRvci5wcm90b3R5cGUuc2F2ZVNlbGVjdGlvbj1mdW5jdGlvbigpe2lmKHdpbmRvdy5nZXRTZWxlY3Rpb24pe3ZhciBhPXdpbmRvdy5nZXRTZWxlY3Rpb24oKTtpZihhLmdldFJhbmdlQXQmJmEucmFuZ2VDb3VudCl7Zm9yKHZhciBiPVtdLGU9MCxjPWEucmFuZ2VDb3VudDtlPGM7KytlKWIucHVzaChhLmdldFJhbmdlQXQoZSkpO3JldHVybiBifX1lbHNlIGlmKGRvY3VtZW50LnNlbGVjdGlvbiYmCmRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSlyZXR1cm4gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7cmV0dXJuIG51bGx9O214Q2VsbEVkaXRvci5wcm90b3R5cGUucmVzdG9yZVNlbGVjdGlvbj1mdW5jdGlvbihhKXt0cnl7aWYoYSlpZih3aW5kb3cuZ2V0U2VsZWN0aW9uKXtzZWw9d2luZG93LmdldFNlbGVjdGlvbigpO3NlbC5yZW1vdmVBbGxSYW5nZXMoKTtmb3IodmFyIGI9MCxlPWEubGVuZ3RoO2I8ZTsrK2Ipc2VsLmFkZFJhbmdlKGFbYl0pfWVsc2UgZG9jdW1lbnQuc2VsZWN0aW9uJiZhLnNlbGVjdCYmYS5zZWxlY3QoKX1jYXRjaChoYSl7fX07dmFyIG49bXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmluaXRpYWxpemVMYWJlbDtteENlbGxSZW5kZXJlci5wcm90b3R5cGUuaW5pdGlhbGl6ZUxhYmVsPWZ1bmN0aW9uKGEpe251bGwhPWEudGV4dCYmKGEudGV4dC5yZXBsYWNlTGluZWZlZWRzPSIwIiE9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLCJubDJCciIsCiIxIikpO24uYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgdj1teENvbnN0cmFpbnRIYW5kbGVyLnByb3RvdHlwZS51cGRhdGU7bXhDb25zdHJhaW50SGFuZGxlci5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEsYil7dGhpcy5pc0tlZXBGb2N1c0V2ZW50KGEpfHwhbXhFdmVudC5pc0FsdERvd24oYS5nZXRFdmVudCgpKT92LmFwcGx5KHRoaXMsYXJndW1lbnRzKTp0aGlzLnJlc2V0KCl9O214R3VpZGUucHJvdG90eXBlLmNyZWF0ZUd1aWRlU2hhcGU9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBteFBvbHlsaW5lKFtdLG14Q29uc3RhbnRzLkdVSURFX0NPTE9SLG14Q29uc3RhbnRzLkdVSURFX1NUUk9LRVdJRFRIKX07bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5lc2NhcGVDYW5jZWxzRWRpdGluZz0hMTt2YXIgdD1teENlbGxFZGl0b3IucHJvdG90eXBlLnN0YXJ0RWRpdGluZztteENlbGxFZGl0b3IucHJvdG90eXBlLnN0YXJ0RWRpdGluZz1mdW5jdGlvbihhLGIpe2E9dGhpcy5ncmFwaC5nZXRTdGFydEVkaXRpbmdDZWxsKGEsCmIpO3QuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciBlPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZShhKTt0aGlzLnRleHRhcmVhLmNsYXNzTmFtZT1udWxsIT1lJiYxPT1lLnN0eWxlLmh0bWw/Im14Q2VsbEVkaXRvciBnZUNvbnRlbnRFZGl0YWJsZSI6Im14Q2VsbEVkaXRvciBteFBsYWluVGV4dEVkaXRvciI7dGhpcy5jb2RlVmlld01vZGU9ITE7dGhpcy5zd2l0Y2hTZWxlY3Rpb25TdGF0ZT1udWxsO3RoaXMuZ3JhcGguc2V0U2VsZWN0aW9uQ2VsbChhKTt2YXIgZT10aGlzLmdyYXBoLmdldE1vZGVsKCkuZ2V0UGFyZW50KGEpLGM9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoYSk7dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmlzRWRnZShlKSYmbnVsbCE9YyYmYy5yZWxhdGl2ZXx8dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmlzRWRnZShhKT9teENsaWVudC5JU19RVUlSS1M/dGhpcy50ZXh0YXJlYS5zdHlsZS5ib3JkZXI9ImdyYXkgZG90dGVkIDFweCI6dGhpcy50ZXh0YXJlYS5zdHlsZS5vdXRsaW5lPQpteENsaWVudC5JU19JRXx8bXhDbGllbnQuSVNfSUUxMXx8bXhDbGllbnQuSVNfRkYmJm14Q2xpZW50LklTX1dJTj8iZ3JheSBkb3R0ZWQgMXB4IjoiIjpteENsaWVudC5JU19RVUlSS1MmJih0aGlzLnRleHRhcmVhLnN0eWxlLm91dGxpbmU9Im5vbmUiLHRoaXMudGV4dGFyZWEuc3R5bGUuYm9yZGVyPSIiKX07dmFyIHk9bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5pbnN0YWxsTGlzdGVuZXJzO214Q2VsbEVkaXRvci5wcm90b3R5cGUuaW5zdGFsbExpc3RlbmVycz1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEsZSl7ZS5vcmlnaW5hbE5vZGU9YTthPWEuZmlyc3RDaGlsZDtmb3IodmFyIGM9ZS5maXJzdENoaWxkO251bGwhPWEmJm51bGwhPWM7KWIoYSxjKSxhPWEubmV4dFNpYmxpbmcsYz1jLm5leHRTaWJsaW5nO3JldHVybiBlfWZ1bmN0aW9uIGUoYSxiKXtpZihudWxsIT1hKWlmKGIub3JpZ2luYWxOb2RlIT1hKWMoYSk7ZWxzZSBmb3IoYT1hLmZpcnN0Q2hpbGQsYj1iLmZpcnN0Q2hpbGQ7bnVsbCE9CmE7KXt2YXIgZD1hLm5leHRTaWJsaW5nO251bGw9PWI/YyhhKTooZShhLGIpLGI9Yi5uZXh0U2libGluZyk7YT1kfX1mdW5jdGlvbiBjKGEpe2Zvcih2YXIgYj1hLmZpcnN0Q2hpbGQ7bnVsbCE9Yjspe3ZhciBlPWIubmV4dFNpYmxpbmc7YyhiKTtiPWV9MT09YS5ub2RlVHlwZSYmKCJCUiI9PT1hLm5vZGVOYW1lfHxudWxsIT1hLmZpcnN0Q2hpbGQpfHwzPT1hLm5vZGVUeXBlJiYwIT1teFV0aWxzLnRyaW0obXhVdGlscy5nZXRUZXh0Q29udGVudChhKSkubGVuZ3RoPygzPT1hLm5vZGVUeXBlJiZteFV0aWxzLnNldFRleHRDb250ZW50KGEsbXhVdGlscy5nZXRUZXh0Q29udGVudChhKS5yZXBsYWNlKC9cbnxcci9nLCIiKSksMT09YS5ub2RlVHlwZSYmKGEucmVtb3ZlQXR0cmlidXRlKCJzdHlsZSIpLGEucmVtb3ZlQXR0cmlidXRlKCJjbGFzcyIpLGEucmVtb3ZlQXR0cmlidXRlKCJ3aWR0aCIpLGEucmVtb3ZlQXR0cmlidXRlKCJjZWxscGFkZGluZyIpLGEucmVtb3ZlQXR0cmlidXRlKCJjZWxsc3BhY2luZyIpLAphLnJlbW92ZUF0dHJpYnV0ZSgiYm9yZGVyIikpKTphLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSl9eS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bXhDbGllbnQuSVNfUVVJUktTfHw3PT09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHw4PT09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHxteEV2ZW50LmFkZExpc3RlbmVyKHRoaXMudGV4dGFyZWEsInBhc3RlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt2YXIgYz1iKHRoaXMudGV4dGFyZWEsdGhpcy50ZXh0YXJlYS5jbG9uZU5vZGUoITApKTt3aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe251bGwhPXRoaXMudGV4dGFyZWEmJigwPD10aGlzLnRleHRhcmVhLmlubmVySFRNTC5pbmRleE9mKCI8bzpPZmZpY2VEb2N1bWVudFNldHRpbmdzPiIpfHwwPD10aGlzLnRleHRhcmVhLmlubmVySFRNTC5pbmRleE9mKCJceDNjIS0tW2lmICFtc29dPiIpP2UodGhpcy50ZXh0YXJlYSxjKTpHcmFwaC5yZW1vdmVQYXN0ZUZvcm1hdHRpbmcodGhpcy50ZXh0YXJlYSkpfSksCjApfSkpfTtteENlbGxFZGl0b3IucHJvdG90eXBlLnRvZ2dsZVZpZXdNb2RlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKHRoaXMuZWRpdGluZ0NlbGwpO2lmKG51bGwhPWEpe3ZhciBiPW51bGwhPWEmJiIwIiE9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLCJubDJCciIsIjEiKSxlPXRoaXMuc2F2ZVNlbGVjdGlvbigpO2lmKHRoaXMuY29kZVZpZXdNb2RlKXtwPW14VXRpbHMuZXh0cmFjdFRleHRXaXRoV2hpdGVzcGFjZSh0aGlzLnRleHRhcmVhLmNoaWxkTm9kZXMpOzA8cC5sZW5ndGgmJiJcbiI9PXAuY2hhckF0KHAubGVuZ3RoLTEpJiYocD1wLnN1YnN0cmluZygwLHAubGVuZ3RoLTEpKTtwPXRoaXMuZ3JhcGguc2FuaXRpemVIdG1sKGI/cC5yZXBsYWNlKC9cbi9nLCI8YnIvPiIpOnAsITApO3RoaXMudGV4dGFyZWEuY2xhc3NOYW1lPSJteENlbGxFZGl0b3IgZ2VDb250ZW50RWRpdGFibGUiO3ZhciBjPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GT05UU0laRSwKbXhDb25zdGFudHMuREVGQVVMVF9GT05UU0laRSksYj1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRk9OVEZBTUlMWSxteENvbnN0YW50cy5ERUZBVUxUX0ZPTlRGQU1JTFkpLGQ9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FMSUdOLG14Q29uc3RhbnRzLkFMSUdOX0xFRlQpLGY9KG14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GT05UU1RZTEUsMCkmbXhDb25zdGFudHMuRk9OVF9CT0xEKT09bXhDb25zdGFudHMuRk9OVF9CT0xELGc9KG14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GT05UU1RZTEUsMCkmbXhDb25zdGFudHMuRk9OVF9JVEFMSUMpPT1teENvbnN0YW50cy5GT05UX0lUQUxJQyxsPVtdOyhteFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRk9OVFNUWUxFLDApJm14Q29uc3RhbnRzLkZPTlRfVU5ERVJMSU5FKT09bXhDb25zdGFudHMuRk9OVF9VTkRFUkxJTkUmJgpsLnB1c2goInVuZGVybGluZSIpOyhteFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRk9OVFNUWUxFLDApJm14Q29uc3RhbnRzLkZPTlRfU1RSSUtFVEhST1VHSCk9PW14Q29uc3RhbnRzLkZPTlRfU1RSSUtFVEhST1VHSCYmbC5wdXNoKCJsaW5lLXRocm91Z2giKTt0aGlzLnRleHRhcmVhLnN0eWxlLmxpbmVIZWlnaHQ9bXhDb25zdGFudHMuQUJTT0xVVEVfTElORV9IRUlHSFQ/TWF0aC5yb3VuZChjKm14Q29uc3RhbnRzLkxJTkVfSEVJR0hUKSsicHgiOm14Q29uc3RhbnRzLkxJTkVfSEVJR0hUO3RoaXMudGV4dGFyZWEuc3R5bGUuZm9udFNpemU9TWF0aC5yb3VuZChjKSsicHgiO3RoaXMudGV4dGFyZWEuc3R5bGUudGV4dERlY29yYXRpb249bC5qb2luKCIgIik7dGhpcy50ZXh0YXJlYS5zdHlsZS5mb250V2VpZ2h0PWY/ImJvbGQiOiJub3JtYWwiO3RoaXMudGV4dGFyZWEuc3R5bGUuZm9udFN0eWxlPWc/Iml0YWxpYyI6IiI7dGhpcy50ZXh0YXJlYS5zdHlsZS5mb250RmFtaWx5PQpiO3RoaXMudGV4dGFyZWEuc3R5bGUudGV4dEFsaWduPWQ7dGhpcy50ZXh0YXJlYS5zdHlsZS5wYWRkaW5nPSIwcHgiO3RoaXMudGV4dGFyZWEuaW5uZXJIVE1MIT1wJiYodGhpcy50ZXh0YXJlYS5pbm5lckhUTUw9cCwwPT10aGlzLnRleHRhcmVhLmlubmVySFRNTC5sZW5ndGgmJih0aGlzLnRleHRhcmVhLmlubmVySFRNTD10aGlzLmdldEVtcHR5TGFiZWxUZXh0KCksdGhpcy5jbGVhck9uQ2hhbmdlPTA8dGhpcy50ZXh0YXJlYS5pbm5lckhUTUwubGVuZ3RoKSk7dGhpcy5jb2RlVmlld01vZGU9ITF9ZWxzZXt0aGlzLmNsZWFyT25DaGFuZ2UmJnRoaXMudGV4dGFyZWEuaW5uZXJIVE1MPT10aGlzLmdldEVtcHR5TGFiZWxUZXh0KCkmJih0aGlzLmNsZWFyT25DaGFuZ2U9ITEsdGhpcy50ZXh0YXJlYS5pbm5lckhUTUw9IiIpO3ZhciBwPW14VXRpbHMuaHRtbEVudGl0aWVzKHRoaXMudGV4dGFyZWEuaW5uZXJIVE1MKTtteENsaWVudC5JU19RVUlSS1N8fDg9PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8CihwPW14VXRpbHMucmVwbGFjZVRyYWlsaW5nTmV3bGluZXMocCwiPGRpdj48YnI+PC9kaXY+IikpO3A9dGhpcy5ncmFwaC5zYW5pdGl6ZUh0bWwoYj9wLnJlcGxhY2UoL1xuL2csIiIpLnJlcGxhY2UoLyZsdDticlxzKi4/Jmd0Oy9nLCI8YnI+Iik6cCwhMCk7dGhpcy50ZXh0YXJlYS5jbGFzc05hbWU9Im14Q2VsbEVkaXRvciBteFBsYWluVGV4dEVkaXRvciI7dmFyIGM9bXhDb25zdGFudHMuREVGQVVMVF9GT05UU0laRTt0aGlzLnRleHRhcmVhLnN0eWxlLmxpbmVIZWlnaHQ9bXhDb25zdGFudHMuQUJTT0xVVEVfTElORV9IRUlHSFQ/TWF0aC5yb3VuZChjKm14Q29uc3RhbnRzLkxJTkVfSEVJR0hUKSsicHgiOm14Q29uc3RhbnRzLkxJTkVfSEVJR0hUO3RoaXMudGV4dGFyZWEuc3R5bGUuZm9udFNpemU9TWF0aC5yb3VuZChjKSsicHgiO3RoaXMudGV4dGFyZWEuc3R5bGUudGV4dERlY29yYXRpb249IiI7dGhpcy50ZXh0YXJlYS5zdHlsZS5mb250V2VpZ2h0PSJub3JtYWwiO3RoaXMudGV4dGFyZWEuc3R5bGUuZm9udFN0eWxlPQoiIjt0aGlzLnRleHRhcmVhLnN0eWxlLmZvbnRGYW1pbHk9bXhDb25zdGFudHMuREVGQVVMVF9GT05URkFNSUxZO3RoaXMudGV4dGFyZWEuc3R5bGUudGV4dEFsaWduPSJsZWZ0Ijt0aGlzLnRleHRhcmVhLnN0eWxlLnBhZGRpbmc9IjJweCI7dGhpcy50ZXh0YXJlYS5pbm5lckhUTUwhPXAmJih0aGlzLnRleHRhcmVhLmlubmVySFRNTD1wKTt0aGlzLmNvZGVWaWV3TW9kZT0hMH10aGlzLnRleHRhcmVhLmZvY3VzKCk7bnVsbCE9dGhpcy5zd2l0Y2hTZWxlY3Rpb25TdGF0ZSYmdGhpcy5yZXN0b3JlU2VsZWN0aW9uKHRoaXMuc3dpdGNoU2VsZWN0aW9uU3RhdGUpO3RoaXMuc3dpdGNoU2VsZWN0aW9uU3RhdGU9ZTt0aGlzLnJlc2l6ZSgpfX07dmFyIHg9bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5yZXNpemU7bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5yZXNpemU9ZnVuY3Rpb24oYSxiKXtpZihudWxsIT10aGlzLnRleHRhcmVhKWlmKGE9dGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0U3RhdGUodGhpcy5lZGl0aW5nQ2VsbCksCnRoaXMuY29kZVZpZXdNb2RlJiZudWxsIT1hKXt2YXIgZT1hLnZpZXcuc2NhbGU7dGhpcy5ib3VuZHM9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShhKTtpZigwPT10aGlzLmJvdW5kcy53aWR0aCYmMD09dGhpcy5ib3VuZHMuaGVpZ2h0KXt0aGlzLmJvdW5kcy53aWR0aD0xNjAqZTt0aGlzLmJvdW5kcy5oZWlnaHQ9NjAqZTt2YXIgYz1udWxsIT1hLnRleHQ/YS50ZXh0Lm1hcmdpbjpudWxsO251bGw9PWMmJihjPW14VXRpbHMuZ2V0QWxpZ25tZW50QXNQb2ludChteFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQUxJR04sbXhDb25zdGFudHMuQUxJR05fQ0VOVEVSKSxteFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfVkVSVElDQUxfQUxJR04sbXhDb25zdGFudHMuQUxJR05fTUlERExFKSkpO3RoaXMuYm91bmRzLngrPWMueCp0aGlzLmJvdW5kcy53aWR0aDt0aGlzLmJvdW5kcy55Kz1jLnkqdGhpcy5ib3VuZHMuaGVpZ2h0fXRoaXMudGV4dGFyZWEuc3R5bGUud2lkdGg9Ck1hdGgucm91bmQoKHRoaXMuYm91bmRzLndpZHRoLTQpL2UpKyJweCI7dGhpcy50ZXh0YXJlYS5zdHlsZS5oZWlnaHQ9TWF0aC5yb3VuZCgodGhpcy5ib3VuZHMuaGVpZ2h0LTQpL2UpKyJweCI7dGhpcy50ZXh0YXJlYS5zdHlsZS5vdmVyZmxvdz0iYXV0byI7dGhpcy50ZXh0YXJlYS5jbGllbnRIZWlnaHQ8dGhpcy50ZXh0YXJlYS5vZmZzZXRIZWlnaHQmJih0aGlzLnRleHRhcmVhLnN0eWxlLmhlaWdodD1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLmhlaWdodC9lKSsodGhpcy50ZXh0YXJlYS5vZmZzZXRIZWlnaHQtdGhpcy50ZXh0YXJlYS5jbGllbnRIZWlnaHQpKyJweCIsdGhpcy5ib3VuZHMuaGVpZ2h0PXBhcnNlSW50KHRoaXMudGV4dGFyZWEuc3R5bGUuaGVpZ2h0KSplKTt0aGlzLnRleHRhcmVhLmNsaWVudFdpZHRoPHRoaXMudGV4dGFyZWEub2Zmc2V0V2lkdGgmJih0aGlzLnRleHRhcmVhLnN0eWxlLndpZHRoPU1hdGgucm91bmQodGhpcy5ib3VuZHMud2lkdGgvZSkrKHRoaXMudGV4dGFyZWEub2Zmc2V0V2lkdGgtCnRoaXMudGV4dGFyZWEuY2xpZW50V2lkdGgpKyJweCIsdGhpcy5ib3VuZHMud2lkdGg9cGFyc2VJbnQodGhpcy50ZXh0YXJlYS5zdHlsZS53aWR0aCkqZSk7dGhpcy50ZXh0YXJlYS5zdHlsZS5sZWZ0PU1hdGgucm91bmQodGhpcy5ib3VuZHMueCkrInB4Ijt0aGlzLnRleHRhcmVhLnN0eWxlLnRvcD1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLnkpKyJweCI7bXhDbGllbnQuSVNfVk1MP3RoaXMudGV4dGFyZWEuc3R5bGUuem9vbT1lOm14VXRpbHMuc2V0UHJlZml4ZWRTdHlsZSh0aGlzLnRleHRhcmVhLnN0eWxlLCJ0cmFuc2Zvcm0iLCJzY2FsZSgiK2UrIiwiK2UrIikiKX1lbHNlIHRoaXMudGV4dGFyZWEuc3R5bGUuaGVpZ2h0PSIiLHRoaXMudGV4dGFyZWEuc3R5bGUub3ZlcmZsb3c9IiIseC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O214Q2VsbEVkaXRvckdldEluaXRpYWxWYWx1ZT1teENlbGxFZGl0b3IucHJvdG90eXBlLmdldEluaXRpYWxWYWx1ZTtteENlbGxFZGl0b3IucHJvdG90eXBlLmdldEluaXRpYWxWYWx1ZT0KZnVuY3Rpb24oYSxiKXtpZigiMCI9PW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSwiaHRtbCIsIjAiKSlyZXR1cm4gbXhDZWxsRWRpdG9yR2V0SW5pdGlhbFZhbHVlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgZT10aGlzLmdyYXBoLmdldEVkaXRpbmdWYWx1ZShhLmNlbGwsYik7IjEiPT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsIm5sMkJyIiwiMSIpJiYoZT1lLnJlcGxhY2UoL1xuL2csIjxici8+IikpO3JldHVybiBlPXRoaXMuZ3JhcGguc2FuaXRpemVIdG1sKGUsITApfTtteENlbGxFZGl0b3JHZXRDdXJyZW50VmFsdWU9bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5nZXRDdXJyZW50VmFsdWU7bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5nZXRDdXJyZW50VmFsdWU9ZnVuY3Rpb24oYSl7aWYoIjAiPT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsImh0bWwiLCIwIikpcmV0dXJuIG14Q2VsbEVkaXRvckdldEN1cnJlbnRWYWx1ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGI9dGhpcy5ncmFwaC5zYW5pdGl6ZUh0bWwodGhpcy50ZXh0YXJlYS5pbm5lckhUTUwsCiEwKTtyZXR1cm4gYj0iMSI9PW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSwibmwyQnIiLCIxIik/Yi5yZXBsYWNlKC9cclxuL2csIjxici8+IikucmVwbGFjZSgvXG4vZywiPGJyLz4iKTpiLnJlcGxhY2UoL1xyXG4vZywiIikucmVwbGFjZSgvXG4vZywiIil9O3ZhciBFPW14Q2VsbEVkaXRvci5wcm90b3R5cGUuc3RvcEVkaXRpbmc7bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5zdG9wRWRpdGluZz1mdW5jdGlvbihhKXt0aGlzLmNvZGVWaWV3TW9kZSYmdGhpcy50b2dnbGVWaWV3TW9kZSgpO0UuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuZm9jdXNDb250YWluZXIoKX07bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5mb2N1c0NvbnRhaW5lcj1mdW5jdGlvbigpe3RyeXt0aGlzLmdyYXBoLmNvbnRhaW5lci5mb2N1cygpfWNhdGNoKFQpe319O3ZhciBBPW14Q2VsbEVkaXRvci5wcm90b3R5cGUuYXBwbHlWYWx1ZTtteENlbGxFZGl0b3IucHJvdG90eXBlLmFwcGx5VmFsdWU9ZnVuY3Rpb24oYSwKYil7dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmJlZ2luVXBkYXRlKCk7dHJ5e0EuYXBwbHkodGhpcyxhcmd1bWVudHMpLCIiPT1iJiZ0aGlzLmdyYXBoLmlzQ2VsbERlbGV0YWJsZShhLmNlbGwpJiYwPT10aGlzLmdyYXBoLm1vZGVsLmdldENoaWxkQ291bnQoYS5jZWxsKSYmdGhpcy5ncmFwaC5pc1RyYW5zcGFyZW50U3RhdGUoYSkmJnRoaXMuZ3JhcGgucmVtb3ZlQ2VsbHMoW2EuY2VsbF0sITEpfWZpbmFsbHl7dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX07bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5nZXRCYWNrZ3JvdW5kQ29sb3I9ZnVuY3Rpb24oYSl7dmFyIGI9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0xBQkVMX0JBQ0tHUk9VTkRDT0xPUixudWxsKTtudWxsIT1iJiZiIT1teENvbnN0YW50cy5OT05FfHwhKG51bGwhPWEuY2VsbC5nZW9tZXRyeSYmMDxhLmNlbGwuZ2VvbWV0cnkud2lkdGgpfHwwPT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsCm14Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OLDApJiYwIT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfSE9SSVpPTlRBTCwxKXx8KGI9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZJTExDT0xPUixudWxsKSk7Yj09bXhDb25zdGFudHMuTk9ORSYmKGI9bnVsbCk7cmV0dXJuIGJ9O214Q2VsbEVkaXRvci5wcm90b3R5cGUuZ2V0TWluaW11bVNpemU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5ncmFwaC5nZXRWaWV3KCkuc2NhbGU7cmV0dXJuIG5ldyBteFJlY3RhbmdsZSgwLDAsbnVsbD09YS50ZXh0PzMwOmEudGV4dC5zaXplKmIrMjAsMzApfTtteEdyYXBoSGFuZGxlcklzVmFsaWREcm9wVGFyZ2V0PW14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5pc1ZhbGlkRHJvcFRhcmdldDtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuaXNWYWxpZERyb3BUYXJnZXQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbXhHcmFwaEhhbmRsZXJJc1ZhbGlkRHJvcFRhcmdldC5hcHBseSh0aGlzLAphcmd1bWVudHMpJiYhbXhFdmVudC5pc0FsdERvd24oYi5nZXRFdmVudCl9O214R3JhcGhWaWV3LnByb3RvdHlwZS5mb3JtYXRVbml0VGV4dD1mdW5jdGlvbihhKXtyZXR1cm4gYT9jKGEsdGhpcy51bml0KTphfTtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUudXBkYXRlSGludD1mdW5jdGlvbihiKXtpZihudWxsIT10aGlzLnBCb3VuZHMmJihudWxsIT10aGlzLnNoYXBlfHx0aGlzLmxpdmVQcmV2aWV3QWN0aXZlKSl7bnVsbD09dGhpcy5oaW50JiYodGhpcy5oaW50PWEoKSx0aGlzLmdyYXBoLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmhpbnQpKTt2YXIgZT10aGlzLmdyYXBoLnZpZXcudHJhbnNsYXRlLGQ9dGhpcy5ncmFwaC52aWV3LnNjYWxlO2I9dGhpcy5yb3VuZExlbmd0aCgodGhpcy5ib3VuZHMueCt0aGlzLmN1cnJlbnREeCkvZC1lLngpO2U9dGhpcy5yb3VuZExlbmd0aCgodGhpcy5ib3VuZHMueSt0aGlzLmN1cnJlbnREeSkvZC1lLnkpO2Q9dGhpcy5ncmFwaC52aWV3LnVuaXQ7CnRoaXMuaGludC5pbm5lckhUTUw9YyhiLGQpKyIsICIrYyhlLGQpO3RoaXMuaGludC5zdHlsZS5sZWZ0PXRoaXMucEJvdW5kcy54K3RoaXMuY3VycmVudER4K01hdGgucm91bmQoKHRoaXMucEJvdW5kcy53aWR0aC10aGlzLmhpbnQuY2xpZW50V2lkdGgpLzIpKyJweCI7dGhpcy5oaW50LnN0eWxlLnRvcD10aGlzLnBCb3VuZHMueSt0aGlzLmN1cnJlbnREeSt0aGlzLnBCb3VuZHMuaGVpZ2h0K0VkaXRvci5oaW50T2Zmc2V0KyJweCJ9fTtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUucmVtb3ZlSGludD1mdW5jdGlvbigpe251bGwhPXRoaXMuaGludCYmKHRoaXMuaGludC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuaGludCksdGhpcy5oaW50PW51bGwpfTt2YXIgQz1teFN0YWNrTGF5b3V0LnByb3RvdHlwZS5yZXNpemVDZWxsO214U3RhY2tMYXlvdXQucHJvdG90eXBlLnJlc2l6ZUNlbGw9ZnVuY3Rpb24oYSxiKXtDLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgZT10aGlzLmdyYXBoLmdldENlbGxTdHlsZShhKTsKaWYobnVsbD09ZS5jaGlsZExheW91dCl7dmFyIGM9dGhpcy5ncmFwaC5tb2RlbC5nZXRQYXJlbnQoYSksZD1udWxsIT1jP3RoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGMpOm51bGw7bnVsbCE9ZCYmKGU9dGhpcy5ncmFwaC5nZXRDZWxsU3R5bGUoYyksInN0YWNrTGF5b3V0Ij09ZS5jaGlsZExheW91dCYmKGU9IjEiPT1teFV0aWxzLmdldFZhbHVlKGUsImhvcml6b250YWxTdGFjayIsIjEiKSxkPWQuY2xvbmUoKSxlP2QuaGVpZ2h0PWIuaGVpZ2h0OmQud2lkdGg9Yi53aWR0aCx0aGlzLmdyYXBoLm1vZGVsLnNldEdlb21ldHJ5KGMsZCkpKX19O3ZhciB6PW14U2VsZWN0aW9uQ2VsbHNIYW5kbGVyLnByb3RvdHlwZS5nZXRIYW5kbGVkU2VsZWN0aW9uQ2VsbHM7bXhTZWxlY3Rpb25DZWxsc0hhbmRsZXIucHJvdG90eXBlLmdldEhhbmRsZWRTZWxlY3Rpb25DZWxscz1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSl7ZS5nZXQoYSl8fChlLnB1dChhLCEwKSxkLnB1c2goYSkpfWZvcih2YXIgYj0Kei5hcHBseSh0aGlzLGFyZ3VtZW50cyksZT1uZXcgbXhEaWN0aW9uYXJ5LGM9dGhpcy5ncmFwaC5tb2RlbCxkPVtdLGY9MDtmPGIubGVuZ3RoO2YrKyl7dmFyIGc9YltmXTt0aGlzLmdyYXBoLmlzVGFibGVDZWxsKGcpP2EoYy5nZXRQYXJlbnQoYy5nZXRQYXJlbnQoZykpKTp0aGlzLmdyYXBoLmlzVGFibGVSb3coZykmJmEoYy5nZXRQYXJlbnQoZykpO2EoZyl9cmV0dXJuIGR9O3ZhciBEPW14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuY3JlYXRlUGFyZW50SGlnaGxpZ2h0U2hhcGU7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVQYXJlbnRIaWdobGlnaHRTaGFwZT1mdW5jdGlvbihhKXt2YXIgYj1ELmFwcGx5KHRoaXMsYXJndW1lbnRzKTtiLnN0cm9rZT0iI0MwQzBDMCI7Yi5zdHJva2V3aWR0aD0xO3JldHVybiBifTt2YXIgRz1teEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVQYXJlbnRIaWdobGlnaHRTaGFwZTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVQYXJlbnRIaWdobGlnaHRTaGFwZT0KZnVuY3Rpb24oYSl7dmFyIGI9Ry5hcHBseSh0aGlzLGFyZ3VtZW50cyk7Yi5zdHJva2U9IiNDMEMwQzAiO2Iuc3Ryb2tld2lkdGg9MTtyZXR1cm4gYn07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5yb3RhdGlvbkhhbmRsZVZTcGFjaW5nPS0xMjtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmdldFJvdGF0aW9uSGFuZGxlUG9zaXRpb249ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdldEhhbmRsZVBhZGRpbmcoKTtyZXR1cm4gbmV3IG14UG9pbnQodGhpcy5ib3VuZHMueCt0aGlzLmJvdW5kcy53aWR0aC10aGlzLnJvdGF0aW9uSGFuZGxlVlNwYWNpbmcrYS54LzIsdGhpcy5ib3VuZHMueSt0aGlzLnJvdGF0aW9uSGFuZGxlVlNwYWNpbmctYS55LzIpfTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmlzUmVjdXJzaXZlUmVzaXplPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuZ3JhcGguaXNSZWN1cnNpdmVWZXJ0ZXhSZXNpemUoYSkmJiFteEV2ZW50LmlzQ29udHJvbERvd24oYi5nZXRFdmVudCgpKX07Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaXNDZW50ZXJlZEV2ZW50PWZ1bmN0aW9uKGEsYil7cmV0dXJuISghdGhpcy5ncmFwaC5pc1N3aW1sYW5lKGEuY2VsbCkmJjA8dGhpcy5ncmFwaC5tb2RlbC5nZXRDaGlsZENvdW50KGEuY2VsbCkmJiF0aGlzLmdyYXBoLmlzQ2VsbENvbGxhcHNlZChhLmNlbGwpJiYiMSI9PW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSwicmVjdXJzaXZlUmVzaXplIiwiMSIpJiZudWxsPT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsImNoaWxkTGF5b3V0IixudWxsKSkmJm14RXZlbnQuaXNDb250cm9sRG93bihiLmdldEV2ZW50KCkpfHxteEV2ZW50LmlzTWV0YURvd24oYi5nZXRFdmVudCgpKX07dmFyIEY9bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5pc1JvdGF0aW9uSGFuZGxlVmlzaWJsZTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmlzUm90YXRpb25IYW5kbGVWaXNpYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIEYuYXBwbHkodGhpcyxhcmd1bWVudHMpJiYKIXRoaXMuZ3JhcGguaXNUYWJsZUNlbGwodGhpcy5zdGF0ZS5jZWxsKSYmIXRoaXMuZ3JhcGguaXNUYWJsZVJvdyh0aGlzLnN0YXRlLmNlbGwpJiYhdGhpcy5ncmFwaC5pc1RhYmxlKHRoaXMuc3RhdGUuY2VsbCl9O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuZ2V0U2l6ZXJCb3VuZHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmFwaC5pc1RhYmxlQ2VsbCh0aGlzLnN0YXRlLmNlbGwpP3RoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZSh0aGlzLmdyYXBoLm1vZGVsLmdldFBhcmVudCh0aGlzLmdyYXBoLm1vZGVsLmdldFBhcmVudCh0aGlzLnN0YXRlLmNlbGwpKSk6dGhpcy5ib3VuZHN9O3ZhciBIPW14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaXNQYXJlbnRIaWdobGlnaHRWaXNpYmxlO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaXNQYXJlbnRIaWdobGlnaHRWaXNpYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIEguYXBwbHkodGhpcyxhcmd1bWVudHMpJiYhdGhpcy5ncmFwaC5pc1RhYmxlQ2VsbCh0aGlzLnN0YXRlLmNlbGwpJiYKIXRoaXMuZ3JhcGguaXNUYWJsZVJvdyh0aGlzLnN0YXRlLmNlbGwpfTt2YXIgSj1teFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmlzQ3VzdG9tSGFuZGxlVmlzaWJsZTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmlzQ3VzdG9tSGFuZGxlVmlzaWJsZT1mdW5jdGlvbihhKXtyZXR1cm4gYS50YWJsZUhhbmRsZXx8Si5hcHBseSh0aGlzLGFyZ3VtZW50cykmJighdGhpcy5ncmFwaC5pc1RhYmxlKHRoaXMuc3RhdGUuY2VsbCl8fHRoaXMuZ3JhcGguaXNDZWxsU2VsZWN0ZWQodGhpcy5zdGF0ZS5jZWxsKSl9O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uQm9yZGVySW5zZXQ9ZnVuY3Rpb24oKXt2YXIgYT0wO3RoaXMuZ3JhcGguaXNUYWJsZVJvdyh0aGlzLnN0YXRlLmNlbGwpP2E9MTp0aGlzLmdyYXBoLmlzVGFibGVDZWxsKHRoaXMuc3RhdGUuY2VsbCkmJihhPTIpO3JldHVybiBhfTt2YXIgdT1teFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmdldFNlbGVjdGlvbkJvcmRlckJvdW5kczsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25Cb3JkZXJCb3VuZHM9ZnVuY3Rpb24oKXtyZXR1cm4gdS5hcHBseSh0aGlzLGFyZ3VtZW50cykuZ3JvdygtdGhpcy5nZXRTZWxlY3Rpb25Cb3JkZXJJbnNldCgpKX07dmFyIEs9bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVDdXN0b21IYW5kbGVzO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuY3JlYXRlQ3VzdG9tSGFuZGxlcz1mdW5jdGlvbigpe3ZhciBhPUsuYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKHRoaXMuZ3JhcGguaXNUYWJsZSh0aGlzLnN0YXRlLmNlbGwpKXt2YXIgYj10aGlzLmdyYXBoLGU9Yi5tb2RlbCxjPXRoaXMuc3RhdGUsZD10aGlzLnNlbGVjdGlvbkJvcmRlcixmPXRoaXM7bnVsbD09YSYmKGE9W10pO3ZhciBnPWIudmlldy5nZXRDZWxsU3RhdGVzKGUuZ2V0Q2hpbGRDZWxscyh0aGlzLnN0YXRlLmNlbGwsITApKTtpZigwPGcubGVuZ3RoKXtmb3IodmFyIGw9Yi52aWV3LmdldENlbGxTdGF0ZXMoZS5nZXRDaGlsZENlbGxzKGdbMF0uY2VsbCwKITApKSxlPTA7ZTxsLmxlbmd0aDtlKyspbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oZSl7dmFyIGc9bFtlXSxwPWU8bC5sZW5ndGgtMT9sW2UrMV06bnVsbCx1PW5ldyBteExpbmUobmV3IG14UmVjdGFuZ2xlLG14Q29uc3RhbnRzLk5PTkUsMSwhMCk7dS5pc0Rhc2hlZD1kLmlzRGFzaGVkO3U9bmV3IG14SGFuZGxlKGcsImNvbC1yZXNpemUiLG51bGwsdSk7dS50YWJsZUhhbmRsZT0hMDt2YXIgbj0wO3Uuc2hhcGUubm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh1LnNoYXBlLm5vZGUsdS5zaGFwZS5ub2RlLnBhcmVudE5vZGUuZmlyc3RDaGlsZCk7dS5yZWRyYXc9ZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLnNoYXBlJiZudWxsIT10aGlzLnN0YXRlLnNoYXBlKXt2YXIgYT1iLmdldEFjdHVhbFN0YXJ0U2l6ZShjLmNlbGwpO3RoaXMuc2hhcGUuc3Ryb2tlPTA9PW4/bXhDb25zdGFudHMuTk9ORTpkLnN0cm9rZTt0aGlzLnNoYXBlLmJvdW5kcy54PXRoaXMuc3RhdGUueCt0aGlzLnN0YXRlLndpZHRoKwpuKnRoaXMuZ3JhcGgudmlldy5zY2FsZTt0aGlzLnNoYXBlLmJvdW5kcy53aWR0aD0xO3RoaXMuc2hhcGUuYm91bmRzLnk9Yy55KyhlPT1sLmxlbmd0aC0xPzA6YS55KnRoaXMuZ3JhcGgudmlldy5zY2FsZSk7dGhpcy5zaGFwZS5ib3VuZHMuaGVpZ2h0PWMuaGVpZ2h0LShlPT1sLmxlbmd0aC0xPzA6KGEuaGVpZ2h0K2EueSkqdGhpcy5ncmFwaC52aWV3LnNjYWxlKTt0aGlzLnNoYXBlLnJlZHJhdygpfX07dmFyIHQ9ITE7dS5zZXRQb3NpdGlvbj1mdW5jdGlvbihhLGUsYyl7bj1NYXRoLm1heChHcmFwaC5taW5UYWJsZUNvbHVtbldpZHRoLWEud2lkdGgsZS54LWEueC1hLndpZHRoKTt0PW14RXZlbnQuaXNTaGlmdERvd24oYy5nZXRFdmVudCgpKTtudWxsPT1wfHx0fHwobj1NYXRoLm1pbigocC54K3Aud2lkdGgtZy54LWcud2lkdGgpL2Iudmlldy5zY2FsZS1HcmFwaC5taW5UYWJsZUNvbHVtbldpZHRoLG4pKX07dS5leGVjdXRlPWZ1bmN0aW9uKGEpe2lmKDAhPW4pYi5zZXRUYWJsZUNvbHVtbldpZHRoKHRoaXMuc3RhdGUuY2VsbCwKbix0KTtlbHNlIGlmKCFmLmJsb2NrRGVsYXllZFNlbGVjdGlvbil7dmFyIGU9Yi5nZXRDZWxsQXQoYS5nZXRHcmFwaFgoKSxhLmdldEdyYXBoWSgpKXx8Yy5jZWxsO2Iuc2VsZWN0Q2VsbEZvckV2ZW50KGUsYS5nZXRFdmVudCgpKX1uPTB9O3UucmVzZXQ9ZnVuY3Rpb24oKXtuPTB9O2EucHVzaCh1KX0pKGUpO2ZvcihlPTA7ZTxnLmxlbmd0aDtlKyspbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oZSl7ZT1nW2VdO3ZhciBsPW5ldyBteExpbmUobmV3IG14UmVjdGFuZ2xlLG14Q29uc3RhbnRzLk5PTkUsMSk7bC5pc0Rhc2hlZD1kLmlzRGFzaGVkO2U9bmV3IG14SGFuZGxlKGUsInJvdy1yZXNpemUiLG51bGwsbCk7ZS50YWJsZUhhbmRsZT0hMDt2YXIgcD0wO2Uuc2hhcGUubm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLnNoYXBlLm5vZGUsZS5zaGFwZS5ub2RlLnBhcmVudE5vZGUuZmlyc3RDaGlsZCk7ZS5yZWRyYXc9ZnVuY3Rpb24oKXtudWxsIT10aGlzLnNoYXBlJiZudWxsIT0KdGhpcy5zdGF0ZS5zaGFwZSYmKHRoaXMuc2hhcGUuc3Ryb2tlPTA9PXA/bXhDb25zdGFudHMuTk9ORTpkLnN0cm9rZSx0aGlzLnNoYXBlLmJvdW5kcy54PXRoaXMuc3RhdGUueCx0aGlzLnNoYXBlLmJvdW5kcy53aWR0aD10aGlzLnN0YXRlLndpZHRoLHRoaXMuc2hhcGUuYm91bmRzLnk9dGhpcy5zdGF0ZS55K3RoaXMuc3RhdGUuaGVpZ2h0K3AqdGhpcy5ncmFwaC52aWV3LnNjYWxlLHRoaXMuc2hhcGUuYm91bmRzLmhlaWdodD0xLHRoaXMuc2hhcGUucmVkcmF3KCkpfTtlLnNldFBvc2l0aW9uPWZ1bmN0aW9uKGEsYixlKXtwPU1hdGgubWF4KEdyYXBoLm1pblRhYmxlUm93SGVpZ2h0LWEuaGVpZ2h0LGIueS1hLnktYS5oZWlnaHQpfTtlLmV4ZWN1dGU9ZnVuY3Rpb24oYSl7aWYoMCE9cCliLnNldFRhYmxlUm93SGVpZ2h0KHRoaXMuc3RhdGUuY2VsbCxwLCFteEV2ZW50LmlzU2hpZnREb3duKGEuZ2V0RXZlbnQoKSkpO2Vsc2UgaWYoIWYuYmxvY2tEZWxheWVkU2VsZWN0aW9uKXt2YXIgZT0KYi5nZXRDZWxsQXQoYS5nZXRHcmFwaFgoKSxhLmdldEdyYXBoWSgpKXx8Yy5jZWxsO2Iuc2VsZWN0Q2VsbEZvckV2ZW50KGUsYS5nZXRFdmVudCgpKX1wPTB9O2UucmVzZXQ9ZnVuY3Rpb24oKXtwPTB9O2EucHVzaChlKX0pKGUpfX1yZXR1cm4gbnVsbCE9YT9hLnJldmVyc2UoKTpudWxsfTt2YXIgQj1teFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnNldEhhbmRsZXNWaXNpYmxlO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuc2V0SGFuZGxlc1Zpc2libGU9ZnVuY3Rpb24oYSl7Qi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYobnVsbCE9dGhpcy5tb3ZlSGFuZGxlcylmb3IodmFyIGI9MDtiPHRoaXMubW92ZUhhbmRsZXMubGVuZ3RoO2IrKyl0aGlzLm1vdmVIYW5kbGVzW2JdLnN0eWxlLnZpc2liaWxpdHk9YT8iIjoiaGlkZGVuIjtpZihudWxsIT10aGlzLmNvcm5lckhhbmRsZXMpZm9yKGI9MDtiPHRoaXMuY29ybmVySGFuZGxlcy5sZW5ndGg7YisrKXRoaXMuY29ybmVySGFuZGxlc1tiXS5ub2RlLnN0eWxlLnZpc2liaWxpdHk9CmE/IiI6ImhpZGRlbiJ9O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUucmVmcmVzaE1vdmVIYW5kbGVzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5ncmFwaC5tb2RlbDtpZihudWxsIT10aGlzLm1vdmVIYW5kbGVzKXtmb3IodmFyIGI9MDtiPHRoaXMubW92ZUhhbmRsZXMubGVuZ3RoO2IrKyl0aGlzLm1vdmVIYW5kbGVzW2JdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5tb3ZlSGFuZGxlc1tiXSk7dGhpcy5tb3ZlSGFuZGxlcz1udWxsfXRoaXMubW92ZUhhbmRsZXM9W107Zm9yKGI9MDtiPGEuZ2V0Q2hpbGRDb3VudCh0aGlzLnN0YXRlLmNlbGwpO2IrKylteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXtpZihudWxsIT1iJiZhLmlzVmVydGV4KGIuY2VsbCkpe3ZhciBlPW14VXRpbHMuY3JlYXRlSW1hZ2UoRWRpdG9yLnJvd01vdmVJbWFnZSk7ZS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO2Uuc3R5bGUuY3Vyc29yPSJwb2ludGVyIjtlLnN0eWxlLndpZHRoPSI3cHgiO2Uuc3R5bGUuaGVpZ2h0PQoiNHB4IjtlLnN0eWxlLnBhZGRpbmc9IjRweCAycHggNHB4IDJweCI7ZS5yb3dTdGF0ZT1iO214RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyhlLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuZ3JhcGgucG9wdXBNZW51SGFuZGxlci5oaWRlTWVudSgpO3RoaXMuZ3JhcGguc3RvcEVkaXRpbmcoITEpO3RoaXMuZ3JhcGguc2VsZWN0Q2VsbEZvckV2ZW50KGIuY2VsbCxhKTtteEV2ZW50LmlzUG9wdXBUcmlnZ2VyKGEpfHwodGhpcy5ncmFwaC5ncmFwaEhhbmRsZXIuc3RhcnQodGhpcy5zdGF0ZS5jZWxsLG14RXZlbnQuZ2V0Q2xpZW50WChhKSxteEV2ZW50LmdldENsaWVudFkoYSksdGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25DZWxscygpKSx0aGlzLmdyYXBoLmdyYXBoSGFuZGxlci5jZWxsV2FzQ2xpY2tlZD0hMCx0aGlzLmdyYXBoLmlzTW91c2VUcmlnZ2VyPW14RXZlbnQuaXNNb3VzZUV2ZW50KGEpLHRoaXMuZ3JhcGguaXNNb3VzZURvd249ITApO214RXZlbnQuY29uc3VtZShhKX0pLApudWxsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe214RXZlbnQuaXNQb3B1cFRyaWdnZXIoYSkmJih0aGlzLmdyYXBoLnBvcHVwTWVudUhhbmRsZXIucG9wdXAobXhFdmVudC5nZXRDbGllbnRYKGEpLG14RXZlbnQuZ2V0Q2xpZW50WShhKSxiLmNlbGwsYSksbXhFdmVudC5jb25zdW1lKGEpKX0pKTt0aGlzLm1vdmVIYW5kbGVzLnB1c2goZSk7dGhpcy5ncmFwaC5jb250YWluZXIuYXBwZW5kQ2hpbGQoZSl9fSkodGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKGEuZ2V0Q2hpbGRBdCh0aGlzLnN0YXRlLmNlbGwsYikpKX07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5yZWZyZXNoPWZ1bmN0aW9uKCl7aWYobnVsbCE9dGhpcy5jdXN0b21IYW5kbGVzKXtmb3IodmFyIGE9MDthPHRoaXMuY3VzdG9tSGFuZGxlcy5sZW5ndGg7YSsrKXRoaXMuY3VzdG9tSGFuZGxlc1thXS5kZXN0cm95KCk7dGhpcy5jdXN0b21IYW5kbGVzPXRoaXMuY3JlYXRlQ3VzdG9tSGFuZGxlcygpfXRoaXMuZ3JhcGguaXNUYWJsZSh0aGlzLnN0YXRlLmNlbGwpJiYKdGhpcy5yZWZyZXNoTW92ZUhhbmRsZXMoKX07dmFyIE09bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5nZXRIYW5kbGVQYWRkaW5nO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuZ2V0SGFuZGxlUGFkZGluZz1mdW5jdGlvbigpe3ZhciBhPW5ldyBteFBvaW50KDAsMCksYj10aGlzLnRvbGVyYW5jZSxlPXRoaXMuc3RhdGUuc3R5bGUuc2hhcGU7bnVsbD09bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlc1tlXSYmbXhTdGVuY2lsUmVnaXN0cnkuZ2V0U3RlbmNpbChlKTtlPXRoaXMuZ3JhcGguaXNUYWJsZSh0aGlzLnN0YXRlLmNlbGwpfHx0aGlzLmdyYXBoLmNlbGxFZGl0b3IuZ2V0RWRpdGluZ0NlbGwoKT09dGhpcy5zdGF0ZS5jZWxsO2lmKCFlJiZudWxsIT10aGlzLmN1c3RvbUhhbmRsZXMpZm9yKHZhciBjPTA7Yzx0aGlzLmN1c3RvbUhhbmRsZXMubGVuZ3RoO2MrKylpZihudWxsIT10aGlzLmN1c3RvbUhhbmRsZXNbY10uc2hhcGUmJm51bGwhPXRoaXMuY3VzdG9tSGFuZGxlc1tjXS5zaGFwZS5ib3VuZHMpe3ZhciBkPQp0aGlzLmN1c3RvbUhhbmRsZXNbY10uc2hhcGUuYm91bmRzLGY9ZC5nZXRDZW50ZXJYKCksZz1kLmdldENlbnRlclkoKTtpZihNYXRoLmFicyh0aGlzLnN0YXRlLngtZik8ZC53aWR0aC8yfHxNYXRoLmFicyh0aGlzLnN0YXRlLnktZyk8ZC5oZWlnaHQvMnx8TWF0aC5hYnModGhpcy5zdGF0ZS54K3RoaXMuc3RhdGUud2lkdGgtZik8ZC53aWR0aC8yfHxNYXRoLmFicyh0aGlzLnN0YXRlLnkrdGhpcy5zdGF0ZS5oZWlnaHQtZyk8ZC5oZWlnaHQvMil7ZT0hMDticmVha319ZSYmbnVsbCE9dGhpcy5zaXplcnMmJjA8dGhpcy5zaXplcnMubGVuZ3RoJiZudWxsIT10aGlzLnNpemVyc1swXT8oYi89Mix0aGlzLmdyYXBoLmlzVGFibGUodGhpcy5zdGF0ZS5jZWxsKSYmKGIrPTcpLGEueD10aGlzLnNpemVyc1swXS5ib3VuZHMud2lkdGgrYixhLnk9dGhpcy5zaXplcnNbMF0uYm91bmRzLmhlaWdodCtiKTphPU0uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiBhfTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZUhpbnQ9CmZ1bmN0aW9uKGIpe2lmKHRoaXMuaW5kZXghPW14RXZlbnQuTEFCRUxfSEFORExFKXtudWxsPT10aGlzLmhpbnQmJih0aGlzLmhpbnQ9YSgpLHRoaXMuc3RhdGUudmlldy5ncmFwaC5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5oaW50KSk7aWYodGhpcy5pbmRleD09bXhFdmVudC5ST1RBVElPTl9IQU5ETEUpdGhpcy5oaW50LmlubmVySFRNTD10aGlzLmN1cnJlbnRBbHBoYSsiJmRlZzsiO2Vsc2V7Yj10aGlzLnN0YXRlLnZpZXcuc2NhbGU7dmFyIGU9dGhpcy5zdGF0ZS52aWV3LnVuaXQ7dGhpcy5oaW50LmlubmVySFRNTD1jKHRoaXMucm91bmRMZW5ndGgodGhpcy5ib3VuZHMud2lkdGgvYiksZSkrIiB4ICIrYyh0aGlzLnJvdW5kTGVuZ3RoKHRoaXMuYm91bmRzLmhlaWdodC9iKSxlKX1iPW14VXRpbHMuZ2V0Qm91bmRpbmdCb3godGhpcy5ib3VuZHMsbnVsbCE9dGhpcy5jdXJyZW50QWxwaGE/dGhpcy5jdXJyZW50QWxwaGE6dGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTl18fAoiMCIpO251bGw9PWImJihiPXRoaXMuYm91bmRzKTt0aGlzLmhpbnQuc3R5bGUubGVmdD1iLngrTWF0aC5yb3VuZCgoYi53aWR0aC10aGlzLmhpbnQuY2xpZW50V2lkdGgpLzIpKyJweCI7dGhpcy5oaW50LnN0eWxlLnRvcD1iLnkrYi5oZWlnaHQrRWRpdG9yLmhpbnRPZmZzZXQrInB4IjtudWxsIT10aGlzLmxpbmtIaW50JiYodGhpcy5saW5rSGludC5zdHlsZS5kaXNwbGF5PSJub25lIil9fTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJlbW92ZUhpbnQ9ZnVuY3Rpb24oKXtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUucmVtb3ZlSGludC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbCE9dGhpcy5saW5rSGludCYmKHRoaXMubGlua0hpbnQuc3R5bGUuZGlzcGxheT0iIil9O3ZhciBQPW14RWRnZUhhbmRsZXIucHJvdG90eXBlLm1vdXNlTW92ZTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5tb3VzZU1vdmU9ZnVuY3Rpb24oYSxiKXtQLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtudWxsIT0KdGhpcy5ncmFwaC5ncmFwaEhhbmRsZXImJm51bGwhPXRoaXMuZ3JhcGguZ3JhcGhIYW5kbGVyLmZpcnN0JiZudWxsIT10aGlzLmxpbmtIaW50JiYibm9uZSIhPXRoaXMubGlua0hpbnQuc3R5bGUuZGlzcGxheSYmKHRoaXMubGlua0hpbnQuc3R5bGUuZGlzcGxheT0ibm9uZSIpfTt2YXIgST1teEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5tb3VzZVVwO214RWRnZUhhbmRsZXIucHJvdG90eXBlLm1vdXNlVXA9ZnVuY3Rpb24oYSxiKXtJLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtudWxsIT10aGlzLmxpbmtIaW50JiYibm9uZSI9PXRoaXMubGlua0hpbnQuc3R5bGUuZGlzcGxheSYmKHRoaXMubGlua0hpbnQuc3R5bGUuZGlzcGxheT0iIil9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZUhpbnQ9ZnVuY3Rpb24oYixlKXtudWxsPT10aGlzLmhpbnQmJih0aGlzLmhpbnQ9YSgpLHRoaXMuc3RhdGUudmlldy5ncmFwaC5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5oaW50KSk7dmFyIGQ9CnRoaXMuZ3JhcGgudmlldy50cmFuc2xhdGUsZj10aGlzLmdyYXBoLnZpZXcuc2NhbGUsZz10aGlzLnJvdW5kTGVuZ3RoKGUueC9mLWQueCksZD10aGlzLnJvdW5kTGVuZ3RoKGUueS9mLWQueSksZj10aGlzLmdyYXBoLnZpZXcudW5pdDt0aGlzLmhpbnQuaW5uZXJIVE1MPWMoZyxmKSsiLCAiK2MoZCxmKTt0aGlzLmhpbnQuc3R5bGUudmlzaWJpbGl0eT0idmlzaWJsZSI7aWYodGhpcy5pc1NvdXJjZXx8dGhpcy5pc1RhcmdldCludWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRDb25zdHJhaW50JiZudWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRGb2N1cz8oZz10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRDb25zdHJhaW50LnBvaW50LHRoaXMuaGludC5pbm5lckhUTUw9IlsiK01hdGgucm91bmQoMTAwKmcueCkrIiUsICIrTWF0aC5yb3VuZCgxMDAqZy55KSsiJV0iKTp0aGlzLm1hcmtlci5oYXNWYWxpZFN0YXRlKCkmJih0aGlzLmhpbnQuc3R5bGUudmlzaWJpbGl0eT0KImhpZGRlbiIpO3RoaXMuaGludC5zdHlsZS5sZWZ0PU1hdGgucm91bmQoYi5nZXRHcmFwaFgoKS10aGlzLmhpbnQuY2xpZW50V2lkdGgvMikrInB4Ijt0aGlzLmhpbnQuc3R5bGUudG9wPU1hdGgubWF4KGIuZ2V0R3JhcGhZKCksZS55KStFZGl0b3IuaGludE9mZnNldCsicHgiO251bGwhPXRoaXMubGlua0hpbnQmJih0aGlzLmxpbmtIaW50LnN0eWxlLmRpc3BsYXk9Im5vbmUiKX07bXhFZGdlSGFuZGxlci5wcm90b3R5cGUucmVtb3ZlSGludD1teFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJlbW92ZUhpbnQ7SG92ZXJJY29ucy5wcm90b3R5cGUubWFpbkhhbmRsZT1teENsaWVudC5JU19TVkc/R3JhcGguY3JlYXRlU3ZnSW1hZ2UoMTgsMTgsJzxjaXJjbGUgY3g9IjkiIGN5PSI5IiByPSI1IiBzdHJva2U9IiNmZmYiIGZpbGw9IicrSG92ZXJJY29ucy5wcm90b3R5cGUuYXJyb3dGaWxsKyciIHN0cm9rZS13aWR0aD0iMSIvPicpOm5ldyBteEltYWdlKElNQUdFX1BBVEgrIi9oYW5kbGUtbWFpbi5wbmciLAoxNywxNyk7SG92ZXJJY29ucy5wcm90b3R5cGUuc2Vjb25kYXJ5SGFuZGxlPW14Q2xpZW50LklTX1NWRz9HcmFwaC5jcmVhdGVTdmdJbWFnZSgxNiwxNiwnPHBhdGggZD0ibSA4IDMgTCAxMyA4IEwgOCAxMyBMIDMgOCB6IiBzdHJva2U9IiNmZmYiIGZpbGw9IiNmY2EwMDAiLz4nKTpuZXcgbXhJbWFnZShJTUFHRV9QQVRIKyIvaGFuZGxlLXNlY29uZGFyeS5wbmciLDE3LDE3KTtIb3Zlckljb25zLnByb3RvdHlwZS5maXhlZEhhbmRsZT1teENsaWVudC5JU19TVkc/R3JhcGguY3JlYXRlU3ZnSW1hZ2UoMTgsMTgsJzxjaXJjbGUgY3g9IjkiIGN5PSI5IiByPSI1IiBzdHJva2U9IiNmZmYiIGZpbGw9IicrSG92ZXJJY29ucy5wcm90b3R5cGUuYXJyb3dGaWxsKyciIHN0cm9rZS13aWR0aD0iMSIvPjxwYXRoIGQ9Im0gNyA3IEwgMTEgMTEgTSA3IDExIEwgMTEgNyIgc3Ryb2tlPSIjZmZmIi8+Jyk6bmV3IG14SW1hZ2UoSU1BR0VfUEFUSCsiL2hhbmRsZS1maXhlZC5wbmciLDE3LDE3KTtIb3Zlckljb25zLnByb3RvdHlwZS50ZXJtaW5hbEhhbmRsZT0KbXhDbGllbnQuSVNfU1ZHP0dyYXBoLmNyZWF0ZVN2Z0ltYWdlKDE4LDE4LCc8Y2lyY2xlIGN4PSI5IiBjeT0iOSIgcj0iNSIgc3Ryb2tlPSIjZmZmIiBmaWxsPSInK0hvdmVySWNvbnMucHJvdG90eXBlLmFycm93RmlsbCsnIiBzdHJva2Utd2lkdGg9IjEiLz48Y2lyY2xlIGN4PSI5IiBjeT0iOSIgcj0iMiIgc3Ryb2tlPSIjZmZmIiBmaWxsPSJ0cmFuc3BhcmVudCIvPicpOm5ldyBteEltYWdlKElNQUdFX1BBVEgrIi9oYW5kbGUtdGVybWluYWwucG5nIiwxNywxNyk7SG92ZXJJY29ucy5wcm90b3R5cGUucm90YXRpb25IYW5kbGU9bXhDbGllbnQuSVNfU1ZHP0dyYXBoLmNyZWF0ZVN2Z0ltYWdlKDE2LDE2LCc8cGF0aCBzdHJva2U9IicrSG92ZXJJY29ucy5wcm90b3R5cGUuYXJyb3dGaWxsKyciIGZpbGw9IicrSG92ZXJJY29ucy5wcm90b3R5cGUuYXJyb3dGaWxsKyciIGQ9Ik0xNS41NSA1LjU1TDExIDF2My4wN0M3LjA2IDQuNTYgNCA3LjkyIDQgMTJzMy4wNSA3LjQ0IDcgNy45M3YtMi4wMmMtMi44NC0uNDgtNS0yLjk0LTUtNS45MXMyLjE2LTUuNDMgNS01LjkxVjEwbDQuNTUtNC40NXpNMTkuOTMgMTFjLS4xNy0xLjM5LS43Mi0yLjczLTEuNjItMy44OWwtMS40MiAxLjQyYy41NC43NS44OCAxLjYgMS4wMiAyLjQ3aDIuMDJ6TTEzIDE3Ljl2Mi4wMmMxLjM5LS4xNyAyLjc0LS43MSAzLjktMS42MWwtMS40NC0xLjQ0Yy0uNzUuNTQtMS41OS44OS0yLjQ2IDEuMDN6bTMuODktMi40MmwxLjQyIDEuNDFjLjktMS4xNiAxLjQ1LTIuNSAxLjYyLTMuODloLTIuMDJjLS4xNC44Ny0uNDggMS43Mi0xLjAyIDIuNDh6Ii8+JywKMjQsMjQpOm5ldyBteEltYWdlKElNQUdFX1BBVEgrIi9oYW5kbGUtcm90YXRlLnBuZyIsMTYsMTYpO214Q2xpZW50LklTX1NWRyYmKG14Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLnBvaW50SW1hZ2U9R3JhcGguY3JlYXRlU3ZnSW1hZ2UoNSw1LCc8cGF0aCBkPSJtIDAgMCBMIDUgNSBNIDAgNSBMIDUgMCIgc3Ryb2tlPSInK0hvdmVySWNvbnMucHJvdG90eXBlLmFycm93RmlsbCsnIi8+JykpO214VmVydGV4SGFuZGxlci5UQUJMRV9IQU5ETEVfQ09MT1I9IiNmY2EwMDAiO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlSW1hZ2U9SG92ZXJJY29ucy5wcm90b3R5cGUubWFpbkhhbmRsZTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnNlY29uZGFyeUhhbmRsZUltYWdlPUhvdmVySWNvbnMucHJvdG90eXBlLnNlY29uZGFyeUhhbmRsZTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVJbWFnZT1Ib3Zlckljb25zLnByb3RvdHlwZS5tYWluSGFuZGxlO214RWRnZUhhbmRsZXIucHJvdG90eXBlLnRlcm1pbmFsSGFuZGxlSW1hZ2U9CkhvdmVySWNvbnMucHJvdG90eXBlLnRlcm1pbmFsSGFuZGxlO214RWRnZUhhbmRsZXIucHJvdG90eXBlLmZpeGVkSGFuZGxlSW1hZ2U9SG92ZXJJY29ucy5wcm90b3R5cGUuZml4ZWRIYW5kbGU7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUubGFiZWxIYW5kbGVJbWFnZT1Ib3Zlckljb25zLnByb3RvdHlwZS5zZWNvbmRhcnlIYW5kbGU7bXhPdXRsaW5lLnByb3RvdHlwZS5zaXplckltYWdlPUhvdmVySWNvbnMucHJvdG90eXBlLm1haW5IYW5kbGU7bnVsbCE9d2luZG93LlNpZGViYXImJihTaWRlYmFyLnByb3RvdHlwZS50cmlhbmdsZVVwPUhvdmVySWNvbnMucHJvdG90eXBlLnRyaWFuZ2xlVXAsU2lkZWJhci5wcm90b3R5cGUudHJpYW5nbGVSaWdodD1Ib3Zlckljb25zLnByb3RvdHlwZS50cmlhbmdsZVJpZ2h0LFNpZGViYXIucHJvdG90eXBlLnRyaWFuZ2xlRG93bj1Ib3Zlckljb25zLnByb3RvdHlwZS50cmlhbmdsZURvd24sU2lkZWJhci5wcm90b3R5cGUudHJpYW5nbGVMZWZ0PUhvdmVySWNvbnMucHJvdG90eXBlLnRyaWFuZ2xlTGVmdCwKU2lkZWJhci5wcm90b3R5cGUucmVmcmVzaFRhcmdldD1Ib3Zlckljb25zLnByb3RvdHlwZS5yZWZyZXNoVGFyZ2V0LFNpZGViYXIucHJvdG90eXBlLnJvdW5kRHJvcD1Ib3Zlckljb25zLnByb3RvdHlwZS5yb3VuZERyb3ApO214Q2xpZW50LklTX1NWR3x8KChuZXcgSW1hZ2UpLnNyYz1Ib3Zlckljb25zLnByb3RvdHlwZS5tYWluSGFuZGxlLnNyYywobmV3IEltYWdlKS5zcmM9SG92ZXJJY29ucy5wcm90b3R5cGUuZml4ZWRIYW5kbGUuc3JjLChuZXcgSW1hZ2UpLnNyYz1Ib3Zlckljb25zLnByb3RvdHlwZS50ZXJtaW5hbEhhbmRsZS5zcmMsKG5ldyBJbWFnZSkuc3JjPUhvdmVySWNvbnMucHJvdG90eXBlLnNlY29uZGFyeUhhbmRsZS5zcmMsKG5ldyBJbWFnZSkuc3JjPUhvdmVySWNvbnMucHJvdG90eXBlLnJvdGF0aW9uSGFuZGxlLnNyYywobmV3IEltYWdlKS5zcmM9SG92ZXJJY29ucy5wcm90b3R5cGUudHJpYW5nbGVVcC5zcmMsKG5ldyBJbWFnZSkuc3JjPUhvdmVySWNvbnMucHJvdG90eXBlLnRyaWFuZ2xlUmlnaHQuc3JjLAoobmV3IEltYWdlKS5zcmM9SG92ZXJJY29ucy5wcm90b3R5cGUudHJpYW5nbGVEb3duLnNyYywobmV3IEltYWdlKS5zcmM9SG92ZXJJY29ucy5wcm90b3R5cGUudHJpYW5nbGVMZWZ0LnNyYywobmV3IEltYWdlKS5zcmM9SG92ZXJJY29ucy5wcm90b3R5cGUucmVmcmVzaFRhcmdldC5zcmMsKG5ldyBJbWFnZSkuc3JjPUhvdmVySWNvbnMucHJvdG90eXBlLnJvdW5kRHJvcC5zcmMpO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUucm90YXRpb25FbmFibGVkPSEwO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUubWFuYWdlU2l6ZXJzPSEwO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUubGl2ZVByZXZpZXc9ITA7bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLm1heExpdmVQcmV2aWV3PTE2O214UnViYmVyYmFuZC5wcm90b3R5cGUuZGVmYXVsdE9wYWNpdHk9MzA7bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUub3V0bGluZUNvbm5lY3Q9ITA7bXhDZWxsSGlnaGxpZ2h0LnByb3RvdHlwZS5rZWVwT25Ub3A9CiEwO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUucGFyZW50SGlnaGxpZ2h0RW5hYmxlZD0hMDtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5wYXJlbnRIaWdobGlnaHRFbmFibGVkPSEwO214RWRnZUhhbmRsZXIucHJvdG90eXBlLmRibENsaWNrUmVtb3ZlRW5hYmxlZD0hMDtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5zdHJhaWdodFJlbW92ZUVuYWJsZWQ9ITA7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUudmlydHVhbEJlbmRzRW5hYmxlZD0hMDtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5tZXJnZVJlbW92ZUVuYWJsZWQ9ITA7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUubWFuYWdlTGFiZWxIYW5kbGU9ITA7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUub3V0bGluZUNvbm5lY3Q9ITA7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuaXNBZGRWaXJ0dWFsQmVuZEV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiFteEV2ZW50LmlzU2hpZnREb3duKGEuZ2V0RXZlbnQoKSl9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmlzQ3VzdG9tSGFuZGxlRXZlbnQ9CmZ1bmN0aW9uKGEpe3JldHVybiFteEV2ZW50LmlzU2hpZnREb3duKGEuZ2V0RXZlbnQoKSl9O2lmKEdyYXBoLnRvdWNoU3R5bGUpe2lmKG14Q2xpZW50LklTX1RPVUNIfHwwPG5hdmlnYXRvci5tYXhUb3VjaFBvaW50c3x8MDxuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cylteFNoYXBlLnByb3RvdHlwZS5zdmdTdHJva2VUb2xlcmFuY2U9MTgsbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS50b2xlcmFuY2U9MTIsbXhFZGdlSGFuZGxlci5wcm90b3R5cGUudG9sZXJhbmNlPTEyLEdyYXBoLnByb3RvdHlwZS50b2xlcmFuY2U9MTIsbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5yb3RhdGlvbkhhbmRsZVZTcGFjaW5nPS0xNixteENvbnN0cmFpbnRIYW5kbGVyLnByb3RvdHlwZS5nZXRUb2xlcmFuY2U9ZnVuY3Rpb24oYSl7cmV0dXJuIG14RXZlbnQuaXNNb3VzZUV2ZW50KGEuZ2V0RXZlbnQoKSk/NDp0aGlzLmdyYXBoLmdldFRvbGVyYW5jZSgpfTtteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5pc1Bhbm5pbmdUcmlnZ2VyPQpmdW5jdGlvbihhKXt2YXIgYj1hLmdldEV2ZW50KCk7cmV0dXJuIG51bGw9PWEuZ2V0U3RhdGUoKSYmIW14RXZlbnQuaXNNb3VzZUV2ZW50KGIpfHxteEV2ZW50LmlzUG9wdXBUcmlnZ2VyKGIpJiYobnVsbD09YS5nZXRTdGF0ZSgpfHxteEV2ZW50LmlzQ29udHJvbERvd24oYil8fG14RXZlbnQuaXNTaGlmdERvd24oYikpfTt2YXIgUj1teEdyYXBoSGFuZGxlci5wcm90b3R5cGUubW91c2VEb3duO214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5tb3VzZURvd249ZnVuY3Rpb24oYSxiKXtSLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtteEV2ZW50LmlzVG91Y2hFdmVudChiLmdldEV2ZW50KCkpJiZ0aGlzLmdyYXBoLmlzQ2VsbFNlbGVjdGVkKGIuZ2V0Q2VsbCgpKSYmMTx0aGlzLmdyYXBoLmdldFNlbGVjdGlvbkNvdW50KCkmJih0aGlzLmRlbGF5ZWRTZWxlY3Rpb249ITEpfX1lbHNlIG14UGFubmluZ0hhbmRsZXIucHJvdG90eXBlLmlzUGFubmluZ1RyaWdnZXI9ZnVuY3Rpb24oYSl7dmFyIGI9CmEuZ2V0RXZlbnQoKTtyZXR1cm4gbXhFdmVudC5pc0xlZnRNb3VzZUJ1dHRvbihiKSYmKHRoaXMudXNlTGVmdEJ1dHRvbkZvclBhbm5pbmcmJm51bGw9PWEuZ2V0U3RhdGUoKXx8bXhFdmVudC5pc0NvbnRyb2xEb3duKGIpJiYhbXhFdmVudC5pc1NoaWZ0RG93bihiKSl8fHRoaXMudXNlUG9wdXBUcmlnZ2VyJiZteEV2ZW50LmlzUG9wdXBUcmlnZ2VyKGIpfTtteFJ1YmJlcmJhbmQucHJvdG90eXBlLmlzU3BhY2VFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5ncmFwaC5pc0VuYWJsZWQoKSYmIXRoaXMuZ3JhcGguaXNDZWxsTG9ja2VkKHRoaXMuZ3JhcGguZ2V0RGVmYXVsdFBhcmVudCgpKSYmbXhFdmVudC5pc0NvbnRyb2xEb3duKGEuZ2V0RXZlbnQoKSkmJm14RXZlbnQuaXNTaGlmdERvd24oYS5nZXRFdmVudCgpKX07bXhSdWJiZXJiYW5kLnByb3RvdHlwZS5jYW5jZWxsZWQ9ITE7bXhSdWJiZXJiYW5kLnByb3RvdHlwZS5jYW5jZWw9ZnVuY3Rpb24oKXt0aGlzLmlzQWN0aXZlKCkmJgoodGhpcy5jYW5jZWxsZWQ9ITAsdGhpcy5yZXNldCgpKX07bXhSdWJiZXJiYW5kLnByb3RvdHlwZS5tb3VzZVVwPWZ1bmN0aW9uKGEsYil7aWYodGhpcy5jYW5jZWxsZWQpdGhpcy5jYW5jZWxsZWQ9ITEsYi5jb25zdW1lKCk7ZWxzZXt2YXIgZT1udWxsIT10aGlzLmRpdiYmIm5vbmUiIT10aGlzLmRpdi5zdHlsZS5kaXNwbGF5LGM9bnVsbCxkPW51bGwsZj1udWxsLGc9bnVsbDtudWxsIT10aGlzLmZpcnN0JiZudWxsIT10aGlzLmN1cnJlbnRYJiZudWxsIT10aGlzLmN1cnJlbnRZJiYoYz10aGlzLmZpcnN0LngsZD10aGlzLmZpcnN0LnksZj0odGhpcy5jdXJyZW50WC1jKS90aGlzLmdyYXBoLnZpZXcuc2NhbGUsZz0odGhpcy5jdXJyZW50WS1kKS90aGlzLmdyYXBoLnZpZXcuc2NhbGUsbXhFdmVudC5pc0FsdERvd24oYi5nZXRFdmVudCgpKXx8KGY9dGhpcy5ncmFwaC5zbmFwKGYpLGc9dGhpcy5ncmFwaC5zbmFwKGcpLHRoaXMuZ3JhcGguaXNHcmlkRW5hYmxlZCgpfHwoTWF0aC5hYnMoZik8CnRoaXMuZ3JhcGgudG9sZXJhbmNlJiYoZj0wKSxNYXRoLmFicyhnKTx0aGlzLmdyYXBoLnRvbGVyYW5jZSYmKGc9MCkpKSk7dGhpcy5yZXNldCgpO2lmKGUpe2lmKG14RXZlbnQuaXNBbHREb3duKGIuZ2V0RXZlbnQoKSkmJnRoaXMuZ3JhcGguaXNUb2dnbGVFdmVudChiLmdldEV2ZW50KCkpKXt2YXIgZj1uZXcgbXhSZWN0YW5nbGUodGhpcy54LHRoaXMueSx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxsPXRoaXMuZ3JhcGguZ2V0Q2VsbHMoZi54LGYueSxmLndpZHRoLGYuaGVpZ2h0KTt0aGlzLmdyYXBoLnJlbW92ZVNlbGVjdGlvbkNlbGxzKGwpfWVsc2UgaWYodGhpcy5pc1NwYWNlRXZlbnQoYikpe3RoaXMuZ3JhcGgubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKGw9dGhpcy5ncmFwaC5nZXRDZWxsc0JleW9uZChjLGQsdGhpcy5ncmFwaC5nZXREZWZhdWx0UGFyZW50KCksITAsITApLGU9MDtlPGwubGVuZ3RoO2UrKylpZih0aGlzLmdyYXBoLmlzQ2VsbE1vdmFibGUobFtlXSkpe3ZhciBwPQp0aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUobFtlXSksdT10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShsW2VdKTtudWxsIT1wJiZudWxsIT11JiYodT11LmNsb25lKCksdS50cmFuc2xhdGUoZixnKSx0aGlzLmdyYXBoLm1vZGVsLnNldEdlb21ldHJ5KGxbZV0sdSkpfX1maW5hbGx5e3RoaXMuZ3JhcGgubW9kZWwuZW5kVXBkYXRlKCl9fWVsc2UgZj1uZXcgbXhSZWN0YW5nbGUodGhpcy54LHRoaXMueSx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLmdyYXBoLnNlbGVjdFJlZ2lvbihmLGIuZ2V0RXZlbnQoKSk7Yi5jb25zdW1lKCl9fX07bXhSdWJiZXJiYW5kLnByb3RvdHlwZS5tb3VzZU1vdmU9ZnVuY3Rpb24oYSxiKXtpZighYi5pc0NvbnN1bWVkKCkmJm51bGwhPXRoaXMuZmlyc3Qpe3ZhciBlPW14VXRpbHMuZ2V0U2Nyb2xsT3JpZ2luKHRoaXMuZ3JhcGguY29udGFpbmVyKSxjPW14VXRpbHMuZ2V0T2Zmc2V0KHRoaXMuZ3JhcGguY29udGFpbmVyKTtlLngtPWMueDtlLnktPWMueTsKdmFyIGM9Yi5nZXRYKCkrZS54LGU9Yi5nZXRZKCkrZS55LGQ9dGhpcy5maXJzdC54LWMsZj10aGlzLmZpcnN0LnktZSxnPXRoaXMuZ3JhcGgudG9sZXJhbmNlO2lmKG51bGwhPXRoaXMuZGl2fHxNYXRoLmFicyhkKT5nfHxNYXRoLmFicyhmKT5nKW51bGw9PXRoaXMuZGl2JiYodGhpcy5kaXY9dGhpcy5jcmVhdGVTaGFwZSgpKSxteFV0aWxzLmNsZWFyU2VsZWN0aW9uKCksdGhpcy51cGRhdGUoYyxlKSx0aGlzLmlzU3BhY2VFdmVudChiKT8oYz10aGlzLngrdGhpcy53aWR0aCxlPXRoaXMueSt0aGlzLmhlaWdodCxkPXRoaXMuZ3JhcGgudmlldy5zY2FsZSxteEV2ZW50LmlzQWx0RG93bihiLmdldEV2ZW50KCkpfHwodGhpcy53aWR0aD10aGlzLmdyYXBoLnNuYXAodGhpcy53aWR0aC9kKSpkLHRoaXMuaGVpZ2h0PXRoaXMuZ3JhcGguc25hcCh0aGlzLmhlaWdodC9kKSpkLHRoaXMuZ3JhcGguaXNHcmlkRW5hYmxlZCgpfHwodGhpcy53aWR0aDx0aGlzLmdyYXBoLnRvbGVyYW5jZSYmKHRoaXMud2lkdGg9CjApLHRoaXMuaGVpZ2h0PHRoaXMuZ3JhcGgudG9sZXJhbmNlJiYodGhpcy5oZWlnaHQ9MCkpLHRoaXMueDx0aGlzLmZpcnN0LngmJih0aGlzLng9Yy10aGlzLndpZHRoKSx0aGlzLnk8dGhpcy5maXJzdC55JiYodGhpcy55PWUtdGhpcy5oZWlnaHQpKSx0aGlzLmRpdi5zdHlsZS5ib3JkZXJTdHlsZT0iZGFzaGVkIix0aGlzLmRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9IndoaXRlIix0aGlzLmRpdi5zdHlsZS5sZWZ0PXRoaXMueCsicHgiLHRoaXMuZGl2LnN0eWxlLnRvcD10aGlzLnkrInB4Iix0aGlzLmRpdi5zdHlsZS53aWR0aD1NYXRoLm1heCgwLHRoaXMud2lkdGgpKyJweCIsdGhpcy5kaXYuc3R5bGUuaGVpZ2h0PXRoaXMuZ3JhcGguY29udGFpbmVyLmNsaWVudEhlaWdodCsicHgiLHRoaXMuZGl2LnN0eWxlLmJvcmRlcldpZHRoPTA+PXRoaXMud2lkdGg/IjBweCAxcHggMHB4IDBweCI6IjBweCAxcHggMHB4IDFweCIsbnVsbD09dGhpcy5zZWNvbmREaXYmJih0aGlzLnNlY29uZERpdj0KdGhpcy5kaXYuY2xvbmVOb2RlKCEwKSx0aGlzLmRpdi5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMuc2Vjb25kRGl2KSksdGhpcy5zZWNvbmREaXYuc3R5bGUubGVmdD10aGlzLngrInB4Iix0aGlzLnNlY29uZERpdi5zdHlsZS50b3A9dGhpcy55KyJweCIsdGhpcy5zZWNvbmREaXYuc3R5bGUud2lkdGg9dGhpcy5ncmFwaC5jb250YWluZXIuY2xpZW50V2lkdGgrInB4Iix0aGlzLnNlY29uZERpdi5zdHlsZS5oZWlnaHQ9TWF0aC5tYXgoMCx0aGlzLmhlaWdodCkrInB4Iix0aGlzLnNlY29uZERpdi5zdHlsZS5ib3JkZXJXaWR0aD0wPj10aGlzLmhlaWdodD8iMXB4IDBweCAwcHggMHB4IjoiMXB4IDBweCAxcHggMHB4Iik6KHRoaXMuZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvcj0iIix0aGlzLmRpdi5zdHlsZS5ib3JkZXJXaWR0aD0iIix0aGlzLmRpdi5zdHlsZS5ib3JkZXJTdHlsZT0iIixudWxsIT10aGlzLnNlY29uZERpdiYmKHRoaXMuc2Vjb25kRGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zZWNvbmREaXYpLAp0aGlzLnNlY29uZERpdj1udWxsKSksYi5jb25zdW1lKCl9fTt2YXIgZWE9bXhSdWJiZXJiYW5kLnByb3RvdHlwZS5yZXNldDtteFJ1YmJlcmJhbmQucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5zZWNvbmREaXYmJih0aGlzLnNlY29uZERpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2Vjb25kRGl2KSx0aGlzLnNlY29uZERpdj1udWxsKTtlYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBmYT0obmV3IERhdGUpLmdldFRpbWUoKSxZPTAsWj1teEVkZ2VIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVQcmV2aWV3U3RhdGU7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUudXBkYXRlUHJldmlld1N0YXRlPWZ1bmN0aW9uKGEsYixlLGMpe1ouYXBwbHkodGhpcyxhcmd1bWVudHMpO2UhPXRoaXMuY3VycmVudFRlcm1pbmFsU3RhdGU/KGZhPShuZXcgRGF0ZSkuZ2V0VGltZSgpLFk9MCk6WT0obmV3IERhdGUpLmdldFRpbWUoKS1mYTt0aGlzLmN1cnJlbnRUZXJtaW5hbFN0YXRlPQplfTt2YXIgWD1teEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5pc091dGxpbmVDb25uZWN0RXZlbnQ7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuaXNPdXRsaW5lQ29ubmVjdEV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT10aGlzLmN1cnJlbnRUZXJtaW5hbFN0YXRlJiZhLmdldFN0YXRlKCk9PXRoaXMuY3VycmVudFRlcm1pbmFsU3RhdGUmJjJFMzxZfHwobnVsbD09dGhpcy5jdXJyZW50VGVybWluYWxTdGF0ZXx8IjAiIT1teFV0aWxzLmdldFZhbHVlKHRoaXMuY3VycmVudFRlcm1pbmFsU3RhdGUuc3R5bGUsIm91dGxpbmVDb25uZWN0IiwiMSIpKSYmWC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUhhbmRsZVNoYXBlPWZ1bmN0aW9uKGEsYil7dmFyIGU9bnVsbCE9YSYmMD09YSxjPXRoaXMuc3RhdGUuZ2V0VmlzaWJsZVRlcm1pbmFsU3RhdGUoZSksZD1udWxsIT1hJiYoMD09YXx8YT49dGhpcy5zdGF0ZS5hYnNvbHV0ZVBvaW50cy5sZW5ndGgtCjF8fHRoaXMuY29uc3RydWN0b3I9PW14RWxib3dFZGdlSGFuZGxlciYmMj09YSk/dGhpcy5ncmFwaC5nZXRDb25uZWN0aW9uQ29uc3RyYWludCh0aGlzLnN0YXRlLGMsZSk6bnVsbCxlPW51bGwhPShudWxsIT1kP3RoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvblBvaW50KHRoaXMuc3RhdGUuZ2V0VmlzaWJsZVRlcm1pbmFsU3RhdGUoZSksZCk6bnVsbCk/dGhpcy5maXhlZEhhbmRsZUltYWdlOm51bGwhPWQmJm51bGwhPWM/dGhpcy50ZXJtaW5hbEhhbmRsZUltYWdlOnRoaXMuaGFuZGxlSW1hZ2U7aWYobnVsbCE9ZSlyZXR1cm4gZT1uZXcgbXhJbWFnZVNoYXBlKG5ldyBteFJlY3RhbmdsZSgwLDAsZS53aWR0aCxlLmhlaWdodCksZS5zcmMpLGUucHJlc2VydmVJbWFnZUFzcGVjdD0hMSxlO2U9bXhDb25zdGFudHMuSEFORExFX1NJWkU7dGhpcy5wcmVmZXJIdG1sJiYtLWU7cmV0dXJuIG5ldyBteFJlY3RhbmdsZVNoYXBlKG5ldyBteFJlY3RhbmdsZSgwLDAsZSxlKSxteENvbnN0YW50cy5IQU5ETEVfRklMTENPTE9SLApteENvbnN0YW50cy5IQU5ETEVfU1RST0tFQ09MT1IpfTt2YXIgYWE9bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVTaXplclNoYXBlO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuY3JlYXRlU2l6ZXJTaGFwZT1mdW5jdGlvbihhLGIsZSl7dGhpcy5oYW5kbGVJbWFnZT1iPT1teEV2ZW50LlJPVEFUSU9OX0hBTkRMRT9Ib3Zlckljb25zLnByb3RvdHlwZS5yb3RhdGlvbkhhbmRsZTpiPT1teEV2ZW50LkxBQkVMX0hBTkRMRT90aGlzLnNlY29uZGFyeUhhbmRsZUltYWdlOnRoaXMuaGFuZGxlSW1hZ2U7cmV0dXJuIGFhLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dmFyIGdhPW14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveDtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3g9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSYmMT09YS5sZW5ndGgpe3ZhciBiPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxlPWIuZ2V0UGFyZW50KGFbMF0pLGM9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoYVswXSk7CmlmKGIuaXNFZGdlKGUpJiZudWxsIT1jJiZjLnJlbGF0aXZlJiYoYj10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUoYVswXSksbnVsbCE9YiYmMj5iLndpZHRoJiYyPmIuaGVpZ2h0JiZudWxsIT1iLnRleHQmJm51bGwhPWIudGV4dC5ib3VuZGluZ0JveCkpcmV0dXJuIG14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUoYi50ZXh0LmJvdW5kaW5nQm94KX1yZXR1cm4gZ2EuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgZGE9bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmdldEd1aWRlU3RhdGVzO214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5nZXRHdWlkZVN0YXRlcz1mdW5jdGlvbigpe2Zvcih2YXIgYT1kYS5hcHBseSh0aGlzLGFyZ3VtZW50cyksYj1bXSxlPTA7ZTxhLmxlbmd0aDtlKyspIjEiIT1teFV0aWxzLmdldFZhbHVlKGFbZV0uc3R5bGUsInBhcnQiLCIwIikmJmIucHVzaChhW2VdKTtyZXR1cm4gYn07dmFyIFU9bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25Cb3VuZHM7Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uQm91bmRzPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxlPWIuZ2V0UGFyZW50KGEuY2VsbCksYz10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShhLmNlbGwpO3JldHVybiBiLmlzRWRnZShlKSYmbnVsbCE9YyYmYy5yZWxhdGl2ZSYmMj5hLndpZHRoJiYyPmEuaGVpZ2h0JiZudWxsIT1hLnRleHQmJm51bGwhPWEudGV4dC5ib3VuZGluZ0JveD8oYj1hLnRleHQudW5yb3RhdGVkQm91bmRpbmdCb3h8fGEudGV4dC5ib3VuZGluZ0JveCxuZXcgbXhSZWN0YW5nbGUoTWF0aC5yb3VuZChiLngpLE1hdGgucm91bmQoYi55KSxNYXRoLnJvdW5kKGIud2lkdGgpLE1hdGgucm91bmQoYi5oZWlnaHQpKSk6VS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBjYT1teFZlcnRleEhhbmRsZXIucHJvdG90eXBlLm1vdXNlRG93bjtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLm1vdXNlRG93bj1mdW5jdGlvbihhLApiKXt2YXIgZT10aGlzLmdyYXBoLmdldE1vZGVsKCksYz1lLmdldFBhcmVudCh0aGlzLnN0YXRlLmNlbGwpLGQ9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkodGhpcy5zdGF0ZS5jZWxsKTsodGhpcy5nZXRIYW5kbGVGb3JFdmVudChiKT09bXhFdmVudC5ST1RBVElPTl9IQU5ETEV8fCFlLmlzRWRnZShjKXx8bnVsbD09ZHx8IWQucmVsYXRpdmV8fG51bGw9PXRoaXMuc3RhdGV8fDI8PXRoaXMuc3RhdGUud2lkdGh8fDI8PXRoaXMuc3RhdGUuaGVpZ2h0KSYmY2EuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJvdGF0ZUNsaWNrPWZ1bmN0aW9uKCl7dmFyIGE9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1NUUk9LRUNPTE9SLG14Q29uc3RhbnRzLk5PTkUpLGI9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZJTExDT0xPUixteENvbnN0YW50cy5OT05FKTsKdGhpcy5zdGF0ZS52aWV3LmdyYXBoLm1vZGVsLmlzVmVydGV4KHRoaXMuc3RhdGUuY2VsbCkmJmE9PW14Q29uc3RhbnRzLk5PTkUmJmI9PW14Q29uc3RhbnRzLk5PTkU/KGE9bXhVdGlscy5tb2QobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OLDApKzkwLDM2MCksdGhpcy5zdGF0ZS52aWV3LmdyYXBoLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT04sYSxbdGhpcy5zdGF0ZS5jZWxsXSkpOnRoaXMuc3RhdGUudmlldy5ncmFwaC50dXJuU2hhcGVzKFt0aGlzLnN0YXRlLmNlbGxdKX07dmFyIFE9bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5tb3VzZU1vdmU7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5tb3VzZU1vdmU9ZnVuY3Rpb24oYSxiKXtRLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtudWxsIT10aGlzLmdyYXBoLmdyYXBoSGFuZGxlci5maXJzdCYmKG51bGwhPXRoaXMucm90YXRpb25TaGFwZSYmCm51bGwhPXRoaXMucm90YXRpb25TaGFwZS5ub2RlJiYodGhpcy5yb3RhdGlvblNoYXBlLm5vZGUuc3R5bGUuZGlzcGxheT0ibm9uZSIpLG51bGwhPXRoaXMubGlua0hpbnQmJiJub25lIiE9dGhpcy5saW5rSGludC5zdHlsZS5kaXNwbGF5JiYodGhpcy5saW5rSGludC5zdHlsZS5kaXNwbGF5PSJub25lIikpfTt2YXIgTD1teFZlcnRleEhhbmRsZXIucHJvdG90eXBlLm1vdXNlVXA7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5tb3VzZVVwPWZ1bmN0aW9uKGEsYil7TC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbCE9dGhpcy5yb3RhdGlvblNoYXBlJiZudWxsIT10aGlzLnJvdGF0aW9uU2hhcGUubm9kZSYmKHRoaXMucm90YXRpb25TaGFwZS5ub2RlLnN0eWxlLmRpc3BsYXk9MT09dGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25Db3VudCgpPyIiOiJub25lIik7bnVsbCE9dGhpcy5saW5rSGludCYmIm5vbmUiPT10aGlzLmxpbmtIaW50LnN0eWxlLmRpc3BsYXkmJih0aGlzLmxpbmtIaW50LnN0eWxlLmRpc3BsYXk9CiIiKTt0aGlzLmJsb2NrRGVsYXllZFNlbGVjdGlvbj1udWxsfTt2YXIgamE9bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5pbml0O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe2phLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgYT0hMTtudWxsIT10aGlzLnJvdGF0aW9uU2hhcGUmJnRoaXMucm90YXRpb25TaGFwZS5ub2RlLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgicm90YXRlVG9vbHRpcCIpKTtpZih0aGlzLmdyYXBoLmlzVGFibGUodGhpcy5zdGF0ZS5jZWxsKSl0aGlzLnJlZnJlc2hNb3ZlSGFuZGxlcygpO2Vsc2UgaWYoMT09dGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25Db3VudCgpJiYodGhpcy5ncmFwaC5pc1RhYmxlQ2VsbCh0aGlzLnN0YXRlLmNlbGwpfHx0aGlzLmdyYXBoLmlzVGFibGVSb3codGhpcy5zdGF0ZS5jZWxsKSkpe3RoaXMuY29ybmVySGFuZGxlcz1bXTtmb3IodmFyIGI9MDs0PmI7YisrKXt2YXIgZT1uZXcgbXhSZWN0YW5nbGVTaGFwZShuZXcgbXhSZWN0YW5nbGUoMCwKMCw2LDYpLCIjZmZmZmZmIixteENvbnN0YW50cy5IQU5ETEVfU1RST0tFQ09MT1IpO2UuZGlhbGVjdD10aGlzLmdyYXBoLmRpYWxlY3QhPW14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHP214Q29uc3RhbnRzLkRJQUxFQ1RfVk1MOm14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHO2UuaW5pdCh0aGlzLmdyYXBoLnZpZXcuZ2V0T3ZlcmxheVBhbmUoKSk7dGhpcy5jb3JuZXJIYW5kbGVzLnB1c2goZSl9fXZhciBjPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5zcGVjaWFsSGFuZGxlJiYodGhpcy5zcGVjaWFsSGFuZGxlLm5vZGUuc3R5bGUuZGlzcGxheT10aGlzLmdyYXBoLmlzRW5hYmxlZCgpJiZ0aGlzLmdyYXBoLmdldFNlbGVjdGlvbkNvdW50KCk8dGhpcy5ncmFwaC5ncmFwaEhhbmRsZXIubWF4Q2VsbHM/IiI6Im5vbmUiKTt0aGlzLnJlZHJhd0hhbmRsZXMoKX0pO3RoaXMuY2hhbmdlSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIpe3RoaXMudXBkYXRlTGlua0hpbnQodGhpcy5ncmFwaC5nZXRMaW5rRm9yQ2VsbCh0aGlzLnN0YXRlLmNlbGwpLAp0aGlzLmdyYXBoLmdldExpbmtzRm9yU3RhdGUodGhpcy5zdGF0ZSkpO2MoKX0pO3RoaXMuZ3JhcGguZ2V0U2VsZWN0aW9uTW9kZWwoKS5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSx0aGlzLmNoYW5nZUhhbmRsZXIpO3RoaXMuZ3JhcGguZ2V0TW9kZWwoKS5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSx0aGlzLmNoYW5nZUhhbmRsZXIpO3RoaXMuZWRpdGluZ0hhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiKXt0aGlzLnJlZHJhd0hhbmRsZXMoKX0pO3RoaXMuZ3JhcGguYWRkTGlzdGVuZXIobXhFdmVudC5FRElUSU5HX1NUT1BQRUQsdGhpcy5lZGl0aW5nSGFuZGxlcik7Yj10aGlzLmdyYXBoLmdldExpbmtGb3JDZWxsKHRoaXMuc3RhdGUuY2VsbCk7ZT10aGlzLmdyYXBoLmdldExpbmtzRm9yU3RhdGUodGhpcy5zdGF0ZSk7dGhpcy51cGRhdGVMaW5rSGludChiLGUpO2lmKG51bGwhPWJ8fG51bGwhPWUmJjA8ZS5sZW5ndGgpYT0hMDthJiZ0aGlzLnJlZHJhd0hhbmRsZXMoKX07Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUudXBkYXRlTGlua0hpbnQ9ZnVuY3Rpb24oYixlKXt0cnl7aWYobnVsbD09YiYmKG51bGw9PWV8fDA9PWUubGVuZ3RoKXx8MTx0aGlzLmdyYXBoLmdldFNlbGVjdGlvbkNvdW50KCkpbnVsbCE9dGhpcy5saW5rSGludCYmKHRoaXMubGlua0hpbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmxpbmtIaW50KSx0aGlzLmxpbmtIaW50PW51bGwpO2Vsc2UgaWYobnVsbCE9Ynx8bnVsbCE9ZSYmMDxlLmxlbmd0aCl7bnVsbD09dGhpcy5saW5rSGludCYmKHRoaXMubGlua0hpbnQ9YSgpLHRoaXMubGlua0hpbnQuc3R5bGUucGFkZGluZz0iNnB4IDhweCA2cHggOHB4Iix0aGlzLmxpbmtIaW50LnN0eWxlLm9wYWNpdHk9IjEiLHRoaXMubGlua0hpbnQuc3R5bGUuZmlsdGVyPSIiLHRoaXMuZ3JhcGguY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubGlua0hpbnQpKTt0aGlzLmxpbmtIaW50LmlubmVySFRNTD0iIjtpZihudWxsIT1iJiYodGhpcy5saW5rSGludC5hcHBlbmRDaGlsZCh0aGlzLmdyYXBoLmNyZWF0ZUxpbmtGb3JIaW50KGIpKSwKdGhpcy5ncmFwaC5pc0VuYWJsZWQoKSYmImZ1bmN0aW9uIj09PXR5cGVvZiB0aGlzLmdyYXBoLmVkaXRMaW5rKSl7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIik7Yy5zZXRBdHRyaWJ1dGUoInNyYyIsRWRpdG9yLmVkaXRJbWFnZSk7Yy5zZXRBdHRyaWJ1dGUoInRpdGxlIixteFJlc291cmNlcy5nZXQoImVkaXRMaW5rIikpO2Muc2V0QXR0cmlidXRlKCJ3aWR0aCIsIjExIik7Yy5zZXRBdHRyaWJ1dGUoImhlaWdodCIsIjExIik7Yy5zdHlsZS5tYXJnaW5MZWZ0PSIxMHB4IjtjLnN0eWxlLm1hcmdpbkJvdHRvbT0iLTFweCI7Yy5zdHlsZS5jdXJzb3I9InBvaW50ZXIiO3RoaXMubGlua0hpbnQuYXBwZW5kQ2hpbGQoYyk7bXhFdmVudC5hZGRMaXN0ZW5lcihjLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5ncmFwaC5zZXRTZWxlY3Rpb25DZWxsKHRoaXMuc3RhdGUuY2VsbCk7dGhpcy5ncmFwaC5lZGl0TGluaygpO214RXZlbnQuY29uc3VtZShhKX0pKTsKdmFyIGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIik7ZC5zZXRBdHRyaWJ1dGUoInNyYyIsRGlhbG9nLnByb3RvdHlwZS5jbGVhckltYWdlKTtkLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgicmVtb3ZlSXQiLFtteFJlc291cmNlcy5nZXQoImxpbmsiKV0pKTtkLnNldEF0dHJpYnV0ZSgid2lkdGgiLCIxMyIpO2Quc2V0QXR0cmlidXRlKCJoZWlnaHQiLCIxMCIpO2Quc3R5bGUubWFyZ2luTGVmdD0iNHB4IjtkLnN0eWxlLm1hcmdpbkJvdHRvbT0iLTFweCI7ZC5zdHlsZS5jdXJzb3I9InBvaW50ZXIiO3RoaXMubGlua0hpbnQuYXBwZW5kQ2hpbGQoZCk7bXhFdmVudC5hZGRMaXN0ZW5lcihkLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5ncmFwaC5zZXRMaW5rRm9yQ2VsbCh0aGlzLnN0YXRlLmNlbGwsbnVsbCk7bXhFdmVudC5jb25zdW1lKGEpfSkpfWlmKG51bGwhPWUpZm9yKGM9MDtjPGUubGVuZ3RoO2MrKyl7dmFyIGY9CmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Yuc3R5bGUubWFyZ2luVG9wPW51bGwhPWJ8fDA8Yz8iNnB4IjoiMHB4IjtmLmFwcGVuZENoaWxkKHRoaXMuZ3JhcGguY3JlYXRlTGlua0ZvckhpbnQoZVtjXS5nZXRBdHRyaWJ1dGUoImhyZWYiKSxteFV0aWxzLmdldFRleHRDb250ZW50KGVbY10pKSk7dGhpcy5saW5rSGludC5hcHBlbmRDaGlsZChmKX19fWNhdGNoKG5hKXt9fTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVMaW5rSGludD1teFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZUxpbmtIaW50O3ZhciBPPW14RWRnZUhhbmRsZXIucHJvdG90eXBlLmluaXQ7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe08uYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuY29uc3RyYWludEhhbmRsZXIuaXNFbmFibGVkPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdGUudmlldy5ncmFwaC5jb25uZWN0aW9uSGFuZGxlci5pc0VuYWJsZWQoKX0pOwp2YXIgYT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe251bGwhPXRoaXMubGlua0hpbnQmJih0aGlzLmxpbmtIaW50LnN0eWxlLmRpc3BsYXk9MT09dGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25Db3VudCgpPyIiOiJub25lIik7bnVsbCE9dGhpcy5sYWJlbFNoYXBlJiYodGhpcy5sYWJlbFNoYXBlLm5vZGUuc3R5bGUuZGlzcGxheT10aGlzLmdyYXBoLmlzRW5hYmxlZCgpJiZ0aGlzLmdyYXBoLmdldFNlbGVjdGlvbkNvdW50KCk8dGhpcy5ncmFwaC5ncmFwaEhhbmRsZXIubWF4Q2VsbHM/IiI6Im5vbmUiKX0pO3RoaXMuY2hhbmdlSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiLGUpe3RoaXMudXBkYXRlTGlua0hpbnQodGhpcy5ncmFwaC5nZXRMaW5rRm9yQ2VsbCh0aGlzLnN0YXRlLmNlbGwpLHRoaXMuZ3JhcGguZ2V0TGlua3NGb3JTdGF0ZSh0aGlzLnN0YXRlKSk7YSgpO3RoaXMucmVkcmF3SGFuZGxlcygpfSk7dGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25Nb2RlbCgpLmFkZExpc3RlbmVyKG14RXZlbnQuQ0hBTkdFLAp0aGlzLmNoYW5nZUhhbmRsZXIpO3RoaXMuZ3JhcGguZ2V0TW9kZWwoKS5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSx0aGlzLmNoYW5nZUhhbmRsZXIpO3ZhciBiPXRoaXMuZ3JhcGguZ2V0TGlua0ZvckNlbGwodGhpcy5zdGF0ZS5jZWxsKSxlPXRoaXMuZ3JhcGguZ2V0TGlua3NGb3JTdGF0ZSh0aGlzLnN0YXRlKTtpZihudWxsIT1ifHxudWxsIT1lJiYwPGUubGVuZ3RoKXRoaXMudXBkYXRlTGlua0hpbnQoYixlKSx0aGlzLnJlZHJhd0hhbmRsZXMoKX07dmFyIFM9bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuaW5pdDtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7Uy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy5jb25zdHJhaW50SGFuZGxlci5pc0VuYWJsZWQ9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmFwaC5jb25uZWN0aW9uSGFuZGxlci5pc0VuYWJsZWQoKX0pfTt2YXIgaWE9bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5yZWRyYXdIYW5kbGVzOwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJlZHJhd0hhbmRsZXM9ZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLm1vdmVIYW5kbGVzKWZvcih2YXIgYT0wO2E8dGhpcy5tb3ZlSGFuZGxlcy5sZW5ndGg7YSsrKXRoaXMubW92ZUhhbmRsZXNbYV0uc3R5bGUubGVmdD10aGlzLm1vdmVIYW5kbGVzW2FdLnJvd1N0YXRlLngrdGhpcy5tb3ZlSGFuZGxlc1thXS5yb3dTdGF0ZS53aWR0aC01KyJweCIsdGhpcy5tb3ZlSGFuZGxlc1thXS5zdHlsZS50b3A9dGhpcy5tb3ZlSGFuZGxlc1thXS5yb3dTdGF0ZS55K3RoaXMubW92ZUhhbmRsZXNbYV0ucm93U3RhdGUuaGVpZ2h0LzItNisicHgiO2lmKG51bGwhPXRoaXMuY29ybmVySGFuZGxlcyl7dmFyIGE9dGhpcy5nZXRTZWxlY3Rpb25Cb3JkZXJJbnNldCgpLGI9dGhpcy5jb3JuZXJIYW5kbGVzLGU9YlswXS5ib3VuZHMuaGVpZ2h0LzI7YlswXS5ib3VuZHMueD10aGlzLnN0YXRlLngtYlswXS5ib3VuZHMud2lkdGgvMithO2JbMF0uYm91bmRzLnk9CnRoaXMuc3RhdGUueS1lK2E7YlswXS5yZWRyYXcoKTtiWzFdLmJvdW5kcy54PWJbMF0uYm91bmRzLngrdGhpcy5zdGF0ZS53aWR0aC0yKmE7YlsxXS5ib3VuZHMueT1iWzBdLmJvdW5kcy55O2JbMV0ucmVkcmF3KCk7YlsyXS5ib3VuZHMueD1iWzBdLmJvdW5kcy54O2JbMl0uYm91bmRzLnk9dGhpcy5zdGF0ZS55K3RoaXMuc3RhdGUuaGVpZ2h0LTIqYTtiWzJdLnJlZHJhdygpO2JbM10uYm91bmRzLng9YlsxXS5ib3VuZHMueDtiWzNdLmJvdW5kcy55PWJbMl0uYm91bmRzLnk7YlszXS5yZWRyYXcoKTtmb3IoYT0wO2E8dGhpcy5jb3JuZXJIYW5kbGVzLmxlbmd0aDthKyspdGhpcy5jb3JuZXJIYW5kbGVzW2FdLm5vZGUuc3R5bGUuZGlzcGxheT0xPT10aGlzLmdyYXBoLmdldFNlbGVjdGlvbkNvdW50KCk/IiI6Im5vbmUifW51bGwhPXRoaXMucm90YXRpb25TaGFwZSYmbnVsbCE9dGhpcy5yb3RhdGlvblNoYXBlLm5vZGUmJih0aGlzLnJvdGF0aW9uU2hhcGUubm9kZS5zdHlsZS5kaXNwbGF5PQpudWxsIT10aGlzLm1vdmVIYW5kbGVzfHwxIT10aGlzLmdyYXBoLmdldFNlbGVjdGlvbkNvdW50KCl8fG51bGwhPXRoaXMuaW5kZXgmJnRoaXMuaW5kZXghPW14RXZlbnQuUk9UQVRJT05fSEFORExFPyJub25lIjoiIik7aWEuYXBwbHkodGhpcyk7bnVsbCE9dGhpcy5zdGF0ZSYmbnVsbCE9dGhpcy5saW5rSGludCYmKGE9bmV3IG14UG9pbnQodGhpcy5zdGF0ZS5nZXRDZW50ZXJYKCksdGhpcy5zdGF0ZS5nZXRDZW50ZXJZKCkpLGI9bmV3IG14UmVjdGFuZ2xlKHRoaXMuc3RhdGUueCx0aGlzLnN0YXRlLnktMjIsdGhpcy5zdGF0ZS53aWR0aCsyNCx0aGlzLnN0YXRlLmhlaWdodCsyMiksZT1teFV0aWxzLmdldEJvdW5kaW5nQm94KGIsdGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTl18fCIwIixhKSxhPW51bGwhPWU/bXhVdGlscy5nZXRCb3VuZGluZ0JveCh0aGlzLnN0YXRlLHRoaXMuc3RhdGUuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT05dfHwKIjAiKTp0aGlzLnN0YXRlLGI9bnVsbCE9dGhpcy5zdGF0ZS50ZXh0P3RoaXMuc3RhdGUudGV4dC5ib3VuZGluZ0JveDpudWxsLG51bGw9PWUmJihlPXRoaXMuc3RhdGUpLGU9ZS55K2UuaGVpZ2h0LG51bGwhPWImJihlPU1hdGgubWF4KGUsYi55K2IuaGVpZ2h0KSksdGhpcy5saW5rSGludC5zdHlsZS5sZWZ0PU1hdGgubWF4KDAsTWF0aC5yb3VuZChhLngrKGEud2lkdGgtdGhpcy5saW5rSGludC5jbGllbnRXaWR0aCkvMikpKyJweCIsdGhpcy5saW5rSGludC5zdHlsZS50b3A9TWF0aC5yb3VuZChlK3RoaXMudmVydGljYWxPZmZzZXQvMitFZGl0b3IuaGludE9mZnNldCkrInB4Iil9O3ZhciByYT1teFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3k7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7cmEuYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKG51bGwhPXRoaXMubW92ZUhhbmRsZXMpe2Zvcih2YXIgYT0wO2E8dGhpcy5tb3ZlSGFuZGxlcy5sZW5ndGg7YSsrKXRoaXMubW92ZUhhbmRsZXNbYV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm1vdmVIYW5kbGVzW2FdKTsKdGhpcy5tb3ZlSGFuZGxlcz1udWxsfWlmKG51bGwhPXRoaXMuY29ybmVySGFuZGxlcyl7Zm9yKGE9MDthPHRoaXMuY29ybmVySGFuZGxlcy5sZW5ndGg7YSsrKXRoaXMuY29ybmVySGFuZGxlc1thXS5ub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jb3JuZXJIYW5kbGVzW2FdLm5vZGUpO3RoaXMuY29ybmVySGFuZGxlcz1udWxsfW51bGwhPXRoaXMubGlua0hpbnQmJih0aGlzLmxpbmtIaW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5saW5rSGludCksdGhpcy5saW5rSGludD1udWxsKTtudWxsIT10aGlzLmNoYW5nZUhhbmRsZXImJih0aGlzLmdyYXBoLmdldFNlbGVjdGlvbk1vZGVsKCkucmVtb3ZlTGlzdGVuZXIodGhpcy5jaGFuZ2VIYW5kbGVyKSx0aGlzLmdyYXBoLmdldE1vZGVsKCkucmVtb3ZlTGlzdGVuZXIodGhpcy5jaGFuZ2VIYW5kbGVyKSx0aGlzLmNoYW5nZUhhbmRsZXI9bnVsbCk7bnVsbCE9dGhpcy5lZGl0aW5nSGFuZGxlciYmKHRoaXMuZ3JhcGgucmVtb3ZlTGlzdGVuZXIodGhpcy5lZGl0aW5nSGFuZGxlciksCnRoaXMuZWRpdGluZ0hhbmRsZXI9bnVsbCl9O3ZhciBOPW14RWRnZUhhbmRsZXIucHJvdG90eXBlLnJlZHJhd0hhbmRsZXM7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUucmVkcmF3SGFuZGxlcz1mdW5jdGlvbigpe2lmKG51bGwhPXRoaXMubWFya2VyJiYoTi5hcHBseSh0aGlzKSxudWxsIT10aGlzLnN0YXRlJiZudWxsIT10aGlzLmxpbmtIaW50KSl7dmFyIGE9dGhpcy5zdGF0ZTtudWxsIT10aGlzLnN0YXRlLnRleHQmJm51bGwhPXRoaXMuc3RhdGUudGV4dC5ib3VuZHMmJihhPW5ldyBteFJlY3RhbmdsZShhLngsYS55LGEud2lkdGgsYS5oZWlnaHQpLGEuYWRkKHRoaXMuc3RhdGUudGV4dC5ib3VuZHMpKTt0aGlzLmxpbmtIaW50LnN0eWxlLmxlZnQ9TWF0aC5tYXgoMCxNYXRoLnJvdW5kKGEueCsoYS53aWR0aC10aGlzLmxpbmtIaW50LmNsaWVudFdpZHRoKS8yKSkrInB4Ijt0aGlzLmxpbmtIaW50LnN0eWxlLnRvcD1NYXRoLnJvdW5kKGEueSthLmhlaWdodCtFZGl0b3IuaGludE9mZnNldCkrCiJweCJ9fTt2YXIgbWE9bXhFZGdlSGFuZGxlci5wcm90b3R5cGUucmVzZXQ7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXttYS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbCE9dGhpcy5saW5rSGludCYmKHRoaXMubGlua0hpbnQuc3R5bGUudmlzaWJpbGl0eT0iIil9O3ZhciBXPW14RWRnZUhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3k7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe1cuYXBwbHkodGhpcyxhcmd1bWVudHMpO251bGwhPXRoaXMubGlua0hpbnQmJih0aGlzLmxpbmtIaW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5saW5rSGludCksdGhpcy5saW5rSGludD1udWxsKTtudWxsIT10aGlzLmNoYW5nZUhhbmRsZXImJih0aGlzLmdyYXBoLmdldE1vZGVsKCkucmVtb3ZlTGlzdGVuZXIodGhpcy5jaGFuZ2VIYW5kbGVyKSx0aGlzLmdyYXBoLmdldFNlbGVjdGlvbk1vZGVsKCkucmVtb3ZlTGlzdGVuZXIodGhpcy5jaGFuZ2VIYW5kbGVyKSwKdGhpcy5jaGFuZ2VIYW5kbGVyPW51bGwpfX0oKTsoZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7bXhTd2ltbGFuZS5jYWxsKHRoaXMpfWZ1bmN0aW9uIGMoKXtteEN5bGluZGVyLmNhbGwodGhpcyl9ZnVuY3Rpb24gZigpe214QWN0b3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBkKCl7bXhDeWxpbmRlci5jYWxsKHRoaXMpfWZ1bmN0aW9uIG0oKXtteEN5bGluZGVyLmNhbGwodGhpcyl9ZnVuY3Rpb24gaygpe214Q3lsaW5kZXIuY2FsbCh0aGlzKX1mdW5jdGlvbiBxKCl7bXhBY3Rvci5jYWxsKHRoaXMpfWZ1bmN0aW9uIGIoKXtteEN5bGluZGVyLmNhbGwodGhpcyl9ZnVuY3Rpb24gZSgpe214QWN0b3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBnKCl7bXhBY3Rvci5jYWxsKHRoaXMpfWZ1bmN0aW9uIHAoKXtteEFjdG9yLmNhbGwodGhpcyl9ZnVuY3Rpb24gbCgpe214QWN0b3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBuKCl7bXhBY3Rvci5jYWxsKHRoaXMpfWZ1bmN0aW9uIHYoKXtteEFjdG9yLmNhbGwodGhpcyl9ZnVuY3Rpb24gdCgpe214QWN0b3IuY2FsbCh0aGlzKX0KZnVuY3Rpb24geShhLGIpe3RoaXMuY2FudmFzPWE7dGhpcy5jYW52YXMuc2V0TGluZUpvaW4oInJvdW5kIik7dGhpcy5jYW52YXMuc2V0TGluZUNhcCgicm91bmQiKTt0aGlzLmRlZmF1bHRWYXJpYXRpb249Yjt0aGlzLm9yaWdpbmFsTGluZVRvPXRoaXMuY2FudmFzLmxpbmVUbzt0aGlzLmNhbnZhcy5saW5lVG89bXhVdGlscy5iaW5kKHRoaXMseS5wcm90b3R5cGUubGluZVRvKTt0aGlzLm9yaWdpbmFsTW92ZVRvPXRoaXMuY2FudmFzLm1vdmVUbzt0aGlzLmNhbnZhcy5tb3ZlVG89bXhVdGlscy5iaW5kKHRoaXMseS5wcm90b3R5cGUubW92ZVRvKTt0aGlzLm9yaWdpbmFsQ2xvc2U9dGhpcy5jYW52YXMuY2xvc2U7dGhpcy5jYW52YXMuY2xvc2U9bXhVdGlscy5iaW5kKHRoaXMseS5wcm90b3R5cGUuY2xvc2UpO3RoaXMub3JpZ2luYWxRdWFkVG89dGhpcy5jYW52YXMucXVhZFRvO3RoaXMuY2FudmFzLnF1YWRUbz1teFV0aWxzLmJpbmQodGhpcyx5LnByb3RvdHlwZS5xdWFkVG8pO3RoaXMub3JpZ2luYWxDdXJ2ZVRvPQp0aGlzLmNhbnZhcy5jdXJ2ZVRvO3RoaXMuY2FudmFzLmN1cnZlVG89bXhVdGlscy5iaW5kKHRoaXMseS5wcm90b3R5cGUuY3VydmVUbyk7dGhpcy5vcmlnaW5hbEFyY1RvPXRoaXMuY2FudmFzLmFyY1RvO3RoaXMuY2FudmFzLmFyY1RvPW14VXRpbHMuYmluZCh0aGlzLHkucHJvdG90eXBlLmFyY1RvKX1mdW5jdGlvbiB4KCl7bXhSZWN0YW5nbGVTaGFwZS5jYWxsKHRoaXMpfWZ1bmN0aW9uIEUoKXtteFJlY3RhbmdsZVNoYXBlLmNhbGwodGhpcyl9ZnVuY3Rpb24gQSgpe214QWN0b3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBDKCl7bXhBY3Rvci5jYWxsKHRoaXMpfWZ1bmN0aW9uIHooKXtteEFjdG9yLmNhbGwodGhpcyl9ZnVuY3Rpb24gRCgpe214UmVjdGFuZ2xlU2hhcGUuY2FsbCh0aGlzKX1mdW5jdGlvbiBHKCl7bXhSZWN0YW5nbGVTaGFwZS5jYWxsKHRoaXMpfWZ1bmN0aW9uIEYoKXtteEN5bGluZGVyLmNhbGwodGhpcyl9ZnVuY3Rpb24gSCgpe214U2hhcGUuY2FsbCh0aGlzKX1mdW5jdGlvbiBKKCl7bXhTaGFwZS5jYWxsKHRoaXMpfQpmdW5jdGlvbiB1KCl7bXhFbGxpcHNlLmNhbGwodGhpcyl9ZnVuY3Rpb24gSygpe214U2hhcGUuY2FsbCh0aGlzKX1mdW5jdGlvbiBCKCl7bXhTaGFwZS5jYWxsKHRoaXMpfWZ1bmN0aW9uIE0oKXtteFJlY3RhbmdsZVNoYXBlLmNhbGwodGhpcyl9ZnVuY3Rpb24gUCgpe214U2hhcGUuY2FsbCh0aGlzKX1mdW5jdGlvbiBJKCl7bXhTaGFwZS5jYWxsKHRoaXMpfWZ1bmN0aW9uIFIoKXtteFNoYXBlLmNhbGwodGhpcyl9ZnVuY3Rpb24gZWEoKXtteFNoYXBlLmNhbGwodGhpcyl9ZnVuY3Rpb24gZmEoKXtteFNoYXBlLmNhbGwodGhpcyl9ZnVuY3Rpb24gWSgpe214Q3lsaW5kZXIuY2FsbCh0aGlzKX1mdW5jdGlvbiBaKCl7bXhDeWxpbmRlci5jYWxsKHRoaXMpfWZ1bmN0aW9uIFgoKXtteFJlY3RhbmdsZVNoYXBlLmNhbGwodGhpcyl9ZnVuY3Rpb24gYWEoKXtteERvdWJsZUVsbGlwc2UuY2FsbCh0aGlzKX1mdW5jdGlvbiBnYSgpe214RG91YmxlRWxsaXBzZS5jYWxsKHRoaXMpfWZ1bmN0aW9uIGRhKCl7bXhBcnJvd0Nvbm5lY3Rvci5jYWxsKHRoaXMpOwp0aGlzLnNwYWNpbmc9MH1mdW5jdGlvbiBVKCl7bXhBcnJvd0Nvbm5lY3Rvci5jYWxsKHRoaXMpO3RoaXMuc3BhY2luZz0wfWZ1bmN0aW9uIGNhKCl7bXhBY3Rvci5jYWxsKHRoaXMpfWZ1bmN0aW9uIFEoKXtteFJlY3RhbmdsZVNoYXBlLmNhbGwodGhpcyl9ZnVuY3Rpb24gTCgpe214QWN0b3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBqYSgpe214QWN0b3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBPKCl7bXhBY3Rvci5jYWxsKHRoaXMpfWZ1bmN0aW9uIFMoKXtteEFjdG9yLmNhbGwodGhpcyl9ZnVuY3Rpb24gaWEoKXtteEFjdG9yLmNhbGwodGhpcyl9ZnVuY3Rpb24gcmEoKXtteEFjdG9yLmNhbGwodGhpcyl9ZnVuY3Rpb24gTigpe214QWN0b3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBtYSgpe214QWN0b3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBXKCl7bXhBY3Rvci5jYWxsKHRoaXMpfWZ1bmN0aW9uIFQoKXtteEFjdG9yLmNhbGwodGhpcyl9ZnVuY3Rpb24gcGEoKXtteEVsbGlwc2UuY2FsbCh0aGlzKX0KZnVuY3Rpb24gc2EoKXtteEVsbGlwc2UuY2FsbCh0aGlzKX1mdW5jdGlvbiBoYSgpe214RWxsaXBzZS5jYWxsKHRoaXMpfWZ1bmN0aW9uIHFhKCl7bXhSaG9tYnVzLmNhbGwodGhpcyl9ZnVuY3Rpb24gbmEoKXtteEVsbGlwc2UuY2FsbCh0aGlzKX1mdW5jdGlvbiB6YSgpe214RWxsaXBzZS5jYWxsKHRoaXMpfWZ1bmN0aW9uIEJhKCl7bXhFbGxpcHNlLmNhbGwodGhpcyl9ZnVuY3Rpb24gb2EoKXtteEVsbGlwc2UuY2FsbCh0aGlzKX1mdW5jdGlvbiB3YSgpe214QWN0b3IuY2FsbCh0aGlzKX1mdW5jdGlvbiB4YSgpe214QWN0b3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBrYSgpe214QWN0b3IuY2FsbCh0aGlzKX1mdW5jdGlvbiB0YSgpe214Q29ubmVjdG9yLmNhbGwodGhpcyl9ZnVuY3Rpb24gQWEoYSxiLGUsYyxkLGYsZyxsLHAsdSl7Zys9cDt2YXIgYmE9Yy5jbG9uZSgpO2MueC09ZCooMipnK3ApO2MueS09ZiooMipnK3ApO2QqPWcrcDtmKj1nK3A7cmV0dXJuIGZ1bmN0aW9uKCl7YS5lbGxpcHNlKGJhLngtCmQtZyxiYS55LWYtZywyKmcsMipnKTt1P2EuZmlsbEFuZFN0cm9rZSgpOmEuc3Ryb2tlKCl9fW14VXRpbHMuZXh0ZW5kKGEsbXhTd2ltbGFuZSk7YS5wcm90b3R5cGUuZ2V0TGFiZWxCb3VuZHM9ZnVuY3Rpb24oYSl7cmV0dXJuIDA9PXRoaXMuZ2V0VGl0bGVTaXplKCk/bXhTaGFwZS5wcm90b3R5cGUuZ2V0TGFiZWxCb3VuZHMuYXBwbHkodGhpcyxhcmd1bWVudHMpOm14U3dpbWxhbmUucHJvdG90eXBlLmdldExhYmVsQm91bmRzLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07YS5wcm90b3R5cGUucGFpbnRWZXJ0ZXhTaGFwZT1mdW5jdGlvbihhLGIsZSxjLGQpezA9PXRoaXMuZ2V0VGl0bGVTaXplKCk/bXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUucGFpbnRCYWNrZ3JvdW5kLmFwcGx5KHRoaXMsYXJndW1lbnRzKToobXhTd2ltbGFuZS5wcm90b3R5cGUucGFpbnRWZXJ0ZXhTaGFwZS5hcHBseSh0aGlzLGFyZ3VtZW50cyksYS50cmFuc2xhdGUoLWIsLWUpKTt0aGlzLnBhaW50Rm9yZWdyb3VuZChhLApiLGUsYyxkKX07YS5wcm90b3R5cGUucGFpbnRGb3JlZ3JvdW5kPWZ1bmN0aW9uKGEsYixlLGMsZCl7aWYobnVsbCE9dGhpcy5zdGF0ZSl7dmFyIGY9dGhpcy5mbGlwSCxnPXRoaXMuZmxpcFY7aWYodGhpcy5kaXJlY3Rpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSHx8dGhpcy5kaXJlY3Rpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSCl2YXIgYmE9ZixmPWcsZz1iYTthLnJvdGF0ZSgtdGhpcy5nZXRTaGFwZVJvdGF0aW9uKCksZixnLGIrYy8yLGUrZC8yKTtzPXRoaXMuc2NhbGU7Yj10aGlzLmJvdW5kcy54L3M7ZT10aGlzLmJvdW5kcy55L3M7Yz10aGlzLmJvdW5kcy53aWR0aC9zO2Q9dGhpcy5ib3VuZHMuaGVpZ2h0L3M7dGhpcy5wYWludFRhYmxlRm9yZWdyb3VuZChhLGIsZSxjLGQpfX07YS5wcm90b3R5cGUucGFpbnRUYWJsZUZvcmVncm91bmQ9ZnVuY3Rpb24oYSxiLGUsYyxkKXt2YXIgZj10aGlzLnN0YXRlLnZpZXcuZ3JhcGgsZz1mLmdldEFjdHVhbFN0YXJ0U2l6ZSh0aGlzLnN0YXRlLmNlbGwpLApiYT1mLm1vZGVsLmdldENoaWxkQ2VsbHModGhpcy5zdGF0ZS5jZWxsLCEwKTtpZigwPGJhLmxlbmd0aCl7dmFyIGw9IjAiIT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsInJvd0xpbmVzIiwiMSIpLHA9IjAiIT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsImNvbHVtbkxpbmVzIiwiMSIpO2lmKGwpZm9yKGw9MTtsPGJhLmxlbmd0aDtsKyspe3ZhciB1PWYuZ2V0Q2VsbEdlb21ldHJ5KGJhW2xdKTtudWxsIT11JiYoYS5iZWdpbigpLGEubW92ZVRvKGIrZy54LGUrdS55KSxhLmxpbmVUbyhiK2MtZy53aWR0aCxlK3UueSksYS5lbmQoKSxhLnN0cm9rZSgpKX1pZihwKWZvcihjPWYubW9kZWwuZ2V0Q2hpbGRDZWxscyhiYVswXSwhMCksbD0xO2w8Yy5sZW5ndGg7bCsrKXU9Zi5nZXRDZWxsR2VvbWV0cnkoY1tsXSksbnVsbCE9dSYmKGEuYmVnaW4oKSxhLm1vdmVUbyhiK3UueCtnLngsZStnLnkpLGEubGluZVRvKGIrdS54K2cueCxlK2QtZy5oZWlnaHQpLGEuZW5kKCksCmEuc3Ryb2tlKCkpfX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgidGFibGUiLGEpO214VXRpbHMuZXh0ZW5kKGMsbXhDeWxpbmRlcik7Yy5wcm90b3R5cGUuc2l6ZT0yMDtjLnByb3RvdHlwZS5kYXJrT3BhY2l0eT0wO2MucHJvdG90eXBlLmRhcmtPcGFjaXR5Mj0wO2MucHJvdG90eXBlLnBhaW50VmVydGV4U2hhcGU9ZnVuY3Rpb24oYSxiLGUsYyxkKXt2YXIgZj1NYXRoLm1heCgwLE1hdGgubWluKGMsTWF0aC5taW4oZCxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSkpKSksZz1NYXRoLm1heCgtMSxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJkYXJrT3BhY2l0eSIsdGhpcy5kYXJrT3BhY2l0eSkpKSksYmE9TWF0aC5tYXgoLTEsTWF0aC5taW4oMSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwiZGFya09wYWNpdHkyIix0aGlzLmRhcmtPcGFjaXR5MikpKSk7CmEudHJhbnNsYXRlKGIsZSk7YS5iZWdpbigpO2EubW92ZVRvKDAsMCk7YS5saW5lVG8oYy1mLDApO2EubGluZVRvKGMsZik7YS5saW5lVG8oYyxkKTthLmxpbmVUbyhmLGQpO2EubGluZVRvKDAsZC1mKTthLmxpbmVUbygwLDApO2EuY2xvc2UoKTthLmVuZCgpO2EuZmlsbEFuZFN0cm9rZSgpO3RoaXMub3V0bGluZXx8KGEuc2V0U2hhZG93KCExKSwwIT1nJiYoYS5zZXRGaWxsQWxwaGEoTWF0aC5hYnMoZykpLGEuc2V0RmlsbENvbG9yKDA+Zz8iI0ZGRkZGRiI6IiMwMDAwMDAiKSxhLmJlZ2luKCksYS5tb3ZlVG8oMCwwKSxhLmxpbmVUbyhjLWYsMCksYS5saW5lVG8oYyxmKSxhLmxpbmVUbyhmLGYpLGEuY2xvc2UoKSxhLmZpbGwoKSksMCE9YmEmJihhLnNldEZpbGxBbHBoYShNYXRoLmFicyhiYSkpLGEuc2V0RmlsbENvbG9yKDA+YmE/IiNGRkZGRkYiOiIjMDAwMDAwIiksYS5iZWdpbigpLGEubW92ZVRvKDAsMCksYS5saW5lVG8oZixmKSxhLmxpbmVUbyhmLGQpLGEubGluZVRvKDAsZC0KZiksYS5jbG9zZSgpLGEuZmlsbCgpKSxhLmJlZ2luKCksYS5tb3ZlVG8oZixkKSxhLmxpbmVUbyhmLGYpLGEubGluZVRvKDAsMCksYS5tb3ZlVG8oZixmKSxhLmxpbmVUbyhjLGYpLGEuZW5kKCksYS5zdHJva2UoKSl9O2MucHJvdG90eXBlLmdldExhYmVsTWFyZ2lucz1mdW5jdGlvbihhKXtyZXR1cm4gbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJib3VuZGVkTGJsIiwhMSk/KGE9cGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInNpemUiLHRoaXMuc2l6ZSkpKnRoaXMuc2NhbGUsbmV3IG14UmVjdGFuZ2xlKGEsYSwwLDApKTpudWxsfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJjdWJlIixjKTt2YXIgdWE9TWF0aC50YW4obXhVdGlscy50b1JhZGlhbnMoMzApKSxsYT0oLjUtdWEpLzI7bXhVdGlscy5leHRlbmQoZixteEFjdG9yKTtmLnByb3RvdHlwZS5zaXplPTIwO2YucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGUsYyxkKXtiPQpNYXRoLm1pbihjLGQvdWEpO2EudHJhbnNsYXRlKChjLWIpLzIsKGQtYikvMitiLzQpO2EubW92ZVRvKDAsLjI1KmIpO2EubGluZVRvKC41KmIsYipsYSk7YS5saW5lVG8oYiwuMjUqYik7YS5saW5lVG8oLjUqYiwoLjUtbGEpKmIpO2EubGluZVRvKDAsLjI1KmIpO2EuY2xvc2UoKTthLmVuZCgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJpc29SZWN0YW5nbGUiLGYpO214VXRpbHMuZXh0ZW5kKGQsbXhDeWxpbmRlcik7ZC5wcm90b3R5cGUuc2l6ZT0yMDtkLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCxmKXtiPU1hdGgubWluKGMsZC8oLjUrdWEpKTtmPyhhLm1vdmVUbygwLC4yNSpiKSxhLmxpbmVUbyguNSpiLCguNS1sYSkqYiksYS5saW5lVG8oYiwuMjUqYiksYS5tb3ZlVG8oLjUqYiwoLjUtbGEpKmIpLGEubGluZVRvKC41KmIsKDEtbGEpKmIpKTooYS50cmFuc2xhdGUoKGMtYikvMiwoZC1iKS8yKSxhLm1vdmVUbygwLC4yNSpiKSxhLmxpbmVUbyguNSoKYixiKmxhKSxhLmxpbmVUbyhiLC4yNSpiKSxhLmxpbmVUbyhiLC43NSpiKSxhLmxpbmVUbyguNSpiLCgxLWxhKSpiKSxhLmxpbmVUbygwLC43NSpiKSxhLmNsb3NlKCkpO2EuZW5kKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImlzb0N1YmUiLGQpO214VXRpbHMuZXh0ZW5kKG0sbXhDeWxpbmRlcik7bS5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsZSxjLGQsZil7Yj1NYXRoLm1pbihkLzIsTWF0aC5yb3VuZChkLzgpK3RoaXMuc3Ryb2tld2lkdGgtMSk7aWYoZiYmbnVsbCE9dGhpcy5maWxsfHwhZiYmbnVsbD09dGhpcy5maWxsKWEubW92ZVRvKDAsYiksYS5jdXJ2ZVRvKDAsMipiLGMsMipiLGMsYiksZnx8KGEuc3Ryb2tlKCksYS5iZWdpbigpKSxhLnRyYW5zbGF0ZSgwLGIvMiksYS5tb3ZlVG8oMCxiKSxhLmN1cnZlVG8oMCwyKmIsYywyKmIsYyxiKSxmfHwoYS5zdHJva2UoKSxhLmJlZ2luKCkpLGEudHJhbnNsYXRlKDAsYi8yKSxhLm1vdmVUbygwLGIpLAphLmN1cnZlVG8oMCwyKmIsYywyKmIsYyxiKSxmfHwoYS5zdHJva2UoKSxhLmJlZ2luKCkpLGEudHJhbnNsYXRlKDAsLWIpO2Z8fChhLm1vdmVUbygwLGIpLGEuY3VydmVUbygwLC1iLzMsYywtYi8zLGMsYiksYS5saW5lVG8oYyxkLWIpLGEuY3VydmVUbyhjLGQrYi8zLDAsZCtiLzMsMCxkLWIpLGEuY2xvc2UoKSl9O20ucHJvdG90eXBlLmdldExhYmVsTWFyZ2lucz1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKDAsMi41Kk1hdGgubWluKGEuaGVpZ2h0LzIsTWF0aC5yb3VuZChhLmhlaWdodC84KSt0aGlzLnN0cm9rZXdpZHRoLTEpLDAsMCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImRhdGFzdG9yZSIsbSk7bXhVdGlscy5leHRlbmQoayxteEN5bGluZGVyKTtrLnByb3RvdHlwZS5zaXplPTMwO2sucHJvdG90eXBlLmRhcmtPcGFjaXR5PTA7ay5wcm90b3R5cGUucGFpbnRWZXJ0ZXhTaGFwZT1mdW5jdGlvbihhLGIsZSxjLGQpe3ZhciBmPU1hdGgubWF4KDAsCk1hdGgubWluKGMsTWF0aC5taW4oZCxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSkpKSksZz1NYXRoLm1heCgtMSxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJkYXJrT3BhY2l0eSIsdGhpcy5kYXJrT3BhY2l0eSkpKSk7YS50cmFuc2xhdGUoYixlKTthLmJlZ2luKCk7YS5tb3ZlVG8oMCwwKTthLmxpbmVUbyhjLWYsMCk7YS5saW5lVG8oYyxmKTthLmxpbmVUbyhjLGQpO2EubGluZVRvKDAsZCk7YS5saW5lVG8oMCwwKTthLmNsb3NlKCk7YS5lbmQoKTthLmZpbGxBbmRTdHJva2UoKTt0aGlzLm91dGxpbmV8fChhLnNldFNoYWRvdyghMSksMCE9ZyYmKGEuc2V0RmlsbEFscGhhKE1hdGguYWJzKGcpKSxhLnNldEZpbGxDb2xvcigwPmc/IiNGRkZGRkYiOiIjMDAwMDAwIiksYS5iZWdpbigpLGEubW92ZVRvKGMtZiwwKSxhLmxpbmVUbyhjLWYsZiksYS5saW5lVG8oYyxmKSxhLmNsb3NlKCksCmEuZmlsbCgpKSxhLmJlZ2luKCksYS5tb3ZlVG8oYy1mLDApLGEubGluZVRvKGMtZixmKSxhLmxpbmVUbyhjLGYpLGEuZW5kKCksYS5zdHJva2UoKSl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoIm5vdGUiLGspO214VXRpbHMuZXh0ZW5kKHEsbXhBY3Rvcik7cS5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsZSxjLGQpe2EubW92ZVRvKDAsMCk7YS5xdWFkVG8oYy8yLC41KmQsYywwKTthLnF1YWRUbyguNSpjLGQvMixjLGQpO2EucXVhZFRvKGMvMiwuNSpkLDAsZCk7YS5xdWFkVG8oLjUqYyxkLzIsMCwwKTthLmVuZCgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJzd2l0Y2giLHEpO214VXRpbHMuZXh0ZW5kKGIsbXhDeWxpbmRlcik7Yi5wcm90b3R5cGUudGFiV2lkdGg9NjA7Yi5wcm90b3R5cGUudGFiSGVpZ2h0PTIwO2IucHJvdG90eXBlLnRhYlBvc2l0aW9uPSJyaWdodCI7Yi5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsZSxjLApkLGYpe2I9TWF0aC5tYXgoMCxNYXRoLm1pbihjLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJ0YWJXaWR0aCIsdGhpcy50YWJXaWR0aCkpKSk7ZT1NYXRoLm1heCgwLE1hdGgubWluKGQscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInRhYkhlaWdodCIsdGhpcy50YWJIZWlnaHQpKSkpO3ZhciBnPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwidGFiUG9zaXRpb24iLHRoaXMudGFiUG9zaXRpb24pO2Y/ImxlZnQiPT1nPyhhLm1vdmVUbygwLGUpLGEubGluZVRvKGIsZSkpOihhLm1vdmVUbyhjLWIsZSksYS5saW5lVG8oYyxlKSk6KCJsZWZ0Ij09Zz8oYS5tb3ZlVG8oMCwwKSxhLmxpbmVUbyhiLDApLGEubGluZVRvKGIsZSksYS5saW5lVG8oYyxlKSk6KGEubW92ZVRvKDAsZSksYS5saW5lVG8oYy1iLGUpLGEubGluZVRvKGMtYiwwKSxhLmxpbmVUbyhjLDApKSxhLmxpbmVUbyhjLGQpLGEubGluZVRvKDAsZCksYS5saW5lVG8oMCwKZSksYS5jbG9zZSgpKTthLmVuZCgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJmb2xkZXIiLGIpO214VXRpbHMuZXh0ZW5kKGUsbXhBY3Rvcik7ZS5wcm90b3R5cGUuc2l6ZT0zMDtlLnByb3RvdHlwZS5pc1JvdW5kYWJsZT1mdW5jdGlvbigpe3JldHVybiEwfTtlLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCl7Yj1NYXRoLm1heCgwLE1hdGgubWluKGMsTWF0aC5taW4oZCxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSkpKSk7ZT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSxteENvbnN0YW50cy5MSU5FX0FSQ1NJWkUpLzI7dGhpcy5hZGRQb2ludHMoYSxbbmV3IG14UG9pbnQoYiwwKSxuZXcgbXhQb2ludChjLDApLG5ldyBteFBvaW50KGMsZCksbmV3IG14UG9pbnQoMCxkKSxuZXcgbXhQb2ludCgwLGIpXSx0aGlzLmlzUm91bmRlZCxlLCEwKTsKYS5lbmQoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgiY2FyZCIsZSk7bXhVdGlscy5leHRlbmQoZyxteEFjdG9yKTtnLnByb3RvdHlwZS5zaXplPS40O2cucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGUsYyxkKXtiPWQqTWF0aC5tYXgoMCxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkpO2EubW92ZVRvKDAsYi8yKTthLnF1YWRUbyhjLzQsMS40KmIsYy8yLGIvMik7YS5xdWFkVG8oMypjLzQsYiooMS0xLjQpLGMsYi8yKTthLmxpbmVUbyhjLGQtYi8yKTthLnF1YWRUbygzKmMvNCxkLTEuNCpiLGMvMixkLWIvMik7YS5xdWFkVG8oYy80LGQtYiooMS0xLjQpLDAsZC1iLzIpO2EubGluZVRvKDAsYi8yKTthLmNsb3NlKCk7YS5lbmQoKX07Zy5wcm90b3R5cGUuZ2V0TGFiZWxCb3VuZHM9ZnVuY3Rpb24oYSl7aWYobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJib3VuZGVkTGJsIiwKITEpKXt2YXIgYj1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInNpemUiLHRoaXMuc2l6ZSksZT1hLndpZHRoLGM9YS5oZWlnaHQ7aWYobnVsbD09dGhpcy5kaXJlY3Rpb258fHRoaXMuZGlyZWN0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVHx8dGhpcy5kaXJlY3Rpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUKXJldHVybiBiKj1jLG5ldyBteFJlY3RhbmdsZShhLngsYS55K2IsZSxjLTIqYik7Yio9ZTtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKGEueCtiLGEueSxlLTIqYixjKX1yZXR1cm4gYX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgidGFwZSIsZyk7bXhVdGlscy5leHRlbmQocCxteEFjdG9yKTtwLnByb3RvdHlwZS5zaXplPS4zO3AucHJvdG90eXBlLmdldExhYmVsTWFyZ2lucz1mdW5jdGlvbihhKXtyZXR1cm4gbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJib3VuZGVkTGJsIiwhMSk/bmV3IG14UmVjdGFuZ2xlKDAsMCwwLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLAoic2l6ZSIsdGhpcy5zaXplKSkqYS5oZWlnaHQpOm51bGx9O3AucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGUsYyxkKXtiPWQqTWF0aC5tYXgoMCxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkpO2EubW92ZVRvKDAsMCk7YS5saW5lVG8oYywwKTthLmxpbmVUbyhjLGQtYi8yKTthLnF1YWRUbygzKmMvNCxkLTEuNCpiLGMvMixkLWIvMik7YS5xdWFkVG8oYy80LGQtYiooMS0xLjQpLDAsZC1iLzIpO2EubGluZVRvKDAsYi8yKTthLmNsb3NlKCk7YS5lbmQoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgiZG9jdW1lbnQiLHApO3ZhciBJYT1teEN5bGluZGVyLnByb3RvdHlwZS5nZXRDeWxpbmRlclNpemU7bXhDeWxpbmRlci5wcm90b3R5cGUuZ2V0Q3lsaW5kZXJTaXplPWZ1bmN0aW9uKGEsYixlLGMpe3ZhciBkPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIpO3JldHVybiBudWxsIT0KZD9jKk1hdGgubWF4KDAsTWF0aC5taW4oMSxkKSk6SWEuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtteEN5bGluZGVyLnByb3RvdHlwZS5nZXRMYWJlbE1hcmdpbnM9ZnVuY3Rpb24oYSl7aWYobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJib3VuZGVkTGJsIiwhMSkpe3ZhciBiPTIqbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIiwuMTUpO3JldHVybiBuZXcgbXhSZWN0YW5nbGUoMCxNYXRoLm1pbih0aGlzLm1heEhlaWdodCp0aGlzLnNjYWxlLGEuaGVpZ2h0KmIpLDAsMCl9cmV0dXJuIG51bGx9O214VXRpbHMuZXh0ZW5kKGwsbXhBY3Rvcik7bC5wcm90b3R5cGUuc2l6ZT0uMjtsLnByb3RvdHlwZS5pc1JvdW5kYWJsZT1mdW5jdGlvbigpe3JldHVybiEwfTtsLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCl7Yj1jKk1hdGgubWF4KDAsTWF0aC5taW4oMSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSkpKTsKZT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSxteENvbnN0YW50cy5MSU5FX0FSQ1NJWkUpLzI7dGhpcy5hZGRQb2ludHMoYSxbbmV3IG14UG9pbnQoMCxkKSxuZXcgbXhQb2ludChiLDApLG5ldyBteFBvaW50KGMsMCksbmV3IG14UG9pbnQoYy1iLGQpXSx0aGlzLmlzUm91bmRlZCxlLCEwKTthLmVuZCgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJwYXJhbGxlbG9ncmFtIixsKTtteFV0aWxzLmV4dGVuZChuLG14QWN0b3IpO24ucHJvdG90eXBlLnNpemU9LjI7bi5wcm90b3R5cGUuaXNSb3VuZGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH07bi5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsZSxjLGQpe2I9YypNYXRoLm1heCgwLE1hdGgubWluKC41LHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkpO2U9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLApteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLG14Q29uc3RhbnRzLkxJTkVfQVJDU0laRSkvMjt0aGlzLmFkZFBvaW50cyhhLFtuZXcgbXhQb2ludCgwLGQpLG5ldyBteFBvaW50KGIsMCksbmV3IG14UG9pbnQoYy1iLDApLG5ldyBteFBvaW50KGMsZCldLHRoaXMuaXNSb3VuZGVkLGUsITApfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJ0cmFwZXpvaWQiLG4pO214VXRpbHMuZXh0ZW5kKHYsbXhBY3Rvcik7di5wcm90b3R5cGUuc2l6ZT0uNTt2LnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCl7YS5zZXRGaWxsQ29sb3IobnVsbCk7Yj1jKk1hdGgubWF4KDAsTWF0aC5taW4oMSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSkpKTtlPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLG14Q29uc3RhbnRzLkxJTkVfQVJDU0laRSkvMjt0aGlzLmFkZFBvaW50cyhhLApbbmV3IG14UG9pbnQoYywwKSxuZXcgbXhQb2ludChiLDApLG5ldyBteFBvaW50KGIsZC8yKSxuZXcgbXhQb2ludCgwLGQvMiksbmV3IG14UG9pbnQoYixkLzIpLG5ldyBteFBvaW50KGIsZCksbmV3IG14UG9pbnQoYyxkKV0sdGhpcy5pc1JvdW5kZWQsZSwhMSk7YS5lbmQoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgiY3VybHlCcmFja2V0Iix2KTtteFV0aWxzLmV4dGVuZCh0LG14QWN0b3IpO3QucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGUsYyxkKXthLnNldFN0cm9rZVdpZHRoKDEpO2Euc2V0RmlsbENvbG9yKHRoaXMuc3Ryb2tlKTtiPWMvNTthLnJlY3QoMCwwLGIsZCk7YS5maWxsQW5kU3Ryb2tlKCk7YS5yZWN0KDIqYiwwLGIsZCk7YS5maWxsQW5kU3Ryb2tlKCk7YS5yZWN0KDQqYiwwLGIsZCk7YS5maWxsQW5kU3Ryb2tlKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInBhcmFsbGVsTWFya2VyIix0KTt5LnByb3RvdHlwZS5tb3ZlVG89CmZ1bmN0aW9uKGEsYil7dGhpcy5vcmlnaW5hbE1vdmVUby5hcHBseSh0aGlzLmNhbnZhcyxhcmd1bWVudHMpO3RoaXMubGFzdFg9YTt0aGlzLmxhc3RZPWI7dGhpcy5maXJzdFg9YTt0aGlzLmZpcnN0WT1ifTt5LnByb3RvdHlwZS5jbG9zZT1mdW5jdGlvbigpe251bGwhPXRoaXMuZmlyc3RYJiZudWxsIT10aGlzLmZpcnN0WSYmKHRoaXMubGluZVRvKHRoaXMuZmlyc3RYLHRoaXMuZmlyc3RZKSx0aGlzLm9yaWdpbmFsQ2xvc2UuYXBwbHkodGhpcy5jYW52YXMsYXJndW1lbnRzKSk7dGhpcy5vcmlnaW5hbENsb3NlLmFwcGx5KHRoaXMuY2FudmFzLGFyZ3VtZW50cyl9O3kucHJvdG90eXBlLnF1YWRUbz1mdW5jdGlvbihhLGIsZSxjKXt0aGlzLm9yaWdpbmFsUXVhZFRvLmFwcGx5KHRoaXMuY2FudmFzLGFyZ3VtZW50cyk7dGhpcy5sYXN0WD1lO3RoaXMubGFzdFk9Y307eS5wcm90b3R5cGUuY3VydmVUbz1mdW5jdGlvbihhLGIsZSxjLGQsZil7dGhpcy5vcmlnaW5hbEN1cnZlVG8uYXBwbHkodGhpcy5jYW52YXMsCmFyZ3VtZW50cyk7dGhpcy5sYXN0WD1kO3RoaXMubGFzdFk9Zn07eS5wcm90b3R5cGUuYXJjVG89ZnVuY3Rpb24oYSxiLGUsYyxkLGYsZyl7dGhpcy5vcmlnaW5hbEFyY1RvLmFwcGx5KHRoaXMuY2FudmFzLGFyZ3VtZW50cyk7dGhpcy5sYXN0WD1mO3RoaXMubGFzdFk9Z307eS5wcm90b3R5cGUubGluZVRvPWZ1bmN0aW9uKGEsYil7aWYobnVsbCE9dGhpcy5sYXN0WCYmbnVsbCE9dGhpcy5sYXN0WSl7dmFyIGU9ZnVuY3Rpb24oYSl7cmV0dXJuIm51bWJlciI9PT10eXBlb2YgYT9hPzA+YT8tMToxOmE9PT1hPzA6TmFOOk5hTn0sYz1NYXRoLmFicyhhLXRoaXMubGFzdFgpLGQ9TWF0aC5hYnMoYi10aGlzLmxhc3RZKSxmPU1hdGguc3FydChjKmMrZCpkKTtpZigyPmYpe3RoaXMub3JpZ2luYWxMaW5lVG8uYXBwbHkodGhpcy5jYW52YXMsYXJndW1lbnRzKTt0aGlzLmxhc3RYPWE7dGhpcy5sYXN0WT1iO3JldHVybn12YXIgZz1NYXRoLnJvdW5kKGYvMTApLGw9dGhpcy5kZWZhdWx0VmFyaWF0aW9uOwo1PmcmJihnPTUsbC89Myk7Zm9yKHZhciBiYT1lKGEtdGhpcy5sYXN0WCkqYy9nLGU9ZShiLXRoaXMubGFzdFkpKmQvZyxjPWMvZixkPWQvZixmPTA7ZjxnO2YrKyl7dmFyIHA9KE1hdGgucmFuZG9tKCktLjUpKmw7dGhpcy5vcmlnaW5hbExpbmVUby5jYWxsKHRoaXMuY2FudmFzLGJhKmYrdGhpcy5sYXN0WC1wKmQsZSpmK3RoaXMubGFzdFktcCpjKX10aGlzLm9yaWdpbmFsTGluZVRvLmNhbGwodGhpcy5jYW52YXMsYSxiKX1lbHNlIHRoaXMub3JpZ2luYWxMaW5lVG8uYXBwbHkodGhpcy5jYW52YXMsYXJndW1lbnRzKTt0aGlzLmxhc3RYPWE7dGhpcy5sYXN0WT1ifTt5LnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5jYW52YXMubGluZVRvPXRoaXMub3JpZ2luYWxMaW5lVG87dGhpcy5jYW52YXMubW92ZVRvPXRoaXMub3JpZ2luYWxNb3ZlVG87dGhpcy5jYW52YXMuY2xvc2U9dGhpcy5vcmlnaW5hbENsb3NlO3RoaXMuY2FudmFzLnF1YWRUbz10aGlzLm9yaWdpbmFsUXVhZFRvOwp0aGlzLmNhbnZhcy5jdXJ2ZVRvPXRoaXMub3JpZ2luYWxDdXJ2ZVRvO3RoaXMuY2FudmFzLmFyY1RvPXRoaXMub3JpZ2luYWxBcmNUb307dmFyIEphPW14U2hhcGUucHJvdG90eXBlLnBhaW50O214U2hhcGUucHJvdG90eXBlLmRlZmF1bHRKaWdnbGU9MS41O214U2hhcGUucHJvdG90eXBlLnBhaW50PWZ1bmN0aW9uKGEpe251bGwhPXRoaXMuc3R5bGUmJiIwIiE9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJjb21pYyIsIjAiKSYmbnVsbD09YS5oYW5kSGlnZ2xlJiYoYS5oYW5kSmlnZ2xlPW5ldyB5KGEsbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJqaWdnbGUiLHRoaXMuZGVmYXVsdEppZ2dsZSkpKTtKYS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbCE9YS5oYW5kSmlnZ2xlJiYoYS5oYW5kSmlnZ2xlLmRlc3Ryb3koKSxkZWxldGUgYS5oYW5kSmlnZ2xlKX07bXhSaG9tYnVzLnByb3RvdHlwZS5kZWZhdWx0SmlnZ2xlPTI7dmFyIFBhPW14UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLmlzSHRtbEFsbG93ZWQ7Cm14UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLmlzSHRtbEFsbG93ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4obnVsbD09dGhpcy5zdHlsZXx8IjAiPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImNvbWljIiwiMCIpKSYmUGEuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgUWE9bXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUucGFpbnRCYWNrZ3JvdW5kO214UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLnBhaW50QmFja2dyb3VuZD1mdW5jdGlvbihhLGIsZSxjLGQpe2lmKG51bGw9PWEuaGFuZEppZ2dsZSlRYS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7ZWxzZXt2YXIgZj0hMDtudWxsIT10aGlzLnN0eWxlJiYoZj0iMSI9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9QT0lOVEVSX0VWRU5UUywiMSIpKTtpZihmfHxudWxsIT10aGlzLmZpbGwmJnRoaXMuZmlsbCE9bXhDb25zdGFudHMuTk9ORXx8bnVsbCE9dGhpcy5zdHJva2UmJnRoaXMuc3Ryb2tlIT0KbXhDb25zdGFudHMuTk9ORSlmfHxudWxsIT10aGlzLmZpbGwmJnRoaXMuZmlsbCE9bXhDb25zdGFudHMuTk9ORXx8KGEucG9pbnRlckV2ZW50cz0hMSksYS5iZWdpbigpLHRoaXMuaXNSb3VuZGVkPygiMSI9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BQlNPTFVURV9BUkNTSVpFLDApP2Y9TWF0aC5taW4oYy8yLE1hdGgubWluKGQvMixteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSxteENvbnN0YW50cy5MSU5FX0FSQ1NJWkUpLzIpKTooZj1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSwxMDAqbXhDb25zdGFudHMuUkVDVEFOR0xFX1JPVU5ESU5HX0ZBQ1RPUikvMTAwLGY9TWF0aC5taW4oYypmLGQqZikpLGEubW92ZVRvKGIrZixlKSxhLmxpbmVUbyhiK2MtZixlKSxhLnF1YWRUbyhiK2MsZSxiK2MsZStmKSxhLmxpbmVUbyhiK2MsZStkLWYpLGEucXVhZFRvKGIrCmMsZStkLGIrYy1mLGUrZCksYS5saW5lVG8oYitmLGUrZCksYS5xdWFkVG8oYixlK2QsYixlK2QtZiksYS5saW5lVG8oYixlK2YpLGEucXVhZFRvKGIsZSxiK2YsZSkpOihhLm1vdmVUbyhiLGUpLGEubGluZVRvKGIrYyxlKSxhLmxpbmVUbyhiK2MsZStkKSxhLmxpbmVUbyhiLGUrZCksYS5saW5lVG8oYixlKSksYS5jbG9zZSgpLGEuZW5kKCksYS5maWxsQW5kU3Ryb2tlKCl9fTt2YXIgUmE9bXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUucGFpbnRGb3JlZ3JvdW5kO214UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLnBhaW50Rm9yZWdyb3VuZD1mdW5jdGlvbihhLGIsZSxjLGQpe251bGw9PWEuaGFuZEppZ2dsZSYmUmEuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtteFV0aWxzLmV4dGVuZCh4LG14UmVjdGFuZ2xlU2hhcGUpO3gucHJvdG90eXBlLnNpemU9LjE7eC5wcm90b3R5cGUuaXNIdG1sQWxsb3dlZD1mdW5jdGlvbigpe3JldHVybiExfTt4LnByb3RvdHlwZS5nZXRMYWJlbEJvdW5kcz0KZnVuY3Rpb24oYSl7aWYobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0hPUklaT05UQUwsITApPT0obnVsbD09dGhpcy5kaXJlY3Rpb258fHRoaXMuZGlyZWN0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVHx8dGhpcy5kaXJlY3Rpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUKSl7dmFyIGI9YS53aWR0aCxlPWEuaGVpZ2h0O2E9bmV3IG14UmVjdGFuZ2xlKGEueCxhLnksYixlKTt2YXIgYz1iKk1hdGgubWF4KDAsTWF0aC5taW4oMSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSkpKTtpZih0aGlzLmlzUm91bmRlZCl2YXIgZD1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSwxMDAqbXhDb25zdGFudHMuUkVDVEFOR0xFX1JPVU5ESU5HX0ZBQ1RPUikvMTAwLGM9TWF0aC5tYXgoYyxNYXRoLm1pbihiKmQsZSpkKSk7YS54Kz0KTWF0aC5yb3VuZChjKTthLndpZHRoLT1NYXRoLnJvdW5kKDIqYyl9cmV0dXJuIGF9O3gucHJvdG90eXBlLnBhaW50Rm9yZWdyb3VuZD1mdW5jdGlvbihhLGIsZSxjLGQpe3ZhciBmPWMqTWF0aC5tYXgoMCxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkpO2lmKHRoaXMuaXNSb3VuZGVkKXZhciBnPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLDEwMCpteENvbnN0YW50cy5SRUNUQU5HTEVfUk9VTkRJTkdfRkFDVE9SKS8xMDAsZj1NYXRoLm1heChmLE1hdGgubWluKGMqZyxkKmcpKTtmPU1hdGgucm91bmQoZik7YS5iZWdpbigpO2EubW92ZVRvKGIrZixlKTthLmxpbmVUbyhiK2YsZStkKTthLm1vdmVUbyhiK2MtZixlKTthLmxpbmVUbyhiK2MtZixlK2QpO2EuZW5kKCk7YS5zdHJva2UoKTtteFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5wYWludEZvcmVncm91bmQuYXBwbHkodGhpcywKYXJndW1lbnRzKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgicHJvY2VzcyIseCk7bXhVdGlscy5leHRlbmQoRSxteFJlY3RhbmdsZVNoYXBlKTtFLnByb3RvdHlwZS5wYWludEJhY2tncm91bmQ9ZnVuY3Rpb24oYSxiLGUsYyxkKXthLnNldEZpbGxDb2xvcihteENvbnN0YW50cy5OT05FKTthLnJlY3QoYixlLGMsZCk7YS5maWxsKCl9O0UucHJvdG90eXBlLnBhaW50Rm9yZWdyb3VuZD1mdW5jdGlvbihhLGIsZSxjLGQpe307bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgidHJhbnNwYXJlbnQiLEUpO214VXRpbHMuZXh0ZW5kKEEsbXhIZXhhZ29uKTtBLnByb3RvdHlwZS5zaXplPTMwO0EucHJvdG90eXBlLnBvc2l0aW9uPS41O0EucHJvdG90eXBlLnBvc2l0aW9uMj0uNTtBLnByb3RvdHlwZS5iYXNlPTIwO0EucHJvdG90eXBlLmdldExhYmVsTWFyZ2lucz1mdW5jdGlvbigpe3JldHVybiBuZXcgbXhSZWN0YW5nbGUoMCwwLDAscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsCiJzaXplIix0aGlzLnNpemUpKSp0aGlzLnNjYWxlKX07QS5wcm90b3R5cGUuaXNSb3VuZGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH07QS5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsZSxjLGQpe2I9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkUsbXhDb25zdGFudHMuTElORV9BUkNTSVpFKS8yO2U9TWF0aC5tYXgoMCxNYXRoLm1pbihkLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkpO3ZhciBmPWMqTWF0aC5tYXgoMCxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJwb3NpdGlvbiIsdGhpcy5wb3NpdGlvbikpKSksZz1jKk1hdGgubWF4KDAsTWF0aC5taW4oMSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwicG9zaXRpb24yIix0aGlzLnBvc2l0aW9uMikpKSksbD1NYXRoLm1heCgwLE1hdGgubWluKGMsCnBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJiYXNlIix0aGlzLmJhc2UpKSkpO3RoaXMuYWRkUG9pbnRzKGEsW25ldyBteFBvaW50KDAsMCksbmV3IG14UG9pbnQoYywwKSxuZXcgbXhQb2ludChjLGQtZSksbmV3IG14UG9pbnQoTWF0aC5taW4oYyxmK2wpLGQtZSksbmV3IG14UG9pbnQoZyxkKSxuZXcgbXhQb2ludChNYXRoLm1heCgwLGYpLGQtZSksbmV3IG14UG9pbnQoMCxkLWUpXSx0aGlzLmlzUm91bmRlZCxiLCEwLFs0XSl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImNhbGxvdXQiLEEpO214VXRpbHMuZXh0ZW5kKEMsbXhBY3Rvcik7Qy5wcm90b3R5cGUuc2l6ZT0uMjtDLnByb3RvdHlwZS5maXhlZFNpemU9MjA7Qy5wcm90b3R5cGUuaXNSb3VuZGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH07Qy5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsZSxjLGQpe2I9IjAiIT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImZpeGVkU2l6ZSIsCiIwIik/TWF0aC5tYXgoMCxNYXRoLm1pbihjLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLmZpeGVkU2l6ZSkpKSk6YypNYXRoLm1heCgwLE1hdGgubWluKDEscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInNpemUiLHRoaXMuc2l6ZSkpKSk7ZT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSxteENvbnN0YW50cy5MSU5FX0FSQ1NJWkUpLzI7dGhpcy5hZGRQb2ludHMoYSxbbmV3IG14UG9pbnQoMCwwKSxuZXcgbXhQb2ludChjLWIsMCksbmV3IG14UG9pbnQoYyxkLzIpLG5ldyBteFBvaW50KGMtYixkKSxuZXcgbXhQb2ludCgwLGQpLG5ldyBteFBvaW50KGIsZC8yKV0sdGhpcy5pc1JvdW5kZWQsZSwhMCk7YS5lbmQoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgic3RlcCIsQyk7bXhVdGlscy5leHRlbmQoeixteEhleGFnb24pO3oucHJvdG90eXBlLnNpemU9Ci4yNTt6LnByb3RvdHlwZS5pc1JvdW5kYWJsZT1mdW5jdGlvbigpe3JldHVybiEwfTt6LnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCl7Yj1jKk1hdGgubWF4KDAsTWF0aC5taW4oMSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSkpKTtlPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLG14Q29uc3RhbnRzLkxJTkVfQVJDU0laRSkvMjt0aGlzLmFkZFBvaW50cyhhLFtuZXcgbXhQb2ludChiLDApLG5ldyBteFBvaW50KGMtYiwwKSxuZXcgbXhQb2ludChjLC41KmQpLG5ldyBteFBvaW50KGMtYixkKSxuZXcgbXhQb2ludChiLGQpLG5ldyBteFBvaW50KDAsLjUqZCldLHRoaXMuaXNSb3VuZGVkLGUsITApfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJoZXhhZ29uIix6KTtteFV0aWxzLmV4dGVuZChELG14UmVjdGFuZ2xlU2hhcGUpO0QucHJvdG90eXBlLmlzSHRtbEFsbG93ZWQ9CmZ1bmN0aW9uKCl7cmV0dXJuITF9O0QucHJvdG90eXBlLnBhaW50Rm9yZWdyb3VuZD1mdW5jdGlvbihhLGIsZSxjLGQpe3ZhciBmPU1hdGgubWluKGMvNSxkLzUpKzE7YS5iZWdpbigpO2EubW92ZVRvKGIrYy8yLGUrZik7YS5saW5lVG8oYitjLzIsZStkLWYpO2EubW92ZVRvKGIrZixlK2QvMik7YS5saW5lVG8oYitjLWYsZStkLzIpO2EuZW5kKCk7YS5zdHJva2UoKTtteFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5wYWludEZvcmVncm91bmQuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJwbHVzIixEKTt2YXIgTmE9bXhSaG9tYnVzLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlO214UmhvbWJ1cy5wcm90b3R5cGUuZ2V0TGFiZWxCb3VuZHM9ZnVuY3Rpb24oYSl7aWYoMT09dGhpcy5zdHlsZVsiZG91YmxlIl0pe3ZhciBiPSgyKk1hdGgubWF4KDIsdGhpcy5zdHJva2V3aWR0aCsxKStwYXJzZUZsb2F0KHRoaXMuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfTUFSR0lOXXx8CjApKSp0aGlzLnNjYWxlO3JldHVybiBuZXcgbXhSZWN0YW5nbGUoYS54K2IsYS55K2IsYS53aWR0aC0yKmIsYS5oZWlnaHQtMipiKX1yZXR1cm4gYX07bXhSaG9tYnVzLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlPWZ1bmN0aW9uKGEsYixlLGMsZCl7TmEuYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKCF0aGlzLm91dGxpbmUmJjE9PXRoaXMuc3R5bGVbImRvdWJsZSJdKXt2YXIgZj0yKk1hdGgubWF4KDIsdGhpcy5zdHJva2V3aWR0aCsxKStwYXJzZUZsb2F0KHRoaXMuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfTUFSR0lOXXx8MCk7Yis9ZjtlKz1mO2MtPTIqZjtkLT0yKmY7MDxjJiYwPGQmJihhLnNldFNoYWRvdyghMSksTmEuYXBwbHkodGhpcyxbYSxiLGUsYyxkXSkpfX07bXhVdGlscy5leHRlbmQoRyxteFJlY3RhbmdsZVNoYXBlKTtHLnByb3RvdHlwZS5pc0h0bWxBbGxvd2VkPWZ1bmN0aW9uKCl7cmV0dXJuITF9O0cucHJvdG90eXBlLmdldExhYmVsQm91bmRzPWZ1bmN0aW9uKGEpe2lmKDE9PQp0aGlzLnN0eWxlWyJkb3VibGUiXSl7dmFyIGI9KE1hdGgubWF4KDIsdGhpcy5zdHJva2V3aWR0aCsxKStwYXJzZUZsb2F0KHRoaXMuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfTUFSR0lOXXx8MCkpKnRoaXMuc2NhbGU7cmV0dXJuIG5ldyBteFJlY3RhbmdsZShhLngrYixhLnkrYixhLndpZHRoLTIqYixhLmhlaWdodC0yKmIpfXJldHVybiBhfTtHLnByb3RvdHlwZS5wYWludEZvcmVncm91bmQ9ZnVuY3Rpb24oYSxiLGUsYyxkKXtpZihudWxsIT10aGlzLnN0eWxlKXtpZighdGhpcy5vdXRsaW5lJiYxPT10aGlzLnN0eWxlWyJkb3VibGUiXSl7dmFyIGY9TWF0aC5tYXgoMix0aGlzLnN0cm9rZXdpZHRoKzEpK3BhcnNlRmxvYXQodGhpcy5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9NQVJHSU5dfHwwKTtiKz1mO2UrPWY7Yy09MipmO2QtPTIqZjswPGMmJjA8ZCYmbXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUucGFpbnRCYWNrZ3JvdW5kLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1hLnNldERhc2hlZCghMSk7CnZhciBmPTAsZztkb3tnPW14Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXNbdGhpcy5zdHlsZVsic3ltYm9sIitmXV07aWYobnVsbCE9Zyl7dmFyIGw9dGhpcy5zdHlsZVsic3ltYm9sIitmKyJBbGlnbiJdLHA9dGhpcy5zdHlsZVsic3ltYm9sIitmKyJWZXJ0aWNhbEFsaWduIl0sYmE9dGhpcy5zdHlsZVsic3ltYm9sIitmKyJXaWR0aCJdLHU9dGhpcy5zdHlsZVsic3ltYm9sIitmKyJIZWlnaHQiXSxuPXRoaXMuc3R5bGVbInN5bWJvbCIrZisiU3BhY2luZyJdfHwwLHQ9dGhpcy5zdHlsZVsic3ltYm9sIitmKyJWU3BhY2luZyJdfHxuLEI9dGhpcy5zdHlsZVsic3ltYm9sIitmKyJBcmNTcGFjaW5nIl07bnVsbCE9QiYmKEIqPXRoaXMuZ2V0QXJjU2l6ZShjK3RoaXMuc3Ryb2tld2lkdGgsZCt0aGlzLnN0cm9rZXdpZHRoKSxuKz1CLHQrPUIpO3ZhciBCPWIsaz1lLEI9bD09bXhDb25zdGFudHMuQUxJR05fQ0VOVEVSP0IrKGMtYmEpLzI6bD09bXhDb25zdGFudHMuQUxJR05fUklHSFQ/QisKKGMtYmEtbik6QituLGs9cD09bXhDb25zdGFudHMuQUxJR05fTUlERExFP2srKGQtdSkvMjpwPT1teENvbnN0YW50cy5BTElHTl9CT1RUT00/aysoZC11LXQpOmsrdDthLnNhdmUoKTtsPW5ldyBnO2wuc3R5bGU9dGhpcy5zdHlsZTtnLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlLmNhbGwobCxhLEIsayxiYSx1KTthLnJlc3RvcmUoKX1mKyt9d2hpbGUobnVsbCE9Zyl9bXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUucGFpbnRGb3JlZ3JvdW5kLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgiZXh0IixHKTtteFV0aWxzLmV4dGVuZChGLG14Q3lsaW5kZXIpO0YucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGUsYyxkLGYpe2Y/KGEubW92ZVRvKDAsMCksYS5saW5lVG8oYy8yLGQvMiksYS5saW5lVG8oYywwKSxhLmVuZCgpKTooYS5tb3ZlVG8oMCwwKSxhLmxpbmVUbyhjLDApLGEubGluZVRvKGMsZCksYS5saW5lVG8oMCxkKSwKYS5jbG9zZSgpKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgibWVzc2FnZSIsRik7bXhVdGlscy5leHRlbmQoSCxteFNoYXBlKTtILnByb3RvdHlwZS5wYWludEJhY2tncm91bmQ9ZnVuY3Rpb24oYSxiLGUsYyxkKXthLnRyYW5zbGF0ZShiLGUpO2EuZWxsaXBzZShjLzQsMCxjLzIsZC80KTthLmZpbGxBbmRTdHJva2UoKTthLmJlZ2luKCk7YS5tb3ZlVG8oYy8yLGQvNCk7YS5saW5lVG8oYy8yLDIqZC8zKTthLm1vdmVUbyhjLzIsZC8zKTthLmxpbmVUbygwLGQvMyk7YS5tb3ZlVG8oYy8yLGQvMyk7YS5saW5lVG8oYyxkLzMpO2EubW92ZVRvKGMvMiwyKmQvMyk7YS5saW5lVG8oMCxkKTthLm1vdmVUbyhjLzIsMipkLzMpO2EubGluZVRvKGMsZCk7YS5lbmQoKTthLnN0cm9rZSgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJ1bWxBY3RvciIsSCk7bXhVdGlscy5leHRlbmQoSixteFNoYXBlKTtKLnByb3RvdHlwZS5nZXRMYWJlbE1hcmdpbnM9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBteFJlY3RhbmdsZShhLndpZHRoLwo2LDAsMCwwKX07Si5wcm90b3R5cGUucGFpbnRCYWNrZ3JvdW5kPWZ1bmN0aW9uKGEsYixlLGMsZCl7YS50cmFuc2xhdGUoYixlKTthLmJlZ2luKCk7YS5tb3ZlVG8oMCxkLzQpO2EubGluZVRvKDAsMypkLzQpO2EuZW5kKCk7YS5zdHJva2UoKTthLmJlZ2luKCk7YS5tb3ZlVG8oMCxkLzIpO2EubGluZVRvKGMvNixkLzIpO2EuZW5kKCk7YS5zdHJva2UoKTthLmVsbGlwc2UoYy82LDAsNSpjLzYsZCk7YS5maWxsQW5kU3Ryb2tlKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInVtbEJvdW5kYXJ5IixKKTtteFV0aWxzLmV4dGVuZCh1LG14RWxsaXBzZSk7dS5wcm90b3R5cGUucGFpbnRWZXJ0ZXhTaGFwZT1mdW5jdGlvbihhLGIsZSxjLGQpe214RWxsaXBzZS5wcm90b3R5cGUucGFpbnRWZXJ0ZXhTaGFwZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YS5iZWdpbigpO2EubW92ZVRvKGIrYy84LGUrZCk7YS5saW5lVG8oYis3KmMvOCxlK2QpO2EuZW5kKCk7YS5zdHJva2UoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgidW1sRW50aXR5IiwKdSk7bXhVdGlscy5leHRlbmQoSyxteFNoYXBlKTtLLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlPWZ1bmN0aW9uKGEsYixlLGMsZCl7YS50cmFuc2xhdGUoYixlKTthLmJlZ2luKCk7YS5tb3ZlVG8oYywwKTthLmxpbmVUbygwLGQpO2EubW92ZVRvKDAsMCk7YS5saW5lVG8oYyxkKTthLmVuZCgpO2Euc3Ryb2tlKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInVtbERlc3Ryb3kiLEspO214VXRpbHMuZXh0ZW5kKEIsbXhTaGFwZSk7Qi5wcm90b3R5cGUuZ2V0TGFiZWxCb3VuZHM9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBteFJlY3RhbmdsZShhLngsYS55K2EuaGVpZ2h0LzgsYS53aWR0aCw3KmEuaGVpZ2h0LzgpfTtCLnByb3RvdHlwZS5wYWludEJhY2tncm91bmQ9ZnVuY3Rpb24oYSxiLGUsYyxkKXthLnRyYW5zbGF0ZShiLGUpO2EuYmVnaW4oKTthLm1vdmVUbygzKmMvOCxkLzgqMS4xKTthLmxpbmVUbyg1KmMvOCwwKTthLmVuZCgpO2Euc3Ryb2tlKCk7YS5lbGxpcHNlKDAsCmQvOCxjLDcqZC84KTthLmZpbGxBbmRTdHJva2UoKX07Qi5wcm90b3R5cGUucGFpbnRGb3JlZ3JvdW5kPWZ1bmN0aW9uKGEsYixlLGMsZCl7YS5iZWdpbigpO2EubW92ZVRvKDMqYy84LGQvOCoxLjEpO2EubGluZVRvKDUqYy84LGQvNCk7YS5lbmQoKTthLnN0cm9rZSgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJ1bWxDb250cm9sIixCKTtteFV0aWxzLmV4dGVuZChNLG14UmVjdGFuZ2xlU2hhcGUpO00ucHJvdG90eXBlLnNpemU9NDA7TS5wcm90b3R5cGUuaXNIdG1sQWxsb3dlZD1mdW5jdGlvbigpe3JldHVybiExfTtNLnByb3RvdHlwZS5nZXRMYWJlbEJvdW5kcz1mdW5jdGlvbihhKXt2YXIgYj1NYXRoLm1heCgwLE1hdGgubWluKGEuaGVpZ2h0LHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSp0aGlzLnNjYWxlKSk7cmV0dXJuIG5ldyBteFJlY3RhbmdsZShhLngsYS55LGEud2lkdGgsYil9O00ucHJvdG90eXBlLnBhaW50QmFja2dyb3VuZD0KZnVuY3Rpb24oYSxiLGUsYyxkKXt2YXIgZj1NYXRoLm1heCgwLE1hdGgubWluKGQscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInNpemUiLHRoaXMuc2l6ZSkpKSksZz1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInBhcnRpY2lwYW50Iik7bnVsbD09Z3x8bnVsbD09dGhpcy5zdGF0ZT9teFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5wYWludEJhY2tncm91bmQuY2FsbCh0aGlzLGEsYixlLGMsZik6KGc9dGhpcy5zdGF0ZS52aWV3LmdyYXBoLmNlbGxSZW5kZXJlci5nZXRTaGFwZShnKSxudWxsIT1nJiZnIT1NJiYoZz1uZXcgZyxnLmFwcGx5KHRoaXMuc3RhdGUpLGEuc2F2ZSgpLGcucGFpbnRWZXJ0ZXhTaGFwZShhLGIsZSxjLGYpLGEucmVzdG9yZSgpKSk7ZjxkJiYoYS5zZXREYXNoZWQoITApLGEuYmVnaW4oKSxhLm1vdmVUbyhiK2MvMixlK2YpLGEubGluZVRvKGIrYy8yLGUrZCksYS5lbmQoKSxhLnN0cm9rZSgpKX07TS5wcm90b3R5cGUucGFpbnRGb3JlZ3JvdW5kPQpmdW5jdGlvbihhLGIsZSxjLGQpe3ZhciBmPU1hdGgubWF4KDAsTWF0aC5taW4oZCxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSkpKTtteFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5wYWludEZvcmVncm91bmQuY2FsbCh0aGlzLGEsYixlLGMsTWF0aC5taW4oZCxmKSl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInVtbExpZmVsaW5lIixNKTtteFV0aWxzLmV4dGVuZChQLG14U2hhcGUpO1AucHJvdG90eXBlLndpZHRoPTYwO1AucHJvdG90eXBlLmhlaWdodD0zMDtQLnByb3RvdHlwZS5jb3JuZXI9MTA7UC5wcm90b3R5cGUuZ2V0TGFiZWxNYXJnaW5zPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgbXhSZWN0YW5nbGUoMCwwLGEud2lkdGgtcGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsIndpZHRoIix0aGlzLndpZHRoKSp0aGlzLnNjYWxlKSxhLmhlaWdodC1wYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwKImhlaWdodCIsdGhpcy5oZWlnaHQpKnRoaXMuc2NhbGUpKX07UC5wcm90b3R5cGUucGFpbnRCYWNrZ3JvdW5kPWZ1bmN0aW9uKGEsYixlLGMsZCl7dmFyIGY9dGhpcy5jb3JuZXIsZz1NYXRoLm1pbihjLE1hdGgubWF4KGYscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsIndpZHRoIix0aGlzLndpZHRoKSkpKSxsPU1hdGgubWluKGQsTWF0aC5tYXgoMS41KmYscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImhlaWdodCIsdGhpcy5oZWlnaHQpKSkpLHA9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1NXSU1MQU5FX0ZJTExDT0xPUixteENvbnN0YW50cy5OT05FKTtwIT1teENvbnN0YW50cy5OT05FJiYoYS5zZXRGaWxsQ29sb3IocCksYS5yZWN0KGIsZSxjLGQpLGEuZmlsbCgpKTtudWxsIT10aGlzLmZpbGwmJnRoaXMuZmlsbCE9bXhDb25zdGFudHMuTk9ORSYmdGhpcy5ncmFkaWVudCYmdGhpcy5ncmFkaWVudCE9Cm14Q29uc3RhbnRzLk5PTkU/KHRoaXMuZ2V0R3JhZGllbnRCb3VuZHMoYSxiLGUsYyxkKSxhLnNldEdyYWRpZW50KHRoaXMuZmlsbCx0aGlzLmdyYWRpZW50LGIsZSxjLGQsdGhpcy5ncmFkaWVudERpcmVjdGlvbikpOmEuc2V0RmlsbENvbG9yKHRoaXMuZmlsbCk7YS5iZWdpbigpO2EubW92ZVRvKGIsZSk7YS5saW5lVG8oYitnLGUpO2EubGluZVRvKGIrZyxlK01hdGgubWF4KDAsbC0xLjUqZikpO2EubGluZVRvKGIrTWF0aC5tYXgoMCxnLWYpLGUrbCk7YS5saW5lVG8oYixlK2wpO2EuY2xvc2UoKTthLmZpbGxBbmRTdHJva2UoKTthLmJlZ2luKCk7YS5tb3ZlVG8oYitnLGUpO2EubGluZVRvKGIrYyxlKTthLmxpbmVUbyhiK2MsZStkKTthLmxpbmVUbyhiLGUrZCk7YS5saW5lVG8oYixlK2wpO2Euc3Ryb2tlKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInVtbEZyYW1lIixQKTtteFBlcmltZXRlci5MaWZlbGluZVBlcmltZXRlcj1mdW5jdGlvbihhLGIsZSxjKXtjPU0ucHJvdG90eXBlLnNpemU7Cm51bGwhPWImJihjPW14VXRpbHMuZ2V0VmFsdWUoYi5zdHlsZSwic2l6ZSIsYykqYi52aWV3LnNjYWxlKTtiPXBhcnNlRmxvYXQoYi5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TVFJPS0VXSURUSF18fDEpKmIudmlldy5zY2FsZS8yLTE7ZS54PGEuZ2V0Q2VudGVyWCgpJiYoYj0tMSooYisxKSk7cmV0dXJuIG5ldyBteFBvaW50KGEuZ2V0Q2VudGVyWCgpK2IsTWF0aC5taW4oYS55K2EuaGVpZ2h0LE1hdGgubWF4KGEueStjLGUueSkpKX07bXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKCJsaWZlbGluZVBlcmltZXRlciIsbXhQZXJpbWV0ZXIuTGlmZWxpbmVQZXJpbWV0ZXIpO214UGVyaW1ldGVyLk9ydGhvZ29uYWxQZXJpbWV0ZXI9ZnVuY3Rpb24oYSxiLGUsYyl7Yz0hMDtyZXR1cm4gbXhQZXJpbWV0ZXIuUmVjdGFuZ2xlUGVyaW1ldGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07bXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKCJvcnRob2dvbmFsUGVyaW1ldGVyIixteFBlcmltZXRlci5PcnRob2dvbmFsUGVyaW1ldGVyKTsKbXhQZXJpbWV0ZXIuQmFja2JvbmVQZXJpbWV0ZXI9ZnVuY3Rpb24oYSxiLGUsYyl7Yz1wYXJzZUZsb2F0KGIuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1RST0tFV0lEVEhdfHwxKSpiLnZpZXcuc2NhbGUvMi0xO251bGwhPWIuc3R5bGUuYmFja2JvbmVTaXplJiYoYys9cGFyc2VGbG9hdChiLnN0eWxlLmJhY2tib25lU2l6ZSkqYi52aWV3LnNjYWxlLzItMSk7aWYoInNvdXRoIj09Yi5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ESVJFQ1RJT05dfHwibm9ydGgiPT1iLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0RJUkVDVElPTl0pcmV0dXJuIGUueDxhLmdldENlbnRlclgoKSYmKGM9LTEqKGMrMSkpLG5ldyBteFBvaW50KGEuZ2V0Q2VudGVyWCgpK2MsTWF0aC5taW4oYS55K2EuaGVpZ2h0LE1hdGgubWF4KGEueSxlLnkpKSk7ZS55PGEuZ2V0Q2VudGVyWSgpJiYoYz0tMSooYysxKSk7cmV0dXJuIG5ldyBteFBvaW50KE1hdGgubWluKGEueCthLndpZHRoLE1hdGgubWF4KGEueCxlLngpKSwKYS5nZXRDZW50ZXJZKCkrYyl9O214U3R5bGVSZWdpc3RyeS5wdXRWYWx1ZSgiYmFja2JvbmVQZXJpbWV0ZXIiLG14UGVyaW1ldGVyLkJhY2tib25lUGVyaW1ldGVyKTtteFBlcmltZXRlci5DYWxsb3V0UGVyaW1ldGVyPWZ1bmN0aW9uKGEsYixlLGMpe3JldHVybiBteFBlcmltZXRlci5SZWN0YW5nbGVQZXJpbWV0ZXIobXhVdGlscy5nZXREaXJlY3RlZEJvdW5kcyhhLG5ldyBteFJlY3RhbmdsZSgwLDAsMCxNYXRoLm1heCgwLE1hdGgubWluKGEuaGVpZ2h0LHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZShiLnN0eWxlLCJzaXplIixBLnByb3RvdHlwZS5zaXplKSkqYi52aWV3LnNjYWxlKSkpLGIuc3R5bGUpLGIsZSxjKX07bXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKCJjYWxsb3V0UGVyaW1ldGVyIixteFBlcmltZXRlci5DYWxsb3V0UGVyaW1ldGVyKTtteFBlcmltZXRlci5QYXJhbGxlbG9ncmFtUGVyaW1ldGVyPWZ1bmN0aW9uKGEsYixlLGMpe3ZhciBkPWwucHJvdG90eXBlLnNpemU7Cm51bGwhPWImJihkPW14VXRpbHMuZ2V0VmFsdWUoYi5zdHlsZSwic2l6ZSIsZCkpO3ZhciBmPWEueCxnPWEueSxwPWEud2lkdGgsdT1hLmhlaWdodDtiPW51bGwhPWI/bXhVdGlscy5nZXRWYWx1ZShiLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0RJUkVDVElPTixteENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVCk6bXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1Q7Yj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIfHxiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEg/KGQ9dSpNYXRoLm1heCgwLE1hdGgubWluKDEsZCkpLGc9W25ldyBteFBvaW50KGYsZyksbmV3IG14UG9pbnQoZitwLGcrZCksbmV3IG14UG9pbnQoZitwLGcrdSksbmV3IG14UG9pbnQoZixnK3UtZCksbmV3IG14UG9pbnQoZixnKV0pOihkPXAqTWF0aC5tYXgoMCxNYXRoLm1pbigxLGQpKSxnPVtuZXcgbXhQb2ludChmK2QsZyksbmV3IG14UG9pbnQoZitwLGcpLG5ldyBteFBvaW50KGYrcC1kLGcrdSksbmV3IG14UG9pbnQoZiwKZyt1KSxuZXcgbXhQb2ludChmK2QsZyldKTt1PWEuZ2V0Q2VudGVyWCgpO2E9YS5nZXRDZW50ZXJZKCk7YT1uZXcgbXhQb2ludCh1LGEpO2MmJihlLng8Znx8ZS54PmYrcD9hLnk9ZS55OmEueD1lLngpO3JldHVybiBteFV0aWxzLmdldFBlcmltZXRlclBvaW50KGcsYSxlKX07bXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKCJwYXJhbGxlbG9ncmFtUGVyaW1ldGVyIixteFBlcmltZXRlci5QYXJhbGxlbG9ncmFtUGVyaW1ldGVyKTtteFBlcmltZXRlci5UcmFwZXpvaWRQZXJpbWV0ZXI9ZnVuY3Rpb24oYSxiLGUsYyl7dmFyIGQ9bi5wcm90b3R5cGUuc2l6ZTtudWxsIT1iJiYoZD1teFV0aWxzLmdldFZhbHVlKGIuc3R5bGUsInNpemUiLGQpKTt2YXIgZj1hLngsZz1hLnksbD1hLndpZHRoLHA9YS5oZWlnaHQ7Yj1udWxsIT1iP214VXRpbHMuZ2V0VmFsdWUoYi5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ESVJFQ1RJT04sbXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1QpOm14Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNUOwpiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVD8oZD1sKk1hdGgubWF4KDAsTWF0aC5taW4oMSxkKSksZz1bbmV3IG14UG9pbnQoZitkLGcpLG5ldyBteFBvaW50KGYrbC1kLGcpLG5ldyBteFBvaW50KGYrbCxnK3ApLG5ldyBteFBvaW50KGYsZytwKSxuZXcgbXhQb2ludChmK2QsZyldKTpiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVD8oZD1sKk1hdGgubWF4KDAsTWF0aC5taW4oMSxkKSksZz1bbmV3IG14UG9pbnQoZixnKSxuZXcgbXhQb2ludChmK2wsZyksbmV3IG14UG9pbnQoZitsLWQsZytwKSxuZXcgbXhQb2ludChmK2QsZytwKSxuZXcgbXhQb2ludChmLGcpXSk6Yj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIPyhkPXAqTWF0aC5tYXgoMCxNYXRoLm1pbigxLGQpKSxnPVtuZXcgbXhQb2ludChmLGcrZCksbmV3IG14UG9pbnQoZitsLGcpLG5ldyBteFBvaW50KGYrbCxnK3ApLG5ldyBteFBvaW50KGYsZytwLWQpLG5ldyBteFBvaW50KGYsZytkKV0pOihkPXAqTWF0aC5tYXgoMCwKTWF0aC5taW4oMSxkKSksZz1bbmV3IG14UG9pbnQoZixnKSxuZXcgbXhQb2ludChmK2wsZytkKSxuZXcgbXhQb2ludChmK2wsZytwLWQpLG5ldyBteFBvaW50KGYsZytwKSxuZXcgbXhQb2ludChmLGcpXSk7cD1hLmdldENlbnRlclgoKTthPWEuZ2V0Q2VudGVyWSgpO2E9bmV3IG14UG9pbnQocCxhKTtjJiYoZS54PGZ8fGUueD5mK2w/YS55PWUueTphLng9ZS54KTtyZXR1cm4gbXhVdGlscy5nZXRQZXJpbWV0ZXJQb2ludChnLGEsZSl9O214U3R5bGVSZWdpc3RyeS5wdXRWYWx1ZSgidHJhcGV6b2lkUGVyaW1ldGVyIixteFBlcmltZXRlci5UcmFwZXpvaWRQZXJpbWV0ZXIpO214UGVyaW1ldGVyLlN0ZXBQZXJpbWV0ZXI9ZnVuY3Rpb24oYSxiLGUsYyl7dmFyIGQ9IjAiIT1teFV0aWxzLmdldFZhbHVlKGIuc3R5bGUsImZpeGVkU2l6ZSIsIjAiKSxmPWQ/Qy5wcm90b3R5cGUuZml4ZWRTaXplOkMucHJvdG90eXBlLnNpemU7bnVsbCE9YiYmKGY9bXhVdGlscy5nZXRWYWx1ZShiLnN0eWxlLAoic2l6ZSIsZikpO3ZhciBnPWEueCxsPWEueSxwPWEud2lkdGgsdT1hLmhlaWdodCxuPWEuZ2V0Q2VudGVyWCgpO2E9YS5nZXRDZW50ZXJZKCk7Yj1udWxsIT1iP214VXRpbHMuZ2V0VmFsdWUoYi5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ESVJFQ1RJT04sbXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1QpOm14Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNUO2I9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNUPyhkPWQ/TWF0aC5tYXgoMCxNYXRoLm1pbihwLGYpKTpwKk1hdGgubWF4KDAsTWF0aC5taW4oMSxmKSksbD1bbmV3IG14UG9pbnQoZyxsKSxuZXcgbXhQb2ludChnK3AtZCxsKSxuZXcgbXhQb2ludChnK3AsYSksbmV3IG14UG9pbnQoZytwLWQsbCt1KSxuZXcgbXhQb2ludChnLGwrdSksbmV3IG14UG9pbnQoZytkLGEpLG5ldyBteFBvaW50KGcsbCldKTpiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVD8oZD1kP01hdGgubWF4KDAsTWF0aC5taW4ocCxmKSk6cCpNYXRoLm1heCgwLApNYXRoLm1pbigxLGYpKSxsPVtuZXcgbXhQb2ludChnK2QsbCksbmV3IG14UG9pbnQoZytwLGwpLG5ldyBteFBvaW50KGcrcC1kLGEpLG5ldyBteFBvaW50KGcrcCxsK3UpLG5ldyBteFBvaW50KGcrZCxsK3UpLG5ldyBteFBvaW50KGcsYSksbmV3IG14UG9pbnQoZytkLGwpXSk6Yj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIPyhkPWQ/TWF0aC5tYXgoMCxNYXRoLm1pbih1LGYpKTp1Kk1hdGgubWF4KDAsTWF0aC5taW4oMSxmKSksbD1bbmV3IG14UG9pbnQoZyxsK2QpLG5ldyBteFBvaW50KG4sbCksbmV3IG14UG9pbnQoZytwLGwrZCksbmV3IG14UG9pbnQoZytwLGwrdSksbmV3IG14UG9pbnQobixsK3UtZCksbmV3IG14UG9pbnQoZyxsK3UpLG5ldyBteFBvaW50KGcsbCtkKV0pOihkPWQ/TWF0aC5tYXgoMCxNYXRoLm1pbih1LGYpKTp1Kk1hdGgubWF4KDAsTWF0aC5taW4oMSxmKSksbD1bbmV3IG14UG9pbnQoZyxsKSxuZXcgbXhQb2ludChuLGwrZCksbmV3IG14UG9pbnQoZysKcCxsKSxuZXcgbXhQb2ludChnK3AsbCt1LWQpLG5ldyBteFBvaW50KG4sbCt1KSxuZXcgbXhQb2ludChnLGwrdS1kKSxuZXcgbXhQb2ludChnLGwpXSk7bj1uZXcgbXhQb2ludChuLGEpO2MmJihlLng8Z3x8ZS54PmcrcD9uLnk9ZS55Om4ueD1lLngpO3JldHVybiBteFV0aWxzLmdldFBlcmltZXRlclBvaW50KGwsbixlKX07bXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKCJzdGVwUGVyaW1ldGVyIixteFBlcmltZXRlci5TdGVwUGVyaW1ldGVyKTtteFBlcmltZXRlci5IZXhhZ29uUGVyaW1ldGVyMj1mdW5jdGlvbihhLGIsZSxjKXt2YXIgZD16LnByb3RvdHlwZS5zaXplO251bGwhPWImJihkPW14VXRpbHMuZ2V0VmFsdWUoYi5zdHlsZSwic2l6ZSIsZCkpO3ZhciBmPWEueCxnPWEueSxsPWEud2lkdGgscD1hLmhlaWdodCx1PWEuZ2V0Q2VudGVyWCgpO2E9YS5nZXRDZW50ZXJZKCk7Yj1udWxsIT1iP214VXRpbHMuZ2V0VmFsdWUoYi5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ESVJFQ1RJT04sCm14Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNUKTpteENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVDtiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEh8fGI9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSD8oZD1wKk1hdGgubWF4KDAsTWF0aC5taW4oMSxkKSksZz1bbmV3IG14UG9pbnQodSxnKSxuZXcgbXhQb2ludChmK2wsZytkKSxuZXcgbXhQb2ludChmK2wsZytwLWQpLG5ldyBteFBvaW50KHUsZytwKSxuZXcgbXhQb2ludChmLGcrcC1kKSxuZXcgbXhQb2ludChmLGcrZCksbmV3IG14UG9pbnQodSxnKV0pOihkPWwqTWF0aC5tYXgoMCxNYXRoLm1pbigxLGQpKSxnPVtuZXcgbXhQb2ludChmK2QsZyksbmV3IG14UG9pbnQoZitsLWQsZyksbmV3IG14UG9pbnQoZitsLGEpLG5ldyBteFBvaW50KGYrbC1kLGcrcCksbmV3IG14UG9pbnQoZitkLGcrcCksbmV3IG14UG9pbnQoZixhKSxuZXcgbXhQb2ludChmK2QsZyldKTt1PW5ldyBteFBvaW50KHUsYSk7YyYmKGUueDxmfHxlLng+ZisKbD91Lnk9ZS55OnUueD1lLngpO3JldHVybiBteFV0aWxzLmdldFBlcmltZXRlclBvaW50KGcsdSxlKX07bXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKCJoZXhhZ29uUGVyaW1ldGVyMiIsbXhQZXJpbWV0ZXIuSGV4YWdvblBlcmltZXRlcjIpO214VXRpbHMuZXh0ZW5kKEksbXhTaGFwZSk7SS5wcm90b3R5cGUuc2l6ZT0xMDtJLnByb3RvdHlwZS5wYWludEJhY2tncm91bmQ9ZnVuY3Rpb24oYSxiLGUsYyxkKXt2YXIgZj1wYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSk7YS50cmFuc2xhdGUoYixlKTthLmVsbGlwc2UoKGMtZikvMiwwLGYsZik7YS5maWxsQW5kU3Ryb2tlKCk7YS5iZWdpbigpO2EubW92ZVRvKGMvMixmKTthLmxpbmVUbyhjLzIsZCk7YS5lbmQoKTthLnN0cm9rZSgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJsb2xsaXBvcCIsSSk7bXhVdGlscy5leHRlbmQoUixteFNoYXBlKTtSLnByb3RvdHlwZS5zaXplPQoxMDtSLnByb3RvdHlwZS5pbnNldD0yO1IucHJvdG90eXBlLnBhaW50QmFja2dyb3VuZD1mdW5jdGlvbihhLGIsZSxjLGQpe3ZhciBmPXBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSxnPXBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJpbnNldCIsdGhpcy5pbnNldCkpK3RoaXMuc3Ryb2tld2lkdGg7YS50cmFuc2xhdGUoYixlKTthLmJlZ2luKCk7YS5tb3ZlVG8oYy8yLGYrZyk7YS5saW5lVG8oYy8yLGQpO2EuZW5kKCk7YS5zdHJva2UoKTthLmJlZ2luKCk7YS5tb3ZlVG8oKGMtZikvMi1nLGYvMik7YS5xdWFkVG8oKGMtZikvMi1nLGYrZyxjLzIsZitnKTthLnF1YWRUbygoYytmKS8yK2csZitnLChjK2YpLzIrZyxmLzIpO2EuZW5kKCk7YS5zdHJva2UoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgicmVxdWlyZXMiLFIpO214VXRpbHMuZXh0ZW5kKGVhLG14U2hhcGUpO2VhLnByb3RvdHlwZS5wYWludEJhY2tncm91bmQ9CmZ1bmN0aW9uKGEsYixlLGMsZCl7YS50cmFuc2xhdGUoYixlKTthLmJlZ2luKCk7YS5tb3ZlVG8oMCwwKTthLnF1YWRUbyhjLDAsYyxkLzIpO2EucXVhZFRvKGMsZCwwLGQpO2EuZW5kKCk7YS5zdHJva2UoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgicmVxdWlyZWRJbnRlcmZhY2UiLGVhKTtteFV0aWxzLmV4dGVuZChmYSxteFNoYXBlKTtmYS5wcm90b3R5cGUuaW5zZXQ9MjtmYS5wcm90b3R5cGUucGFpbnRCYWNrZ3JvdW5kPWZ1bmN0aW9uKGEsYixlLGMsZCl7dmFyIGY9cGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImluc2V0Iix0aGlzLmluc2V0KSkrdGhpcy5zdHJva2V3aWR0aDthLnRyYW5zbGF0ZShiLGUpO2EuZWxsaXBzZSgwLGYsYy0yKmYsZC0yKmYpO2EuZmlsbEFuZFN0cm9rZSgpO2EuYmVnaW4oKTthLm1vdmVUbyhjLzIsMCk7YS5xdWFkVG8oYywwLGMsZC8yKTthLnF1YWRUbyhjLGQsYy8yLGQpO2EuZW5kKCk7YS5zdHJva2UoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgicHJvdmlkZWRSZXF1aXJlZEludGVyZmFjZSIsCmZhKTtteFV0aWxzLmV4dGVuZChZLG14Q3lsaW5kZXIpO1kucHJvdG90eXBlLmpldHR5V2lkdGg9MjA7WS5wcm90b3R5cGUuamV0dHlIZWlnaHQ9MTA7WS5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsZSxjLGQsZil7dmFyIGc9cGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImpldHR5V2lkdGgiLHRoaXMuamV0dHlXaWR0aCkpO2I9cGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImpldHR5SGVpZ2h0Iix0aGlzLmpldHR5SGVpZ2h0KSk7ZT1nLzI7dmFyIGc9ZStnLzIsbD1NYXRoLm1pbihiLGQtYikscD1NYXRoLm1pbihsKzIqYixkLWIpO2Y/KGEubW92ZVRvKGUsbCksYS5saW5lVG8oZyxsKSxhLmxpbmVUbyhnLGwrYiksYS5saW5lVG8oZSxsK2IpLGEubW92ZVRvKGUscCksYS5saW5lVG8oZyxwKSxhLmxpbmVUbyhnLHArYiksYS5saW5lVG8oZSxwK2IpKTooYS5tb3ZlVG8oZSwwKSxhLmxpbmVUbyhjLDApLGEubGluZVRvKGMsCmQpLGEubGluZVRvKGUsZCksYS5saW5lVG8oZSxwK2IpLGEubGluZVRvKDAscCtiKSxhLmxpbmVUbygwLHApLGEubGluZVRvKGUscCksYS5saW5lVG8oZSxsK2IpLGEubGluZVRvKDAsbCtiKSxhLmxpbmVUbygwLGwpLGEubGluZVRvKGUsbCksYS5jbG9zZSgpKTthLmVuZCgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJtb2R1bGUiLFkpO214VXRpbHMuZXh0ZW5kKFosbXhDeWxpbmRlcik7Wi5wcm90b3R5cGUuamV0dHlXaWR0aD0zMjtaLnByb3RvdHlwZS5qZXR0eUhlaWdodD0xMjtaLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCxmKXt2YXIgZz1wYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwiamV0dHlXaWR0aCIsdGhpcy5qZXR0eVdpZHRoKSk7Yj1wYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwiamV0dHlIZWlnaHQiLHRoaXMuamV0dHlIZWlnaHQpKTtlPWcvMjt2YXIgZz1lK2cvMixsPS4zKmQtYi8KMixwPS43KmQtYi8yO2Y/KGEubW92ZVRvKGUsbCksYS5saW5lVG8oZyxsKSxhLmxpbmVUbyhnLGwrYiksYS5saW5lVG8oZSxsK2IpLGEubW92ZVRvKGUscCksYS5saW5lVG8oZyxwKSxhLmxpbmVUbyhnLHArYiksYS5saW5lVG8oZSxwK2IpKTooYS5tb3ZlVG8oZSwwKSxhLmxpbmVUbyhjLDApLGEubGluZVRvKGMsZCksYS5saW5lVG8oZSxkKSxhLmxpbmVUbyhlLHArYiksYS5saW5lVG8oMCxwK2IpLGEubGluZVRvKDAscCksYS5saW5lVG8oZSxwKSxhLmxpbmVUbyhlLGwrYiksYS5saW5lVG8oMCxsK2IpLGEubGluZVRvKDAsbCksYS5saW5lVG8oZSxsKSxhLmNsb3NlKCkpO2EuZW5kKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImNvbXBvbmVudCIsWik7bXhVdGlscy5leHRlbmQoWCxteFJlY3RhbmdsZVNoYXBlKTtYLnByb3RvdHlwZS5wYWludEZvcmVncm91bmQ9ZnVuY3Rpb24oYSxiLGUsYyxkKXt2YXIgZj1jLzIsZz1kLzIsbD1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsCm14Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkUsbXhDb25zdGFudHMuTElORV9BUkNTSVpFKS8yO2EuYmVnaW4oKTt0aGlzLmFkZFBvaW50cyhhLFtuZXcgbXhQb2ludChiK2YsZSksbmV3IG14UG9pbnQoYitjLGUrZyksbmV3IG14UG9pbnQoYitmLGUrZCksbmV3IG14UG9pbnQoYixlK2cpXSx0aGlzLmlzUm91bmRlZCxsLCEwKTthLnN0cm9rZSgpO214UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLnBhaW50Rm9yZWdyb3VuZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImFzc29jaWF0aXZlRW50aXR5IixYKTtteFV0aWxzLmV4dGVuZChhYSxteERvdWJsZUVsbGlwc2UpO2FhLnByb3RvdHlwZS5vdXRlclN0cm9rZT0hMDthYS5wcm90b3R5cGUucGFpbnRWZXJ0ZXhTaGFwZT1mdW5jdGlvbihhLGIsZSxjLGQpe3ZhciBmPU1hdGgubWluKDQsTWF0aC5taW4oYy81LGQvNSkpOzA8YyYmMDxkJiYoYS5lbGxpcHNlKGIrZixlK2YsYy0yKmYsZC0yKgpmKSxhLmZpbGxBbmRTdHJva2UoKSk7YS5zZXRTaGFkb3coITEpO3RoaXMub3V0ZXJTdHJva2UmJihhLmVsbGlwc2UoYixlLGMsZCksYS5zdHJva2UoKSl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImVuZFN0YXRlIixhYSk7bXhVdGlscy5leHRlbmQoZ2EsYWEpO2dhLnByb3RvdHlwZS5vdXRlclN0cm9rZT0hMTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJzdGFydFN0YXRlIixnYSk7bXhVdGlscy5leHRlbmQoZGEsbXhBcnJvd0Nvbm5lY3Rvcik7ZGEucHJvdG90eXBlLmRlZmF1bHRXaWR0aD00O2RhLnByb3RvdHlwZS5pc09wZW5FbmRlZD1mdW5jdGlvbigpe3JldHVybiEwfTtkYS5wcm90b3R5cGUuZ2V0RWRnZVdpZHRoPWZ1bmN0aW9uKCl7cmV0dXJuIG14VXRpbHMuZ2V0TnVtYmVyKHRoaXMuc3R5bGUsIndpZHRoIix0aGlzLmRlZmF1bHRXaWR0aCkrTWF0aC5tYXgoMCx0aGlzLnN0cm9rZXdpZHRoLTEpfTtkYS5wcm90b3R5cGUuaXNBcnJvd1JvdW5kZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1JvdW5kZWR9OwpteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJsaW5rIixkYSk7bXhVdGlscy5leHRlbmQoVSxteEFycm93Q29ubmVjdG9yKTtVLnByb3RvdHlwZS5kZWZhdWx0V2lkdGg9MTA7VS5wcm90b3R5cGUuZGVmYXVsdEFycm93V2lkdGg9MjA7VS5wcm90b3R5cGUuZ2V0U3RhcnRBcnJvd1dpZHRoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RWRnZVdpZHRoKCkrbXhVdGlscy5nZXROdW1iZXIodGhpcy5zdHlsZSwic3RhcnRXaWR0aCIsdGhpcy5kZWZhdWx0QXJyb3dXaWR0aCl9O1UucHJvdG90eXBlLmdldEVuZEFycm93V2lkdGg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRFZGdlV2lkdGgoKStteFV0aWxzLmdldE51bWJlcih0aGlzLnN0eWxlLCJlbmRXaWR0aCIsdGhpcy5kZWZhdWx0QXJyb3dXaWR0aCl9O1UucHJvdG90eXBlLmdldEVkZ2VXaWR0aD1mdW5jdGlvbigpe3JldHVybiBteFV0aWxzLmdldE51bWJlcih0aGlzLnN0eWxlLCJ3aWR0aCIsdGhpcy5kZWZhdWx0V2lkdGgpKwpNYXRoLm1heCgwLHRoaXMuc3Ryb2tld2lkdGgtMSl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImZsZXhBcnJvdyIsVSk7bXhVdGlscy5leHRlbmQoY2EsbXhBY3Rvcik7Y2EucHJvdG90eXBlLnNpemU9MzA7Y2EucHJvdG90eXBlLmlzUm91bmRhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2NhLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCl7Yj1NYXRoLm1pbihkLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSk7ZT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSxteENvbnN0YW50cy5MSU5FX0FSQ1NJWkUpLzI7dGhpcy5hZGRQb2ludHMoYSxbbmV3IG14UG9pbnQoMCxkKSxuZXcgbXhQb2ludCgwLGIpLG5ldyBteFBvaW50KGMsMCksbmV3IG14UG9pbnQoYyxkKV0sdGhpcy5pc1JvdW5kZWQsZSwhMCk7YS5lbmQoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgibWFudWFsSW5wdXQiLApjYSk7bXhVdGlscy5leHRlbmQoUSxteFJlY3RhbmdsZVNoYXBlKTtRLnByb3RvdHlwZS5keD0yMDtRLnByb3RvdHlwZS5keT0yMDtRLnByb3RvdHlwZS5pc0h0bWxBbGxvd2VkPWZ1bmN0aW9uKCl7cmV0dXJuITF9O1EucHJvdG90eXBlLnBhaW50Rm9yZWdyb3VuZD1mdW5jdGlvbihhLGIsZSxjLGQpe214UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLnBhaW50Rm9yZWdyb3VuZC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGY9MDtpZih0aGlzLmlzUm91bmRlZCl2YXIgZz1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSwxMDAqbXhDb25zdGFudHMuUkVDVEFOR0xFX1JPVU5ESU5HX0ZBQ1RPUikvMTAwLGY9TWF0aC5tYXgoZixNYXRoLm1pbihjKmcsZCpnKSk7Zz1NYXRoLm1heChmLE1hdGgubWluKGMscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImR4Iix0aGlzLmR4KSkpKTtmPU1hdGgubWF4KGYsTWF0aC5taW4oZCwKcGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImR5Iix0aGlzLmR5KSkpKTthLmJlZ2luKCk7YS5tb3ZlVG8oYixlK2YpO2EubGluZVRvKGIrYyxlK2YpO2EuZW5kKCk7YS5zdHJva2UoKTthLmJlZ2luKCk7YS5tb3ZlVG8oYitnLGUpO2EubGluZVRvKGIrZyxlK2QpO2EuZW5kKCk7YS5zdHJva2UoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgiaW50ZXJuYWxTdG9yYWdlIixRKTtteFV0aWxzLmV4dGVuZChMLG14QWN0b3IpO0wucHJvdG90eXBlLmR4PTIwO0wucHJvdG90eXBlLmR5PTIwO0wucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGUsYyxkKXtiPU1hdGgubWF4KDAsTWF0aC5taW4oYyxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwiZHgiLHRoaXMuZHgpKSkpO2U9TWF0aC5tYXgoMCxNYXRoLm1pbihkLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJkeSIsdGhpcy5keSkpKSk7cGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsCiJzaXplIix0aGlzLnNpemUpKTt2YXIgZj1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSxteENvbnN0YW50cy5MSU5FX0FSQ1NJWkUpLzI7dGhpcy5hZGRQb2ludHMoYSxbbmV3IG14UG9pbnQoMCwwKSxuZXcgbXhQb2ludChjLDApLG5ldyBteFBvaW50KGMsZSksbmV3IG14UG9pbnQoYixlKSxuZXcgbXhQb2ludChiLGQpLG5ldyBteFBvaW50KDAsZCldLHRoaXMuaXNSb3VuZGVkLGYsITApO2EuZW5kKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImNvcm5lciIsTCk7bXhVdGlscy5leHRlbmQoamEsbXhBY3Rvcik7amEucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGUsYyxkKXthLm1vdmVUbygwLDApO2EubGluZVRvKDAsZCk7YS5lbmQoKTthLm1vdmVUbyhjLDApO2EubGluZVRvKGMsZCk7YS5lbmQoKTthLm1vdmVUbygwLGQvMik7YS5saW5lVG8oYyxkLzIpO2EuZW5kKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImNyb3NzYmFyIiwKamEpO214VXRpbHMuZXh0ZW5kKE8sbXhBY3Rvcik7Ty5wcm90b3R5cGUuZHg9MjA7Ty5wcm90b3R5cGUuZHk9MjA7Ty5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsZSxjLGQpe2I9TWF0aC5tYXgoMCxNYXRoLm1pbihjLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJkeCIsdGhpcy5keCkpKSk7ZT1NYXRoLm1heCgwLE1hdGgubWluKGQscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImR5Iix0aGlzLmR5KSkpKTtwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSk7dmFyIGY9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkUsbXhDb25zdGFudHMuTElORV9BUkNTSVpFKS8yO3RoaXMuYWRkUG9pbnRzKGEsW25ldyBteFBvaW50KDAsMCksbmV3IG14UG9pbnQoYywwKSxuZXcgbXhQb2ludChjLGUpLG5ldyBteFBvaW50KChjK2IpLwoyLGUpLG5ldyBteFBvaW50KChjK2IpLzIsZCksbmV3IG14UG9pbnQoKGMtYikvMixkKSxuZXcgbXhQb2ludCgoYy1iKS8yLGUpLG5ldyBteFBvaW50KDAsZSldLHRoaXMuaXNSb3VuZGVkLGYsITApO2EuZW5kKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInRlZSIsTyk7bXhVdGlscy5leHRlbmQoUyxteEFjdG9yKTtTLnByb3RvdHlwZS5hcnJvd1dpZHRoPS4zO1MucHJvdG90eXBlLmFycm93U2l6ZT0uMjtTLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCl7dmFyIGY9ZCpNYXRoLm1heCgwLE1hdGgubWluKDEscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImFycm93V2lkdGgiLHRoaXMuYXJyb3dXaWR0aCkpKSk7Yj1jKk1hdGgubWF4KDAsTWF0aC5taW4oMSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwiYXJyb3dTaXplIix0aGlzLmFycm93U2l6ZSkpKSk7ZT0oZC1mKS8yO3ZhciBmPWUrZixnPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwKbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSxteENvbnN0YW50cy5MSU5FX0FSQ1NJWkUpLzI7dGhpcy5hZGRQb2ludHMoYSxbbmV3IG14UG9pbnQoMCxlKSxuZXcgbXhQb2ludChjLWIsZSksbmV3IG14UG9pbnQoYy1iLDApLG5ldyBteFBvaW50KGMsZC8yKSxuZXcgbXhQb2ludChjLWIsZCksbmV3IG14UG9pbnQoYy1iLGYpLG5ldyBteFBvaW50KDAsZildLHRoaXMuaXNSb3VuZGVkLGcsITApO2EuZW5kKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInNpbmdsZUFycm93IixTKTtteFV0aWxzLmV4dGVuZChpYSxteEFjdG9yKTtpYS5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsZSxjLGQpe3ZhciBmPWQqTWF0aC5tYXgoMCxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJhcnJvd1dpZHRoIixTLnByb3RvdHlwZS5hcnJvd1dpZHRoKSkpKTtiPWMqTWF0aC5tYXgoMCxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLAoiYXJyb3dTaXplIixTLnByb3RvdHlwZS5hcnJvd1NpemUpKSkpO2U9KGQtZikvMjt2YXIgZj1lK2YsZz1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSxteENvbnN0YW50cy5MSU5FX0FSQ1NJWkUpLzI7dGhpcy5hZGRQb2ludHMoYSxbbmV3IG14UG9pbnQoMCxkLzIpLG5ldyBteFBvaW50KGIsMCksbmV3IG14UG9pbnQoYixlKSxuZXcgbXhQb2ludChjLWIsZSksbmV3IG14UG9pbnQoYy1iLDApLG5ldyBteFBvaW50KGMsZC8yKSxuZXcgbXhQb2ludChjLWIsZCksbmV3IG14UG9pbnQoYy1iLGYpLG5ldyBteFBvaW50KGIsZiksbmV3IG14UG9pbnQoYixkKV0sdGhpcy5pc1JvdW5kZWQsZywhMCk7YS5lbmQoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgiZG91YmxlQXJyb3ciLGlhKTtteFV0aWxzLmV4dGVuZChyYSxteEFjdG9yKTtyYS5wcm90b3R5cGUuc2l6ZT0uMTtyYS5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLApiLGUsYyxkKXtiPWMqTWF0aC5tYXgoMCxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkpO2EubW92ZVRvKGIsMCk7YS5saW5lVG8oYywwKTthLnF1YWRUbyhjLTIqYixkLzIsYyxkKTthLmxpbmVUbyhiLGQpO2EucXVhZFRvKGItMipiLGQvMixiLDApO2EuY2xvc2UoKTthLmVuZCgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJkYXRhU3RvcmFnZSIscmEpO214VXRpbHMuZXh0ZW5kKE4sbXhBY3Rvcik7Ti5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsZSxjLGQpe2EubW92ZVRvKDAsMCk7YS5xdWFkVG8oYywwLGMsZC8yKTthLnF1YWRUbyhjLGQsMCxkKTthLmNsb3NlKCk7YS5lbmQoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgib3IiLE4pO214VXRpbHMuZXh0ZW5kKG1hLG14QWN0b3IpO21hLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCl7YS5tb3ZlVG8oMCwKMCk7YS5xdWFkVG8oYywwLGMsZC8yKTthLnF1YWRUbyhjLGQsMCxkKTthLnF1YWRUbyhjLzIsZC8yLDAsMCk7YS5jbG9zZSgpO2EuZW5kKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInhvciIsbWEpO214VXRpbHMuZXh0ZW5kKFcsbXhBY3Rvcik7Vy5wcm90b3R5cGUuc2l6ZT0yMDtXLnByb3RvdHlwZS5pc1JvdW5kYWJsZT1mdW5jdGlvbigpe3JldHVybiEwfTtXLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCl7Yj1NYXRoLm1pbihjLzIsTWF0aC5taW4oZCxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSkpKTtlPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLG14Q29uc3RhbnRzLkxJTkVfQVJDU0laRSkvMjt0aGlzLmFkZFBvaW50cyhhLFtuZXcgbXhQb2ludChiLDApLG5ldyBteFBvaW50KGMtYiwwKSxuZXcgbXhQb2ludChjLC44KmIpLG5ldyBteFBvaW50KGMsCmQpLG5ldyBteFBvaW50KDAsZCksbmV3IG14UG9pbnQoMCwuOCpiKV0sdGhpcy5pc1JvdW5kZWQsZSwhMCk7YS5lbmQoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgibG9vcExpbWl0IixXKTtteFV0aWxzLmV4dGVuZChULG14QWN0b3IpO1QucHJvdG90eXBlLnNpemU9LjM3NTtULnByb3RvdHlwZS5pc1JvdW5kYWJsZT1mdW5jdGlvbigpe3JldHVybiEwfTtULnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCl7Yj1kKk1hdGgubWF4KDAsTWF0aC5taW4oMSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSkpKTtlPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLG14Q29uc3RhbnRzLkxJTkVfQVJDU0laRSkvMjt0aGlzLmFkZFBvaW50cyhhLFtuZXcgbXhQb2ludCgwLDApLG5ldyBteFBvaW50KGMsMCksbmV3IG14UG9pbnQoYyxkLWIpLG5ldyBteFBvaW50KGMvCjIsZCksbmV3IG14UG9pbnQoMCxkLWIpXSx0aGlzLmlzUm91bmRlZCxlLCEwKTthLmVuZCgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJvZmZQYWdlQ29ubmVjdG9yIixUKTtteFV0aWxzLmV4dGVuZChwYSxteEVsbGlwc2UpO3BhLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlPWZ1bmN0aW9uKGEsYixlLGMsZCl7bXhFbGxpcHNlLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTthLmJlZ2luKCk7YS5tb3ZlVG8oYitjLzIsZStkKTthLmxpbmVUbyhiK2MsZStkKTthLmVuZCgpO2Euc3Ryb2tlKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInRhcGVEYXRhIixwYSk7bXhVdGlscy5leHRlbmQoc2EsbXhFbGxpcHNlKTtzYS5wcm90b3R5cGUucGFpbnRWZXJ0ZXhTaGFwZT1mdW5jdGlvbihhLGIsZSxjLGQpe214RWxsaXBzZS5wcm90b3R5cGUucGFpbnRWZXJ0ZXhTaGFwZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YS5zZXRTaGFkb3coITEpOwphLmJlZ2luKCk7YS5tb3ZlVG8oYixlK2QvMik7YS5saW5lVG8oYitjLGUrZC8yKTthLmVuZCgpO2Euc3Ryb2tlKCk7YS5iZWdpbigpO2EubW92ZVRvKGIrYy8yLGUpO2EubGluZVRvKGIrYy8yLGUrZCk7YS5lbmQoKTthLnN0cm9rZSgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJvckVsbGlwc2UiLHNhKTtteFV0aWxzLmV4dGVuZChoYSxteEVsbGlwc2UpO2hhLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlPWZ1bmN0aW9uKGEsYixlLGMsZCl7bXhFbGxpcHNlLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTthLnNldFNoYWRvdyghMSk7YS5iZWdpbigpO2EubW92ZVRvKGIrLjE0NSpjLGUrLjE0NSpkKTthLmxpbmVUbyhiKy44NTUqYyxlKy44NTUqZCk7YS5lbmQoKTthLnN0cm9rZSgpO2EuYmVnaW4oKTthLm1vdmVUbyhiKy44NTUqYyxlKy4xNDUqZCk7YS5saW5lVG8oYisuMTQ1KmMsZSsuODU1KmQpO2EuZW5kKCk7YS5zdHJva2UoKX07Cm14Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInN1bUVsbGlwc2UiLGhhKTtteFV0aWxzLmV4dGVuZChxYSxteFJob21idXMpO3FhLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlPWZ1bmN0aW9uKGEsYixlLGMsZCl7bXhSaG9tYnVzLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTthLnNldFNoYWRvdyghMSk7YS5iZWdpbigpO2EubW92ZVRvKGIsZStkLzIpO2EubGluZVRvKGIrYyxlK2QvMik7YS5lbmQoKTthLnN0cm9rZSgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJzb3J0U2hhcGUiLHFhKTtteFV0aWxzLmV4dGVuZChuYSxteEVsbGlwc2UpO25hLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlPWZ1bmN0aW9uKGEsYixlLGMsZCl7YS5iZWdpbigpO2EubW92ZVRvKGIsZSk7YS5saW5lVG8oYitjLGUpO2EubGluZVRvKGIrYy8yLGUrZC8yKTthLmNsb3NlKCk7YS5maWxsQW5kU3Ryb2tlKCk7YS5iZWdpbigpO2EubW92ZVRvKGIsCmUrZCk7YS5saW5lVG8oYitjLGUrZCk7YS5saW5lVG8oYitjLzIsZStkLzIpO2EuY2xvc2UoKTthLmZpbGxBbmRTdHJva2UoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgiY29sbGF0ZSIsbmEpO214VXRpbHMuZXh0ZW5kKHphLG14RWxsaXBzZSk7emEucHJvdG90eXBlLnBhaW50VmVydGV4U2hhcGU9ZnVuY3Rpb24oYSxiLGUsYyxkKXt2YXIgZj1lK2QtNTthLmJlZ2luKCk7YS5tb3ZlVG8oYixlKTthLmxpbmVUbyhiLGUrZCk7YS5tb3ZlVG8oYixmKTthLmxpbmVUbyhiKzEwLGYtNSk7YS5tb3ZlVG8oYixmKTthLmxpbmVUbyhiKzEwLGYrNSk7YS5tb3ZlVG8oYixmKTthLmxpbmVUbyhiK2MsZik7YS5tb3ZlVG8oYitjLGUpO2EubGluZVRvKGIrYyxlK2QpO2EubW92ZVRvKGIrYyxmKTthLmxpbmVUbyhiK2MtMTAsZi01KTthLm1vdmVUbyhiK2MsZik7YS5saW5lVG8oYitjLTEwLGYrNSk7YS5lbmQoKTthLnN0cm9rZSgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJkaW1lbnNpb24iLAp6YSk7bXhVdGlscy5leHRlbmQoQmEsbXhFbGxpcHNlKTtCYS5wcm90b3R5cGUucGFpbnRWZXJ0ZXhTaGFwZT1mdW5jdGlvbihhLGIsZSxjLGQpe3RoaXMub3V0bGluZXx8YS5zZXRTdHJva2VDb2xvcihudWxsKTtteFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5wYWludEJhY2tncm91bmQuYXBwbHkodGhpcyxhcmd1bWVudHMpO251bGwhPXRoaXMuc3R5bGUmJihhLnNldFN0cm9rZUNvbG9yKHRoaXMuc3Ryb2tlKSxhLnJlY3QoYixlLGMsZCksYS5maWxsKCksYS5iZWdpbigpLGEubW92ZVRvKGIsZSksIjEiPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInRvcCIsIjEiKT9hLmxpbmVUbyhiK2MsZSk6YS5tb3ZlVG8oYitjLGUpLCIxIj09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJyaWdodCIsIjEiKT9hLmxpbmVUbyhiK2MsZStkKTphLm1vdmVUbyhiK2MsZStkKSwiMSI9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwiYm90dG9tIiwiMSIpP2EubGluZVRvKGIsZSsKZCk6YS5tb3ZlVG8oYixlK2QpLCIxIj09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJsZWZ0IiwiMSIpJiZhLmxpbmVUbyhiLGUpLGEuZW5kKCksYS5zdHJva2UoKSl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInBhcnRpYWxSZWN0YW5nbGUiLEJhKTtteFV0aWxzLmV4dGVuZChvYSxteEVsbGlwc2UpO29hLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlPWZ1bmN0aW9uKGEsYixlLGMsZCl7bXhFbGxpcHNlLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTthLnNldFNoYWRvdyghMSk7YS5iZWdpbigpOyJ2ZXJ0aWNhbCI9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwibGluZSIpPyhhLm1vdmVUbyhiK2MvMixlKSxhLmxpbmVUbyhiK2MvMixlK2QpKTooYS5tb3ZlVG8oYixlK2QvMiksYS5saW5lVG8oYitjLGUrZC8yKSk7YS5lbmQoKTthLnN0cm9rZSgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJsaW5lRWxsaXBzZSIsCm9hKTtteFV0aWxzLmV4dGVuZCh3YSxteEFjdG9yKTt3YS5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsZSxjLGQpe2I9TWF0aC5taW4oYyxkLzIpO2EubW92ZVRvKDAsMCk7YS5saW5lVG8oYy1iLDApO2EucXVhZFRvKGMsMCxjLGQvMik7YS5xdWFkVG8oYyxkLGMtYixkKTthLmxpbmVUbygwLGQpO2EuY2xvc2UoKTthLmVuZCgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJkZWxheSIsd2EpO214VXRpbHMuZXh0ZW5kKHhhLG14QWN0b3IpO3hhLnByb3RvdHlwZS5zaXplPS4yO3hhLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCl7Yj1NYXRoLm1pbihkLGMpO3ZhciBmPU1hdGgubWF4KDAsTWF0aC5taW4oYixiKnBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkpO2I9KGQtZikvMjtlPWIrZjt2YXIgZz0oYy1mKS8yLGY9ZytmO2EubW92ZVRvKDAsYik7YS5saW5lVG8oZyxiKTthLmxpbmVUbyhnLAowKTthLmxpbmVUbyhmLDApO2EubGluZVRvKGYsYik7YS5saW5lVG8oYyxiKTthLmxpbmVUbyhjLGUpO2EubGluZVRvKGYsZSk7YS5saW5lVG8oZixkKTthLmxpbmVUbyhnLGQpO2EubGluZVRvKGcsZSk7YS5saW5lVG8oMCxlKTthLmNsb3NlKCk7YS5lbmQoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgiY3Jvc3MiLHhhKTtteFV0aWxzLmV4dGVuZChrYSxteEFjdG9yKTtrYS5wcm90b3R5cGUuc2l6ZT0uMjU7a2EucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGUsYyxkKXtiPU1hdGgubWluKGMsZC8yKTtlPU1hdGgubWluKGMtYixNYXRoLm1heCgwLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkqYyk7YS5tb3ZlVG8oMCxkLzIpO2EubGluZVRvKGUsMCk7YS5saW5lVG8oYy1iLDApO2EucXVhZFRvKGMsMCxjLGQvMik7YS5xdWFkVG8oYyxkLGMtYixkKTthLmxpbmVUbyhlLGQpO2EuY2xvc2UoKTthLmVuZCgpfTsKbXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgiZGlzcGxheSIsa2EpO214VXRpbHMuZXh0ZW5kKHRhLG14Q29ubmVjdG9yKTt0YS5wcm90b3R5cGUub3JpZ1BhaW50RWRnZVNoYXBlPXRhLnByb3RvdHlwZS5wYWludEVkZ2VTaGFwZTt0YS5wcm90b3R5cGUucGFpbnRFZGdlU2hhcGU9ZnVuY3Rpb24oYSxiLGUpe2Zvcih2YXIgYz1bXSxkPTA7ZDxiLmxlbmd0aDtkKyspYy5wdXNoKG14VXRpbHMuY2xvbmUoYltkXSkpO3ZhciBkPWEuc3RhdGUuZGFzaGVkLGY9YS5zdGF0ZS5maXhEYXNoO3RhLnByb3RvdHlwZS5vcmlnUGFpbnRFZGdlU2hhcGUuYXBwbHkodGhpcyxbYSxjLGVdKTszPD1hLnN0YXRlLnN0cm9rZVdpZHRoJiYoYz1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImZpbGxDb2xvciIsbnVsbCksbnVsbCE9YyYmKGEuc2V0U3Ryb2tlQ29sb3IoYyksYS5zZXRTdHJva2VXaWR0aChhLnN0YXRlLnN0cm9rZVdpZHRoLTIpLGEuc2V0RGFzaGVkKGQsZiksdGEucHJvdG90eXBlLm9yaWdQYWludEVkZ2VTaGFwZS5hcHBseSh0aGlzLApbYSxiLGVdKSkpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJmaWxsZWRFZGdlIix0YSk7InVuZGVmaW5lZCIhPT10eXBlb2YgU3R5bGVGb3JtYXRQYW5lbCYmZnVuY3Rpb24oKXt2YXIgYT1TdHlsZUZvcm1hdFBhbmVsLnByb3RvdHlwZS5nZXRDdXN0b21Db2xvcnM7U3R5bGVGb3JtYXRQYW5lbC5wcm90b3R5cGUuZ2V0Q3VzdG9tQ29sb3JzPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5mb3JtYXQuZ2V0U2VsZWN0aW9uU3RhdGUoKSxlPWEuYXBwbHkodGhpcyxhcmd1bWVudHMpOyJ1bWxGcmFtZSI9PWIuc3R5bGUuc2hhcGUmJmUucHVzaCh7dGl0bGU6bXhSZXNvdXJjZXMuZ2V0KCJsYW5lQ29sb3IiKSxrZXk6InN3aW1sYW5lRmlsbENvbG9yIixkZWZhdWx0VmFsdWU6IiNmZmZmZmYifSk7cmV0dXJuIGV9fSgpO214TWFya2VyLmFkZE1hcmtlcigiZGFzaCIsZnVuY3Rpb24oYSxiLGUsYyxkLGYsZyxsLHAsdSl7dmFyIG49ZCooZytwKzEpLHQ9ZiooZytwKzEpO3JldHVybiBmdW5jdGlvbigpe2EuYmVnaW4oKTsKYS5tb3ZlVG8oYy54LW4vMi10LzIsYy55LXQvMituLzIpO2EubGluZVRvKGMueCt0LzItMypuLzIsYy55LTMqdC8yLW4vMik7YS5zdHJva2UoKX19KTtteE1hcmtlci5hZGRNYXJrZXIoImJveCIsZnVuY3Rpb24oYSxiLGUsYyxkLGYsZyxsLHAsdSl7dmFyIG49ZCooZytwKzEpLHQ9ZiooZytwKzEpLEI9Yy54K24vMixrPWMueSt0LzI7Yy54LT1uO2MueS09dDtyZXR1cm4gZnVuY3Rpb24oKXthLmJlZ2luKCk7YS5tb3ZlVG8oQi1uLzItdC8yLGstdC8yK24vMik7YS5saW5lVG8oQi1uLzIrdC8yLGstdC8yLW4vMik7YS5saW5lVG8oQit0LzItMypuLzIsay0zKnQvMi1uLzIpO2EubGluZVRvKEItdC8yLTMqbi8yLGstMyp0LzIrbi8yKTthLmNsb3NlKCk7dT9hLmZpbGxBbmRTdHJva2UoKTphLnN0cm9rZSgpfX0pO214TWFya2VyLmFkZE1hcmtlcigiY3Jvc3MiLGZ1bmN0aW9uKGEsYixlLGMsZCxmLGcsbCxwLHUpe3ZhciBuPWQqKGcrcCsxKSx0PWYqKGcrcCsxKTtyZXR1cm4gZnVuY3Rpb24oKXthLmJlZ2luKCk7CmEubW92ZVRvKGMueC1uLzItdC8yLGMueS10LzIrbi8yKTthLmxpbmVUbyhjLngrdC8yLTMqbi8yLGMueS0zKnQvMi1uLzIpO2EubW92ZVRvKGMueC1uLzIrdC8yLGMueS10LzItbi8yKTthLmxpbmVUbyhjLngtdC8yLTMqbi8yLGMueS0zKnQvMituLzIpO2Euc3Ryb2tlKCl9fSk7bXhNYXJrZXIuYWRkTWFya2VyKCJjaXJjbGUiLEFhKTtteE1hcmtlci5hZGRNYXJrZXIoImNpcmNsZVBsdXMiLGZ1bmN0aW9uKGEsYixlLGMsZCxmLGcsbCxwLHUpe3ZhciBuPWMuY2xvbmUoKSx0PUFhLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxCPWQqKGcrMipwKSxrPWYqKGcrMipwKTtyZXR1cm4gZnVuY3Rpb24oKXt0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTthLmJlZ2luKCk7YS5tb3ZlVG8obi54LWQqcCxuLnktZipwKTthLmxpbmVUbyhuLngtMipCK2QqcCxuLnktMiprK2YqcCk7YS5tb3ZlVG8obi54LUItaytmKnAsbi55LWsrQi1kKnApO2EubGluZVRvKG4ueCtrLUItZipwLG4ueS1rLUIrZCpwKTthLnN0cm9rZSgpfX0pOwpteE1hcmtlci5hZGRNYXJrZXIoImhhbGZDaXJjbGUiLGZ1bmN0aW9uKGEsYixlLGMsZCxmLGcsbCxwLHUpe3ZhciBuPWQqKGcrcCsxKSx0PWYqKGcrcCsxKSxCPWMuY2xvbmUoKTtjLngtPW47Yy55LT10O3JldHVybiBmdW5jdGlvbigpe2EuYmVnaW4oKTthLm1vdmVUbyhCLngtdCxCLnkrbik7YS5xdWFkVG8oYy54LXQsYy55K24sYy54LGMueSk7YS5xdWFkVG8oYy54K3QsYy55LW4sQi54K3QsQi55LW4pO2Euc3Ryb2tlKCl9fSk7bXhNYXJrZXIuYWRkTWFya2VyKCJhc3luYyIsZnVuY3Rpb24oYSxiLGUsYyxkLGYsZyxsLHAsdSl7Yj1kKnAqMS4xMTg7ZT1mKnAqMS4xMTg7ZCo9ZytwO2YqPWcrcDt2YXIgbj1jLmNsb25lKCk7bi54LT1iO24ueS09ZTtjLngrPTEqLWQtYjtjLnkrPTEqLWYtZTtyZXR1cm4gZnVuY3Rpb24oKXthLmJlZ2luKCk7YS5tb3ZlVG8obi54LG4ueSk7bD9hLmxpbmVUbyhuLngtZC1mLzIsbi55LWYrZC8yKTphLmxpbmVUbyhuLngrZi8yLWQsbi55LWYtZC8yKTsKYS5saW5lVG8obi54LWQsbi55LWYpO2EuY2xvc2UoKTt1P2EuZmlsbEFuZFN0cm9rZSgpOmEuc3Ryb2tlKCl9fSk7bXhNYXJrZXIuYWRkTWFya2VyKCJvcGVuQXN5bmMiLGZ1bmN0aW9uKGEpe2E9bnVsbCE9YT9hOjI7cmV0dXJuIGZ1bmN0aW9uKGIsZSxjLGQsZixnLGwscCx1LG4pe2YqPWwrdTtnKj1sK3U7dmFyIHQ9ZC5jbG9uZSgpO3JldHVybiBmdW5jdGlvbigpe2IuYmVnaW4oKTtiLm1vdmVUbyh0LngsdC55KTtwP2IubGluZVRvKHQueC1mLWcvYSx0LnktZytmL2EpOmIubGluZVRvKHQueCtnL2EtZix0LnktZy1mL2EpO2Iuc3Ryb2tlKCl9fX0oMikpO2lmKCJ1bmRlZmluZWQiIT09dHlwZW9mIG14VmVydGV4SGFuZGxlcil7dmFyIE9hPWZ1bmN0aW9uKGEsYixlKXtyZXR1cm4gRGEoYSxbIndpZHRoIl0sYixmdW5jdGlvbihiLGMsZCxmLGcpe2c9YS5zaGFwZS5nZXRFZGdlV2lkdGgoKSphLnZpZXcuc2NhbGUrZTtyZXR1cm4gbmV3IG14UG9pbnQoZi54K2MqYi80K2QqZy8yLGYueSsKZCpiLzQtYypnLzIpfSxmdW5jdGlvbihiLGMsZCxmLGcsbCl7Yj1NYXRoLnNxcnQobXhVdGlscy5wdFNlZ0Rpc3RTcShmLngsZi55LGcueCxnLnksbC54LGwueSkpO2Euc3R5bGUud2lkdGg9TWF0aC5yb3VuZCgyKmIpL2Eudmlldy5zY2FsZS1lfSl9LERhPWZ1bmN0aW9uKGEsYixlLGMsZCl7cmV0dXJuIFYoYSxiLGZ1bmN0aW9uKGIpe3ZhciBkPWEuYWJzb2x1dGVQb2ludHMsZj1kLmxlbmd0aC0xO2I9YS52aWV3LnRyYW5zbGF0ZTt2YXIgZz1hLnZpZXcuc2NhbGUsbD1lP2RbMF06ZFtmXSxkPWU/ZFsxXTpkW2YtMV0sZj1kLngtbC54LHA9ZC55LWwueSx1PU1hdGguc3FydChmKmYrcCpwKSxsPWMuY2FsbCh0aGlzLHUsZi91LHAvdSxsLGQpO3JldHVybiBuZXcgbXhQb2ludChsLngvZy1iLngsbC55L2ctYi55KX0sZnVuY3Rpb24oYixjLGYpe3ZhciBnPWEuYWJzb2x1dGVQb2ludHMsbD1nLmxlbmd0aC0xO2I9YS52aWV3LnRyYW5zbGF0ZTt2YXIgcD1hLnZpZXcuc2NhbGUsdT1lP2dbMF06CmdbbF0sZz1lP2dbMV06Z1tsLTFdLGw9Zy54LXUueCxuPWcueS11LnksdD1NYXRoLnNxcnQobCpsK24qbik7Yy54PShjLngrYi54KSpwO2MueT0oYy55K2IueSkqcDtkLmNhbGwodGhpcyx0LGwvdCxuL3QsdSxnLGMsZil9KX0seWE9ZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3JldHVybltWKGIsWyJhcnJvd1dpZHRoIiwiYXJyb3dTaXplIl0sZnVuY3Rpb24oYil7dmFyIGU9TWF0aC5tYXgoMCxNYXRoLm1pbigxLG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwiYXJyb3dXaWR0aCIsUy5wcm90b3R5cGUuYXJyb3dXaWR0aCkpKSxjPU1hdGgubWF4KDAsTWF0aC5taW4oYSxteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsImFycm93U2l6ZSIsUy5wcm90b3R5cGUuYXJyb3dTaXplKSkpO3JldHVybiBuZXcgbXhQb2ludChiLngrKDEtYykqYi53aWR0aCxiLnkrKDEtZSkqYi5oZWlnaHQvMil9LGZ1bmN0aW9uKGIsZSl7dGhpcy5zdGF0ZS5zdHlsZS5hcnJvd1dpZHRoPQpNYXRoLm1heCgwLE1hdGgubWluKDEsTWF0aC5hYnMoYi55K2IuaGVpZ2h0LzItZS55KS9iLmhlaWdodCoyKSk7dGhpcy5zdGF0ZS5zdHlsZS5hcnJvd1NpemU9TWF0aC5tYXgoMCxNYXRoLm1pbihhLChiLngrYi53aWR0aC1lLngpL2Iud2lkdGgpKX0pXX19LEthPWZ1bmN0aW9uKGEsYixlKXtyZXR1cm4gZnVuY3Rpb24oYyl7dmFyIGQ9W1YoYyxbInNpemUiXSxmdW5jdGlvbihlKXt2YXIgYz1NYXRoLm1heCgwLE1hdGgubWluKGUud2lkdGgsTWF0aC5taW4oZS5oZWlnaHQscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsInNpemUiLGIpKSkpKSphO3JldHVybiBuZXcgbXhQb2ludChlLngrYyxlLnkrYyl9LGZ1bmN0aW9uKGIsZSl7dGhpcy5zdGF0ZS5zdHlsZS5zaXplPU1hdGgucm91bmQoTWF0aC5tYXgoMCxNYXRoLm1pbihNYXRoLm1pbihiLndpZHRoLGUueC1iLngpLE1hdGgubWluKGIuaGVpZ2h0LGUueS1iLnkpKSkvYSl9LCExKV07ZSYmbXhVdGlscy5nZXRWYWx1ZShjLnN0eWxlLApteENvbnN0YW50cy5TVFlMRV9ST1VOREVELCExKSYmZC5wdXNoKHZhKGMpKTtyZXR1cm4gZH19LEVhPWZ1bmN0aW9uKGEsYixlLGMsZCl7ZT1udWxsIT1lP2U6MTtyZXR1cm4gZnVuY3Rpb24oZil7dmFyIGc9W1YoZixbInNpemUiXSxmdW5jdGlvbihiKXt2YXIgZT1udWxsIT1kPyIwIiE9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJmaXhlZFNpemUiLCIwIik6bnVsbCxjPXBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJzaXplIixlP2Q6YSkpO3JldHVybiBuZXcgbXhQb2ludChiLngrTWF0aC5tYXgoMCxNYXRoLm1pbihiLndpZHRoLGMqKGU/MTpiLndpZHRoKSkpLGIuZ2V0Q2VudGVyWSgpKX0sZnVuY3Rpb24oYSxiLGMpe2E9bnVsbCE9ZCYmIjAiIT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsImZpeGVkU2l6ZSIsIjAiKT9iLngtYS54Ok1hdGgubWF4KDAsTWF0aC5taW4oZSwoYi54LWEueCkvYS53aWR0aCkpO3RoaXMuc3RhdGUuc3R5bGUuc2l6ZT0KYX0sITEsYyldO2ImJm14VXRpbHMuZ2V0VmFsdWUoZi5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ST1VOREVELCExKSYmZy5wdXNoKHZhKGYpKTtyZXR1cm4gZ319LExhPWZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihiKXt2YXIgZT1bVihiLFsic2l6ZSJdLGZ1bmN0aW9uKGIpe3ZhciBlPU1hdGgubWF4KDAsTWF0aC5taW4oYSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwic2l6ZSIsbi5wcm90b3R5cGUuc2l6ZSkpKSk7cmV0dXJuIG5ldyBteFBvaW50KGIueCtlKmIud2lkdGgqLjc1LGIueStiLmhlaWdodC80KX0sZnVuY3Rpb24oYixlKXt0aGlzLnN0YXRlLnN0eWxlLnNpemU9TWF0aC5tYXgoMCxNYXRoLm1pbihhLChlLngtYi54KS8oLjc1KmIud2lkdGgpKSl9LCExLCEwKV07bXhVdGlscy5nZXRWYWx1ZShiLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1JPVU5ERUQsITEpJiZlLnB1c2godmEoYikpO3JldHVybiBlfX0sQ2E9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oYSl7dmFyIGI9CltdO214VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ST1VOREVELCExKSYmYi5wdXNoKHZhKGEpKTtyZXR1cm4gYn19LHZhPWZ1bmN0aW9uKGEsYil7cmV0dXJuIFYoYSxbbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRV0sZnVuY3Rpb24oZSl7dmFyIGM9bnVsbCE9Yj9iOmUuaGVpZ2h0Lzg7aWYoIjEiPT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQUJTT0xVVEVfQVJDU0laRSwwKSl7dmFyIGQ9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkUsbXhDb25zdGFudHMuTElORV9BUkNTSVpFKS8yO3JldHVybiBuZXcgbXhQb2ludChlLngrZS53aWR0aC1NYXRoLm1pbihlLndpZHRoLzIsZCksZS55K2MpfWQ9TWF0aC5tYXgoMCxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLDEwMCpteENvbnN0YW50cy5SRUNUQU5HTEVfUk9VTkRJTkdfRkFDVE9SKSkpLwoxMDA7cmV0dXJuIG5ldyBteFBvaW50KGUueCtlLndpZHRoLU1hdGgubWluKE1hdGgubWF4KGUud2lkdGgvMixlLmhlaWdodC8yKSxNYXRoLm1pbihlLndpZHRoLGUuaGVpZ2h0KSpkKSxlLnkrYyl9LGZ1bmN0aW9uKGIsZSxjKXsiMSI9PW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BQlNPTFVURV9BUkNTSVpFLDApP3RoaXMuc3RhdGUuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRV09TWF0aC5yb3VuZChNYXRoLm1heCgwLE1hdGgubWluKGIud2lkdGgsMiooYi54K2Iud2lkdGgtZS54KSkpKTp0aGlzLnN0YXRlLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkVdPU1hdGgucm91bmQoTWF0aC5taW4oNTAsTWF0aC5tYXgoMCwxMDAqKGIud2lkdGgtZS54K2IueCkvTWF0aC5taW4oYi53aWR0aCxiLmhlaWdodCkpKSl9KX0sVj1mdW5jdGlvbihhLGIsZSxjLGQsZixnKXt2YXIgbD1uZXcgbXhIYW5kbGUoYSxudWxsLG14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuc2Vjb25kYXJ5SGFuZGxlSW1hZ2UpOwpsLmV4ZWN1dGU9ZnVuY3Rpb24oYSl7Zm9yKHZhciBlPTA7ZTxiLmxlbmd0aDtlKyspdGhpcy5jb3B5U3R5bGUoYltlXSk7ZyYmZyhhKX07bC5nZXRQb3NpdGlvbj1lO2wuc2V0UG9zaXRpb249YztsLmlnbm9yZUdyaWQ9bnVsbCE9ZD9kOiEwO2lmKGYpe3ZhciBwPWwucG9zaXRpb25DaGFuZ2VkO2wucG9zaXRpb25DaGFuZ2VkPWZ1bmN0aW9uKCl7cC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YS52aWV3LmludmFsaWRhdGUodGhpcy5zdGF0ZS5jZWxsKTthLnZpZXcudmFsaWRhdGUoKX19cmV0dXJuIGx9LEZhPXtsaW5rOmZ1bmN0aW9uKGEpe3JldHVybltPYShhLCEwLDEwKSxPYShhLCExLDEwKV19LGZsZXhBcnJvdzpmdW5jdGlvbihhKXt2YXIgYj1hLnZpZXcuZ3JhcGguZ3JpZFNpemUvYS52aWV3LnNjYWxlLGU9W107bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1NUQVJUQVJST1csbXhDb25zdGFudHMuTk9ORSkhPW14Q29uc3RhbnRzLk5PTkUmJihlLnB1c2goRGEoYSwKWyJ3aWR0aCIsbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFLG14Q29uc3RhbnRzLlNUWUxFX0VORFNJWkVdLCEwLGZ1bmN0aW9uKGIsZSxjLGQsZil7Yj0oYS5zaGFwZS5nZXRFZGdlV2lkdGgoKS1hLnNoYXBlLnN0cm9rZXdpZHRoKSphLnZpZXcuc2NhbGU7Zj0zKm14VXRpbHMuZ2V0TnVtYmVyKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFLG14Q29uc3RhbnRzLkFSUk9XX1NJWkUvNSkqYS52aWV3LnNjYWxlO3JldHVybiBuZXcgbXhQb2ludChkLngrZSooZithLnNoYXBlLnN0cm9rZXdpZHRoKmEudmlldy5zY2FsZSkrYypiLzIsZC55K2MqKGYrYS5zaGFwZS5zdHJva2V3aWR0aCphLnZpZXcuc2NhbGUpLWUqYi8yKX0sZnVuY3Rpb24oZSxjLGQsZixnLGwscCl7ZT1NYXRoLnNxcnQobXhVdGlscy5wdFNlZ0Rpc3RTcShmLngsZi55LGcueCxnLnksbC54LGwueSkpO2M9bXhVdGlscy5wdExpbmVEaXN0KGYueCxmLnksZi54K2QsZi55LWMsbC54LGwueSk7YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkVdPQpNYXRoLnJvdW5kKDEwMCooYy1hLnNoYXBlLnN0cm9rZXdpZHRoKS8zKS8xMDAvYS52aWV3LnNjYWxlO2Euc3R5bGUud2lkdGg9TWF0aC5yb3VuZCgyKmUpL2Eudmlldy5zY2FsZTtteEV2ZW50LmlzQ29udHJvbERvd24ocC5nZXRFdmVudCgpKSYmKGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRU5EU0laRV09YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkVdKTtteEV2ZW50LmlzQWx0RG93bihwLmdldEV2ZW50KCkpfHxNYXRoLmFicyhwYXJzZUZsb2F0KGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFXSktcGFyc2VGbG9hdChhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VORFNJWkVdKSk8Yi82JiYoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkVdPWEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRU5EU0laRV0pfSkpLGUucHVzaChEYShhLFsic3RhcnRXaWR0aCIsImVuZFdpZHRoIixteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkUsbXhDb25zdGFudHMuU1RZTEVfRU5EU0laRV0sCiEwLGZ1bmN0aW9uKGIsZSxjLGQsZil7Yj0oYS5zaGFwZS5nZXRTdGFydEFycm93V2lkdGgoKS1hLnNoYXBlLnN0cm9rZXdpZHRoKSphLnZpZXcuc2NhbGU7Zj0zKm14VXRpbHMuZ2V0TnVtYmVyKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFLG14Q29uc3RhbnRzLkFSUk9XX1NJWkUvNSkqYS52aWV3LnNjYWxlO3JldHVybiBuZXcgbXhQb2ludChkLngrZSooZithLnNoYXBlLnN0cm9rZXdpZHRoKmEudmlldy5zY2FsZSkrYypiLzIsZC55K2MqKGYrYS5zaGFwZS5zdHJva2V3aWR0aCphLnZpZXcuc2NhbGUpLWUqYi8yKX0sZnVuY3Rpb24oZSxjLGQsZixnLGwscCl7ZT1NYXRoLnNxcnQobXhVdGlscy5wdFNlZ0Rpc3RTcShmLngsZi55LGcueCxnLnksbC54LGwueSkpO2M9bXhVdGlscy5wdExpbmVEaXN0KGYueCxmLnksZi54K2QsZi55LWMsbC54LGwueSk7YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkVdPU1hdGgucm91bmQoMTAwKihjLWEuc2hhcGUuc3Ryb2tld2lkdGgpLwozKS8xMDAvYS52aWV3LnNjYWxlO2Euc3R5bGUuc3RhcnRXaWR0aD1NYXRoLm1heCgwLE1hdGgucm91bmQoMiplKS1hLnNoYXBlLmdldEVkZ2VXaWR0aCgpKS9hLnZpZXcuc2NhbGU7bXhFdmVudC5pc0NvbnRyb2xEb3duKHAuZ2V0RXZlbnQoKSkmJihhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VORFNJWkVdPWEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFXSxhLnN0eWxlLmVuZFdpZHRoPWEuc3R5bGUuc3RhcnRXaWR0aCk7bXhFdmVudC5pc0FsdERvd24ocC5nZXRFdmVudCgpKXx8KE1hdGguYWJzKHBhcnNlRmxvYXQoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkVdKS1wYXJzZUZsb2F0KGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRU5EU0laRV0pKTxiLzYmJihhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRV09YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FTkRTSVpFXSksTWF0aC5hYnMocGFyc2VGbG9hdChhLnN0eWxlLnN0YXJ0V2lkdGgpLQpwYXJzZUZsb2F0KGEuc3R5bGUuZW5kV2lkdGgpKTxiJiYoYS5zdHlsZS5zdGFydFdpZHRoPWEuc3R5bGUuZW5kV2lkdGgpKX0pKSk7bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0VOREFSUk9XLG14Q29uc3RhbnRzLk5PTkUpIT1teENvbnN0YW50cy5OT05FJiYoZS5wdXNoKERhKGEsWyJ3aWR0aCIsbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFLG14Q29uc3RhbnRzLlNUWUxFX0VORFNJWkVdLCExLGZ1bmN0aW9uKGIsZSxjLGQsZil7Yj0oYS5zaGFwZS5nZXRFZGdlV2lkdGgoKS1hLnNoYXBlLnN0cm9rZXdpZHRoKSphLnZpZXcuc2NhbGU7Zj0zKm14VXRpbHMuZ2V0TnVtYmVyKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRU5EU0laRSxteENvbnN0YW50cy5BUlJPV19TSVpFLzUpKmEudmlldy5zY2FsZTtyZXR1cm4gbmV3IG14UG9pbnQoZC54K2UqKGYrYS5zaGFwZS5zdHJva2V3aWR0aCphLnZpZXcuc2NhbGUpLWMqYi8yLGQueStjKihmK2Euc2hhcGUuc3Ryb2tld2lkdGgqCmEudmlldy5zY2FsZSkrZSpiLzIpfSxmdW5jdGlvbihlLGMsZCxmLGcsbCxwKXtlPU1hdGguc3FydChteFV0aWxzLnB0U2VnRGlzdFNxKGYueCxmLnksZy54LGcueSxsLngsbC55KSk7Yz1teFV0aWxzLnB0TGluZURpc3QoZi54LGYueSxmLngrZCxmLnktYyxsLngsbC55KTthLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VORFNJWkVdPU1hdGgucm91bmQoMTAwKihjLWEuc2hhcGUuc3Ryb2tld2lkdGgpLzMpLzEwMC9hLnZpZXcuc2NhbGU7YS5zdHlsZS53aWR0aD1NYXRoLnJvdW5kKDIqZSkvYS52aWV3LnNjYWxlO214RXZlbnQuaXNDb250cm9sRG93bihwLmdldEV2ZW50KCkpJiYoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkVdPWEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRU5EU0laRV0pO214RXZlbnQuaXNBbHREb3duKHAuZ2V0RXZlbnQoKSl8fE1hdGguYWJzKHBhcnNlRmxvYXQoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FTkRTSVpFXSktcGFyc2VGbG9hdChhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRV0pKTwKYi82JiYoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FTkRTSVpFXT1hLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRV0pfSkpLGUucHVzaChEYShhLFsic3RhcnRXaWR0aCIsImVuZFdpZHRoIixteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkUsbXhDb25zdGFudHMuU1RZTEVfRU5EU0laRV0sITEsZnVuY3Rpb24oYixlLGMsZCxmKXtiPShhLnNoYXBlLmdldEVuZEFycm93V2lkdGgoKS1hLnNoYXBlLnN0cm9rZXdpZHRoKSphLnZpZXcuc2NhbGU7Zj0zKm14VXRpbHMuZ2V0TnVtYmVyKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRU5EU0laRSxteENvbnN0YW50cy5BUlJPV19TSVpFLzUpKmEudmlldy5zY2FsZTtyZXR1cm4gbmV3IG14UG9pbnQoZC54K2UqKGYrYS5zaGFwZS5zdHJva2V3aWR0aCphLnZpZXcuc2NhbGUpLWMqYi8yLGQueStjKihmK2Euc2hhcGUuc3Ryb2tld2lkdGgqYS52aWV3LnNjYWxlKStlKmIvMil9LGZ1bmN0aW9uKGUsYyxkLGYsZyxsLHApe2U9Ck1hdGguc3FydChteFV0aWxzLnB0U2VnRGlzdFNxKGYueCxmLnksZy54LGcueSxsLngsbC55KSk7Yz1teFV0aWxzLnB0TGluZURpc3QoZi54LGYueSxmLngrZCxmLnktYyxsLngsbC55KTthLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VORFNJWkVdPU1hdGgucm91bmQoMTAwKihjLWEuc2hhcGUuc3Ryb2tld2lkdGgpLzMpLzEwMC9hLnZpZXcuc2NhbGU7YS5zdHlsZS5lbmRXaWR0aD1NYXRoLm1heCgwLE1hdGgucm91bmQoMiplKS1hLnNoYXBlLmdldEVkZ2VXaWR0aCgpKS9hLnZpZXcuc2NhbGU7bXhFdmVudC5pc0NvbnRyb2xEb3duKHAuZ2V0RXZlbnQoKSkmJihhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRV09YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FTkRTSVpFXSxhLnN0eWxlLnN0YXJ0V2lkdGg9YS5zdHlsZS5lbmRXaWR0aCk7bXhFdmVudC5pc0FsdERvd24ocC5nZXRFdmVudCgpKXx8KE1hdGguYWJzKHBhcnNlRmxvYXQoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FTkRTSVpFXSktCnBhcnNlRmxvYXQoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkVdKSk8Yi82JiYoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FTkRTSVpFXT1hLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRV0pLE1hdGguYWJzKHBhcnNlRmxvYXQoYS5zdHlsZS5lbmRXaWR0aCktcGFyc2VGbG9hdChhLnN0eWxlLnN0YXJ0V2lkdGgpKTxiJiYoYS5zdHlsZS5lbmRXaWR0aD1hLnN0eWxlLnN0YXJ0V2lkdGgpKX0pKSk7cmV0dXJuIGV9LHN3aW1sYW5lOmZ1bmN0aW9uKGEpe3ZhciBiPVtdO2lmKG14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ST1VOREVEKSl7dmFyIGU9cGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFLG14Q29uc3RhbnRzLkRFRkFVTFRfU1RBUlRTSVpFKSk7Yi5wdXNoKHZhKGEsZS8yKSl9Yi5wdXNoKFYoYSxbbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFXSwKZnVuY3Rpb24oYil7dmFyIGU9cGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFLG14Q29uc3RhbnRzLkRFRkFVTFRfU1RBUlRTSVpFKSk7cmV0dXJuIDE9PW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9IT1JJWk9OVEFMLDEpP25ldyBteFBvaW50KGIuZ2V0Q2VudGVyWCgpLGIueStNYXRoLm1heCgwLE1hdGgubWluKGIuaGVpZ2h0LGUpKSk6bmV3IG14UG9pbnQoYi54K01hdGgubWF4KDAsTWF0aC5taW4oYi53aWR0aCxlKSksYi5nZXRDZW50ZXJZKCkpfSxmdW5jdGlvbihiLGUpe2Euc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFXT0xPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfSE9SSVpPTlRBTCwxKT9NYXRoLnJvdW5kKE1hdGgubWF4KDAsTWF0aC5taW4oYi5oZWlnaHQsZS55LWIueSkpKTpNYXRoLnJvdW5kKE1hdGgubWF4KDAsCk1hdGgubWluKGIud2lkdGgsZS54LWIueCkpKX0sITEsbnVsbCxmdW5jdGlvbihiKXtpZihteEV2ZW50LmlzU2hpZnREb3duKGIuZ2V0RXZlbnQoKSkmJihiPWEudmlldy5ncmFwaCxiLmlzVGFibGVSb3coYS5jZWxsKXx8Yi5pc1RhYmxlQ2VsbChhLmNlbGwpKSl7Zm9yKHZhciBlPWIuZ2V0U3dpbWxhbmVEaXJlY3Rpb24oYS5zdHlsZSksYz1iLm1vZGVsLmdldFBhcmVudChhLmNlbGwpLGM9Yi5tb2RlbC5nZXRDaGlsZENlbGxzKGMsITApLGQ9W10sZj0wO2Y8Yy5sZW5ndGg7ZisrKWNbZl0hPWEuY2VsbCYmYi5pc1N3aW1sYW5lKGNbZl0pJiZiLmdldFN3aW1sYW5lRGlyZWN0aW9uKGIuZ2V0Q3VycmVudENlbGxTdHlsZShjW2ZdKSk9PWUmJmQucHVzaChjW2ZdKTtiLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFLGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFXSxkKX19KSk7cmV0dXJuIGJ9LGxhYmVsOkNhKCksZXh0OkNhKCkscmVjdGFuZ2xlOkNhKCksCnRyaWFuZ2xlOkNhKCkscmhvbWJ1czpDYSgpLHVtbExpZmVsaW5lOmZ1bmN0aW9uKGEpe3JldHVybltWKGEsWyJzaXplIl0sZnVuY3Rpb24oYSl7dmFyIGI9TWF0aC5tYXgoMCxNYXRoLm1pbihhLmhlaWdodCxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwic2l6ZSIsTS5wcm90b3R5cGUuc2l6ZSkpKSk7cmV0dXJuIG5ldyBteFBvaW50KGEuZ2V0Q2VudGVyWCgpLGEueStiKX0sZnVuY3Rpb24oYSxiKXt0aGlzLnN0YXRlLnN0eWxlLnNpemU9TWF0aC5yb3VuZChNYXRoLm1heCgwLE1hdGgubWluKGEuaGVpZ2h0LGIueS1hLnkpKSl9LCExKV19LHVtbEZyYW1lOmZ1bmN0aW9uKGEpe3JldHVybltWKGEsWyJ3aWR0aCIsImhlaWdodCJdLGZ1bmN0aW9uKGEpe3ZhciBiPU1hdGgubWF4KFAucHJvdG90eXBlLmNvcm5lcixNYXRoLm1pbihhLndpZHRoLG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwid2lkdGgiLFAucHJvdG90eXBlLndpZHRoKSkpLAplPU1hdGgubWF4KDEuNSpQLnByb3RvdHlwZS5jb3JuZXIsTWF0aC5taW4oYS5oZWlnaHQsbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJoZWlnaHQiLFAucHJvdG90eXBlLmhlaWdodCkpKTtyZXR1cm4gbmV3IG14UG9pbnQoYS54K2IsYS55K2UpfSxmdW5jdGlvbihhLGIpe3RoaXMuc3RhdGUuc3R5bGUud2lkdGg9TWF0aC5yb3VuZChNYXRoLm1heChQLnByb3RvdHlwZS5jb3JuZXIsTWF0aC5taW4oYS53aWR0aCxiLngtYS54KSkpO3RoaXMuc3RhdGUuc3R5bGUuaGVpZ2h0PU1hdGgucm91bmQoTWF0aC5tYXgoMS41KlAucHJvdG90eXBlLmNvcm5lcixNYXRoLm1pbihhLmhlaWdodCxiLnktYS55KSkpfSwhMSldfSxwcm9jZXNzOmZ1bmN0aW9uKGEpe3ZhciBiPVtWKGEsWyJzaXplIl0sZnVuY3Rpb24oYSl7dmFyIGI9TWF0aC5tYXgoMCxNYXRoLm1pbiguNSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwic2l6ZSIseC5wcm90b3R5cGUuc2l6ZSkpKSk7CnJldHVybiBuZXcgbXhQb2ludChhLngrYS53aWR0aCpiLGEueSthLmhlaWdodC80KX0sZnVuY3Rpb24oYSxiKXt0aGlzLnN0YXRlLnN0eWxlLnNpemU9TWF0aC5tYXgoMCxNYXRoLm1pbiguNSwoYi54LWEueCkvYS53aWR0aCkpfSwhMSldO214VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ST1VOREVELCExKSYmYi5wdXNoKHZhKGEpKTtyZXR1cm4gYn0sY3Jvc3M6ZnVuY3Rpb24oYSl7cmV0dXJuW1YoYSxbInNpemUiXSxmdW5jdGlvbihhKXt2YXIgYj1NYXRoLm1pbihhLndpZHRoLGEuaGVpZ2h0KSxiPU1hdGgubWF4KDAsTWF0aC5taW4oMSxteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsInNpemUiLHhhLnByb3RvdHlwZS5zaXplKSkpKmIvMjtyZXR1cm4gbmV3IG14UG9pbnQoYS5nZXRDZW50ZXJYKCktYixhLmdldENlbnRlclkoKS1iKX0sZnVuY3Rpb24oYSxiKXt2YXIgZT1NYXRoLm1pbihhLndpZHRoLGEuaGVpZ2h0KTt0aGlzLnN0YXRlLnN0eWxlLnNpemU9Ck1hdGgubWF4KDAsTWF0aC5taW4oMSxNYXRoLm1pbihNYXRoLm1heCgwLGEuZ2V0Q2VudGVyWSgpLWIueSkvZSoyLE1hdGgubWF4KDAsYS5nZXRDZW50ZXJYKCktYi54KS9lKjIpKSl9KV19LG5vdGU6ZnVuY3Rpb24oYSl7cmV0dXJuW1YoYSxbInNpemUiXSxmdW5jdGlvbihhKXt2YXIgYj1NYXRoLm1heCgwLE1hdGgubWluKGEud2lkdGgsTWF0aC5taW4oYS5oZWlnaHQscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsInNpemUiLGsucHJvdG90eXBlLnNpemUpKSkpKTtyZXR1cm4gbmV3IG14UG9pbnQoYS54K2Eud2lkdGgtYixhLnkrYil9LGZ1bmN0aW9uKGEsYil7dGhpcy5zdGF0ZS5zdHlsZS5zaXplPU1hdGgucm91bmQoTWF0aC5tYXgoMCxNYXRoLm1pbihNYXRoLm1pbihhLndpZHRoLGEueCthLndpZHRoLWIueCksTWF0aC5taW4oYS5oZWlnaHQsYi55LWEueSkpKSl9KV19LG1hbnVhbElucHV0OmZ1bmN0aW9uKGEpe3ZhciBiPVtWKGEsWyJzaXplIl0sCmZ1bmN0aW9uKGEpe3ZhciBiPU1hdGgubWF4KDAsTWF0aC5taW4oYS5oZWlnaHQsbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJzaXplIixjYS5wcm90b3R5cGUuc2l6ZSkpKTtyZXR1cm4gbmV3IG14UG9pbnQoYS54K2Eud2lkdGgvNCxhLnkrMypiLzQpfSxmdW5jdGlvbihhLGIpe3RoaXMuc3RhdGUuc3R5bGUuc2l6ZT1NYXRoLnJvdW5kKE1hdGgubWF4KDAsTWF0aC5taW4oYS5oZWlnaHQsNCooYi55LWEueSkvMykpKX0sITEpXTtteFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfUk9VTkRFRCwhMSkmJmIucHVzaCh2YShhKSk7cmV0dXJuIGJ9LGRhdGFTdG9yYWdlOmZ1bmN0aW9uKGEpe3JldHVybltWKGEsWyJzaXplIl0sZnVuY3Rpb24oYSl7dmFyIGI9TWF0aC5tYXgoMCxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJzaXplIixyYS5wcm90b3R5cGUuc2l6ZSkpKSk7cmV0dXJuIG5ldyBteFBvaW50KGEueCsKKDEtYikqYS53aWR0aCxhLmdldENlbnRlclkoKSl9LGZ1bmN0aW9uKGEsYil7dGhpcy5zdGF0ZS5zdHlsZS5zaXplPU1hdGgubWF4KDAsTWF0aC5taW4oMSwoYS54K2Eud2lkdGgtYi54KS9hLndpZHRoKSl9LCExKV19LGNhbGxvdXQ6ZnVuY3Rpb24oYSl7dmFyIGI9W1YoYSxbInNpemUiLCJwb3NpdGlvbiJdLGZ1bmN0aW9uKGEpe3ZhciBiPU1hdGgubWF4KDAsTWF0aC5taW4oYS5oZWlnaHQsbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJzaXplIixBLnByb3RvdHlwZS5zaXplKSkpLGU9TWF0aC5tYXgoMCxNYXRoLm1pbigxLG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwicG9zaXRpb24iLEEucHJvdG90eXBlLnBvc2l0aW9uKSkpO214VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwiYmFzZSIsQS5wcm90b3R5cGUuYmFzZSk7cmV0dXJuIG5ldyBteFBvaW50KGEueCtlKmEud2lkdGgsYS55K2EuaGVpZ2h0LWIpfSxmdW5jdGlvbihhLGIpe214VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwKImJhc2UiLEEucHJvdG90eXBlLmJhc2UpO3RoaXMuc3RhdGUuc3R5bGUuc2l6ZT1NYXRoLnJvdW5kKE1hdGgubWF4KDAsTWF0aC5taW4oYS5oZWlnaHQsYS55K2EuaGVpZ2h0LWIueSkpKTt0aGlzLnN0YXRlLnN0eWxlLnBvc2l0aW9uPU1hdGgucm91bmQoMTAwKk1hdGgubWF4KDAsTWF0aC5taW4oMSwoYi54LWEueCkvYS53aWR0aCkpKS8xMDB9LCExKSxWKGEsWyJwb3NpdGlvbjIiXSxmdW5jdGlvbihhKXt2YXIgYj1NYXRoLm1heCgwLE1hdGgubWluKDEsbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJwb3NpdGlvbjIiLEEucHJvdG90eXBlLnBvc2l0aW9uMikpKTtyZXR1cm4gbmV3IG14UG9pbnQoYS54K2IqYS53aWR0aCxhLnkrYS5oZWlnaHQpfSxmdW5jdGlvbihhLGIpe3RoaXMuc3RhdGUuc3R5bGUucG9zaXRpb24yPU1hdGgucm91bmQoMTAwKk1hdGgubWF4KDAsTWF0aC5taW4oMSwoYi54LWEueCkvYS53aWR0aCkpKS8xMDB9LCExKSxWKGEsWyJiYXNlIl0sZnVuY3Rpb24oYSl7dmFyIGI9Ck1hdGgubWF4KDAsTWF0aC5taW4oYS5oZWlnaHQsbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJzaXplIixBLnByb3RvdHlwZS5zaXplKSkpLGU9TWF0aC5tYXgoMCxNYXRoLm1pbigxLG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwicG9zaXRpb24iLEEucHJvdG90eXBlLnBvc2l0aW9uKSkpLGM9TWF0aC5tYXgoMCxNYXRoLm1pbihhLndpZHRoLG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwiYmFzZSIsQS5wcm90b3R5cGUuYmFzZSkpKTtyZXR1cm4gbmV3IG14UG9pbnQoYS54K01hdGgubWluKGEud2lkdGgsZSphLndpZHRoK2MpLGEueSthLmhlaWdodC1iKX0sZnVuY3Rpb24oYSxiKXt2YXIgZT1NYXRoLm1heCgwLE1hdGgubWluKDEsbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJwb3NpdGlvbiIsQS5wcm90b3R5cGUucG9zaXRpb24pKSk7dGhpcy5zdGF0ZS5zdHlsZS5iYXNlPU1hdGgucm91bmQoTWF0aC5tYXgoMCxNYXRoLm1pbihhLndpZHRoLApiLngtYS54LWUqYS53aWR0aCkpKX0sITEpXTtteFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfUk9VTkRFRCwhMSkmJmIucHVzaCh2YShhKSk7cmV0dXJuIGJ9LGludGVybmFsU3RvcmFnZTpmdW5jdGlvbihhKXt2YXIgYj1bVihhLFsiZHgiLCJkeSJdLGZ1bmN0aW9uKGEpe3ZhciBiPU1hdGgubWF4KDAsTWF0aC5taW4oYS53aWR0aCxteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsImR4IixRLnByb3RvdHlwZS5keCkpKSxlPU1hdGgubWF4KDAsTWF0aC5taW4oYS5oZWlnaHQsbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJkeSIsUS5wcm90b3R5cGUuZHkpKSk7cmV0dXJuIG5ldyBteFBvaW50KGEueCtiLGEueStlKX0sZnVuY3Rpb24oYSxiKXt0aGlzLnN0YXRlLnN0eWxlLmR4PU1hdGgucm91bmQoTWF0aC5tYXgoMCxNYXRoLm1pbihhLndpZHRoLGIueC1hLngpKSk7dGhpcy5zdGF0ZS5zdHlsZS5keT1NYXRoLnJvdW5kKE1hdGgubWF4KDAsCk1hdGgubWluKGEuaGVpZ2h0LGIueS1hLnkpKSl9LCExKV07bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1JPVU5ERUQsITEpJiZiLnB1c2godmEoYSkpO3JldHVybiBifSxtb2R1bGU6ZnVuY3Rpb24oYSl7cmV0dXJuW1YoYSxbImpldHR5V2lkdGgiLCJqZXR0eUhlaWdodCJdLGZ1bmN0aW9uKGEpe3ZhciBiPU1hdGgubWF4KDAsTWF0aC5taW4oYS53aWR0aCxteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsImpldHR5V2lkdGgiLFkucHJvdG90eXBlLmpldHR5V2lkdGgpKSksZT1NYXRoLm1heCgwLE1hdGgubWluKGEuaGVpZ2h0LG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwiamV0dHlIZWlnaHQiLFkucHJvdG90eXBlLmpldHR5SGVpZ2h0KSkpO3JldHVybiBuZXcgbXhQb2ludChhLngrYi8yLGEueSsyKmUpfSxmdW5jdGlvbihhLGIpe3RoaXMuc3RhdGUuc3R5bGUuamV0dHlXaWR0aD1NYXRoLnJvdW5kKDIqTWF0aC5tYXgoMCwKTWF0aC5taW4oYS53aWR0aCxiLngtYS54KSkpO3RoaXMuc3RhdGUuc3R5bGUuamV0dHlIZWlnaHQ9TWF0aC5yb3VuZChNYXRoLm1heCgwLE1hdGgubWluKGEuaGVpZ2h0LGIueS1hLnkpKS8yKX0pXX0sY29ybmVyOmZ1bmN0aW9uKGEpe3JldHVybltWKGEsWyJkeCIsImR5Il0sZnVuY3Rpb24oYSl7dmFyIGI9TWF0aC5tYXgoMCxNYXRoLm1pbihhLndpZHRoLG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwiZHgiLEwucHJvdG90eXBlLmR4KSkpLGU9TWF0aC5tYXgoMCxNYXRoLm1pbihhLmhlaWdodCxteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsImR5IixMLnByb3RvdHlwZS5keSkpKTtyZXR1cm4gbmV3IG14UG9pbnQoYS54K2IsYS55K2UpfSxmdW5jdGlvbihhLGIpe3RoaXMuc3RhdGUuc3R5bGUuZHg9TWF0aC5yb3VuZChNYXRoLm1heCgwLE1hdGgubWluKGEud2lkdGgsYi54LWEueCkpKTt0aGlzLnN0YXRlLnN0eWxlLmR5PU1hdGgucm91bmQoTWF0aC5tYXgoMCwKTWF0aC5taW4oYS5oZWlnaHQsYi55LWEueSkpKX0sITEpXX0sdGVlOmZ1bmN0aW9uKGEpe3JldHVybltWKGEsWyJkeCIsImR5Il0sZnVuY3Rpb24oYSl7dmFyIGI9TWF0aC5tYXgoMCxNYXRoLm1pbihhLndpZHRoLG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwiZHgiLE8ucHJvdG90eXBlLmR4KSkpLGU9TWF0aC5tYXgoMCxNYXRoLm1pbihhLmhlaWdodCxteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsImR5IixPLnByb3RvdHlwZS5keSkpKTtyZXR1cm4gbmV3IG14UG9pbnQoYS54KyhhLndpZHRoK2IpLzIsYS55K2UpfSxmdW5jdGlvbihhLGIpe3RoaXMuc3RhdGUuc3R5bGUuZHg9TWF0aC5yb3VuZChNYXRoLm1heCgwLDIqTWF0aC5taW4oYS53aWR0aC8yLGIueC1hLngtYS53aWR0aC8yKSkpO3RoaXMuc3RhdGUuc3R5bGUuZHk9TWF0aC5yb3VuZChNYXRoLm1heCgwLE1hdGgubWluKGEuaGVpZ2h0LGIueS1hLnkpKSl9LCExKV19LHNpbmdsZUFycm93OnlhKDEpLApkb3VibGVBcnJvdzp5YSguNSksZm9sZGVyOmZ1bmN0aW9uKGEpe3JldHVybltWKGEsWyJ0YWJXaWR0aCIsInRhYkhlaWdodCJdLGZ1bmN0aW9uKGEpe3ZhciBlPU1hdGgubWF4KDAsTWF0aC5taW4oYS53aWR0aCxteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsInRhYldpZHRoIixiLnByb3RvdHlwZS50YWJXaWR0aCkpKSxjPU1hdGgubWF4KDAsTWF0aC5taW4oYS5oZWlnaHQsbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJ0YWJIZWlnaHQiLGIucHJvdG90eXBlLnRhYkhlaWdodCkpKTtteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsInRhYlBvc2l0aW9uIixiLnByb3RvdHlwZS50YWJQb3NpdGlvbik9PW14Q29uc3RhbnRzLkFMSUdOX1JJR0hUJiYoZT1hLndpZHRoLWUpO3JldHVybiBuZXcgbXhQb2ludChhLngrZSxhLnkrYyl9LGZ1bmN0aW9uKGEsZSl7dmFyIGM9TWF0aC5tYXgoMCxNYXRoLm1pbihhLndpZHRoLGUueC1hLngpKTtteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsCiJ0YWJQb3NpdGlvbiIsYi5wcm90b3R5cGUudGFiUG9zaXRpb24pPT1teENvbnN0YW50cy5BTElHTl9SSUdIVCYmKGM9YS53aWR0aC1jKTt0aGlzLnN0YXRlLnN0eWxlLnRhYldpZHRoPU1hdGgucm91bmQoYyk7dGhpcy5zdGF0ZS5zdHlsZS50YWJIZWlnaHQ9TWF0aC5yb3VuZChNYXRoLm1heCgwLE1hdGgubWluKGEuaGVpZ2h0LGUueS1hLnkpKSl9LCExKV19LGRvY3VtZW50OmZ1bmN0aW9uKGEpe3JldHVybltWKGEsWyJzaXplIl0sZnVuY3Rpb24oYSl7dmFyIGI9TWF0aC5tYXgoMCxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJzaXplIixwLnByb3RvdHlwZS5zaXplKSkpKTtyZXR1cm4gbmV3IG14UG9pbnQoYS54KzMqYS53aWR0aC80LGEueSsoMS1iKSphLmhlaWdodCl9LGZ1bmN0aW9uKGEsYil7dGhpcy5zdGF0ZS5zdHlsZS5zaXplPU1hdGgubWF4KDAsTWF0aC5taW4oMSwoYS55K2EuaGVpZ2h0LWIueSkvYS5oZWlnaHQpKX0sCiExKV19LHRhcGU6ZnVuY3Rpb24oYSl7cmV0dXJuW1YoYSxbInNpemUiXSxmdW5jdGlvbihhKXt2YXIgYj1NYXRoLm1heCgwLE1hdGgubWluKDEscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsInNpemUiLGcucHJvdG90eXBlLnNpemUpKSkpO3JldHVybiBuZXcgbXhQb2ludChhLmdldENlbnRlclgoKSxhLnkrYiphLmhlaWdodC8yKX0sZnVuY3Rpb24oYSxiKXt0aGlzLnN0YXRlLnN0eWxlLnNpemU9TWF0aC5tYXgoMCxNYXRoLm1pbigxLChiLnktYS55KS9hLmhlaWdodCoyKSl9LCExKV19LG9mZlBhZ2VDb25uZWN0b3I6ZnVuY3Rpb24oYSl7cmV0dXJuW1YoYSxbInNpemUiXSxmdW5jdGlvbihhKXt2YXIgYj1NYXRoLm1heCgwLE1hdGgubWluKDEscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsInNpemUiLFQucHJvdG90eXBlLnNpemUpKSkpO3JldHVybiBuZXcgbXhQb2ludChhLmdldENlbnRlclgoKSxhLnkrKDEtYikqCmEuaGVpZ2h0KX0sZnVuY3Rpb24oYSxiKXt0aGlzLnN0YXRlLnN0eWxlLnNpemU9TWF0aC5tYXgoMCxNYXRoLm1pbigxLChhLnkrYS5oZWlnaHQtYi55KS9hLmhlaWdodCkpfSwhMSldfSxzdGVwOkVhKEMucHJvdG90eXBlLnNpemUsITAsbnVsbCwhMCxDLnByb3RvdHlwZS5maXhlZFNpemUpLGhleGFnb246RWEoei5wcm90b3R5cGUuc2l6ZSwhMCwuNSwhMCksY3VybHlCcmFja2V0OkVhKHYucHJvdG90eXBlLnNpemUsITEpLGRpc3BsYXk6RWEoa2EucHJvdG90eXBlLnNpemUsITEpLGN1YmU6S2EoMSxjLnByb3RvdHlwZS5zaXplLCExKSxjYXJkOkthKC41LGUucHJvdG90eXBlLnNpemUsITApLGxvb3BMaW1pdDpLYSguNSxXLnByb3RvdHlwZS5zaXplLCEwKSx0cmFwZXpvaWQ6TGEoLjUpLHBhcmFsbGVsb2dyYW06TGEoMSl9O0dyYXBoLmNyZWF0ZUhhbmRsZT1WO0dyYXBoLmhhbmRsZUZhY3Rvcnk9RmE7dmFyIFNhPW14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuY3JlYXRlQ3VzdG9tSGFuZGxlczsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVDdXN0b21IYW5kbGVzPWZ1bmN0aW9uKCl7dmFyIGE9U2EuYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKHRoaXMuZ3JhcGguaXNDZWxsUm90YXRhYmxlKHRoaXMuc3RhdGUuY2VsbCkpe3ZhciBiPXRoaXMuc3RhdGUuc3R5bGUuc2hhcGU7bnVsbD09bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlc1tiXSYmbnVsbD09bXhTdGVuY2lsUmVnaXN0cnkuZ2V0U3RlbmNpbChiKT9iPW14Q29uc3RhbnRzLlNIQVBFX1JFQ1RBTkdMRTp0aGlzLnN0YXRlLnZpZXcuZ3JhcGguaXNTd2ltbGFuZSh0aGlzLnN0YXRlLmNlbGwpJiYoYj1teENvbnN0YW50cy5TSEFQRV9TV0lNTEFORSk7Yj1GYVtiXTtudWxsPT1iJiZudWxsIT10aGlzLnN0YXRlLnNoYXBlJiZ0aGlzLnN0YXRlLnNoYXBlLmlzUm91bmRhYmxlKCkmJihiPUZhW214Q29uc3RhbnRzLlNIQVBFX1JFQ1RBTkdMRV0pO251bGwhPWImJihiPWIodGhpcy5zdGF0ZSksbnVsbCE9YiYmKGE9Cm51bGw9PWE/YjphLmNvbmNhdChiKSkpfXJldHVybiBhfTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVDdXN0b21IYW5kbGVzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5zdGF0ZS5zdHlsZS5zaGFwZTtudWxsPT1teENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzW2FdJiZudWxsPT1teFN0ZW5jaWxSZWdpc3RyeS5nZXRTdGVuY2lsKGEpJiYoYT1teENvbnN0YW50cy5TSEFQRV9DT05ORUNUT1IpO2E9RmFbYV07cmV0dXJuIG51bGwhPWE/YSh0aGlzLnN0YXRlKTpudWxsfX1lbHNlIEdyYXBoLmNyZWF0ZUhhbmRsZT1mdW5jdGlvbigpe30sR3JhcGguaGFuZGxlRmFjdG9yeT17fTt2YXIgR2E9bmV3IG14UG9pbnQoMSwwKSxIYT1uZXcgbXhQb2ludCgxLDApLHlhPW14VXRpbHMudG9SYWRpYW5zKC0zMCksR2E9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQoR2EsTWF0aC5jb3MoeWEpLE1hdGguc2luKHlhKSkseWE9bXhVdGlscy50b1JhZGlhbnMoLTE1MCksSGE9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQoSGEsCk1hdGguY29zKHlhKSxNYXRoLnNpbih5YSkpO214RWRnZVN0eWxlLklzb21ldHJpY0Nvbm5lY3Rvcj1mdW5jdGlvbihhLGIsZSxjLGQpe3ZhciBmPWEudmlldztjPW51bGwhPWMmJjA8Yy5sZW5ndGg/Y1swXTpudWxsO3ZhciBnPWEuYWJzb2x1dGVQb2ludHMsbD1nWzBdLGc9Z1tnLmxlbmd0aC0xXTtudWxsIT1jJiYoYz1mLnRyYW5zZm9ybUNvbnRyb2xQb2ludChhLGMpKTtudWxsPT1sJiZudWxsIT1iJiYobD1uZXcgbXhQb2ludChiLmdldENlbnRlclgoKSxiLmdldENlbnRlclkoKSkpO251bGw9PWcmJm51bGwhPWUmJihnPW5ldyBteFBvaW50KGUuZ2V0Q2VudGVyWCgpLGUuZ2V0Q2VudGVyWSgpKSk7dmFyIHA9R2EueCx1PUdhLnksbj1IYS54LHQ9SGEueSxCPSJob3Jpem9udGFsIj09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLCJlbGJvdyIsImhvcml6b250YWwiKTtpZihudWxsIT1nJiZudWxsIT1sKXthPWZ1bmN0aW9uKGEsYixlKXthLT1rLng7dmFyIGM9Yi1rLnk7Yj0odCphLQpuKmMpLyhwKnQtdSpuKTthPSh1KmEtcCpjKS8odSpuLXAqdCk7Qj8oZSYmKGs9bmV3IG14UG9pbnQoay54K3AqYixrLnkrdSpiKSxkLnB1c2goaykpLGs9bmV3IG14UG9pbnQoay54K24qYSxrLnkrdCphKSk6KGUmJihrPW5ldyBteFBvaW50KGsueCtuKmEsay55K3QqYSksZC5wdXNoKGspKSxrPW5ldyBteFBvaW50KGsueCtwKmIsay55K3UqYikpO2QucHVzaChrKX07dmFyIGs9bDtudWxsPT1jJiYoYz1uZXcgbXhQb2ludChsLngrKGcueC1sLngpLzIsbC55KyhnLnktbC55KS8yKSk7YShjLngsYy55LCEwKTthKGcueCxnLnksITEpfX07bXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKCJpc29tZXRyaWNFZGdlU3R5bGUiLG14RWRnZVN0eWxlLklzb21ldHJpY0Nvbm5lY3Rvcik7dmFyIFRhPUdyYXBoLnByb3RvdHlwZS5jcmVhdGVFZGdlSGFuZGxlcjtHcmFwaC5wcm90b3R5cGUuY3JlYXRlRWRnZUhhbmRsZXI9ZnVuY3Rpb24oYSxiKXtpZihiPT1teEVkZ2VTdHlsZS5Jc29tZXRyaWNDb25uZWN0b3Ipe3ZhciBlPQpuZXcgbXhFbGJvd0VkZ2VIYW5kbGVyKGEpO2Uuc25hcFRvVGVybWluYWxzPSExO3JldHVybiBlfXJldHVybiBUYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2YucHJvdG90eXBlLmNvbnN0cmFpbnRzPVtdO2QucHJvdG90eXBlLmdldENvbnN0cmFpbnRzPWZ1bmN0aW9uKGEsYixlKXthPVtdO3ZhciBjPU1hdGgudGFuKG14VXRpbHMudG9SYWRpYW5zKDMwKSksZD0oLjUtYykvMixjPU1hdGgubWluKGIsZS8oLjUrYykpO2I9KGItYykvMjtlPShlLWMpLzI7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxiLGUrLjI1KmMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGIrLjUqYyxlK2MqZCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYitjLGUrLjI1KmMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwKMCksITEsbnVsbCxiK2MsZSsuNzUqYykpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYisuNSpjLGUrKDEtZCkqYykpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYixlKy43NSpjKSk7cmV0dXJuIGF9O0EucHJvdG90eXBlLmdldENvbnN0cmFpbnRzPWZ1bmN0aW9uKGEsYixlKXthPVtdO214VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLG14Q29uc3RhbnRzLkxJTkVfQVJDU0laRSk7dmFyIGM9TWF0aC5tYXgoMCxNYXRoLm1pbihlLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkpO3BhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJwb3NpdGlvbiIsdGhpcy5wb3NpdGlvbikpO3ZhciBkPWIqTWF0aC5tYXgoMCxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLAoicG9zaXRpb24yIix0aGlzLnBvc2l0aW9uMikpKSk7cGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImJhc2UiLHRoaXMuYmFzZSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4yNSwwKSwhMSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNSwwKSwhMSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNzUsMCksITEpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwwKSwhMSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYiwuNSooZS1jKSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsCmIsZS1jKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxkLGUpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLDAsZS1jKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwwLC41KihlLWMpKSk7Yj49MipjJiZhLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMCksITEpKTtyZXR1cm4gYX07bXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUuY29uc3RyYWludHM9W25ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4yNSwwKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMCksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC43NSwKMCksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsMCksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjI1KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuNSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjc1KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuMjUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC41KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNzUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDEpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMjUsMSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDEpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNzUsCjEpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLDEpLCEwKV07bXhFbGxpcHNlLnByb3RvdHlwZS5jb25zdHJhaW50cz1bbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwwKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwxKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwxKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMCksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDEpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC41KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNSkpXTtteExhYmVsLnByb3RvdHlwZS5jb25zdHJhaW50cz0KbXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUuY29uc3RyYWludHM7bXhJbWFnZVNoYXBlLnByb3RvdHlwZS5jb25zdHJhaW50cz1teFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5jb25zdHJhaW50cztteFN3aW1sYW5lLnByb3RvdHlwZS5jb25zdHJhaW50cz1teFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5jb25zdHJhaW50cztELnByb3RvdHlwZS5jb25zdHJhaW50cz1teFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5jb25zdHJhaW50cztrLnByb3RvdHlwZS5nZXRDb25zdHJhaW50cz1mdW5jdGlvbihhLGIsZSl7YT1bXTt2YXIgYz1NYXRoLm1heCgwLE1hdGgubWluKGIsTWF0aC5taW4oZSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSkpKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwKITEsbnVsbCwuNSooYi1jKSwwKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxiLWMsMCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYi0uNSpjLC41KmMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGIsYykpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYiwuNSooZStjKSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLDEpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDEpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMSksITEpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwKLjUpLCExKSk7Yj49MipjJiZhLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMCksITEpKTtyZXR1cm4gYX07ZS5wcm90b3R5cGUuZ2V0Q29uc3RyYWludHM9ZnVuY3Rpb24oYSxiLGUpe2E9W107dmFyIGM9TWF0aC5tYXgoMCxNYXRoLm1pbihiLE1hdGgubWluKGUscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInNpemUiLHRoaXMuc2l6ZSkpKSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLDApLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwuNSooYitjKSwwKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxjLDApKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLC41KmMsLjUqYykpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLAowKSwhMSxudWxsLDAsYykpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsMCwuNSooZStjKSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDEpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDEpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsMSksITEpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNSksITEpKTtiPj0yKmMmJmEucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNSwwKSwhMSkpO3JldHVybiBhfTtjLnByb3RvdHlwZS5nZXRDb25zdHJhaW50cz1mdW5jdGlvbihhLGIsZSl7YT1bXTt2YXIgYz1NYXRoLm1heCgwLE1hdGgubWluKGIsTWF0aC5taW4oZSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwKInNpemUiLHRoaXMuc2l6ZSkpKSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwuNSooYi1jKSwwKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxiLWMsMCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYi0uNSpjLC41KmMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGIsYykpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYiwuNSooZStjKSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLDEpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsCjApLCExLG51bGwsLjUqKGIrYyksZSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYyxlKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwuNSpjLGUtLjUqYykpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsMCxlLWMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLDAsLjUqKGUtYykpKTtyZXR1cm4gYX07Yi5wcm90b3R5cGUuZ2V0Q29uc3RyYWludHM9ZnVuY3Rpb24oYSxiLGUpe2E9W107dmFyIGM9TWF0aC5tYXgoMCxNYXRoLm1pbihiLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJ0YWJXaWR0aCIsdGhpcy50YWJXaWR0aCkpKSksZD1NYXRoLm1heCgwLE1hdGgubWluKGUscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsCiJ0YWJIZWlnaHQiLHRoaXMudGFiSGVpZ2h0KSkpKTsibGVmdCI9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwidGFiUG9zaXRpb24iLHRoaXMudGFiUG9zaXRpb24pPyhhLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSkpLGEucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsLjUqYywwKSksYS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxjLDApKSxhLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGMsZCkpLGEucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsLjUqKGIrYyksZCkpKTooYS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsMCksITEpKSxhLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwKMCksITEsbnVsbCxiLS41KmMsMCkpLGEucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYi1jLDApKSxhLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGItYyxkKSksYS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwuNSooYi1jKSxkKSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYixkKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxiLC4yNSooZS1kKStkKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxiLC41KihlLWQpK2QpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLApiLC43NSooZS1kKStkKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxiLGUpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLDAsZCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsMCwuMjUqKGUtZCkrZCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsMCwuNSooZS1kKStkKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwwLC43NSooZS1kKStkKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwwLGUpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjI1LDEpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LAoxKSwhMSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNzUsMSksITEpKTtyZXR1cm4gYX07US5wcm90b3R5cGUuY29uc3RyYWludHM9bXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUuY29uc3RyYWludHM7cmEucHJvdG90eXBlLmNvbnN0cmFpbnRzPW14UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLmNvbnN0cmFpbnRzO3BhLnByb3RvdHlwZS5jb25zdHJhaW50cz1teEVsbGlwc2UucHJvdG90eXBlLmNvbnN0cmFpbnRzO3NhLnByb3RvdHlwZS5jb25zdHJhaW50cz1teEVsbGlwc2UucHJvdG90eXBlLmNvbnN0cmFpbnRzO2hhLnByb3RvdHlwZS5jb25zdHJhaW50cz1teEVsbGlwc2UucHJvdG90eXBlLmNvbnN0cmFpbnRzO29hLnByb3RvdHlwZS5jb25zdHJhaW50cz1teEVsbGlwc2UucHJvdG90eXBlLmNvbnN0cmFpbnRzO2NhLnByb3RvdHlwZS5jb25zdHJhaW50cz1teFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5jb25zdHJhaW50czt3YS5wcm90b3R5cGUuY29uc3RyYWludHM9Cm14UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLmNvbnN0cmFpbnRzO2thLnByb3RvdHlwZS5nZXRDb25zdHJhaW50cz1mdW5jdGlvbihhLGIsZSl7YT1bXTt2YXIgYz1NYXRoLm1pbihiLGUvMiksZD1NYXRoLm1pbihiLWMsTWF0aC5tYXgoMCxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSkpKmIpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC41KSwhMSxudWxsKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxkLDApKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLC41KihkK2ItYyksMCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYi1jLDApKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwKLjUpLCExLG51bGwpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGItYyxlKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwuNSooZCtiLWMpLGUpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGQsZSkpO3JldHVybiBhfTtZLnByb3RvdHlwZS5nZXRDb25zdHJhaW50cz1mdW5jdGlvbihhLGIsZSl7Yj1wYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUoYSwiamV0dHlXaWR0aCIsWS5wcm90b3R5cGUuamV0dHlXaWR0aCkpLzI7YT1wYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUoYSwiamV0dHlIZWlnaHQiLFkucHJvdG90eXBlLmpldHR5SGVpZ2h0KSk7dmFyIGM9W25ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxiKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMjUsCjApLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNSwwKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjc1LDApLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLDApLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC4yNSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsLjUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC43NSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMSksITEsbnVsbCxiKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMjUsMSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDEpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNzUsMSksCiEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLDEpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsMCxNYXRoLm1pbihlLS41KmEsMS41KmEpKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsMCxNYXRoLm1pbihlLS41KmEsMy41KmEpKV07ZT41KmEmJmMucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC43NSksITEsbnVsbCxiKSk7ZT44KmEmJmMucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC41KSwhMSxudWxsLGIpKTtlPjE1KmEmJmMucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC4yNSksITEsbnVsbCxiKSk7cmV0dXJuIGN9O1cucHJvdG90eXBlLmNvbnN0cmFpbnRzPW14UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLmNvbnN0cmFpbnRzO1QucHJvdG90eXBlLmNvbnN0cmFpbnRzPQpteFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5jb25zdHJhaW50cztteEN5bGluZGVyLnByb3RvdHlwZS5jb25zdHJhaW50cz1bbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjE1LC4wNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDApLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguODUsLjA1KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuMyksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC43KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuMyksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsLjUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLAouNyksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4xNSwuOTUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNSwxKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjg1LC45NSksITEpXTtILnByb3RvdHlwZS5jb25zdHJhaW50cz1bbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjI1LC4xKSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMCksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC43NSwuMSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMS8zKSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwxKSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwxLzMpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLAoxKSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsLjUpLCExKV07Wi5wcm90b3R5cGUuY29uc3RyYWludHM9W25ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4yNSwwKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMCksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC43NSwwKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuMyksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjcpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC4yNSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsLjUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC43NSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4yNSwKMSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDEpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNzUsMSksITApXTtteEFjdG9yLnByb3RvdHlwZS5jb25zdHJhaW50cz1bbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMCksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4yNSwuMiksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4xLC41KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuNzUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNzUsLjI1KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjksLjUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC43NSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4yNSwKMSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDEpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNzUsMSksITApXTtxLnByb3RvdHlwZS5jb25zdHJhaW50cz1bbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsLjI1KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwwKSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjI1LC41KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjc1LC41KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwxKSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsLjc1KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwKMSksITEpXTtnLnByb3RvdHlwZS5jb25zdHJhaW50cz1bbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuMzUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC41KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuNjUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC4zNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsLjUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC42NSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4yNSwxKSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjc1LDApLCExKV07Qy5wcm90b3R5cGUuY29uc3RyYWludHM9W25ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4yNSwwKSwKITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDApLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNzUsMCksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4yNSwxKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC43NSwxKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuMjUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC41KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuNzUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC4yNSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsLjUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLAouNzUpLCEwKV07bXhMaW5lLnByb3RvdHlwZS5jb25zdHJhaW50cz1bbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4yNSwuNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC43NSwuNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsLjUpLCExKV07SS5wcm90b3R5cGUuY29uc3RyYWludHM9W25ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDApLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNSwxKSwhMSldO214RG91YmxlRWxsaXBzZS5wcm90b3R5cGUuY29uc3RyYWludHM9bXhFbGxpcHNlLnByb3RvdHlwZS5jb25zdHJhaW50cztteFJob21idXMucHJvdG90eXBlLmNvbnN0cmFpbnRzPW14RWxsaXBzZS5wcm90b3R5cGUuY29uc3RyYWludHM7bXhUcmlhbmdsZS5wcm90b3R5cGUuY29uc3RyYWludHM9CltuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC4yNSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC43NSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDApLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNSwxKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNSksITApXTtteEhleGFnb24ucHJvdG90eXBlLmNvbnN0cmFpbnRzPVtuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMzc1LDApLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNSwwKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjYyNSwwKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwKLjI1KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuNSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjc1KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuMjUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC41KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNzUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMzc1LDEpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNSwxKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjYyNSwxKSwhMCldO214Q2xvdWQucHJvdG90eXBlLmNvbnN0cmFpbnRzPVtuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMjUsLjI1KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjQsCi4xKSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjE2LC41NSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4wNywuNCksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4zMSwuOCksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4xMywuNzcpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguOCwuOCksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41NSwuOTUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguODc1LC41KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjk2LC43KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjYyNSwuMiksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC44OCwKLjI1KSwhMSldO2wucHJvdG90eXBlLmNvbnN0cmFpbnRzPW14UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLmNvbnN0cmFpbnRzO24ucHJvdG90eXBlLmNvbnN0cmFpbnRzPW14UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLmNvbnN0cmFpbnRzO3AucHJvdG90eXBlLmNvbnN0cmFpbnRzPVtuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMjUsMCksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDApLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNzUsMCksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjI1KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuNSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjc1KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuMjUpLAohMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsLjc1KSwhMCldO214QXJyb3cucHJvdG90eXBlLmNvbnN0cmFpbnRzPW51bGw7Ty5wcm90b3R5cGUuZ2V0Q29uc3RyYWludHM9ZnVuY3Rpb24oYSxiLGUpe2E9W107dmFyIGM9TWF0aC5tYXgoMCxNYXRoLm1pbihiLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJkeCIsdGhpcy5keCkpKSksZD1NYXRoLm1heCgwLE1hdGgubWluKGUscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImR5Iix0aGlzLmR5KSkpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNSwwKSwhMSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLAowKSwhMSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYiwuNSpkKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxiLGQpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLC43NSpiKy4yNSpjLGQpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLC41KihiK2MpLGQpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLC41KihiK2MpLC41KihlK2QpKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwuNSooYitjKSxlKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDEpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsCjApLCExLG51bGwsLjUqKGItYyksZSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsLjUqKGItYyksLjUqKGUrZCkpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLC41KihiLWMpLGQpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLC4yNSpiLS4yNSpjLGQpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLDAsZCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsMCwuNSpkKSk7cmV0dXJuIGF9O0wucHJvdG90eXBlLmdldENvbnN0cmFpbnRzPWZ1bmN0aW9uKGEsYixlKXthPVtdO3ZhciBjPU1hdGgubWF4KDAsTWF0aC5taW4oYixwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwKImR4Iix0aGlzLmR4KSkpKSxkPU1hdGgubWF4KDAsTWF0aC5taW4oZSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwiZHkiLHRoaXMuZHkpKSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDApLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsMCksITEpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGIsLjUqZCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYixkKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwuNSooYitjKSxkKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsCjApLCExLG51bGwsYyxkKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxjLC41KihlK2QpKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxjLGUpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLC41KmMsZSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC41KSwhMSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDEpLCExKSk7cmV0dXJuIGF9O2phLnByb3RvdHlwZS5jb25zdHJhaW50cz1bbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsCjEpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMjUsLjUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNSwuNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC43NSwuNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsMCksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsLjUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLDEpLCExKV07Uy5wcm90b3R5cGUuZ2V0Q29uc3RyYWludHM9ZnVuY3Rpb24oYSxiLGUpe2E9W107dmFyIGM9ZSpNYXRoLm1heCgwLE1hdGgubWluKDEscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImFycm93V2lkdGgiLHRoaXMuYXJyb3dXaWR0aCkpKSksZD1iKk1hdGgubWF4KDAsTWF0aC5taW4oMSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwKImFycm93U2l6ZSIsdGhpcy5hcnJvd1NpemUpKSkpLGM9KGUtYykvMjthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuNSksITEpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLDAsYykpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsLjUqKGItZCksYykpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYi1kLDApKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNSksITEpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGItZCxlKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwuNSooYi1kKSxlLWMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwKMCksITEsbnVsbCwwLGUtYykpO3JldHVybiBhfTtpYS5wcm90b3R5cGUuZ2V0Q29uc3RyYWludHM9ZnVuY3Rpb24oYSxiLGUpe2E9W107dmFyIGM9ZSpNYXRoLm1heCgwLE1hdGgubWluKDEscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImFycm93V2lkdGgiLFMucHJvdG90eXBlLmFycm93V2lkdGgpKSkpLGQ9YipNYXRoLm1heCgwLE1hdGgubWluKDEscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImFycm93U2l6ZSIsUy5wcm90b3R5cGUuYXJyb3dTaXplKSkpKSxjPShlLWMpLzI7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjUpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxkLDApKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLC41KmIsYykpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLAowKSwhMSxudWxsLGItZCwwKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsLjUpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxiLWQsZSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsLjUqYixlLWMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGQsZSkpO3JldHVybiBhfTt4YS5wcm90b3R5cGUuZ2V0Q29uc3RyYWludHM9ZnVuY3Rpb24oYSxiLGUpe2E9W107dmFyIGM9TWF0aC5taW4oZSxiKSxkPU1hdGgubWF4KDAsTWF0aC5taW4oYyxjKnBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkpLGM9KGUtZCkvMixmPWMrZCxnPShiLWQpLzIsZD1nK2Q7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsCjApLCExLG51bGwsZywuNSpjKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxnLDApKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMCksITEpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGQsMCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsZCwuNSpjKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxkLGMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGcsZS0uNSpjKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxnLGUpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsCjEpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxkLGUpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGQsZS0uNSpjKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxkLGYpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLC41KihiK2QpLGMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGIsYykpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC41KSwhMSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYixmKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsCjApLCExLG51bGwsLjUqKGIrZCksZikpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsZyxmKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwuNSpnLGMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLDAsYykpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC41KSwhMSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsMCxmKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwuNSpnLGYpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGcsYykpO3JldHVybiBhfTtNLnByb3RvdHlwZS5jb25zdHJhaW50cz0KbnVsbDtOLnByb3RvdHlwZS5jb25zdHJhaW50cz1bbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuMjUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC41KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuNzUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC41KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjcsLjEpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNywuOSksITEpXTttYS5wcm90b3R5cGUuY29uc3RyYWludHM9W25ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4xNzUsLjI1KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjI1LC41KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjE3NSwKLjc1KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC43LC4xKSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjcsLjkpLCExKV07ZWEucHJvdG90eXBlLmNvbnN0cmFpbnRzPVtuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC41KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNSksITEpXTtmYS5wcm90b3R5cGUuY29uc3RyYWludHM9W25ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC41KSwhMSldfSkoKTtmdW5jdGlvbiBBY3Rpb25zKGEpe3RoaXMuZWRpdG9yVWk9YTt0aGlzLmFjdGlvbnM9e307dGhpcy5pbml0KCl9CkFjdGlvbnMucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEpe2QuZXNjYXBlKCk7YT1kLmRlbGV0ZUNlbGxzKGQuZ2V0RGVsZXRhYmxlQ2VsbHMoZC5nZXRTZWxlY3Rpb25DZWxscygpKSxhKTtudWxsIT1hJiZkLnNldFNlbGVjdGlvbkNlbGxzKGEpfXZhciBjPXRoaXMuZWRpdG9yVWksZj1jLmVkaXRvcixkPWYuZ3JhcGgsbT1mdW5jdGlvbigpe3JldHVybiBBY3Rpb24ucHJvdG90eXBlLmlzRW5hYmxlZC5hcHBseSh0aGlzLGFyZ3VtZW50cykmJmQuaXNFbmFibGVkKCl9O3RoaXMuYWRkQWN0aW9uKCJuZXcuLi4iLGZ1bmN0aW9uKCl7ZC5vcGVuTGluayhjLmdldFVybCgpKX0pO3RoaXMuYWRkQWN0aW9uKCJvcGVuLi4uIixmdW5jdGlvbigpe3dpbmRvdy5vcGVuTmV3PSEwO3dpbmRvdy5vcGVuS2V5PSJvcGVuIjtjLm9wZW5GaWxlKCl9KTt0aGlzLmFkZEFjdGlvbigiaW1wb3J0Li4uIixmdW5jdGlvbigpe3dpbmRvdy5vcGVuTmV3PSExO3dpbmRvdy5vcGVuS2V5PQoiaW1wb3J0Ijt3aW5kb3cub3BlbkZpbGU9bmV3IE9wZW5GaWxlKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7Yy5oaWRlRGlhbG9nKCl9KSk7d2luZG93Lm9wZW5GaWxlLnNldENvbnN1bWVyKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsZSl7dHJ5e3ZhciBiPW14VXRpbHMucGFyc2VYbWwoYSk7Zi5ncmFwaC5zZXRTZWxlY3Rpb25DZWxscyhmLmdyYXBoLmltcG9ydEdyYXBoTW9kZWwoYi5kb2N1bWVudEVsZW1lbnQpKX1jYXRjaChwKXtteFV0aWxzLmFsZXJ0KG14UmVzb3VyY2VzLmdldCgiaW52YWxpZE9yTWlzc2luZ0ZpbGUiKSsiOiAiK3AubWVzc2FnZSl9fSkpO2Muc2hvd0RpYWxvZygobmV3IE9wZW5EaWFsb2codGhpcykpLmNvbnRhaW5lciwzMjAsMjIwLCEwLCEwLGZ1bmN0aW9uKCl7d2luZG93Lm9wZW5GaWxlPW51bGx9KX0pLmlzRW5hYmxlZD1tO3RoaXMuYWRkQWN0aW9uKCJzYXZlIixmdW5jdGlvbigpe2Muc2F2ZUZpbGUoITEpfSxudWxsLG51bGwsRWRpdG9yLmN0cmxLZXkrCiIrUyIpLmlzRW5hYmxlZD1tO3RoaXMuYWRkQWN0aW9uKCJzYXZlQXMuLi4iLGZ1bmN0aW9uKCl7Yy5zYXZlRmlsZSghMCl9LG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiK1NoaWZ0K1MiKS5pc0VuYWJsZWQ9bTt0aGlzLmFkZEFjdGlvbigiZXhwb3J0Li4uIixmdW5jdGlvbigpe2Muc2hvd0RpYWxvZygobmV3IEV4cG9ydERpYWxvZyhjKSkuY29udGFpbmVyLDMwMCwyOTYsITAsITApfSk7dGhpcy5hZGRBY3Rpb24oImVkaXREaWFncmFtLi4uIixmdW5jdGlvbigpe3ZhciBhPW5ldyBFZGl0RGlhZ3JhbURpYWxvZyhjKTtjLnNob3dEaWFsb2coYS5jb250YWluZXIsNjIwLDQyMCwhMCwhMSk7YS5pbml0KCl9KTt0aGlzLmFkZEFjdGlvbigicGFnZVNldHVwLi4uIixmdW5jdGlvbigpe2Muc2hvd0RpYWxvZygobmV3IFBhZ2VTZXR1cERpYWxvZyhjKSkuY29udGFpbmVyLDMyMCwyMjAsITAsITApfSkuaXNFbmFibGVkPW07dGhpcy5hZGRBY3Rpb24oInByaW50Li4uIixmdW5jdGlvbigpe2Muc2hvd0RpYWxvZygobmV3IFByaW50RGlhbG9nKGMpKS5jb250YWluZXIsCjMwMCwxODAsITAsITApfSxudWxsLCJzcHJpdGUtcHJpbnQiLEVkaXRvci5jdHJsS2V5KyIrUCIpO3RoaXMuYWRkQWN0aW9uKCJwcmV2aWV3IixmdW5jdGlvbigpe214VXRpbHMuc2hvdyhkLG51bGwsMTAsMTApfSk7dGhpcy5hZGRBY3Rpb24oInVuZG8iLGZ1bmN0aW9uKCl7Yy51bmRvKCl9LG51bGwsInNwcml0ZS11bmRvIixFZGl0b3IuY3RybEtleSsiK1oiKTt0aGlzLmFkZEFjdGlvbigicmVkbyIsZnVuY3Rpb24oKXtjLnJlZG8oKX0sbnVsbCwic3ByaXRlLXJlZG8iLG14Q2xpZW50LklTX1dJTj9FZGl0b3IuY3RybEtleSsiK1kiOkVkaXRvci5jdHJsS2V5KyIrU2hpZnQrWiIpO3RoaXMuYWRkQWN0aW9uKCJjdXQiLGZ1bmN0aW9uKCl7bXhDbGlwYm9hcmQuY3V0KGQpfSxudWxsLCJzcHJpdGUtY3V0IixFZGl0b3IuY3RybEtleSsiK1giKTt0aGlzLmFkZEFjdGlvbigiY29weSIsZnVuY3Rpb24oKXt0cnl7bXhDbGlwYm9hcmQuY29weShkKX1jYXRjaChiKXtjLmhhbmRsZUVycm9yKGIpfX0sCm51bGwsInNwcml0ZS1jb3B5IixFZGl0b3IuY3RybEtleSsiK0MiKTt0aGlzLmFkZEFjdGlvbigicGFzdGUiLGZ1bmN0aW9uKCl7ZC5pc0VuYWJsZWQoKSYmIWQuaXNDZWxsTG9ja2VkKGQuZ2V0RGVmYXVsdFBhcmVudCgpKSYmbXhDbGlwYm9hcmQucGFzdGUoZCl9LCExLCJzcHJpdGUtcGFzdGUiLEVkaXRvci5jdHJsS2V5KyIrViIpO3RoaXMuYWRkQWN0aW9uKCJwYXN0ZUhlcmUiLGZ1bmN0aW9uKGEpe2lmKGQuaXNFbmFibGVkKCkmJiFkLmlzQ2VsbExvY2tlZChkLmdldERlZmF1bHRQYXJlbnQoKSkpe2QuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgYj1teENsaXBib2FyZC5wYXN0ZShkKTtpZihudWxsIT1iKXthPSEwO2Zvcih2YXIgYz0wO2M8Yi5sZW5ndGgmJmE7YysrKWE9YSYmZC5tb2RlbC5pc0VkZ2UoYltjXSk7dmFyIGY9ZC52aWV3LnRyYW5zbGF0ZSxsPWQudmlldy5zY2FsZSxuPWYueCxrPWYueSxmPW51bGw7aWYoMT09Yi5sZW5ndGgmJmEpe3ZhciB0PWQuZ2V0Q2VsbEdlb21ldHJ5KGJbMF0pOwpudWxsIT10JiYoZj10LmdldFRlcm1pbmFsUG9pbnQoITApKX1mPW51bGwhPWY/ZjpkLmdldEJvdW5kaW5nQm94RnJvbUdlb21ldHJ5KGIsYSk7aWYobnVsbCE9Zil7dmFyIG09TWF0aC5yb3VuZChkLnNuYXAoZC5wb3B1cE1lbnVIYW5kbGVyLnRyaWdnZXJYL2wtbikpLHg9TWF0aC5yb3VuZChkLnNuYXAoZC5wb3B1cE1lbnVIYW5kbGVyLnRyaWdnZXJZL2wtaykpO2QuY2VsbHNNb3ZlZChiLG0tZi54LHgtZi55KX19fWZpbmFsbHl7ZC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX19KTt0aGlzLmFkZEFjdGlvbigiY29weVNpemUiLGZ1bmN0aW9uKGEpe2E9ZC5nZXRTZWxlY3Rpb25DZWxsKCk7ZC5pc0VuYWJsZWQoKSYmbnVsbCE9YSYmZC5nZXRNb2RlbCgpLmlzVmVydGV4KGEpJiYoYT1kLmdldENlbGxHZW9tZXRyeShhKSxudWxsIT1hJiYoYy5jb3BpZWRTaXplPW5ldyBteFJlY3RhbmdsZShhLngsYS55LGEud2lkdGgsYS5oZWlnaHQpKSl9LG51bGwsbnVsbCwiQWx0K1NoaWZ0K1giKTsKdGhpcy5hZGRBY3Rpb24oInBhc3RlU2l6ZSIsZnVuY3Rpb24oYSl7aWYoZC5pc0VuYWJsZWQoKSYmIWQuaXNTZWxlY3Rpb25FbXB0eSgpJiZudWxsIT1jLmNvcGllZFNpemUpe2QuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgYj1kLmdldFNlbGVjdGlvbkNlbGxzKCk7Zm9yKGE9MDthPGIubGVuZ3RoO2ErKylpZihkLmdldE1vZGVsKCkuaXNWZXJ0ZXgoYlthXSkpe3ZhciBmPWQuZ2V0Q2VsbEdlb21ldHJ5KGJbYV0pO251bGwhPWYmJihmPWYuY2xvbmUoKSxmLndpZHRoPWMuY29waWVkU2l6ZS53aWR0aCxmLmhlaWdodD1jLmNvcGllZFNpemUuaGVpZ2h0LGQuZ2V0TW9kZWwoKS5zZXRHZW9tZXRyeShiW2FdLGYpKX19ZmluYWxseXtkLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9fX0sbnVsbCxudWxsLCJBbHQrU2hpZnQrViIpO3RoaXMuYWRkQWN0aW9uKCJkZWxldGUiLGZ1bmN0aW9uKGIpe2EobnVsbCE9YiYmbXhFdmVudC5pc1NoaWZ0RG93bihiKSl9LG51bGwsbnVsbCwiRGVsZXRlIik7CnRoaXMuYWRkQWN0aW9uKCJkZWxldGVBbGwiLGZ1bmN0aW9uKCl7YSghMCl9LG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiK0RlbGV0ZSIpO3RoaXMuYWRkQWN0aW9uKCJkdXBsaWNhdGUiLGZ1bmN0aW9uKCl7dHJ5e2Quc2V0U2VsZWN0aW9uQ2VsbHMoZC5kdXBsaWNhdGVDZWxscygpKX1jYXRjaChiKXtjLmhhbmRsZUVycm9yKGIpfX0sbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrRCIpO3RoaXMucHV0KCJ0dXJuIixuZXcgQWN0aW9uKG14UmVzb3VyY2VzLmdldCgidHVybiIpKyIgLyAiK214UmVzb3VyY2VzLmdldCgicmV2ZXJzZSIpLGZ1bmN0aW9uKGEpe2QudHVyblNoYXBlcyhkLmdldFNlbGVjdGlvbkNlbGxzKCksbnVsbCE9YT9teEV2ZW50LmlzU2hpZnREb3duKGEpOiExKX0sbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrUiIpKTt0aGlzLmFkZEFjdGlvbigic2VsZWN0VmVydGljZXMiLGZ1bmN0aW9uKCl7ZC5zZWxlY3RWZXJ0aWNlcyhudWxsLCEwKX0sbnVsbCxudWxsLApFZGl0b3IuY3RybEtleSsiK1NoaWZ0K0kiKTt0aGlzLmFkZEFjdGlvbigic2VsZWN0RWRnZXMiLGZ1bmN0aW9uKCl7ZC5zZWxlY3RFZGdlcygpfSxudWxsLG51bGwsRWRpdG9yLmN0cmxLZXkrIitTaGlmdCtFIik7dGhpcy5hZGRBY3Rpb24oInNlbGVjdEFsbCIsZnVuY3Rpb24oKXtkLnNlbGVjdEFsbChudWxsLCEwKX0sbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrQSIpO3RoaXMuYWRkQWN0aW9uKCJzZWxlY3ROb25lIixmdW5jdGlvbigpe2QuY2xlYXJTZWxlY3Rpb24oKX0sbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrU2hpZnQrQSIpO3RoaXMuYWRkQWN0aW9uKCJsb2NrVW5sb2NrIixmdW5jdGlvbigpe2lmKCFkLmlzU2VsZWN0aW9uRW1wdHkoKSl7ZC5nZXRNb2RlbCgpLmJlZ2luVXBkYXRlKCk7dHJ5e3ZhciBhPWQuaXNDZWxsTW92YWJsZShkLmdldFNlbGVjdGlvbkNlbGwoKSk/MTowO2QudG9nZ2xlQ2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9NT1ZBQkxFLGEpO2QudG9nZ2xlQ2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9SRVNJWkFCTEUsCmEpO2QudG9nZ2xlQ2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9ST1RBVEFCTEUsYSk7ZC50b2dnbGVDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX0RFTEVUQUJMRSxhKTtkLnRvZ2dsZUNlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfRURJVEFCTEUsYSk7ZC50b2dnbGVDZWxsU3R5bGVzKCJjb25uZWN0YWJsZSIsYSl9ZmluYWxseXtkLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9fX0sbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrTCIpO3RoaXMuYWRkQWN0aW9uKCJob21lIixmdW5jdGlvbigpe2QuaG9tZSgpfSxudWxsLG51bGwsIlNoaWZ0K0hvbWUiKTt0aGlzLmFkZEFjdGlvbigiZXhpdEdyb3VwIixmdW5jdGlvbigpe2QuZXhpdEdyb3VwKCl9LG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiK1NoaWZ0K0hvbWUiKTt0aGlzLmFkZEFjdGlvbigiZW50ZXJHcm91cCIsZnVuY3Rpb24oKXtkLmVudGVyR3JvdXAoKX0sbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrU2hpZnQrRW5kIik7CnRoaXMuYWRkQWN0aW9uKCJjb2xsYXBzZSIsZnVuY3Rpb24oKXtkLmZvbGRDZWxscyghMCl9LG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiK0hvbWUiKTt0aGlzLmFkZEFjdGlvbigiZXhwYW5kIixmdW5jdGlvbigpe2QuZm9sZENlbGxzKCExKX0sbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrRW5kIik7dGhpcy5hZGRBY3Rpb24oInRvRnJvbnQiLGZ1bmN0aW9uKCl7ZC5vcmRlckNlbGxzKCExKX0sbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrU2hpZnQrRiIpO3RoaXMuYWRkQWN0aW9uKCJ0b0JhY2siLGZ1bmN0aW9uKCl7ZC5vcmRlckNlbGxzKCEwKX0sbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrU2hpZnQrQiIpO3RoaXMuYWRkQWN0aW9uKCJncm91cCIsZnVuY3Rpb24oKXsxPT1kLmdldFNlbGVjdGlvbkNvdW50KCk/ZC5zZXRDZWxsU3R5bGVzKCJjb250YWluZXIiLCIxIik6ZC5zZXRTZWxlY3Rpb25DZWxsKGQuZ3JvdXBDZWxscyhudWxsLDApKX0sbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KwoiK0ciKTt0aGlzLmFkZEFjdGlvbigidW5ncm91cCIsZnVuY3Rpb24oKXsxPT1kLmdldFNlbGVjdGlvbkNvdW50KCkmJjA9PWQuZ2V0TW9kZWwoKS5nZXRDaGlsZENvdW50KGQuZ2V0U2VsZWN0aW9uQ2VsbCgpKT9kLnNldENlbGxTdHlsZXMoImNvbnRhaW5lciIsIjAiKTpkLnNldFNlbGVjdGlvbkNlbGxzKGQudW5ncm91cENlbGxzKCkpfSxudWxsLG51bGwsRWRpdG9yLmN0cmxLZXkrIitTaGlmdCtVIik7dGhpcy5hZGRBY3Rpb24oInJlbW92ZUZyb21Hcm91cCIsZnVuY3Rpb24oKXtkLnJlbW92ZUNlbGxzRnJvbVBhcmVudCgpfSk7dGhpcy5hZGRBY3Rpb24oImVkaXQiLGZ1bmN0aW9uKCl7ZC5pc0VuYWJsZWQoKSYmZC5zdGFydEVkaXRpbmdBdENlbGwoKX0sbnVsbCxudWxsLCJGMi9FbnRlciIpO3RoaXMuYWRkQWN0aW9uKCJlZGl0RGF0YS4uLiIsZnVuY3Rpb24oKXt2YXIgYT1kLmdldFNlbGVjdGlvbkNlbGwoKXx8ZC5nZXRNb2RlbCgpLmdldFJvb3QoKTtjLnNob3dEYXRhRGlhbG9nKGEpfSwKbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrTSIpO3RoaXMuYWRkQWN0aW9uKCJlZGl0VG9vbHRpcC4uLiIsZnVuY3Rpb24oKXt2YXIgYT1jLmVkaXRvci5ncmFwaDtpZihhLmlzRW5hYmxlZCgpJiYhYS5pc1NlbGVjdGlvbkVtcHR5KCkpe3ZhciBlPWEuZ2V0U2VsZWN0aW9uQ2VsbCgpLGQ9IiI7aWYobXhVdGlscy5pc05vZGUoZS52YWx1ZSkpe3ZhciBmPWUudmFsdWUuZ2V0QXR0cmlidXRlKCJ0b29sdGlwIik7bnVsbCE9ZiYmKGQ9Zil9ZD1uZXcgVGV4dGFyZWFEaWFsb2coYyxteFJlc291cmNlcy5nZXQoImVkaXRUb29sdGlwIikrIjoiLGQsZnVuY3Rpb24oYil7YS5zZXRUb29sdGlwRm9yQ2VsbChlLGIpfSk7Yy5zaG93RGlhbG9nKGQuY29udGFpbmVyLDMyMCwyMDAsITAsITApO2QuaW5pdCgpfX0sbnVsbCxudWxsLCJBbHQrU2hpZnQrVCIpO3RoaXMuYWRkQWN0aW9uKCJvcGVuTGluayIsZnVuY3Rpb24oKXt2YXIgYT1kLmdldExpbmtGb3JDZWxsKGQuZ2V0U2VsZWN0aW9uQ2VsbCgpKTsKbnVsbCE9YSYmZC5vcGVuTGluayhhKX0pO3RoaXMuYWRkQWN0aW9uKCJlZGl0TGluay4uLiIsZnVuY3Rpb24oKXt2YXIgYT1jLmVkaXRvci5ncmFwaDtpZihhLmlzRW5hYmxlZCgpJiYhYS5pc1NlbGVjdGlvbkVtcHR5KCkpe3ZhciBlPWEuZ2V0U2VsZWN0aW9uQ2VsbCgpLGQ9YS5nZXRMaW5rRm9yQ2VsbChlKXx8IiI7Yy5zaG93TGlua0RpYWxvZyhkLG14UmVzb3VyY2VzLmdldCgiYXBwbHkiKSxmdW5jdGlvbihiKXtiPW14VXRpbHMudHJpbShiKTthLnNldExpbmtGb3JDZWxsKGUsMDxiLmxlbmd0aD9iOm51bGwpfSl9fSxudWxsLG51bGwsIkFsdCtTaGlmdCtMIik7dGhpcy5wdXQoImluc2VydEltYWdlIixuZXcgQWN0aW9uKG14UmVzb3VyY2VzLmdldCgiaW1hZ2UiKSsiLi4uIixmdW5jdGlvbigpe2QuaXNFbmFibGVkKCkmJiFkLmlzQ2VsbExvY2tlZChkLmdldERlZmF1bHRQYXJlbnQoKSkmJihkLmNsZWFyU2VsZWN0aW9uKCksYy5hY3Rpb25zLmdldCgiaW1hZ2UiKS5mdW5jdCgpKX0pKS5pc0VuYWJsZWQ9Cm07dGhpcy5wdXQoImluc2VydExpbmsiLG5ldyBBY3Rpb24obXhSZXNvdXJjZXMuZ2V0KCJsaW5rIikrIi4uLiIsZnVuY3Rpb24oKXtkLmlzRW5hYmxlZCgpJiYhZC5pc0NlbGxMb2NrZWQoZC5nZXREZWZhdWx0UGFyZW50KCkpJiZjLnNob3dMaW5rRGlhbG9nKCIiLG14UmVzb3VyY2VzLmdldCgiaW5zZXJ0IiksZnVuY3Rpb24oYSxlKXthPW14VXRpbHMudHJpbShhKTtpZigwPGEubGVuZ3RoKXt2YXIgYj1udWxsLGM9ZC5nZXRMaW5rVGl0bGUoYSk7bnVsbCE9ZSYmMDxlLmxlbmd0aCYmKGI9ZVswXS5pY29uVXJsLGM9ZVswXS5uYW1lfHxlWzBdLnR5cGUsYz1jLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Muc3Vic3RyaW5nKDEpLDMwPGMubGVuZ3RoJiYoYz1jLnN1YnN0cmluZygwLDMwKSsiLi4uIikpO3ZhciBmPWQuZ2V0RnJlZUluc2VydFBvaW50KCksYj1uZXcgbXhDZWxsKGMsbmV3IG14R2VvbWV0cnkoZi54LGYueSwxMDAsNDApLCJmb250Q29sb3I9IzAwMDBFRTtmb250U3R5bGU9NDtyb3VuZGVkPTE7b3ZlcmZsb3c9aGlkZGVuOyIrCihudWxsIT1iPyJzaGFwZT1sYWJlbDtpbWFnZVdpZHRoPTE2O2ltYWdlSGVpZ2h0PTE2O3NwYWNpbmdMZWZ0PTI2O2FsaWduPWxlZnQ7aW1hZ2U9IitiOiJzcGFjaW5nPTEwOyIpKTtiLnZlcnRleD0hMDtkLnNldExpbmtGb3JDZWxsKGIsYSk7ZC5jZWxsU2l6ZVVwZGF0ZWQoYiwhMCk7ZC5nZXRNb2RlbCgpLmJlZ2luVXBkYXRlKCk7dHJ5e2I9ZC5hZGRDZWxsKGIpLGQuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJjZWxsc0luc2VydGVkIiwiY2VsbHMiLFtiXSkpfWZpbmFsbHl7ZC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfWQuc2V0U2VsZWN0aW9uQ2VsbChiKTtkLnNjcm9sbENlbGxUb1Zpc2libGUoZC5nZXRTZWxlY3Rpb25DZWxsKCkpfX0pfSkpLmlzRW5hYmxlZD1tO3RoaXMuYWRkQWN0aW9uKCJsaW5rLi4uIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3ZhciBhPWMuZWRpdG9yLmdyYXBoO2lmKGEuaXNFbmFibGVkKCkpaWYoYS5jZWxsRWRpdG9yLmlzQ29udGVudEVkaXRpbmcoKSl7dmFyIGU9CmEuZ2V0U2VsZWN0ZWRFbGVtZW50KCksZD1hLmdldFBhcmVudEJ5TmFtZShlLCJBIixhLmNlbGxFZGl0b3IudGV4dGFyZWEpLGY9IiI7aWYobnVsbD09ZCYmbnVsbCE9ZSYmbnVsbCE9ZS5nZXRFbGVtZW50c0J5VGFnTmFtZSlmb3IodmFyIGw9ZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYSIpLG49MDtuPGwubGVuZ3RoJiZudWxsPT1kO24rKylsW25dLnRleHRDb250ZW50PT1lLnRleHRDb250ZW50JiYoZD1sW25dKTtudWxsIT1kJiYiQSI9PWQubm9kZU5hbWUmJihmPWQuZ2V0QXR0cmlidXRlKCJocmVmIil8fCIiLGEuc2VsZWN0Tm9kZShkKSk7dmFyIGs9YS5jZWxsRWRpdG9yLnNhdmVTZWxlY3Rpb24oKTtjLnNob3dMaW5rRGlhbG9nKGYsbXhSZXNvdXJjZXMuZ2V0KCJhcHBseSIpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe2EuY2VsbEVkaXRvci5yZXN0b3JlU2VsZWN0aW9uKGspO251bGwhPWImJmEuaW5zZXJ0TGluayhiKX0pKX1lbHNlIGEuaXNTZWxlY3Rpb25FbXB0eSgpPwp0aGlzLmdldCgiaW5zZXJ0TGluayIpLmZ1bmN0KCk6dGhpcy5nZXQoImVkaXRMaW5rIikuZnVuY3QoKX0pKS5pc0VuYWJsZWQ9bTt0aGlzLmFkZEFjdGlvbigiYXV0b3NpemUiLGZ1bmN0aW9uKCl7dmFyIGE9ZC5nZXRTZWxlY3Rpb25DZWxscygpO2lmKG51bGwhPWEpe2QuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGU9MDtlPGEubGVuZ3RoO2UrKyl7dmFyIGM9YVtlXTtpZihkLmdldE1vZGVsKCkuZ2V0Q2hpbGRDb3VudChjKSlkLnVwZGF0ZUdyb3VwQm91bmRzKFtjXSwyMCk7ZWxzZXt2YXIgZj1kLnZpZXcuZ2V0U3RhdGUoYyksbD1kLmdldENlbGxHZW9tZXRyeShjKTtkLmdldE1vZGVsKCkuaXNWZXJ0ZXgoYykmJm51bGwhPWYmJm51bGwhPWYudGV4dCYmbnVsbCE9bCYmZC5pc1dyYXBwaW5nKGMpPyhsPWwuY2xvbmUoKSxsLmhlaWdodD1mLnRleHQuYm91bmRpbmdCb3guaGVpZ2h0L2Qudmlldy5zY2FsZSxkLmdldE1vZGVsKCkuc2V0R2VvbWV0cnkoYyxsKSk6CmQudXBkYXRlQ2VsbFNpemUoYyl9fX1maW5hbGx5e2QuZ2V0TW9kZWwoKS5lbmRVcGRhdGUoKX19fSxudWxsLG51bGwsRWRpdG9yLmN0cmxLZXkrIitTaGlmdCtZIik7dGhpcy5hZGRBY3Rpb24oImZvcm1hdHRlZFRleHQiLGZ1bmN0aW9uKCl7dmFyIGE9ZC5nZXRWaWV3KCkuZ2V0U3RhdGUoZC5nZXRTZWxlY3Rpb25DZWxsKCkpO2lmKG51bGwhPWEpe2Quc3RvcEVkaXRpbmcoKTthPSIxIj09YS5zdHlsZS5odG1sP251bGw6IjEiO2QuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGU9ZC5nZXRTZWxlY3Rpb25DZWxscygpLGY9MDtmPGUubGVuZ3RoO2YrKylpZihzdGF0ZT1kLmdldFZpZXcoKS5nZXRTdGF0ZShlW2ZdKSxudWxsIT1zdGF0ZSl7dmFyIHA9bXhVdGlscy5nZXRWYWx1ZShzdGF0ZS5zdHlsZSwiaHRtbCIsIjAiKTtpZigiMSI9PXAmJm51bGw9PWEpe3ZhciBsPWQuY29udmVydFZhbHVlVG9TdHJpbmcoc3RhdGUuY2VsbCk7IjAiIT1teFV0aWxzLmdldFZhbHVlKHN0YXRlLnN0eWxlLAoibmwyQnIiLCIxIikmJihsPWwucmVwbGFjZSgvXG4vZywiIikucmVwbGFjZSgvPGJyXHMqLj8+L2csIlxuIikpO3ZhciBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO24uaW5uZXJIVE1MPWQuc2FuaXRpemVIdG1sKGwpO2w9bXhVdGlscy5leHRyYWN0VGV4dFdpdGhXaGl0ZXNwYWNlKG4uY2hpbGROb2Rlcyk7ZC5jZWxsTGFiZWxDaGFuZ2VkKHN0YXRlLmNlbGwsbCk7ZC5zZXRDZWxsU3R5bGVzKCJodG1sIixhLFtlW2ZdXSl9ZWxzZSIwIj09cCYmIjEiPT1hJiYobD1teFV0aWxzLmh0bWxFbnRpdGllcyhkLmNvbnZlcnRWYWx1ZVRvU3RyaW5nKHN0YXRlLmNlbGwpLCExKSwiMCIhPW14VXRpbHMuZ2V0VmFsdWUoc3RhdGUuc3R5bGUsIm5sMkJyIiwiMSIpJiYobD1sLnJlcGxhY2UoL1xuL2csIjxici8+IikpLGQuY2VsbExhYmVsQ2hhbmdlZChzdGF0ZS5jZWxsLGQuc2FuaXRpemVIdG1sKGwpKSxkLnNldENlbGxTdHlsZXMoImh0bWwiLGEsW2VbZl1dKSl9Yy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInN0eWxlQ2hhbmdlZCIsCiJrZXlzIixbImh0bWwiXSwidmFsdWVzIixbbnVsbCE9YT9hOiIwIl0sImNlbGxzIixlKSl9ZmluYWxseXtkLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9fX0pO3RoaXMuYWRkQWN0aW9uKCJ3b3JkV3JhcCIsZnVuY3Rpb24oKXt2YXIgYT1kLmdldFZpZXcoKS5nZXRTdGF0ZShkLmdldFNlbGVjdGlvbkNlbGwoKSksZT0id3JhcCI7ZC5zdG9wRWRpdGluZygpO251bGwhPWEmJiJ3cmFwIj09YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9XSElURV9TUEFDRV0mJihlPW51bGwpO2Quc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9XSElURV9TUEFDRSxlKX0pO3RoaXMuYWRkQWN0aW9uKCJyb3RhdGlvbiIsZnVuY3Rpb24oKXt2YXIgYT0iMCIsZT1kLmdldFZpZXcoKS5nZXRTdGF0ZShkLmdldFNlbGVjdGlvbkNlbGwoKSk7bnVsbCE9ZSYmKGE9ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTl18fGEpO2E9bmV3IEZpbGVuYW1lRGlhbG9nKGMsYSxteFJlc291cmNlcy5nZXQoImFwcGx5IiksCmZ1bmN0aW9uKGEpe251bGwhPWEmJjA8YS5sZW5ndGgmJmQuc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTixhKX0sbXhSZXNvdXJjZXMuZ2V0KCJlbnRlclZhbHVlIikrIiAoIitteFJlc291cmNlcy5nZXQoInJvdGF0aW9uIikrIiAwLTM2MCkiKTtjLnNob3dEaWFsb2coYS5jb250YWluZXIsMzc1LDgwLCEwLCEwKTthLmluaXQoKX0pO3RoaXMuYWRkQWN0aW9uKCJyZXNldFZpZXciLGZ1bmN0aW9uKCl7ZC56b29tVG8oMSk7Yy5yZXNldFNjcm9sbGJhcnMoKX0sbnVsbCxudWxsLCJIb21lIik7dGhpcy5hZGRBY3Rpb24oInpvb21JbiIsZnVuY3Rpb24oYSl7ZC5pc0Zhc3Rab29tRW5hYmxlZCgpP2QubGF6eVpvb20oITAsITAsYy5idXR0b25ab29tRGVsYXkpOmQuem9vbUluKCl9LG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiICsgKE51bXBhZCkgLyBBbHQrTW91c2V3aGVlbCIpO3RoaXMuYWRkQWN0aW9uKCJ6b29tT3V0IixmdW5jdGlvbihhKXtkLmlzRmFzdFpvb21FbmFibGVkKCk/CmQubGF6eVpvb20oITEsITAsYy5idXR0b25ab29tRGVsYXkpOmQuem9vbU91dCgpfSxudWxsLG51bGwsRWRpdG9yLmN0cmxLZXkrIiAtIChOdW1wYWQpIC8gQWx0K01vdXNld2hlZWwiKTt0aGlzLmFkZEFjdGlvbigiZml0V2luZG93IixmdW5jdGlvbigpe3ZhciBhPWQuaXNTZWxlY3Rpb25FbXB0eSgpP2QuZ2V0R3JhcGhCb3VuZHMoKTpkLmdldEJvdW5kaW5nQm94KGQuZ2V0U2VsZWN0aW9uQ2VsbHMoKSksZT1kLnZpZXcudHJhbnNsYXRlLGM9ZC52aWV3LnNjYWxlO2Eud2lkdGgvPWM7YS5oZWlnaHQvPWM7YS54PWEueC9jLWUueDthLnk9YS55L2MtZS55O3ZhciBjPWQuY29udGFpbmVyLmNsaWVudFdpZHRoLTEwLGY9ZC5jb250YWluZXIuY2xpZW50SGVpZ2h0LTEwLGw9TWF0aC5mbG9vcigyMCpNYXRoLm1pbihjL2Eud2lkdGgsZi9hLmhlaWdodCkpLzIwO2Quem9vbVRvKGwpO214VXRpbHMuaGFzU2Nyb2xsYmFycyhkLmNvbnRhaW5lcikmJihkLmNvbnRhaW5lci5zY3JvbGxUb3A9KGEueSsKZS55KSpsLU1hdGgubWF4KChmLWEuaGVpZ2h0KmwpLzIrNSwwKSxkLmNvbnRhaW5lci5zY3JvbGxMZWZ0PShhLngrZS54KSpsLU1hdGgubWF4KChjLWEud2lkdGgqbCkvMis1LDApKX0sbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrU2hpZnQrSCIpO3RoaXMuYWRkQWN0aW9uKCJmaXRQYWdlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2QucGFnZVZpc2libGV8fHRoaXMuZ2V0KCJwYWdlVmlldyIpLmZ1bmN0KCk7dmFyIGE9ZC5wYWdlRm9ybWF0LGU9ZC5wYWdlU2NhbGU7ZC56b29tVG8oTWF0aC5mbG9vcigyMCpNYXRoLm1pbigoZC5jb250YWluZXIuY2xpZW50V2lkdGgtMTApL2Eud2lkdGgvZSwoZC5jb250YWluZXIuY2xpZW50SGVpZ2h0LTEwKS9hLmhlaWdodC9lKSkvMjApO214VXRpbHMuaGFzU2Nyb2xsYmFycyhkLmNvbnRhaW5lcikmJihhPWQuZ2V0UGFnZVBhZGRpbmcoKSxkLmNvbnRhaW5lci5zY3JvbGxUb3A9YS55KmQudmlldy5zY2FsZS0xLGQuY29udGFpbmVyLnNjcm9sbExlZnQ9Ck1hdGgubWluKGEueCpkLnZpZXcuc2NhbGUsKGQuY29udGFpbmVyLnNjcm9sbFdpZHRoLWQuY29udGFpbmVyLmNsaWVudFdpZHRoKS8yKS0xKX0pLG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiK0oiKTt0aGlzLmFkZEFjdGlvbigiZml0VHdvUGFnZXMiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7ZC5wYWdlVmlzaWJsZXx8dGhpcy5nZXQoInBhZ2VWaWV3IikuZnVuY3QoKTt2YXIgYT1kLnBhZ2VGb3JtYXQsZT1kLnBhZ2VTY2FsZTtkLnpvb21UbyhNYXRoLmZsb29yKDIwKk1hdGgubWluKChkLmNvbnRhaW5lci5jbGllbnRXaWR0aC0xMCkvKDIqYS53aWR0aCkvZSwoZC5jb250YWluZXIuY2xpZW50SGVpZ2h0LTEwKS9hLmhlaWdodC9lKSkvMjApO214VXRpbHMuaGFzU2Nyb2xsYmFycyhkLmNvbnRhaW5lcikmJihhPWQuZ2V0UGFnZVBhZGRpbmcoKSxkLmNvbnRhaW5lci5zY3JvbGxUb3A9TWF0aC5taW4oYS55LChkLmNvbnRhaW5lci5zY3JvbGxIZWlnaHQtZC5jb250YWluZXIuY2xpZW50SGVpZ2h0KS8KMiksZC5jb250YWluZXIuc2Nyb2xsTGVmdD1NYXRoLm1pbihhLngsKGQuY29udGFpbmVyLnNjcm9sbFdpZHRoLWQuY29udGFpbmVyLmNsaWVudFdpZHRoKS8yKSl9KSxudWxsLG51bGwsRWRpdG9yLmN0cmxLZXkrIitTaGlmdCtKIik7dGhpcy5hZGRBY3Rpb24oImZpdFBhZ2VXaWR0aCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtkLnBhZ2VWaXNpYmxlfHx0aGlzLmdldCgicGFnZVZpZXciKS5mdW5jdCgpO2Quem9vbVRvKE1hdGguZmxvb3IoMjAqKGQuY29udGFpbmVyLmNsaWVudFdpZHRoLTEwKS9kLnBhZ2VGb3JtYXQud2lkdGgvZC5wYWdlU2NhbGUpLzIwKTtpZihteFV0aWxzLmhhc1Njcm9sbGJhcnMoZC5jb250YWluZXIpKXt2YXIgYT1kLmdldFBhZ2VQYWRkaW5nKCk7ZC5jb250YWluZXIuc2Nyb2xsTGVmdD1NYXRoLm1pbihhLngqZC52aWV3LnNjYWxlLChkLmNvbnRhaW5lci5zY3JvbGxXaWR0aC1kLmNvbnRhaW5lci5jbGllbnRXaWR0aCkvMil9fSkpO3RoaXMucHV0KCJjdXN0b21ab29tIiwKbmV3IEFjdGlvbihteFJlc291cmNlcy5nZXQoImN1c3RvbSIpKyIuLi4iLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGE9bmV3IEZpbGVuYW1lRGlhbG9nKHRoaXMuZWRpdG9yVWkscGFyc2VJbnQoMTAwKmQuZ2V0VmlldygpLmdldFNjYWxlKCkpLG14UmVzb3VyY2VzLmdldCgiYXBwbHkiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXthPXBhcnNlSW50KGEpOyFpc05hTihhKSYmMDxhJiZkLnpvb21UbyhhLzEwMCl9KSxteFJlc291cmNlcy5nZXQoInpvb20iKSsiICglKSIpO3RoaXMuZWRpdG9yVWkuc2hvd0RpYWxvZyhhLmNvbnRhaW5lciwzMDAsODAsITAsITApO2EuaW5pdCgpfSksbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrMCIpKTt0aGlzLmFkZEFjdGlvbigicGFnZVNjYWxlLi4uIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3ZhciBhPW5ldyBGaWxlbmFtZURpYWxvZyh0aGlzLmVkaXRvclVpLHBhcnNlSW50KDEwMCpkLnBhZ2VTY2FsZSksCm14UmVzb3VyY2VzLmdldCgiYXBwbHkiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXthPXBhcnNlSW50KGEpOyFpc05hTihhKSYmMDxhJiYoYT1uZXcgQ2hhbmdlUGFnZVNldHVwKGMsbnVsbCxudWxsLG51bGwsYS8xMDApLGEuaWdub3JlQ29sb3I9ITAsYS5pZ25vcmVJbWFnZT0hMCxkLm1vZGVsLmV4ZWN1dGUoYSkpfSksbXhSZXNvdXJjZXMuZ2V0KCJwYWdlU2NhbGUiKSsiICglKSIpO3RoaXMuZWRpdG9yVWkuc2hvd0RpYWxvZyhhLmNvbnRhaW5lciwzMDAsODAsITAsITApO2EuaW5pdCgpfSkpO3ZhciBrPW51bGwsaz10aGlzLmFkZEFjdGlvbigiZ3JpZCIsZnVuY3Rpb24oKXtkLnNldEdyaWRFbmFibGVkKCFkLmlzR3JpZEVuYWJsZWQoKSk7Yy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImdyaWRFbmFibGVkQ2hhbmdlZCIpKX0sbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrU2hpZnQrRyIpO2suc2V0VG9nZ2xlQWN0aW9uKCEwKTtrLnNldFNlbGVjdGVkQ2FsbGJhY2soZnVuY3Rpb24oKXtyZXR1cm4gZC5pc0dyaWRFbmFibGVkKCl9KTsKay5zZXRFbmFibGVkKCExKTtrPXRoaXMuYWRkQWN0aW9uKCJndWlkZXMiLGZ1bmN0aW9uKCl7ZC5ncmFwaEhhbmRsZXIuZ3VpZGVzRW5hYmxlZD0hZC5ncmFwaEhhbmRsZXIuZ3VpZGVzRW5hYmxlZDtjLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgiZ3VpZGVzRW5hYmxlZENoYW5nZWQiKSl9KTtrLnNldFRvZ2dsZUFjdGlvbighMCk7ay5zZXRTZWxlY3RlZENhbGxiYWNrKGZ1bmN0aW9uKCl7cmV0dXJuIGQuZ3JhcGhIYW5kbGVyLmd1aWRlc0VuYWJsZWR9KTtrLnNldEVuYWJsZWQoITEpO2s9dGhpcy5hZGRBY3Rpb24oInRvb2x0aXBzIixmdW5jdGlvbigpe2QudG9vbHRpcEhhbmRsZXIuc2V0RW5hYmxlZCghZC50b29sdGlwSGFuZGxlci5pc0VuYWJsZWQoKSl9KTtrLnNldFRvZ2dsZUFjdGlvbighMCk7ay5zZXRTZWxlY3RlZENhbGxiYWNrKGZ1bmN0aW9uKCl7cmV0dXJuIGQudG9vbHRpcEhhbmRsZXIuaXNFbmFibGVkKCl9KTtrPXRoaXMuYWRkQWN0aW9uKCJjb2xsYXBzZUV4cGFuZCIsCmZ1bmN0aW9uKCl7dmFyIGE9bmV3IENoYW5nZVBhZ2VTZXR1cChjKTthLmlnbm9yZUNvbG9yPSEwO2EuaWdub3JlSW1hZ2U9ITA7YS5mb2xkaW5nRW5hYmxlZD0hZC5mb2xkaW5nRW5hYmxlZDtkLm1vZGVsLmV4ZWN1dGUoYSl9KTtrLnNldFRvZ2dsZUFjdGlvbighMCk7ay5zZXRTZWxlY3RlZENhbGxiYWNrKGZ1bmN0aW9uKCl7cmV0dXJuIGQuZm9sZGluZ0VuYWJsZWR9KTtrLmlzRW5hYmxlZD1tO2s9dGhpcy5hZGRBY3Rpb24oInNjcm9sbGJhcnMiLGZ1bmN0aW9uKCl7Yy5zZXRTY3JvbGxiYXJzKCFjLmhhc1Njcm9sbGJhcnMoKSl9KTtrLnNldFRvZ2dsZUFjdGlvbighMCk7ay5zZXRTZWxlY3RlZENhbGxiYWNrKGZ1bmN0aW9uKCl7cmV0dXJuIGQuc2Nyb2xsYmFyc30pO2s9dGhpcy5hZGRBY3Rpb24oInBhZ2VWaWV3IixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2Muc2V0UGFnZVZpc2libGUoIWQucGFnZVZpc2libGUpfSkpO2suc2V0VG9nZ2xlQWN0aW9uKCEwKTtrLnNldFNlbGVjdGVkQ2FsbGJhY2soZnVuY3Rpb24oKXtyZXR1cm4gZC5wYWdlVmlzaWJsZX0pOwprPXRoaXMuYWRkQWN0aW9uKCJjb25uZWN0aW9uQXJyb3dzIixmdW5jdGlvbigpe2QuY29ubmVjdGlvbkFycm93c0VuYWJsZWQ9IWQuY29ubmVjdGlvbkFycm93c0VuYWJsZWQ7Yy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImNvbm5lY3Rpb25BcnJvd3NDaGFuZ2VkIikpfSxudWxsLG51bGwsIkFsdCtTaGlmdCtBIik7ay5zZXRUb2dnbGVBY3Rpb24oITApO2suc2V0U2VsZWN0ZWRDYWxsYmFjayhmdW5jdGlvbigpe3JldHVybiBkLmNvbm5lY3Rpb25BcnJvd3NFbmFibGVkfSk7az10aGlzLmFkZEFjdGlvbigiY29ubmVjdGlvblBvaW50cyIsZnVuY3Rpb24oKXtkLnNldENvbm5lY3RhYmxlKCFkLmNvbm5lY3Rpb25IYW5kbGVyLmlzRW5hYmxlZCgpKTtjLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgiY29ubmVjdGlvblBvaW50c0NoYW5nZWQiKSl9LG51bGwsbnVsbCwiQWx0K1NoaWZ0K1AiKTtrLnNldFRvZ2dsZUFjdGlvbighMCk7ay5zZXRTZWxlY3RlZENhbGxiYWNrKGZ1bmN0aW9uKCl7cmV0dXJuIGQuY29ubmVjdGlvbkhhbmRsZXIuaXNFbmFibGVkKCl9KTsKaz10aGlzLmFkZEFjdGlvbigiY29weUNvbm5lY3QiLGZ1bmN0aW9uKCl7ZC5jb25uZWN0aW9uSGFuZGxlci5zZXRDcmVhdGVUYXJnZXQoIWQuY29ubmVjdGlvbkhhbmRsZXIuaXNDcmVhdGVUYXJnZXQoKSk7Yy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImNvcHlDb25uZWN0Q2hhbmdlZCIpKX0pO2suc2V0VG9nZ2xlQWN0aW9uKCEwKTtrLnNldFNlbGVjdGVkQ2FsbGJhY2soZnVuY3Rpb24oKXtyZXR1cm4gZC5jb25uZWN0aW9uSGFuZGxlci5pc0NyZWF0ZVRhcmdldCgpfSk7ay5pc0VuYWJsZWQ9bTtrPXRoaXMuYWRkQWN0aW9uKCJhdXRvc2F2ZSIsZnVuY3Rpb24oKXtjLmVkaXRvci5zZXRBdXRvc2F2ZSghYy5lZGl0b3IuYXV0b3NhdmUpfSk7ay5zZXRUb2dnbGVBY3Rpb24oITApO2suc2V0U2VsZWN0ZWRDYWxsYmFjayhmdW5jdGlvbigpe3JldHVybiBjLmVkaXRvci5hdXRvc2F2ZX0pO2suaXNFbmFibGVkPW07ay52aXNpYmxlPSExO3RoaXMuYWRkQWN0aW9uKCJoZWxwIixmdW5jdGlvbigpe3ZhciBhPQoiIjtteFJlc291cmNlcy5pc0xhbmd1YWdlU3VwcG9ydGVkKG14Q2xpZW50Lmxhbmd1YWdlKSYmKGE9Il8iK214Q2xpZW50Lmxhbmd1YWdlKTtkLm9wZW5MaW5rKFJFU09VUkNFU19QQVRIKyIvaGVscCIrYSsiLmh0bWwiKX0pO3ZhciBxPSExO3RoaXMucHV0KCJhYm91dCIsbmV3IEFjdGlvbihteFJlc291cmNlcy5nZXQoImFib3V0IikrIiBHcmFwaCBFZGl0b3IuLi4iLGZ1bmN0aW9uKCl7cXx8KGMuc2hvd0RpYWxvZygobmV3IEFib3V0RGlhbG9nKGMpKS5jb250YWluZXIsMzIwLDI4MCwhMCwhMCxmdW5jdGlvbigpe3E9ITF9KSxxPSEwKX0pKTtrPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsZSxjLGYpe3JldHVybiB0aGlzLmFkZEFjdGlvbihhLGZ1bmN0aW9uKCl7aWYobnVsbCE9YyYmZC5jZWxsRWRpdG9yLmlzQ29udGVudEVkaXRpbmcoKSljKCk7ZWxzZXtkLnN0b3BFZGl0aW5nKCExKTtkLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7dmFyIGE9ZC5nZXRTZWxlY3Rpb25DZWxscygpOwpkLnRvZ2dsZUNlbGxTdHlsZUZsYWdzKG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRTVFlMRSxlLGEpOyhlJm14Q29uc3RhbnRzLkZPTlRfQk9MRCk9PW14Q29uc3RhbnRzLkZPTlRfQk9MRD9kLnVwZGF0ZUxhYmVsRWxlbWVudHMoZC5nZXRTZWxlY3Rpb25DZWxscygpLGZ1bmN0aW9uKGEpe2Euc3R5bGUuZm9udFdlaWdodD1udWxsOyJCIj09YS5ub2RlTmFtZSYmZC5yZXBsYWNlRWxlbWVudChhKX0pOihlJm14Q29uc3RhbnRzLkZPTlRfSVRBTElDKT09bXhDb25zdGFudHMuRk9OVF9JVEFMSUM/ZC51cGRhdGVMYWJlbEVsZW1lbnRzKGQuZ2V0U2VsZWN0aW9uQ2VsbHMoKSxmdW5jdGlvbihhKXthLnN0eWxlLmZvbnRTdHlsZT1udWxsOyJJIj09YS5ub2RlTmFtZSYmZC5yZXBsYWNlRWxlbWVudChhKX0pOihlJm14Q29uc3RhbnRzLkZPTlRfVU5ERVJMSU5FKT09bXhDb25zdGFudHMuRk9OVF9VTkRFUkxJTkUmJmQudXBkYXRlTGFiZWxFbGVtZW50cyhkLmdldFNlbGVjdGlvbkNlbGxzKCksZnVuY3Rpb24oYSl7YS5zdHlsZS50ZXh0RGVjb3JhdGlvbj0KbnVsbDsiVSI9PWEubm9kZU5hbWUmJmQucmVwbGFjZUVsZW1lbnQoYSl9KTtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKykwPT1kLm1vZGVsLmdldENoaWxkQ291bnQoYVtiXSkmJmQuYXV0b1NpemVDZWxsKGFbYl0sITEpfWZpbmFsbHl7ZC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX19LG51bGwsbnVsbCxmKX0pO2soImJvbGQiLG14Q29uc3RhbnRzLkZPTlRfQk9MRCxmdW5jdGlvbigpe2RvY3VtZW50LmV4ZWNDb21tYW5kKCJib2xkIiwhMSxudWxsKX0sRWRpdG9yLmN0cmxLZXkrIitCIik7aygiaXRhbGljIixteENvbnN0YW50cy5GT05UX0lUQUxJQyxmdW5jdGlvbigpe2RvY3VtZW50LmV4ZWNDb21tYW5kKCJpdGFsaWMiLCExLG51bGwpfSxFZGl0b3IuY3RybEtleSsiK0kiKTtrKCJ1bmRlcmxpbmUiLG14Q29uc3RhbnRzLkZPTlRfVU5ERVJMSU5FLGZ1bmN0aW9uKCl7ZG9jdW1lbnQuZXhlY0NvbW1hbmQoInVuZGVybGluZSIsITEsbnVsbCl9LEVkaXRvci5jdHJsS2V5KyIrVSIpOwp0aGlzLmFkZEFjdGlvbigiZm9udENvbG9yLi4uIixmdW5jdGlvbigpe2MubWVudXMucGlja0NvbG9yKG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRDT0xPUiwiZm9yZWNvbG9yIiwiMDAwMDAwIil9KTt0aGlzLmFkZEFjdGlvbigic3Ryb2tlQ29sb3IuLi4iLGZ1bmN0aW9uKCl7Yy5tZW51cy5waWNrQ29sb3IobXhDb25zdGFudHMuU1RZTEVfU1RST0tFQ09MT1IpfSk7dGhpcy5hZGRBY3Rpb24oImZpbGxDb2xvci4uLiIsZnVuY3Rpb24oKXtjLm1lbnVzLnBpY2tDb2xvcihteENvbnN0YW50cy5TVFlMRV9GSUxMQ09MT1IpfSk7dGhpcy5hZGRBY3Rpb24oImdyYWRpZW50Q29sb3IuLi4iLGZ1bmN0aW9uKCl7Yy5tZW51cy5waWNrQ29sb3IobXhDb25zdGFudHMuU1RZTEVfR1JBRElFTlRDT0xPUil9KTt0aGlzLmFkZEFjdGlvbigiYmFja2dyb3VuZENvbG9yLi4uIixmdW5jdGlvbigpe2MubWVudXMucGlja0NvbG9yKG14Q29uc3RhbnRzLlNUWUxFX0xBQkVMX0JBQ0tHUk9VTkRDT0xPUiwiYmFja2NvbG9yIil9KTsKdGhpcy5hZGRBY3Rpb24oImJvcmRlckNvbG9yLi4uIixmdW5jdGlvbigpe2MubWVudXMucGlja0NvbG9yKG14Q29uc3RhbnRzLlNUWUxFX0xBQkVMX0JPUkRFUkNPTE9SKX0pO3RoaXMuYWRkQWN0aW9uKCJ2ZXJ0aWNhbCIsZnVuY3Rpb24oKXtjLm1lbnVzLnRvZ2dsZVN0eWxlKG14Q29uc3RhbnRzLlNUWUxFX0hPUklaT05UQUwsITApfSk7dGhpcy5hZGRBY3Rpb24oInNoYWRvdyIsZnVuY3Rpb24oKXtjLm1lbnVzLnRvZ2dsZVN0eWxlKG14Q29uc3RhbnRzLlNUWUxFX1NIQURPVyl9KTt0aGlzLmFkZEFjdGlvbigic29saWQiLGZ1bmN0aW9uKCl7ZC5nZXRNb2RlbCgpLmJlZ2luVXBkYXRlKCk7dHJ5e2Quc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9EQVNIRUQsbnVsbCksZC5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX0RBU0hfUEFUVEVSTixudWxsKSxjLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgic3R5bGVDaGFuZ2VkIiwia2V5cyIsW214Q29uc3RhbnRzLlNUWUxFX0RBU0hFRCwKbXhDb25zdGFudHMuU1RZTEVfREFTSF9QQVRURVJOXSwidmFsdWVzIixbbnVsbCxudWxsXSwiY2VsbHMiLGQuZ2V0U2VsZWN0aW9uQ2VsbHMoKSkpfWZpbmFsbHl7ZC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX0pO3RoaXMuYWRkQWN0aW9uKCJkYXNoZWQiLGZ1bmN0aW9uKCl7ZC5nZXRNb2RlbCgpLmJlZ2luVXBkYXRlKCk7dHJ5e2Quc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9EQVNIRUQsIjEiKSxkLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfREFTSF9QQVRURVJOLG51bGwpLGMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJzdHlsZUNoYW5nZWQiLCJrZXlzIixbbXhDb25zdGFudHMuU1RZTEVfREFTSEVELG14Q29uc3RhbnRzLlNUWUxFX0RBU0hfUEFUVEVSTl0sInZhbHVlcyIsWyIxIixudWxsXSwiY2VsbHMiLGQuZ2V0U2VsZWN0aW9uQ2VsbHMoKSkpfWZpbmFsbHl7ZC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX0pO3RoaXMuYWRkQWN0aW9uKCJkb3R0ZWQiLApmdW5jdGlvbigpe2QuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtkLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfREFTSEVELCIxIiksZC5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX0RBU0hfUEFUVEVSTiwiMSA0IiksYy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInN0eWxlQ2hhbmdlZCIsImtleXMiLFtteENvbnN0YW50cy5TVFlMRV9EQVNIRUQsbXhDb25zdGFudHMuU1RZTEVfREFTSF9QQVRURVJOXSwidmFsdWVzIixbIjEiLCIxIDQiXSwiY2VsbHMiLGQuZ2V0U2VsZWN0aW9uQ2VsbHMoKSkpfWZpbmFsbHl7ZC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX0pO3RoaXMuYWRkQWN0aW9uKCJzaGFycCIsZnVuY3Rpb24oKXtkLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7ZC5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX1JPVU5ERUQsIjAiKSxkLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfQ1VSVkVELCIwIiksYy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInN0eWxlQ2hhbmdlZCIsCiJrZXlzIixbbXhDb25zdGFudHMuU1RZTEVfUk9VTkRFRCxteENvbnN0YW50cy5TVFlMRV9DVVJWRURdLCJ2YWx1ZXMiLFsiMCIsIjAiXSwiY2VsbHMiLGQuZ2V0U2VsZWN0aW9uQ2VsbHMoKSkpfWZpbmFsbHl7ZC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX0pO3RoaXMuYWRkQWN0aW9uKCJyb3VuZGVkIixmdW5jdGlvbigpe2QuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtkLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfUk9VTkRFRCwiMSIpLGQuc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9DVVJWRUQsIjAiKSxjLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgic3R5bGVDaGFuZ2VkIiwia2V5cyIsW214Q29uc3RhbnRzLlNUWUxFX1JPVU5ERUQsbXhDb25zdGFudHMuU1RZTEVfQ1VSVkVEXSwidmFsdWVzIixbIjEiLCIwIl0sImNlbGxzIixkLmdldFNlbGVjdGlvbkNlbGxzKCkpKX1maW5hbGx5e2QuZ2V0TW9kZWwoKS5lbmRVcGRhdGUoKX19KTt0aGlzLmFkZEFjdGlvbigidG9nZ2xlUm91bmRlZCIsCmZ1bmN0aW9uKCl7aWYoIWQuaXNTZWxlY3Rpb25FbXB0eSgpJiZkLmlzRW5hYmxlZCgpKXtkLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7dmFyIGE9ZC5nZXRTZWxlY3Rpb25DZWxscygpLGU9ZC5nZXRDdXJyZW50Q2VsbFN0eWxlKGFbMF0pLGY9IjEiPT1teFV0aWxzLmdldFZhbHVlKGUsbXhDb25zdGFudHMuU1RZTEVfUk9VTkRFRCwiMCIpPyIwIjoiMSI7ZC5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX1JPVU5ERUQsZik7ZC5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX0NVUlZFRCxudWxsKTtjLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgic3R5bGVDaGFuZ2VkIiwia2V5cyIsW214Q29uc3RhbnRzLlNUWUxFX1JPVU5ERUQsbXhDb25zdGFudHMuU1RZTEVfQ1VSVkVEXSwidmFsdWVzIixbZiwiMCJdLCJjZWxscyIsZC5nZXRTZWxlY3Rpb25DZWxscygpKSl9ZmluYWxseXtkLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9fX0pO3RoaXMuYWRkQWN0aW9uKCJjdXJ2ZWQiLApmdW5jdGlvbigpe2QuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtkLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfUk9VTkRFRCwiMCIpLGQuc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9DVVJWRUQsIjEiKSxjLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgic3R5bGVDaGFuZ2VkIiwia2V5cyIsW214Q29uc3RhbnRzLlNUWUxFX1JPVU5ERUQsbXhDb25zdGFudHMuU1RZTEVfQ1VSVkVEXSwidmFsdWVzIixbIjAiLCIxIl0sImNlbGxzIixkLmdldFNlbGVjdGlvbkNlbGxzKCkpKX1maW5hbGx5e2QuZ2V0TW9kZWwoKS5lbmRVcGRhdGUoKX19KTt0aGlzLmFkZEFjdGlvbigiY29sbGFwc2libGUiLGZ1bmN0aW9uKCl7dmFyIGE9ZC52aWV3LmdldFN0YXRlKGQuZ2V0U2VsZWN0aW9uQ2VsbCgpKSxlPSIxIjtudWxsIT1hJiZudWxsIT1kLmdldEZvbGRpbmdJbWFnZShhKSYmKGU9IjAiKTtkLnNldENlbGxTdHlsZXMoImNvbGxhcHNpYmxlIixlKTtjLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgic3R5bGVDaGFuZ2VkIiwKImtleXMiLFsiY29sbGFwc2libGUiXSwidmFsdWVzIixbZV0sImNlbGxzIixkLmdldFNlbGVjdGlvbkNlbGxzKCkpKX0pO3RoaXMuYWRkQWN0aW9uKCJlZGl0U3R5bGUuLi4iLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGE9ZC5nZXRTZWxlY3Rpb25DZWxscygpO2lmKG51bGwhPWEmJjA8YS5sZW5ndGgpe3ZhciBlPWQuZ2V0TW9kZWwoKSxlPW5ldyBUZXh0YXJlYURpYWxvZyh0aGlzLmVkaXRvclVpLG14UmVzb3VyY2VzLmdldCgiZWRpdFN0eWxlIikrIjoiLGUuZ2V0U3R5bGUoYVswXSl8fCIiLGZ1bmN0aW9uKGIpe251bGwhPWImJmQuc2V0Q2VsbFN0eWxlKG14VXRpbHMudHJpbShiKSxhKX0sbnVsbCxudWxsLDQwMCwyMjApO3RoaXMuZWRpdG9yVWkuc2hvd0RpYWxvZyhlLmNvbnRhaW5lciw0MjAsMzAwLCEwLCEwKTtlLmluaXQoKX19KSxudWxsLG51bGwsRWRpdG9yLmN0cmxLZXkrIitFIik7dGhpcy5hZGRBY3Rpb24oInNldEFzRGVmYXVsdFN0eWxlIixmdW5jdGlvbigpe2QuaXNFbmFibGVkKCkmJgohZC5pc1NlbGVjdGlvbkVtcHR5KCkmJmMuc2V0RGVmYXVsdFN0eWxlKGQuZ2V0U2VsZWN0aW9uQ2VsbCgpKX0sbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrU2hpZnQrRCIpO3RoaXMuYWRkQWN0aW9uKCJjbGVhckRlZmF1bHRTdHlsZSIsZnVuY3Rpb24oKXtkLmlzRW5hYmxlZCgpJiZjLmNsZWFyRGVmYXVsdFN0eWxlKCl9LG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiK1NoaWZ0K1IiKTt0aGlzLmFkZEFjdGlvbigiYWRkV2F5cG9pbnQiLGZ1bmN0aW9uKCl7dmFyIGE9ZC5nZXRTZWxlY3Rpb25DZWxsKCk7aWYobnVsbCE9YSYmZC5nZXRNb2RlbCgpLmlzRWRnZShhKSl7dmFyIGU9Zi5ncmFwaC5zZWxlY3Rpb25DZWxsc0hhbmRsZXIuZ2V0SGFuZGxlcihhKTtpZihlIGluc3RhbmNlb2YgbXhFZGdlSGFuZGxlcil7Zm9yKHZhciBjPWQudmlldy50cmFuc2xhdGUscD1kLnZpZXcuc2NhbGUsbD1jLngsYz1jLnksYT1kLmdldE1vZGVsKCkuZ2V0UGFyZW50KGEpLG49ZC5nZXRDZWxsR2VvbWV0cnkoYSk7ZC5nZXRNb2RlbCgpLmlzVmVydGV4KGEpJiYKbnVsbCE9bjspbCs9bi54LGMrPW4ueSxhPWQuZ2V0TW9kZWwoKS5nZXRQYXJlbnQoYSksbj1kLmdldENlbGxHZW9tZXRyeShhKTtsPU1hdGgucm91bmQoZC5zbmFwKGQucG9wdXBNZW51SGFuZGxlci50cmlnZ2VyWC9wLWwpKTtwPU1hdGgucm91bmQoZC5zbmFwKGQucG9wdXBNZW51SGFuZGxlci50cmlnZ2VyWS9wLWMpKTtlLmFkZFBvaW50QXQoZS5zdGF0ZSxsLHApfX19KTt0aGlzLmFkZEFjdGlvbigicmVtb3ZlV2F5cG9pbnQiLGZ1bmN0aW9uKCl7dmFyIGE9Yy5hY3Rpb25zLmdldCgicmVtb3ZlV2F5cG9pbnQiKTtudWxsIT1hLmhhbmRsZXImJmEuaGFuZGxlci5yZW1vdmVQb2ludChhLmhhbmRsZXIuc3RhdGUsYS5pbmRleCl9KTt0aGlzLmFkZEFjdGlvbigiY2xlYXJXYXlwb2ludHMiLGZ1bmN0aW9uKCl7dmFyIGE9ZC5nZXRTZWxlY3Rpb25DZWxscygpO2lmKG51bGwhPWEpe2E9ZC5hZGRBbGxFZGdlcyhhKTtkLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBlPQowO2U8YS5sZW5ndGg7ZSsrKXt2YXIgYz1hW2VdO2lmKGQuZ2V0TW9kZWwoKS5pc0VkZ2UoYykpe3ZhciBmPWQuZ2V0Q2VsbEdlb21ldHJ5KGMpO251bGwhPWYmJihmPWYuY2xvbmUoKSxmLnBvaW50cz1udWxsLGQuZ2V0TW9kZWwoKS5zZXRHZW9tZXRyeShjLGYpKX19fWZpbmFsbHl7ZC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX19LG51bGwsbnVsbCwiQWx0K1NoaWZ0K0MiKTtrPXRoaXMuYWRkQWN0aW9uKCJzdWJzY3JpcHQiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7ZC5jZWxsRWRpdG9yLmlzQ29udGVudEVkaXRpbmcoKSYmZG9jdW1lbnQuZXhlY0NvbW1hbmQoInN1YnNjcmlwdCIsITEsbnVsbCl9KSxudWxsLG51bGwsRWRpdG9yLmN0cmxLZXkrIissIik7az10aGlzLmFkZEFjdGlvbigic3VwZXJzY3JpcHQiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7ZC5jZWxsRWRpdG9yLmlzQ29udGVudEVkaXRpbmcoKSYmZG9jdW1lbnQuZXhlY0NvbW1hbmQoInN1cGVyc2NyaXB0IiwKITEsbnVsbCl9KSxudWxsLG51bGwsRWRpdG9yLmN0cmxLZXkrIisuIik7az10aGlzLmFkZEFjdGlvbigiaW5kZW50IixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2QuY2VsbEVkaXRvci5pc0NvbnRlbnRFZGl0aW5nKCkmJmRvY3VtZW50LmV4ZWNDb21tYW5kKCJpbmRlbnQiLCExLG51bGwpfSksbnVsbCxudWxsLCJTaGlmdCtUYWIiKTt0aGlzLmFkZEFjdGlvbigiaW1hZ2UuLi4iLGZ1bmN0aW9uKCl7aWYoZC5pc0VuYWJsZWQoKSYmIWQuaXNDZWxsTG9ja2VkKGQuZ2V0RGVmYXVsdFBhcmVudCgpKSl7dmFyIGE9bXhSZXNvdXJjZXMuZ2V0KCJpbWFnZSIpKyIgKCIrbXhSZXNvdXJjZXMuZ2V0KCJ1cmwiKSsiKToiLGU9ZC5nZXRWaWV3KCkuZ2V0U3RhdGUoZC5nZXRTZWxlY3Rpb25DZWxsKCkpLGY9IiI7bnVsbCE9ZSYmKGY9ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9JTUFHRV18fGYpO3ZhciBwPWQuY2VsbEVkaXRvci5zYXZlU2VsZWN0aW9uKCk7Yy5zaG93SW1hZ2VEaWFsb2coYSwKZixmdW5jdGlvbihhLGIsZSl7aWYoZC5jZWxsRWRpdG9yLmlzQ29udGVudEVkaXRpbmcoKSlkLmNlbGxFZGl0b3IucmVzdG9yZVNlbGVjdGlvbihwKSxkLmluc2VydEltYWdlKGEsYixlKTtlbHNle3ZhciBjPWQuZ2V0U2VsZWN0aW9uQ2VsbHMoKTtpZihudWxsIT1hJiYoMDxhLmxlbmd0aHx8MDxjLmxlbmd0aCkpe3ZhciBmPW51bGw7ZC5nZXRNb2RlbCgpLmJlZ2luVXBkYXRlKCk7dHJ5e2lmKDA9PWMubGVuZ3RoKXt2YXIgZz1kLmdldEZyZWVJbnNlcnRQb2ludCgpLGY9Yz1bZC5pbnNlcnRWZXJ0ZXgoZC5nZXREZWZhdWx0UGFyZW50KCksbnVsbCwiIixnLngsZy55LGIsZSwic2hhcGU9aW1hZ2U7aW1hZ2VBc3BlY3Q9MDthc3BlY3Q9Zml4ZWQ7dmVydGljYWxMYWJlbFBvc2l0aW9uPWJvdHRvbTt2ZXJ0aWNhbEFsaWduPXRvcDsiKV07ZC5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImNlbGxzSW5zZXJ0ZWQiLCJjZWxscyIsZikpfWQuc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9JTUFHRSwKMDxhLmxlbmd0aD9hOm51bGwsYyk7dmFyIGw9ZC5nZXRDdXJyZW50Q2VsbFN0eWxlKGNbMF0pOyJpbWFnZSIhPWxbbXhDb25zdGFudHMuU1RZTEVfU0hBUEVdJiYibGFiZWwiIT1sW214Q29uc3RhbnRzLlNUWUxFX1NIQVBFXT9kLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfU0hBUEUsImltYWdlIixjKTowPT1hLmxlbmd0aCYmZC5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX1NIQVBFLG51bGwsYyk7aWYoMT09ZC5nZXRTZWxlY3Rpb25Db3VudCgpJiZudWxsIT1iJiZudWxsIT1lKXt2YXIgbj1jWzBdLGs9ZC5nZXRNb2RlbCgpLmdldEdlb21ldHJ5KG4pO251bGwhPWsmJihrPWsuY2xvbmUoKSxrLndpZHRoPWIsay5oZWlnaHQ9ZSxkLmdldE1vZGVsKCkuc2V0R2VvbWV0cnkobixrKSl9fWZpbmFsbHl7ZC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfW51bGwhPWYmJihkLnNldFNlbGVjdGlvbkNlbGxzKGYpLGQuc2Nyb2xsQ2VsbFRvVmlzaWJsZShmWzBdKSl9fX0sCmQuY2VsbEVkaXRvci5pc0NvbnRlbnRFZGl0aW5nKCksIWQuY2VsbEVkaXRvci5pc0NvbnRlbnRFZGl0aW5nKCkpfX0pLmlzRW5hYmxlZD1tO2s9dGhpcy5hZGRBY3Rpb24oImxheWVycyIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtudWxsPT10aGlzLmxheWVyc1dpbmRvdz8odGhpcy5sYXllcnNXaW5kb3c9bmV3IExheWVyc1dpbmRvdyhjLGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGgtMjgwLDEyMCwyMjAsMTk2KSx0aGlzLmxheWVyc1dpbmRvdy53aW5kb3cuYWRkTGlzdGVuZXIoInNob3ciLGZ1bmN0aW9uKCl7Yy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImxheWVycyIpKX0pLHRoaXMubGF5ZXJzV2luZG93LndpbmRvdy5hZGRMaXN0ZW5lcigiaGlkZSIsZnVuY3Rpb24oKXtjLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgibGF5ZXJzIikpfSksdGhpcy5sYXllcnNXaW5kb3cud2luZG93LnNldFZpc2libGUoITApLGMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJsYXllcnMiKSksCnRoaXMubGF5ZXJzV2luZG93LmluaXQoKSk6dGhpcy5sYXllcnNXaW5kb3cud2luZG93LnNldFZpc2libGUoIXRoaXMubGF5ZXJzV2luZG93LndpbmRvdy5pc1Zpc2libGUoKSl9KSxudWxsLG51bGwsRWRpdG9yLmN0cmxLZXkrIitTaGlmdCtMIik7ay5zZXRUb2dnbGVBY3Rpb24oITApO2suc2V0U2VsZWN0ZWRDYWxsYmFjayhteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLmxheWVyc1dpbmRvdyYmdGhpcy5sYXllcnNXaW5kb3cud2luZG93LmlzVmlzaWJsZSgpfSkpO2s9dGhpcy5hZGRBY3Rpb24oImZvcm1hdFBhbmVsIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2MudG9nZ2xlRm9ybWF0UGFuZWwoKX0pLG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiK1NoaWZ0K1AiKTtrLnNldFRvZ2dsZUFjdGlvbighMCk7ay5zZXRTZWxlY3RlZENhbGxiYWNrKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIDA8Yy5mb3JtYXRXaWR0aH0pKTsKaz10aGlzLmFkZEFjdGlvbigib3V0bGluZSIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtudWxsPT10aGlzLm91dGxpbmVXaW5kb3c/KHRoaXMub3V0bGluZVdpbmRvdz1uZXcgT3V0bGluZVdpbmRvdyhjLGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGgtMjYwLDEwMCwxODAsMTgwKSx0aGlzLm91dGxpbmVXaW5kb3cud2luZG93LmFkZExpc3RlbmVyKCJzaG93IixmdW5jdGlvbigpe2MuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJvdXRsaW5lIikpfSksdGhpcy5vdXRsaW5lV2luZG93LndpbmRvdy5hZGRMaXN0ZW5lcigiaGlkZSIsZnVuY3Rpb24oKXtjLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgib3V0bGluZSIpKX0pLHRoaXMub3V0bGluZVdpbmRvdy53aW5kb3cuc2V0VmlzaWJsZSghMCksYy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoIm91dGxpbmUiKSkpOnRoaXMub3V0bGluZVdpbmRvdy53aW5kb3cuc2V0VmlzaWJsZSghdGhpcy5vdXRsaW5lV2luZG93LndpbmRvdy5pc1Zpc2libGUoKSl9KSwKbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrU2hpZnQrTyIpO2suc2V0VG9nZ2xlQWN0aW9uKCEwKTtrLnNldFNlbGVjdGVkQ2FsbGJhY2sobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5vdXRsaW5lV2luZG93JiZ0aGlzLm91dGxpbmVXaW5kb3cud2luZG93LmlzVmlzaWJsZSgpfSkpfTtBY3Rpb25zLnByb3RvdHlwZS5hZGRBY3Rpb249ZnVuY3Rpb24oYSxjLGYsZCxtKXt2YXIgazsiLi4uIj09YS5zdWJzdHJpbmcoYS5sZW5ndGgtMyk/KGE9YS5zdWJzdHJpbmcoMCxhLmxlbmd0aC0zKSxrPW14UmVzb3VyY2VzLmdldChhKSsiLi4uIik6az1teFJlc291cmNlcy5nZXQoYSk7cmV0dXJuIHRoaXMucHV0KGEsbmV3IEFjdGlvbihrLGMsZixkLG0pKX07QWN0aW9ucy5wcm90b3R5cGUucHV0PWZ1bmN0aW9uKGEsYyl7cmV0dXJuIHRoaXMuYWN0aW9uc1thXT1jfTtBY3Rpb25zLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYWN0aW9uc1thXX07CmZ1bmN0aW9uIEFjdGlvbihhLGMsZixkLG0pe214RXZlbnRTb3VyY2UuY2FsbCh0aGlzKTt0aGlzLmxhYmVsPWE7dGhpcy5mdW5jdD10aGlzLmNyZWF0ZUZ1bmN0aW9uKGMpO3RoaXMuZW5hYmxlZD1udWxsIT1mP2Y6ITA7dGhpcy5pY29uQ2xzPWQ7dGhpcy5zaG9ydGN1dD1tO3RoaXMudmlzaWJsZT0hMH1teFV0aWxzLmV4dGVuZChBY3Rpb24sbXhFdmVudFNvdXJjZSk7QWN0aW9uLnByb3RvdHlwZS5jcmVhdGVGdW5jdGlvbj1mdW5jdGlvbihhKXtyZXR1cm4gYX07QWN0aW9uLnByb3RvdHlwZS5zZXRFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuZW5hYmxlZCE9YSYmKHRoaXMuZW5hYmxlZD1hLHRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJzdGF0ZUNoYW5nZWQiKSkpfTtBY3Rpb24ucHJvdG90eXBlLmlzRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuYWJsZWR9OwpBY3Rpb24ucHJvdG90eXBlLnNldFRvZ2dsZUFjdGlvbj1mdW5jdGlvbihhKXt0aGlzLnRvZ2dsZUFjdGlvbj1hfTtBY3Rpb24ucHJvdG90eXBlLnNldFNlbGVjdGVkQ2FsbGJhY2s9ZnVuY3Rpb24oYSl7dGhpcy5zZWxlY3RlZENhbGxiYWNrPWF9O0FjdGlvbi5wcm90b3R5cGUuaXNTZWxlY3RlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNlbGVjdGVkQ2FsbGJhY2soKX07RHJhd2lvRmlsZT1mdW5jdGlvbihhLGMpe214RXZlbnRTb3VyY2UuY2FsbCh0aGlzKTt0aGlzLnVpPWE7dGhpcy5zaGFkb3dEYXRhPXRoaXMuZGF0YT1jfHwiIjt0aGlzLnNoYWRvd1BhZ2VzPW51bGw7dGhpcy5jcmVhdGVkPShuZXcgRGF0ZSkuZ2V0VGltZSgpO3RoaXMuc3RhdHM9e29wZW5lZDowLG1lcmdlZDowLGZpbGVNZXJnZWQ6MCxmaWxlUmVsb2FkZWQ6MCxjb25mbGljdHM6MCx0aW1lb3V0czowLHNhdmVkOjAsY2xvc2VkOjAsZGVzdHJveWVkOjAsam9pbmVkOjAsY2hlY2tzdW1FcnJvcnM6MCxieXRlc1NlbnQ6MCxieXRlc1JlY2VpdmVkOjAsbXNnU2VudDowLG1zZ1JlY2VpdmVkOjAsY2FjaGVIaXRzOjAsY2FjaGVNaXNzOjAsY2FjaGVGYWlsOjB9fTtEcmF3aW9GaWxlLlNZTkM9dXJsUGFyYW1zLnN5bmN8fCJhdXRvIjtEcmF3aW9GaWxlLkxBU1RfV1JJVEVfV0lOUz0hMDtteFV0aWxzLmV4dGVuZChEcmF3aW9GaWxlLG14RXZlbnRTb3VyY2UpOwpEcmF3aW9GaWxlLnByb3RvdHlwZS5hbGxDaGFuZ2VzU2F2ZWRLZXk9ImFsbENoYW5nZXNTYXZlZCI7RHJhd2lvRmlsZS5wcm90b3R5cGUuYXV0b3NhdmVEZWxheT0xNTAwO0RyYXdpb0ZpbGUucHJvdG90eXBlLm1heEF1dG9zYXZlRGVsYXk9M0U0O0RyYXdpb0ZpbGUucHJvdG90eXBlLmF1dG9zYXZlVGhyZWFkPW51bGw7RHJhd2lvRmlsZS5wcm90b3R5cGUubGFzdEF1dG9zYXZlPW51bGw7RHJhd2lvRmlsZS5wcm90b3R5cGUubGFzdFNhdmVkPW51bGw7RHJhd2lvRmlsZS5wcm90b3R5cGUubGFzdENoYW5nZWQ9bnVsbDtEcmF3aW9GaWxlLnByb3RvdHlwZS5vcGVuZWQ9bnVsbDtEcmF3aW9GaWxlLnByb3RvdHlwZS5tb2RpZmllZD0hMTtEcmF3aW9GaWxlLnByb3RvdHlwZS5zaGFkb3dNb2RpZmllZD0hMTtEcmF3aW9GaWxlLnByb3RvdHlwZS5kYXRhPW51bGw7RHJhd2lvRmlsZS5wcm90b3R5cGUuc2hhZG93RGF0YT1udWxsO0RyYXdpb0ZpbGUucHJvdG90eXBlLnNoYWRvd1BhZ2VzPW51bGw7CkRyYXdpb0ZpbGUucHJvdG90eXBlLmNoYW5nZUxpc3RlbmVyRW5hYmxlZD0hMDtEcmF3aW9GaWxlLnByb3RvdHlwZS5sYXN0QXV0b3NhdmVSZXZpc2lvbj1udWxsO0RyYXdpb0ZpbGUucHJvdG90eXBlLm1heEF1dG9zYXZlUmV2aXNpb25EZWxheT0zRTU7RHJhd2lvRmlsZS5wcm90b3R5cGUuaW5Db25mbGljdFN0YXRlPSExO0RyYXdpb0ZpbGUucHJvdG90eXBlLmludmFsaWRDaGVja3N1bT0hMTtEcmF3aW9GaWxlLnByb3RvdHlwZS5lcnJvclJlcG9ydHNFbmFibGVkPSExO0RyYXdpb0ZpbGUucHJvdG90eXBlLnJlcG9ydEVuYWJsZWQ9ITA7RHJhd2lvRmlsZS5wcm90b3R5cGUuYWdlU3RhcnQ9bnVsbDtEcmF3aW9GaWxlLnByb3RvdHlwZS5nZXRTaXplPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuZGF0YT90aGlzLmRhdGEubGVuZ3RoOjB9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5zeW5jaHJvbml6ZUZpbGU9ZnVuY3Rpb24oYSxjKXt0aGlzLnNhdmluZ0ZpbGU/bnVsbCE9YyYmYyh7bWVzc2FnZTpteFJlc291cmNlcy5nZXQoImJ1c3kiKX0pOm51bGwhPXRoaXMuc3luYz90aGlzLnN5bmMuZmlsZUNoYW5nZWQoYSxjKTp0aGlzLnVwZGF0ZUZpbGUoYSxjKX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLnVwZGF0ZUZpbGU9ZnVuY3Rpb24oYSxjLGYsZCl7bnVsbCE9ZiYmZigpfHwodGhpcy51aS5nZXRDdXJyZW50RmlsZSgpIT10aGlzfHx0aGlzLmludmFsaWRDaGVja3N1bT9udWxsIT1jJiZjKCk6dGhpcy5nZXRMYXRlc3RWZXJzaW9uKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKG0pe3RyeXtudWxsIT1mJiZmKCl8fCh0aGlzLnVpLmdldEN1cnJlbnRGaWxlKCkhPXRoaXN8fHRoaXMuaW52YWxpZENoZWNrc3VtP251bGwhPWMmJmMoKTpudWxsIT1tP3RoaXMubWVyZ2VGaWxlKG0sYSxjLGQpOnRoaXMucmVsb2FkRmlsZShhLGMpKX1jYXRjaChrKXtudWxsIT1jJiZjKGspfX0pLGMpKX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLm1lcmdlRmlsZT1mdW5jdGlvbihhLGMsZixkKXt2YXIgbT0hMDt0cnl7dGhpcy5zdGF0cy5maWxlTWVyZ2VkKys7dmFyIGs9bnVsbCE9dGhpcy5zaGFkb3dQYWdlcz90aGlzLnNoYWRvd1BhZ2VzOnRoaXMudWkuZ2V0UGFnZXNGb3JOb2RlKG14VXRpbHMucGFyc2VYbWwodGhpcy5zaGFkb3dEYXRhKS5kb2N1bWVudEVsZW1lbnQpLHE9dGhpcy51aS5nZXRQYWdlc0Zvck5vZGUobXhVdGlscy5wYXJzZVhtbChhLmRhdGEpLmRvY3VtZW50RWxlbWVudCk7aWYobnVsbCE9cSYmMDxxLmxlbmd0aCl7dGhpcy5zaGFkb3dQYWdlcz1xO3RoaXMuYmFja3VwUGF0Y2g9dGhpcy5pc01vZGlmaWVkKCk/dGhpcy51aS5kaWZmUGFnZXMoayx0aGlzLnVpLnBhZ2VzKTpudWxsO3ZhciBiPVt0aGlzLnVpLmRpZmZQYWdlcyhudWxsIT1kP2Q6ayx0aGlzLnNoYWRvd1BhZ2VzKV07aWYoIXRoaXMuaWdub3JlUGF0Y2hlcyhiKSl7dmFyIGU9dGhpcy51aS5wYXRjaFBhZ2VzKGssCmJbMF0pO2Q9e307dmFyIGc9dGhpcy51aS5nZXRIYXNoVmFsdWVGb3JQYWdlcyhlLGQpLGs9e30scD10aGlzLnVpLmdldEhhc2hWYWx1ZUZvclBhZ2VzKHRoaXMuc2hhZG93UGFnZXMsayk7IjEiPT11cmxQYXJhbXMudGVzdCYmRWRpdG9yVWkuZGVidWcoIkZpbGUubWVyZ2VGaWxlIixbdGhpc10sImJhY2t1cCIsdGhpcy5iYWNrdXBQYXRjaCwicGF0Y2hlcyIsYiwiY2hlY2tzdW0iLHA9PWcsZyk7aWYobnVsbCE9ZyYmZyE9cCl7dmFyIGw9dGhpcy5jb21wcmVzc1JlcG9ydERhdGEodGhpcy5nZXRBbm9ueW1pemVkWG1sRm9yUGFnZXMocSkpLG49dGhpcy5jb21wcmVzc1JlcG9ydERhdGEodGhpcy5nZXRBbm9ueW1pemVkWG1sRm9yUGFnZXMoZSkpLHY9dGhpcy51aS5oYXNoVmFsdWUoYS5nZXRDdXJyZW50RXRhZygpKSx0PXRoaXMudWkuaGFzaFZhbHVlKHRoaXMuZ2V0Q3VycmVudEV0YWcoKSk7dGhpcy5jaGVja3N1bUVycm9yKGYsYiwiU2hhZG93IERldGFpbHM6ICIrSlNPTi5zdHJpbmdpZnkoZCkrCiJcbkNoZWNrc3VtOiAiK2crIlxuQ3VycmVudDogIitwKyJcbkN1cnJlbnQgRGV0YWlsczogIitKU09OLnN0cmluZ2lmeShrKSsiXG5Gcm9tOiAiK3YrIlxuVG86ICIrdCsiXG5cbkZpbGUgRGF0YTpcbiIrbCsiXG5QYXRjaGVkIFNoYWRvdzpcbiIrbixudWxsLCJtZXJnZUZpbGUiKTtyZXR1cm59dGhpcy5wYXRjaChiLERyYXdpb0ZpbGUuTEFTVF9XUklURV9XSU5TP3RoaXMuYmFja3VwUGF0Y2g6bnVsbCl9fWVsc2UgdGhyb3cgbT0hMSxFcnJvcihteFJlc291cmNlcy5nZXQoIm5vdEFEaWFncmFtRmlsZSIpKTt0aGlzLmluQ29uZmxpY3RTdGF0ZT10aGlzLmludmFsaWRDaGVja3N1bT0hMTt0aGlzLnNldERlc2NyaXB0b3IoYS5nZXREZXNjcmlwdG9yKCkpO3RoaXMuZGVzY3JpcHRvckNoYW5nZWQoKTt0aGlzLmJhY2t1cFBhdGNoPW51bGw7bnVsbCE9YyYmYygpfWNhdGNoKEUpe3RoaXMuaW52YWxpZENoZWNrc3VtPXRoaXMuaW5Db25mbGljdFN0YXRlPSEwO3RoaXMuZGVzY3JpcHRvckNoYW5nZWQoKTsKbnVsbCE9ZiYmZihFKTt0cnl7aWYobSlpZih0aGlzLmVycm9yUmVwb3J0c0VuYWJsZWQpdGhpcy5zZW5kRXJyb3JSZXBvcnQoIkVycm9yIGluIG1lcmdlRmlsZSIsbnVsbCxFKTtlbHNle3ZhciB5PXRoaXMuZ2V0Q3VycmVudFVzZXIoKSx4PW51bGwhPXk/eS5pZDoidW5rbm93biI7RWRpdG9yVWkubG9nRXJyb3IoIkVycm9yIGluIG1lcmdlRmlsZSIsbnVsbCx0aGlzLmdldE1vZGUoKSsiLiIrdGhpcy5nZXRJZCgpLHgsRSl9fWNhdGNoKEEpe319fTsKRHJhd2lvRmlsZS5wcm90b3R5cGUuZ2V0QW5vbnltaXplZFhtbEZvclBhZ2VzPWZ1bmN0aW9uKGEpe3ZhciBjPW5ldyBteENvZGVjKG14VXRpbHMuY3JlYXRlWG1sRG9jdW1lbnQoKSksZj1jLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIm14ZmlsZSIpO2lmKG51bGwhPWEpZm9yKHZhciBkPTA7ZDxhLmxlbmd0aDtkKyspe3ZhciBtPWMuZW5jb2RlKG5ldyBteEdyYXBoTW9kZWwoYVtkXS5yb290KSk7IjEiIT11cmxQYXJhbXMuZGV2JiYobT10aGlzLnVpLmFub255bWl6ZU5vZGUobSwhMCkpO20uc2V0QXR0cmlidXRlKCJpZCIsYVtkXS5nZXRJZCgpKTthW2RdLnZpZXdTdGF0ZSYmdGhpcy51aS5lZGl0b3IuZ3JhcGguc2F2ZVZpZXdTdGF0ZShhW2RdLnZpZXdTdGF0ZSxtLCEwKTtmLmFwcGVuZENoaWxkKG0pfXJldHVybiBteFV0aWxzLmdldFByZXR0eVhtbChmKX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLmNvbXByZXNzUmVwb3J0RGF0YT1mdW5jdGlvbihhLGMsZil7Yz1udWxsIT1jP2M6MUU0O251bGwhPWYmJm51bGwhPWEmJmEubGVuZ3RoPmY/YT1hLnN1YnN0cmluZygwLGYpKyJbLi4uXSI6bnVsbCE9YSYmYS5sZW5ndGg+YyYmKGE9R3JhcGguY29tcHJlc3MoYSkrIlxuIik7cmV0dXJuIGF9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5jaGVja3N1bUVycm9yPWZ1bmN0aW9uKGEsYyxmLGQsbSl7dGhpcy5zdGF0cy5jaGVja3N1bUVycm9ycysrO3RoaXMuaW52YWxpZENoZWNrc3VtPXRoaXMuaW5Db25mbGljdFN0YXRlPSEwO3RoaXMuZGVzY3JpcHRvckNoYW5nZWQoKTtudWxsIT10aGlzLnN5bmMmJnRoaXMuc3luYy51cGRhdGVPbmxpbmVTdGF0ZSgpO251bGwhPWEmJmEoKTt0cnl7aWYodGhpcy5lcnJvclJlcG9ydHNFbmFibGVkKXtpZihudWxsIT1jKWZvcihhPTA7YTxjLmxlbmd0aDthKyspdGhpcy51aS5hbm9ueW1pemVQYXRjaChjW2FdKTt2YXIgaz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt2YXIgYj10aGlzLmNvbXByZXNzUmVwb3J0RGF0YShKU09OLnN0cmluZ2lmeShjLG51bGwsMikpO2E9bnVsbCE9YT90aGlzLmNvbXByZXNzUmVwb3J0RGF0YSh0aGlzLmdldEFub255bWl6ZWRYbWxGb3JQYWdlcyh0aGlzLnVpLmdldFBhZ2VzRm9yTm9kZShteFV0aWxzLnBhcnNlWG1sKGEuZGF0YSkuZG9jdW1lbnRFbGVtZW50KSksCjI1RTMpOiJuL2EiO3RoaXMuc2VuZEVycm9yUmVwb3J0KCJDaGVja3N1bSBFcnJvciBpbiAiK20rIiAiK3RoaXMuZ2V0SGFzaCgpLChudWxsIT1mP2Y6IiIpKyJcblxuUGF0Y2hlczpcbiIrYisobnVsbCE9YT8iXG5cblJlbW90ZTpcbiIrYToiIiksbnVsbCw3RTQpfSk7bnVsbD09ZD9rKG51bGwpOnRoaXMuZ2V0TGF0ZXN0VmVyc2lvbihteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsIT1hJiZhLmdldEN1cnJlbnRFdGFnKCk9PWQ/ayhhKTprKG51bGwpfSksZnVuY3Rpb24oKXt9KX1lbHNle3ZhciBxPXRoaXMuZ2V0Q3VycmVudFVzZXIoKSxiPW51bGwhPXE/cS5pZDoidW5rbm93biI7RWRpdG9yVWkubG9nRXJyb3IoIkNoZWNrc3VtIEVycm9yIGluICIrbSsiICIrdGhpcy5nZXRJZCgpLG51bGwsdGhpcy5nZXRNb2RlKCkrIi4iK3RoaXMuZ2V0SWQoKSwidXNlcl8iK2IrKG51bGwhPXRoaXMuc3luYz8iLWNsaWVudF8iK3RoaXMuc3luYy5jbGllbnRJZDoiLW5vc3luYyIpKTsKdHJ5e0VkaXRvclVpLmxvZ0V2ZW50KHtjYXRlZ29yeToiQ0hFQ0tTVU0tRVJST1ItU1lOQy1GSUxFLSIrdGhpcy5nZXRIYXNoKCksYWN0aW9uOm0sbGFiZWw6InVzZXJfIitiKyhudWxsIT10aGlzLnN5bmM/Ii1jbGllbnRfIit0aGlzLnN5bmMuY2xpZW50SWQ6Ii1ub3N5bmMiKX0pfWNhdGNoKGUpe319fWNhdGNoKGUpe319OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5zZW5kRXJyb3JSZXBvcnQ9ZnVuY3Rpb24oYSxjLGYsZCl7dHJ5e3ZhciBtPXRoaXMuY29tcHJlc3NSZXBvcnREYXRhKHRoaXMuZ2V0QW5vbnltaXplZFhtbEZvclBhZ2VzKHRoaXMuc2hhZG93UGFnZXMpLDI1RTMpLGs9dGhpcy5jb21wcmVzc1JlcG9ydERhdGEodGhpcy5nZXRBbm9ueW1pemVkWG1sRm9yUGFnZXModGhpcy51aS5wYWdlcyksMjVFMykscT10aGlzLmdldEN1cnJlbnRVc2VyKCksYj1udWxsIT1xP3RoaXMudWkuaGFzaFZhbHVlKHEuaWQpOiJ1bmtub3duIixlPW51bGwhPXRoaXMuc3luYz8iLWNsaWVudF8iK3RoaXMuc3luYy5jbGllbnRJZDoiLW5vc3luYyIsZz10aGlzLmdldFRpdGxlKCkscD1nLmxhc3RJbmRleE9mKCIuIikscT0ieG1sIjswPHAmJihxPWcuc3Vic3RyaW5nKHApKTt2YXIgbD1udWxsIT1mP2Yuc3RhY2s6RXJyb3IoKS5zdGFjaztFZGl0b3JVaS5zZW5kUmVwb3J0KGErIiAiKyhuZXcgRGF0ZSkudG9JU09TdHJpbmcoKSsKIjpcblxuQXBwVmVyc2lvbj0iK25hdmlnYXRvci5hcHBWZXJzaW9uKyJcbkZpbGU9Iit0aGlzLnVpLmhhc2hWYWx1ZSh0aGlzLmdldElkKCkpKyIgKCIrdGhpcy5nZXRNb2RlKCkrIikiKyh0aGlzLmlzTW9kaWZpZWQoKT8iIG1vZGlmaWVkIjoiIikrIlxuU2l6ZS9UeXBlPSIrdGhpcy5nZXRTaXplKCkrIiAoIitxKyIpXG5Vc2VyPSIrYitlKyJcblByZWZpeD0iK3RoaXMudWkuZWRpdG9yLmdyYXBoLm1vZGVsLnByZWZpeCsiXG5TeW5jPSIrRHJhd2lvRmlsZS5TWU5DKyhudWxsIT10aGlzLnN5bmM/KHRoaXMuc3luYy5lbmFibGVkPyIgZW5hYmxlZCI6IiIpKyh0aGlzLnN5bmMuaXNDb25uZWN0ZWQoKT8iIGNvbm5lY3RlZCI6IiIpOiIiKSsiXG5QbHVnaW5zPSIrKG51bGwhPW14U2V0dGluZ3Muc2V0dGluZ3M/bXhTZXR0aW5ncy5nZXRQbHVnaW5zKCk6Im51bGwiKSsiXG5cblN0YXRzOlxuIitKU09OLnN0cmluZ2lmeSh0aGlzLnN0YXRzLG51bGwsMikrKG51bGwhPWM/IlxuXG4iK2M6CiIiKSsobnVsbCE9Zj8iXG5cbkVycm9yOiAiK2YubWVzc2FnZToiIikrIlxuXG5TdGFjazpcbiIrbCsiXG5cblNoYWRvdzpcbiIrbSsiXG5cbkRhdGE6XG4iK2ssZCl9Y2F0Y2gobil7fX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLnJlbG9hZEZpbGU9ZnVuY3Rpb24oYSxjKXt0cnl7dGhpcy51aS5zcGlubmVyLnN0b3AoKTt2YXIgZj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuc3RhdHMuZmlsZVJlbG9hZGVkKys7dGhpcy5yZXBvcnRFbmFibGVkPSExO3ZhciBjPXRoaXMudWkuZWRpdG9yLmdyYXBoLmdldFZpZXdTdGF0ZSgpLGY9dGhpcy51aS5lZGl0b3IuZ3JhcGguZ2V0U2VsZWN0aW9uQ2VsbHMoKSxrPXRoaXMudWkuY3VycmVudFBhZ2U7dGhpcy51aS5sb2FkRmlsZSh0aGlzLmdldEhhc2goKSwhMCxudWxsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7aWYobnVsbD09dGhpcy51aS5maWxlTG9hZGVkRXJyb3Ipe3RoaXMudWkucmVzdG9yZVZpZXdTdGF0ZShrLGMsZik7bnVsbCE9dGhpcy5iYWNrdXBQYXRjaCYmdGhpcy5wYXRjaChbdGhpcy5iYWNrdXBQYXRjaF0pO3ZhciBkPXRoaXMudWkuZ2V0Q3VycmVudEZpbGUoKTtudWxsIT1kJiYoZC5zdGF0cz0KdGhpcy5zdGF0cyk7bnVsbCE9YSYmYSgpfX0pLCEwKX0pO3RoaXMuaXNNb2RpZmllZCgpJiZudWxsPT10aGlzLmJhY2t1cFBhdGNoP3RoaXMudWkuY29uZmlybShteFJlc291cmNlcy5nZXQoImFsbENoYW5nZXNMb3N0IiksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmhhbmRsZUZpbGVTdWNjZXNzKCJtYW51YWwiPT1EcmF3aW9GaWxlLlNZTkMpfSksZixteFJlc291cmNlcy5nZXQoImNhbmNlbCIpLG14UmVzb3VyY2VzLmdldCgiZGlzY2FyZENoYW5nZXMiKSk6ZigpfWNhdGNoKGQpe251bGwhPWMmJmMoZCl9fTtEcmF3aW9GaWxlLnByb3RvdHlwZS5jb3B5RmlsZT1mdW5jdGlvbihhLGMpe3RoaXMudWkuZWRpdG9yLmVkaXRBc05ldyh0aGlzLnVpLmdldEZpbGVEYXRhKCEwKSx0aGlzLnVpLmdldENvcHlGaWxlbmFtZSh0aGlzKSl9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5pZ25vcmVQYXRjaGVzPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYz0hMCxmPTA7ZjxhLmxlbmd0aCYmYztmKyspYz1jJiYwPT1PYmplY3Qua2V5cyhhW2ZdKS5sZW5ndGg7cmV0dXJuIGN9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5wYXRjaD1mdW5jdGlvbihhLGMpe3ZhciBmPXRoaXMudWkuZWRpdG9yLnVuZG9NYW5hZ2VyLGQ9Zi5oaXN0b3J5LnNsaWNlKCksbT1mLmluZGV4T2ZOZXh0QWRkLGs9dGhpcy51aS5lZGl0b3IuZ3JhcGg7ay5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIjt2YXIgcT10aGlzLmNoYW5nZUxpc3RlbmVyRW5hYmxlZDt0aGlzLmNoYW5nZUxpc3RlbmVyRW5hYmxlZD0hMTt2YXIgYj1rLmZvbGRpbmdFbmFibGVkLGU9ay5tYXRoRW5hYmxlZCxnPWsuY2VsbFJlbmRlcmVyLnJlZHJhdztrLmNlbGxSZW5kZXJlci5yZWRyYXc9ZnVuY3Rpb24oYSl7YS52aWV3LmdyYXBoLmlzRWRpdGluZyhhLmNlbGwpJiYoYS52aWV3LmdyYXBoLnNjcm9sbENlbGxUb1Zpc2libGUoYS5jZWxsKSxhLnZpZXcuZ3JhcGguY2VsbEVkaXRvci5yZXNpemUoKSk7Zy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2subW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBwPQowO3A8YS5sZW5ndGg7cCsrKXRoaXMudWkucGFnZXM9dGhpcy51aS5wYXRjaFBhZ2VzKHRoaXMudWkucGFnZXMsYVtwXSwhMCxjLHRoaXMuaXNNb2RpZmllZCgpKTswPT10aGlzLnVpLnBhZ2VzLmxlbmd0aCYmdGhpcy51aS5wYWdlcy5wdXNoKHRoaXMudWkuY3JlYXRlUGFnZSgpKTswPm14VXRpbHMuaW5kZXhPZih0aGlzLnVpLnBhZ2VzLHRoaXMudWkuY3VycmVudFBhZ2UpJiZ0aGlzLnVpLnNlbGVjdFBhZ2UodGhpcy51aS5wYWdlc1swXSwhMCl9ZmluYWxseXtrLmNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5PSIiO2subW9kZWwuZW5kVXBkYXRlKCk7ay5jZWxsUmVuZGVyZXIucmVkcmF3PWc7dGhpcy5jaGFuZ2VMaXN0ZW5lckVuYWJsZWQ9cTtmLmhpc3Rvcnk9ZDtmLmluZGV4T2ZOZXh0QWRkPW07Zi5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5DTEVBUikpO2lmKG51bGw9PXRoaXMudWkuY3VycmVudFBhZ2V8fHRoaXMudWkuY3VycmVudFBhZ2UubmVlZHNVcGRhdGUpZSE9CmsubWF0aEVuYWJsZWQ/KHRoaXMudWkuZWRpdG9yLnVwZGF0ZUdyYXBoQ29tcG9uZW50cygpLGsucmVmcmVzaCgpKTooYiE9ay5mb2xkaW5nRW5hYmxlZD9rLnZpZXcucmV2YWxpZGF0ZSgpOmsudmlldy52YWxpZGF0ZSgpLGsuc2l6ZURpZENoYW5nZSgpKTt0aGlzLnVpLnVwZGF0ZVRhYkNvbnRhaW5lcigpfX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24oYSxjLGYsZCxtLGspe3RyeXtpZih0aGlzLmlzRWRpdGFibGUoKSlpZighbSYmdGhpcy5pbnZhbGlkQ2hlY2tzdW0paWYobnVsbCE9ZilmKHttZXNzYWdlOm14UmVzb3VyY2VzLmdldCgiY2hlY2tzdW0iKX0pO2Vsc2UgdGhyb3cgRXJyb3IobXhSZXNvdXJjZXMuZ2V0KCJjaGVja3N1bSIpKTtlbHNlIHRoaXMudXBkYXRlRmlsZURhdGEoKSx0aGlzLmNsZWFyQXV0b3NhdmUoKSxudWxsIT1jJiZjKCk7ZWxzZSBpZihudWxsIT1mKWYoe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJyZWFkT25seSIpfSk7ZWxzZSB0aHJvdyBFcnJvcihteFJlc291cmNlcy5nZXQoInJlYWRPbmx5IikpO31jYXRjaChxKXtpZihudWxsIT1mKWYocSk7ZWxzZSB0aHJvdyBxO319OwpEcmF3aW9GaWxlLnByb3RvdHlwZS51cGRhdGVGaWxlRGF0YT1mdW5jdGlvbihhKXt0aGlzLnNldERhdGEodGhpcy51aS5nZXRGaWxlRGF0YShudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsdGhpcyxudWxsIT1hPyFhOiF0aGlzLmlzQ29tcHJlc3NlZCgpKSl9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmlzQ29tcHJlc3NlZFN0b3JhZ2U9ZnVuY3Rpb24oKXtyZXR1cm4hMH07RHJhd2lvRmlsZS5wcm90b3R5cGUuaXNDb21wcmVzc2VkPWZ1bmN0aW9uKCl7dmFyIGE9bnVsbCE9dGhpcy51aS5maWxlTm9kZT90aGlzLnVpLmZpbGVOb2RlLmdldEF0dHJpYnV0ZSgiY29tcHJlc3NlZCIpOm51bGw7cmV0dXJuIG51bGwhPWE/ImZhbHNlIiE9YTp0aGlzLmlzQ29tcHJlc3NlZFN0b3JhZ2UoKSYmRWRpdG9yLmNvbXByZXNzWG1sfTsKRHJhd2lvRmlsZS5wcm90b3R5cGUuZGVjb21wcmVzcz1mdW5jdGlvbigpe3RoaXMudXBkYXRlRmlsZURhdGEoITEpO251bGwhPXRoaXMudWkuZmlsZU5vZGUmJnRoaXMudWkuZmlsZU5vZGUuc2V0QXR0cmlidXRlKCJjb21wcmVzc2VkIiwiZmFsc2UiKTt0aGlzLmZpbGVDaGFuZ2VkKCl9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmNvbXByZXNzPWZ1bmN0aW9uKCl7dGhpcy51cGRhdGVGaWxlRGF0YSghMCk7bnVsbCE9dGhpcy51aS5maWxlTm9kZSYmdGhpcy51aS5maWxlTm9kZS5zZXRBdHRyaWJ1dGUoImNvbXByZXNzZWQiLCJ0cnVlIik7dGhpcy5maWxlQ2hhbmdlZCgpfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5zYXZlQXM9ZnVuY3Rpb24oYSxjLGYpe307RHJhd2lvRmlsZS5wcm90b3R5cGUuc2F2ZUZpbGU9ZnVuY3Rpb24oYSxjLGYsZCl7fTtEcmF3aW9GaWxlLnByb3RvdHlwZS5nZXRQdWJsaWNVcmw9ZnVuY3Rpb24oYSl7YShudWxsKX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLmlzUmVzdHJpY3RlZD1mdW5jdGlvbigpe3JldHVybiExfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5pc01vZGlmaWVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubW9kaWZpZWR9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmdldFNoYWRvd01vZGlmaWVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2hhZG93TW9kaWZpZWR9O0RyYXdpb0ZpbGUucHJvdG90eXBlLnNldFNoYWRvd01vZGlmaWVkPWZ1bmN0aW9uKGEpe3RoaXMuc2hhZG93TW9kaWZpZWQ9YX07RHJhd2lvRmlsZS5wcm90b3R5cGUuc2V0TW9kaWZpZWQ9ZnVuY3Rpb24oYSl7dGhpcy5zaGFkb3dNb2RpZmllZD10aGlzLm1vZGlmaWVkPWF9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmlzQXV0b3NhdmVPcHRpb25hbD1mdW5jdGlvbigpe3JldHVybiExfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5pc0F1dG9zYXZlPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuaW5Db25mbGljdFN0YXRlJiZ0aGlzLnVpLmVkaXRvci5hdXRvc2F2ZX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLmlzUmVuYW1hYmxlPWZ1bmN0aW9uKCl7cmV0dXJuITF9O0RyYXdpb0ZpbGUucHJvdG90eXBlLnJlbmFtZT1mdW5jdGlvbihhLGMsZil7fTtEcmF3aW9GaWxlLnByb3RvdHlwZS5pc01vdmFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hMX07RHJhd2lvRmlsZS5wcm90b3R5cGUuaXNUcmFzaGVkPWZ1bmN0aW9uKCl7cmV0dXJuITF9O0RyYXdpb0ZpbGUucHJvdG90eXBlLm1vdmU9ZnVuY3Rpb24oYSxjLGYpe307RHJhd2lvRmlsZS5wcm90b3R5cGUuZ2V0SGFzaD1mdW5jdGlvbigpe3JldHVybiIifTtEcmF3aW9GaWxlLnByb3RvdHlwZS5nZXRJZD1mdW5jdGlvbigpe3JldHVybiIifTtEcmF3aW9GaWxlLnByb3RvdHlwZS5pc0VkaXRhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMudWkuZWRpdG9yLmlzQ2hyb21lbGVzc1ZpZXcoKXx8dGhpcy51aS5lZGl0b3IuZWRpdGFibGV9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmdldFVpPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudWl9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5nZXRUaXRsZT1mdW5jdGlvbigpe3JldHVybiIifTtEcmF3aW9GaWxlLnByb3RvdHlwZS5zZXREYXRhPWZ1bmN0aW9uKGEpe3RoaXMuZGF0YT1hfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5nZXREYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24oKXt0aGlzLnN0YXRzLm9wZW5lZCsrO3ZhciBhPXRoaXMuZ2V0RGF0YSgpO2lmKG51bGwhPWEpe3ZhciBjPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYz0wO251bGwhPWEmJmM8YS5sZW5ndGg7YysrKXt2YXIgZj1hW2NdO251bGwhPWYuaWQmJjA9PWYuaWQuaW5kZXhPZigiZXh0Rm9udF8iKSYmZi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGYpfX07Yyhkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCJoZWFkID4gc3R5bGVbaWRdIikpO2MoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgiaGVhZCA+IGxpbmtbaWRdIikpO3RoaXMudWkuc2V0RmlsZURhdGEoYSk7dGhpcy5pc01vZGlmaWVkKCl8fCh0aGlzLnNoYWRvd0RhdGE9bXhVdGlscy5nZXRYbWwodGhpcy51aS5nZXRYbWxGaWxlRGF0YSgpKSx0aGlzLnNoYWRvd1BhZ2VzPW51bGwpfXRoaXMuaW5zdGFsbExpc3RlbmVycygpO3RoaXMuaXNTeW5jU3VwcG9ydGVkKCkmJnRoaXMuc3RhcnRTeW5jKCl9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5pc1N5bmNTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX07RHJhd2lvRmlsZS5wcm90b3R5cGUuaXNSZXZpc2lvbkhpc3RvcnlTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX07RHJhd2lvRmlsZS5wcm90b3R5cGUuZ2V0UmV2aXNpb25zPWZ1bmN0aW9uKGEsYyl7YShudWxsKX07RHJhd2lvRmlsZS5wcm90b3R5cGUubG9hZERlc2NyaXB0b3I9ZnVuY3Rpb24oYSxjKXthKG51bGwpfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5sb2FkUGF0Y2hEZXNjcmlwdG9yPWZ1bmN0aW9uKGEsYyl7dGhpcy5sb2FkRGVzY3JpcHRvcihteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihjKXthKGMpfSksYyl9O0RyYXdpb0ZpbGUucHJvdG90eXBlLnBhdGNoRGVzY3JpcHRvcj1mdW5jdGlvbihhLGMpe3RoaXMuc2V0RGVzY3JpcHRvckV0YWcoYSx0aGlzLmdldERlc2NyaXB0b3JFdGFnKGMpKX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLnN0YXJ0U3luYz1mdW5jdGlvbigpeyJhdXRvIiE9RHJhd2lvRmlsZS5TWU5DfHwiMSI9PXVybFBhcmFtcy5zdGVhbHRofHwiMSIhPXVybFBhcmFtcy5ydCYmdGhpcy51aS5lZGl0b3IuY2hyb21lbGVzcyYmIXRoaXMudWkuZWRpdG9yLmVkaXRhYmxlfHwobnVsbD09dGhpcy5zeW5jJiYodGhpcy5zeW5jPW5ldyBEcmF3aW9GaWxlU3luYyh0aGlzKSksdGhpcy5zeW5jLnN0YXJ0KCkpfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5pc0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuITF9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmdldENoYW5uZWxJZD1mdW5jdGlvbigpe3JldHVybiBHcmFwaC5jb21wcmVzcyh0aGlzLmdldEhhc2goKSkucmVwbGFjZSgvW1wvICtdL2csIl8iKX07RHJhd2lvRmlsZS5wcm90b3R5cGUuZ2V0Q2hhbm5lbEtleT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbH07RHJhd2lvRmlsZS5wcm90b3R5cGUuZ2V0Q3VycmVudFVzZXI9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07CkRyYXdpb0ZpbGUucHJvdG90eXBlLmdldExhdGVzdFZlcnNpb249ZnVuY3Rpb24oYSxjKXthKG51bGwpfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5nZXRMYXN0TW9kaWZpZWREYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBEYXRlfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5zZXRDdXJyZW50UmV2aXNpb25JZD1mdW5jdGlvbihhKXt0aGlzLnNldERlc2NyaXB0b3JSZXZpc2lvbklkKHRoaXMuZ2V0RGVzY3JpcHRvcigpLGEpfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5nZXRDdXJyZW50UmV2aXNpb25JZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldERlc2NyaXB0b3JSZXZpc2lvbklkKHRoaXMuZ2V0RGVzY3JpcHRvcigpKX07RHJhd2lvRmlsZS5wcm90b3R5cGUuc2V0Q3VycmVudEV0YWc9ZnVuY3Rpb24oYSl7dGhpcy5zZXREZXNjcmlwdG9yRXRhZyh0aGlzLmdldERlc2NyaXB0b3IoKSxhKX07RHJhd2lvRmlsZS5wcm90b3R5cGUuZ2V0Q3VycmVudEV0YWc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXREZXNjcmlwdG9yRXRhZyh0aGlzLmdldERlc2NyaXB0b3IoKSl9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5nZXREZXNjcmlwdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O0RyYXdpb0ZpbGUucHJvdG90eXBlLnNldERlc2NyaXB0b3I9ZnVuY3Rpb24oKXt9O0RyYXdpb0ZpbGUucHJvdG90eXBlLnNldERlc2NyaXB0b3JSZXZpc2lvbklkPWZ1bmN0aW9uKGEsYyl7dGhpcy5zZXREZXNjcmlwdG9yRXRhZyhhLGMpfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5nZXREZXNjcmlwdG9yUmV2aXNpb25JZD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5nZXREZXNjcmlwdG9yRXRhZyhhKX07RHJhd2lvRmlsZS5wcm90b3R5cGUuc2V0RGVzY3JpcHRvckV0YWc9ZnVuY3Rpb24oYSxjKXt9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmdldERlc2NyaXB0b3JFdGFnPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5nZXREZXNjcmlwdG9yU2VjcmV0PWZ1bmN0aW9uKGEpe3JldHVybiBudWxsfTsKRHJhd2lvRmlsZS5wcm90b3R5cGUuaW5zdGFsbExpc3RlbmVycz1mdW5jdGlvbigpe251bGw9PXRoaXMuY2hhbmdlTGlzdGVuZXImJih0aGlzLmNoYW5nZUxpc3RlbmVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7dmFyIGY9bnVsbCE9Yz9jLmdldFByb3BlcnR5KCJlZGl0Iik6bnVsbDshdGhpcy5jaGFuZ2VMaXN0ZW5lckVuYWJsZWR8fCF0aGlzLmlzRWRpdGFibGUoKXx8bnVsbCE9ZiYmZi5pZ25vcmVFZGl0fHx0aGlzLmZpbGVDaGFuZ2VkKCl9KSx0aGlzLnVpLmVkaXRvci5ncmFwaC5tb2RlbC5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSx0aGlzLmNoYW5nZUxpc3RlbmVyKSx0aGlzLnVpLmVkaXRvci5ncmFwaC5hZGRMaXN0ZW5lcigiZ3JpZFNpemVDaGFuZ2VkIix0aGlzLmNoYW5nZUxpc3RlbmVyKSx0aGlzLnVpLmVkaXRvci5ncmFwaC5hZGRMaXN0ZW5lcigic2hhZG93VmlzaWJsZUNoYW5nZWQiLHRoaXMuY2hhbmdlTGlzdGVuZXIpLHRoaXMudWkuYWRkTGlzdGVuZXIoInBhZ2VGb3JtYXRDaGFuZ2VkIiwKdGhpcy5jaGFuZ2VMaXN0ZW5lciksdGhpcy51aS5hZGRMaXN0ZW5lcigicGFnZVNjYWxlQ2hhbmdlZCIsdGhpcy5jaGFuZ2VMaXN0ZW5lciksdGhpcy51aS5hZGRMaXN0ZW5lcigiYmFja2dyb3VuZENvbG9yQ2hhbmdlZCIsdGhpcy5jaGFuZ2VMaXN0ZW5lciksdGhpcy51aS5hZGRMaXN0ZW5lcigiYmFja2dyb3VuZEltYWdlQ2hhbmdlZCIsdGhpcy5jaGFuZ2VMaXN0ZW5lciksdGhpcy51aS5hZGRMaXN0ZW5lcigiZm9sZGluZ0VuYWJsZWRDaGFuZ2VkIix0aGlzLmNoYW5nZUxpc3RlbmVyKSx0aGlzLnVpLmFkZExpc3RlbmVyKCJtYXRoRW5hYmxlZENoYW5nZWQiLHRoaXMuY2hhbmdlTGlzdGVuZXIpLHRoaXMudWkuYWRkTGlzdGVuZXIoImdyaWRFbmFibGVkQ2hhbmdlZCIsdGhpcy5jaGFuZ2VMaXN0ZW5lciksdGhpcy51aS5hZGRMaXN0ZW5lcigiZ3VpZGVzRW5hYmxlZENoYW5nZWQiLHRoaXMuY2hhbmdlTGlzdGVuZXIpLHRoaXMudWkuYWRkTGlzdGVuZXIoInBhZ2VWaWV3Q2hhbmdlZCIsCnRoaXMuY2hhbmdlTGlzdGVuZXIpLHRoaXMudWkuYWRkTGlzdGVuZXIoImNvbm5lY3Rpb25Qb2ludHNDaGFuZ2VkIix0aGlzLmNoYW5nZUxpc3RlbmVyKSx0aGlzLnVpLmFkZExpc3RlbmVyKCJjb25uZWN0aW9uQXJyb3dzQ2hhbmdlZCIsdGhpcy5jaGFuZ2VMaXN0ZW5lcikpfTsKRHJhd2lvRmlsZS5wcm90b3R5cGUuYWRkQWxsU2F2ZWRTdGF0dXM9ZnVuY3Rpb24oYSl7bnVsbCE9dGhpcy51aS5zdGF0dXNDb250YWluZXImJnRoaXMudWkuZ2V0Q3VycmVudEZpbGUoKT09dGhpcyYmKGE9bnVsbCE9YT9hOm14VXRpbHMuaHRtbEVudGl0aWVzKG14UmVzb3VyY2VzLmdldCh0aGlzLmFsbENoYW5nZXNTYXZlZEtleSkpLHRoaXMudWkuZWRpdG9yLnNldFN0YXR1cygnPGRpdiB0aXRsZT0iJythKyciPicrYSsiPC9kaXY+IiksYT10aGlzLnVpLnN0YXR1c0NvbnRhaW5lci5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGl2IiksMDxhLmxlbmd0aCYmdGhpcy5pc1JldmlzaW9uSGlzdG9yeVN1cHBvcnRlZCgpJiYoYVswXS5zdHlsZS5jdXJzb3I9InBvaW50ZXIiLGFbMF0uc3R5bGUudGV4dERlY29yYXRpb249InVuZGVybGluZSIsbXhFdmVudC5hZGRMaXN0ZW5lcihhWzBdLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnVpLmFjdGlvbnMuZ2V0KCJyZXZpc2lvbkhpc3RvcnkiKS5mdW5jdCgpfSkpKSl9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5zYXZlRHJhZnQ9ZnVuY3Rpb24oKXt0cnl7bnVsbD09dGhpcy5kcmFmdElkJiYodGhpcy5kcmFmdElkPUVkaXRvci5ndWlkKCkpO3ZhciBhPXt0eXBlOiJkcmFmdCIsY3JlYXRlZDp0aGlzLmNyZWF0ZWQsbW9kaWZpZWQ6KG5ldyBEYXRlKS5nZXRUaW1lKCksZGF0YTp0aGlzLnVpLmdldEZpbGVEYXRhKCksdGl0bGU6dGhpcy5nZXRUaXRsZSgpLGFsaXZlQ2hlY2s6dGhpcy51aS5kcmFmdEFsaXZlQ2hlY2t9O3RoaXMudWkuc2V0RGF0YWJhc2VJdGVtKCIuZHJhZnRfIit0aGlzLmRyYWZ0SWQsSlNPTi5zdHJpbmdpZnkoYSkpO0VkaXRvclVpLmRlYnVnKCJkcmFmdCBzYXZlZCIsdGhpcy5kcmFmdElkLGEpfWNhdGNoKGMpe2NvbnNvbGUuZXJyb3IoYyksdGhpcy5yZW1vdmVEcmFmdCgpfX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLnJlbW92ZURyYWZ0PWZ1bmN0aW9uKCl7dHJ5e251bGwhPXRoaXMuZHJhZnRJZCYmKHRoaXMudWkucmVtb3ZlRGF0YWJhc2VJdGVtKCIuZHJhZnRfIit0aGlzLmRyYWZ0SWQpLEVkaXRvclVpLmRlYnVnKCJkcmFmdCBkZWxldGVkIiwiLmRyYWZ0XyIrdGhpcy5kcmFmdElkKSl9Y2F0Y2goYSl7fX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLmFkZFVuc2F2ZWRTdGF0dXM9ZnVuY3Rpb24oYSl7aWYoIXRoaXMuaW5Db25mbGljdFN0YXRlJiZudWxsIT10aGlzLnVpLnN0YXR1c0NvbnRhaW5lciYmdGhpcy51aS5nZXRDdXJyZW50RmlsZSgpPT10aGlzKWlmKGEgaW5zdGFuY2VvZiBFcnJvciYmbnVsbCE9YS5tZXNzYWdlJiYiIiE9YS5tZXNzYWdlKXt2YXIgYz1teFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQoInVuc2F2ZWRDaGFuZ2VzIikpO3RoaXMudWkuZWRpdG9yLnNldFN0YXR1cygnPGRpdiB0aXRsZT0iJytjKyciIGNsYXNzPSJnZVN0YXR1c0FsZXJ0IiBzdHlsZT0ib3ZlcmZsb3c6aGlkZGVuOyI+JytjKyIgKCIrbXhVdGlscy5odG1sRW50aXRpZXMoYS5tZXNzYWdlKSsiKTwvZGl2PiIpfWVsc2V7Yz10aGlzLmdldEVycm9yTWVzc2FnZShhKTtpZihudWxsPT1jJiZudWxsIT10aGlzLmxhc3RTYXZlZCl7dmFyIGY9dGhpcy51aS50aW1lU2luY2UobmV3IERhdGUodGhpcy5sYXN0U2F2ZWQpKTsKbnVsbCE9ZiYmKGM9bXhSZXNvdXJjZXMuZ2V0KCJsYXN0U2F2ZWQiLFtmXSkpfW51bGwhPWMmJjYwPGMubGVuZ3RoJiYoYz1jLnN1YnN0cmluZygwLDYwKSsiLi4uIik7Yz1teFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQoInVuc2F2ZWRDaGFuZ2VzQ2xpY2tIZXJlVG9TYXZlIikpKyhudWxsIT1jJiYiIiE9Yz8iICgiK214VXRpbHMuaHRtbEVudGl0aWVzKGMpKyIpIjoiIik7dGhpcy51aS5lZGl0b3Iuc2V0U3RhdHVzKCc8ZGl2IHRpdGxlPSInK2MrJyIgY2xhc3M9ImdlU3RhdHVzQWxlcnQiIHN0eWxlPSJjdXJzb3I6cG9pbnRlcjtvdmVyZmxvdzpoaWRkZW47Ij4nK2MrIjwvZGl2PiIpO2M9dGhpcy51aS5zdGF0dXNDb250YWluZXIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpO251bGwhPWMmJjA8Yy5sZW5ndGg/bXhFdmVudC5hZGRMaXN0ZW5lcihjWzBdLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnVpLmFjdGlvbnMuZ2V0KG51bGwhPQp0aGlzLnVpLm1vZGUmJnRoaXMuaXNFZGl0YWJsZSgpPyJzYXZlIjoic2F2ZUFzIikuZnVuY3QoKX0pKTooYz1teFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQoInVuc2F2ZWRDaGFuZ2VzIikpLHRoaXMudWkuZWRpdG9yLnNldFN0YXR1cygnPGRpdiB0aXRsZT0iJytjKyciIGNsYXNzPSJnZVN0YXR1c0FsZXJ0IiBzdHlsZT0ib3ZlcmZsb3c6aGlkZGVuOyI+JytjKyIgKCIrbXhVdGlscy5odG1sRW50aXRpZXMoYS5tZXNzYWdlKSsiKTwvZGl2PiIpKTtFZGl0b3JVaS5lbmFibGVEcmFmdHMmJm51bGw9PXRoaXMuZ2V0TW9kZSgpJiYobnVsbCE9dGhpcy5zYXZlRHJhZnRUaHJlYWQmJndpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5zYXZlRHJhZnRUaHJlYWQpLHRoaXMuc2F2ZURyYWZ0VGhyZWFkPXdpbmRvdy5zZXRUaW1lb3V0KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5zYXZlRHJhZnQoKX0pLDApKX19OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5hZGRDb25mbGljdFN0YXR1cz1mdW5jdGlvbihhLGMpe3RoaXMuaW52YWxpZENoZWNrc3VtJiZudWxsPT1jJiYoYz1teFJlc291cmNlcy5nZXQoImNoZWNrc3VtIikpO3RoaXMuc2V0Q29uZmxpY3RTdGF0dXMobXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KCJmaWxlQ2hhbmdlZFN5bmMiKSkrKG51bGwhPWMmJiIiIT1jPyIgKCIrbXhVdGlscy5odG1sRW50aXRpZXMoYykrIikiOiIiKSk7dGhpcy51aS5zcGlubmVyLnN0b3AoKTt0aGlzLmNsZWFyQXV0b3NhdmUoKTt2YXIgZj1udWxsIT10aGlzLnVpLnN0YXR1c0NvbnRhaW5lcj90aGlzLnVpLnN0YXR1c0NvbnRhaW5lci5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGl2Iik6bnVsbDtudWxsIT1mJiYwPGYubGVuZ3RoP214RXZlbnQuYWRkTGlzdGVuZXIoZlswXSwiY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGMpeyJJTUciIT1teEV2ZW50LmdldFNvdXJjZShjKS5ub2RlTmFtZSYmCmEoKX0pKTp0aGlzLnVpLmFsZXJ0KG14VXRpbHMuaHRtbEVudGl0aWVzKG14UmVzb3VyY2VzLmdldCgiZmlsZUNoYW5nZWRTeW5jIikpLGEpfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5zZXRDb25mbGljdFN0YXR1cz1mdW5jdGlvbihhKXt0aGlzLnVpLmVkaXRvci5zZXRTdGF0dXMoJzxkaXYgdGl0bGU9IicrYSsnIiBjbGFzcz0iZ2VTdGF0dXNBbGVydCBnZUJsaW5rIiBzdHlsZT0iY3Vyc29yOnBvaW50ZXI7b3ZlcmZsb3c6aGlkZGVuOyI+JythKycgPGEgaHJlZj0iaHR0cHM6Ly9kZXNrLmRyYXcuaW8vc3VwcG9ydC9zb2x1dGlvbnMvYXJ0aWNsZXMvMTYwMDAwODc5NDciIHRhcmdldD0iX2JsYW5rIj48aW1nIGJvcmRlcj0iMCIgc3R5bGU9Im1hcmdpbi1sZWZ0OjJweDtjdXJzb3I6aGVscDtvcGFjaXR5OjAuNTt3aWR0aDoxNnB4O2hlaWdodDoxNnB4OyIgdmFsaWduPSJib3R0b20iIHNyYz0iJytFZGl0b3IuaGVscEltYWdlKyciIHN0eWxlPSIiLz48L2E+PC9kaXY+Jyl9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5zaG93UmVmcmVzaERpYWxvZz1mdW5jdGlvbihhLGMsZil7bnVsbD09ZiYmKGY9bXhSZXNvdXJjZXMuZ2V0KCJjaGVja3N1bSIpKTt0aGlzLnVpLmVkaXRvci5pc0Nocm9tZWxlc3NWaWV3KCkmJiF0aGlzLnVpLmVkaXRvci5lZGl0YWJsZT90aGlzLnVpLmFsZXJ0KG14UmVzb3VyY2VzLmdldCgiZmlsZUNoYW5nZWRTeW5jIiksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnJlbG9hZEZpbGUoYSxjKX0pKToodGhpcy5hZGRDb25mbGljdFN0YXR1cyhteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuc2hvd1JlZnJlc2hEaWFsb2coYSxjKX0pLGYpLHRoaXMudWkuc2hvd0Vycm9yKG14UmVzb3VyY2VzLmdldCgiZXJyb3IiKSsiICgiK2YrIikiLG14UmVzb3VyY2VzLmdldCgiZmlsZUNoYW5nZWRTeW5jRGlhbG9nIiksbXhSZXNvdXJjZXMuZ2V0KCJtYWtlQ29weSIpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5jb3B5RmlsZShhLApjKX0pLG51bGwsbXhSZXNvdXJjZXMuZ2V0KCJzeW5jaHJvbml6ZSIpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5yZWxvYWRGaWxlKGEsYyl9KSxteFJlc291cmNlcy5nZXQoImNhbmNlbCIpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy51aS5oaWRlRGlhbG9nKCl9KSwzNjAsMTUwKSl9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5zaG93Q29weURpYWxvZz1mdW5jdGlvbihhLGMsZil7dGhpcy5pbnZhbGlkQ2hlY2tzdW09dGhpcy5pbkNvbmZsaWN0U3RhdGU9ITE7dGhpcy5hZGRVbnNhdmVkU3RhdHVzKCk7dGhpcy51aS5zaG93RXJyb3IobXhSZXNvdXJjZXMuZ2V0KCJleHRlcm5hbENoYW5nZXMiKSxteFJlc291cmNlcy5nZXQoImZpbGVDaGFuZ2VkT3ZlcndyaXRlRGlhbG9nIiksbXhSZXNvdXJjZXMuZ2V0KCJtYWtlQ29weSIpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5jb3B5RmlsZShhLGMpfSksbnVsbCxteFJlc291cmNlcy5nZXQoIm92ZXJ3cml0ZSIpLGYsbXhSZXNvdXJjZXMuZ2V0KCJjYW5jZWwiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMudWkuaGlkZURpYWxvZygpfSksMzYwLDE1MCl9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5zaG93Q29uZmxpY3REaWFsb2c9ZnVuY3Rpb24oYSxjKXt0aGlzLnVpLnNob3dFcnJvcihteFJlc291cmNlcy5nZXQoImV4dGVybmFsQ2hhbmdlcyIpLG14UmVzb3VyY2VzLmdldCgiZmlsZUNoYW5nZWRTeW5jRGlhbG9nIiksbXhSZXNvdXJjZXMuZ2V0KCJvdmVyd3JpdGUiKSxhLG51bGwsbXhSZXNvdXJjZXMuZ2V0KCJzeW5jaHJvbml6ZSIpLGMsbXhSZXNvdXJjZXMuZ2V0KCJjYW5jZWwiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMudWkuaGlkZURpYWxvZygpO3RoaXMuaGFuZGxlRmlsZUVycm9yKG51bGwsITEpfSksMzQwLDE1MCl9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5yZWRpcmVjdFRvTmV3QXBwPWZ1bmN0aW9uKGEsYyl7dGhpcy51aS5zcGlubmVyLnN0b3AoKTtpZighdGhpcy5yZWRpcmVjdERpYWxvZ1Nob3dpbmcpe3RoaXMucmVkaXJlY3REaWFsb2dTaG93aW5nPSEwO3ZhciBmPXdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCsiLy8iK3dpbmRvdy5sb2NhdGlvbi5ob3N0KyIvIit0aGlzLnVpLmdldFNlYXJjaCgiY3JlYXRlIHRpdGxlIG1vZGUgdXJsIGRyaXZlIHNwbGFzaCBzdGF0ZSIuc3BsaXQoIiAiKSkrIiMiK3RoaXMuZ2V0SGFzaCgpLGQ9bXhSZXNvdXJjZXMuZ2V0KCJyZWRpcmVjdFRvTmV3QXBwIik7bnVsbCE9YyYmKGQrPSIgKCIrYysiKSIpO3ZhciBtPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGM9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnJlZGlyZWN0RGlhbG9nU2hvd2luZz0hMTt3aW5kb3cubG9jYXRpb24uaHJlZj09Zj93aW5kb3cubG9jYXRpb24ucmVsb2FkKCk6CndpbmRvdy5sb2NhdGlvbi5ocmVmPWZ9KTtudWxsPT1hJiZ0aGlzLmlzTW9kaWZpZWQoKT90aGlzLnVpLmNvbmZpcm0obXhSZXNvdXJjZXMuZ2V0KCJhbGxDaGFuZ2VzTG9zdCIpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5yZWRpcmVjdERpYWxvZ1Nob3dpbmc9ITF9KSxjLG14UmVzb3VyY2VzLmdldCgiY2FuY2VsIiksbXhSZXNvdXJjZXMuZ2V0KCJkaXNjYXJkQ2hhbmdlcyIpKTpjKCl9KTtudWxsIT1hP3RoaXMuaXNNb2RpZmllZCgpP3RoaXMudWkuY29uZmlybShkLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5yZWRpcmVjdERpYWxvZ1Nob3dpbmc9ITE7YSgpfSksbSxteFJlc291cmNlcy5nZXQoImNhbmNlbCIpLG14UmVzb3VyY2VzLmdldCgiZGlzY2FyZENoYW5nZXMiKSk6dGhpcy51aS5jb25maXJtKGQsbSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMucmVkaXJlY3REaWFsb2dTaG93aW5nPSExO2EoKX0pKTp0aGlzLnVpLmFsZXJ0KG14UmVzb3VyY2VzLmdldCgicmVkaXJlY3RUb05ld0FwcCIpLAptKX19O0RyYXdpb0ZpbGUucHJvdG90eXBlLmhhbmRsZUZpbGVTdWNjZXNzPWZ1bmN0aW9uKGEpe3RoaXMudWkuc3Bpbm5lci5zdG9wKCk7dGhpcy51aS5nZXRDdXJyZW50RmlsZSgpPT10aGlzJiYodGhpcy5pc01vZGlmaWVkKCk/dGhpcy5maWxlQ2hhbmdlZCgpOmE/KHRoaXMuaXNUcmFzaGVkKCk/dGhpcy5hZGRBbGxTYXZlZFN0YXR1cyhteFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQodGhpcy5hbGxDaGFuZ2VzU2F2ZWRLZXkpKSsiICgiK214VXRpbHMuaHRtbEVudGl0aWVzKG14UmVzb3VyY2VzLmdldCgiZmlsZU1vdmVkVG9UcmFzaCIpKSsiKSIpOnRoaXMuYWRkQWxsU2F2ZWRTdGF0dXMoKSxudWxsIT10aGlzLnN5bmMmJih0aGlzLnN5bmMucmVzZXRVcGRhdGVTdGF0dXNUaHJlYWQoKSx0aGlzLnN5bmMucmVtb3RlRmlsZUNoYW5nZWQmJih0aGlzLnN5bmMucmVtb3RlRmlsZUNoYW5nZWQ9ITEsdGhpcy5zeW5jLmZpbGVDaGFuZ2VkTm90aWZ5KCkpKSk6dGhpcy51aS5lZGl0b3Iuc2V0U3RhdHVzKCIiKSl9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5oYW5kbGVGaWxlRXJyb3I9ZnVuY3Rpb24oYSxjKXt0aGlzLnVpLnNwaW5uZXIuc3RvcCgpO2lmKHRoaXMudWkuZ2V0Q3VycmVudEZpbGUoKT09dGhpcylpZih0aGlzLmluQ29uZmxpY3RTdGF0ZSl0aGlzLmhhbmRsZUNvbmZsaWN0RXJyb3IoYSxjKTtlbHNlIGlmKHRoaXMuaXNNb2RpZmllZCgpJiZ0aGlzLmFkZFVuc2F2ZWRTdGF0dXMoYSksYyl0aGlzLnVpLmhhbmRsZUVycm9yKGEsbnVsbCE9YT9teFJlc291cmNlcy5nZXQoImVycm9yU2F2aW5nRmlsZSIpOm51bGwpO2Vsc2UgaWYoIXRoaXMuaXNNb2RpZmllZCgpKXt2YXIgZj10aGlzLmdldEVycm9yTWVzc2FnZShhKTtudWxsIT1mJiY2MDxmLmxlbmd0aCYmKGY9Zi5zdWJzdHJpbmcoMCw2MCkrIi4uLiIpO3RoaXMudWkuZWRpdG9yLnNldFN0YXR1cygnPGRpdiBjbGFzcz0iZ2VTdGF0dXNBbGVydCIgc3R5bGU9ImN1cnNvcjpwb2ludGVyO292ZXJmbG93OmhpZGRlbjsiPicrbXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KCJlcnJvciIpKSsKKG51bGwhPWY/IiAoIitteFV0aWxzLmh0bWxFbnRpdGllcyhmKSsiKSI6IiIpKyI8L2Rpdj4iKX19OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5oYW5kbGVDb25mbGljdEVycm9yPWZ1bmN0aW9uKGEsYyl7dmFyIGY9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmhhbmRsZUZpbGVTdWNjZXNzKCEwKX0pLGQ9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5oYW5kbGVGaWxlRXJyb3IoYSwhMCl9KSxtPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy51aS5zcGlubmVyLnNwaW4oZG9jdW1lbnQuYm9keSxteFJlc291cmNlcy5nZXQoInNhdmluZyIpKSYmKHRoaXMudWkuZWRpdG9yLnNldFN0YXR1cygiIiksdGhpcy5zYXZlKCEwLGYsZCxudWxsLCEwLHRoaXMuY29uc3RydWN0b3IhPUdpdEh1YkZpbGUmJnRoaXMuY29uc3RydWN0b3IhPUdpdExhYkZpbGV8fG51bGw9PWE/bnVsbDphLmNvbW1pdE1lc3NhZ2UpKX0pLGs9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnVpLnNwaW5uZXIuc3Bpbihkb2N1bWVudC5ib2R5LG14UmVzb3VyY2VzLmdldCgidXBkYXRpbmdEb2N1bWVudCIpKSYmCnRoaXMuc3luY2hyb25pemVGaWxlKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy51aS5zcGlubmVyLnN0b3AoKTt0aGlzLnVpLnNwaW5uZXIuc3Bpbihkb2N1bWVudC5ib2R5LG14UmVzb3VyY2VzLmdldCgic2F2aW5nIikpJiZ0aGlzLnNhdmUoITAsZixkLG51bGwsbnVsbCx0aGlzLmNvbnN0cnVjdG9yIT1HaXRIdWJGaWxlJiZ0aGlzLmNvbnN0cnVjdG9yIT1HaXRMYWJGaWxlfHxudWxsPT1hP251bGw6YS5jb21taXRNZXNzYWdlKX0pLGQpfSk7Im5vbmUiPT1EcmF3aW9GaWxlLlNZTkM/dGhpcy5zaG93Q29weURpYWxvZyhmLGQsbSk6dGhpcy5pbnZhbGlkQ2hlY2tzdW0/dGhpcy5zaG93UmVmcmVzaERpYWxvZyhmLGQsdGhpcy5nZXRFcnJvck1lc3NhZ2UoYSkpOmM/dGhpcy5zaG93Q29uZmxpY3REaWFsb2cobSxrKTp0aGlzLmFkZENvbmZsaWN0U3RhdHVzKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy51aS5lZGl0b3Iuc2V0U3RhdHVzKG14VXRpbHMuaHRtbEVudGl0aWVzKG14UmVzb3VyY2VzLmdldCgidXBkYXRpbmdEb2N1bWVudCIpKSk7CnRoaXMuc3luY2hyb25pemVGaWxlKGYsZCl9KSx0aGlzLmdldEVycm9yTWVzc2FnZShhKSl9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmdldEVycm9yTWVzc2FnZT1mdW5jdGlvbihhKXt2YXIgYz1udWxsIT1hP251bGwhPWEuZXJyb3I/YS5lcnJvci5tZXNzYWdlOmEubWVzc2FnZTpudWxsO251bGw9PWMmJm51bGwhPWEmJmEuY29kZT09QXBwLkVSUk9SX1RJTUVPVVQmJihjPW14UmVzb3VyY2VzLmdldCgidGltZW91dCIpKTtyZXR1cm4gY307RHJhd2lvRmlsZS5wcm90b3R5cGUuaXNPdmVyZHVlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuYWdlU3RhcnQmJkRhdGUubm93KCktdGhpcy5hZ2VTdGFydC5nZXRUaW1lKCk+PXRoaXMudWkud2FybkludGVydmFsfTsKRHJhd2lvRmlsZS5wcm90b3R5cGUuZmlsZUNoYW5nZWQ9ZnVuY3Rpb24oKXt0aGlzLmxhc3RDaGFuZ2VkPW5ldyBEYXRlO3RoaXMuc2V0TW9kaWZpZWQoITApO3RoaXMuaXNBdXRvc2F2ZSgpPyh0aGlzLmFkZEFsbFNhdmVkU3RhdHVzKG14VXRpbHMuaHRtbEVudGl0aWVzKG14UmVzb3VyY2VzLmdldCgic2F2aW5nIikpKyIuLi4iKSx0aGlzLnVpLnNjaGVkdWxlU2FuaXR5Q2hlY2soKSxudWxsPT10aGlzLmFnZVN0YXJ0JiYodGhpcy5hZ2VTdGFydD1uZXcgRGF0ZSksdGhpcy5hdXRvc2F2ZSh0aGlzLmF1dG9zYXZlRGVsYXksdGhpcy5tYXhBdXRvc2F2ZURlbGF5LG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMudWkuc3RvcFNhbml0eUNoZWNrKCk7bnVsbD09dGhpcy5hdXRvc2F2ZVRocmVhZD8odGhpcy5oYW5kbGVGaWxlU3VjY2VzcyghMCksdGhpcy5hZ2VTdGFydD1udWxsKTp0aGlzLmlzTW9kaWZpZWQoKSYmKHRoaXMudWkuc2NoZWR1bGVTYW5pdHlDaGVjaygpLHRoaXMuYWdlU3RhcnQ9CnRoaXMubGFzdENoYW5nZWQpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5oYW5kbGVGaWxlRXJyb3IoYSl9KSkpOih0aGlzLmFnZVN0YXJ0PW51bGwsdGhpcy5pc0F1dG9zYXZlT3B0aW9uYWwoKSYmdGhpcy51aS5lZGl0b3IuYXV0b3NhdmV8fHRoaXMuaW5Db25mbGljdFN0YXRlfHx0aGlzLmFkZFVuc2F2ZWRTdGF0dXMoKSl9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmNyZWF0ZVNlY3JldD1mdW5jdGlvbihhLGMpe3ZhciBmPUVkaXRvci5ndWlkKDMyKTtudWxsIT10aGlzLnN5bmM/dGhpcy5zeW5jLmNyZWF0ZVRva2VuKGYsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYyl7YShmLGMpfSksYyk6YShmKX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLmZpbGVTYXZlZD1mdW5jdGlvbihhLGMsZixkLG0pe3RoaXMubGFzdFNhdmVkPW5ldyBEYXRlO3RoaXMuYWdlU3RhcnQ9bnVsbDt0cnl7dGhpcy5zdGF0cy5zYXZlZCsrLHRoaXMuaW52YWxpZENoZWNrc3VtPXRoaXMuaW5Db25mbGljdFN0YXRlPSExLG51bGw9PXRoaXMuc3luYz8odGhpcy5zaGFkb3dEYXRhPWEsdGhpcy5zaGFkb3dQYWdlcz1udWxsLG51bGwhPWYmJmYoKSk6dGhpcy5zeW5jLmZpbGVTYXZlZCh0aGlzLnVpLmdldFBhZ2VzRm9yTm9kZShteFV0aWxzLnBhcnNlWG1sKGEpLmRvY3VtZW50RWxlbWVudCksYyxmLGQsbSl9Y2F0Y2goYil7dGhpcy5pbnZhbGlkQ2hlY2tzdW09dGhpcy5pbkNvbmZsaWN0U3RhdGU9ITA7dGhpcy5kZXNjcmlwdG9yQ2hhbmdlZCgpO251bGwhPWQmJmQoYik7dHJ5e2lmKHRoaXMuZXJyb3JSZXBvcnRzRW5hYmxlZCl0aGlzLnNlbmRFcnJvclJlcG9ydCgiRXJyb3IgaW4gZmlsZVNhdmVkIixudWxsLGIpO2Vsc2V7dmFyIGs9CnRoaXMuZ2V0Q3VycmVudFVzZXIoKSxxPW51bGwhPWs/ay5pZDoidW5rbm93biI7RWRpdG9yVWkubG9nRXJyb3IoIkVycm9yIGluIGZpbGVTYXZlZCIsbnVsbCx0aGlzLmdldE1vZGUoKSsiLiIrdGhpcy5nZXRJZCgpLHEsYil9fWNhdGNoKGUpe319fTsKRHJhd2lvRmlsZS5wcm90b3R5cGUuYXV0b3NhdmU9ZnVuY3Rpb24oYSxjLGYsZCl7bnVsbD09dGhpcy5sYXN0QXV0b3NhdmUmJih0aGlzLmxhc3RBdXRvc2F2ZT1EYXRlLm5vdygpKTthPURhdGUubm93KCktdGhpcy5sYXN0QXV0b3NhdmU8Yz9hOjA7dGhpcy5jbGVhckF1dG9zYXZlKCk7dmFyIG09d2luZG93LnNldFRpbWVvdXQobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmxhc3RBdXRvc2F2ZT1udWxsO3RoaXMuYXV0b3NhdmVUaHJlYWQ9PW0mJih0aGlzLmF1dG9zYXZlVGhyZWFkPW51bGwpO2lmKHRoaXMuaXNNb2RpZmllZCgpJiZ0aGlzLmlzQXV0b3NhdmVOb3coKSl7dmFyIGE9dGhpcy5pc0F1dG9zYXZlUmV2aXNpb24oKTthJiYodGhpcy5sYXN0QXV0b3NhdmVSZXZpc2lvbj0obmV3IERhdGUpLmdldFRpbWUoKSk7dGhpcy5zYXZlKGEsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5hdXRvc2F2ZUNvbXBsZXRlZCgpO251bGwhPWYmJmYoYSl9KSxteFV0aWxzLmJpbmQodGhpcywKZnVuY3Rpb24oYSl7bnVsbCE9ZCYmZChhKX0pKX1lbHNlIHRoaXMuaXNNb2RpZmllZCgpfHx0aGlzLnVpLmVkaXRvci5zZXRTdGF0dXMoIiIpLG51bGwhPWYmJmYobnVsbCl9KSxhKTt0aGlzLmF1dG9zYXZlVGhyZWFkPW19O0RyYXdpb0ZpbGUucHJvdG90eXBlLmlzQXV0b3NhdmVOb3c9ZnVuY3Rpb24oKXtyZXR1cm4hMH07RHJhd2lvRmlsZS5wcm90b3R5cGUuYXV0b3NhdmVDb21wbGV0ZWQ9ZnVuY3Rpb24oKXt9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmNsZWFyQXV0b3NhdmU9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmF1dG9zYXZlVGhyZWFkJiYod2luZG93LmNsZWFyVGltZW91dCh0aGlzLmF1dG9zYXZlVGhyZWFkKSx0aGlzLmF1dG9zYXZlVGhyZWFkPW51bGwpfTsKRHJhd2lvRmlsZS5wcm90b3R5cGUuaXNBdXRvc2F2ZVJldmlzaW9uPWZ1bmN0aW9uKCl7dmFyIGE9KG5ldyBEYXRlKS5nZXRUaW1lKCk7cmV0dXJuIG51bGw9PXRoaXMubGFzdEF1dG9zYXZlUmV2aXNpb258fGEtdGhpcy5sYXN0QXV0b3NhdmVSZXZpc2lvbj50aGlzLm1heEF1dG9zYXZlUmV2aXNpb25EZWxheX07RHJhd2lvRmlsZS5wcm90b3R5cGUuZGVzY3JpcHRvckNoYW5nZWQ9ZnVuY3Rpb24oKXt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgiZGVzY3JpcHRvckNoYW5nZWQiKSl9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmNvbnRlbnRDaGFuZ2VkPWZ1bmN0aW9uKCl7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImNvbnRlbnRDaGFuZ2VkIikpfTsKRHJhd2lvRmlsZS5wcm90b3R5cGUuY2xvc2U9ZnVuY3Rpb24oYSl7dGhpcy51cGRhdGVGaWxlRGF0YSgpO3RoaXMuc3RhdHMuY2xvc2VkKys7dGhpcy5pc0F1dG9zYXZlKCkmJnRoaXMuaXNNb2RpZmllZCgpJiZ0aGlzLnNhdmUodGhpcy5pc0F1dG9zYXZlUmV2aXNpb24oKSxudWxsLG51bGwsYSk7dGhpcy5kZXN0cm95KCl9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmhhc1NhbWVFeHRlbnNpb249ZnVuY3Rpb24oYSxjKXtpZihudWxsIT1hJiZudWxsIT1jKXt2YXIgZj1hLmxhc3RJbmRleE9mKCIuIiksZD0wPGY/YS5zdWJzdHJpbmcoZik6IiIsZj1jLmxhc3RJbmRleE9mKCIuIik7cmV0dXJuIGQ9PT0oMDxmP2Muc3Vic3RyaW5nKGYpOiIiKX1yZXR1cm4gYT09Y307CkRyYXdpb0ZpbGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVycz1mdW5jdGlvbigpe251bGwhPXRoaXMuY2hhbmdlTGlzdGVuZXImJih0aGlzLnVpLmVkaXRvci5ncmFwaC5tb2RlbC5yZW1vdmVMaXN0ZW5lcih0aGlzLmNoYW5nZUxpc3RlbmVyKSx0aGlzLnVpLmVkaXRvci5ncmFwaC5yZW1vdmVMaXN0ZW5lcih0aGlzLmNoYW5nZUxpc3RlbmVyKSx0aGlzLnVpLnJlbW92ZUxpc3RlbmVyKHRoaXMuY2hhbmdlTGlzdGVuZXIpLHRoaXMuY2hhbmdlTGlzdGVuZXI9bnVsbCl9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLnN0YXRzLmRlc3Ryb3llZCsrO3RoaXMuY2xlYXJBdXRvc2F2ZSgpO3RoaXMucmVtb3ZlTGlzdGVuZXJzKCk7bnVsbCE9dGhpcy5zeW5jJiYodGhpcy5zeW5jLmRlc3Ryb3koKSx0aGlzLnN5bmM9bnVsbCl9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmNvbW1lbnRzU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITF9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5jb21tZW50c1JlZnJlc2hOZWVkZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH07RHJhd2lvRmlsZS5wcm90b3R5cGUuY29tbWVudHNTYXZlTmVlZGVkPWZ1bmN0aW9uKCl7cmV0dXJuITF9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmdldENvbW1lbnRzPWZ1bmN0aW9uKGEsYyl7YShbXSl9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmFkZENvbW1lbnQ9ZnVuY3Rpb24oYSxjLGYpe2MoRGF0ZS5ub3coKSl9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmNhblJlcGx5VG9SZXBsaWVzPWZ1bmN0aW9uKCl7cmV0dXJuITB9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmNhbkNvbW1lbnQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH07RHJhd2lvRmlsZS5wcm90b3R5cGUubmV3Q29tbWVudD1mdW5jdGlvbihhLGMpe3JldHVybiBuZXcgRHJhd2lvQ29tbWVudCh0aGlzLG51bGwsYSxEYXRlLm5vdygpLERhdGUubm93KCksITEsYyl9O0xvY2FsRmlsZT1mdW5jdGlvbihhLGMsZixkKXtEcmF3aW9GaWxlLmNhbGwodGhpcyxhLGMpO3RoaXMudGl0bGU9Zjt0aGlzLm1vZGU9ZD9udWxsOkFwcC5NT0RFX0RFVklDRX07bXhVdGlscy5leHRlbmQoTG9jYWxGaWxlLERyYXdpb0ZpbGUpO0xvY2FsRmlsZS5wcm90b3R5cGUuaXNBdXRvc2F2ZT1mdW5jdGlvbigpe3JldHVybiExfTtMb2NhbEZpbGUucHJvdG90eXBlLmdldE1vZGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tb2RlfTtMb2NhbEZpbGUucHJvdG90eXBlLmdldFRpdGxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGl0bGV9O0xvY2FsRmlsZS5wcm90b3R5cGUuaXNSZW5hbWFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH07TG9jYWxGaWxlLnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKGEsYyxmKXt0aGlzLnNhdmVBcyh0aGlzLnRpdGxlLGMsZil9O0xvY2FsRmlsZS5wcm90b3R5cGUuc2F2ZUFzPWZ1bmN0aW9uKGEsYyxmKXt0aGlzLnNhdmVGaWxlKGEsITEsYyxmKX07CkxvY2FsRmlsZS5wcm90b3R5cGUuc2F2ZUZpbGU9ZnVuY3Rpb24oYSxjLGYsZCl7dGhpcy50aXRsZT1hO3RoaXMudXBkYXRlRmlsZURhdGEoKTtjPXRoaXMuZ2V0RGF0YSgpO3ZhciBtPXRoaXMudWkudXNlQ2FudmFzRm9yRXhwb3J0JiYvKFwucG5nKSQvaS50ZXN0KHRoaXMuZ2V0VGl0bGUoKSksaz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihjKXtpZih0aGlzLnVpLmlzT2ZmbGluZUFwcCgpfHx0aGlzLnVpLmlzTG9jYWxGaWxlU2F2ZSgpKXRoaXMudWkuZG9TYXZlTG9jYWxGaWxlKGMsYSxtPyJpbWFnZS9wbmciOiJ0ZXh0L3htbCIsbSk7ZWxzZSBpZihjLmxlbmd0aDxNQVhfUkVRVUVTVF9TSVpFKXt2YXIgYj1hLmxhc3RJbmRleE9mKCIuIiksYj0wPGI/YS5zdWJzdHJpbmcoYisxKToieG1sIjsobmV3IG14WG1sUmVxdWVzdChTQVZFX1VSTCwiZm9ybWF0PSIrYisiJnhtbD0iK2VuY29kZVVSSUNvbXBvbmVudChjKSsiJmZpbGVuYW1lPSIrZW5jb2RlVVJJQ29tcG9uZW50KGEpKwoobT8iJmJpbmFyeT0xIjoiIikpKS5zaW11bGF0ZShkb2N1bWVudCwiX2JsYW5rIil9ZWxzZSB0aGlzLnVpLmhhbmRsZUVycm9yKHttZXNzYWdlOm14UmVzb3VyY2VzLmdldCgiZHJhd2luZ1Rvb0xhcmdlIil9LG14UmVzb3VyY2VzLmdldCgiZXJyb3IiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe214VXRpbHMucG9wdXAoYyl9KSk7dGhpcy5zZXRNb2RpZmllZCghMSk7dGhpcy5jb250ZW50Q2hhbmdlZCgpO251bGwhPWYmJmYoKX0pO20/KGM9dGhpcy51aS5nZXRQbmdGaWxlUHJvcGVydGllcyh0aGlzLnVpLmZpbGVOb2RlKSx0aGlzLnVpLmdldEVtYmVkZGVkUG5nKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2soYSl9KSxkLHRoaXMudWkuZ2V0Q3VycmVudEZpbGUoKSE9dGhpcz90aGlzLmdldERhdGEoKTpudWxsLGMuc2NhbGUsYy5ib3JkZXIpKTprKGMpfTsKTG9jYWxGaWxlLnByb3RvdHlwZS5yZW5hbWU9ZnVuY3Rpb24oYSxjLGYpe3RoaXMudGl0bGU9YTt0aGlzLmRlc2NyaXB0b3JDaGFuZ2VkKCk7bnVsbCE9YyYmYygpfTtMb2NhbEZpbGUucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24oKXt0aGlzLnVpLnNldEZpbGVEYXRhKHRoaXMuZ2V0RGF0YSgpKTt0aGlzLmluc3RhbGxMaXN0ZW5lcnMoKX07KGZ1bmN0aW9uKCl7InVuZGVmaW5lZCIhPT10eXBlb2YgaHRtbDQmJihodG1sNC5BVFRSSUJTWyJzcGFuOjpkYXRhLWx1Y2lkLWNvbnRlbnQiXT0wLGh0bWw0LkFUVFJJQlNbInNwYW46OmRhdGEtbHVjaWQtdHlwZSJdPTApO0VkaXRvci5wcm90b3R5cGUuYXBwTmFtZT0iZGlhZ3JhbXMubmV0IjtFZGl0b3IucHJvdG90eXBlLmRpYWdyYW1GaWxlVHlwZXM9W3tkZXNjcmlwdGlvbjoiZGlhZ3JhbVhtbERlc2MiLGV4dGVuc2lvbjoiZHJhd2lvIn0se2Rlc2NyaXB0aW9uOiJkaWFncmFtUG5nRGVzYyIsZXh0ZW5zaW9uOiJwbmcifSx7ZGVzY3JpcHRpb246ImRpYWdyYW1TdmdEZXNjIixleHRlbnNpb246InN2ZyJ9LHtkZXNjcmlwdGlvbjoiZGlhZ3JhbUh0bWxEZXNjIixleHRlbnNpb246Imh0bWwifSx7ZGVzY3JpcHRpb246ImRpYWdyYW1YbWxEZXNjIixleHRlbnNpb246InhtbCJ9XTtFZGl0b3IucHJvdG90eXBlLmxpYnJhcnlGaWxlVHlwZXM9W3tkZXNjcmlwdGlvbjoiTGlicmFyeSAoLmRyYXdpb2xpYiwgLnhtbCkiLApleHRlbnNpb25zOlsiZHJhd2lvbGliIiwieG1sIl19XTtFZGl0b3IucHJvdG90eXBlLmZpbGVFeHRlbnNpb25zPVt7ZXh0OiJodG1sIix0aXRsZToiZmlsZXR5cGVIdG1sIn0se2V4dDoicG5nIix0aXRsZToiZmlsZXR5cGVQbmcifSx7ZXh0OiJzdmciLHRpdGxlOiJmaWxldHlwZVN2ZyJ9XTtFZGl0b3IuY2xvc2VJbWFnZT1teENsaWVudC5JU19TVkc/ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmtBQUFBWkNBTUFBQUR6TjNWUkFBQUFwVkJNVkVVQUFBRC8vLy9rNU9ULy8vOEFBQUIxZFhYTXpNejkvZjM5L2YzNysvdjUrZm4rL3Y3Ly8vOWlZbUphV2xxRmhZV25wNmVqbzZPSGg0Zi8vLy8vLy8vLy8vLy8vLy83Ky92NStmbng4ZkgvLy84QUFBRC8vLzhiR3h2NysvdjUrZmtvS0NnaElTRkRRME1ZR0JqaDRlSFkyTmpiMjl0UVVGQnZiMjlIUjBjL1B6ODJOallyS3l1L3Y3OFNFaEx1N3U3czdPelYxZFZWVlZVN096c1ZGUlhBdjc4UUVCQnpxZWhNQUFBQUczUlNUbE1BQS83cC92ejV4WmxyVGlQTC92NzgrL3Y3K09YZDJUWVFEczhMNzBaYkFBQUJLVWxFUVZRb3ozVlMxM0xDTUJCVVhIQ2hkOGl1a0RzbFFDaEovdi9UY2hhRzRjWFMrT1NiMWM3dHJVN1Y2ME9wZFJ6Mlp0TlpMNHpYTmxjTjhCRXRTRzYrTnhJWGtlUlBvQnVRMWNqdlozMS9WSkZCMTBJU2xpNmRpWWZIOGlZTzNXVU5DY05sQjBnVHJYT3RreFRvME8xYUtLaUJCTWhodjJNTkJRS29pQTV3eGxabzBKRHpEM0FZS2JXYWN5ajNmczAxd3hleTBweUVQK1I4cFdLV1hvcXRJWjBERGc1cGJraTlrckVLT2E2TFZEUXNkb1hFc2k0NlpxaDY5S0Z6N0IxdTdIYjJ5RFY4ZmlyWERLQmxaNFVGaXN3S0dSaFhUUzkzL0VDSzd5eG5KMytTM3kvVGhwTytjZlNEMDE3bnFhMThhYXNhYlUwL3Q3ZCt0azAvMW9NRUoxTmFENjdpd2RGNjhPYWJGU0xuK2VIYjArdmp5K3VrOGJyOWZkcmZ0SDBPMm1lbmZkNytBUWZZTS9sTmpvREhBQUFBQUVsRlRrU3VRbUNDIjoKSU1BR0VfUEFUSCsiL2RlbGV0ZS5wbmciO0VkaXRvci5wbHVzSW1hZ2U9bXhDbGllbnQuSVNfU1ZHPyJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFvQUFBQUtDQVlBQUFDTk1zKzlBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlKcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1TUMxak1EWXdJRFl4TGpFek5EYzNOeXdnTWpBeE1DOHdNaTh4TWkweE56b3pNam93TUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVOVE5TQk5ZV05wYm5SdmMyZ2lJSGh0Y0UxTk9rbHVjM1JoYm1ObFNVUTlJbmh0Y0M1cGFXUTZNRGRDTVRkRU5qVkNPRU00TVRGRk5EbENSalZCTkRkQ09EVTVOak5CTlVNaUlIaHRjRTFOT2tSdlkzVnRaVzUwU1VROUluaHRjQzVrYVdRNk1EZENNVGRFTmpaQ09FTTRNVEZGTkRsQ1JqVkJORGRDT0RVNU5qTkJOVU1pUGlBOGVHMXdUVTA2UkdWeWFYWmxaRVp5YjIwZ2MzUlNaV1k2YVc1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvd04wSXhOMFEyTTBJNFF6Z3hNVVUwT1VKR05VRTBOMEk0TlRrMk0wRTFReUlnYzNSU1pXWTZaRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG93TjBJeE4wUTJORUk0UXpneE1VVTBPVUpHTlVFME4wSTROVGsyTTBFMVF5SXZQaUE4TDNKa1pqcEVaWE5qY21sd2RHbHZiajRnUEM5eVpHWTZVa1JHUGlBOEwzZzZlRzF3YldWMFlUNGdQRDk0Y0dGamEyVjBJR1Z1WkQwaWNpSS9QdGpyam1nQUFBQXRTVVJCVkhqYVl2ei8vejhETWlndkx3Y0xkSFoyTWlLTE16RVFDYWl2a0xHc3JPdy9kVTBjQXI0R0NEQUFSUXNRYlRGcnYxMEFBQUFBU1VWT1JLNUNZSUk9IjoKSU1BR0VfUEFUSCsiL3BsdXMucG5nIjtFZGl0b3Iuc3BpbkltYWdlPW14Q2xpZW50LklTX1NWRz8iZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoREFBTUFQVXhBRVZyaVZwN2xtQ0FtbUdCbTJPQ25HbUhuM09QcG5lU3FZS2JyNE9jc0lTY3NJMmt0bzZrdDQ2bHQ1S251Wm10dnBxdXZwdXZ2NTZ5d2FDendxSzF4S3U3eWF5OXlxKy96TEhBemJmRjBiakcwYnpKMUx6SzFNRE4xOGpUMjhuVDNNM1gzdEhhNGRUYzQ5WGQ1TmpmNWRuZzV0M2s2ZC9sNnVEbTZ1cnU4ZTd4OC9EejlmVDI5L2I0K1BqNStmajUrdnI2K3YvLy93QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNINUJBa0tBREVBSWY4TFRrVlVVME5CVUVVeUxqQURBUUFBQUN3QUFBQUFEQUFNQUFBR1I4Q1ljRWdzT2dZQUlheDRDQ1F1UWxkckNCRXNpSzhWUzJob0ZHT3JsSkRBK2NaUXdrTG5xeW9KRlpLdmlTUzBJQ3JFMGVjMGpEQXdJaVVlR3lCRkdoTVBGQmtoWm8xQkFDSDVCQWtLQUM0QUxBQUFBQUFNQUF3QWhWQjBrRlIzazFWNGsyQ0FtbVdFblc2TG8zS09wWGVTcUgyWHJJT2NzSVNkc0ltaHRJcWh0SkNtdUpHbnVadXd2NTJ3d0oreXdaK3l3cW02eUxIQnpiTEN6clhFejdmRjBMbkgwcnJJMHI3TDFiL00xc1hSMmNmVDI4clYzY3pXM3MvWjROZmU1TnZpNk9EbTZ1TG42K0xuN09MbzdPWHE3ZWZzNyt6dzh1L3k5UER5OVBYMytQcjcrLy8vL3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVpEUUpkd1NDeEdEQUlBb1ZGa0ZCd1lTeUl3R0U0T2tDSnhJZEc2V2tKRXg4c1NLajdlbGZCQjBhNVNRZzFFUTBTVlZNUEtoRE02aVVJa1JSNFpGeHNnSmw2SlFRQWgrUVFKQ2dBeEFDd0FBQUFBREFBTUFJVkdhNGxjZlpkamdweGtnNTFuaHA1dWk2TjNrcWg1bEtxRm5iR0huN0tJb0xPUXA3aVJwN21TcUxtVHFicWFycjZicjcrZnNzR2l0Y09pdGNTdXZzdXV2OHV3d015enc4NjF4TkM1eDlLNng5Sy96TmJEenRqRTBObkcwZHJKMU56UTJlRFMyK0xUMitMVjNlUFo0T2JhNGViYjR1ZmM0K2ptNis3dDhQTHQ4UFB0OGZQeDgvWHg5UFgwOXZmMTkvajMrUG4vLy84QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHUThDWWNFZ3NVaFFGZ2dGU2pDUW1uRTFqY0JocUdCWGlJdUFRU2k3RkdFSWdmSXpDRm9DWEZDWmlQTzBoS0JNaXdsN0VUNmVVWXFsV0xrVW5JU0ltS0MxeGJVRUFJZmtFQ1FvQU1nQXNBQUFBQUF3QURBQ0ZUbktQVDNLUFZIYVRZb0tjYjR5amNZNmxlWlNwZjVtdGdadXZoNSt5aXFHMGk2SzFqcVcza2FlNW5ySEJuckxCbjdMQ29MUENvYlREcWJySXFydklzOExPdE1QUHRjUFB0Y1RQdU1iUnVjZlN2Y3JVdnN2VndNeld4ZEhheWRUY3l0WGR6TmJlemRmZjBkcmgyT0RsMitMbjNlVHA0T2JxNHVqczVPbnQ1dXZ1Nk8zdzZ1N3c2dTd4Ny9MMDl2ajUrdnI3K3Z2Ny8vLy9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQmtkQW1YQklMSEljaWNPQ1VxeEVMS0tQeEtBWWdpWWQ0b01BRVdvOFJWbWpJTVNjd2htQmNKTUtYd0xDRUNtTUdBaFBJMVFSd0JpYVNpeENNREZoTFNvckxpOHdZWXhDUVFBaCtRUUpDZ0F4QUN3QUFBQUFEQUFNQUlWWmVwVmdnSnBoZ1p0bmhwNXZqS04ya2FoM2txbUJtcStLb2JTTG9yV05wTGFScDdtV3E3eWJyNytnczhLaXRjU2t0c1dudU1hbnVjZXh3TTJ5d2M2M3h0RzZ5Tk85eXRTK3l0Vy96TmJEejlqSDB0dkwxZDNOMTk3UzIrTFUzT1BVM2VQVjNlVFgzK1hhNGVmYjR1ZmQ1T25sNnU3cjd2SHM3L0x0OFBMdzgvWHk5UGJ5OWZiMDlmZjIrUG4zK1BuNit2ci8vLzhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdTTUNZY0Vnc2Vpd1NSK1JTN0dBNEpGR0Y4UmlXTmlFaUpURVJna2pGR0FRaC9LVENHb0p3cEFwbkJrSVRLcndvQ0ZXbkZsRWhhQXhYTEM5Q0J3QUdSUzR3UWdFTFlZMUNRUUFoK1FRSkNnQXpBQ3dBQUFBQURBQU1BSVZNY0k1U2RaRmhnWnR0aTZKd2phUjRrNm1BbWE2Q202K0tvYlNMb3JXTG83V05vN2FQcHJlZHNNQ2VzY0dpdE1PaXRjU211TWFxdThpeHdjMnp3czYzeGRDNHh0RzV4OUs5eXRYQXpkZkN6dGpGME5uRjBkcksxZDNNMXQ3UDJOL1AyZURUMitMWDMrWGU1T25oNSt2aTUrdmo2T3prNmUzbjdPL283Ty9xN3ZIczcvTHQ4UFB1OGZQeDgvWDMrUG42K3Z2NysvdjgvUHovLy84QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBR1JjQ1pjRWdzbWtJYlRPWlRMSWxHcVpObmNobTJTQ2dpSjZJUnFsakZtUVVpWElWbm9JVFFkZTRjaEM5WStMRVF4bVRGUmtGU05GQXFEQU1JUlFvQ0FBRUVEbWVMUVFBaCtRUUpDZ0F3QUN3QUFBQUFEQUFNQUlWWGVaUmVmcGxmZjVsaGdadHBoNTl5anFWMmthZUFtcTZGbmJHRm5yR0xvcldOcExhUXA3bVJxTG1ZcmIyZXNzR2dzOEtsdDhhcHVzaXR2Y3F1djh1MnhOQzd5Tk84eWRTOHl0VEF6ZGZCemRmTTF0N04xOTdRMmVEVTNPUFgzK1haNE9iWjRlYmM0K2pmNWVyZzVlcmc1dXZwN2ZEdThmUHY4dlR6OWZiMDl2ZjE5L2ozK1BuNCtmbjUrdnI2Ky92Ly8vOEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdSVUNZY0Vnc3Brd2pFS2hVVkoxUXNCTnAweG0yVml4aVNPTVJ2bHhGR0FjVEpvb2s1ZUVISWhRY3dwV0lrQUZRRUNrTnk5QVFXRnd5RUFrUFJRNEZBd1FJRTJsbFFRQWgrUVFKQ2dBdkFDd0FBQUFBREFBTUFJVk5jWTVTZFpGaWdwdHBoNkJ2aktOMGtLZDhscXVBbXErRW5iR0duN0tIbjdPTnBMYU9wYmVhcnIrY3NNQ2RzY0Nlc2NHaHRNT251TWF1dnN1endzNjB3ODYyeGRDOXl0Vy95OWEvek5iQ3p0akcwZHJIMHR2SzFOM00xdDdOMTkvVTNlUGI0dWZmNXVyajZPems2ZTNsNnU3bTZ1N283UERxN3ZEdDhQUHY4dlR3OHZUdzgvWDE5dmY2K3Z2Ly8vOEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHUThDWGNFZ3N2bHl0VlVwbEpMSklwU0VEVUVTRlRFTEJ3U2dDQ1FFVjQya2pERmlNbzR1UXNEQjJNa0xIb0VIVVREN0RSQUhDOFZBaVowUVNDZ1lJRHhoTmlVRUFPdz09IjoKSU1BR0VfUEFUSCsiL3NwaW4uZ2lmIjtFZGl0b3IuZ2xvYmVJbWFnZT0iZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJajQ4Y0dGMGFDQmtQU0pOTVRFdU9Ua2dNa00yTGpRM0lESWdNaUEyTGpRNElESWdNVEp6TkM0ME55QXhNQ0E1TGprNUlERXdRekUzTGpVeUlESXlJREl5SURFM0xqVXlJREl5SURFeVV6RTNMalV5SURJZ01URXVPVGtnTW5wdE5pNDVNeUEyYUMweUxqazFZeTB1TXpJdE1TNHlOUzB1TnpndE1pNDBOUzB4TGpNNExUTXVOVFlnTVM0NE5DNDJNeUF6TGpNM0lERXVPVEVnTkM0ek15QXpMalUyZWsweE1pQTBMakEwWXk0NE15QXhMaklnTVM0ME9DQXlMalV6SURFdU9URWdNeTQ1Tm1ndE15NDRNbU11TkRNdE1TNDBNeUF4TGpBNExUSXVOellnTVM0NU1TMHpMamsyZWswMExqSTJJREUwUXpRdU1TQXhNeTR6TmlBMElERXlMalk1SURRZ01USnpMakV0TVM0ek5pNHlOaTB5YURNdU16aGpMUzR3T0M0Mk5pMHVNVFFnTVM0ek1pMHVNVFFnTWlBd0lDNDJPQzR3TmlBeExqTTBMakUwSURKSU5DNHlObnB0TGpneUlESm9NaTQ1TldNdU16SWdNUzR5TlM0M09DQXlMalExSURFdU16Z2dNeTQxTmkweExqZzBMUzQyTXkwekxqTTNMVEV1T1MwMExqTXpMVE11TlRaNmJUSXVPVFV0T0VnMUxqQTRZeTQ1TmkweExqWTJJREl1TkRrdE1pNDVNeUEwTGpNekxUTXVOVFpET0M0NE1TQTFMalUxSURndU16VWdOaTQzTlNBNExqQXpJRGg2VFRFeUlERTVMamsyWXkwdU9ETXRNUzR5TFRFdU5EZ3RNaTQxTXkweExqa3hMVE11T1Rab015NDRNbU10TGpReklERXVORE10TVM0d09DQXlMamMyTFRFdU9URWdNeTQ1Tm5wTk1UUXVNelFnTVRSSU9TNDJObU10TGpBNUxTNDJOaTB1TVRZdE1TNHpNaTB1TVRZdE1pQXdMUzQyT0M0d055MHhMak0xTGpFMkxUSm9OQzQyT0dNdU1Ea3VOalV1TVRZZ01TNHpNaTR4TmlBeUlEQWdMalk0TFM0d055QXhMak0wTFM0eE5pQXllbTB1TWpVZ05TNDFObU11TmkweExqRXhJREV1TURZdE1pNHpNU0F4TGpNNExUTXVOVFpvTWk0NU5XTXRMamsySURFdU5qVXRNaTQwT1NBeUxqa3pMVFF1TXpNZ015NDFObnBOTVRZdU16WWdNVFJqTGpBNExTNDJOaTR4TkMweExqTXlMakUwTFRJZ01DMHVOamd0TGpBMkxURXVNelF0TGpFMExUSm9NeTR6T0dNdU1UWXVOalF1TWpZZ01TNHpNUzR5TmlBeWN5MHVNU0F4TGpNMkxTNHlOaUF5YUMwekxqTTRlaUl2UGp3dmMzWm5QZz09IjsKRWRpdG9yLmNvbW1lbnRJbWFnZT0iZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJajQ4Y0dGMGFDQmtQU0pOTWpFdU9Ua2dOR013TFRFdU1TMHVPRGt0TWkweExqazVMVEpJTkdNdE1TNHhJREF0TWlBdU9TMHlJREoyTVRKak1DQXhMakV1T1NBeUlESWdNbWd4Tkd3MElEUXRMakF4TFRFNGVrMHhPQ0F4TkVnMmRpMHlhREV5ZGpKNmJUQXRNMGcyVmpsb01USjJNbnB0TUMwelNEWldObWd4TW5ZeWVpSXZQanh3WVhSb0lHUTlJazB3SURCb01qUjJNalJJTUhvaUlHWnBiR3c5SW01dmJtVWlMejQ4TDNOMlp6ND0iO0VkaXRvci5jb21tZW50SW1hZ2VJbnZlcnRlZD0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDQUFBQUFnQ0FZQUFBQnplbnIwQUFBQkxFbEVRVlJZUisyV3Z5NEZRUmpGZjRkSU5BcTlYcXRTYVZScVhBclBJTkVvZFVxbGh4QzUvcFU2bllkUVNIUWVRVFJITnRtVnVYdVhySXh2MWsxc041dk1PYjg1Yzc1a3hNQ2ZCdlpuQ3NEMkVyQUd6QWZBdlV0NlRIVW5BR3dmQVdmQVFvQjVJM2toNmFCWmZBTFlYZ0dlZzgwYjMxVkpUOVVpQlJnQjQ4Q1RwOUxia3U3YUFQdkFaU0dBSFVtM3N3RWdLV3RVYmJzajFmNEpEQTRBYkdiMjRpRXJnVXp6cjdidlNycnBWY0tnSzVnaGdLQU85RS9ndndOQkpSeEp1dTQxQlVFZCtCRkFSQTMrSnNBV2NCOXgzQTdOemdTcXQrQUxzRndBWWhxZ01yVzlVYjhKMTRHNVFKQnVnQWhEMnlmQWFVdDdUOUxWeEJoR21EZWF0by9yWkp0ZlpRSHE2MDBoeWdQVUVJZkFPVEFNUUFMeFdyUUQ3WDdaWHBUMFZxeUUzeFU4NjhuOUc1UHpBU1B2cGlIYXZCQVVBQUFBQUVsRlRrU3VRbUNDIjsKRWRpdG9yLnVzZXJJbWFnZT0iZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJajQ4Y0dGMGFDQmtQU0pOTVRJZ01USmpNaTR5TVNBd0lEUXRNUzQzT1NBMExUUnpMVEV1TnprdE5DMDBMVFF0TkNBeExqYzVMVFFnTkNBeExqYzVJRFFnTkNBMGVtMHdJREpqTFRJdU5qY2dNQzA0SURFdU16UXRPQ0EwZGpKb01UWjJMVEpqTUMweUxqWTJMVFV1TXpNdE5DMDRMVFI2SWk4K1BDOXpkbWMrIjtFZGl0b3Iuc2hhcmVJbWFnZT0iZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJajQ4Y0dGMGFDQmtQU0pOTVRnZ01UWXVNRGhqTFM0M05pQXdMVEV1TkRRdU15MHhMamsyTGpjM1REZ3VPVEVnTVRJdU4yTXVNRFV0TGpJekxqQTVMUzQwTmk0d09TMHVOM010TGpBMExTNDBOeTB1TURrdExqZHNOeTR3TlMwMExqRXhZeTQxTkM0MUlERXVNalV1T0RFZ01pNHdOQzQ0TVNBeExqWTJJREFnTXkweExqTTBJRE10TTNNdE1TNHpOQzB6TFRNdE15MHpJREV1TXpRdE15QXpZekFnTGpJMExqQTBMalEzTGpBNUxqZE1PQzR3TkNBNUxqZ3hRemN1TlNBNUxqTXhJRFl1TnprZ09TQTJJRGxqTFRFdU5qWWdNQzB6SURFdU16UXRNeUF6Y3pFdU16UWdNeUF6SUROakxqYzVJREFnTVM0MUxTNHpNU0F5TGpBMExTNDRNV3czTGpFeUlEUXVNVFpqTFM0d05TNHlNUzB1TURndU5ETXRMakE0TGpZMUlEQWdNUzQyTVNBeExqTXhJREl1T1RJZ01pNDVNaUF5TGpreUlERXVOakVnTUNBeUxqa3lMVEV1TXpFZ01pNDVNaTB5TGpreWN5MHhMak14TFRJdU9USXRNaTQ1TWkweUxqa3llaUl2UGp3dmMzWm5QZz09IjsKRWRpdG9yLnN5bmNJbWFnZT0iZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJajQ4Y0dGMGFDQmtQU0pOTVRJZ05GWXhURGdnTld3MElEUldObU16TGpNeElEQWdOaUF5TGpZNUlEWWdOaUF3SURFdU1ERXRMakkxSURFdU9UY3RMamNnTWk0NGJERXVORFlnTVM0ME5rTXhPUzQxTkNBeE5TNHdNeUF5TUNBeE15NDFOeUF5TUNBeE1tTXdMVFF1TkRJdE15NDFPQzA0TFRndE9IcHRNQ0F4TkdNdE15NHpNU0F3TFRZdE1pNDJPUzAyTFRZZ01DMHhMakF4TGpJMUxURXVPVGN1TnkweUxqaE1OUzR5TkNBM0xqYzBRelF1TkRZZ09DNDVOeUEwSURFd0xqUXpJRFFnTVRKak1DQTBMalF5SURNdU5UZ2dPQ0E0SURoMk0ydzBMVFF0TkMwMGRqTjZJaTgrUEM5emRtYysiO0VkaXRvci5zeW5jRGlzYWJsZWRJbWFnZT0KImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWo0OGNHRjBhQ0JrUFNKTk1UQWdOaTR6TlZZMExqSTJZeTB1T0M0eU1TMHhMalUxTGpVMExUSXVNak11T1Rac01TNDBOaUF4TGpRMll5NHlOUzB1TVRJdU5TMHVNalF1TnpjdExqTXplbTB0Tnk0eE5DMHVPVFJzTWk0ek5pQXlMak0yUXpRdU5EVWdPQzQ1T1NBMElERXdMalEwSURRZ01USmpNQ0F5TGpJeExqa3hJRFF1TWlBeUxqTTJJRFV1TmpSTU5DQXlNR2cyZGkwMmJDMHlMakkwSURJdU1qUkROaTQyT0NBeE5TNHhOU0EySURFekxqWTJJRFlnTVRKak1DMHhJQzR5TlMweExqazBMalk0TFRJdU56ZHNPQzR3T0NBNExqQTRZeTB1TWpVdU1UTXRMalV1TWpVdExqYzNMak0wZGpJdU1EbGpMamd0TGpJeElERXVOVFV0TGpVMElESXVNak10TGprMmJESXVNellnTWk0ek5pQXhMakkzTFRFdU1qZE1OQzR4TkNBMExqRTBJREl1T0RZZ05TNDBNWHBOTWpBZ05HZ3ROblkyYkRJdU1qUXRNaTR5TkVNeE55NHpNaUE0TGpnMUlERTRJREV3TGpNMElERTRJREV5WXpBZ01TMHVNalVnTVM0NU5DMHVOamdnTWk0M04yd3hMalEySURFdU5EWkRNVGt1TlRVZ01UVXVNREVnTWpBZ01UTXVOVFlnTWpBZ01USmpNQzB5TGpJeExTNDVNUzAwTGpJdE1pNHpOaTAxTGpZMFRESXdJRFI2SWk4K1BDOXpkbWMrIjsKRWRpdG9yLnN5bmNQcm9ibGVtSW1hZ2U9ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWo0OGNHRjBhQ0JrUFNKTk15QXhNbU13SURJdU1qRXVPVEVnTkM0eUlESXVNellnTlM0Mk5Fd3pJREl3YURaMkxUWnNMVEl1TWpRZ01pNHlORU0xTGpZNElERTFMakUxSURVZ01UTXVOallnTlNBeE1tTXdMVEl1TmpFZ01TNDJOeTAwTGpneklEUXROUzQyTlZZMExqSTJRelV1TlRVZ05TNHhOU0F6SURndU1qY2dNeUF4TW5wdE9DQTFhREoyTFRKb0xUSjJNbnBOTWpFZ05HZ3ROblkyYkRJdU1qUXRNaTR5TkVNeE9DNHpNaUE0TGpnMUlERTVJREV3TGpNMElERTVJREV5WXpBZ01pNDJNUzB4TGpZM0lEUXVPRE10TkNBMUxqWTFkakl1TURsak15NDBOUzB1T0RrZ05pMDBMakF4SURZdE55NDNOQ0F3TFRJdU1qRXRMamt4TFRRdU1pMHlMak0yTFRVdU5qUk1NakVnTkhwdExURXdJRGxvTWxZM2FDMHlkalo2SWk4K1BDOXpkbWMrIjsKRWRpdG9yLnR3ZWV0SW1hZ2U9SU1BR0VfUEFUSCsiL3R3ZWV0LnBuZyI7RWRpdG9yLmZhY2Vib29rSW1hZ2U9SU1BR0VfUEFUSCsiL2ZhY2Vib29rLnBuZyI7RWRpdG9yLmJsYW5rSW1hZ2U9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQUVBQUFBQkNBWUFBQUFmRmNTSkFBQUFDa2xFUVZSNG5HTUFBUUFBQlFBQkRRb3R0QUFBQUFCSlJVNUVya0pnZ2c9PSI7RWRpdG9yLmhpUmVzSW1hZ2U9bXhDbGllbnQuSVNfU1ZHPyJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUZBQUFBQStDQU1BQUFDTE1XeTFBQUFBaDFCTVZFVUFBQUJNVEV4RVJFUkJRVUZCUVVGRlJVVkFRRUJDUWtKQVFFQTZPanBEUTBOS1NrcEJRVUZCUVVGRVJFUkVSRVJCUVVGQ1FrSkNRa0pDUWtKSlNVbEJRVUZDUWtKRFEwTkRRME5DUWtKRFEwTkJRVUZCUVVGQ1FrSkJRVUZDUWtKQ1FrSkRRME5DUWtKSFIwZEJRVUZDUWtKQ1FrSkFRRUJDUWtKRFEwTkFRRUJFUkVSQ1FrSWsxaFMyQUFBQUtuUlNUbE1BQWpqOTZCTDdQZ1FGUndmdTNUWWF6S3VWalJYbDFWMURQQ24xdUxHam5XTlZJZ3k5aFU0MGVHcVBrTTM4QUFBQ0cwbEVRVlJZdysyWDYzS2JNQkNGendaYmxnR0RjZU43NG11YXRwTGUvL202TUhWM2dIR0ZBdjJSak05NE1BYnh6ZG5Wc1FiQkRLd0g4QUg4TURBeWFmempxWWV5T0cwNFhFN1JTOG5JUkRYZzZCbFQrckEwbm10QVBoK05RUkR4SUFTSU1HNDRyQU1yR3VuQmdId3kzdVVsZHhnZ0lTdEdLcDJmK0RRYzJPNGg0ZVFzWDNPMklGQi9vRWJzak9LYlN0bmpBRUErekoweWxaVGJndm9Ebjh4TnluNkRiajVLZDRHc05wQUJhNmR1UVBmU2RFajg4VGdNQWhLdUNXakFrZ21GWFBMbnNEMHBXZDNPRkdkck11Z1FJSS9lT01QRWlHT3pxUE1JZVdyY1NvTUNnNzFXMXBYQlB2Q1ArZ1MvT2RYcVEzdVcyMys5M1hHV0xsL09hQmI4MDViTmNCUG9FSWNWSnNuSHpjeHBaSDg2dTVLWjlnRGJ5NWRRQ2NuS3FkYmtlNEl0STRUemQ3SVc5aFpRdDRFTzZHRzliOXNZdXVLOVd3bjhUSXIyeEtiRjIrM05ocitxeENoSi9BSTZwSWZDdTR6NFpvd3A0WlVOaWh6Nzl2ZXd6Y3RuSER3VHZRTy9oQ2RGQnpyVUdET1BuMlkvRjhZS1Q0b09BVEx2bGhPem56bUJTZEZCSld0YzU4eTdyK1VWRk9DUWN6eTN3cE42cGVnRHFIdHNDUFRHdkg5SnVUTzBEeWc4aWNsZFlQaytSQjZnOEFvZmo0bTJFS0J2dFRtVVBEOXhEZDFwUGNTUmVWMlU1aUQvaWsyeXJuZ3R2dnFCZlB6T3ZLaURUS1RzQ2RvSFpKN3BMTGZmZ1R3bEo1dkpkdEpWMi9qaUFZYUx2TEdoTUFFRE81UWNEZzJNL2pPdy84Wm4rSzNad0p2SFQ3WmZmZ0MvTnZBM3pjeWJUZUlmRTRFQUFBQUFTVVZPUks1Q1lJST0iOgpJTUFHRV9QQVRIKyIvaW1nLWhpLXJlcy5wbmciO0VkaXRvci5sb1Jlc0ltYWdlPW14Q2xpZW50LklTX1NWRz8iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFGQUFBQUErQ0FNQUFBQ0xNV3kxQUFBQVMxQk1WRVZBUUVBQUFBQTFOVFZCUVVGRFEwTkRRME5GUlVWRVJFUkJRVUZCUVVGQlFVRkFRRUJCUVVGQlFVRkNRa0pDUWtKQ1FrSkJRVUZDUWtKRFEwTkRRME5DUWtKQ1FrSkNRa0pHUmtiNS9YcVRBQUFBR1hSU1RsUCtBQVdPRGxBU0NzZXNYK0xjMkx5V2UzcHdhMXRDUGpvaGpTSmZvQUFBQUkxSlJFRlVXTVB0MU1rS2hUQU1SdUcwYW52bmVYci9KNzFuVXlwS2NkcUkvTjh5aExNS01aRTFDYWhuQ2xEUXpNUEI0NEVEM0VnZUN1YmdEV25XUU1IcHdUdEt3VGUrVUhENHNKOTR3YlVFSEhGR2hJTGxZRGVTbnNRZWFiZUNnc1BCZ0IwTU9aWjlvR0E1R0pGaUpTZlVVTEFmakxqQVJyaEN3WDd3aDJZQ0R3VmJ3WmtVQktxRkZKUk4rd09jd1NnUjJzUkVjZ0FBQUFCSlJVNUVya0pnZ2c9PSI6CklNQUdFX1BBVEgrIi9pbWctbG8tcmVzLnBuZyI7RWRpdG9yLmNhbWVyYUxhcmdlSW1hZ2U9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBZ0NBWUFBQUJ6ZW5yMEFBQUFBWE5TUjBJQXJzNGM2UUFBQUFsd1NGbHpBQUFMRXdBQUN4TUJBSnFjR0FBQUFWbHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlsaE5VQ0JEYjNKbElEVXVOQzR3SWo0S0lDQWdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRLSUNBZ0lDQWdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlLSUNBZ0lDQWdJQ0FnSUNBZ2VHMXNibk02ZEdsbVpqMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzkwYVdabUx6RXVNQzhpUGdvZ0lDQWdJQ0FnSUNBOGRHbG1aanBQY21sbGJuUmhkR2x2Ymo0eFBDOTBhV1ptT2s5eWFXVnVkR0YwYVc5dVBnb2dJQ0FnSUNBOEwzSmtaanBFWlhOamNtbHdkR2x2Ymo0S0lDQWdQQzl5WkdZNlVrUkdQZ284TDNnNmVHMXdiV1YwWVQ0S1RNSW5XUUFBQS9CSlJFRlVXQW5GbDB1SWpXRVl4ODg1YnVQU3VHd21TWXd0d3NZMWlrS1NOWU5jbG1RbmFkZ3JaU1Bsc25CTFNsYUdCZE5ZS1kwVmRpNEw0ell6SXF4R3htWEcvL2QrNy8vMCt1WTduV01pVC8yLzUzbWYrM3Y3dm5OS3BmOU01VWJyRHc4UGo0bSt3em1lVDFGQlVTNlhmK1lOb3g2cmVNT051a2lqTVhVVE0zTm1JNzVQeVhjSlB3UldnNWtTN3h5c0RMTm1mRVV4cHgycmNlTkU1MElsWWp5UmtsY0xmMHByWSt4NEJUcWZteDNaVUhRYU85SVNHbmdZcTM4Vi8xRUgrRUNQYStRYUsxdTFrVkJRaXJETUNoaVMzQ1RlSWt3V3ZnaHR3aEtCcFo4ZzFDTzJCOTlGeW5WVS9Lb3dTUmdRM21sckJzVloxYXdtUWxTMFNHYmZYZ2xmQlBiZFJHTW01TzhSWGcyUDgzNXBEQ3Z6V2pnaFRIRVRjTHBaTEh3UzhrVEN0QkVLMVNOODNFZ2FtOFl4eVZacWMrRG81cWt3UytnVDlnck53a1VCRzZjYnNHL2dzM0JUdUMvMENoQ3hxNFF0d2d6Qk1kd1VaQlB5TjRGdGZpNHNZUFpIa3RiT1NSbEl1dXRSUDVqWWowdWVacDg4eHlZY1MvelpvaUx5UVQxSUEvY1RqN2VTbHducmhJK0pua1FiQ3dvMlN4LzJNN1ZKdDE3d2RoVnRneHZycG9GbkF1U0FiSlE5N2JpWkFsS3hCZkQ5d2dPaFYrQmdJUi9BWnRKNGt3RDVQR1NqN09tbWVraldFeTBvQVFIQVMzK0twQnB6WHFZSzNVSXRvcEhwU1JNbm8yTitjbTdnRFluZlJDY3IzUUJxcmlNSExKRGtleWhGZmlHNWFWYksrOHJodFA5TTZRY0lFSkhYNUZwOU5NQXlRbFlpdStPT0pObE9EQ0lYeWthL1AyM2JuY1RkaUM3T3lkQzErdjFCc2IrNXI4NERLOFMzUmRtZjVjUlVGVzNiWHRXVVN0MVJkazZHNFN5SlYybzFZSWQrdk5VeHIreDV5Q0ppYXBGdGN4UXpManJ4Ym9HY014dkZKd0VPS25Md2pJYmt4L3NkU21lU2FVWSsrU3dUQXhWKzRESlQ3UlZ3a2JrNDZnTkNzaWZJSXR1eTBlOVBGMzNDYjRob21oTjVZUnl6TDVxNVYyVk5rdjk4a3Fnb0dUbzNZRjlDbk1NNVk1ckl0RmZ2QlNpOUp1bFZYT2dJK1Z3SW50a3QrU2FaNndlUWZjb3ZKZjd6cFRmbDg2UC93QUY3RnoxOE5lS3dtdkFXQ2FYMFovdU1IUXI0Mlp4dlIvUnhjdzV4TSs5Si9DSnE4dzJnZHVEaG1EZ3NvL1FyQkg0N2RFWFExSXFjenlIcElPZklSdG5UdFY3U3dPMW9LWEtrVTNmYlRvRkdTREh0TVdjYUgxV0J1VlluRGJSRmk5OWlxU015U2R6eFhja3JhelVoMjNLQlZZR0ljZk5Ca1R4Y2EwZTRBVEowS3VrR1lWQmdyL01ubGhQT3RRcS9rc1VmQ2J6aCtFRkNqdG5DVW9IZmpoQS9Pc2lUdjJIY0V2Sk1FTHAwVmFrWkRsaVRtcmlUZFBpdnhVNFZtRWh0UHJHVitLSmhPN1pLdDBkb0ZaaDFmZ1pTQldJVzJBR0VId2czQlVXT25LdEgrc3VxZHcwN3RZTWZnbENyV1BENW13OXFWWXVuaWFYa1QwT3RXYVN1bzVMSlRZMVJCZityb0Y5WDUreS81cVUrREFBQUFBQkpSVTVFcmtKZ2dnPT0iOwpFZGl0b3Iuc3ZnQnJva2VuSW1hZ2U9R3JhcGguY3JlYXRlU3ZnSW1hZ2UoMTAsMTAsJzxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxMCIgaGVpZ2h0PSIxMCIgc3Ryb2tlPSIjMDAwIiBmaWxsPSJ0cmFuc3BhcmVudCIvPjxwYXRoIGQ9Im0gMCAwIEwgMTAgMTAgTCAwIDEwIEwgMTAgMCIgc3Ryb2tlPSIjMDAwIiBmaWxsPSJ0cmFuc3BhcmVudCIvPicpO0VkaXRvci5kZWZhdWx0Q3VzdG9tTGlicmFyaWVzPVtdO0VkaXRvci5lbmFibGVDdXN0b21MaWJyYXJpZXM9ITA7RWRpdG9yLmVuYWJsZUN1c3RvbVByb3BlcnRpZXM9ITA7RWRpdG9yLmNvbXByZXNzWG1sPSEwO0VkaXRvci5nbG9iYWxWYXJzPW51bGw7RWRpdG9yLnNoYWRvd09wdGlvbkVuYWJsZWQ9IW14Q2xpZW50LklTX1NGO0VkaXRvci5jb25maWc9bnVsbDtFZGl0b3IuY29uZmlnVmVyc2lvbj1udWxsO0VkaXRvci5jb21tb25FZGdlUHJvcGVydGllcz1be3R5cGU6InNlcGFyYXRvciJ9LHtuYW1lOiJhcmNTaXplIixkaXNwTmFtZToiQXJjIFNpemUiLAp0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOm14Q29uc3RhbnRzLkxJTkVfQVJDU0laRX0se25hbWU6InNvdXJjZVBvcnRDb25zdHJhaW50IixkaXNwTmFtZToiU291cmNlIENvbnN0cmFpbnQiLHR5cGU6ImVudW0iLGRlZlZhbDoibm9uZSIsZW51bUxpc3Q6W3t2YWw6Im5vbmUiLGRpc3BOYW1lOiJOb25lIn0se3ZhbDoibm9ydGgiLGRpc3BOYW1lOiJOb3J0aCJ9LHt2YWw6ImVhc3QiLGRpc3BOYW1lOiJFYXN0In0se3ZhbDoic291dGgiLGRpc3BOYW1lOiJTb3V0aCJ9LHt2YWw6Indlc3QiLGRpc3BOYW1lOiJXZXN0In1dfSx7bmFtZToidGFyZ2V0UG9ydENvbnN0cmFpbnQiLGRpc3BOYW1lOiJUYXJnZXQgQ29uc3RyYWludCIsdHlwZToiZW51bSIsZGVmVmFsOiJub25lIixlbnVtTGlzdDpbe3ZhbDoibm9uZSIsZGlzcE5hbWU6Ik5vbmUifSx7dmFsOiJub3J0aCIsZGlzcE5hbWU6Ik5vcnRoIn0se3ZhbDoiZWFzdCIsZGlzcE5hbWU6IkVhc3QifSx7dmFsOiJzb3V0aCIsZGlzcE5hbWU6IlNvdXRoIn0sCnt2YWw6Indlc3QiLGRpc3BOYW1lOiJXZXN0In1dfSx7bmFtZToiamV0dHlTaXplIixkaXNwTmFtZToiSmV0dHkgU2l6ZSIsdHlwZToiaW50IixtaW46MCxkZWZWYWw6ImF1dG8iLGFsbG93QXV0bzohMCxpc1Zpc2libGU6ZnVuY3Rpb24oYSl7cmV0dXJuIm9ydGhvZ29uYWxFZGdlU3R5bGUiPT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRURHRSxudWxsKX19LHtuYW1lOiJmaWxsT3BhY2l0eSIsZGlzcE5hbWU6IkZpbGwgT3BhY2l0eSIsdHlwZToiaW50IixtaW46MCxtYXg6MTAwLGRlZlZhbDoxMDB9LHtuYW1lOiJzdHJva2VPcGFjaXR5IixkaXNwTmFtZToiU3Ryb2tlIE9wYWNpdHkiLHR5cGU6ImludCIsbWluOjAsbWF4OjEwMCxkZWZWYWw6MTAwfSx7bmFtZToic3RhcnRGaWxsIixkaXNwTmFtZToiU3RhcnQgRmlsbCIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfSx7bmFtZToiZW5kRmlsbCIsZGlzcE5hbWU6IkVuZCBGaWxsIix0eXBlOiJib29sIixkZWZWYWw6ITB9LAp7bmFtZToicGVyaW1ldGVyU3BhY2luZyIsZGlzcE5hbWU6IlRlcm1pbmFsIFNwYWNpbmciLHR5cGU6ImZsb2F0IixkZWZWYWw6MH0se25hbWU6ImFuY2hvclBvaW50RGlyZWN0aW9uIixkaXNwTmFtZToiQW5jaG9yIERpcmVjdGlvbiIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfSx7bmFtZToic25hcFRvUG9pbnQiLGRpc3BOYW1lOiJTbmFwIHRvIFBvaW50Iix0eXBlOiJib29sIixkZWZWYWw6ITF9LHtuYW1lOiJmaXhEYXNoIixkaXNwTmFtZToiRml4ZWQgRGFzaCIsdHlwZToiYm9vbCIsZGVmVmFsOiExfSx7bmFtZToiamlnZ2xlIixkaXNwTmFtZToiSmlnZ2xlIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjEuNSxpc1Zpc2libGU6ZnVuY3Rpb24oYSl7cmV0dXJuIjEiPT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsImNvbWljIiwiMCIpfX0se25hbWU6ImVkaXRhYmxlIixkaXNwTmFtZToiRWRpdGFibGUiLHR5cGU6ImJvb2wiLGRlZlZhbDohMH0se25hbWU6ImJhY2tncm91bmRPdXRsaW5lIiwKZGlzcE5hbWU6IkJhY2tncm91bmQgT3V0bGluZSIsdHlwZToiYm9vbCIsZGVmVmFsOiExfSx7bmFtZToiYmVuZGFibGUiLGRpc3BOYW1lOiJCZW5kYWJsZSIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfSx7bmFtZToibW92YWJsZSIsZGlzcE5hbWU6Ik1vdmFibGUiLHR5cGU6ImJvb2wiLGRlZlZhbDohMH0se25hbWU6ImNsb25lYWJsZSIsZGlzcE5hbWU6IkNsb25lYWJsZSIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfSx7bmFtZToiZGVsZXRhYmxlIixkaXNwTmFtZToiRGVsZXRhYmxlIix0eXBlOiJib29sIixkZWZWYWw6ITB9LHtuYW1lOiJvcnRob2dvbmFsTG9vcCIsZGlzcE5hbWU6Ikxvb3AgUm91dGluZyIsdHlwZToiYm9vbCIsZGVmVmFsOiExfSx7bmFtZToibm9KdW1wIixkaXNwTmFtZToiTm8gSnVtcHMiLHR5cGU6ImJvb2wiLGRlZlZhbDohMX1dO0VkaXRvci5jb21tb25WZXJ0ZXhQcm9wZXJ0aWVzPVt7dHlwZToic2VwYXJhdG9yIn0se25hbWU6InJlc2l6ZUxhc3RSb3ciLGRpc3BOYW1lOiJSZXNpemUgTGFzdCBSb3ciLAp0eXBlOiJib29sIixnZXREZWZhdWx0VmFsdWU6ZnVuY3Rpb24oYSxiKXt2YXIgZT1iLmVkaXRvclVpLmVkaXRvci5ncmFwaC5nZXRDZWxsU3R5bGUoMT09YS52ZXJ0aWNlcy5sZW5ndGgmJjA9PWEuZWRnZXMubGVuZ3RoP2EudmVydGljZXNbMF06bnVsbCk7cmV0dXJuIjEiPT1teFV0aWxzLmdldFZhbHVlKGUsInJlc2l6ZUxhc3RSb3ciLCIwIil9LGlzVmlzaWJsZTpmdW5jdGlvbihhLGIpe3ZhciBlPWIuZWRpdG9yVWkuZWRpdG9yLmdyYXBoO3JldHVybiAxPT1hLnZlcnRpY2VzLmxlbmd0aCYmMD09YS5lZGdlcy5sZW5ndGgmJmUuaXNUYWJsZShhLnZlcnRpY2VzWzBdKX19LHtuYW1lOiJyZXNpemVMYXN0IixkaXNwTmFtZToiUmVzaXplIExhc3QgQ29sdW1uIix0eXBlOiJib29sIixnZXREZWZhdWx0VmFsdWU6ZnVuY3Rpb24oYSxiKXt2YXIgZT1iLmVkaXRvclVpLmVkaXRvci5ncmFwaC5nZXRDZWxsU3R5bGUoMT09YS52ZXJ0aWNlcy5sZW5ndGgmJjA9PWEuZWRnZXMubGVuZ3RoP2EudmVydGljZXNbMF06Cm51bGwpO3JldHVybiIxIj09bXhVdGlscy5nZXRWYWx1ZShlLCJyZXNpemVMYXN0IiwiMCIpfSxpc1Zpc2libGU6ZnVuY3Rpb24oYSxiKXt2YXIgZT1iLmVkaXRvclVpLmVkaXRvci5ncmFwaDtyZXR1cm4gMT09YS52ZXJ0aWNlcy5sZW5ndGgmJjA9PWEuZWRnZXMubGVuZ3RoJiZlLmlzVGFibGUoYS52ZXJ0aWNlc1swXSl9fSx7bmFtZToiZmlsbE9wYWNpdHkiLGRpc3BOYW1lOiJGaWxsIE9wYWNpdHkiLHR5cGU6ImludCIsbWluOjAsbWF4OjEwMCxkZWZWYWw6MTAwfSx7bmFtZToic3Ryb2tlT3BhY2l0eSIsZGlzcE5hbWU6IlN0cm9rZSBPcGFjaXR5Iix0eXBlOiJpbnQiLG1pbjowLG1heDoxMDAsZGVmVmFsOjEwMH0se25hbWU6Im92ZXJmbG93IixkaXNwTmFtZToiVGV4dCBPdmVyZmxvdyIsZGVmVmFsOiJ2aXNpYmxlIix0eXBlOiJlbnVtIixlbnVtTGlzdDpbe3ZhbDoidmlzaWJsZSIsZGlzcE5hbWU6IlZpc2libGUifSx7dmFsOiJoaWRkZW4iLGRpc3BOYW1lOiJIaWRkZW4ifSx7dmFsOiJmaWxsIiwKZGlzcE5hbWU6IkZpbGwifSx7dmFsOiJ3aWR0aCIsZGlzcE5hbWU6IldpZHRoIn1dfSx7bmFtZToibm9MYWJlbCIsZGlzcE5hbWU6IkhpZGUgTGFiZWwiLHR5cGU6ImJvb2wiLGRlZlZhbDohMX0se25hbWU6ImxhYmVsUGFkZGluZyIsZGlzcE5hbWU6IkxhYmVsIFBhZGRpbmciLHR5cGU6ImZsb2F0IixkZWZWYWw6MH0se25hbWU6ImRpcmVjdGlvbiIsZGlzcE5hbWU6IkRpcmVjdGlvbiIsdHlwZToiZW51bSIsZGVmVmFsOiJlYXN0IixlbnVtTGlzdDpbe3ZhbDoibm9ydGgiLGRpc3BOYW1lOiJOb3J0aCJ9LHt2YWw6ImVhc3QiLGRpc3BOYW1lOiJFYXN0In0se3ZhbDoic291dGgiLGRpc3BOYW1lOiJTb3V0aCJ9LHt2YWw6Indlc3QiLGRpc3BOYW1lOiJXZXN0In1dfSx7bmFtZToicG9ydENvbnN0cmFpbnQiLGRpc3BOYW1lOiJDb25zdHJhaW50Iix0eXBlOiJlbnVtIixkZWZWYWw6Im5vbmUiLGVudW1MaXN0Olt7dmFsOiJub25lIixkaXNwTmFtZToiTm9uZSJ9LHt2YWw6Im5vcnRoIixkaXNwTmFtZToiTm9ydGgifSwKe3ZhbDoiZWFzdCIsZGlzcE5hbWU6IkVhc3QifSx7dmFsOiJzb3V0aCIsZGlzcE5hbWU6IlNvdXRoIn0se3ZhbDoid2VzdCIsZGlzcE5hbWU6Ildlc3QifV19LHtuYW1lOiJwb3J0Q29uc3RyYWludFJvdGF0aW9uIixkaXNwTmFtZToiUm90YXRlIENvbnN0cmFpbnQiLHR5cGU6ImJvb2wiLGRlZlZhbDohMX0se25hbWU6ImNvbm5lY3RhYmxlIixkaXNwTmFtZToiQ29ubmVjdGFibGUiLHR5cGU6ImJvb2wiLGdldERlZmF1bHRWYWx1ZTpmdW5jdGlvbihhLGIpe3JldHVybiBiLmVkaXRvclVpLmVkaXRvci5ncmFwaC5pc0NlbGxDb25uZWN0YWJsZSgxPT1hLnZlcnRpY2VzLmxlbmd0aCYmMD09YS5lZGdlcy5sZW5ndGg/YS52ZXJ0aWNlc1swXTpudWxsKX0saXNWaXNpYmxlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIDE9PWEudmVydGljZXMubGVuZ3RoJiYwPT1hLmVkZ2VzLmxlbmd0aH19LHtuYW1lOiJhbGxvd0Fycm93cyIsZGlzcE5hbWU6IkFsbG93IEFycm93cyIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfSwKe25hbWU6InNuYXBUb1BvaW50IixkaXNwTmFtZToiU25hcCB0byBQb2ludCIsdHlwZToiYm9vbCIsZGVmVmFsOiExfSx7bmFtZToicGVyaW1ldGVyIixkaXNwTmFtZToiUGVyaW1ldGVyIixkZWZWYWw6Im5vbmUiLHR5cGU6ImVudW0iLGVudW1MaXN0Olt7dmFsOiJub25lIixkaXNwTmFtZToiTm9uZSJ9LHt2YWw6InJlY3RhbmdsZVBlcmltZXRlciIsZGlzcE5hbWU6IlJlY3RhbmdsZSJ9LHt2YWw6ImVsbGlwc2VQZXJpbWV0ZXIiLGRpc3BOYW1lOiJFbGxpcHNlIn0se3ZhbDoicmhvbWJ1c1BlcmltZXRlciIsZGlzcE5hbWU6IlJob21idXMifSx7dmFsOiJ0cmlhbmdsZVBlcmltZXRlciIsZGlzcE5hbWU6IlRyaWFuZ2xlIn0se3ZhbDoiaGV4YWdvblBlcmltZXRlcjIiLGRpc3BOYW1lOiJIZXhhZ29uIn0se3ZhbDoibGlmZWxpbmVQZXJpbWV0ZXIiLGRpc3BOYW1lOiJMaWZlbGluZSJ9LHt2YWw6Im9ydGhvZ29uYWxQZXJpbWV0ZXIiLGRpc3BOYW1lOiJPcnRob2dvbmFsIn0se3ZhbDoiYmFja2JvbmVQZXJpbWV0ZXIiLApkaXNwTmFtZToiQmFja2JvbmUifSx7dmFsOiJjYWxsb3V0UGVyaW1ldGVyIixkaXNwTmFtZToiQ2FsbG91dCJ9LHt2YWw6InBhcmFsbGVsb2dyYW1QZXJpbWV0ZXIiLGRpc3BOYW1lOiJQYXJhbGxlbG9ncmFtIn0se3ZhbDoidHJhcGV6b2lkUGVyaW1ldGVyIixkaXNwTmFtZToiVHJhcGV6b2lkIn0se3ZhbDoic3RlcFBlcmltZXRlciIsZGlzcE5hbWU6IlN0ZXAifV19LHtuYW1lOiJmaXhEYXNoIixkaXNwTmFtZToiRml4ZWQgRGFzaCIsdHlwZToiYm9vbCIsZGVmVmFsOiExfSx7bmFtZToiamlnZ2xlIixkaXNwTmFtZToiSmlnZ2xlIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjEuNSxpc1Zpc2libGU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4iMSI9PW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSwiY29taWMiLCIwIil9fSx7bmFtZToiYXV0b3NpemUiLGRpc3BOYW1lOiJBdXRvc2l6ZSIsdHlwZToiYm9vbCIsZGVmVmFsOiExfSx7bmFtZToiY29udGFpbmVyIixkaXNwTmFtZToiQ29udGFpbmVyIiwKdHlwZToiYm9vbCIsZGVmVmFsOiExLGlzVmlzaWJsZTpmdW5jdGlvbihhLGIpe3JldHVybiAxPT1hLnZlcnRpY2VzLmxlbmd0aCYmMD09YS5lZGdlcy5sZW5ndGh9fSx7bmFtZToiZHJvcFRhcmdldCIsZGlzcE5hbWU6IkRyb3AgVGFyZ2V0Iix0eXBlOiJib29sIixnZXREZWZhdWx0VmFsdWU6ZnVuY3Rpb24oYSxiKXt2YXIgZT0xPT1hLnZlcnRpY2VzLmxlbmd0aCYmMD09YS5lZGdlcy5sZW5ndGg/YS52ZXJ0aWNlc1swXTpudWxsLGM9Yi5lZGl0b3JVaS5lZGl0b3IuZ3JhcGg7cmV0dXJuIG51bGwhPWUmJihjLmlzU3dpbWxhbmUoZSl8fDA8Yy5tb2RlbC5nZXRDaGlsZENvdW50KGUpKX0saXNWaXNpYmxlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIDE9PWEudmVydGljZXMubGVuZ3RoJiYwPT1hLmVkZ2VzLmxlbmd0aH19LHtuYW1lOiJjb2xsYXBzaWJsZSIsZGlzcE5hbWU6IkNvbGxhcHNpYmxlIix0eXBlOiJib29sIixnZXREZWZhdWx0VmFsdWU6ZnVuY3Rpb24oYSxiKXt2YXIgZT0xPT1hLnZlcnRpY2VzLmxlbmd0aCYmCjA9PWEuZWRnZXMubGVuZ3RoP2EudmVydGljZXNbMF06bnVsbCxjPWIuZWRpdG9yVWkuZWRpdG9yLmdyYXBoO3JldHVybiBudWxsIT1lJiYoYy5pc0NvbnRhaW5lcihlKSYmIjAiIT1hLnN0eWxlLmNvbGxhcHNpYmxlfHwhYy5pc0NvbnRhaW5lcihlKSYmIjEiPT1hLnN0eWxlLmNvbGxhcHNpYmxlKX0saXNWaXNpYmxlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIDE9PWEudmVydGljZXMubGVuZ3RoJiYwPT1hLmVkZ2VzLmxlbmd0aH19LHtuYW1lOiJyZWN1cnNpdmVSZXNpemUiLGRpc3BOYW1lOiJSZXNpemUgQ2hpbGRyZW4iLHR5cGU6ImJvb2wiLGRlZlZhbDohMCxpc1Zpc2libGU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gMT09YS52ZXJ0aWNlcy5sZW5ndGgmJjA9PWEuZWRnZXMubGVuZ3RoJiYhYi5lZGl0b3JVaS5lZGl0b3IuZ3JhcGguaXNTd2ltbGFuZShhLnZlcnRpY2VzWzBdKSYmbnVsbD09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLCJjaGlsZExheW91dCIsbnVsbCl9fSx7bmFtZToiZXhwYW5kIiwKZGlzcE5hbWU6IkV4cGFuZCIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfSx7bmFtZToicGFydCIsZGlzcE5hbWU6IlBhcnQiLHR5cGU6ImJvb2wiLGRlZlZhbDohMSxpc1Zpc2libGU6ZnVuY3Rpb24oYSxiKXt2YXIgZT1iLmVkaXRvclVpLmVkaXRvci5ncmFwaC5tb2RlbDtyZXR1cm4gMDxhLnZlcnRpY2VzLmxlbmd0aD9lLmlzVmVydGV4KGUuZ2V0UGFyZW50KGEudmVydGljZXNbMF0pKTohMX19LHtuYW1lOiJlZGl0YWJsZSIsZGlzcE5hbWU6IkVkaXRhYmxlIix0eXBlOiJib29sIixkZWZWYWw6ITB9LHtuYW1lOiJiYWNrZ3JvdW5kT3V0bGluZSIsZGlzcE5hbWU6IkJhY2tncm91bmQgT3V0bGluZSIsdHlwZToiYm9vbCIsZGVmVmFsOiExfSx7bmFtZToibW92YWJsZSIsZGlzcE5hbWU6Ik1vdmFibGUiLHR5cGU6ImJvb2wiLGRlZlZhbDohMH0se25hbWU6Im1vdmFibGVMYWJlbCIsZGlzcE5hbWU6Ik1vdmFibGUgTGFiZWwiLHR5cGU6ImJvb2wiLGRlZlZhbDohMSxpc1Zpc2libGU6ZnVuY3Rpb24oYSwKYil7dmFyIGU9MDxhLnZlcnRpY2VzLmxlbmd0aD9iLmVkaXRvclVpLmVkaXRvci5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoYS52ZXJ0aWNlc1swXSk6bnVsbDtyZXR1cm4gbnVsbCE9ZSYmIWUucmVsYXRpdmV9fSx7bmFtZToicmVzaXphYmxlIixkaXNwTmFtZToiUmVzaXphYmxlIix0eXBlOiJib29sIixkZWZWYWw6ITB9LHtuYW1lOiJyZXNpemVXaWR0aCIsZGlzcE5hbWU6IlJlc2l6ZSBXaWR0aCIsdHlwZToiYm9vbCIsZGVmVmFsOiExfSx7bmFtZToicmVzaXplSGVpZ2h0IixkaXNwTmFtZToiUmVzaXplIEhlaWdodCIsdHlwZToiYm9vbCIsZGVmVmFsOiExfSx7bmFtZToicm90YXRhYmxlIixkaXNwTmFtZToiUm90YXRhYmxlIix0eXBlOiJib29sIixkZWZWYWw6ITB9LHtuYW1lOiJjbG9uZWFibGUiLGRpc3BOYW1lOiJDbG9uZWFibGUiLHR5cGU6ImJvb2wiLGRlZlZhbDohMH0se25hbWU6ImRlbGV0YWJsZSIsZGlzcE5hbWU6IkRlbGV0YWJsZSIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfSwKe25hbWU6InRyZWVGb2xkaW5nIixkaXNwTmFtZToiVHJlZSBGb2xkaW5nIix0eXBlOiJib29sIixkZWZWYWw6ITF9LHtuYW1lOiJ0cmVlTW92aW5nIixkaXNwTmFtZToiVHJlZSBNb3ZpbmciLHR5cGU6ImJvb2wiLGRlZlZhbDohMX0se25hbWU6InBvaW50ZXJFdmVudHMiLGRpc3BOYW1lOiJQb2ludGVyIEV2ZW50cyIsdHlwZToiYm9vbCIsZGVmVmFsOiEwLGlzVmlzaWJsZTpmdW5jdGlvbihhLGIpe3ZhciBlPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GSUxMQ09MT1IsbnVsbCk7cmV0dXJuIGIuZWRpdG9yVWkuZWRpdG9yLmdyYXBoLmlzU3dpbWxhbmUoYS52ZXJ0aWNlc1swXSl8fG51bGw9PWV8fGU9PW14Q29uc3RhbnRzLk5PTkV9fSx7bmFtZToibW92ZUNlbGxzIixkaXNwTmFtZToiTW92ZSBDZWxscyBvbiBGb2xkIix0eXBlOiJib29sIixkZWZWYWw6ITEsaXNWaXNpYmxlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIDA8YS52ZXJ0aWNlcy5sZW5ndGgmJgpiLmVkaXRvclVpLmVkaXRvci5ncmFwaC5pc0NvbnRhaW5lcihhLnZlcnRpY2VzWzBdKX19XTtFZGl0b3IuZGVmYXVsdENzdlZhbHVlPScjI1xuIyMgRXhhbXBsZSBDU1YgaW1wb3J0LiBVc2UgIyMgZm9yIGNvbW1lbnRzIGFuZCAjIGZvciBjb25maWd1cmF0aW9uLiBQYXN0ZSBDU1YgYmVsb3cuXG4jIyBUaGUgZm9sbG93aW5nIG5hbWVzIGFyZSByZXNlcnZlZCBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIChvciBpZ25vcmVkKTpcbiMjIGlkLCB0b29sdGlwLCBwbGFjZWhvbGRlcihzKSwgbGluayBhbmQgbGFiZWwgKHNlZSBiZWxvdylcbiMjXG4jXG4jIyBOb2RlIGxhYmVsIHdpdGggcGxhY2Vob2xkZXJzIGFuZCBIVE1MLlxuIyMgRGVmYXVsdCBpcyBcJyVuYW1lX29mX2ZpcnN0X2NvbHVtbiVcJy5cbiNcbiMgbGFiZWw6ICVuYW1lJTxicj48aSBzdHlsZT0iY29sb3I6Z3JheTsiPiVwb3NpdGlvbiU8L2k+PGJyPjxhIGhyZWY9Im1haWx0bzolZW1haWwlIj5FbWFpbDwvYT5cbiNcbiMjIE5vZGUgc3R5bGUgKHBsYWNlaG9sZGVycyBhcmUgcmVwbGFjZWQgb25jZSkuXG4jIyBEZWZhdWx0IGlzIHRoZSBjdXJyZW50IHN0eWxlIGZvciBub2Rlcy5cbiNcbiMgc3R5bGU6IGxhYmVsO2ltYWdlPSVpbWFnZSU7d2hpdGVTcGFjZT13cmFwO2h0bWw9MTtyb3VuZGVkPTE7ZmlsbENvbG9yPSVmaWxsJTtzdHJva2VDb2xvcj0lc3Ryb2tlJTtcbiNcbiMjIFBhcmVudCBzdHlsZSBmb3Igbm9kZXMgd2l0aCBjaGlsZCBub2RlcyAocGxhY2Vob2xkZXJzIGFyZSByZXBsYWNlZCBvbmNlKS5cbiNcbiMgcGFyZW50c3R5bGU6IHN3aW1sYW5lO3doaXRlU3BhY2U9d3JhcDtodG1sPTE7Y2hpbGRMYXlvdXQ9c3RhY2tMYXlvdXQ7aG9yaXpvbnRhbD0xO2hvcml6b250YWxTdGFjaz0wO3Jlc2l6ZVBhcmVudD0xO3Jlc2l6ZUxhc3Q9MDtjb2xsYXBzaWJsZT0xO1xuI1xuIyMgT3B0aW9uYWwgY29sdW1uIG5hbWUgdGhhdCBjb250YWlucyBhIHJlZmVyZW5jZSB0byBhIG5hbWVkIHN0eWxlIGluIHN0eWxlcy5cbiMjIERlZmF1bHQgaXMgdGhlIGN1cnJlbnQgc3R5bGUgZm9yIG5vZGVzLlxuI1xuIyBzdHlsZW5hbWU6IC1cbiNcbiMjIEpTT04gZm9yIG5hbWVkIHN0eWxlcyBvZiB0aGUgZm9ybSB7Im5hbWUiOiAic3R5bGUiLCAibmFtZSI6ICJzdHlsZSJ9IHdoZXJlIHN0eWxlIGlzIGEgY2VsbCBzdHlsZSB3aXRoXG4jIyBwbGFjZWhvbGRlcnMgdGhhdCBhcmUgcmVwbGFjZWQgb25jZS5cbiNcbiMgc3R5bGVzOiAtXG4jXG4jIyBPcHRpb25hbCBjb2x1bW4gbmFtZSB0aGF0IGNvbnRhaW5zIGEgcmVmZXJlbmNlIHRvIGEgbmFtZWQgbGFiZWwgaW4gbGFiZWxzLlxuIyMgRGVmYXVsdCBpcyB0aGUgY3VycmVudCBsYWJlbC5cbiNcbiMgbGFiZWxuYW1lOiAtXG4jXG4jIyBKU09OIGZvciBuYW1lZCBsYWJlbHMgb2YgdGhlIGZvcm0geyJuYW1lIjogImxhYmVsIiwgIm5hbWUiOiAibGFiZWwifSB3aGVyZSBsYWJlbCBpcyBhIGNlbGwgbGFiZWwgd2l0aFxuIyMgcGxhY2Vob2xkZXJzLlxuI1xuIyBsYWJlbHM6IC1cbiNcbiMjIFVzZXMgdGhlIGdpdmVuIGNvbHVtbiBuYW1lIGFzIHRoZSBpZGVudGl0eSBmb3IgY2VsbHMgKHVwZGF0ZXMgZXhpc3RpbmcgY2VsbHMpLlxuIyMgRGVmYXVsdCBpcyBubyBpZGVudGl0eSAoZW1wdHkgdmFsdWUgb3IgLSkuXG4jXG4jIGlkZW50aXR5OiAtXG4jXG4jIyBVc2VzIHRoZSBnaXZlbiBjb2x1bW4gbmFtZSBhcyB0aGUgcGFyZW50IHJlZmVyZW5jZSBmb3IgY2VsbHMuIERlZmF1bHQgaXMgbm8gcGFyZW50IChlbXB0eSBvciAtKS5cbiMjIFRoZSBpZGVudGl0eSBhYm92ZSBpcyB1c2VkIGZvciByZXNvbHZpbmcgdGhlIHJlZmVyZW5jZSBzbyBpdCBtdXN0IGJlIHNwZWNpZmllZC5cbiNcbiMgcGFyZW50OiAtXG4jXG4jIyBBZGRzIGEgcHJlZml4IHRvIHRoZSBpZGVudGl0eSBvZiBjZWxscyB0byBtYWtlIHN1cmUgdGhleSBkbyBub3QgY29sbGlkZSB3aXRoIGV4aXN0aW5nIGNlbGxzICh3aG9zZVxuIyMgSURzIGFyZSBudW1iZXJzIGZyb20gMC4ubiwgc29tZXRpbWVzIHdpdGggYSBHVUlEIHByZWZpeCBpbiB0aGUgY29udGV4dCBvZiByZWFsdGltZSBjb2xsYWJvcmF0aW9uKS5cbiMjIERlZmF1bHQgaXMgY3N2aW1wb3J0LS5cbiNcbiMgbmFtZXNwYWNlOiBjc3ZpbXBvcnQtXG4jXG4jIyBDb25uZWN0aW9ucyBiZXR3ZWVuIHJvd3MgKCJmcm9tIjogc291cmNlIGNvbHVtLCAidG8iOiB0YXJnZXQgY29sdW1uKS5cbiMjIExhYmVsLCBzdHlsZSBhbmQgaW52ZXJ0IGFyZSBvcHRpb25hbC4gRGVmYXVsdHMgYXJlIFwnXCcsIGN1cnJlbnQgc3R5bGUgYW5kIGZhbHNlLlxuIyMgSWYgcGxhY2Vob2xkZXJzIGFyZSB1c2VkIGluIHRoZSBzdHlsZSwgdGhleSBhcmUgcmVwbGFjZWQgd2l0aCBkYXRhIGZyb20gdGhlIHNvdXJjZS5cbiMjIEFuIG9wdGlvbmFsIHBsYWNlaG9sZGVycyBjYW4gYmUgc2V0IHRvIHRhcmdldCB0byB1c2UgZGF0YSBmcm9tIHRoZSB0YXJnZXQgaW5zdGVhZC5cbiMjIEluIGFkZGl0aW9uIHRvIGxhYmVsLCBhbiBvcHRpb25hbCBmcm9tbGFiZWwgYW5kIHRvbGFiZWwgY2FuIGJlIHVzZWQgdG8gbmFtZSB0aGUgY29sdW1uXG4jIyB0aGF0IGNvbnRhaW5zIHRoZSB0ZXh0IGZvciB0aGUgbGFiZWwgaW4gdGhlIGVkZ2VzIHNvdXJjZSBvciB0YXJnZXQgKGludmVydCBpZ25vcmVkKS5cbiMjIFRoZSBsYWJlbCBpcyBjb25jYXRlbmF0ZWQgaW4gdGhlIGZvcm0gZnJvbWxhYmVsICsgbGFiZWwgKyB0b2xhYmVsIGlmIGFsbCBhcmUgZGVmaW5lZC5cbiMjIEFkZGl0aW9uYWwgbGFiZWxzIGNhbiBiZSBhZGRlZCBieSB1c2luZyBhbiBvcHRpb25hbCBsYWJlbHMgYXJyYXkgd2l0aCBlbnRyaWVzIG9mIHRoZVxuIyMgZm9ybSB7ImxhYmVsIjogc3RyaW5nLCAieCI6IG51bWJlciwgInkiOiBudW1iZXIsICJkeCI6IG51bWJlciwgImR5IjogbnVtYmVyfSB3aGVyZVxuIyMgeCBpcyBmcm9tIC0xIHRvIDEgYWxvbmcgdGhlIGVkZ2UsIHkgaXMgb3J0aG9nb25hbCwgYW5kIGR4L2R5IGFyZSBvZmZzZXRzIGluIHBpeGVscy5cbiMjIFRoZSB0YXJnZXQgY29sdW1uIG1heSBjb250YWluIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdmFsdWVzLlxuIyMgTXVsdGlwbGUgY29ubmVjdCBlbnRyaWVzIGFyZSBhbGxvd2VkLlxuI1xuIyBjb25uZWN0OiB7ImZyb20iOiAibWFuYWdlciIsICJ0byI6ICJuYW1lIiwgImludmVydCI6IHRydWUsICJsYWJlbCI6ICJtYW5hZ2VzIiwgXFxcbiMgICAgICAgICAgInN0eWxlIjogImN1cnZlZD0xO2VuZEFycm93PWJsb2NrVGhpbjtlbmRGaWxsPTE7Zm9udFNpemU9MTE7In1cbiMgY29ubmVjdDogeyJmcm9tIjogInJlZnMiLCAidG8iOiAiaWQiLCAic3R5bGUiOiAiY3VydmVkPTE7Zm9udFNpemU9MTE7In1cbiNcbiMjIE5vZGUgeC1jb29yZGluYXRlLiBQb3NzaWJsZSB2YWx1ZSBpcyBhIGNvbHVtbiBuYW1lLiBEZWZhdWx0IGlzIGVtcHR5LiBMYXlvdXRzIHdpbGxcbiMjIG92ZXJyaWRlIHRoaXMgdmFsdWUuXG4jXG4jIGxlZnQ6IFxuI1xuIyMgTm9kZSB5LWNvb3JkaW5hdGUuIFBvc3NpYmxlIHZhbHVlIGlzIGEgY29sdW1uIG5hbWUuIERlZmF1bHQgaXMgZW1wdHkuIExheW91dHMgd2lsbFxuIyMgb3ZlcnJpZGUgdGhpcyB2YWx1ZS5cbiNcbiMgdG9wOiBcbiNcbiMjIE5vZGUgd2lkdGguIFBvc3NpYmxlIHZhbHVlIGlzIGEgbnVtYmVyIChpbiBweCksIGF1dG8gb3IgYW4gQCBzaWduIGZvbGxvd2VkIGJ5IGEgY29sdW1uXG4jIyBuYW1lIHRoYXQgY29udGFpbnMgdGhlIHZhbHVlIGZvciB0aGUgd2lkdGguIERlZmF1bHQgaXMgYXV0by5cbiNcbiMgd2lkdGg6IGF1dG9cbiNcbiMjIE5vZGUgaGVpZ2h0LiBQb3NzaWJsZSB2YWx1ZSBpcyBhIG51bWJlciAoaW4gcHgpLCBhdXRvIG9yIGFuIEAgc2lnbiBmb2xsb3dlZCBieSBhIGNvbHVtblxuIyMgbmFtZSB0aGF0IGNvbnRhaW5zIHRoZSB2YWx1ZSBmb3IgdGhlIGhlaWdodC4gRGVmYXVsdCBpcyBhdXRvLlxuI1xuIyBoZWlnaHQ6IGF1dG9cbiNcbiMjIFBhZGRpbmcgZm9yIGF1dG9zaXplLiBEZWZhdWx0IGlzIDAuXG4jXG4jIHBhZGRpbmc6IC0xMlxuI1xuIyMgQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgaWdub3JlZCBjb2x1bW5zIGZvciBtZXRhZGF0YS4gKFRoZXNlIGNhbiBiZVxuIyMgdXNlZCBmb3IgY29ubmVjdGlvbnMgYW5kIHN0eWxlcyBidXQgd2lsbCBub3QgYmUgYWRkZWQgYXMgbWV0YWRhdGEuKVxuI1xuIyBpZ25vcmU6IGlkLGltYWdlLGZpbGwsc3Ryb2tlLHJlZnMsbWFuYWdlclxuI1xuIyMgQ29sdW1uIHRvIGJlIHJlbmFtZWQgdG8gbGluayBhdHRyaWJ1dGUgKHVzZWQgYXMgbGluaykuXG4jXG4jIGxpbms6IHVybFxuI1xuIyMgU3BhY2luZyBiZXR3ZWVuIG5vZGVzLiBEZWZhdWx0IGlzIDQwLlxuI1xuIyBub2Rlc3BhY2luZzogNDBcbiNcbiMjIFNwYWNpbmcgYmV0d2VlbiBsZXZlbHMgb2YgaGllcmFyY2hpY2FsIGxheW91dHMuIERlZmF1bHQgaXMgMTAwLlxuI1xuIyBsZXZlbHNwYWNpbmc6IDEwMFxuI1xuIyMgU3BhY2luZyBiZXR3ZWVuIHBhcmFsbGVsIGVkZ2VzLiBEZWZhdWx0IGlzIDQwLiBVc2UgMCB0byBkaXNhYmxlLlxuI1xuIyBlZGdlc3BhY2luZzogNDBcbiNcbiMjIE5hbWUgb3IgSlNPTiBvZiBsYXlvdXQuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYXV0bywgbm9uZSwgdmVydGljYWx0cmVlLCBob3Jpem9udGFsdHJlZSxcbiMjIHZlcnRpY2FsZmxvdywgaG9yaXpvbnRhbGZsb3csIG9yZ2FuaWMsIGNpcmNsZSBvciBhIEpTT04gc3RyaW5nIGFzIHVzZWQgaW4gTGF5b3V0LCBBcHBseS5cbiMjIERlZmF1bHQgaXMgYXV0by5cbiNcbiMgbGF5b3V0OiBhdXRvXG4jXG4jIyAtLS0tIENTViBiZWxvdyB0aGlzIGxpbmUuIEZpcnN0IGxpbmUgYXJlIGNvbHVtbiBuYW1lcy4gLS0tLVxubmFtZSxwb3NpdGlvbixpZCxsb2NhdGlvbixtYW5hZ2VyLGVtYWlsLGZpbGwsc3Ryb2tlLHJlZnMsdXJsLGltYWdlXG5FdmFuIE1pbGxlcixDRk8sZW1pLE9mZmljZSAxLCxtZUBleGFtcGxlLmNvbSwjZGFlOGZjLCM2YzhlYmYsLGh0dHBzOi8vd3d3LmRyYXcuaW8saHR0cHM6Ly9jZG4zLmljb25maW5kZXIuY29tL2RhdGEvaWNvbnMvdXNlci1hdmF0YXJzLTEvNTEyL3VzZXJzLTktMi0xMjgucG5nXG5FZHdhcmQgTW9ycmlzb24sQnJhbmQgTWFuYWdlcixlbW8sT2ZmaWNlIDIsRXZhbiBNaWxsZXIsbWVAZXhhbXBsZS5jb20sI2Q1ZThkNCwjODJiMzY2LCxodHRwczovL3d3dy5kcmF3LmlvLGh0dHBzOi8vY2RuMy5pY29uZmluZGVyLmNvbS9kYXRhL2ljb25zL3VzZXItYXZhdGFycy0xLzUxMi91c2Vycy0xMC0zLTEyOC5wbmdcblJvbiBEb25vdmFuLFN5c3RlbSBBZG1pbixyZG8sT2ZmaWNlIDMsRXZhbiBNaWxsZXIsbWVAZXhhbXBsZS5jb20sI2Q1ZThkNCwjODJiMzY2LCJlbW8sdHZhIixodHRwczovL3d3dy5kcmF3LmlvLGh0dHBzOi8vY2RuMy5pY29uZmluZGVyLmNvbS9kYXRhL2ljb25zL3VzZXItYXZhdGFycy0xLzUxMi91c2Vycy0yLTEyOC5wbmdcblRlc3NhIFZhbGV0LEhSIERpcmVjdG9yLHR2YSxPZmZpY2UgNCxFdmFuIE1pbGxlcixtZUBleGFtcGxlLmNvbSwjZDVlOGQ0LCM4MmIzNjYsLGh0dHBzOi8vd3d3LmRyYXcuaW8saHR0cHM6Ly9jZG4zLmljb25maW5kZXIuY29tL2RhdGEvaWNvbnMvdXNlci1hdmF0YXJzLTEvNTEyL3VzZXJzLTMtMTI4LnBuZ1xuJzsKRWRpdG9yLmZhc3RDb21wcmVzcz1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09YXx8MD09YS5sZW5ndGh8fCJ1bmRlZmluZWQiPT09dHlwZW9mIHBha28/YTpwYWtvLmRlZmxhdGVSYXcoYSx7dG86InN0cmluZyJ9KX07RWRpdG9yLmZhc3REZWNvbXByZXNzPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hfHwwPT1hLmxlbmd0aHx8InVuZGVmaW5lZCI9PT10eXBlb2YgcGFrbz9hOnBha28uaW5mbGF0ZVJhdyhhLHt0bzoic3RyaW5nIn0pfTtFZGl0b3IuZXh0cmFjdEdyYXBoTW9kZWw9ZnVuY3Rpb24oYSxiLGUpe2lmKG51bGwhPWEmJiJ1bmRlZmluZWQiIT09dHlwZW9mIHBha28pe3ZhciBjPWEub3duZXJEb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGl2IiksZD1bXTtpZihudWxsIT1jJiYwPGMubGVuZ3RoKWZvcih2YXIgZj0wO2Y8Yy5sZW5ndGg7ZisrKWlmKCJteGdyYXBoIj09Y1tmXS5nZXRBdHRyaWJ1dGUoImNsYXNzIikpe2QucHVzaChjW2ZdKTticmVha30wPGQubGVuZ3RoJiYKKGM9ZFswXS5nZXRBdHRyaWJ1dGUoImRhdGEtbXhncmFwaCIpLG51bGwhPWM/KGQ9SlNPTi5wYXJzZShjKSxudWxsIT1kJiZudWxsIT1kLnhtbCYmKGE9bXhVdGlscy5wYXJzZVhtbChkLnhtbCksYT1hLmRvY3VtZW50RWxlbWVudCkpOihkPWRbMF0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpLDA8ZC5sZW5ndGgmJihjPW14VXRpbHMuZ2V0VGV4dENvbnRlbnQoZFswXSksYz1HcmFwaC5kZWNvbXByZXNzKGMsbnVsbCxlKSwwPGMubGVuZ3RoJiYoYT1teFV0aWxzLnBhcnNlWG1sKGMpLGE9YS5kb2N1bWVudEVsZW1lbnQpKSkpfWlmKG51bGwhPWEmJiJzdmciPT1hLm5vZGVOYW1lKWlmKGM9YS5nZXRBdHRyaWJ1dGUoImNvbnRlbnQiKSxudWxsIT1jJiYiPCIhPWMuY2hhckF0KDApJiYiJSIhPWMuY2hhckF0KDApJiYoYz11bmVzY2FwZSh3aW5kb3cuYXRvYj9hdG9iKGMpOkJhc2U2NC5kZWNvZGUoY29udCxjKSkpLG51bGwhPWMmJiIlIj09Yy5jaGFyQXQoMCkmJihjPWRlY29kZVVSSUNvbXBvbmVudChjKSksCm51bGwhPWMmJjA8Yy5sZW5ndGgpYT1teFV0aWxzLnBhcnNlWG1sKGMpLmRvY3VtZW50RWxlbWVudDtlbHNlIHRocm93e21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJub3RBRGlhZ3JhbUZpbGUiKX07bnVsbD09YXx8Ynx8KGQ9bnVsbCwiZGlhZ3JhbSI9PWEubm9kZU5hbWU/ZD1hOiJteGZpbGUiPT1hLm5vZGVOYW1lJiYoYz1hLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaWFncmFtIiksMDxjLmxlbmd0aCYmKGQ9Y1tNYXRoLm1heCgwLE1hdGgubWluKGMubGVuZ3RoLTEsdXJsUGFyYW1zLnBhZ2V8fDApKV0pKSxudWxsIT1kJiYoYT1FZGl0b3IucGFyc2VEaWFncmFtTm9kZShkLGUpKSk7bnVsbD09YXx8Im14R3JhcGhNb2RlbCI9PWEubm9kZU5hbWV8fGImJiJteGZpbGUiPT1hLm5vZGVOYW1lfHwoYT1udWxsKTtyZXR1cm4gYX07RWRpdG9yLnBhcnNlRGlhZ3JhbU5vZGU9ZnVuY3Rpb24oYSxiKXt2YXIgZT1teFV0aWxzLnRyaW0obXhVdGlscy5nZXRUZXh0Q29udGVudChhKSksYz1udWxsOwowPGUubGVuZ3RoPyhlPUdyYXBoLmRlY29tcHJlc3MoZSxudWxsLGIpLG51bGwhPWUmJjA8ZS5sZW5ndGgmJihjPW14VXRpbHMucGFyc2VYbWwoZSkuZG9jdW1lbnRFbGVtZW50KSk6KGU9bXhVdGlscy5nZXRDaGlsZE5vZGVzKGEpLDA8ZS5sZW5ndGgmJihjPW14VXRpbHMuY3JlYXRlWG1sRG9jdW1lbnQoKSxjLmFwcGVuZENoaWxkKGMuaW1wb3J0Tm9kZShlWzBdLCEwKSksYz1jLmRvY3VtZW50RWxlbWVudCkpO3JldHVybiBjfTtFZGl0b3IuZ2V0RGlhZ3JhbU5vZGVYbWw9ZnVuY3Rpb24oYSl7dmFyIGI9bXhVdGlscy5nZXRUZXh0Q29udGVudChhKSxlPW51bGw7MDxiLmxlbmd0aD9lPUdyYXBoLmRlY29tcHJlc3MoYik6bnVsbCE9YS5maXJzdENoaWxkJiYoZT1teFV0aWxzLmdldFhtbChhLmZpcnN0Q2hpbGQpKTtyZXR1cm4gZX07RWRpdG9yLmV4dHJhY3RHcmFwaE1vZGVsRnJvbVBkZj1mdW5jdGlvbihhKXthPWEuc3Vic3RyaW5nKGEuaW5kZXhPZigiLCIpKzEpO2E9d2luZG93LmF0b2ImJgohbXhDbGllbnQuSVNfU0Y/YXRvYihhKTpCYXNlNjQuZGVjb2RlKGEsITApO2Zvcih2YXIgYj1udWxsLGU9IiIsYz0wLGQ9MCxmPVtdLGc9bnVsbDtkPGEubGVuZ3RoOyl7dmFyIGw9YS5jaGFyQ29kZUF0KGQpLGQ9ZCsxOzEwIT1sJiYoZSs9U3RyaW5nLmZyb21DaGFyQ29kZShsKSk7bD09Ii9TdWJqZWN0ICglM0NteGZpbGUiLmNoYXJDb2RlQXQoYyk/YysrOmM9MDtpZigxOT09Yyl7dmFyIHA9YS5pbmRleE9mKCIlM0MlMkZteGZpbGUlM0UpIixkKSsxNSxkPWQtOTtpZihwPmQpe2I9YS5zdWJzdHJpbmcoZCxwKTticmVha319MTA9PWwmJigiZW5kb2JqIj09ZT9nPW51bGw6Im9iaiI9PWUuc3Vic3RyaW5nKGUubGVuZ3RoLTMsZS5sZW5ndGgpfHwieHJlZiI9PWV8fCJ0cmFpbGVyIj09ZT8oZz1bXSxmW2Uuc3BsaXQoIiAiKVswXV09Zyk6bnVsbCE9ZyYmZy5wdXNoKGUpLGU9IiIpfW51bGw9PWImJihiPUVkaXRvci5leHRyYWN0R3JhcGhNb2RlbEZyb21YcmVmKGYpKTtudWxsIT1iJiYKKGI9ZGVjb2RlVVJJQ29tcG9uZW50KGIucmVwbGFjZSgvXFxcKC9nLCIoIikucmVwbGFjZSgvXFxcKS9nLCIpIikpKTtyZXR1cm4gYn07RWRpdG9yLmV4dHJhY3RHcmFwaE1vZGVsRnJvbVhyZWY9ZnVuY3Rpb24oYSl7dmFyIGI9YS50cmFpbGVyLGU9bnVsbDtudWxsIT1iJiYoYj0vLiogXC9JbmZvIChcZCspIChcZCspIFIvZy5leGVjKGIuam9pbigiXG4iKSksbnVsbCE9YiYmMDxiLmxlbmd0aCYmKGI9YVtiWzFdXSxudWxsIT1iJiYoYj0vLiogXC9TdWJqZWN0IChcZCspIChcZCspIFIvZy5leGVjKGIuam9pbigiXG4iKSksbnVsbCE9YiYmMDxiLmxlbmd0aCYmKGE9YVtiWzFdXSxudWxsIT1hJiYoYT1hLmpvaW4oIlxuIiksZT1hLnN1YnN0cmluZygxLGEubGVuZ3RoLTEpKSkpKSk7cmV0dXJuIGV9O0VkaXRvci5leHRyYWN0R3JhcGhNb2RlbEZyb21Qbmc9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbDt0cnl7dmFyIGU9YS5zdWJzdHJpbmcoYS5pbmRleE9mKCIsIikrMSksYz13aW5kb3cuYXRvYiYmCiFteENsaWVudC5JU19TRj9hdG9iKGUpOkJhc2U2NC5kZWNvZGUoZSwhMCk7RWRpdG9yVWkucGFyc2VQbmcoYyxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGUsZCl7YT1jLnN1YnN0cmluZyhhKzgsYSs4K2QpOyJ6VFh0Ij09ZT8oZD1hLmluZGV4T2YoU3RyaW5nLmZyb21DaGFyQ29kZSgwKSksIm14R3JhcGhNb2RlbCI9PWEuc3Vic3RyaW5nKDAsZCkmJihhPXBha28uaW5mbGF0ZVJhdyhhLnN1YnN0cmluZyhkKzIpLHt0bzoic3RyaW5nIn0pLnJlcGxhY2UoL1wrL2csIiAiKSxudWxsIT1hJiYwPGEubGVuZ3RoJiYoYj1hKSkpOiJ0RVh0Ij09ZSYmKGE9YS5zcGxpdChTdHJpbmcuZnJvbUNoYXJDb2RlKDApKSwxPGEubGVuZ3RoJiYoIm14R3JhcGhNb2RlbCI9PWFbMF18fCJteGZpbGUiPT1hWzBdKSYmKGI9YVsxXSkpO2lmKG51bGwhPWJ8fCJJREFUIj09ZSlyZXR1cm4hMH0pKX1jYXRjaChQKXt9bnVsbCE9YiYmIiUiPT1iLmNoYXJBdCgwKSYmKGI9ZGVjb2RlVVJJQ29tcG9uZW50KGIpKTsKbnVsbCE9YiYmIiUiPT1iLmNoYXJBdCgwKSYmKGI9ZGVjb2RlVVJJQ29tcG9uZW50KGIpKTtyZXR1cm4gYn07RWRpdG9yLmV4dHJhY3RQYXJzZXJFcnJvcj1mdW5jdGlvbihhLGIpe3ZhciBlPW51bGwsYz1udWxsIT1hP2EuZ2V0RWxlbWVudHNCeVRhZ05hbWUoInBhcnNlcmVycm9yIik6bnVsbDtudWxsIT1jJiYwPGMubGVuZ3RoJiYoZT1ifHxteFJlc291cmNlcy5nZXQoImludmFsaWRDaGFycyIpLGM9Y1swXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGl2IiksMDxjLmxlbmd0aCYmKGU9bXhVdGlscy5nZXRUZXh0Q29udGVudChjWzBdKSkpO3JldHVybiBudWxsIT1lP214VXRpbHMudHJpbShlKTplfTtFZGl0b3IuY29uZmlndXJlPWZ1bmN0aW9uKGEsYil7aWYobnVsbCE9YSl7RWRpdG9yLmNvbmZpZz1hO0VkaXRvci5jb25maWdWZXJzaW9uPWEudmVyc2lvbjtNZW51cy5wcm90b3R5cGUuZGVmYXVsdEZvbnRzPWEuZGVmYXVsdEZvbnRzfHxNZW51cy5wcm90b3R5cGUuZGVmYXVsdEZvbnRzOwpDb2xvckRpYWxvZy5wcm90b3R5cGUucHJlc2V0Q29sb3JzPWEucHJlc2V0Q29sb3JzfHxDb2xvckRpYWxvZy5wcm90b3R5cGUucHJlc2V0Q29sb3JzO0NvbG9yRGlhbG9nLnByb3RvdHlwZS5kZWZhdWx0Q29sb3JzPWEuZGVmYXVsdENvbG9yc3x8Q29sb3JEaWFsb2cucHJvdG90eXBlLmRlZmF1bHRDb2xvcnM7U3R5bGVGb3JtYXRQYW5lbC5wcm90b3R5cGUuZGVmYXVsdENvbG9yU2NoZW1lcz1hLmRlZmF1bHRDb2xvclNjaGVtZXN8fFN0eWxlRm9ybWF0UGFuZWwucHJvdG90eXBlLmRlZmF1bHRDb2xvclNjaGVtZXM7R3JhcGgucHJvdG90eXBlLmRlZmF1bHRFZGdlTGVuZ3RoPWEuZGVmYXVsdEVkZ2VMZW5ndGh8fEdyYXBoLnByb3RvdHlwZS5kZWZhdWx0RWRnZUxlbmd0aDtEcmF3aW9GaWxlLnByb3RvdHlwZS5hdXRvc2F2ZURlbGF5PWEuYXV0b3NhdmVEZWxheXx8RHJhd2lvRmlsZS5wcm90b3R5cGUuYXV0b3NhdmVEZWxheTtudWxsIT1hLnRlbXBsYXRlRmlsZSYmKEVkaXRvclVpLnRlbXBsYXRlRmlsZT0KYS50ZW1wbGF0ZUZpbGUpO251bGwhPWEuZ2xvYmFsVmFycyYmKEVkaXRvci5nbG9iYWxWYXJzPWEuZ2xvYmFsVmFycyk7bnVsbCE9YS5jb21wcmVzc1htbCYmKEVkaXRvci5jb21wcmVzc1htbD1hLmNvbXByZXNzWG1sKTthLmN1c3RvbUZvbnRzJiYoTWVudXMucHJvdG90eXBlLmRlZmF1bHRGb250cz1hLmN1c3RvbUZvbnRzLmNvbmNhdChNZW51cy5wcm90b3R5cGUuZGVmYXVsdEZvbnRzKSk7YS5jdXN0b21QcmVzZXRDb2xvcnMmJihDb2xvckRpYWxvZy5wcm90b3R5cGUucHJlc2V0Q29sb3JzPWEuY3VzdG9tUHJlc2V0Q29sb3JzLmNvbmNhdChDb2xvckRpYWxvZy5wcm90b3R5cGUucHJlc2V0Q29sb3JzKSk7bnVsbCE9YS5jdXN0b21Db2xvclNjaGVtZXMmJihTdHlsZUZvcm1hdFBhbmVsLnByb3RvdHlwZS5kZWZhdWx0Q29sb3JTY2hlbWVzPWEuY3VzdG9tQ29sb3JTY2hlbWVzLmNvbmNhdChTdHlsZUZvcm1hdFBhbmVsLnByb3RvdHlwZS5kZWZhdWx0Q29sb3JTY2hlbWVzKSk7aWYobnVsbCE9CmEuY3NzKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzdHlsZSIpO2Uuc2V0QXR0cmlidXRlKCJ0eXBlIiwidGV4dC9jc3MiKTtlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGEuY3NzKSk7dmFyIGM9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoInNjcmlwdCIpWzBdO2MucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZSxjKX1udWxsIT1hLmxpYnJhcmllcyYmKFNpZGViYXIucHJvdG90eXBlLmN1c3RvbUVudHJpZXM9YS5saWJyYXJpZXMpO251bGwhPWEuZW5hYmxlZExpYnJhcmllcyYmKFNpZGViYXIucHJvdG90eXBlLmVuYWJsZWRMaWJyYXJpZXM9YS5lbmFibGVkTGlicmFyaWVzKTtudWxsIT1hLmRlZmF1bHRMaWJyYXJpZXMmJihTaWRlYmFyLnByb3RvdHlwZS5kZWZhdWx0RW50cmllcz1hLmRlZmF1bHRMaWJyYXJpZXMpO251bGwhPWEuZGVmYXVsdEN1c3RvbUxpYnJhcmllcyYmKEVkaXRvci5kZWZhdWx0Q3VzdG9tTGlicmFyaWVzPWEuZGVmYXVsdEN1c3RvbUxpYnJhcmllcyk7Cm51bGwhPWEuZW5hYmxlQ3VzdG9tTGlicmFyaWVzJiYoRWRpdG9yLmVuYWJsZUN1c3RvbUxpYnJhcmllcz1hLmVuYWJsZUN1c3RvbUxpYnJhcmllcyk7bnVsbCE9YS5kZWZhdWx0VmVydGV4U3R5bGUmJihHcmFwaC5wcm90b3R5cGUuZGVmYXVsdFZlcnRleFN0eWxlPWEuZGVmYXVsdFZlcnRleFN0eWxlKTtudWxsIT1hLmRlZmF1bHRFZGdlU3R5bGUmJihHcmFwaC5wcm90b3R5cGUuZGVmYXVsdEVkZ2VTdHlsZT1hLmRlZmF1bHRFZGdlU3R5bGUpO2EuZW1wdHlEaWFncmFtWG1sJiYoRWRpdG9yVWkucHJvdG90eXBlLmVtcHR5RGlhZ3JhbVhtbD1hLmVtcHR5RGlhZ3JhbVhtbCk7YS50aHVtYldpZHRoJiYoU2lkZWJhci5wcm90b3R5cGUudGh1bWJXaWR0aD1hLnRodW1iV2lkdGgpO2EudGh1bWJIZWlnaHQmJihTaWRlYmFyLnByb3RvdHlwZS50aHVtYkhlaWdodD1hLnRodW1iSGVpZ2h0KTthLmVtcHR5TGlicmFyeVhtbCYmKEVkaXRvclVpLnByb3RvdHlwZS5lbXB0eUxpYnJhcnlYbWw9YS5lbXB0eUxpYnJhcnlYbWwpOwphLnNpZGViYXJXaWR0aCYmKEVkaXRvclVpLnByb3RvdHlwZS5oc3BsaXRQb3NpdGlvbj1hLnNpZGViYXJXaWR0aCk7YS5mb250Q3NzJiZFZGl0b3IuY29uZmlndXJlRm9udENzcyhhLmZvbnRDc3MpO251bGwhPWEuYXV0b3NhdmVEZWxheSYmKGU9cGFyc2VJbnQoYS5hdXRvc2F2ZURlbGF5KSwhaXNOYU4oZSkmJjA8ZT9EcmF3aW9GaWxlLnByb3RvdHlwZS5hdXRvc2F2ZURlbGF5PWU6RWRpdG9yVWkuZGVidWcoIkludmFsaWQgYXV0b3NhdmVEZWxheTogIithLmF1dG9zYXZlRGVsYXkpKTtpZihudWxsIT1hLnBsdWdpbnMmJiFiKWZvcihBcHAuaW5pdFBsdWdpbkNhbGxiYWNrKCksZT0wO2U8YS5wbHVnaW5zLmxlbmd0aDtlKyspbXhzY3JpcHQoYS5wbHVnaW5zW2VdKX19O0VkaXRvci5jb25maWd1cmVGb250Q3NzPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe0VkaXRvci5wcm90b3R5cGUuZm9udENzcz1hO3ZhciBiPWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJzY3JpcHQiKVswXTsKaWYobnVsbCE9YiYmbnVsbCE9Yi5wYXJlbnROb2RlKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzdHlsZSIpO2Uuc2V0QXR0cmlidXRlKCJ0eXBlIiwidGV4dC9jc3MiKTtlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGEpKTtiLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsYik7YT1hLnNwbGl0KCJ1cmwoIik7Zm9yKGU9MTtlPGEubGVuZ3RoO2UrKyl7dmFyIGM9YVtlXS5pbmRleE9mKCIpIiksYz1FZGl0b3IudHJpbUNzc1VybChhW2VdLnN1YnN0cmluZygwLGMpKSxkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImxpbmsiKTtkLnNldEF0dHJpYnV0ZSgicmVsIiwicHJlbG9hZCIpO2Quc2V0QXR0cmlidXRlKCJocmVmIixjKTtkLnNldEF0dHJpYnV0ZSgiYXMiLCJmb250Iik7ZC5zZXRBdHRyaWJ1dGUoImNyb3Nzb3JpZ2luIiwiIik7Yi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkLGIpfX19fTtFZGl0b3IudHJpbUNzc1VybD1mdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKFJlZ0V4cCgiXltcXHNcIiddKyIsCiJnIiksIiIpLnJlcGxhY2UoUmVnRXhwKCJbXFxzXCInXSskIiwiZyIpLCIiKX07RWRpdG9yLkdPT0dMRV9GT05UUz0iaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PSI7RWRpdG9yLkdVSURfQUxQSEFCRVQ9IjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaLV8iO0VkaXRvci5HVUlEX0xFTkdUSD0yMDtFZGl0b3IuZ3VpZD1mdW5jdGlvbihhKXthPW51bGwhPWE/YTpFZGl0b3IuR1VJRF9MRU5HVEg7Zm9yKHZhciBiPVtdLGU9MDtlPGE7ZSsrKWIucHVzaChFZGl0b3IuR1VJRF9BTFBIQUJFVC5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKkVkaXRvci5HVUlEX0FMUEhBQkVULmxlbmd0aCkpKTtyZXR1cm4gYi5qb2luKCIiKX07RWRpdG9yLnByb3RvdHlwZS50aW1lb3V0PTI1RTM7RWRpdG9yLnByb3RvdHlwZS51c2VGb3JlaWduT2JqZWN0Rm9yTWF0aD0hbXhDbGllbnQuSVNfU0Y7RWRpdG9yLnByb3RvdHlwZS5lZGl0QnV0dG9uTGluaz0KbnVsbCE9dXJsUGFyYW1zLmVkaXQ/ZGVjb2RlVVJJQ29tcG9uZW50KHVybFBhcmFtcy5lZGl0KTpudWxsO0VkaXRvci5wcm90b3R5cGUuY3Jvc3NPcmlnaW5JbWFnZXM9IW14Q2xpZW50LklTX0lFO3ZhciBhPUVkaXRvci5wcm90b3R5cGUuc2V0R3JhcGhYbWw7RWRpdG9yLnByb3RvdHlwZS5zZXRHcmFwaFhtbD1mdW5jdGlvbihiKXtiPW51bGwhPWImJiJteGxpYnJhcnkiIT1iLm5vZGVOYW1lP3RoaXMuZXh0cmFjdEdyYXBoTW9kZWwoYik6bnVsbDtpZihudWxsIT1iKXt2YXIgZT1iLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJwYXJzZXJlcnJvciIpO2lmKG51bGwhPWUmJjA8ZS5sZW5ndGgpe3ZhciBlPWVbMF0sYz1lLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaXYiKTtudWxsIT1jJiYwPGMubGVuZ3RoJiYoZT1jWzBdKTt0aHJvd3ttZXNzYWdlOm14VXRpbHMuZ2V0VGV4dENvbnRlbnQoZSl9O31pZigibXhHcmFwaE1vZGVsIj09Yi5ub2RlTmFtZSl7ZT1iLmdldEF0dHJpYnV0ZSgic3R5bGUiKXx8CiJkZWZhdWx0LXN0eWxlMiI7aWYoIjEiPT11cmxQYXJhbXMuZW1iZWR8fG51bGwhPWUmJiIiIT1lKWUhPXRoaXMuZ3JhcGguY3VycmVudFN0eWxlJiYoYz1udWxsIT10aGlzLmdyYXBoLnRoZW1lcz90aGlzLmdyYXBoLnRoZW1lc1tlXTpteFV0aWxzLmxvYWQoU1RZTEVfUEFUSCsiLyIrZSsiLnhtbCIpLmdldERvY3VtZW50RWxlbWVudCgpLG51bGwhPWMmJihkPW5ldyBteENvZGVjKGMub3duZXJEb2N1bWVudCksZC5kZWNvZGUoYyx0aGlzLmdyYXBoLmdldFN0eWxlc2hlZXQoKSkpKTtlbHNlIGlmKGM9bnVsbCE9dGhpcy5ncmFwaC50aGVtZXM/dGhpcy5ncmFwaC50aGVtZXNbImRlZmF1bHQtb2xkIl06bXhVdGlscy5sb2FkKFNUWUxFX1BBVEgrIi9kZWZhdWx0LW9sZC54bWwiKS5nZXREb2N1bWVudEVsZW1lbnQoKSxudWxsIT1jKXt2YXIgZD1uZXcgbXhDb2RlYyhjLm93bmVyRG9jdW1lbnQpO2QuZGVjb2RlKGMsdGhpcy5ncmFwaC5nZXRTdHlsZXNoZWV0KCkpfXRoaXMuZ3JhcGguY3VycmVudFN0eWxlPQplO3RoaXMuZ3JhcGgubWF0aEVuYWJsZWQ9IjEiPT11cmxQYXJhbXMubWF0aHx8IjEiPT1iLmdldEF0dHJpYnV0ZSgibWF0aCIpO2U9Yi5nZXRBdHRyaWJ1dGUoImJhY2tncm91bmRJbWFnZSIpO251bGwhPWU/KGU9SlNPTi5wYXJzZShlKSx0aGlzLmdyYXBoLnNldEJhY2tncm91bmRJbWFnZShuZXcgbXhJbWFnZShlLnNyYyxlLndpZHRoLGUuaGVpZ2h0KSkpOnRoaXMuZ3JhcGguc2V0QmFja2dyb3VuZEltYWdlKG51bGwpO214Q2xpZW50Lk5PX0ZPPXRoaXMuZ3JhcGgubWF0aEVuYWJsZWQmJiF0aGlzLnVzZUZvcmVpZ25PYmplY3RGb3JNYXRoPyEwOnRoaXMub3JpZ2luYWxOb0ZvcmVpZ25PYmplY3Q7dGhpcy5ncmFwaC51c2VDc3NUcmFuc2Zvcm1zPSFteENsaWVudC5OT19GTyYmdGhpcy5pc0Nocm9tZWxlc3NWaWV3KCkmJnRoaXMuZ3JhcGguaXNDc3NUcmFuc2Zvcm1zU3VwcG9ydGVkKCk7dGhpcy5ncmFwaC51cGRhdGVDc3NUcmFuc2Zvcm0oKTt0aGlzLmdyYXBoLnNldFNoYWRvd1Zpc2libGUoIjEiPT0KYi5nZXRBdHRyaWJ1dGUoInNoYWRvdyIpLCExKTtpZihlPWIuZ2V0QXR0cmlidXRlKCJleHRGb250cyIpKXRyeXtmb3IoZT1lLnNwbGl0KCJ8IikubWFwKGZ1bmN0aW9uKGEpe2E9YS5zcGxpdCgiXiIpO3JldHVybntuYW1lOmFbMF0sdXJsOmFbMV19fSksYz0wO2M8ZS5sZW5ndGg7YysrKXRoaXMuZ3JhcGguYWRkRXh0Rm9udChlW2NdLm5hbWUsZVtjXS51cmwpfWNhdGNoKFApe2NvbnNvbGUubG9nKCJFeHRGb250cyBmb3JtYXQgZXJyb3I6ICIrUC5tZXNzYWdlKX19YS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZWxzZSB0aHJvd3ttZXNzYWdlOm14UmVzb3VyY2VzLmdldCgibm90QURpYWdyYW1GaWxlIil8fCJJbnZhbGlkIGRhdGEiLHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWVzc2FnZX19O307dmFyIGM9RWRpdG9yLnByb3RvdHlwZS5nZXRHcmFwaFhtbDtFZGl0b3IucHJvdG90eXBlLmdldEdyYXBoWG1sPWZ1bmN0aW9uKGEpe2E9bnVsbCE9YT9hOiEwO3ZhciBiPWMuYXBwbHkodGhpcywKYXJndW1lbnRzKTtudWxsIT10aGlzLmdyYXBoLmN1cnJlbnRTdHlsZSYmImRlZmF1bHQtc3R5bGUyIiE9dGhpcy5ncmFwaC5jdXJyZW50U3R5bGUmJmIuc2V0QXR0cmlidXRlKCJzdHlsZSIsdGhpcy5ncmFwaC5jdXJyZW50U3R5bGUpO251bGwhPXRoaXMuZ3JhcGguYmFja2dyb3VuZEltYWdlJiZiLnNldEF0dHJpYnV0ZSgiYmFja2dyb3VuZEltYWdlIixKU09OLnN0cmluZ2lmeSh0aGlzLmdyYXBoLmJhY2tncm91bmRJbWFnZSkpO2Iuc2V0QXR0cmlidXRlKCJtYXRoIix0aGlzLmdyYXBoLm1hdGhFbmFibGVkPyIxIjoiMCIpO2Iuc2V0QXR0cmlidXRlKCJzaGFkb3ciLHRoaXMuZ3JhcGguc2hhZG93VmlzaWJsZT8iMSI6IjAiKTtpZihudWxsIT10aGlzLmdyYXBoLmV4dEZvbnRzJiYwPHRoaXMuZ3JhcGguZXh0Rm9udHMubGVuZ3RoKXt2YXIgZT10aGlzLmdyYXBoLmV4dEZvbnRzLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gYS5uYW1lKyJeIithLnVybH0pO2Iuc2V0QXR0cmlidXRlKCJleHRGb250cyIsCmUuam9pbigifCIpKX1yZXR1cm4gYn07RWRpdG9yLnByb3RvdHlwZS5pc0RhdGFTdmc9ZnVuY3Rpb24oYSl7dHJ5e3ZhciBiPW14VXRpbHMucGFyc2VYbWwoYSkuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgiY29udGVudCIpO2lmKG51bGwhPWImJihudWxsIT1iJiYiPCIhPWIuY2hhckF0KDApJiYiJSIhPWIuY2hhckF0KDApJiYoYj11bmVzY2FwZSh3aW5kb3cuYXRvYj9hdG9iKGIpOkJhc2U2NC5kZWNvZGUoY29udCxiKSkpLG51bGwhPWImJiIlIj09Yi5jaGFyQXQoMCkmJihiPWRlY29kZVVSSUNvbXBvbmVudChiKSksbnVsbCE9YiYmMDxiLmxlbmd0aCkpe3ZhciBlPW14VXRpbHMucGFyc2VYbWwoYikuZG9jdW1lbnRFbGVtZW50O3JldHVybiJteGZpbGUiPT1lLm5vZGVOYW1lfHwibXhHcmFwaE1vZGVsIj09ZS5ub2RlTmFtZX19Y2F0Y2goTSl7fXJldHVybiExfTtFZGl0b3IucHJvdG90eXBlLmV4dHJhY3RHcmFwaE1vZGVsPWZ1bmN0aW9uKGEsYixlKXtyZXR1cm4gRWRpdG9yLmV4dHJhY3RHcmFwaE1vZGVsLmFwcGx5KHRoaXMsCmFyZ3VtZW50cyl9O3ZhciBmPUVkaXRvci5wcm90b3R5cGUucmVzZXRHcmFwaDtFZGl0b3IucHJvdG90eXBlLnJlc2V0R3JhcGg9ZnVuY3Rpb24oKXt0aGlzLmdyYXBoLm1hdGhFbmFibGVkPSIxIj09dXJsUGFyYW1zLm1hdGg7dGhpcy5ncmFwaC52aWV3LngwPW51bGw7dGhpcy5ncmFwaC52aWV3LnkwPW51bGw7bXhDbGllbnQuTk9fRk89dGhpcy5ncmFwaC5tYXRoRW5hYmxlZCYmIXRoaXMudXNlRm9yZWlnbk9iamVjdEZvck1hdGg/ITA6dGhpcy5vcmlnaW5hbE5vRm9yZWlnbk9iamVjdDt0aGlzLmdyYXBoLnVzZUNzc1RyYW5zZm9ybXM9IW14Q2xpZW50Lk5PX0ZPJiZ0aGlzLmlzQ2hyb21lbGVzc1ZpZXcoKSYmdGhpcy5ncmFwaC5pc0Nzc1RyYW5zZm9ybXNTdXBwb3J0ZWQoKTt0aGlzLmdyYXBoLnVwZGF0ZUNzc1RyYW5zZm9ybSgpO2YuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgZD1FZGl0b3IucHJvdG90eXBlLnVwZGF0ZUdyYXBoQ29tcG9uZW50cztFZGl0b3IucHJvdG90eXBlLnVwZGF0ZUdyYXBoQ29tcG9uZW50cz0KZnVuY3Rpb24oKXtkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtteENsaWVudC5OT19GTz10aGlzLmdyYXBoLm1hdGhFbmFibGVkJiYhdGhpcy51c2VGb3JlaWduT2JqZWN0Rm9yTWF0aCYmbnVsbCE9RWRpdG9yLk1hdGhKYXhSZW5kZXI/ITA6dGhpcy5vcmlnaW5hbE5vRm9yZWlnbk9iamVjdDt0aGlzLmdyYXBoLnVzZUNzc1RyYW5zZm9ybXM9IW14Q2xpZW50Lk5PX0ZPJiZ0aGlzLmlzQ2hyb21lbGVzc1ZpZXcoKSYmdGhpcy5ncmFwaC5pc0Nzc1RyYW5zZm9ybXNTdXBwb3J0ZWQoKTt0aGlzLmdyYXBoLnVwZGF0ZUNzc1RyYW5zZm9ybSgpfTtFZGl0b3IuaW5pdE1hdGg9ZnVuY3Rpb24oYSxiKXthPW51bGwhPWE/YTpEUkFXX01BVEhfVVJMKyIvTWF0aEpheC5qcyI7RWRpdG9yLm1hdGhKYXhRdWV1ZT1bXTtFZGl0b3IuZG9NYXRoSmF4UmVuZGVyPWZ1bmN0aW9uKGEpe3dpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ImhpZGRlbiIhPWEuc3R5bGUudmlzaWJpbGl0eSYmTWF0aEpheC5IdWIuUXVldWUoWyJUeXBlc2V0IiwKTWF0aEpheC5IdWIsYV0pfSwwKX07dmFyIGU9bnVsbCE9dXJsUGFyYW1zWyJtYXRoLWZvbnQiXT9kZWNvZGVVUklDb21wb25lbnQodXJsUGFyYW1zWyJtYXRoLWZvbnQiXSk6IlRlWCI7Yj1udWxsIT1iP2I6e2pheDpbImlucHV0L1RlWCIsImlucHV0L01hdGhNTCIsImlucHV0L0FzY2lpTWF0aCJdLmNvbmNhdChbImh0bWwiPT11cmxQYXJhbXNbIm1hdGgtb3V0cHV0Il0/Im91dHB1dC9IVE1MLUNTUyI6Im91dHB1dC9TVkciXSksZXh0ZW5zaW9uczpbInRleDJqYXguanMiLCJtbWwyamF4LmpzIiwiYXNjaWltYXRoMmpheC5qcyJdLFRlWDp7ZXh0ZW5zaW9uczpbIkFNU21hdGguanMiLCJBTVNzeW1ib2xzLmpzIiwibm9FcnJvcnMuanMiLCJub1VuZGVmaW5lZC5qcyJdfSwiSFRNTC1DU1MiOnthdmFpbGFibGVGb250czpbZV0saW1hZ2VGb250Om51bGx9LFNWRzp7Zm9udDplLHVzZUZvbnRDYWNoZTohMX0sdGV4MmpheDp7aWdub3JlQ2xhc3M6Im14Q2VsbEVkaXRvciJ9LGFzY2lpbWF0aDJqYXg6e2lnbm9yZUNsYXNzOiJteENlbGxFZGl0b3IifX07CndpbmRvdy5NYXRoSmF4PXtza2lwU3RhcnR1cFR5cGVzZXQ6ITAsc2hvd01hdGhNZW51OiExLG1lc3NhZ2VTdHlsZToibm9uZSIsQXV0aG9ySW5pdDpmdW5jdGlvbigpe01hdGhKYXguSHViLkNvbmZpZyhiKTtNYXRoSmF4Lkh1Yi5SZWdpc3Rlci5TdGFydHVwSG9vaygiQmVnaW4iLGZ1bmN0aW9uKCl7Zm9yKHZhciBhPTA7YTxFZGl0b3IubWF0aEpheFF1ZXVlLmxlbmd0aDthKyspRWRpdG9yLmRvTWF0aEpheFJlbmRlcihFZGl0b3IubWF0aEpheFF1ZXVlW2FdKX0pfX07RWRpdG9yLk1hdGhKYXhSZW5kZXI9ZnVuY3Rpb24oYSl7InVuZGVmaW5lZCIhPT10eXBlb2YgTWF0aEpheCYmInVuZGVmaW5lZCIhPT10eXBlb2YgTWF0aEpheC5IdWI/RWRpdG9yLmRvTWF0aEpheFJlbmRlcihhKTpFZGl0b3IubWF0aEpheFF1ZXVlLnB1c2goYSl9O0VkaXRvci5NYXRoSmF4Q2xlYXI9ZnVuY3Rpb24oKXtFZGl0b3IubWF0aEpheFF1ZXVlPVtdfTt2YXIgYz1FZGl0b3IucHJvdG90eXBlLmluaXQ7RWRpdG9yLnByb3RvdHlwZS5pbml0PQpmdW5jdGlvbigpe2MuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuZ3JhcGguYWRkTGlzdGVuZXIobXhFdmVudC5TSVpFLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYil7bnVsbCE9dGhpcy5ncmFwaC5jb250YWluZXImJnRoaXMuZ3JhcGgubWF0aEVuYWJsZWQmJiF0aGlzLmdyYXBoLmJsb2NrTWF0aFJlbmRlciYmRWRpdG9yLk1hdGhKYXhSZW5kZXIodGhpcy5ncmFwaC5jb250YWluZXIpfSkpfTtlPWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJzY3JpcHQiKTtpZihudWxsIT1lJiYwPGUubGVuZ3RoKXt2YXIgZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzY3JpcHQiKTtkLnR5cGU9InRleHQvamF2YXNjcmlwdCI7ZC5zcmM9YTtlWzBdLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZCl9fTtFZGl0b3IucHJvdG90eXBlLmNzdlRvQXJyYXk9ZnVuY3Rpb24oYSl7aWYoIS9eXHMqKD86J1teJ1xcXSooPzpcXFtcU1xzXVteJ1xcXSopKid8IlteIlxcXSooPzpcXFtcU1xzXVteIlxcXSopKiJ8W14sJyJcc1xcXSooPzpccytbXiwnIlxzXFxdKykqKVxzKig/OixccyooPzonW14nXFxdKig/OlxcW1xTXHNdW14nXFxdKikqJ3wiW14iXFxdKig/OlxcW1xTXHNdW14iXFxdKikqInxbXiwnIlxzXFxdKig/OlxzK1teLCciXHNcXF0rKSopXHMqKSokLy50ZXN0KGEpKXJldHVybiBudWxsOwp2YXIgYj1bXTthLnJlcGxhY2UoLyg/IVxzKiQpXHMqKD86JyhbXidcXF0qKD86XFxbXFNcc11bXidcXF0qKSopJ3wiKFteIlxcXSooPzpcXFtcU1xzXVteIlxcXSopKikifChbXiwnIlxzXFxdKig/OlxzK1teLCciXHNcXF0rKSopKVxzKig/Oix8JCkvZyxmdW5jdGlvbihhLGUsYyxkKXt2b2lkIDAhPT1lP2IucHVzaChlLnJlcGxhY2UoL1xcJy9nLCInIikpOnZvaWQgMCE9PWM/Yi5wdXNoKGMucmVwbGFjZSgvXFwiL2csJyInKSk6dm9pZCAwIT09ZCYmYi5wdXNoKGQpO3JldHVybiIifSk7LyxccyokLy50ZXN0KGEpJiZiLnB1c2goIiIpO3JldHVybiBifTtFZGl0b3IucHJvdG90eXBlLmlzQ29yc0VuYWJsZWRGb3JVcmw9ZnVuY3Rpb24oYSl7aWYobXhDbGllbnQuSVNfQ0hST01FQVBQfHxFZGl0b3JVaS5pc0VsZWN0cm9uQXBwKXJldHVybiEwO251bGwhPXVybFBhcmFtcy5jb3JzJiZudWxsPT10aGlzLmNvcnNSZWdFeHAmJih0aGlzLmNvcnNSZWdFeHA9bmV3IFJlZ0V4cChkZWNvZGVVUklDb21wb25lbnQodXJsUGFyYW1zLmNvcnMpKSk7CnJldHVybiBudWxsIT10aGlzLmNvcnNSZWdFeHAmJnRoaXMuY29yc1JlZ0V4cC50ZXN0KGEpfHwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tLyI9PT1hLnN1YnN0cmluZygwLDM0KX07RWRpdG9yLnByb3RvdHlwZS5jcmVhdGVJbWFnZVVybENvbnZlcnRlcj1mdW5jdGlvbigpe3ZhciBhPW5ldyBteFVybENvbnZlcnRlcjthLnVwZGF0ZUJhc2VVcmwoKTt2YXIgYj1hLmNvbnZlcnQsZT10aGlzO2EuY29udmVydD1mdW5jdGlvbihjKXtpZihudWxsIT1jKXt2YXIgZD0iaHR0cDovLyI9PWMuc3Vic3RyaW5nKDAsNyl8fCJodHRwczovLyI9PWMuc3Vic3RyaW5nKDAsOCk7ZCYmIW5hdmlnYXRvci5vbkxpbmU/Yz1FZGl0b3Iuc3ZnQnJva2VuSW1hZ2Uuc3JjOiFkfHxjLnN1YnN0cmluZygwLGEuYmFzZVVybC5sZW5ndGgpPT1hLmJhc2VVcmx8fGUuY3Jvc3NPcmlnaW5JbWFnZXMmJmUuaXNDb3JzRW5hYmxlZEZvclVybChjKT8iY2hyb21lLWV4dGVuc2lvbjovLyI9PWMuc3Vic3RyaW5nKDAsCjE5KXx8bXhDbGllbnQuSVNfQ0hST01FQVBQfHwoYz1iLmFwcGx5KHRoaXMsYXJndW1lbnRzKSk6Yz1QUk9YWV9VUkwrIj91cmw9IitlbmNvZGVVUklDb21wb25lbnQoYyl9cmV0dXJuIGN9O3JldHVybiBhfTtFZGl0b3IuY3JlYXRlU3ZnRGF0YVVyaT1mdW5jdGlvbihhKXtyZXR1cm4iZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwiK2J0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGEpKSl9O0VkaXRvci5wcm90b3R5cGUuY29udmVydEltYWdlVG9EYXRhVXJpPWZ1bmN0aW9uKGEsYil7dHJ5e3ZhciBlPSEwLGM9d2luZG93LnNldFRpbWVvdXQobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtlPSExO2IoRWRpdG9yLnN2Z0Jyb2tlbkltYWdlLnNyYyl9KSx0aGlzLnRpbWVvdXQpO2lmKC8oXC5zdmcpJC9pLnRlc3QoYSkpbXhVdGlscy5nZXQoYSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt3aW5kb3cuY2xlYXJUaW1lb3V0KGMpO2UmJmIoRWRpdG9yLmNyZWF0ZVN2Z0RhdGFVcmkoYS5nZXRUZXh0KCkpKX0pLApmdW5jdGlvbigpe3dpbmRvdy5jbGVhclRpbWVvdXQoYyk7ZSYmYihFZGl0b3Iuc3ZnQnJva2VuSW1hZ2Uuc3JjKX0pO2Vsc2V7dmFyIGQ9bmV3IEltYWdlO3RoaXMuY3Jvc3NPcmlnaW5JbWFnZXMmJihkLmNyb3NzT3JpZ2luPSJhbm9ueW1vdXMiKTtkLm9ubG9hZD1mdW5jdGlvbigpe3dpbmRvdy5jbGVhclRpbWVvdXQoYyk7aWYoZSl0cnl7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIiksZj1hLmdldENvbnRleHQoIjJkIik7YS5oZWlnaHQ9ZC5oZWlnaHQ7YS53aWR0aD1kLndpZHRoO2YuZHJhd0ltYWdlKGQsMCwwKTtiKGEudG9EYXRhVVJMKCkpfWNhdGNoKGVhKXtiKEVkaXRvci5zdmdCcm9rZW5JbWFnZS5zcmMpfX07ZC5vbmVycm9yPWZ1bmN0aW9uKCl7d2luZG93LmNsZWFyVGltZW91dChjKTtlJiZiKEVkaXRvci5zdmdCcm9rZW5JbWFnZS5zcmMpfTtkLnNyYz1hfX1jYXRjaChJKXtiKEVkaXRvci5zdmdCcm9rZW5JbWFnZS5zcmMpfX07RWRpdG9yLnByb3RvdHlwZS5jb252ZXJ0SW1hZ2VzPQpmdW5jdGlvbihhLGIsZSxjKXtudWxsPT1jJiYoYz10aGlzLmNyZWF0ZUltYWdlVXJsQ29udmVydGVyKCkpO3ZhciBkPTAsZj1lfHx7fTtlPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGUsZyl7Zm9yKHZhciBsPWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSkscD0wO3A8bC5sZW5ndGg7cCsrKW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGUpe3RyeXtpZihudWxsIT1lKXt2YXIgbD1jLmNvbnZlcnQoZS5nZXRBdHRyaWJ1dGUoZykpO2lmKG51bGwhPWwmJiJkYXRhOiIhPWwuc3Vic3RyaW5nKDAsNSkpe3ZhciBwPWZbbF07bnVsbD09cD8oZCsrLHRoaXMuY29udmVydEltYWdlVG9EYXRhVXJpKGwsZnVuY3Rpb24oYyl7bnVsbCE9YyYmKGZbbF09YyxlLnNldEF0dHJpYnV0ZShnLGMpKTtkLS07MD09ZCYmYihhKX0pKTplLnNldEF0dHJpYnV0ZShnLHApfWVsc2UgbnVsbCE9bCYmZS5zZXRBdHRyaWJ1dGUoZyxsKX19Y2F0Y2goZ2Epe319KShsW3BdKX0pO2UoImltYWdlIiwieGxpbms6aHJlZiIpOwplKCJpbWciLCJzcmMiKTswPT1kJiZiKGEpfTtFZGl0b3IuYmFzZTY0RW5jb2RlPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0iIixlPTAsYz1hLmxlbmd0aCxkLGYsZztlPGM7KXtkPWEuY2hhckNvZGVBdChlKyspJjI1NTtpZihlPT1jKXtiKz0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyIuY2hhckF0KGQ+PjIpO2IrPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvIi5jaGFyQXQoKGQmMyk8PDQpO2IrPSI9PSI7YnJlYWt9Zj1hLmNoYXJDb2RlQXQoZSsrKTtpZihlPT1jKXtiKz0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyIuY2hhckF0KGQ+PjIpO2IrPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvIi5jaGFyQXQoKGQmCjMpPDw0fChmJjI0MCk+PjQpO2IrPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvIi5jaGFyQXQoKGYmMTUpPDwyKTtiKz0iPSI7YnJlYWt9Zz1hLmNoYXJDb2RlQXQoZSsrKTtiKz0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyIuY2hhckF0KGQ+PjIpO2IrPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvIi5jaGFyQXQoKGQmMyk8PDR8KGYmMjQwKT4+NCk7Yis9IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8iLmNoYXJBdCgoZiYxNSk8PDJ8KGcmMTkyKT4+Nik7Yis9IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8iLmNoYXJBdChnJjYzKX1yZXR1cm4gYn07CkVkaXRvci5wcm90b3R5cGUubG9hZFVybD1mdW5jdGlvbihhLGIsZSxjLGQsZixnLGwpe3RyeXt2YXIgcD0hZyYmKGN8fC8oXC5wbmcpKCR8XD8pL2kudGVzdChhKXx8LyhcLmpwZT9nKSgkfFw/KS9pLnRlc3QoYSl8fC8oXC5naWYpKCR8XD8pL2kudGVzdChhKXx8LyhcLnBkZikoJHxcPykvaS50ZXN0KGEpKTtkPW51bGwhPWQ/ZDohMDt2YXIgbj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe214VXRpbHMuZ2V0KGEsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7aWYoMjAwPD1hLmdldFN0YXR1cygpJiYyOTk+PWEuZ2V0U3RhdHVzKCkpe2lmKG51bGwhPWIpe3ZhciBjPWEuZ2V0VGV4dCgpO2lmKHApe2lmKCg5PT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fDEwPT1kb2N1bWVudC5kb2N1bWVudE1vZGUpJiYidW5kZWZpbmVkIiE9PXR5cGVvZiB3aW5kb3cubXhVdGlsc0JpbmFyeVRvQXJyYXkpe2E9bXhVdGlsc0JpbmFyeVRvQXJyYXkoYS5yZXF1ZXN0LnJlc3BvbnNlQm9keSkudG9BcnJheSgpOwpmb3IodmFyIGM9QXJyYXkoYS5sZW5ndGgpLGQ9MDtkPGEubGVuZ3RoO2QrKyljW2RdPVN0cmluZy5mcm9tQ2hhckNvZGUoYVtkXSk7Yz1jLmpvaW4oIiIpfWY9bnVsbCE9Zj9mOiJkYXRhOmltYWdlL3BuZztiYXNlNjQsIjtjPWYrRWRpdG9yLmJhc2U2NEVuY29kZShjKX1iKGMpfX1lbHNlIG51bGwhPWUmJigwPT1hLmdldFN0YXR1cygpP2Uoe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJhY2Nlc3NEZW5pZWQiKX0sYSk6ZSh7bWVzc2FnZTpteFJlc291cmNlcy5nZXQoImVycm9yIikrIiAiK2EuZ2V0U3RhdHVzKCl9LGEpKX0pLGZ1bmN0aW9uKGEpe251bGwhPWUmJmUoe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJlcnJvciIpKyIgIithLmdldFN0YXR1cygpfSl9LHAsdGhpcy50aW1lb3V0LGZ1bmN0aW9uKCl7ZCYmbnVsbCE9ZSYmZSh7Y29kZTpBcHAuRVJST1JfVElNRU9VVCxyZXRyeTpufSl9LGwpfSk7bigpfWNhdGNoKFope251bGwhPWUmJmUoWil9fTtFZGl0b3IucHJvdG90eXBlLmFic29sdXRlQ3NzRm9udHM9CmZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7aWYobnVsbCE9YSl7dmFyIGU9YS5zcGxpdCgidXJsKCIpO2lmKDA8ZS5sZW5ndGgpe2I9W2VbMF1dO2E9d2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO3ZhciBjPW51bGwhPWE/YS5sYXN0SW5kZXhPZigiLyIpOi0xOzA8PWMmJihhPWEuc3Vic3RyaW5nKDAsYysxKSk7dmFyIGM9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImJhc2UiKSxkPW51bGw7bnVsbCE9YyYmMDxjLmxlbmd0aCYmKGQ9Y1swXS5nZXRBdHRyaWJ1dGUoImhyZWYiKSk7Zm9yKHZhciBmPTE7ZjxlLmxlbmd0aDtmKyspaWYoYz1lW2ZdLmluZGV4T2YoIikiKSwwPGMpe3ZhciBnPUVkaXRvci50cmltQ3NzVXJsKGVbZl0uc3Vic3RyaW5nKDAsYykpO3RoaXMuZ3JhcGguaXNSZWxhdGl2ZVVybChnKSYmKGc9bnVsbCE9ZD9kK2c6d2luZG93LmxvY2F0aW9uLnByb3RvY29sKyIvLyIrd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKygiLyI9PWcuY2hhckF0KDApPyIiOmEpK2cpOwpiLnB1c2goJ3VybCgiJytnKyciJytlW2ZdLnN1YnN0cmluZyhjKSl9ZWxzZSBiLnB1c2goZVtmXSl9ZWxzZSBiPVthXX1yZXR1cm4gbnVsbCE9Yj9iLmpvaW4oIiIpOm51bGx9O0VkaXRvci5wcm90b3R5cGUuZW1iZWRDc3NGb250cz1mdW5jdGlvbihhLGIpe3ZhciBlPWEuc3BsaXQoInVybCgiKSxjPTA7bnVsbD09dGhpcy5jYWNoZWRGb250cyYmKHRoaXMuY2FjaGVkRm9udHM9e30pO3ZhciBkPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7aWYoMD09Yyl7Zm9yKHZhciBhPVtlWzBdXSxkPTE7ZDxlLmxlbmd0aDtkKyspe3ZhciBmPWVbZF0uaW5kZXhPZigiKSIpO2EucHVzaCgndXJsKCInKTthLnB1c2godGhpcy5jYWNoZWRGb250c1tFZGl0b3IudHJpbUNzc1VybChlW2RdLnN1YnN0cmluZygwLGYpKV0pO2EucHVzaCgnIicrZVtkXS5zdWJzdHJpbmcoZikpfWIoYS5qb2luKCIiKSl9fSk7aWYoMDxlLmxlbmd0aCl7Zm9yKHZhciBmPTE7ZjxlLmxlbmd0aDtmKyspe3ZhciBnPWVbZl0uaW5kZXhPZigiKSIpLApsPW51bGwscD1lW2ZdLmluZGV4T2YoImZvcm1hdCgiLGcpOzA8cCYmKGw9RWRpdG9yLnRyaW1Dc3NVcmwoZVtmXS5zdWJzdHJpbmcocCs3LGVbZl0uaW5kZXhPZigiKSIscCkpKSk7bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7aWYobnVsbD09dGhpcy5jYWNoZWRGb250c1thXSl7dGhpcy5jYWNoZWRGb250c1thXT1hO2MrKzt2YXIgYj0iYXBwbGljYXRpb24veC1mb250LXR0ZiI7aWYoInN2ZyI9PWx8fC8oXC5zdmcpKCR8XD8pL2kudGVzdChhKSliPSJpbWFnZS9zdmcreG1sIjtlbHNlIGlmKCJvdGYiPT1sfHwiZW1iZWRkZWQtb3BlbnR5cGUiPT1sfHwvKFwub3RmKSgkfFw/KS9pLnRlc3QoYSkpYj0iYXBwbGljYXRpb24veC1mb250LW9wZW50eXBlIjtlbHNlIGlmKCJ3b2ZmIj09bHx8LyhcLndvZmYpKCR8XD8pL2kudGVzdChhKSliPSJhcHBsaWNhdGlvbi9mb250LXdvZmYiO2Vsc2UgaWYoIndvZmYyIj09bHx8LyhcLndvZmYyKSgkfFw/KS9pLnRlc3QoYSkpYj0iYXBwbGljYXRpb24vZm9udC13b2ZmMiI7CmVsc2UgaWYoImVvdCI9PWx8fC8oXC5lb3QpKCR8XD8pL2kudGVzdChhKSliPSJhcHBsaWNhdGlvbi92bmQubXMtZm9udG9iamVjdCI7ZWxzZSBpZigic2ZudCI9PWx8fC8oXC5zZm50KSgkfFw/KS9pLnRlc3QoYSkpYj0iYXBwbGljYXRpb24vZm9udC1zZm50Ijt2YXIgZT1hOy9eaHR0cHM/OlwvXC8vLnRlc3QoZSkmJiF0aGlzLmlzQ29yc0VuYWJsZWRGb3JVcmwoZSkmJihlPVBST1hZX1VSTCsiP3VybD0iK2VuY29kZVVSSUNvbXBvbmVudChhKSk7dGhpcy5sb2FkVXJsKGUsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7dGhpcy5jYWNoZWRGb250c1thXT1iO2MtLTtkKCl9KSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtjLS07ZCgpfSksITAsbnVsbCwiZGF0YToiK2IrIjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwiKX19KShFZGl0b3IudHJpbUNzc1VybChlW2ZdLnN1YnN0cmluZygwLGcpKSxsKX1kKCl9ZWxzZSBiKGEpfTtFZGl0b3IucHJvdG90eXBlLmxvYWRGb250cz0KZnVuY3Rpb24oYSl7bnVsbCE9dGhpcy5mb250Q3NzJiZudWxsPT10aGlzLnJlc29sdmVkRm9udENzcz90aGlzLmVtYmVkQ3NzRm9udHModGhpcy5mb250Q3NzLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3RoaXMucmVzb2x2ZWRGb250Q3NzPWI7YSgpfSkpOmEoKX07RWRpdG9yLnByb3RvdHlwZS5lbWJlZEV4dEZvbnRzPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ3JhcGguZXh0Rm9udHM7aWYobnVsbCE9YiYmMDxiLmxlbmd0aCl7dmFyIGU9IiIsYz0wO251bGw9PXRoaXMuY2FjaGVkR29vZ2xlRm9udHMmJih0aGlzLmNhY2hlZEdvb2dsZUZvbnRzPXt9KTtmb3IodmFyIGQ9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXswPT1jJiZ0aGlzLmVtYmVkQ3NzRm9udHMoZSxhKX0pLGY9MDtmPGIubGVuZ3RoO2YrKylteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIpezA9PWIuaW5kZXhPZihFZGl0b3IuR09PR0xFX0ZPTlRTKT9udWxsPT10aGlzLmNhY2hlZEdvb2dsZUZvbnRzW2JdPwooYysrLHRoaXMubG9hZFVybChiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuY2FjaGVkR29vZ2xlRm9udHNbYl09YTtlKz1hO2MtLTtkKCl9KSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtjLS07ZSs9IkBpbXBvcnQgdXJsKCIrYisiKTsiO2QoKX0pKSk6ZSs9dGhpcy5jYWNoZWRHb29nbGVGb250c1tiXTplKz0nQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6ICInK2ErJyI7c3JjOiB1cmwoIicrYisnIik7fSd9KShiW2ZdLm5hbWUsYltmXS51cmwpO2QoKX1lbHNlIGEoKX07RWRpdG9yLnByb3RvdHlwZS5hZGRNYXRoQ3NzPWZ1bmN0aW9uKGEpe2E9YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGVmcyIpO2lmKG51bGwhPWEmJjA8YS5sZW5ndGgpZm9yKHZhciBiPWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJzdHlsZSIpLGU9MDtlPGIubGVuZ3RoO2UrKykwPG14VXRpbHMuZ2V0VGV4dENvbnRlbnQoYltlXSkuaW5kZXhPZigiTWF0aEpheCIpJiZhWzBdLmFwcGVuZENoaWxkKGJbZV0uY2xvbmVOb2RlKCEwKSl9OwpFZGl0b3IucHJvdG90eXBlLmFkZEZvbnRDc3M9ZnVuY3Rpb24oYSxiKXtiPW51bGwhPWI/Yjp0aGlzLmFic29sdXRlQ3NzRm9udHModGhpcy5mb250Q3NzKTtpZihudWxsIT1iKXt2YXIgZT1hLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkZWZzIiksYz1hLm93bmVyRG9jdW1lbnQ7MD09ZS5sZW5ndGg/KGU9bnVsbCE9Yy5jcmVhdGVFbGVtZW50TlM/Yy5jcmVhdGVFbGVtZW50TlMobXhDb25zdGFudHMuTlNfU1ZHLCJkZWZzIik6Yy5jcmVhdGVFbGVtZW50KCJkZWZzIiksbnVsbCE9YS5maXJzdENoaWxkP2EuaW5zZXJ0QmVmb3JlKGUsYS5maXJzdENoaWxkKTphLmFwcGVuZENoaWxkKGUpKTplPWVbMF07Yz1udWxsIT1jLmNyZWF0ZUVsZW1lbnROUz9jLmNyZWF0ZUVsZW1lbnROUyhteENvbnN0YW50cy5OU19TVkcsInN0eWxlIik6Yy5jcmVhdGVFbGVtZW50KCJzdHlsZSIpO2Muc2V0QXR0cmlidXRlKCJ0eXBlIiwidGV4dC9jc3MiKTtteFV0aWxzLnNldFRleHRDb250ZW50KGMsYik7ZS5hcHBlbmRDaGlsZChjKX19OwpFZGl0b3IucHJvdG90eXBlLmlzRXhwb3J0VG9DYW52YXM9ZnVuY3Rpb24oKXtyZXR1cm4gbXhDbGllbnQuSVNfQ0hST01FQVBQfHx0aGlzLnVzZUNhbnZhc0ZvckV4cG9ydH07RWRpdG9yLnByb3RvdHlwZS5leHBvcnRUb0NhbnZhcz1mdW5jdGlvbihhLGIsZSxjLGQsZixnLGwscCxuLHQsayxtLHksdix4KXt0cnl7Zj1udWxsIT1mP2Y6ITA7Zz1udWxsIT1nP2c6ITA7az1udWxsIT1rP2s6dGhpcy5ncmFwaDttPW51bGwhPW0/bTowO3ZhciB1PXA/bnVsbDprLmJhY2tncm91bmQ7dT09bXhDb25zdGFudHMuTk9ORSYmKHU9bnVsbCk7bnVsbD09dSYmKHU9Yyk7bnVsbD09dSYmMD09cCYmKHU9eD90aGlzLmdyYXBoLmRlZmF1bHRQYWdlQmFja2dyb3VuZENvbG9yOiIjZmZmZmZmIik7dGhpcy5jb252ZXJ0SW1hZ2VzKGsuZ2V0U3ZnKG51bGwsbnVsbCxudWxsLHksbnVsbCxnLG51bGwsbnVsbCxudWxsLG4sbnVsbCx4KSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihlKXt0cnl7dmFyIGM9Cm5ldyBJbWFnZTtjLm9ubG9hZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RyeXt2YXIgZz1mdW5jdGlvbigpe214Q2xpZW50LklTX1NGP3dpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7eS5kcmF3SW1hZ2UoYyxtL2wsbS9sKTthKHApfSwwKTooeS5kcmF3SW1hZ2UoYyxtL2wsbS9sKSxhKHApKX0scD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJjYW52YXMiKSxuPXBhcnNlSW50KGUuZ2V0QXR0cmlidXRlKCJ3aWR0aCIpKSx0PXBhcnNlSW50KGUuZ2V0QXR0cmlidXRlKCJoZWlnaHQiKSk7bD1udWxsIT1sP2w6MTtudWxsIT1iJiYobD1mP01hdGgubWluKDEsTWF0aC5taW4oMypiLyg0KnQpLGIvbikpOmIvbik7bj1NYXRoLmNlaWwobCpuKSsyKm07dD1NYXRoLmNlaWwobCp0KSsyKm07cC5zZXRBdHRyaWJ1dGUoIndpZHRoIixuKTtwLnNldEF0dHJpYnV0ZSgiaGVpZ2h0Iix0KTt2YXIgeT1wLmdldENvbnRleHQoIjJkIik7bnVsbCE9dSYmKHkuYmVnaW5QYXRoKCkseS5yZWN0KDAsCjAsbix0KSx5LmZpbGxTdHlsZT11LHkuZmlsbCgpKTt5LnNjYWxlKGwsbCk7aWYodil7dmFyIHg9ay52aWV3LEI9eC5zY2FsZTt4LnNjYWxlPTE7dmFyIHE9YnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoeC5jcmVhdGVTdmdHcmlkKHguZ3JpZENvbG9yKSkpKTt4LnNjYWxlPUI7dmFyIHE9ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsIitxLHo9ay5ncmlkU2l6ZSp4LmdyaWRTdGVwcypsLEU9ay5nZXRHcmFwaEJvdW5kcygpLEE9eC50cmFuc2xhdGUueCpCLEs9eC50cmFuc2xhdGUueSpCLEM9QSsoRS54LUEpL0IsST1LKyhFLnktSykvQixEPW5ldyBJbWFnZTtELm9ubG9hZD1mdW5jdGlvbigpe3RyeXtmb3IodmFyIGE9LU1hdGgucm91bmQoei1teFV0aWxzLm1vZCgoQS1DKSpsLHopKSxiPS1NYXRoLnJvdW5kKHotbXhVdGlscy5tb2QoKEstSSkqbCx6KSk7YTxuO2ErPXopZm9yKHZhciBlPWI7ZTx0O2UrPXopeS5kcmF3SW1hZ2UoRCxhL2wsZS9sKTtnKCl9Y2F0Y2goa2Epe251bGwhPQpkJiZkKGthKX19O0Qub25lcnJvcj1mdW5jdGlvbihhKXtudWxsIT1kJiZkKGEpfTtELnNyYz1xfWVsc2UgZygpfWNhdGNoKG9hKXtudWxsIT1kJiZkKG9hKX19KTtjLm9uZXJyb3I9ZnVuY3Rpb24oYSl7bnVsbCE9ZCYmZChhKX07biYmdGhpcy5ncmFwaC5hZGRTdmdTaGFkb3coZSk7dGhpcy5ncmFwaC5tYXRoRW5hYmxlZCYmdGhpcy5hZGRNYXRoQ3NzKGUpO3ZhciBnPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dHJ5e251bGwhPXRoaXMucmVzb2x2ZWRGb250Q3NzJiZ0aGlzLmFkZEZvbnRDc3MoZSx0aGlzLnJlc29sdmVkRm9udENzcyksYy5zcmM9RWRpdG9yLmNyZWF0ZVN2Z0RhdGFVcmkobXhVdGlscy5nZXRYbWwoZSkpfWNhdGNoKE8pe251bGwhPWQmJmQoTyl9fSk7dGhpcy5lbWJlZEV4dEZvbnRzKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RyeXtudWxsIT1hJiZ0aGlzLmFkZEZvbnRDc3MoZSxhKSx0aGlzLmxvYWRGb250cyhnKX1jYXRjaChTKXtudWxsIT0KZCYmZChTKX19KSl9Y2F0Y2goTyl7bnVsbCE9ZCYmZChPKX19KSxlLHQpfWNhdGNoKFEpe251bGwhPWQmJmQoUSl9fTtFZGl0b3IuY3JjVGFibGU9W107Zm9yKHZhciBtPTA7MjU2Pm07bSsrKWZvcih2YXIgaz1tLHE9MDs4PnE7cSsrKWs9MT09KGsmMSk/Mzk4ODI5MjM4NF5rPj4+MTprPj4+MSxFZGl0b3IuY3JjVGFibGVbbV09aztFZGl0b3IudXBkYXRlQ1JDPWZ1bmN0aW9uKGEsYixlLGMpe2Zvcih2YXIgZD0wO2Q8YztkKyspYT1FZGl0b3IuY3JjVGFibGVbKGFeYi5jaGFyQ29kZUF0KGUrZCkpJjI1NV1eYT4+Pjg7cmV0dXJuIGF9O0VkaXRvci5jcmMzMj1mdW5jdGlvbihhKXtmb3IodmFyIGI9LTEsZT0wO2U8YS5sZW5ndGg7ZSsrKWI9Yj4+PjheRWRpdG9yLmNyY1RhYmxlWyhiXmEuY2hhckNvZGVBdChlKSkmMjU1XTtyZXR1cm4oYl4tMSk+Pj4wfTtFZGl0b3Iud3JpdGVHcmFwaE1vZGVsVG9Qbmc9ZnVuY3Rpb24oYSxiLGUsYyxkKXtmdW5jdGlvbiBmKGEsYil7dmFyIGU9cDtwKz0KYjtyZXR1cm4gYS5zdWJzdHJpbmcoZSxwKX1mdW5jdGlvbiBnKGEpe2E9ZihhLDQpO3JldHVybiBhLmNoYXJDb2RlQXQoMykrKGEuY2hhckNvZGVBdCgyKTw8OCkrKGEuY2hhckNvZGVBdCgxKTw8MTYpKyhhLmNoYXJDb2RlQXQoMCk8PDI0KX1mdW5jdGlvbiBsKGEpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGE+PjI0JjI1NSxhPj4xNiYyNTUsYT4+OCYyNTUsYSYyNTUpfWE9YS5zdWJzdHJpbmcoYS5pbmRleE9mKCIsIikrMSk7YT13aW5kb3cuYXRvYj9hdG9iKGEpOkJhc2U2NC5kZWNvZGUoYSwhMCk7dmFyIHA9MDtpZihmKGEsOCkhPVN0cmluZy5mcm9tQ2hhckNvZGUoMTM3KSsiUE5HIitTdHJpbmcuZnJvbUNoYXJDb2RlKDEzLDEwLDI2LDEwKSludWxsIT1kJiZkKCk7ZWxzZSBpZihmKGEsNCksIklIRFIiIT1mKGEsNCkpbnVsbCE9ZCYmZCgpO2Vsc2V7ZihhLDE3KTtkPWEuc3Vic3RyaW5nKDAscCk7ZG97dmFyIG49ZyhhKTtpZigiSURBVCI9PWYoYSw0KSl7ZD1hLnN1YnN0cmluZygwLApwLTgpOyJwSFlzIj09YiYmImRwaSI9PWU/KGU9TWF0aC5yb3VuZChjLy4wMjU0KSxlPWwoZSkrbChlKStTdHJpbmcuZnJvbUNoYXJDb2RlKDEpKTplPWUrU3RyaW5nLmZyb21DaGFyQ29kZSgwKSsoInpUWHQiPT1iP1N0cmluZy5mcm9tQ2hhckNvZGUoMCk6IiIpK2M7Yz00Mjk0OTY3Mjk1O2M9RWRpdG9yLnVwZGF0ZUNSQyhjLGIsMCw0KTtjPUVkaXRvci51cGRhdGVDUkMoYyxlLDAsZS5sZW5ndGgpO2QrPWwoZS5sZW5ndGgpK2IrZStsKGNeNDI5NDk2NzI5NSk7ZCs9YS5zdWJzdHJpbmcocC04LGEubGVuZ3RoKTticmVha31kKz1hLnN1YnN0cmluZyhwLTgscC00K24pO2YoYSxuKTtmKGEsNCl9d2hpbGUobik7cmV0dXJuImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwiKyh3aW5kb3cuYnRvYT9idG9hKGQpOkJhc2U2NC5lbmNvZGUoZCwhMCkpfX07aWYod2luZG93LkNvbG9yRGlhbG9nKXtGaWxlbmFtZURpYWxvZy5maWxlbmFtZUhlbHBMaW5rPSJodHRwczovL2Rlc2suZHJhdy5pby9zdXBwb3J0L3NvbHV0aW9ucy9hcnRpY2xlcy8xNjAwMDA5MTQyNiI7CnZhciBiPUNvbG9yRGlhbG9nLmFkZFJlY2VudENvbG9yO0NvbG9yRGlhbG9nLmFkZFJlY2VudENvbG9yPWZ1bmN0aW9uKGEsZSl7Yi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bXhTZXR0aW5ncy5zZXRSZWNlbnRDb2xvcnMoQ29sb3JEaWFsb2cucmVjZW50Q29sb3JzKTtteFNldHRpbmdzLnNhdmUoKX07dmFyIGU9Q29sb3JEaWFsb2cucmVzZXRSZWNlbnRDb2xvcnM7Q29sb3JEaWFsb2cucmVzZXRSZWNlbnRDb2xvcnM9ZnVuY3Rpb24oKXtlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtteFNldHRpbmdzLnNldFJlY2VudENvbG9ycyhDb2xvckRpYWxvZy5yZWNlbnRDb2xvcnMpO214U2V0dGluZ3Muc2F2ZSgpfX13aW5kb3cuRWRpdERhdGFEaWFsb2cmJihFZGl0RGF0YURpYWxvZy5nZXREaXNwbGF5SWRGb3JDZWxsPWZ1bmN0aW9uKGEsYil7dmFyIGU9bnVsbDtudWxsIT1hLmVkaXRvci5ncmFwaC5nZXRNb2RlbCgpLmdldFBhcmVudChiKT9lPWIuZ2V0SWQoKTpudWxsIT1hLmN1cnJlbnRQYWdlJiYKKGU9YS5jdXJyZW50UGFnZS5nZXRJZCgpKTtyZXR1cm4gZX0pO2lmKG51bGwhPXdpbmRvdy5TdHlsZUZvcm1hdFBhbmVsKXt2YXIgZz1Gb3JtYXQucHJvdG90eXBlLmluaXQ7Rm9ybWF0LnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7Zy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy5lZGl0b3JVaS5lZGl0b3IuYWRkTGlzdGVuZXIoImZpbGVMb2FkZWQiLHRoaXMudXBkYXRlKX07dmFyIHA9Rm9ybWF0LnByb3RvdHlwZS5yZWZyZXNoO0Zvcm1hdC5wcm90b3R5cGUucmVmcmVzaD1mdW5jdGlvbigpe251bGwhPXRoaXMuZWRpdG9yVWkuZ2V0Q3VycmVudEZpbGUoKXx8IjEiPT11cmxQYXJhbXMuZW1iZWR8fHRoaXMuZWRpdG9yVWkuZWRpdG9yLmNocm9tZWxlc3M/cC5hcHBseSh0aGlzLGFyZ3VtZW50cyk6dGhpcy5jbGVhcigpfTtEaWFncmFtRm9ybWF0UGFuZWwucHJvdG90eXBlLmlzU2hhZG93T3B0aW9uVmlzaWJsZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZWRpdG9yVWkuZ2V0Q3VycmVudEZpbGUoKTsKcmV0dXJuIjEiPT11cmxQYXJhbXMuZW1iZWR8fG51bGwhPWEmJmEuaXNFZGl0YWJsZSgpfTtEaWFncmFtRm9ybWF0UGFuZWwucHJvdG90eXBlLmlzTWF0aE9wdGlvblZpc2libGU9ZnVuY3Rpb24oYSl7cmV0dXJuITF9O3ZhciBsPURpYWdyYW1Gb3JtYXRQYW5lbC5wcm90b3R5cGUuYWRkVmlldztEaWFncmFtRm9ybWF0UGFuZWwucHJvdG90eXBlLmFkZFZpZXc9ZnVuY3Rpb24oYSl7YT1sLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLmVkaXRvclVpLmdldEN1cnJlbnRGaWxlKCk7aWYobXhDbGllbnQuSVNfU1ZHJiZ0aGlzLmlzU2hhZG93T3B0aW9uVmlzaWJsZSgpKXt2YXIgYj10aGlzLmVkaXRvclVpLGU9Yi5lZGl0b3IuZ3JhcGgsYz10aGlzLmNyZWF0ZU9wdGlvbihteFJlc291cmNlcy5nZXQoInNoYWRvdyIpLGZ1bmN0aW9uKCl7cmV0dXJuIGUuc2hhZG93VmlzaWJsZX0sZnVuY3Rpb24oYSl7dmFyIGM9bmV3IENoYW5nZVBhZ2VTZXR1cChiKTtjLmlnbm9yZUNvbG9yPSEwO2MuaWdub3JlSW1hZ2U9CiEwO2Muc2hhZG93VmlzaWJsZT1hO2UubW9kZWwuZXhlY3V0ZShjKX0se2luc3RhbGw6ZnVuY3Rpb24oYSl7dGhpcy5saXN0ZW5lcj1mdW5jdGlvbigpe2EoZS5zaGFkb3dWaXNpYmxlKX07Yi5hZGRMaXN0ZW5lcigic2hhZG93VmlzaWJsZUNoYW5nZWQiLHRoaXMubGlzdGVuZXIpfSxkZXN0cm95OmZ1bmN0aW9uKCl7Yi5yZW1vdmVMaXN0ZW5lcih0aGlzLmxpc3RlbmVyKX19KTtFZGl0b3Iuc2hhZG93T3B0aW9uRW5hYmxlZHx8KGMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImlucHV0IilbMF0uc2V0QXR0cmlidXRlKCJkaXNhYmxlZCIsImRpc2FibGVkIiksbXhVdGlscy5zZXRPcGFjaXR5KGMsNjApKTthLmFwcGVuZENoaWxkKGMpfXJldHVybiBhfTt2YXIgbj1EaWFncmFtRm9ybWF0UGFuZWwucHJvdG90eXBlLmFkZE9wdGlvbnM7RGlhZ3JhbUZvcm1hdFBhbmVsLnByb3RvdHlwZS5hZGRPcHRpb25zPWZ1bmN0aW9uKGEpe2E9bi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGI9dGhpcy5lZGl0b3JVaSwKZT1iLmVkaXRvci5ncmFwaDtpZihlLmlzRW5hYmxlZCgpKXt2YXIgYz1iLmdldEN1cnJlbnRGaWxlKCk7aWYobnVsbCE9YyYmYy5pc0F1dG9zYXZlT3B0aW9uYWwoKSl7dmFyIGQ9dGhpcy5jcmVhdGVPcHRpb24obXhSZXNvdXJjZXMuZ2V0KCJhdXRvc2F2ZSIpLGZ1bmN0aW9uKCl7cmV0dXJuIGIuZWRpdG9yLmF1dG9zYXZlfSxmdW5jdGlvbihhKXtiLmVkaXRvci5zZXRBdXRvc2F2ZShhKTtiLmVkaXRvci5hdXRvc2F2ZSYmYy5pc01vZGlmaWVkKCkmJmMuZmlsZUNoYW5nZWQoKX0se2luc3RhbGw6ZnVuY3Rpb24oYSl7dGhpcy5saXN0ZW5lcj1mdW5jdGlvbigpe2EoYi5lZGl0b3IuYXV0b3NhdmUpfTtiLmVkaXRvci5hZGRMaXN0ZW5lcigiYXV0b3NhdmVDaGFuZ2VkIix0aGlzLmxpc3RlbmVyKX0sZGVzdHJveTpmdW5jdGlvbigpe2IuZWRpdG9yLnJlbW92ZUxpc3RlbmVyKHRoaXMubGlzdGVuZXIpfX0pO2EuYXBwZW5kQ2hpbGQoZCl9fWlmKHRoaXMuaXNNYXRoT3B0aW9uVmlzaWJsZSgpJiYKZS5pc0VuYWJsZWQoKSYmInVuZGVmaW5lZCIhPT10eXBlb2YgTWF0aEpheCl7ZD10aGlzLmNyZWF0ZU9wdGlvbihteFJlc291cmNlcy5nZXQoIm1hdGhlbWF0aWNhbFR5cGVzZXR0aW5nIiksZnVuY3Rpb24oKXtyZXR1cm4gZS5tYXRoRW5hYmxlZH0sZnVuY3Rpb24oYSl7Yi5hY3Rpb25zLmdldCgibWF0aGVtYXRpY2FsVHlwZXNldHRpbmciKS5mdW5jdCgpfSx7aW5zdGFsbDpmdW5jdGlvbihhKXt0aGlzLmxpc3RlbmVyPWZ1bmN0aW9uKCl7YShlLm1hdGhFbmFibGVkKX07Yi5hZGRMaXN0ZW5lcigibWF0aEVuYWJsZWRDaGFuZ2VkIix0aGlzLmxpc3RlbmVyKX0sZGVzdHJveTpmdW5jdGlvbigpe2IucmVtb3ZlTGlzdGVuZXIodGhpcy5saXN0ZW5lcil9fSk7ZC5zdHlsZS5wYWRkaW5nVG9wPSI1cHgiO2EuYXBwZW5kQ2hpbGQoZCk7dmFyIGY9Yi5tZW51cy5jcmVhdGVIZWxwTGluaygiaHR0cHM6Ly9kZXNrLmRyYXcuaW8vc3VwcG9ydC9zb2x1dGlvbnMvYXJ0aWNsZXMvMTYwMDAwMzI4NzUiKTsKZi5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiO2Yuc3R5bGUubWFyZ2luTGVmdD0iNnB4IjtmLnN0eWxlLnRvcD0iMnB4IjtkLmFwcGVuZENoaWxkKGYpfXJldHVybiBhfTtteENlbGxSZW5kZXJlci5wcm90b3R5cGUuZGVmYXVsdFZlcnRleFNoYXBlLnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPVt7bmFtZToiYXJjU2l6ZSIsZGlzcE5hbWU6IkFyYyBTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOm14Q29uc3RhbnRzLkxJTkVfQVJDU0laRX0se25hbWU6ImFic29sdXRlQXJjU2l6ZSIsZGlzcE5hbWU6IkFicy4gQXJjIFNpemUiLHR5cGU6ImJvb2wiLGRlZlZhbDohMX1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMubGluay5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6IndpZHRoIixkaXNwTmFtZToiV2lkdGgiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6NH1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMuZmxleEFycm93LnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPQpbe25hbWU6IndpZHRoIixkaXNwTmFtZToiV2lkdGgiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6MTB9LHtuYW1lOiJzdGFydFdpZHRoIixkaXNwTmFtZToiU3RhcnQgV2lkdGgiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6MjB9LHtuYW1lOiJlbmRXaWR0aCIsZGlzcE5hbWU6IkVuZCBXaWR0aCIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDoyMH1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMucHJvY2Vzcy5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6InNpemUiLGRpc3BOYW1lOiJJbmRlbnQiLHR5cGU6ImZsb2F0IixtaW46MCxtYXg6LjUsZGVmVmFsOi4xfV07bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy5yaG9tYnVzLnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPVt7bmFtZToiYXJjU2l6ZSIsZGlzcE5hbWU6IkFyYyBTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsbWF4OjUwLGRlZlZhbDpteENvbnN0YW50cy5MSU5FX0FSQ1NJWkV9LHtuYW1lOiJkb3VibGUiLApkaXNwTmFtZToiRG91YmxlIix0eXBlOiJib29sIixkZWZWYWw6ITF9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLnBhcnRpYWxSZWN0YW5nbGUucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJ0b3AiLGRpc3BOYW1lOiJUb3AgTGluZSIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfSx7bmFtZToiYm90dG9tIixkaXNwTmFtZToiQm90dG9tIExpbmUiLHR5cGU6ImJvb2wiLGRlZlZhbDohMH0se25hbWU6ImxlZnQiLGRpc3BOYW1lOiJMZWZ0IExpbmUiLHR5cGU6ImJvb2wiLGRlZlZhbDohMH0se25hbWU6InJpZ2h0IixkaXNwTmFtZToiUmlnaHQgTGluZSIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfV07bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy5wYXJhbGxlbG9ncmFtLnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPVt7bmFtZToiYXJjU2l6ZSIsZGlzcE5hbWU6IkFyYyBTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOm14Q29uc3RhbnRzLkxJTkVfQVJDU0laRX0sCntuYW1lOiJzaXplIixkaXNwTmFtZToiU2xvcGUgQW5nbGUiLHR5cGU6ImZsb2F0IixtaW46MCxtYXg6MSxkZWZWYWw6LjJ9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLmhleGFnb24ucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJhcmNTaXplIixkaXNwTmFtZToiQXJjIFNpemUiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6bXhDb25zdGFudHMuTElORV9BUkNTSVpFfSx7bmFtZToic2l6ZSIsZGlzcE5hbWU6IlNsb3BlIEFuZ2xlIix0eXBlOiJmbG9hdCIsbWluOjAsbWF4OjEsZGVmVmFsOi4yNX1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMudHJpYW5nbGUucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJhcmNTaXplIixkaXNwTmFtZToiQXJjIFNpemUiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6bXhDb25zdGFudHMuTElORV9BUkNTSVpFfV07bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy5kb2N1bWVudC5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz0KW3tuYW1lOiJzaXplIixkaXNwTmFtZToiU2l6ZSIsdHlwZToiZmxvYXQiLGRlZlZhbDouMyxtaW46MCxtYXg6MX1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMuaW50ZXJuYWxTdG9yYWdlLnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPVt7bmFtZToiYXJjU2l6ZSIsZGlzcE5hbWU6IkFyYyBTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOm14Q29uc3RhbnRzLkxJTkVfQVJDU0laRX0se25hbWU6ImR4IixkaXNwTmFtZToiTGVmdCBMaW5lIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjIwfSx7bmFtZToiZHkiLGRpc3BOYW1lOiJUb3AgTGluZSIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDoyMH1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMuY3ViZS5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6InNpemUiLGRpc3BOYW1lOiJTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjIwfSx7bmFtZToiZGFya09wYWNpdHkiLGRpc3BOYW1lOiJEYXJrIE9wYWNpdHkiLAp0eXBlOiJmbG9hdCIsbWluOi0xLG1heDoxLGRlZlZhbDowfSx7bmFtZToiZGFya09wYWNpdHkyIixkaXNwTmFtZToiRGFyayBPcGFjaXR5IDIiLHR5cGU6ImZsb2F0IixtaW46LTEsbWF4OjEsZGVmVmFsOjB9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLnN0ZXAucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJzaXplIixkaXNwTmFtZToiTm90Y2ggU2l6ZSIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDoyMH0se25hbWU6ImZpeGVkU2l6ZSIsZGlzcE5hbWU6IkZpeGVkIFNpemUiLHR5cGU6ImJvb2wiLGRlZlZhbDohMH1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMudHJhcGV6b2lkLnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPVt7bmFtZToiYXJjU2l6ZSIsZGlzcE5hbWU6IkFyYyBTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOm14Q29uc3RhbnRzLkxJTkVfQVJDU0laRX0se25hbWU6InNpemUiLGRpc3BOYW1lOiJTbG9wZSBBbmdsZSIsCnR5cGU6ImZsb2F0IixtaW46MCxtYXg6MSxkZWZWYWw6LjJ9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLnRhcGUucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJzaXplIixkaXNwTmFtZToiU2l6ZSIsdHlwZToiZmxvYXQiLG1pbjowLG1heDoxLGRlZlZhbDouNH1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMubm90ZS5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6InNpemUiLGRpc3BOYW1lOiJGb2xkIFNpemUiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6MzB9LHtuYW1lOiJkYXJrT3BhY2l0eSIsZGlzcE5hbWU6IkRhcmsgT3BhY2l0eSIsdHlwZToiZmxvYXQiLG1pbjotMSxtYXg6MSxkZWZWYWw6MH1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMuY2FyZC5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6ImFyY1NpemUiLGRpc3BOYW1lOiJBcmMgU2l6ZSIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDpteENvbnN0YW50cy5MSU5FX0FSQ1NJWkV9LAp7bmFtZToic2l6ZSIsZGlzcE5hbWU6IkN1dG9mZiBTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjMwfV07bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy5jYWxsb3V0LnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPVt7bmFtZToiYXJjU2l6ZSIsZGlzcE5hbWU6IkFyYyBTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOm14Q29uc3RhbnRzLkxJTkVfQVJDU0laRX0se25hbWU6ImJhc2UiLGRpc3BOYW1lOiJDYWxsb3V0IFdpZHRoIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjIwfSx7bmFtZToic2l6ZSIsZGlzcE5hbWU6IkNhbGxvdXQgTGVuZ3RoIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjMwfSx7bmFtZToicG9zaXRpb24iLGRpc3BOYW1lOiJDYWxsb3V0IFBvc2l0aW9uIix0eXBlOiJmbG9hdCIsbWluOjAsbWF4OjEsZGVmVmFsOi41fSx7bmFtZToicG9zaXRpb24yIixkaXNwTmFtZToiQ2FsbG91dCBUaXAgUG9zaXRpb24iLHR5cGU6ImZsb2F0IiwKbWluOjAsbWF4OjEsZGVmVmFsOi41fV07bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy5mb2xkZXIucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJ0YWJXaWR0aCIsZGlzcE5hbWU6IlRhYiBXaWR0aCIsdHlwZToiZmxvYXQifSx7bmFtZToidGFiSGVpZ2h0IixkaXNwTmFtZToiVGFiIEhlaWdodCIsdHlwZToiZmxvYXQifSx7bmFtZToidGFiUG9zaXRpb24iLGRpc3BOYW1lOiJUYXAgUG9zaXRpb24iLHR5cGU6ImVudW0iLGVudW1MaXN0Olt7dmFsOiJsZWZ0IixkaXNwTmFtZToiTGVmdCJ9LHt2YWw6InJpZ2h0IixkaXNwTmFtZToiUmlnaHQifV19XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLnN3aW1sYW5lLnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPVt7bmFtZToiYXJjU2l6ZSIsZGlzcE5hbWU6IkFyYyBTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjE1fSx7bmFtZToic3RhcnRTaXplIixkaXNwTmFtZToiSGVhZGVyIFNpemUiLHR5cGU6ImZsb2F0In0sCntuYW1lOiJob3Jpem9udGFsIixkaXNwTmFtZToiSG9yaXpvbnRhbCIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfSx7bmFtZToic2VwYXJhdG9yQ29sb3IiLGRpc3BOYW1lOiJTZXBhcmF0b3IgQ29sb3IiLHR5cGU6ImNvbG9yIixkZWZWYWw6bnVsbH1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMudGFibGUucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJyb3dMaW5lcyIsZGlzcE5hbWU6IlJvdyBMaW5lcyIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfSx7bmFtZToiY29sdW1uTGluZXMiLGRpc3BOYW1lOiJDb2x1bW4gTGluZXMiLHR5cGU6ImJvb2wiLGRlZlZhbDohMH0se25hbWU6ImZpeGVkUm93cyIsZGlzcE5hbWU6IkZpeGVkIFJvd3MiLHR5cGU6ImJvb2wiLGRlZlZhbDohMX0se25hbWU6InJlc2l6ZUxhc3QiLGRpc3BOYW1lOiJSZXNpemUgTGFzdCBDb2x1bW4iLHR5cGU6ImJvb2wiLGRlZlZhbDohMX0se25hbWU6InJlc2l6ZUxhc3RSb3ciLGRpc3BOYW1lOiJSZXNpemUgTGFzdCBSb3ciLAp0eXBlOiJib29sIixkZWZWYWw6ITF9XS5jb25jYXQobXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy5zd2ltbGFuZS5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcyk7bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy5kb3VibGVFbGxpcHNlLnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPVt7bmFtZToibWFyZ2luIixkaXNwTmFtZToiSW5kZW50Iix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjR9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLmV4dC5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6ImFyY1NpemUiLGRpc3BOYW1lOiJBcmMgU2l6ZSIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDoxNX0se25hbWU6ImRvdWJsZSIsZGlzcE5hbWU6IkRvdWJsZSIsdHlwZToiYm9vbCIsZGVmVmFsOiExfSx7bmFtZToibWFyZ2luIixkaXNwTmFtZToiSW5kZW50Iix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjB9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLmN1cmx5QnJhY2tldC5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz0KW3tuYW1lOiJyb3VuZGVkIixkaXNwTmFtZToiUm91bmRlZCIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfSx7bmFtZToic2l6ZSIsZGlzcE5hbWU6IlNpemUiLHR5cGU6ImZsb2F0IixtaW46MCxtYXg6MSxkZWZWYWw6LjV9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLmltYWdlLnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPVt7bmFtZToiaW1hZ2VBc3BlY3QiLGRpc3BOYW1lOiJGaXhlZCBJbWFnZSBBc3BlY3QiLHR5cGU6ImJvb2wiLGRlZlZhbDohMH1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMubGFiZWwucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJpbWFnZUFzcGVjdCIsZGlzcE5hbWU6IkZpeGVkIEltYWdlIEFzcGVjdCIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfSx7bmFtZToiaW1hZ2VBbGlnbiIsZGlzcE5hbWU6IkltYWdlIEFsaWduIix0eXBlOiJlbnVtIixlbnVtTGlzdDpbe3ZhbDoibGVmdCIsZGlzcE5hbWU6IkxlZnQifSx7dmFsOiJjZW50ZXIiLApkaXNwTmFtZToiQ2VudGVyIn0se3ZhbDoicmlnaHQiLGRpc3BOYW1lOiJSaWdodCJ9XSxkZWZWYWw6ImxlZnQifSx7bmFtZToiaW1hZ2VWZXJ0aWNhbEFsaWduIixkaXNwTmFtZToiSW1hZ2UgVmVydGljYWwgQWxpZ24iLHR5cGU6ImVudW0iLGVudW1MaXN0Olt7dmFsOiJ0b3AiLGRpc3BOYW1lOiJUb3AifSx7dmFsOiJtaWRkbGUiLGRpc3BOYW1lOiJNaWRkbGUifSx7dmFsOiJib3R0b20iLGRpc3BOYW1lOiJCb3R0b20ifV0sZGVmVmFsOiJtaWRkbGUifSx7bmFtZToiaW1hZ2VXaWR0aCIsZGlzcE5hbWU6IkltYWdlIFdpZHRoIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjI0fSx7bmFtZToiaW1hZ2VIZWlnaHQiLGRpc3BOYW1lOiJJbWFnZSBIZWlnaHQiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6MjR9LHtuYW1lOiJhcmNTaXplIixkaXNwTmFtZToiQXJjIFNpemUiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6MTJ9LHtuYW1lOiJhYnNvbHV0ZUFyY1NpemUiLGRpc3BOYW1lOiJBYnMuIEFyYyBTaXplIiwKdHlwZToiYm9vbCIsZGVmVmFsOiExfV07bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy5kYXRhU3RvcmFnZS5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6InNpemUiLGRpc3BOYW1lOiJTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsbWF4OjEsZGVmVmFsOi4xfV07bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy5tYW51YWxJbnB1dC5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6InNpemUiLGRpc3BOYW1lOiJTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjMwfSx7bmFtZToiYXJjU2l6ZSIsZGlzcE5hbWU6IkFyYyBTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjIwfV07bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy5sb29wTGltaXQucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJzaXplIixkaXNwTmFtZToiU2l6ZSIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDoyMH0se25hbWU6ImFyY1NpemUiLGRpc3BOYW1lOiJBcmMgU2l6ZSIsCnR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6MjB9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLm9mZlBhZ2VDb25uZWN0b3IucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJzaXplIixkaXNwTmFtZToiU2l6ZSIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDozOH0se25hbWU6ImFyY1NpemUiLGRpc3BOYW1lOiJBcmMgU2l6ZSIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDoyMH1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMuZGlzcGxheS5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6InNpemUiLGRpc3BOYW1lOiJTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsbWF4OjEsZGVmVmFsOi4yNX1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMuc2luZ2xlQXJyb3cucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJhcnJvd1dpZHRoIixkaXNwTmFtZToiQXJyb3cgV2lkdGgiLHR5cGU6ImZsb2F0IixtaW46MCxtYXg6MSxkZWZWYWw6LjN9LAp7bmFtZToiYXJyb3dTaXplIixkaXNwTmFtZToiQXJyb3doZWFkIExlbmd0aCIsdHlwZToiZmxvYXQiLG1pbjowLG1heDoxLGRlZlZhbDouMn1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMuZG91YmxlQXJyb3cucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJhcnJvd1dpZHRoIixkaXNwTmFtZToiQXJyb3cgV2lkdGgiLHR5cGU6ImZsb2F0IixtaW46MCxtYXg6MSxkZWZWYWw6LjN9LHtuYW1lOiJhcnJvd1NpemUiLGRpc3BOYW1lOiJBcnJvd2hlYWQgTGVuZ3RoIix0eXBlOiJmbG9hdCIsbWluOjAsbWF4OjEsZGVmVmFsOi4yfV07bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy5jcm9zcy5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6InNpemUiLGRpc3BOYW1lOiJTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsbWF4OjEsZGVmVmFsOi4yfV07bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy5jb3JuZXIucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9Clt7bmFtZToiZHgiLGRpc3BOYW1lOiJXaWR0aDEiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6MjB9LHtuYW1lOiJkeSIsZGlzcE5hbWU6IldpZHRoMiIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDoyMH1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMudGVlLnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPVt7bmFtZToiZHgiLGRpc3BOYW1lOiJXaWR0aDEiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6MjB9LHtuYW1lOiJkeSIsZGlzcE5hbWU6IldpZHRoMiIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDoyMH1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMudW1sTGlmZWxpbmUucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJwYXJ0aWNpcGFudCIsZGlzcE5hbWU6IlBhcnRpY2lwYW50Iix0eXBlOiJlbnVtIixkZWZWYWw6Im5vbmUiLGVudW1MaXN0Olt7dmFsOiJub25lIixkaXNwTmFtZToiRGVmYXVsdCJ9LHt2YWw6InVtbEFjdG9yIixkaXNwTmFtZToiQWN0b3IifSwKe3ZhbDoidW1sQm91bmRhcnkiLGRpc3BOYW1lOiJCb3VuZGFyeSJ9LHt2YWw6InVtbEVudGl0eSIsZGlzcE5hbWU6IkVudGl0eSJ9LHt2YWw6InVtbENvbnRyb2wiLGRpc3BOYW1lOiJDb250cm9sIn1dfSx7bmFtZToic2l6ZSIsZGlzcE5hbWU6IkhlaWdodCIsdHlwZToiZmxvYXQiLGRlZlZhbDo0MCxtaW46MH1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMudW1sRnJhbWUucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJ3aWR0aCIsZGlzcE5hbWU6IlRpdGxlIFdpZHRoIix0eXBlOiJmbG9hdCIsZGVmVmFsOjYwLG1pbjowfSx7bmFtZToiaGVpZ2h0IixkaXNwTmFtZToiVGl0bGUgSGVpZ2h0Iix0eXBlOiJmbG9hdCIsZGVmVmFsOjMwLG1pbjowfV07U3R5bGVGb3JtYXRQYW5lbC5wcm90b3R5cGUuZGVmYXVsdENvbG9yU2NoZW1lcz1bW3tmaWxsOiIiLHN0cm9rZToiIn0se2ZpbGw6IiNmNWY1ZjUiLHN0cm9rZToiIzY2NjY2NiIsZm9udDoiIzMzMzMzMyJ9LHtmaWxsOiIjZGFlOGZjIiwKc3Ryb2tlOiIjNmM4ZWJmIn0se2ZpbGw6IiNkNWU4ZDQiLHN0cm9rZToiIzgyYjM2NiJ9LHtmaWxsOiIjZmZlNmNjIixzdHJva2U6IiNkNzliMDAifSx7ZmlsbDoiI2ZmZjJjYyIsc3Ryb2tlOiIjZDZiNjU2In0se2ZpbGw6IiNmOGNlY2MiLHN0cm9rZToiI2I4NTQ1MCJ9LHtmaWxsOiIjZTFkNWU3IixzdHJva2U6IiM5NjczYTYifV0sW3tmaWxsOiIiLHN0cm9rZToiIn0se2ZpbGw6IiM2MGE5MTciLHN0cm9rZToiIzJENzYwMCIsZm9udDoiI2ZmZmZmZiJ9LHtmaWxsOiIjMDA4YTAwIixzdHJva2U6IiMwMDU3MDAiLGZvbnQ6IiNmZmZmZmYifSx7ZmlsbDoiIzFiYTFlMiIsc3Ryb2tlOiIjMDA2RUFGIixmb250OiIjZmZmZmZmIn0se2ZpbGw6IiMwMDUwZWYiLHN0cm9rZToiIzAwMURCQyIsZm9udDoiI2ZmZmZmZiJ9LHtmaWxsOiIjNmEwMGZmIixzdHJva2U6IiMzNzAwQ0MiLGZvbnQ6IiNmZmZmZmYifSx7ZmlsbDoiI2Q4MDA3MyIsc3Ryb2tlOiIjQTUwMDQwIixmb250OiIjZmZmZmZmIn0sCntmaWxsOiIjYTIwMDI1IixzdHJva2U6IiM2RjAwMDAiLGZvbnQ6IiNmZmZmZmYifV0sW3tmaWxsOiIjZTUxNDAwIixzdHJva2U6IiNCMjAwMDAiLGZvbnQ6IiNmZmZmZmYifSx7ZmlsbDoiI2ZhNjgwMCIsc3Ryb2tlOiIjQzczNTAwIixmb250OiIjZmZmZmZmIn0se2ZpbGw6IiNmMGEzMGEiLHN0cm9rZToiI0JENzAwMCIsZm9udDoiI2ZmZmZmZiJ9LHtmaWxsOiIjZTNjODAwIixzdHJva2U6IiNCMDk1MDAiLGZvbnQ6IiNmZmZmZmYifSx7ZmlsbDoiIzZkODc2NCIsc3Ryb2tlOiIjM0E1NDMxIixmb250OiIjZmZmZmZmIn0se2ZpbGw6IiM2NDc2ODciLHN0cm9rZToiIzMxNDM1NCIsZm9udDoiI2ZmZmZmZiJ9LHtmaWxsOiIjNzY2MDhhIixzdHJva2U6IiM0MzJENTciLGZvbnQ6IiNmZmZmZmYifSx7ZmlsbDoiI2EwNTIyZCIsc3Ryb2tlOiIjNkQxRjAwIixmb250OiIjZmZmZmZmIn1dLFt7ZmlsbDoiIixzdHJva2U6IiJ9LHtmaWxsOm14Q29uc3RhbnRzLk5PTkUsc3Ryb2tlOiIifSx7ZmlsbDoiI2ZhZDdhYyIsCnN0cm9rZToiI2I0NjUwNCJ9LHtmaWxsOiIjZmFkOWQ1IixzdHJva2U6IiNhZTQxMzIifSx7ZmlsbDoiI2IwZTNlNiIsc3Ryb2tlOiIjMGU4MDg4In0se2ZpbGw6IiNiMWRkZjAiLHN0cm9rZToiIzEwNzM5ZSJ9LHtmaWxsOiIjZDBjZWUyIixzdHJva2U6IiM1NjUxN2UifSx7ZmlsbDoiI2JhYzhkMyIsc3Ryb2tlOiIjMjM0NDVkIn1dLFt7ZmlsbDoiIixzdHJva2U6IiJ9LHtmaWxsOiIjZjVmNWY1IixzdHJva2U6IiM2NjY2NjYiLGdyYWRpZW50OiIjYjNiM2IzIn0se2ZpbGw6IiNkYWU4ZmMiLHN0cm9rZToiIzZjOGViZiIsZ3JhZGllbnQ6IiM3ZWE2ZTAifSx7ZmlsbDoiI2Q1ZThkNCIsc3Ryb2tlOiIjODJiMzY2IixncmFkaWVudDoiIzk3ZDA3NyJ9LHtmaWxsOiIjZmZjZDI4IixzdHJva2U6IiNkNzliMDAiLGdyYWRpZW50OiIjZmZhNTAwIn0se2ZpbGw6IiNmZmYyY2MiLHN0cm9rZToiI2Q2YjY1NiIsZ3JhZGllbnQ6IiNmZmQ5NjYifSx7ZmlsbDoiI2Y4Y2VjYyIsc3Ryb2tlOiIjYjg1NDUwIiwKZ3JhZGllbnQ6IiNlYTZiNjYifSx7ZmlsbDoiI2U2ZDBkZSIsc3Ryb2tlOiIjOTk2MTg1IixncmFkaWVudDoiI2Q1NzM5ZCJ9XSxbe2ZpbGw6IiIsc3Ryb2tlOiIifSx7ZmlsbDoiI2VlZWVlZSIsc3Ryb2tlOiIjMzYzOTNkIn0se2ZpbGw6IiNmOWY3ZWQiLHN0cm9rZToiIzM2MzkzZCJ9LHtmaWxsOiIjZmZjYzk5IixzdHJva2U6IiMzNjM5M2QifSx7ZmlsbDoiI2NjZTVmZiIsc3Ryb2tlOiIjMzYzOTNkIn0se2ZpbGw6IiNmZmZmODgiLHN0cm9rZToiIzM2MzkzZCJ9LHtmaWxsOiIjY2RlYjhiIixzdHJva2U6IiMzNjM5M2QifSx7ZmlsbDoiI2ZmY2NjYyIsc3Ryb2tlOiIjMzYzOTNkIn1dXTtTdHlsZUZvcm1hdFBhbmVsLnByb3RvdHlwZS5jdXN0b21Db2xvclNjaGVtZXM9bnVsbDtTdHlsZUZvcm1hdFBhbmVsLnByb3RvdHlwZS5maW5kQ29tbW9uUHJvcGVydGllcz1mdW5jdGlvbihhLGIsZSl7aWYobnVsbCE9Yil7dmFyIGM9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSlpZihlKWZvcih2YXIgYz0KMDtjPGEubGVuZ3RoO2MrKyliW2FbY10ubmFtZV09YVtjXTtlbHNlIGZvcih2YXIgZCBpbiBiKXtmb3IodmFyIGY9ITEsYz0wO2M8YS5sZW5ndGg7YysrKWlmKGFbY10ubmFtZT09ZCYmYVtjXS50eXBlPT1iW2RdLnR5cGUpe2Y9ITA7YnJlYWt9Znx8ZGVsZXRlIGJbZF19fSxkPXRoaXMuZWRpdG9yVWkuZWRpdG9yLmdyYXBoLnZpZXcuZ2V0U3RhdGUoYSk7bnVsbCE9ZCYmbnVsbCE9ZC5zaGFwZSYmKGQuc2hhcGUuY29tbW9uQ3VzdG9tUHJvcEFkZGVkfHwoZC5zaGFwZS5jb21tb25DdXN0b21Qcm9wQWRkZWQ9ITAsZC5zaGFwZS5jdXN0b21Qcm9wZXJ0aWVzPWQuc2hhcGUuY3VzdG9tUHJvcGVydGllc3x8W10sZC5jZWxsLnZlcnRleD9BcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShkLnNoYXBlLmN1c3RvbVByb3BlcnRpZXMsRWRpdG9yLmNvbW1vblZlcnRleFByb3BlcnRpZXMpOkFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGQuc2hhcGUuY3VzdG9tUHJvcGVydGllcyxFZGl0b3IuY29tbW9uRWRnZVByb3BlcnRpZXMpKSwKYyhkLnNoYXBlLmN1c3RvbVByb3BlcnRpZXMpKTthPWEuZ2V0QXR0cmlidXRlKCJjdXN0b21Qcm9wZXJ0aWVzIik7aWYobnVsbCE9YSl0cnl7YyhKU09OLnBhcnNlKGEpKX1jYXRjaChJKXt9fX07dmFyIHY9U3R5bGVGb3JtYXRQYW5lbC5wcm90b3R5cGUuaW5pdDtTdHlsZUZvcm1hdFBhbmVsLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5mb3JtYXQuY3JlYXRlU2VsZWN0aW9uU3RhdGUoKTsiaW1hZ2UiPT1hLnN0eWxlLnNoYXBlfHxhLmNvbnRhaW5zTGFiZWx8fHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuYWRkU3R5bGVzKHRoaXMuY3JlYXRlUGFuZWwoKSkpO3YuYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKEVkaXRvci5lbmFibGVDdXN0b21Qcm9wZXJ0aWVzKXtmb3IodmFyIGI9e30sZT1hLnZlcnRpY2VzLGM9YS5lZGdlcyxkPTA7ZDxlLmxlbmd0aDtkKyspdGhpcy5maW5kQ29tbW9uUHJvcGVydGllcyhlW2RdLGIsMD09ZCk7Zm9yKGQ9MDtkPGMubGVuZ3RoO2QrKyl0aGlzLmZpbmRDb21tb25Qcm9wZXJ0aWVzKGNbZF0sCmIsMD09ZS5sZW5ndGgmJjA9PWQpO251bGwhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzJiYwPE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGIpLmxlbmd0aCYmdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5hZGRQcm9wZXJ0aWVzKHRoaXMuY3JlYXRlUGFuZWwoKSxiLGEpKX19O3ZhciB0PVN0eWxlRm9ybWF0UGFuZWwucHJvdG90eXBlLmFkZFN0eWxlT3BzO1N0eWxlRm9ybWF0UGFuZWwucHJvdG90eXBlLmFkZFN0eWxlT3BzPWZ1bmN0aW9uKGEpe3ZhciBiPW14VXRpbHMuYnV0dG9uKG14UmVzb3VyY2VzLmdldCgiY29weVN0eWxlIiksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5lZGl0b3JVaS5hY3Rpb25zLmdldCgiY29weVN0eWxlIikuZnVuY3QoKX0pKTtiLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgiY29weVN0eWxlIikrIiAoIit0aGlzLmVkaXRvclVpLmFjdGlvbnMuZ2V0KCJjb3B5U3R5bGUiKS5zaG9ydGN1dCsiKSIpOwpiLnN0eWxlLm1hcmdpbkJvdHRvbT0iMnB4IjtiLnN0eWxlLndpZHRoPSIxMDBweCI7Yi5zdHlsZS5tYXJnaW5SaWdodD0iMnB4IjthLmFwcGVuZENoaWxkKGIpO2I9bXhVdGlscy5idXR0b24obXhSZXNvdXJjZXMuZ2V0KCJwYXN0ZVN0eWxlIiksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5lZGl0b3JVaS5hY3Rpb25zLmdldCgicGFzdGVTdHlsZSIpLmZ1bmN0KCl9KSk7Yi5zZXRBdHRyaWJ1dGUoInRpdGxlIixteFJlc291cmNlcy5nZXQoInBhc3RlU3R5bGUiKSsiICgiK3RoaXMuZWRpdG9yVWkuYWN0aW9ucy5nZXQoInBhc3RlU3R5bGUiKS5zaG9ydGN1dCsiKSIpO2Iuc3R5bGUubWFyZ2luQm90dG9tPSIycHgiO2Iuc3R5bGUud2lkdGg9IjEwMHB4IjthLmFwcGVuZENoaWxkKGIpO214VXRpbHMuYnIoYSk7cmV0dXJuIHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtFZGl0b3JVaS5wcm90b3R5cGUucHJvcGVydGllc0NvbGxhcHNlZD0hMDtTdHlsZUZvcm1hdFBhbmVsLnByb3RvdHlwZS5hZGRQcm9wZXJ0aWVzPQpmdW5jdGlvbihhLGIsZSl7ZnVuY3Rpb24gYyhhLGIsZSxjKXtrLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7dmFyIGQ9W10sZj1bXTtpZihudWxsIT1lLmluZGV4KXtmb3IodmFyIGc9W10sbD1lLnBhcmVudFJvdy5uZXh0U2libGluZztsJiZsLmdldEF0dHJpYnV0ZSgiZGF0YS1wTmFtZSIpPT1hOylnLnB1c2gobC5nZXRBdHRyaWJ1dGUoImRhdGEtcFZhbHVlIikpLGw9bC5uZXh0U2libGluZztlLmluZGV4PGcubGVuZ3RoP251bGwhPWM/Zy5zcGxpY2UoYywxKTpnW2UuaW5kZXhdPWI6Zy5wdXNoKGIpO251bGwhPWUuc2l6ZSYmZy5sZW5ndGg+ZS5zaXplJiYoZz1nLnNsaWNlKDAsZS5zaXplKSk7Yj1nLmpvaW4oIiwiKTtudWxsIT1lLmNvdW50UHJvcGVydHkmJihrLnNldENlbGxTdHlsZXMoZS5jb3VudFByb3BlcnR5LGcubGVuZ3RoLGsuZ2V0U2VsZWN0aW9uQ2VsbHMoKSksZC5wdXNoKGUuY291bnRQcm9wZXJ0eSksZi5wdXNoKGcubGVuZ3RoKSl9ay5zZXRDZWxsU3R5bGVzKGEsCmIsay5nZXRTZWxlY3Rpb25DZWxscygpKTtkLnB1c2goYSk7Zi5wdXNoKGIpO2lmKG51bGwhPWUuZGVwZW5kZW50UHJvcHMpZm9yKGE9MDthPGUuZGVwZW5kZW50UHJvcHMubGVuZ3RoO2ErKyl7dmFyIHA9ZS5kZXBlbmRlbnRQcm9wc0RlZlZhbFthXSxuPWUuZGVwZW5kZW50UHJvcHNWYWxzW2FdO2lmKG4ubGVuZ3RoPmIpbj1uLnNsaWNlKDAsYik7ZWxzZSBmb3IodmFyIG09bi5sZW5ndGg7bTxiO20rKyluLnB1c2gocCk7bj1uLmpvaW4oIiwiKTtrLnNldENlbGxTdHlsZXMoZS5kZXBlbmRlbnRQcm9wc1thXSxuLGsuZ2V0U2VsZWN0aW9uQ2VsbHMoKSk7ZC5wdXNoKGUuZGVwZW5kZW50UHJvcHNbYV0pO2YucHVzaChuKX1pZigiZnVuY3Rpb24iPT10eXBlb2YgZS5vbkNoYW5nZSllLm9uQ2hhbmdlKGssYik7dC5lZGl0b3JVaS5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInN0eWxlQ2hhbmdlZCIsImtleXMiLGQsInZhbHVlcyIsZiwiY2VsbHMiLGsuZ2V0U2VsZWN0aW9uQ2VsbHMoKSkpfWZpbmFsbHl7ay5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX0KZnVuY3Rpb24gZChiLGUsYyl7dmFyIGQ9bXhVdGlscy5nZXRPZmZzZXQoYSwhMCksZj1teFV0aWxzLmdldE9mZnNldChiLCEwKTtlLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7ZS5zdHlsZS5sZWZ0PWYueC1kLngrInB4IjtlLnN0eWxlLnRvcD1mLnktZC55KyJweCI7ZS5zdHlsZS53aWR0aD1iLm9mZnNldFdpZHRoKyJweCI7ZS5zdHlsZS5oZWlnaHQ9Yi5vZmZzZXRIZWlnaHQtKGM/NDowKSsicHgiO2Uuc3R5bGUuekluZGV4PTV9ZnVuY3Rpb24gZihhLGIsZSl7dmFyIGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7ZC5zdHlsZS53aWR0aD0iMzJweCI7ZC5zdHlsZS5oZWlnaHQ9IjRweCI7ZC5zdHlsZS5tYXJnaW49IjJweCI7ZC5zdHlsZS5ib3JkZXI9IjFweCBzb2xpZCBibGFjayI7ZC5zdHlsZS5iYWNrZ3JvdW5kPWImJiJub25lIiE9Yj9iOiJ1cmwoJyIrRGlhbG9nLnByb3RvdHlwZS5ub0NvbG9ySW1hZ2UrIicpIjtidG49bXhVdGlscy5idXR0b24oIiIsbXhVdGlscy5iaW5kKHQsCmZ1bmN0aW9uKGYpe3RoaXMuZWRpdG9yVWkucGlja0NvbG9yKGIsZnVuY3Rpb24oYil7ZC5zdHlsZS5iYWNrZ3JvdW5kPSJub25lIj09Yj8idXJsKCciK0RpYWxvZy5wcm90b3R5cGUubm9Db2xvckltYWdlKyInKSI6YjtjKGEsYixlKX0pO214RXZlbnQuY29uc3VtZShmKX0pKTtidG4uc3R5bGUuaGVpZ2h0PSIxMnB4IjtidG4uc3R5bGUud2lkdGg9IjQwcHgiO2J0bi5jbGFzc05hbWU9ImdlQ29sb3JCdG4iO2J0bi5hcHBlbmRDaGlsZChkKTtyZXR1cm4gYnRufWZ1bmN0aW9uIGcoYSxiLGUsZCxmLGcsbCl7bnVsbCE9YiYmKGI9Yi5zcGxpdCgiLCIpLG0ucHVzaCh7bmFtZTphLHZhbHVlczpiLHR5cGU6ZSxkZWZWYWw6ZCxjb3VudFByb3BlcnR5OmYscGFyZW50Um93OmcsaXNEZWxldGFibGU6ITAsZmxpcEJrZzpsfSkpO2J0bj1teFV0aWxzLmJ1dHRvbigiKyIsbXhVdGlscy5iaW5kKHQsZnVuY3Rpb24oYil7Zm9yKHZhciBwPWcsdD0wO251bGwhPXAubmV4dFNpYmxpbmc7KWlmKHAubmV4dFNpYmxpbmcuZ2V0QXR0cmlidXRlKCJkYXRhLXBOYW1lIik9PQphKXA9cC5uZXh0U2libGluZyx0Kys7ZWxzZSBicmVhazt2YXIgaz17dHlwZTplLHBhcmVudFJvdzpnLGluZGV4OnQsaXNEZWxldGFibGU6ITAsZGVmVmFsOmQsY291bnRQcm9wZXJ0eTpmfSx0PW4oYSwiIixrLDA9PXQlMixsKTtjKGEsZCxrKTtwLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHQscC5uZXh0U2libGluZyk7bXhFdmVudC5jb25zdW1lKGIpfSkpO2J0bi5zdHlsZS5oZWlnaHQ9IjE2cHgiO2J0bi5zdHlsZS53aWR0aD0iMjVweCI7YnRuLmNsYXNzTmFtZT0iZ2VDb2xvckJ0biI7cmV0dXJuIGJ0bn1mdW5jdGlvbiBsKGEsYixlLGMsZCxmLGcpe2lmKDA8ZCl7dmFyIGw9QXJyYXkoZCk7Yj1udWxsIT1iP2Iuc3BsaXQoIiwiKTpbXTtmb3IodmFyIHA9MDtwPGQ7cCsrKWxbcF09bnVsbCE9YltwXT9iW3BdOm51bGwhPWM/YzoiIjttLnB1c2goe25hbWU6YSx2YWx1ZXM6bCx0eXBlOmUsZGVmVmFsOmMscGFyZW50Um93OmYsZmxpcEJrZzpnLHNpemU6ZH0pfXJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKX0KZnVuY3Rpb24gcChhLGIsZSl7dmFyIGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTtkLnR5cGU9ImNoZWNrYm94IjtkLmNoZWNrZWQ9IjEiPT1iO214RXZlbnQuYWRkTGlzdGVuZXIoZCwiY2hhbmdlIixmdW5jdGlvbigpe2MoYSxkLmNoZWNrZWQ/IjEiOiIwIixlKX0pO3JldHVybiBkfWZ1bmN0aW9uIG4oYixlLG4sayxtKXt2YXIgeT1uLmRpc3BOYW1lLHU9bi50eXBlLHY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidHIiKTt2LmNsYXNzTmFtZT0iZ2VQcm9wUm93IisobT8iRGFyayI6IiIpKyhrPyJBbHQiOiIiKSsiIGdlUHJvcE5vbkhlYWRlclJvdyI7di5zZXRBdHRyaWJ1dGUoImRhdGEtcE5hbWUiLGIpO3Yuc2V0QXR0cmlidXRlKCJkYXRhLXBWYWx1ZSIsZSk7az0hMTtudWxsIT1uLmluZGV4JiYodi5zZXRBdHRyaWJ1dGUoImRhdGEtaW5kZXgiLG4uaW5kZXgpLHk9KG51bGwhPXk/eToiIikrIlsiK24uaW5kZXgrIl0iLGs9ITApO3ZhciB4PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRkIik7CnguY2xhc3NOYW1lPSJnZVByb3BSb3dDZWxsIjt4LmlubmVySFRNTD1teFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQoeSxudWxsLHkpKTtrJiYoeC5zdHlsZS50ZXh0QWxpZ249InJpZ2h0Iik7di5hcHBlbmRDaGlsZCh4KTt4PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRkIik7eC5jbGFzc05hbWU9ImdlUHJvcFJvd0NlbGwiO2lmKCJjb2xvciI9PXUpeC5hcHBlbmRDaGlsZChmKGIsZSxuKSk7ZWxzZSBpZigiYm9vbCI9PXV8fCJib29sZWFuIj09dSl4LmFwcGVuZENoaWxkKHAoYixlLG4pKTtlbHNlIGlmKCJlbnVtIj09dSl7dmFyIEI9bi5lbnVtTGlzdDtmb3IobT0wO208Qi5sZW5ndGg7bSsrKWlmKHk9QlttXSx5LnZhbD09ZSl7eC5pbm5lckhUTUw9bXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KHkuZGlzcE5hbWUsbnVsbCx5LmRpc3BOYW1lKSk7YnJlYWt9bXhFdmVudC5hZGRMaXN0ZW5lcih4LCJjbGljayIsbXhVdGlscy5iaW5kKHQsZnVuY3Rpb24oKXt2YXIgZj0KZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic2VsZWN0Iik7ZCh4LGYpO2Zvcih2YXIgZz0wO2c8Qi5sZW5ndGg7ZysrKXt2YXIgbD1CW2ddLHA9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgib3B0aW9uIik7cC52YWx1ZT1teFV0aWxzLmh0bWxFbnRpdGllcyhsLnZhbCk7cC5pbm5lckhUTUw9bXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KGwuZGlzcE5hbWUsbnVsbCxsLmRpc3BOYW1lKSk7Zi5hcHBlbmRDaGlsZChwKX1mLnZhbHVlPWU7YS5hcHBlbmRDaGlsZChmKTtteEV2ZW50LmFkZExpc3RlbmVyKGYsImNoYW5nZSIsZnVuY3Rpb24oKXt2YXIgYT1teFV0aWxzLmh0bWxFbnRpdGllcyhmLnZhbHVlKTtjKGIsYSxuKX0pO2YuZm9jdXMoKTtteEV2ZW50LmFkZExpc3RlbmVyKGYsImJsdXIiLGZ1bmN0aW9uKCl7YS5yZW1vdmVDaGlsZChmKX0pfSkpfWVsc2UiZHluYW1pY0FyciI9PXU/eC5hcHBlbmRDaGlsZChnKGIsZSxuLnN1YlR5cGUsbi5zdWJEZWZWYWwsbi5jb3VudFByb3BlcnR5LAp2LG0pKToic3RhdGljQXJyIj09dT94LmFwcGVuZENoaWxkKGwoYixlLG4uc3ViVHlwZSxuLnN1YkRlZlZhbCxuLnNpemUsdixtKSk6KHguaW5uZXJIVE1MPWUsbXhFdmVudC5hZGRMaXN0ZW5lcih4LCJjbGljayIsbXhVdGlscy5iaW5kKHQsZnVuY3Rpb24oKXtmdW5jdGlvbiBmKCl7dmFyIGE9Zy52YWx1ZSxhPTA9PWEubGVuZ3RoJiYic3RyaW5nIiE9dT8wOmE7bi5hbGxvd0F1dG8mJihudWxsIT1hLnRyaW0mJiJhdXRvIj09YS50cmltKCkudG9Mb3dlckNhc2UoKT8oYT0iYXV0byIsdT0ic3RyaW5nIik6KGE9cGFyc2VGbG9hdChhKSxhPWlzTmFOKGEpPzA6YSkpO251bGwhPW4ubWluJiZhPG4ubWluP2E9bi5taW46bnVsbCE9bi5tYXgmJmE+bi5tYXgmJihhPW4ubWF4KTthPW14VXRpbHMuaHRtbEVudGl0aWVzKCgiaW50Ij09dT9wYXJzZUludChhKTphKSsiIik7YyhiLGEsbil9dmFyIGc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTtkKHgsZywhMCk7Zy52YWx1ZT1lO2cuY2xhc3NOYW1lPQoiZ2VQcm9wRWRpdG9yIjsiaW50IiE9dSYmImZsb2F0IiE9dXx8bi5hbGxvd0F1dG98fChnLnR5cGU9Im51bWJlciIsZy5zdGVwPSJpbnQiPT11PyIxIjoiYW55IixudWxsIT1uLm1pbiYmKGcubWluPXBhcnNlRmxvYXQobi5taW4pKSxudWxsIT1uLm1heCYmKGcubWF4PXBhcnNlRmxvYXQobi5tYXgpKSk7YS5hcHBlbmRDaGlsZChnKTtteEV2ZW50LmFkZExpc3RlbmVyKGcsImtleXByZXNzIixmdW5jdGlvbihhKXsxMz09YS5rZXlDb2RlJiZmKCl9KTtnLmZvY3VzKCk7bXhFdmVudC5hZGRMaXN0ZW5lcihnLCJibHVyIixmdW5jdGlvbigpe2YoKX0pfSkpKTtuLmlzRGVsZXRhYmxlJiYobT1teFV0aWxzLmJ1dHRvbigiLSIsbXhVdGlscy5iaW5kKHQsZnVuY3Rpb24oYSl7YyhiLCIiLG4sbi5pbmRleCk7bXhFdmVudC5jb25zdW1lKGEpfSkpLG0uc3R5bGUuaGVpZ2h0PSIxNnB4IixtLnN0eWxlLndpZHRoPSIyNXB4IixtLnN0eWxlWyJmbG9hdCJdPSJyaWdodCIsbS5jbGFzc05hbWU9ImdlQ29sb3JCdG4iLAp4LmFwcGVuZENoaWxkKG0pKTt2LmFwcGVuZENoaWxkKHgpO3JldHVybiB2fXZhciB0PXRoaXMsaz10aGlzLmVkaXRvclVpLmVkaXRvci5ncmFwaCxtPVtdO2Euc3R5bGUucG9zaXRpb249InJlbGF0aXZlIjthLnN0eWxlLnBhZGRpbmc9IjAiO3ZhciB5PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRhYmxlIik7eS5jbGFzc05hbWU9ImdlUHJvcGVydGllcyI7eS5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiO3kuc3R5bGUud2lkdGg9IjEwMCUiO3ZhciB1PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRyIik7dS5jbGFzc05hbWU9ImdlUHJvcEhlYWRlciI7dmFyIHY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGgiKTt2LmNsYXNzTmFtZT0iZ2VQcm9wSGVhZGVyQ2VsbCI7dmFyIHg9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIik7eC5zcmM9U2lkZWJhci5wcm90b3R5cGUuZXhwYW5kZWRJbWFnZTt2LmFwcGVuZENoaWxkKHgpO214VXRpbHMud3JpdGUodixteFJlc291cmNlcy5nZXQoInByb3BlcnR5IikpOwp1LnN0eWxlLmN1cnNvcj0icG9pbnRlciI7dmFyIEI9ZnVuY3Rpb24oKXt2YXIgYj15LnF1ZXJ5U2VsZWN0b3JBbGwoIi5nZVByb3BOb25IZWFkZXJSb3ciKSxlO2lmKHQuZWRpdG9yVWkucHJvcGVydGllc0NvbGxhcHNlZCl7eC5zcmM9U2lkZWJhci5wcm90b3R5cGUuY29sbGFwc2VkSW1hZ2U7ZT0ibm9uZSI7Zm9yKHZhciBjPWEuY2hpbGROb2Rlcy5sZW5ndGgtMTswPD1jO2MtLSl0cnl7dmFyIGQ9YS5jaGlsZE5vZGVzW2NdLGY9ZC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpOyJJTlBVVCIhPWYmJiJTRUxFQ1QiIT1mfHxhLnJlbW92ZUNoaWxkKGQpfWNhdGNoKHFhKXt9fWVsc2UgeC5zcmM9U2lkZWJhci5wcm90b3R5cGUuZXhwYW5kZWRJbWFnZSxlPSIiO2ZvcihjPTA7YzxiLmxlbmd0aDtjKyspYltjXS5zdHlsZS5kaXNwbGF5PWV9O214RXZlbnQuYWRkTGlzdGVuZXIodSwiY2xpY2siLGZ1bmN0aW9uKCl7dC5lZGl0b3JVaS5wcm9wZXJ0aWVzQ29sbGFwc2VkPSF0LmVkaXRvclVpLnByb3BlcnRpZXNDb2xsYXBzZWQ7CkIoKX0pO3UuYXBwZW5kQ2hpbGQodik7dj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0aCIpO3YuY2xhc3NOYW1lPSJnZVByb3BIZWFkZXJDZWxsIjt2LmlubmVySFRNTD1teFJlc291cmNlcy5nZXQoInZhbHVlIik7dS5hcHBlbmRDaGlsZCh2KTt5LmFwcGVuZENoaWxkKHUpO3ZhciBxPSExLHo9ITEsRTtmb3IoRSBpbiBiKWlmKHU9YltFXSwiZnVuY3Rpb24iIT10eXBlb2YgdS5pc1Zpc2libGV8fHUuaXNWaXNpYmxlKGUsdGhpcykpe3ZhciBBPW51bGwhPWUuc3R5bGVbRV0/bXhVdGlscy5odG1sRW50aXRpZXMoZS5zdHlsZVtFXSsiIik6bnVsbCE9dS5nZXREZWZhdWx0VmFsdWU/dS5nZXREZWZhdWx0VmFsdWUoZSx0aGlzKTp1LmRlZlZhbDtpZigic2VwYXJhdG9yIj09dS50eXBlKXo9IXo7ZWxzZXtpZigic3RhdGljQXJyIj09dS50eXBlKXUuc2l6ZT1wYXJzZUludChlLnN0eWxlW3Uuc2l6ZVByb3BlcnR5XXx8Ylt1LnNpemVQcm9wZXJ0eV0uZGVmVmFsKXx8MDtlbHNlIGlmKG51bGwhPQp1LmRlcGVuZGVudFByb3BzKXtmb3IodmFyIEM9dS5kZXBlbmRlbnRQcm9wcyxEPVtdLEs9W10sdj0wO3Y8Qy5sZW5ndGg7disrKXt2YXIgRz1lLnN0eWxlW0Nbdl1dO0sucHVzaChiW0Nbdl1dLnN1YkRlZlZhbCk7RC5wdXNoKG51bGwhPUc/Ry5zcGxpdCgiLCIpOltdKX11LmRlcGVuZGVudFByb3BzRGVmVmFsPUs7dS5kZXBlbmRlbnRQcm9wc1ZhbHM9RH15LmFwcGVuZENoaWxkKG4oRSxBLHUscSx6KSk7cT0hcX19Zm9yKHY9MDt2PG0ubGVuZ3RoO3YrKylmb3IodT1tW3ZdLGI9dS5wYXJlbnRSb3csZT0wO2U8dS52YWx1ZXMubGVuZ3RoO2UrKylFPW4odS5uYW1lLHUudmFsdWVzW2VdLHt0eXBlOnUudHlwZSxwYXJlbnRSb3c6dS5wYXJlbnRSb3csaXNEZWxldGFibGU6dS5pc0RlbGV0YWJsZSxpbmRleDplLGRlZlZhbDp1LmRlZlZhbCxjb3VudFByb3BlcnR5OnUuY291bnRQcm9wZXJ0eSxzaXplOnUuc2l6ZX0sMD09ZSUyLHUuZmxpcEJrZyksYi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShFLApiLm5leHRTaWJsaW5nKSxiPUU7YS5hcHBlbmRDaGlsZCh5KTtCKCk7cmV0dXJuIGF9O1N0eWxlRm9ybWF0UGFuZWwucHJvdG90eXBlLmFkZFN0eWxlcz1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEpe214RXZlbnQuYWRkTGlzdGVuZXIoYSwibW91c2VlbnRlciIsZnVuY3Rpb24oKXthLnN0eWxlLm9wYWNpdHk9IjEifSk7bXhFdmVudC5hZGRMaXN0ZW5lcihhLCJtb3VzZWxlYXZlIixmdW5jdGlvbigpe2Euc3R5bGUub3BhY2l0eT0iMC41In0pfXZhciBlPXRoaXMuZWRpdG9yVWkuZWRpdG9yLmdyYXBoLGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Yy5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiO2Muc3R5bGUucGFkZGluZ0xlZnQ9IjI0cHgiO2Muc3R5bGUucGFkZGluZ1JpZ2h0PSIyMHB4IjthLnN0eWxlLnBhZGRpbmdMZWZ0PSIxNnB4IjthLnN0eWxlLnBhZGRpbmdCb3R0b209IjZweCI7YS5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiO2EuYXBwZW5kQ2hpbGQoYyk7dmFyIGQ9CiJwbGFpbi1ncmF5IHBsYWluLWJsdWUgcGxhaW4tZ3JlZW4gcGxhaW4tdHVycXVvaXNlIHBsYWluLW9yYW5nZSBwbGFpbi15ZWxsb3cgcGxhaW4tcmVkIHBsYWluLXBpbmsgcGxhaW4tcHVycGxlIGdyYXkgYmx1ZSBncmVlbiB0dXJxdW9pc2Ugb3JhbmdlIHllbGxvdyByZWQgcGluayBwdXJwbGUiLnNwbGl0KCIgIiksZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtmLnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCI7Zi5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiO2Yuc3R5bGUudGV4dEFsaWduPSJjZW50ZXIiO2Zvcih2YXIgZz1bXSxsPTA7bDx0aGlzLmRlZmF1bHRDb2xvclNjaGVtZXMubGVuZ3RoO2wrKyl7dmFyIHA9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7cC5zdHlsZS5kaXNwbGF5PSJpbmxpbmUtYmxvY2siO3Auc3R5bGUud2lkdGg9IjZweCI7cC5zdHlsZS5oZWlnaHQ9IjZweCI7cC5zdHlsZS5tYXJnaW5MZWZ0PSI0cHgiO3Auc3R5bGUubWFyZ2luUmlnaHQ9CiIzcHgiO3Auc3R5bGUuYm9yZGVyUmFkaXVzPSIzcHgiO3Auc3R5bGUuY3Vyc29yPSJwb2ludGVyIjtwLnN0eWxlLmJhY2tncm91bmQ9InRyYW5zcGFyZW50IjtwLnN0eWxlLmJvcmRlcj0iMXB4IHNvbGlkICNiNWI2YjciO214VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe214RXZlbnQuYWRkTGlzdGVuZXIocCwiY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bihhKX0pKX0pKGwpO214RXZlbnQuYWRkO2cucHVzaChwKTtmLmFwcGVuZENoaWxkKHApfXZhciBuPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe251bGwhPXRoaXMuZWRpdG9yVWkuY3VycmVudFNjaGVtZSYmKGdbdGhpcy5lZGl0b3JVaS5jdXJyZW50U2NoZW1lXS5zdHlsZS5iYWNrZ3JvdW5kPSJ0cmFuc3BhcmVudCIpO3RoaXMuZWRpdG9yVWkuY3VycmVudFNjaGVtZT1hO3QodGhpcy5kZWZhdWx0Q29sb3JTY2hlbWVzW3RoaXMuZWRpdG9yVWkuY3VycmVudFNjaGVtZV0pO2dbdGhpcy5lZGl0b3JVaS5jdXJyZW50U2NoZW1lXS5zdHlsZS5iYWNrZ3JvdW5kPQoiIzg0ZDdmZiJ9KSx0PW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBiPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBiPW14VXRpbHMuYnV0dG9uKCIiLGZ1bmN0aW9uKGIpe2UuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgYz1lLmdldFNlbGVjdGlvbkNlbGxzKCk7Zm9yKGI9MDtiPGMubGVuZ3RoO2IrKyl7Zm9yKHZhciBmPWUuZ2V0TW9kZWwoKS5nZXRTdHlsZShjW2JdKSxnPTA7ZzxkLmxlbmd0aDtnKyspZj1teFV0aWxzLnJlbW92ZVN0eWxlbmFtZShmLGRbZ10pO3ZhciBsPWUuZ2V0TW9kZWwoKS5pc1ZlcnRleChjW2JdKT9lLmRlZmF1bHRWZXJ0ZXhTdHlsZTplLmRlZmF1bHRFZGdlU3R5bGU7bnVsbCE9YT8oZj1teFV0aWxzLnNldFN0eWxlKGYsbXhDb25zdGFudHMuU1RZTEVfR1JBRElFTlRDT0xPUixhLmdyYWRpZW50fHxteFV0aWxzLmdldFZhbHVlKGwsbXhDb25zdGFudHMuU1RZTEVfR1JBRElFTlRDT0xPUixudWxsKSksZj0iIj09CmEuZmlsbD9teFV0aWxzLnNldFN0eWxlKGYsbXhDb25zdGFudHMuU1RZTEVfRklMTENPTE9SLG51bGwpOm14VXRpbHMuc2V0U3R5bGUoZixteENvbnN0YW50cy5TVFlMRV9GSUxMQ09MT1IsYS5maWxsfHxteFV0aWxzLmdldFZhbHVlKGwsbXhDb25zdGFudHMuU1RZTEVfRklMTENPTE9SLG51bGwpKSxmPSIiPT1hLnN0cm9rZT9teFV0aWxzLnNldFN0eWxlKGYsbXhDb25zdGFudHMuU1RZTEVfU1RST0tFQ09MT1IsbnVsbCk6bXhVdGlscy5zZXRTdHlsZShmLG14Q29uc3RhbnRzLlNUWUxFX1NUUk9LRUNPTE9SLGEuc3Ryb2tlfHxteFV0aWxzLmdldFZhbHVlKGwsbXhDb25zdGFudHMuU1RZTEVfU1RST0tFQ09MT1IsbnVsbCkpLGUuZ2V0TW9kZWwoKS5pc1ZlcnRleChjW2JdKSYmKGY9bXhVdGlscy5zZXRTdHlsZShmLG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRDT0xPUixhLmZvbnR8fG14VXRpbHMuZ2V0VmFsdWUobCxteENvbnN0YW50cy5TVFlMRV9GT05UQ09MT1IsbnVsbCkpKSk6KGY9bXhVdGlscy5zZXRTdHlsZShmLApteENvbnN0YW50cy5TVFlMRV9GSUxMQ09MT1IsbXhVdGlscy5nZXRWYWx1ZShsLG14Q29uc3RhbnRzLlNUWUxFX0ZJTExDT0xPUiwiI2ZmZmZmZiIpKSxmPW14VXRpbHMuc2V0U3R5bGUoZixteENvbnN0YW50cy5TVFlMRV9TVFJPS0VDT0xPUixteFV0aWxzLmdldFZhbHVlKGwsbXhDb25zdGFudHMuU1RZTEVfU1RST0tFQ09MT1IsIiMwMDAwMDAiKSksZj1teFV0aWxzLnNldFN0eWxlKGYsbXhDb25zdGFudHMuU1RZTEVfR1JBRElFTlRDT0xPUixteFV0aWxzLmdldFZhbHVlKGwsbXhDb25zdGFudHMuU1RZTEVfR1JBRElFTlRDT0xPUixudWxsKSksZS5nZXRNb2RlbCgpLmlzVmVydGV4KGNbYl0pJiYoZj1teFV0aWxzLnNldFN0eWxlKGYsbXhDb25zdGFudHMuU1RZTEVfRk9OVENPTE9SLG14VXRpbHMuZ2V0VmFsdWUobCxteENvbnN0YW50cy5TVFlMRV9GT05UQ09MT1IsbnVsbCkpKSk7ZS5nZXRNb2RlbCgpLnNldFN0eWxlKGNbYl0sZil9fWZpbmFsbHl7ZS5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX0pOwpiLmNsYXNzTmFtZT0iZ2VTdHlsZUJ1dHRvbiI7Yi5zdHlsZS53aWR0aD0iMzZweCI7Yi5zdHlsZS5oZWlnaHQ9MTA+PXRoaXMuZGVmYXVsdENvbG9yU2NoZW1lcy5sZW5ndGg/IjI0cHgiOiIzMHB4IjtiLnN0eWxlLm1hcmdpbj0iMHB4IDZweCA2cHggMHB4IjtpZihudWxsIT1hKW51bGwhPWEuZ3JhZGllbnQ/bXhDbGllbnQuSVNfSUUmJihteENsaWVudC5JU19RVUlSS1N8fDEwPmRvY3VtZW50LmRvY3VtZW50TW9kZSk/Yi5zdHlsZS5maWx0ZXI9InByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5HcmFkaWVudChTdGFydENvbG9yU3RyPSciK2EuZmlsbCsiJywgRW5kQ29sb3JTdHI9JyIrYS5ncmFkaWVudCsiJywgR3JhZGllbnRUeXBlPTApIjpiLnN0eWxlLmJhY2tncm91bmRJbWFnZT0ibGluZWFyLWdyYWRpZW50KCIrYS5maWxsKyIgMHB4LCIrYS5ncmFkaWVudCsiIDEwMCUpIjphLmZpbGw9PW14Q29uc3RhbnRzLk5PTkU/Yi5zdHlsZS5iYWNrZ3JvdW5kPSJ1cmwoJyIrCkRpYWxvZy5wcm90b3R5cGUubm9Db2xvckltYWdlKyInKSI6Yi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9IiI9PWEuZmlsbD9teFV0aWxzLmdldFZhbHVlKGUuZGVmYXVsdFZlcnRleFN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZJTExDT0xPUiwiZGFyayI9PXVpVGhlbWU/IiMyYTJhMmEiOiIjZmZmZmZmIik6YS5maWxsfHxteFV0aWxzLmdldFZhbHVlKGUuZGVmYXVsdFZlcnRleFN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZJTExDT0xPUiwiZGFyayI9PXVpVGhlbWU/IiMyYTJhMmEiOiIjZmZmZmZmIiksYi5zdHlsZS5ib3JkZXI9YS5zdHJva2U9PW14Q29uc3RhbnRzLk5PTkU/IjFweCBzb2xpZCB0cmFuc3BhcmVudCI6IiI9PWEuc3Ryb2tlPyIxcHggc29saWQgIitteFV0aWxzLmdldFZhbHVlKGUuZGVmYXVsdFZlcnRleFN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1NUUk9LRUNPTE9SLCJkYXJrIiE9dWlUaGVtZT8iIzJhMmEyYSI6IiNmZmZmZmYiKToiMXB4IHNvbGlkICIrKGEuc3Ryb2tlfHwKbXhVdGlscy5nZXRWYWx1ZShlLmRlZmF1bHRWZXJ0ZXhTdHlsZSxteENvbnN0YW50cy5TVFlMRV9TVFJPS0VDT0xPUiwiZGFyayIhPXVpVGhlbWU/IiMyYTJhMmEiOiIjZmZmZmZmIikpO2Vsc2V7dmFyIGY9bXhVdGlscy5nZXRWYWx1ZShlLmRlZmF1bHRWZXJ0ZXhTdHlsZSxteENvbnN0YW50cy5TVFlMRV9GSUxMQ09MT1IsIiNmZmZmZmYiKSxnPW14VXRpbHMuZ2V0VmFsdWUoZS5kZWZhdWx0VmVydGV4U3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1RST0tFQ09MT1IsIiMwMDAwMDAiKTtiLnN0eWxlLmJhY2tncm91bmRDb2xvcj1mO2Iuc3R5bGUuYm9yZGVyPSIxcHggc29saWQgIitnfWMuYXBwZW5kQ2hpbGQoYil9KTtjLmlubmVySFRNTD0iIjtmb3IodmFyIGY9MDtmPGEubGVuZ3RoO2YrKykwPGYmJjA9PW14VXRpbHMubW9kKGYsNCkmJm14VXRpbHMuYnIoYyksYihhW2ZdKX0pO251bGw9PXRoaXMuZWRpdG9yVWkuY3VycmVudFNjaGVtZT9uKCJkYXJrIj09dWlUaGVtZT8xOjApOm4odGhpcy5lZGl0b3JVaS5jdXJyZW50U2NoZW1lKTsKdmFyIGw9MTA+PXRoaXMuZGVmYXVsdENvbG9yU2NoZW1lcy5sZW5ndGg/Mjg6OCxrPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2suc3R5bGUuY3NzVGV4dD0icG9zaXRpb246YWJzb2x1dGU7bGVmdDoxMHB4O3RvcDo4cHg7Ym90dG9tOiIrbCsicHg7d2lkdGg6MjBweDttYXJnaW46NHB4O29wYWNpdHk6MC41O2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLXBvc2l0aW9uOmNlbnRlciBjZW50ZXI7YmFja2dyb3VuZC1pbWFnZTp1cmwoZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBd0FBQUFRQkFNQUFBRFFUNE0wQUFBQUlWQk1WRVVBQUFCMmRuWjRlSGgzZDNkMWRYVnhjWEYyZG5aMmRuWjJkblp4Y1hGMmRuWW1iM3cxQUFBQUNuUlNUbE1BZkNUa2hodmI3Y1FTUEgySlBnQUFBRFJKUkVGVUNOZGp3QUNNQW1CS2FpR1lzMm9KbUxQS0FaM0RhYlU4QU1SVFhwVUtvcGlzbHFGeVZ6Q0F1VVpnaWtrQlpqb0FjTVlMbnA1M1AvVUFBQUFBU1VWT1JLNUNZSUk9KTsiOwpteEV2ZW50LmFkZExpc3RlbmVyKGssImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe24obXhVdGlscy5tb2QodGhpcy5lZGl0b3JVaS5jdXJyZW50U2NoZW1lLTEsdGhpcy5kZWZhdWx0Q29sb3JTY2hlbWVzLmxlbmd0aCkpfSkpO3ZhciBtPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO20uc3R5bGUuY3NzVGV4dD0icG9zaXRpb246YWJzb2x1dGU7bGVmdDoyMDJweDt0b3A6OHB4O2JvdHRvbToiK2wrInB4O3dpZHRoOjIwcHg7bWFyZ2luOjRweDtvcGFjaXR5OjAuNTtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1wb3NpdGlvbjpjZW50ZXIgY2VudGVyO2JhY2tncm91bmQtaW1hZ2U6dXJsKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQXdBQUFBUUJBTUFBQURRVDRNMEFBQUFJVkJNVkVVQUFBQjJkbloyZG5aMmRuWjJkbloyZG5aMmRuWjJkbloyZG5aMmRuWjJkbllCdXdDY0FBQUFDblJTVGxNQWZDVGtoaHZiN2NRU1BIMkpQZ0FBQURaSlJFRlVDTmRqUUFPTUFtQkthaUdZOGxvRjVyS3N3c1psclZvOEFVaUZyVElDY2JJV0s4QTVERjFnRG9NeW1NUEFwSUF3SHdDUzBReC9VN3FDQlFBQUFBQkpSVTVFcmtKZ2dnPT0pOyI7CjE8dGhpcy5kZWZhdWx0Q29sb3JTY2hlbWVzLmxlbmd0aCYmKGEuYXBwZW5kQ2hpbGQoayksYS5hcHBlbmRDaGlsZChtKSk7bXhFdmVudC5hZGRMaXN0ZW5lcihtLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtuKG14VXRpbHMubW9kKHRoaXMuZWRpdG9yVWkuY3VycmVudFNjaGVtZSsxLHRoaXMuZGVmYXVsdENvbG9yU2NoZW1lcy5sZW5ndGgpKX0pKTtiKGspO2IobSk7dCh0aGlzLmRlZmF1bHRDb2xvclNjaGVtZXNbdGhpcy5lZGl0b3JVaS5jdXJyZW50U2NoZW1lXSk7MTA+PXRoaXMuZGVmYXVsdENvbG9yU2NoZW1lcy5sZW5ndGgmJmEuYXBwZW5kQ2hpbGQoZik7cmV0dXJuIGF9O1N0eWxlRm9ybWF0UGFuZWwucHJvdG90eXBlLmFkZEVkaXRPcHM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5mb3JtYXQuZ2V0U2VsZWN0aW9uU3RhdGUoKSxlPW51bGw7MT09dGhpcy5lZGl0b3JVaS5lZGl0b3IuZ3JhcGguZ2V0U2VsZWN0aW9uQ291bnQoKSYmKGU9bXhVdGlscy5idXR0b24obXhSZXNvdXJjZXMuZ2V0KCJlZGl0U3R5bGUiKSwKbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5lZGl0b3JVaS5hY3Rpb25zLmdldCgiZWRpdFN0eWxlIikuZnVuY3QoKX0pKSxlLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgiZWRpdFN0eWxlIikrIiAoIit0aGlzLmVkaXRvclVpLmFjdGlvbnMuZ2V0KCJlZGl0U3R5bGUiKS5zaG9ydGN1dCsiKSIpLGUuc3R5bGUud2lkdGg9IjIwMnB4IixlLnN0eWxlLm1hcmdpbkJvdHRvbT0iMnB4IixhLmFwcGVuZENoaWxkKGUpKTt2YXIgYz10aGlzLmVkaXRvclVpLmVkaXRvci5ncmFwaCxkPWMudmlldy5nZXRTdGF0ZShjLmdldFNlbGVjdGlvbkNlbGwoKSk7MT09Yy5nZXRTZWxlY3Rpb25Db3VudCgpJiZudWxsIT1kJiZudWxsIT1kLnNoYXBlJiZudWxsIT1kLnNoYXBlLnN0ZW5jaWw/KGI9bXhVdGlscy5idXR0b24obXhSZXNvdXJjZXMuZ2V0KCJlZGl0U2hhcGUiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmVkaXRvclVpLmFjdGlvbnMuZ2V0KCJlZGl0U2hhcGUiKS5mdW5jdCgpfSkpLApiLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgiZWRpdFNoYXBlIikpLGIuc3R5bGUubWFyZ2luQm90dG9tPSIycHgiLG51bGw9PWU/Yi5zdHlsZS53aWR0aD0iMjAycHgiOihlLnN0eWxlLndpZHRoPSIxMDBweCIsYi5zdHlsZS53aWR0aD0iMTAwcHgiLGIuc3R5bGUubWFyZ2luTGVmdD0iMnB4IiksYS5hcHBlbmRDaGlsZChiKSk6Yi5pbWFnZSYmKGI9bXhVdGlscy5idXR0b24obXhSZXNvdXJjZXMuZ2V0KCJlZGl0SW1hZ2UiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmVkaXRvclVpLmFjdGlvbnMuZ2V0KCJpbWFnZSIpLmZ1bmN0KCl9KSksYi5zZXRBdHRyaWJ1dGUoInRpdGxlIixteFJlc291cmNlcy5nZXQoImVkaXRJbWFnZSIpKSxiLnN0eWxlLm1hcmdpbkJvdHRvbT0iMnB4IixudWxsPT1lP2Iuc3R5bGUud2lkdGg9IjIwMnB4IjooZS5zdHlsZS53aWR0aD0iMTAwcHgiLGIuc3R5bGUud2lkdGg9IjEwMHB4IixiLnN0eWxlLm1hcmdpbkxlZnQ9CiIycHgiKSxhLmFwcGVuZENoaWxkKGIpKTtyZXR1cm4gYX19R3JhcGgucHJvdG90eXBlLmRlZmF1bHRUaGVtZU5hbWU9ImRlZmF1bHQtc3R5bGUyIjtHcmFwaC5wcm90b3R5cGUubGFzdFBhc3RlWG1sPW51bGw7R3JhcGgucHJvdG90eXBlLnBhc3RlQ291bnRlcj0wO0dyYXBoLnByb3RvdHlwZS5kZWZhdWx0U2Nyb2xsYmFycz0iMCIhPXVybFBhcmFtcy5zYjtHcmFwaC5wcm90b3R5cGUuZGVmYXVsdFBhZ2VWaXNpYmxlPSIwIiE9dXJsUGFyYW1zLnB2O0dyYXBoLnByb3RvdHlwZS5zaGFkb3dJZD0iZHJvcFNoYWRvdyI7R3JhcGgucHJvdG90eXBlLnN2Z1NoYWRvd0NvbG9yPSIjM0Q0NTc0IjtHcmFwaC5wcm90b3R5cGUuc3ZnU2hhZG93T3BhY2l0eT0iMC40IjtHcmFwaC5wcm90b3R5cGUuc3ZnU2hhZG93Qmx1cj0iMS43IjtHcmFwaC5wcm90b3R5cGUuc3ZnU2hhZG93U2l6ZT0iMyI7R3JhcGgucHJvdG90eXBlLmVkZ2VNb2RlPSJtb3ZlIiE9dXJsUGFyYW1zLmVkZ2U7dmFyIHk9R3JhcGgucHJvdG90eXBlLmluaXQ7CkdyYXBoLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhKXtiPWE7dHJ5e2lmKG14Q2xpZW50LklTX1FVSVJLU3x8Nz09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHw4PT1kb2N1bWVudC5kb2N1bWVudE1vZGUpYj1kb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdChhKSxiLnR5cGU9YS50eXBlLGIuY2FuQnViYmxlPWEuY2FuQnViYmxlLGIuY2FuY2VsYWJsZT1hLmNhbmNlbGFibGUsYi52aWV3PWEudmlldyxiLmRldGFpbD1hLmRldGFpbCxiLnNjcmVlblg9YS5zY3JlZW5YLGIuc2NyZWVuWT1hLnNjcmVlblksYi5jbGllbnRYPWEuY2xpZW50WCxiLmNsaWVudFk9YS5jbGllbnRZLGIuY3RybEtleT1hLmN0cmxLZXksYi5hbHRLZXk9YS5hbHRLZXksYi5zaGlmdEtleT1hLnNoaWZ0S2V5LGIubWV0YUtleT1hLm1ldGFLZXksYi5idXR0b249YS5idXR0b24sYi5yZWxhdGVkVGFyZ2V0PWEucmVsYXRlZFRhcmdldH1jYXRjaChJKXt9fXkuYXBwbHkodGhpcyxhcmd1bWVudHMpOwp3aW5kb3cubXhGcmVlaGFuZCYmKHRoaXMuZnJlZWhhbmQ9bmV3IG14RnJlZWhhbmQodGhpcykpO3ZhciBiPW51bGw7bXhFdmVudC5hZGRMaXN0ZW5lcih0aGlzLmNvbnRhaW5lciwibW91c2VlbnRlciIsYSk7bXhFdmVudC5hZGRMaXN0ZW5lcih0aGlzLmNvbnRhaW5lciwibW91c2Vtb3ZlIixhKTtteEV2ZW50LmFkZExpc3RlbmVyKHRoaXMuY29udGFpbmVyLCJtb3VzZWxlYXZlIixmdW5jdGlvbihhKXtiPW51bGx9KTt0aGlzLmlzTW91c2VJbnNlcnRQb2ludD1mdW5jdGlvbigpe3JldHVybiBudWxsIT1ifTt2YXIgZT10aGlzLmdldEluc2VydFBvaW50O3RoaXMuZ2V0SW5zZXJ0UG9pbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9Yj90aGlzLmdldFBvaW50Rm9yRXZlbnQoYik6ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBjPXRoaXMubGF5b3V0TWFuYWdlci5nZXRMYXlvdXQ7dGhpcy5sYXlvdXRNYW5hZ2VyLmdldExheW91dD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdyYXBoLmdldENlbGxTdHlsZShhKTsKaWYobnVsbCE9Yil7aWYoInJhY2siPT1iLmNoaWxkTGF5b3V0KXt2YXIgZT1uZXcgbXhTdGFja0xheW91dCh0aGlzLmdyYXBoLCExKTtlLmdyaWRTaXplPW51bGwhPWIucmFja1VuaXRTaXplP3BhcnNlRmxvYXQoYi5yYWNrVW5pdFNpemUpOiJ1bmRlZmluZWQiIT09dHlwZW9mIG14UmFja0NvbnRhaW5lcj9teFJhY2tDb250YWluZXIudW5pdFNpemU6MjA7ZS5maWxsPSEwO2UubWFyZ2luTGVmdD1iLm1hcmdpbkxlZnR8fDA7ZS5tYXJnaW5SaWdodD1iLm1hcmdpblJpZ2h0fHwwO2UubWFyZ2luVG9wPWIubWFyZ2luVG9wfHwwO2UubWFyZ2luQm90dG9tPWIubWFyZ2luQm90dG9tfHwwO2UuYWxsb3dHYXBzPWIuYWxsb3dHYXBzfHwwO2UucmVzaXplUGFyZW50PSExO3JldHVybiBlfWlmKCJ1bmRlZmluZWQiIT09dHlwZW9mIG14VGFibGVMYXlvdXQmJiJ0YWJsZUxheW91dCI9PWIuY2hpbGRMYXlvdXQpcmV0dXJuIGU9bmV3IG14VGFibGVMYXlvdXQodGhpcy5ncmFwaCksZS5yb3dzPWIudGFibGVSb3dzfHwKMixlLmNvbHVtbnM9Yi50YWJsZUNvbHVtbnN8fDIsZS5jb2xQZXJjZW50YWdlcz1iLmNvbFBlcmNlbnRhZ2VzLGUucm93UGVyY2VudGFnZXM9Yi5yb3dQZXJjZW50YWdlcyxlLmVxdWFsQ29sdW1ucz0iMSI9PW14VXRpbHMuZ2V0VmFsdWUoYiwiZXF1YWxDb2x1bW5zIixlLmNvbFBlcmNlbnRhZ2VzPyIwIjoiMSIpLGUuZXF1YWxSb3dzPSIxIj09bXhVdGlscy5nZXRWYWx1ZShiLCJlcXVhbFJvd3MiLGUucm93UGVyY2VudGFnZXM/IjAiOiIxIiksZS5yZXNpemVQYXJlbnQ9IjEiPT1teFV0aWxzLmdldFZhbHVlKGIsInJlc2l6ZVBhcmVudCIsIjEiKSxlLmJvcmRlcj1iLnRhYmxlQm9yZGVyfHxlLmJvcmRlcixlLm1hcmdpbkxlZnQ9Yi5tYXJnaW5MZWZ0fHwwLGUubWFyZ2luUmlnaHQ9Yi5tYXJnaW5SaWdodHx8MCxlLm1hcmdpblRvcD1iLm1hcmdpblRvcHx8MCxlLm1hcmdpbkJvdHRvbT1iLm1hcmdpbkJvdHRvbXx8MCxlLmF1dG9BZGRDb2w9IjEiPT1teFV0aWxzLmdldFZhbHVlKGIsCiJhdXRvQWRkQ29sIiwiMCIpLGUuYXV0b0FkZFJvdz0iMSI9PW14VXRpbHMuZ2V0VmFsdWUoYiwiYXV0b0FkZFJvdyIsZS5hdXRvQWRkQ29sPyIwIjoiMSIpLGUuY29sV2lkdGhzPWIuY29sV2lkdGhzfHwiMTAwIixlLnJvd0hlaWdodHM9Yi5yb3dIZWlnaHRzfHwiNTAiLGV9cmV0dXJuIGMuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt0aGlzLnVwZGF0ZUdsb2JhbFVybFZhcmlhYmxlcygpfTt2YXIgeD1HcmFwaC5wcm90b3R5cGUuaXNGYXN0Wm9vbUVuYWJsZWQ7R3JhcGgucHJvdG90eXBlLmlzRmFzdFpvb21FbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHguYXBwbHkodGhpcyxhcmd1bWVudHMpJiYoIXRoaXMuc2hhZG93VmlzaWJsZXx8IW14Q2xpZW50LklTX1NGKX07R3JhcGgucHJvdG90eXBlLnVwZGF0ZUdsb2JhbFVybFZhcmlhYmxlcz1mdW5jdGlvbigpe3RoaXMuZ2xvYmFsVmFycz1FZGl0b3IuZ2xvYmFsVmFycztpZihudWxsIT11cmxQYXJhbXMudmFycyl0cnl7dGhpcy5nbG9iYWxWYXJzPQpudWxsIT10aGlzLmdsb2JhbFZhcnM/bXhVdGlscy5jbG9uZSh0aGlzLmdsb2JhbFZhcnMpOnt9O3ZhciBhPUpTT04ucGFyc2UoZGVjb2RlVVJJQ29tcG9uZW50KHVybFBhcmFtcy52YXJzKSk7aWYobnVsbCE9YSlmb3IodmFyIGIgaW4gYSl0aGlzLmdsb2JhbFZhcnNbYl09YVtiXX1jYXRjaChCKXtudWxsIT13aW5kb3cuY29uc29sZSYmY29uc29sZS5sb2coIkVycm9yIGluIHZhcnMgVVJMIHBhcmFtZXRlcjogIitCKX19O0dyYXBoLnByb3RvdHlwZS5nZXRFeHBvcnRWYXJpYWJsZXM9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5nbG9iYWxWYXJzP214VXRpbHMuY2xvbmUodGhpcy5nbG9iYWxWYXJzKTp7fX07dmFyIEU9R3JhcGgucHJvdG90eXBlLmdldEdsb2JhbFZhcmlhYmxlO0dyYXBoLnByb3RvdHlwZS5nZXRHbG9iYWxWYXJpYWJsZT1mdW5jdGlvbihhKXt2YXIgYj1FLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtudWxsPT1iJiZudWxsIT10aGlzLmdsb2JhbFZhcnMmJihiPXRoaXMuZ2xvYmFsVmFyc1thXSk7CnJldHVybiBifTtHcmFwaC5wcm90b3R5cGUuZ2V0RGVmYXVsdFN0eWxlc2hlZXQ9ZnVuY3Rpb24oKXtpZihudWxsPT10aGlzLmRlZmF1bHRTdHlsZXNoZWV0KXt2YXIgYT10aGlzLnRoZW1lc1siZGVmYXVsdC1zdHlsZTIiXTt0aGlzLmRlZmF1bHRTdHlsZXNoZWV0PShuZXcgbXhDb2RlYyhhLm93bmVyRG9jdW1lbnQpKS5kZWNvZGUoYSl9cmV0dXJuIHRoaXMuZGVmYXVsdFN0eWxlc2hlZXR9O0dyYXBoLnByb3RvdHlwZS5pc1ZpZXdlcj1mdW5jdGlvbigpe3JldHVybiB1cmxQYXJhbXMudmlld2VyfTt2YXIgQT1HcmFwaC5wcm90b3R5cGUuZ2V0U3ZnO0dyYXBoLnByb3RvdHlwZS5nZXRTdmc9ZnVuY3Rpb24oYSxiLGUsYyxkLGYsZyxsLHAsbix0LGspe3ZhciBtPW51bGw7a3x8bnVsbD09dGhpcy50aGVtZXN8fCJkYXJrVGhlbWUiIT10aGlzLmRlZmF1bHRUaGVtZU5hbWV8fChtPXRoaXMuc3R5bGVzaGVldCx0aGlzLnN0eWxlc2hlZXQ9dGhpcy5nZXREZWZhdWx0U3R5bGVzaGVldCgpLAp0aGlzLnJlZnJlc2goKSk7dmFyIHk9QS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYodCYmbnVsbCE9dGhpcy5leHRGb250cyYmMDx0aGlzLmV4dEZvbnRzLmxlbmd0aCl7dmFyIHU9eS5vd25lckRvY3VtZW50LHY9bnVsbCE9dS5jcmVhdGVFbGVtZW50TlM/dS5jcmVhdGVFbGVtZW50TlMobXhDb25zdGFudHMuTlNfU1ZHLCJzdHlsZSIpOnUuY3JlYXRlRWxlbWVudCgic3R5bGUiKTtudWxsIT11LnNldEF0dHJpYnV0ZU5TP3Yuc2V0QXR0cmlidXRlTlMoInR5cGUiLCJ0ZXh0L2NzcyIpOnYuc2V0QXR0cmlidXRlKCJ0eXBlIiwidGV4dC9jc3MiKTtmb3IodmFyIHg9IiIsQj0iIixxPTA7cTx0aGlzLmV4dEZvbnRzLmxlbmd0aDtxKyspe3ZhciB6PXRoaXMuZXh0Rm9udHNbcV0ubmFtZSxFPXRoaXMuZXh0Rm9udHNbcV0udXJsOzA9PUUuaW5kZXhPZihFZGl0b3IuR09PR0xFX0ZPTlRTKT94Kz0iQGltcG9ydCB1cmwoIitFKyIpO1xuIjpCKz0nQGZvbnQtZmFjZSB7XG5mb250LWZhbWlseTogIicrCnorJyI7XG5zcmM6IHVybCgiJytFKyciKTtcbn1cbid9di5hcHBlbmRDaGlsZCh1LmNyZWF0ZVRleHROb2RlKHgrQikpO3kuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRlZnMiKVswXS5hcHBlbmRDaGlsZCh2KX1udWxsIT1tJiYodGhpcy5zdHlsZXNoZWV0PW0sdGhpcy5yZWZyZXNoKCkpO3JldHVybiB5fTt2YXIgQz1HcmFwaC5wcm90b3R5cGUuY3JlYXRlU3ZnSW1hZ2VFeHBvcnQ7R3JhcGgucHJvdG90eXBlLmNyZWF0ZVN2Z0ltYWdlRXhwb3J0PWZ1bmN0aW9uKCl7dmFyIGE9Qy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYodGhpcy5tYXRoRW5hYmxlZCl7dGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7dmFyIGI9YS5kcmF3VGV4dDthLmRyYXdUZXh0PWZ1bmN0aW9uKGEsZSl7aWYobnVsbCE9YS50ZXh0JiZudWxsIT1hLnRleHQudmFsdWUmJmEudGV4dC5jaGVja0JvdW5kcygpJiYobXhVdGlscy5pc05vZGUoYS50ZXh0LnZhbHVlKXx8YS50ZXh0LmRpYWxlY3Q9PQpteENvbnN0YW50cy5ESUFMRUNUX1NUUklDVEhUTUwpKXt2YXIgYz1hLnRleHQuZ2V0Q29udGVudE5vZGUoKTtpZihudWxsIT1jKXtjPWMuY2xvbmVOb2RlKCEwKTtpZihjLmdldEVsZW1lbnRzQnlUYWdOYW1lTlMpZm9yKHZhciBkPWMuZ2V0RWxlbWVudHNCeVRhZ05hbWVOUygiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCIsIm1hdGgiKTswPGQubGVuZ3RoOylkWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZFswXSk7bnVsbCE9Yy5pbm5lckhUTUwmJihkPWEudGV4dC52YWx1ZSxhLnRleHQudmFsdWU9Yy5pbm5lckhUTUwsYi5hcHBseSh0aGlzLGFyZ3VtZW50cyksYS50ZXh0LnZhbHVlPWQpfX1lbHNlIGIuYXBwbHkodGhpcyxhcmd1bWVudHMpfX1yZXR1cm4gYX07dmFyIHo9bXhHcmFwaFZpZXcucHJvdG90eXBlLnZhbGlkYXRlQmFja2dyb3VuZFBhZ2U7bXhHcmFwaFZpZXcucHJvdG90eXBlLnZhbGlkYXRlQmFja2dyb3VuZFBhZ2U9ZnVuY3Rpb24oKXt6LmFwcGx5KHRoaXMsCmFyZ3VtZW50cyk7aWYobXhDbGllbnQuSVNfR0MmJm51bGwhPXRoaXMuZ2V0RHJhd1BhbmUoKSl7dmFyIGE9dGhpcy5nZXREcmF3UGFuZSgpLnBhcmVudE5vZGU7IXRoaXMuZ3JhcGgubWF0aEVuYWJsZWR8fG14Q2xpZW50Lk5PX0ZPfHxudWxsIT10aGlzLndlYktpdEZvcmNlUmVwYWludE5vZGUmJm51bGwhPXRoaXMud2ViS2l0Rm9yY2VSZXBhaW50Tm9kZS5wYXJlbnROb2RlfHwic3ZnIiE9dGhpcy5ncmFwaC5jb250YWluZXIuZmlyc3RDaGlsZC5ub2RlTmFtZT9udWxsPT10aGlzLndlYktpdEZvcmNlUmVwYWludE5vZGV8fHRoaXMuZ3JhcGgubWF0aEVuYWJsZWQmJigic3ZnIj09dGhpcy5ncmFwaC5jb250YWluZXIuZmlyc3RDaGlsZC5ub2RlTmFtZXx8dGhpcy5ncmFwaC5jb250YWluZXIuZmlyc3RDaGlsZD09dGhpcy53ZWJLaXRGb3JjZVJlcGFpbnROb2RlKXx8KG51bGwhPXRoaXMud2ViS2l0Rm9yY2VSZXBhaW50Tm9kZS5wYXJlbnROb2RlJiZ0aGlzLndlYktpdEZvcmNlUmVwYWludE5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLndlYktpdEZvcmNlUmVwYWludE5vZGUpLAp0aGlzLndlYktpdEZvcmNlUmVwYWludE5vZGU9bnVsbCk6KHRoaXMud2ViS2l0Rm9yY2VSZXBhaW50Tm9kZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSx0aGlzLndlYktpdEZvcmNlUmVwYWludE5vZGUuc3R5bGUuY3NzVGV4dD0icG9zaXRpb246YWJzb2x1dGU7IixhLm93bmVyU1ZHRWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLndlYktpdEZvcmNlUmVwYWludE5vZGUsYS5vd25lclNWR0VsZW1lbnQpKX19O3ZhciBEPUdyYXBoLnByb3RvdHlwZS5sb2FkU3R5bGVzaGVldDtHcmFwaC5wcm90b3R5cGUubG9hZFN0eWxlc2hlZXQ9ZnVuY3Rpb24oKXtELmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLmN1cnJlbnRTdHlsZT0iZGVmYXVsdC1zdHlsZTIifTtHcmFwaC5wcm90b3R5cGUuaGFuZGxlQ3VzdG9tTGluaz1mdW5jdGlvbihhKXtpZigiZGF0YTphY3Rpb24vanNvbiwiPT1hLnN1YnN0cmluZygwLDE3KSYmKGE9SlNPTi5wYXJzZShhLnN1YnN0cmluZygxNykpLApudWxsIT1hLmFjdGlvbnMpKXtmb3IodmFyIGI9MDtiPGEuYWN0aW9ucy5sZW5ndGg7YisrKXt2YXIgZT1hLmFjdGlvbnNbYl07aWYobnVsbCE9ZS5vcGVuKWlmKHRoaXMuaXNDdXN0b21MaW5rKGUub3Blbikpe2lmKCF0aGlzLmN1c3RvbUxpbmtDbGlja2VkKGUub3BlbikpcmV0dXJufWVsc2UgdGhpcy5vcGVuTGluayhlLm9wZW4pfXRoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKGI9MDtiPGEuYWN0aW9ucy5sZW5ndGg7YisrKWU9YS5hY3Rpb25zW2JdLG51bGwhPWUudG9nZ2xlJiZ0aGlzLnRvZ2dsZUNlbGxzKHRoaXMuZ2V0Q2VsbHNGb3JBY3Rpb24oZS50b2dnbGUsITApKSxudWxsIT1lLnNob3cmJnRoaXMuc2V0Q2VsbHNWaXNpYmxlKHRoaXMuZ2V0Q2VsbHNGb3JBY3Rpb24oZS5zaG93LCEwKSwhMCksbnVsbCE9ZS5oaWRlJiZ0aGlzLnNldENlbGxzVmlzaWJsZSh0aGlzLmdldENlbGxzRm9yQWN0aW9uKGUuaGlkZSwhMCksITEpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX1mb3IoYj0KMDtiPGEuYWN0aW9ucy5sZW5ndGg7YisrKXt2YXIgZT1hLmFjdGlvbnNbYl0sYz1bXTtudWxsIT1lLnNlbGVjdCYmdGhpcy5pc0VuYWJsZWQoKSYmKGM9dGhpcy5nZXRDZWxsc0ZvckFjdGlvbihlLnNlbGVjdCksdGhpcy5zZXRTZWxlY3Rpb25DZWxscyhjKSk7bnVsbCE9ZS5oaWdobGlnaHQmJihjPXRoaXMuZ2V0Q2VsbHNGb3JBY3Rpb24oZS5oaWdobGlnaHQpLHRoaXMuaGlnaGxpZ2h0Q2VsbHMoYyxlLmhpZ2hsaWdodC5jb2xvcixlLmhpZ2hsaWdodC5kdXJhdGlvbixlLmhpZ2hsaWdodC5vcGFjaXR5KSk7bnVsbCE9ZS5zY3JvbGwmJihjPXRoaXMuZ2V0Q2VsbHNGb3JBY3Rpb24oZS5zY3JvbGwpKTswPGMubGVuZ3RoJiZ0aGlzLnNjcm9sbENlbGxUb1Zpc2libGUoY1swXSl9fX07R3JhcGgucHJvdG90eXBlLnVwZGF0ZUN1c3RvbUxpbmtzRm9yQ2VsbD1mdW5jdGlvbihhLGIpe3ZhciBlPXRoaXMuZ2V0TGlua0ZvckNlbGwoYik7bnVsbCE9ZSYmImRhdGE6YWN0aW9uL2pzb24sIj09CmUuc3Vic3RyaW5nKDAsMTcpJiZ0aGlzLnNldExpbmtGb3JDZWxsKGIsdGhpcy51cGRhdGVDdXN0b21MaW5rKGEsZSkpO2lmKHRoaXMuaXNIdG1sTGFiZWwoYikpe3ZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2MuaW5uZXJIVE1MPXRoaXMuc2FuaXRpemVIdG1sKHRoaXMuZ2V0TGFiZWwoYikpO2Zvcih2YXIgZD1jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJhIiksZj0hMSxnPTA7ZzxkLmxlbmd0aDtnKyspZT1kW2ddLmdldEF0dHJpYnV0ZSgiaHJlZiIpLG51bGwhPWUmJiJkYXRhOmFjdGlvbi9qc29uLCI9PWUuc3Vic3RyaW5nKDAsMTcpJiYoZFtnXS5zZXRBdHRyaWJ1dGUoImhyZWYiLHRoaXMudXBkYXRlQ3VzdG9tTGluayhhLGUpKSxmPSEwKTtmJiZ0aGlzLmxhYmVsQ2hhbmdlZChiLGMuaW5uZXJIVE1MKX19O0dyYXBoLnByb3RvdHlwZS51cGRhdGVDdXN0b21MaW5rPWZ1bmN0aW9uKGEsYil7aWYoImRhdGE6YWN0aW9uL2pzb24sIj09Yi5zdWJzdHJpbmcoMCwxNykpdHJ5e3ZhciBlPQpKU09OLnBhcnNlKGIuc3Vic3RyaW5nKDE3KSk7bnVsbCE9ZS5hY3Rpb25zJiYodGhpcy51cGRhdGVDdXN0b21MaW5rQWN0aW9ucyhhLGUuYWN0aW9ucyksYj0iZGF0YTphY3Rpb24vanNvbiwiK0pTT04uc3RyaW5naWZ5KGUpKX1jYXRjaChNKXt9cmV0dXJuIGJ9O0dyYXBoLnByb3RvdHlwZS51cGRhdGVDdXN0b21MaW5rQWN0aW9ucz1mdW5jdGlvbihhLGIpe2Zvcih2YXIgZT0wO2U8Yi5sZW5ndGg7ZSsrKXt2YXIgYz1iW2VdO3RoaXMudXBkYXRlQ3VzdG9tTGlua0FjdGlvbihhLGMudG9nZ2xlKTt0aGlzLnVwZGF0ZUN1c3RvbUxpbmtBY3Rpb24oYSxjLnNob3cpO3RoaXMudXBkYXRlQ3VzdG9tTGlua0FjdGlvbihhLGMuaGlkZSk7dGhpcy51cGRhdGVDdXN0b21MaW5rQWN0aW9uKGEsYy5zZWxlY3QpO3RoaXMudXBkYXRlQ3VzdG9tTGlua0FjdGlvbihhLGMuaGlnaGxpZ2h0KTt0aGlzLnVwZGF0ZUN1c3RvbUxpbmtBY3Rpb24oYSxjLnNjcm9sbCl9fTtHcmFwaC5wcm90b3R5cGUudXBkYXRlQ3VzdG9tTGlua0FjdGlvbj0KZnVuY3Rpb24oYSxiKXtpZihudWxsIT1iJiZudWxsIT1iLmNlbGxzKXtmb3IodmFyIGU9W10sYz0wO2M8Yi5jZWxscy5sZW5ndGg7YysrKWlmKCIqIj09Yi5jZWxsc1tjXSllLnB1c2goYi5jZWxsc1tjXSk7ZWxzZXt2YXIgZD1hW2IuY2VsbHNbY11dO251bGwhPWQ/IiIhPWQmJmUucHVzaChkKTplLnB1c2goYi5jZWxsc1tjXSl9Yi5jZWxscz1lfX07R3JhcGgucHJvdG90eXBlLmdldENlbGxzRm9yQWN0aW9uPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuZ2V0Q2VsbHNCeUlkKGEuY2VsbHMpLmNvbmNhdCh0aGlzLmdldENlbGxzRm9yVGFncyhhLnRhZ3MsbnVsbCxudWxsLGIpKX07R3JhcGgucHJvdG90eXBlLmdldENlbGxzQnlJZD1mdW5jdGlvbihhKXt2YXIgYj1bXTtpZihudWxsIT1hKWZvcih2YXIgZT0wO2U8YS5sZW5ndGg7ZSsrKWlmKCIqIj09YVtlXSl2YXIgYz10aGlzLmdldERlZmF1bHRQYXJlbnQoKSxiPWIuY29uY2F0KHRoaXMubW9kZWwuZmlsdGVyRGVzY2VuZGFudHMoZnVuY3Rpb24oYSl7cmV0dXJuIGEhPQpjfSxjKSk7ZWxzZXt2YXIgZD10aGlzLm1vZGVsLmdldENlbGwoYVtlXSk7bnVsbCE9ZCYmYi5wdXNoKGQpfXJldHVybiBifTtHcmFwaC5wcm90b3R5cGUuZ2V0Q2VsbHNGb3JUYWdzPWZ1bmN0aW9uKGEsYixlLGMpe3ZhciBkPVtdO2lmKG51bGwhPWEpe2I9bnVsbCE9Yj9iOnRoaXMubW9kZWwuZ2V0RGVzY2VuZGFudHModGhpcy5tb2RlbC5nZXRSb290KCkpO2U9bnVsbCE9ZT9lOiJ0YWdzIjtmb3IodmFyIGY9MCxnPXt9LGw9MDtsPGEubGVuZ3RoO2wrKykwPGFbbF0ubGVuZ3RoJiYoZ1thW2xdLnRvTG93ZXJDYXNlKCldPSEwLGYrKyk7Zm9yKGw9MDtsPGIubGVuZ3RoO2wrKylpZihjJiZ0aGlzLm1vZGVsLmdldFBhcmVudChiW2xdKT09dGhpcy5tb2RlbC5yb290fHx0aGlzLm1vZGVsLmlzVmVydGV4KGJbbF0pfHx0aGlzLm1vZGVsLmlzRWRnZShiW2xdKSl7dmFyIHA9bnVsbCE9YltsXS52YWx1ZSYmIm9iamVjdCI9PXR5cGVvZiBiW2xdLnZhbHVlP214VXRpbHMudHJpbShiW2xdLnZhbHVlLmdldEF0dHJpYnV0ZShlKXx8CiIiKToiIixuPSExO2lmKDA8cC5sZW5ndGgpe2lmKHA9cC50b0xvd2VyQ2FzZSgpLnNwbGl0KCIgIikscC5sZW5ndGg+PWEubGVuZ3RoKXtmb3IodmFyIHQ9bj0wO3Q8cC5sZW5ndGgmJm48Zjt0KyspbnVsbCE9Z1twW3RdXSYmbisrO249bj09Zn19ZWxzZSBuPTA9PWEubGVuZ3RoO24mJmQucHVzaChiW2xdKX19cmV0dXJuIGR9O0dyYXBoLnByb3RvdHlwZS50b2dnbGVDZWxscz1mdW5jdGlvbihhKXt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXRoaXMubW9kZWwuc2V0VmlzaWJsZShhW2JdLCF0aGlzLm1vZGVsLmlzVmlzaWJsZShhW2JdKSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX07R3JhcGgucHJvdG90eXBlLnNldENlbGxzVmlzaWJsZT1mdW5jdGlvbihhLGIpe3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBlPTA7ZTxhLmxlbmd0aDtlKyspdGhpcy5tb2RlbC5zZXRWaXNpYmxlKGFbZV0sYil9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX07CkdyYXBoLnByb3RvdHlwZS5oaWdobGlnaHRDZWxscz1mdW5jdGlvbihhLGIsZSxjKXtmb3IodmFyIGQ9MDtkPGEubGVuZ3RoO2QrKyl0aGlzLmhpZ2hsaWdodENlbGwoYVtkXSxiLGUsYyl9O0dyYXBoLnByb3RvdHlwZS5oaWdobGlnaHRDZWxsPWZ1bmN0aW9uKGEsYixlLGMpe2I9bnVsbCE9Yj9iOm14Q29uc3RhbnRzLkRFRkFVTFRfVkFMSURfQ09MT1I7ZT1udWxsIT1lP2U6MUUzO2E9dGhpcy52aWV3LmdldFN0YXRlKGEpO2lmKG51bGwhPWEpe3ZhciBkPU1hdGgubWF4KDUsbXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1NUUk9LRVdJRFRILDEpKzQpLGY9bmV3IG14Q2VsbEhpZ2hsaWdodCh0aGlzLGIsZCwhMSk7bnVsbCE9YyYmKGYub3BhY2l0eT1jKTtmLmhpZ2hsaWdodChhKTt3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe251bGwhPWYuc2hhcGUmJihteFV0aWxzLnNldFByZWZpeGVkU3R5bGUoZi5zaGFwZS5ub2RlLnN0eWxlLCJ0cmFuc2l0aW9uIiwKImFsbCAxMjAwbXMgZWFzZS1pbi1vdXQiKSxmLnNoYXBlLm5vZGUuc3R5bGUub3BhY2l0eT0wKTt3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe2YuZGVzdHJveSgpfSwxMjAwKX0sZSl9fTtHcmFwaC5wcm90b3R5cGUuYWRkU3ZnU2hhZG93PWZ1bmN0aW9uKGEsYixlKXtlPW51bGwhPWU/ZTohMTt2YXIgYz1hLm93bmVyRG9jdW1lbnQsZD1udWxsIT1jLmNyZWF0ZUVsZW1lbnROUz9jLmNyZWF0ZUVsZW1lbnROUyhteENvbnN0YW50cy5OU19TVkcsImZpbHRlciIpOmMuY3JlYXRlRWxlbWVudCgiZmlsdGVyIik7ZC5zZXRBdHRyaWJ1dGUoImlkIix0aGlzLnNoYWRvd0lkKTt2YXIgZj1udWxsIT1jLmNyZWF0ZUVsZW1lbnROUz9jLmNyZWF0ZUVsZW1lbnROUyhteENvbnN0YW50cy5OU19TVkcsImZlR2F1c3NpYW5CbHVyIik6Yy5jcmVhdGVFbGVtZW50KCJmZUdhdXNzaWFuQmx1ciIpO2Yuc2V0QXR0cmlidXRlKCJpbiIsIlNvdXJjZUFscGhhIik7Zi5zZXRBdHRyaWJ1dGUoInN0ZERldmlhdGlvbiIsCnRoaXMuc3ZnU2hhZG93Qmx1cik7Zi5zZXRBdHRyaWJ1dGUoInJlc3VsdCIsImJsdXIiKTtkLmFwcGVuZENoaWxkKGYpO2Y9bnVsbCE9Yy5jcmVhdGVFbGVtZW50TlM/Yy5jcmVhdGVFbGVtZW50TlMobXhDb25zdGFudHMuTlNfU1ZHLCJmZU9mZnNldCIpOmMuY3JlYXRlRWxlbWVudCgiZmVPZmZzZXQiKTtmLnNldEF0dHJpYnV0ZSgiaW4iLCJibHVyIik7Zi5zZXRBdHRyaWJ1dGUoImR4Iix0aGlzLnN2Z1NoYWRvd1NpemUpO2Yuc2V0QXR0cmlidXRlKCJkeSIsdGhpcy5zdmdTaGFkb3dTaXplKTtmLnNldEF0dHJpYnV0ZSgicmVzdWx0Iiwib2Zmc2V0Qmx1ciIpO2QuYXBwZW5kQ2hpbGQoZik7Zj1udWxsIT1jLmNyZWF0ZUVsZW1lbnROUz9jLmNyZWF0ZUVsZW1lbnROUyhteENvbnN0YW50cy5OU19TVkcsImZlRmxvb2QiKTpjLmNyZWF0ZUVsZW1lbnQoImZlRmxvb2QiKTtmLnNldEF0dHJpYnV0ZSgiZmxvb2QtY29sb3IiLHRoaXMuc3ZnU2hhZG93Q29sb3IpO2Yuc2V0QXR0cmlidXRlKCJmbG9vZC1vcGFjaXR5IiwKdGhpcy5zdmdTaGFkb3dPcGFjaXR5KTtmLnNldEF0dHJpYnV0ZSgicmVzdWx0Iiwib2Zmc2V0Q29sb3IiKTtkLmFwcGVuZENoaWxkKGYpO2Y9bnVsbCE9Yy5jcmVhdGVFbGVtZW50TlM/Yy5jcmVhdGVFbGVtZW50TlMobXhDb25zdGFudHMuTlNfU1ZHLCJmZUNvbXBvc2l0ZSIpOmMuY3JlYXRlRWxlbWVudCgiZmVDb21wb3NpdGUiKTtmLnNldEF0dHJpYnV0ZSgiaW4iLCJvZmZzZXRDb2xvciIpO2Yuc2V0QXR0cmlidXRlKCJpbjIiLCJvZmZzZXRCbHVyIik7Zi5zZXRBdHRyaWJ1dGUoIm9wZXJhdG9yIiwiaW4iKTtmLnNldEF0dHJpYnV0ZSgicmVzdWx0Iiwib2Zmc2V0Qmx1ciIpO2QuYXBwZW5kQ2hpbGQoZik7Zj1udWxsIT1jLmNyZWF0ZUVsZW1lbnROUz9jLmNyZWF0ZUVsZW1lbnROUyhteENvbnN0YW50cy5OU19TVkcsImZlQmxlbmQiKTpjLmNyZWF0ZUVsZW1lbnQoImZlQmxlbmQiKTtmLnNldEF0dHJpYnV0ZSgiaW4iLCJTb3VyY2VHcmFwaGljIik7Zi5zZXRBdHRyaWJ1dGUoImluMiIsCiJvZmZzZXRCbHVyIik7ZC5hcHBlbmRDaGlsZChmKTtmPWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRlZnMiKTswPT1mLmxlbmd0aD8oYz1udWxsIT1jLmNyZWF0ZUVsZW1lbnROUz9jLmNyZWF0ZUVsZW1lbnROUyhteENvbnN0YW50cy5OU19TVkcsImRlZnMiKTpjLmNyZWF0ZUVsZW1lbnQoImRlZnMiKSxudWxsIT1hLmZpcnN0Q2hpbGQ/YS5pbnNlcnRCZWZvcmUoYyxhLmZpcnN0Q2hpbGQpOmEuYXBwZW5kQ2hpbGQoYykpOmM9ZlswXTtjLmFwcGVuZENoaWxkKGQpO2V8fChiPW51bGwhPWI/YjphLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJnIilbMF0sbnVsbCE9YiYmKGIuc2V0QXR0cmlidXRlKCJmaWx0ZXIiLCJ1cmwoIyIrdGhpcy5zaGFkb3dJZCsiKSIpLGlzTmFOKHBhcnNlSW50KGEuZ2V0QXR0cmlidXRlKCJ3aWR0aCIpKSl8fChhLnNldEF0dHJpYnV0ZSgid2lkdGgiLHBhcnNlSW50KGEuZ2V0QXR0cmlidXRlKCJ3aWR0aCIpKSs2KSxhLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixwYXJzZUludChhLmdldEF0dHJpYnV0ZSgiaGVpZ2h0IikpKwo2KSxiPWEuZ2V0QXR0cmlidXRlKCJ2aWV3Qm94IiksbnVsbCE9YiYmMDxiLmxlbmd0aCYmKGI9Yi5zcGxpdCgiICIpLDM8Yi5sZW5ndGgmJih3PXBhcnNlRmxvYXQoYlsyXSkrNixoPXBhcnNlRmxvYXQoYlszXSkrNixhLnNldEF0dHJpYnV0ZSgidmlld0JveCIsYlswXSsiICIrYlsxXSsiICIrdysiICIraCkpKSkpKTtyZXR1cm4gZH07R3JhcGgucHJvdG90eXBlLnNldFNoYWRvd1Zpc2libGU9ZnVuY3Rpb24oYSxiKXtteENsaWVudC5JU19TVkcmJiFteENsaWVudC5JU19TRiYmKGI9bnVsbCE9Yj9iOiEwLCh0aGlzLnNoYWRvd1Zpc2libGU9YSk/dGhpcy52aWV3LmdldERyYXdQYW5lKCkuc2V0QXR0cmlidXRlKCJmaWx0ZXIiLCJ1cmwoIyIrdGhpcy5zaGFkb3dJZCsiKSIpOnRoaXMudmlldy5nZXREcmF3UGFuZSgpLnJlbW92ZUF0dHJpYnV0ZSgiZmlsdGVyIiksYiYmdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInNoYWRvd1Zpc2libGVDaGFuZ2VkIikpKX07R3JhcGgucHJvdG90eXBlLnNlbGVjdFVubG9ja2VkTGF5ZXI9CmZ1bmN0aW9uKCl7aWYobnVsbD09dGhpcy5kZWZhdWx0UGFyZW50KXt2YXIgYT10aGlzLm1vZGVsLmdldENoaWxkQ291bnQodGhpcy5tb2RlbC5yb290KSxiLGU9MDtkbyBiPXRoaXMubW9kZWwuZ2V0Q2hpbGRBdCh0aGlzLm1vZGVsLnJvb3QsZSk7d2hpbGUoZSsrPGEmJiIxIj09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLmdldENlbGxTdHlsZShiKSwibG9ja2VkIiwiMCIpKTtudWxsIT1iJiZ0aGlzLnNldERlZmF1bHRQYXJlbnQoYil9fTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMubW9ja3VwPVtTSEFQRVNfUEFUSCsiL21vY2t1cC9teE1vY2t1cEJ1dHRvbnMuanMiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMuYXJyb3dzMj1bU0hBUEVTX1BBVEgrIi9teEFycm93cy5qcyJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5hdGxhc3NpYW49W1NURU5DSUxfUEFUSCsiL2F0bGFzc2lhbi54bWwiLFNIQVBFU19QQVRIKyIvbXhBdGxhc3NpYW4uanMiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMuYnBtbj0KW1NIQVBFU19QQVRIKyIvYnBtbi9teEJwbW5TaGFwZTIuanMiLFNURU5DSUxfUEFUSCsiL2JwbW4ueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLmM0PVtTSEFQRVNfUEFUSCsiL214QzQuanMiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMuY2lzY28xOT1bU0hBUEVTX1BBVEgrIi9teENpc2NvMTkuanMiLFNURU5DSUxfUEFUSCsiL2Npc2NvMTkueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLmNpc2NvX3NhZmU9W1NIQVBFU19QQVRIKyIvbXhDaXNjb1NhZmUuanMiLFNURU5DSUxfUEFUSCsiL2Npc2NvX3NhZmUvYXJjaGl0ZWN0dXJlLnhtbCIsU1RFTkNJTF9QQVRIKyIvY2lzY29fc2FmZS9idXNpbmVzc19pY29ucy54bWwiLFNURU5DSUxfUEFUSCsiL2Npc2NvX3NhZmUvY2FwYWJpbGl0eS54bWwiLFNURU5DSUxfUEFUSCsiL2Npc2NvX3NhZmUvZGVzaWduLnhtbCIsU1RFTkNJTF9QQVRIKyIvY2lzY29fc2FmZS9pb3RfdGhpbmdzX2ljb25zLnhtbCIsClNURU5DSUxfUEFUSCsiL2Npc2NvX3NhZmUvcGVvcGxlX3BsYWNlc190aGluZ3NfaWNvbnMueG1sIixTVEVOQ0lMX1BBVEgrIi9jaXNjb19zYWZlL3NlY3VyaXR5X2ljb25zLnhtbCIsU1RFTkNJTF9QQVRIKyIvY2lzY29fc2FmZS90ZWNobm9sb2d5X2ljb25zLnhtbCIsU1RFTkNJTF9QQVRIKyIvY2lzY29fc2FmZS90aHJlYXQueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLmRmZD1bU0hBUEVTX1BBVEgrIi9teERGRC5qcyJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5lcj1bU0hBUEVTX1BBVEgrIi9lci9teEVSLmpzIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLmt1YmVybmV0ZXM9W1NIQVBFU19QQVRIKyIvbXhLdWJlcm5ldGVzLmpzIixTVEVOQ0lMX1BBVEgrIi9rdWJlcm5ldGVzLnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5mbG93Y2hhcnQ9W1NIQVBFU19QQVRIKyIvbXhGbG93Y2hhcnQuanMiLFNURU5DSUxfUEFUSCsiL2Zsb3djaGFydC54bWwiXTsKbXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLmlvcz1bU0hBUEVTX1BBVEgrIi9tb2NrdXAvbXhNb2NrdXBpT1MuanMiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMucmFja0dlbmVyYWw9W1NIQVBFU19QQVRIKyIvcmFjay9teFJhY2suanMiLFNURU5DSUxfUEFUSCsiL3JhY2svZ2VuZXJhbC54bWwiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMucmFja0Y1PVtTVEVOQ0lMX1BBVEgrIi9yYWNrL2Y1LnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5sZWFuX21hcHBpbmc9W1NIQVBFU19QQVRIKyIvbXhMZWFuTWFwLmpzIixTVEVOQ0lMX1BBVEgrIi9sZWFuX21hcHBpbmcueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLmJhc2ljPVtTSEFQRVNfUEFUSCsiL214QmFzaWMuanMiLFNURU5DSUxfUEFUSCsiL2Jhc2ljLnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5pb3M3aWNvbnM9W1NURU5DSUxfUEFUSCsiL2lvczcvaWNvbnMueG1sIl07Cm14U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5pb3M3dWk9W1NIQVBFU19QQVRIKyIvaW9zNy9teElPUzdVaS5qcyIsU1RFTkNJTF9QQVRIKyIvaW9zNy9taXNjLnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5hbmRyb2lkPVtTSEFQRVNfUEFUSCsiL214QW5kcm9pZC5qcyIsU1RFTkNJTF9QQVRIKyIvYW5kcm9pZC9hbmRyb2lkLnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllc1siZWxlY3RyaWNhbC9taXNjZWxsYW5lb3VzIl09W1NIQVBFU19QQVRIKyIvbXhFbGVjdHJpY2FsLmpzIixTVEVOQ0lMX1BBVEgrIi9lbGVjdHJpY2FsL21pc2NlbGxhbmVvdXMueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzWyJlbGVjdHJpY2FsL3RyYW5zbWlzc2lvbiJdPVtTSEFQRVNfUEFUSCsiL214RWxlY3RyaWNhbC5qcyIsU1RFTkNJTF9QQVRIKyIvZWxlY3RyaWNhbC90cmFuc21pc3Npb24ueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzWyJlbGVjdHJpY2FsL2xvZ2ljX2dhdGVzIl09CltTSEFQRVNfUEFUSCsiL214RWxlY3RyaWNhbC5qcyIsU1RFTkNJTF9QQVRIKyIvZWxlY3RyaWNhbC9sb2dpY19nYXRlcy54bWwiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXNbImVsZWN0cmljYWwvYWJzdHJhY3QiXT1bU0hBUEVTX1BBVEgrIi9teEVsZWN0cmljYWwuanMiLFNURU5DSUxfUEFUSCsiL2VsZWN0cmljYWwvYWJzdHJhY3QueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLmluZm9ncmFwaGljPVtTSEFQRVNfUEFUSCsiL214SW5mb2dyYXBoaWMuanMiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXNbIm1vY2t1cC9idXR0b25zIl09W1NIQVBFU19QQVRIKyIvbW9ja3VwL214TW9ja3VwQnV0dG9ucy5qcyJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllc1sibW9ja3VwL2NvbnRhaW5lcnMiXT1bU0hBUEVTX1BBVEgrIi9tb2NrdXAvbXhNb2NrdXBDb250YWluZXJzLmpzIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzWyJtb2NrdXAvZm9ybXMiXT0KW1NIQVBFU19QQVRIKyIvbW9ja3VwL214TW9ja3VwRm9ybXMuanMiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXNbIm1vY2t1cC9ncmFwaGljcyJdPVtTSEFQRVNfUEFUSCsiL21vY2t1cC9teE1vY2t1cEdyYXBoaWNzLmpzIixTVEVOQ0lMX1BBVEgrIi9tb2NrdXAvbWlzYy54bWwiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXNbIm1vY2t1cC9tYXJrdXAiXT1bU0hBUEVTX1BBVEgrIi9tb2NrdXAvbXhNb2NrdXBNYXJrdXAuanMiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXNbIm1vY2t1cC9taXNjIl09W1NIQVBFU19QQVRIKyIvbW9ja3VwL214TW9ja3VwTWlzYy5qcyIsU1RFTkNJTF9QQVRIKyIvbW9ja3VwL21pc2MueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzWyJtb2NrdXAvbmF2aWdhdGlvbiJdPVtTSEFQRVNfUEFUSCsiL21vY2t1cC9teE1vY2t1cE5hdmlnYXRpb24uanMiLFNURU5DSUxfUEFUSCsiL21vY2t1cC9taXNjLnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllc1sibW9ja3VwL3RleHQiXT0KW1NIQVBFU19QQVRIKyIvbW9ja3VwL214TW9ja3VwVGV4dC5qcyJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5mbG9vcnBsYW49W1NIQVBFU19QQVRIKyIvbXhGbG9vcnBsYW4uanMiLFNURU5DSUxfUEFUSCsiL2Zsb29ycGxhbi54bWwiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMuYm9vdHN0cmFwPVtTSEFQRVNfUEFUSCsiL214Qm9vdHN0cmFwLmpzIixTSEFQRVNfUEFUSCsiL214QmFzaWMuanMiLFNURU5DSUxfUEFUSCsiL2Jvb3RzdHJhcC54bWwiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMuZ21kbD1bU0hBUEVTX1BBVEgrIi9teEdtZGwuanMiLFNURU5DSUxfUEFUSCsiL2dtZGwueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLmdjcDI9W1NIQVBFU19QQVRIKyIvbXhHQ1AyLmpzIixTVEVOQ0lMX1BBVEgrIi9nY3AyLnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5pYm09W1NIQVBFU19QQVRIKyIvbXhJQk0uanMiLFNURU5DSUxfUEFUSCsKIi9pYm0ueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLmNhYmluZXRzPVtTSEFQRVNfUEFUSCsiL214Q2FiaW5ldHMuanMiLFNURU5DSUxfUEFUSCsiL2NhYmluZXRzLnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5hcmNoaW1hdGU9W1NIQVBFU19QQVRIKyIvbXhBcmNoaU1hdGUuanMiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMuYXJjaGltYXRlMz1bU0hBUEVTX1BBVEgrIi9teEFyY2hpTWF0ZTMuanMiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMuc3lzbWw9W1NIQVBFU19QQVRIKyIvbXhTeXNNTC5qcyJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5laXA9W1NIQVBFU19QQVRIKyIvbXhFaXAuanMiLFNURU5DSUxfUEFUSCsiL2VpcC54bWwiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMubmV0d29ya3M9W1NIQVBFU19QQVRIKyIvbXhOZXR3b3Jrcy5qcyIsU1RFTkNJTF9QQVRIKyIvbmV0d29ya3MueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLmF3czNkPQpbU0hBUEVTX1BBVEgrIi9teEFXUzNELmpzIixTVEVOQ0lMX1BBVEgrIi9hd3MzZC54bWwiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMuYXdzND1bU0hBUEVTX1BBVEgrIi9teEFXUzQuanMiLFNURU5DSUxfUEFUSCsiL2F3czQueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLmF3czRiPVtTSEFQRVNfUEFUSCsiL214QVdTNC5qcyIsU1RFTkNJTF9QQVRIKyIvYXdzNC54bWwiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMudmVlYW09W1NURU5DSUxfUEFUSCsiL3ZlZWFtLzJkLnhtbCIsU1RFTkNJTF9QQVRIKyIvdmVlYW0vM2QueG1sIixTVEVOQ0lMX1BBVEgrIi92ZWVhbS92ZWVhbS54bWwiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMudmVlYW0yPVtTVEVOQ0lMX1BBVEgrIi92ZWVhbS8yZC54bWwiLFNURU5DSUxfUEFUSCsiL3ZlZWFtLzNkLnhtbCIsU1RFTkNJTF9QQVRIKyIvdmVlYW0vdmVlYW0yLnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5waWQyaW5zdD0KW1NIQVBFU19QQVRIKyIvcGlkMi9teFBpZEluc3RydW1lbnRzLmpzIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLnBpZDJtaXNjPVtTSEFQRVNfUEFUSCsiL3BpZDIvbXhQaWRNaXNjLmpzIixTVEVOQ0lMX1BBVEgrIi9waWQvbWlzYy54bWwiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMucGlkMnZhbHZlcz1bU0hBUEVTX1BBVEgrIi9waWQyL214UGlkVmFsdmVzLmpzIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLnBpZEZsb3dTZW5zb3JzPVtTVEVOQ0lMX1BBVEgrIi9waWQvZmxvd19zZW5zb3JzLnhtbCJdO214TWFya2VyLmdldFBhY2thZ2VGb3JUeXBlPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7bnVsbCE9YSYmMDxhLmxlbmd0aCYmKCJFUiI9PWEuc3Vic3RyaW5nKDAsMik/Yj0ibXhncmFwaC5lciI6InN5c01MIj09YS5zdWJzdHJpbmcoMCw1KSYmKGI9Im14Z3JhcGguc3lzbWwiKSk7cmV0dXJuIGJ9O3ZhciBHPW14TWFya2VyLmNyZWF0ZU1hcmtlcjtteE1hcmtlci5jcmVhdGVNYXJrZXI9CmZ1bmN0aW9uKGEsYixlLGMsZCxmLGcsbCxwLG4pe2lmKG51bGwhPWUmJm51bGw9PW14TWFya2VyLm1hcmtlcnNbZV0pe3ZhciB0PXRoaXMuZ2V0UGFja2FnZUZvclR5cGUoZSk7bnVsbCE9dCYmbXhTdGVuY2lsUmVnaXN0cnkuZ2V0U3RlbmNpbCh0KX1yZXR1cm4gRy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O1ByaW50RGlhbG9nLnByb3RvdHlwZS5jcmVhdGU9ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBlKCl7eS52YWx1ZT1NYXRoLm1heCgxLE1hdGgubWluKGwsTWF0aC5tYXgocGFyc2VJbnQoeS52YWx1ZSkscGFyc2VJbnQobS52YWx1ZSkpKSk7bS52YWx1ZT1NYXRoLm1heCgxLE1hdGgubWluKGwsTWF0aC5taW4ocGFyc2VJbnQoeS52YWx1ZSkscGFyc2VJbnQobS52YWx1ZSkpKSl9ZnVuY3Rpb24gYyhiKXtmdW5jdGlvbiBlKGIsZSxmKXt2YXIgZz1iLnVzZUNzc1RyYW5zZm9ybXMsbD1iLmN1cnJlbnRUcmFuc2xhdGUscD1iLmN1cnJlbnRTY2FsZSxuPWIudmlldy50cmFuc2xhdGUsdD0KYi52aWV3LnNjYWxlO2IudXNlQ3NzVHJhbnNmb3JtcyYmKGIudXNlQ3NzVHJhbnNmb3Jtcz0hMSxiLmN1cnJlbnRUcmFuc2xhdGU9bmV3IG14UG9pbnQoMCwwKSxiLmN1cnJlbnRTY2FsZT0xLGIudmlldy50cmFuc2xhdGU9bmV3IG14UG9pbnQoMCwwKSxiLnZpZXcuc2NhbGU9MSk7dmFyIGs9Yi5nZXRHcmFwaEJvdW5kcygpLG09MCx5PTAsdj1zYS5nZXQoKSx4PTEvYi5wYWdlU2NhbGUsej1xLmNoZWNrZWQ7aWYoeil2YXIgeD1wYXJzZUludChLLnZhbHVlKSxFPXBhcnNlSW50KHBhLnZhbHVlKSx4PU1hdGgubWluKHYuaGVpZ2h0KkUvKGsuaGVpZ2h0L2Iudmlldy5zY2FsZSksdi53aWR0aCp4LyhrLndpZHRoL2Iudmlldy5zY2FsZSkpO2Vsc2UgeD1wYXJzZUludCh1LnZhbHVlKS8oMTAwKmIucGFnZVNjYWxlKSxpc05hTih4KSYmKGM9MS9iLnBhZ2VTY2FsZSx1LnZhbHVlPSIxMDAgJSIpO3Y9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZSh2KTt2LndpZHRoPU1hdGguY2VpbCh2LndpZHRoKgpjKTt2LmhlaWdodD1NYXRoLmNlaWwodi5oZWlnaHQqYyk7eCo9YzsheiYmYi5wYWdlVmlzaWJsZT8oaz1iLmdldFBhZ2VMYXlvdXQoKSxtLT1rLngqdi53aWR0aCx5LT1rLnkqdi5oZWlnaHQpOno9ITA7aWYobnVsbD09ZSl7ZT1QcmludERpYWxvZy5jcmVhdGVQcmludFByZXZpZXcoYix4LHYsMCxtLHkseik7ZS5wYWdlU2VsZWN0b3I9ITE7ZS5tYXRoRW5hYmxlZD0hMTttPWEuZ2V0Q3VycmVudEZpbGUoKTtudWxsIT1tJiYoZS50aXRsZT1tLmdldFRpdGxlKCkpO3ZhciBCPWUud3JpdGVIZWFkO2Uud3JpdGVIZWFkPWZ1bmN0aW9uKGUpe0IuYXBwbHkodGhpcyxhcmd1bWVudHMpO214Q2xpZW50LklTX0dDJiYoZS53cml0ZWxuKCc8c3R5bGUgdHlwZT0idGV4dC9jc3MiPicpLGUud3JpdGVsbigiQG1lZGlhIHByaW50IHsiKSxlLndyaXRlbG4oInNwYW4uTWF0aEpheF9TVkcgc3ZnIHsgc2hhcGUtcmVuZGVyaW5nOiBjcmlzcEVkZ2VzOyB9IiksZS53cml0ZWxuKCJ9IiksZS53cml0ZWxuKCI8L3N0eWxlPiIpKTsKbnVsbCE9YS5lZGl0b3IuZm9udENzcyYmKGUud3JpdGVsbignPHN0eWxlIHR5cGU9InRleHQvY3NzIj4nKSxlLndyaXRlbG4oYS5lZGl0b3IuZm9udENzcyksZS53cml0ZWxuKCI8L3N0eWxlPiIpKTtpZihudWxsIT1iLmV4dEZvbnRzKWZvcih2YXIgYz0wO2M8Yi5leHRGb250cy5sZW5ndGg7YysrKXt2YXIgZD1iLmV4dEZvbnRzW2NdLm5hbWUsZj1iLmV4dEZvbnRzW2NdLnVybDswPT1mLmluZGV4T2YoRWRpdG9yLkdPT0dMRV9GT05UUyk/ZS53cml0ZWxuKCc8bGluayByZWw9InN0eWxlc2hlZXQiIGhyZWY9IicrZisnIiBjaGFyc2V0PSJVVEYtOCIgdHlwZT0idGV4dC9jc3MiPicpOihlLndyaXRlbG4oJzxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+JyksZS53cml0ZWxuKCdAZm9udC1mYWNlIHtcblx0Zm9udC1mYW1pbHk6ICInK2QrJyI7XG5cdHNyYzogdXJsKCInK2YrJyIpO1xufScpLGUud3JpdGVsbigiPC9zdHlsZT4iKSl9fTtpZigidW5kZWZpbmVkIiE9PXR5cGVvZiBNYXRoSmF4KXt2YXIgQT0KZS5yZW5kZXJQYWdlO2UucmVuZGVyUGFnZT1mdW5jdGlvbihiLGUsYyxkLGYsZyl7dmFyIGw9bXhDbGllbnQuTk9fRk87bXhDbGllbnQuTk9fRk89dGhpcy5ncmFwaC5tYXRoRW5hYmxlZCYmIWEuZWRpdG9yLnVzZUZvcmVpZ25PYmplY3RGb3JNYXRoPyEwOmEuZWRpdG9yLm9yaWdpbmFsTm9Gb3JlaWduT2JqZWN0O3ZhciBwPUEuYXBwbHkodGhpcyxhcmd1bWVudHMpO214Q2xpZW50Lk5PX0ZPPWw7dGhpcy5ncmFwaC5tYXRoRW5hYmxlZD90aGlzLm1hdGhFbmFibGVkPXRoaXMubWF0aEVuYWJsZWR8fCEwOnAuY2xhc3NOYW1lPSJnZURpc2FibGVNYXRoSmF4IjtyZXR1cm4gcH19bT1udWxsO251bGwhPWQudGhlbWVzJiYiZGFya1RoZW1lIj09ZC5kZWZhdWx0VGhlbWVOYW1lJiYobT1kLnN0eWxlc2hlZXQsZC5zdHlsZXNoZWV0PWQuZ2V0RGVmYXVsdFN0eWxlc2hlZXQoKSxkLnJlZnJlc2goKSk7ZS5vcGVuKG51bGwsbnVsbCxmLCEwKTtudWxsIT1tJiYoZC5zdHlsZXNoZWV0PW0sZC5yZWZyZXNoKCkpfWVsc2V7dj0KYi5iYWNrZ3JvdW5kO2lmKG51bGw9PXZ8fCIiPT12fHx2PT1teENvbnN0YW50cy5OT05FKXY9IiNmZmZmZmYiO2UuYmFja2dyb3VuZENvbG9yPXY7ZS5hdXRvT3JpZ2luPXo7ZS5hcHBlbmRHcmFwaChiLHgsbSx5LGYsITApO2lmKG51bGwhPWIuZXh0Rm9udHMmJm51bGwhPWUud25kKWZvcihmPTA7ZjxiLmV4dEZvbnRzLmxlbmd0aDtmKyspbT1iLmV4dEZvbnRzW2ZdLm5hbWUseT1iLmV4dEZvbnRzW2ZdLnVybCwwPT15LmluZGV4T2YoRWRpdG9yLkdPT0dMRV9GT05UUyk/ZS53bmQuZG9jdW1lbnQud3JpdGVsbignPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSInK3krJyIgY2hhcnNldD0iVVRGLTgiIHR5cGU9InRleHQvY3NzIj4nKTooZS53bmQuZG9jdW1lbnQud3JpdGVsbignPHN0eWxlIHR5cGU9InRleHQvY3NzIj4nKSxlLnduZC5kb2N1bWVudC53cml0ZWxuKCdAZm9udC1mYWNlIHtcblx0Zm9udC1mYW1pbHk6ICInK20rJyI7XG5cdHNyYzogdXJsKCInK3krJyIpO1xufScpLAplLnduZC5kb2N1bWVudC53cml0ZWxuKCI8L3N0eWxlPiIpKX1nJiYoYi51c2VDc3NUcmFuc2Zvcm1zPWcsYi5jdXJyZW50VHJhbnNsYXRlPWwsYi5jdXJyZW50U2NhbGU9cCxiLnZpZXcudHJhbnNsYXRlPW4sYi52aWV3LnNjYWxlPXQpO3JldHVybiBlfXZhciBjPXBhcnNlSW50KGhhLnZhbHVlKS8xMDA7aXNOYU4oYykmJihjPTEsaGEudmFsdWU9IjEwMCAlIik7dmFyIGM9Ljc1KmMsZj1udWxsO251bGwhPWQudGhlbWVzJiYiZGFya1RoZW1lIj09ZC5kZWZhdWx0VGhlbWVOYW1lJiYoZj1kLnN0eWxlc2hlZXQsZC5zdHlsZXNoZWV0PWQuZ2V0RGVmYXVsdFN0eWxlc2hlZXQoKSxkLnJlZnJlc2goKSk7dmFyIGc9bS52YWx1ZSxsPXkudmFsdWUsbj0hdC5jaGVja2VkLGs9bnVsbDtuJiYobj1nPT1wJiZsPT1wKTtpZighbiYmbnVsbCE9YS5wYWdlcyYmYS5wYWdlcy5sZW5ndGgpe3ZhciB2PTAsbj1hLnBhZ2VzLmxlbmd0aC0xO3QuY2hlY2tlZHx8KHY9cGFyc2VJbnQoZyktMSxuPXBhcnNlSW50KGwpLQoxKTtmb3IodmFyIHg9djt4PD1uO3grKyl7dmFyIHo9YS5wYWdlc1t4XSxnPXo9PWEuY3VycmVudFBhZ2U/ZDpudWxsO2lmKG51bGw9PWcpe3ZhciBnPWEuY3JlYXRlVGVtcG9yYXJ5R3JhcGgoZC5zdHlsZXNoZWV0KSxsPSEwLHY9ITEsRT1udWxsLEI9bnVsbDtudWxsPT16LnZpZXdTdGF0ZSYmbnVsbD09ei5yb290JiZhLnVwZGF0ZVBhZ2VSb290KHopO251bGwhPXoudmlld1N0YXRlJiYobD16LnZpZXdTdGF0ZS5wYWdlVmlzaWJsZSx2PXoudmlld1N0YXRlLm1hdGhFbmFibGVkLEU9ei52aWV3U3RhdGUuYmFja2dyb3VuZCxCPXoudmlld1N0YXRlLmJhY2tncm91bmRJbWFnZSxnLmV4dEZvbnRzPXoudmlld1N0YXRlLmV4dEZvbnRzKTtnLmJhY2tncm91bmQ9RTtnLmJhY2tncm91bmRJbWFnZT1udWxsIT1CP25ldyBteEltYWdlKEIuc3JjLEIud2lkdGgsQi5oZWlnaHQpOm51bGw7Zy5wYWdlVmlzaWJsZT1sO2cubWF0aEVuYWJsZWQ9djt2YXIgQT1nLmdldEdsb2JhbFZhcmlhYmxlO2cuZ2V0R2xvYmFsVmFyaWFibGU9CmZ1bmN0aW9uKGIpe3JldHVybiJwYWdlIj09Yj96LmdldE5hbWUoKToicGFnZW51bWJlciI9PWI/eCsxOiJwYWdlY291bnQiPT1iP251bGwhPWEucGFnZXM/YS5wYWdlcy5sZW5ndGg6MTpBLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChnLmNvbnRhaW5lcik7YS51cGRhdGVQYWdlUm9vdCh6KTtnLm1vZGVsLnNldFJvb3Qoei5yb290KX1rPWUoZyxrLHghPW4pO2chPWQmJmcuY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZy5jb250YWluZXIpfX1lbHNlIGs9ZShkKTtudWxsPT1rP2EuaGFuZGxlRXJyb3Ioe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJlcnJvclVwZGF0aW5nUHJldmlldyIpfSk6KGsubWF0aEVuYWJsZWQmJihuPWsud25kLmRvY3VtZW50LGImJihrLnduZC5JTU1FRElBVEVfUFJJTlQ9ITApLG4ud3JpdGVsbignPHNjcmlwdCB0eXBlPSJ0ZXh0L2phdmFzY3JpcHQiIHNyYz0iJytEUkFXSU9fQkFTRV9VUkwrJy9qcy9tYXRoLXByaW50LmpzIj5ceDNjL3NjcmlwdD4nKSksCmsuY2xvc2VEb2N1bWVudCgpLCFrLm1hdGhFbmFibGVkJiZiJiZQcmludERpYWxvZy5wcmludFByZXZpZXcoaykpO251bGwhPWYmJihkLnN0eWxlc2hlZXQ9ZixkLnJlZnJlc2goKSl9dmFyIGQ9YS5lZGl0b3IuZ3JhcGgsZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxnPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImgzIik7Zy5zdHlsZS53aWR0aD0iMTAwJSI7Zy5zdHlsZS50ZXh0QWxpZ249ImNlbnRlciI7Zy5zdHlsZS5tYXJnaW5Ub3A9IjBweCI7bXhVdGlscy53cml0ZShnLGJ8fG14UmVzb3VyY2VzLmdldCgicHJpbnQiKSk7Zi5hcHBlbmRDaGlsZChnKTt2YXIgbD0xLHA9MSxuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO24uc3R5bGUuY3NzVGV4dD0iYm9yZGVyLWJvdHRvbToxcHggc29saWQgbGlnaHRHcmF5O3BhZGRpbmctYm90dG9tOjEycHg7bWFyZ2luLWJvdHRvbToxMnB4OyI7dmFyIHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTt0LnN0eWxlLmNzc1RleHQ9CiJtYXJnaW4tcmlnaHQ6OHB4O21hcmdpbi1ib3R0b206OHB4OyI7dC5zZXRBdHRyaWJ1dGUoInZhbHVlIiwiYWxsIik7dC5zZXRBdHRyaWJ1dGUoInR5cGUiLCJyYWRpbyIpO3Quc2V0QXR0cmlidXRlKCJuYW1lIiwicGFnZXMtcHJpbnRkaWFsb2ciKTtuLmFwcGVuZENoaWxkKHQpO2c9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3BhbiIpO214VXRpbHMud3JpdGUoZyxteFJlc291cmNlcy5nZXQoInByaW50QWxsUGFnZXMiKSk7bi5hcHBlbmRDaGlsZChnKTtteFV0aWxzLmJyKG4pO3ZhciBrPXQuY2xvbmVOb2RlKCEwKTt0LnNldEF0dHJpYnV0ZSgiY2hlY2tlZCIsImNoZWNrZWQiKTtrLnNldEF0dHJpYnV0ZSgidmFsdWUiLCJyYW5nZSIpO24uYXBwZW5kQ2hpbGQoayk7Zz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIik7bXhVdGlscy53cml0ZShnLG14UmVzb3VyY2VzLmdldCgicGFnZXMiKSsiOiIpO24uYXBwZW5kQ2hpbGQoZyk7dmFyIG09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTsKbS5zdHlsZS5jc3NUZXh0PSJtYXJnaW46MCA4cHggMCA4cHg7IjttLnNldEF0dHJpYnV0ZSgidmFsdWUiLCIxIik7bS5zZXRBdHRyaWJ1dGUoInR5cGUiLCJudW1iZXIiKTttLnNldEF0dHJpYnV0ZSgibWluIiwiMSIpO20uc3R5bGUud2lkdGg9IjUwcHgiO24uYXBwZW5kQ2hpbGQobSk7Zz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIik7bXhVdGlscy53cml0ZShnLG14UmVzb3VyY2VzLmdldCgidG8iKSk7bi5hcHBlbmRDaGlsZChnKTt2YXIgeT1tLmNsb25lTm9kZSghMCk7bi5hcHBlbmRDaGlsZCh5KTtteEV2ZW50LmFkZExpc3RlbmVyKG0sImZvY3VzIixmdW5jdGlvbigpe2suY2hlY2tlZD0hMH0pO214RXZlbnQuYWRkTGlzdGVuZXIoeSwiZm9jdXMiLGZ1bmN0aW9uKCl7ay5jaGVja2VkPSEwfSk7bXhFdmVudC5hZGRMaXN0ZW5lcihtLCJjaGFuZ2UiLGUpO214RXZlbnQuYWRkTGlzdGVuZXIoeSwiY2hhbmdlIixlKTtpZihudWxsIT1hLnBhZ2VzJiYobD1hLnBhZ2VzLmxlbmd0aCwKbnVsbCE9YS5jdXJyZW50UGFnZSkpZm9yKGc9MDtnPGEucGFnZXMubGVuZ3RoO2crKylpZihhLmN1cnJlbnRQYWdlPT1hLnBhZ2VzW2ddKXtwPWcrMTttLnZhbHVlPXA7eS52YWx1ZT1wO2JyZWFrfW0uc2V0QXR0cmlidXRlKCJtYXgiLGwpO3kuc2V0QXR0cmlidXRlKCJtYXgiLGwpOzE8bCYmZi5hcHBlbmRDaGlsZChuKTt2YXIgdj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTt2LnN0eWxlLm1hcmdpbkJvdHRvbT0iMTBweCI7dmFyIHg9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTt4LnN0eWxlLm1hcmdpblJpZ2h0PSI4cHgiO3guc2V0QXR0cmlidXRlKCJ2YWx1ZSIsImFkanVzdCIpO3guc2V0QXR0cmlidXRlKCJ0eXBlIiwicmFkaW8iKTt4LnNldEF0dHJpYnV0ZSgibmFtZSIsInByaW50Wm9vbSIpO3YuYXBwZW5kQ2hpbGQoeCk7Zz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIik7bXhVdGlscy53cml0ZShnLG14UmVzb3VyY2VzLmdldCgiYWRqdXN0VG8iKSk7CnYuYXBwZW5kQ2hpbGQoZyk7dmFyIHU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTt1LnN0eWxlLmNzc1RleHQ9Im1hcmdpbjowIDhweCAwIDhweDsiO3Uuc2V0QXR0cmlidXRlKCJ2YWx1ZSIsIjEwMCAlIik7dS5zdHlsZS53aWR0aD0iNTBweCI7di5hcHBlbmRDaGlsZCh1KTtteEV2ZW50LmFkZExpc3RlbmVyKHUsImZvY3VzIixmdW5jdGlvbigpe3guY2hlY2tlZD0hMH0pO2YuYXBwZW5kQ2hpbGQodik7dmFyIG49bi5jbG9uZU5vZGUoITEpLHE9eC5jbG9uZU5vZGUoITApO3Euc2V0QXR0cmlidXRlKCJ2YWx1ZSIsImZpdCIpO3guc2V0QXR0cmlidXRlKCJjaGVja2VkIiwiY2hlY2tlZCIpO2c9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Zy5zdHlsZS5jc3NUZXh0PSJkaXNwbGF5OmlubGluZS1ibG9jaztoZWlnaHQ6MTAwJTt2ZXJ0aWNhbC1hbGlnbjp0b3A7cGFkZGluZy10b3A6MnB4OyI7Zy5hcHBlbmRDaGlsZChxKTtuLmFwcGVuZENoaWxkKGcpO3Y9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGFibGUiKTsKdi5zdHlsZS5kaXNwbGF5PSJpbmxpbmUtYmxvY2siO3ZhciB6PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRib2R5IiksRT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ciIpLEE9RS5jbG9uZU5vZGUoITApLEM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKSxEPUMuY2xvbmVOb2RlKCEwKSxHPUMuY2xvbmVOb2RlKCEwKSxGPUMuY2xvbmVOb2RlKCEwKSxIPUMuY2xvbmVOb2RlKCEwKSxKPUMuY2xvbmVOb2RlKCEwKTtDLnN0eWxlLnRleHRBbGlnbj0icmlnaHQiO0Yuc3R5bGUudGV4dEFsaWduPSJyaWdodCI7bXhVdGlscy53cml0ZShDLG14UmVzb3VyY2VzLmdldCgiZml0VG8iKSk7dmFyIEs9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTtLLnN0eWxlLmNzc1RleHQ9Im1hcmdpbjowIDhweCAwIDhweDsiO0suc2V0QXR0cmlidXRlKCJ2YWx1ZSIsIjEiKTtLLnNldEF0dHJpYnV0ZSgibWluIiwiMSIpO0suc2V0QXR0cmlidXRlKCJ0eXBlIiwibnVtYmVyIik7Sy5zdHlsZS53aWR0aD0KIjQwcHgiO0QuYXBwZW5kQ2hpbGQoSyk7Zz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIik7bXhVdGlscy53cml0ZShnLG14UmVzb3VyY2VzLmdldCgiZml0VG9TaGVldHNBY3Jvc3MiKSk7Ry5hcHBlbmRDaGlsZChnKTtteFV0aWxzLndyaXRlKEYsbXhSZXNvdXJjZXMuZ2V0KCJmaXRUb0J5IikpO3ZhciBwYT1LLmNsb25lTm9kZSghMCk7SC5hcHBlbmRDaGlsZChwYSk7bXhFdmVudC5hZGRMaXN0ZW5lcihLLCJmb2N1cyIsZnVuY3Rpb24oKXtxLmNoZWNrZWQ9ITB9KTtteEV2ZW50LmFkZExpc3RlbmVyKHBhLCJmb2N1cyIsZnVuY3Rpb24oKXtxLmNoZWNrZWQ9ITB9KTtnPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNwYW4iKTtteFV0aWxzLndyaXRlKGcsbXhSZXNvdXJjZXMuZ2V0KCJmaXRUb1NoZWV0c0Rvd24iKSk7Si5hcHBlbmRDaGlsZChnKTtFLmFwcGVuZENoaWxkKEMpO0UuYXBwZW5kQ2hpbGQoRCk7RS5hcHBlbmRDaGlsZChHKTtBLmFwcGVuZENoaWxkKEYpO0EuYXBwZW5kQ2hpbGQoSCk7CkEuYXBwZW5kQ2hpbGQoSik7ei5hcHBlbmRDaGlsZChFKTt6LmFwcGVuZENoaWxkKEEpO3YuYXBwZW5kQ2hpbGQoeik7bi5hcHBlbmRDaGlsZCh2KTtmLmFwcGVuZENoaWxkKG4pO249ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Zz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtnLnN0eWxlLmZvbnRXZWlnaHQ9ImJvbGQiO2cuc3R5bGUubWFyZ2luQm90dG9tPSIxMnB4IjtteFV0aWxzLndyaXRlKGcsbXhSZXNvdXJjZXMuZ2V0KCJwYXBlclNpemUiKSk7bi5hcHBlbmRDaGlsZChnKTtnPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2cuc3R5bGUubWFyZ2luQm90dG9tPSIxMnB4Ijt2YXIgc2E9UGFnZVNldHVwRGlhbG9nLmFkZFBhZ2VGb3JtYXRQYW5lbChnLCJwcmludGRpYWxvZyIsYS5lZGl0b3IuZ3JhcGgucGFnZUZvcm1hdHx8bXhDb25zdGFudHMuUEFHRV9GT1JNQVRfQTRfUE9SVFJBSVQpO24uYXBwZW5kQ2hpbGQoZyk7Zz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIik7Cm14VXRpbHMud3JpdGUoZyxteFJlc291cmNlcy5nZXQoInBhZ2VTY2FsZSIpKTtuLmFwcGVuZENoaWxkKGcpO3ZhciBoYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpO2hhLnN0eWxlLmNzc1RleHQ9Im1hcmdpbjowIDhweCAwIDhweDsiO2hhLnNldEF0dHJpYnV0ZSgidmFsdWUiLCIxMDAgJSIpO2hhLnN0eWxlLndpZHRoPSI2MHB4IjtuLmFwcGVuZENoaWxkKGhhKTtmLmFwcGVuZENoaWxkKG4pO2c9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Zy5zdHlsZS5jc3NUZXh0PSJ0ZXh0LWFsaWduOnJpZ2h0O21hcmdpbjo0OHB4IDAgMCAwOyI7bj1teFV0aWxzLmJ1dHRvbihteFJlc291cmNlcy5nZXQoImNhbmNlbCIpLGZ1bmN0aW9uKCl7YS5oaWRlRGlhbG9nKCl9KTtuLmNsYXNzTmFtZT0iZ2VCdG4iO2EuZWRpdG9yLmNhbmNlbEZpcnN0JiZnLmFwcGVuZENoaWxkKG4pO2EuaXNPZmZsaW5lKCl8fCh2PW14VXRpbHMuYnV0dG9uKG14UmVzb3VyY2VzLmdldCgiaGVscCIpLApmdW5jdGlvbigpe2Qub3BlbkxpbmsoImh0dHBzOi8vZGVzay5kcmF3LmlvL3N1cHBvcnQvc29sdXRpb25zL2FydGljbGVzLzE2MDAwMDQ4OTQ3Iil9KSx2LmNsYXNzTmFtZT0iZ2VCdG4iLGcuYXBwZW5kQ2hpbGQodikpO1ByaW50RGlhbG9nLnByZXZpZXdFbmFibGVkJiYodj1teFV0aWxzLmJ1dHRvbihteFJlc291cmNlcy5nZXQoInByZXZpZXciKSxmdW5jdGlvbigpe2EuaGlkZURpYWxvZygpO2MoITEpfSksdi5jbGFzc05hbWU9ImdlQnRuIixnLmFwcGVuZENoaWxkKHYpKTt2PW14VXRpbHMuYnV0dG9uKG14UmVzb3VyY2VzLmdldChQcmludERpYWxvZy5wcmV2aWV3RW5hYmxlZD8icHJpbnQiOiJvayIpLGZ1bmN0aW9uKCl7YS5oaWRlRGlhbG9nKCk7YyghMCl9KTt2LmNsYXNzTmFtZT0iZ2VCdG4gZ2VQcmltYXJ5QnRuIjtnLmFwcGVuZENoaWxkKHYpO2EuZWRpdG9yLmNhbmNlbEZpcnN0fHxnLmFwcGVuZENoaWxkKG4pO2YuYXBwZW5kQ2hpbGQoZyk7dGhpcy5jb250YWluZXI9Zn07CnZhciBGPUNoYW5nZVBhZ2VTZXR1cC5wcm90b3R5cGUuZXhlY3V0ZTtDaGFuZ2VQYWdlU2V0dXAucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXtudWxsPT10aGlzLnBhZ2UmJih0aGlzLnBhZ2U9dGhpcy51aS5jdXJyZW50UGFnZSk7dGhpcy5wYWdlIT10aGlzLnVpLmN1cnJlbnRQYWdlP251bGwhPXRoaXMucGFnZS52aWV3U3RhdGUmJih0aGlzLmlnbm9yZUNvbG9yfHwodGhpcy5wYWdlLnZpZXdTdGF0ZS5iYWNrZ3JvdW5kPXRoaXMuY29sb3IpLHRoaXMuaWdub3JlSW1hZ2V8fCh0aGlzLnBhZ2Uudmlld1N0YXRlLmJhY2tncm91bmRJbWFnZT10aGlzLmltYWdlKSxudWxsIT10aGlzLmZvcm1hdCYmKHRoaXMucGFnZS52aWV3U3RhdGUucGFnZUZvcm1hdD10aGlzLmZvcm1hdCksbnVsbCE9dGhpcy5tYXRoRW5hYmxlZCYmKHRoaXMucGFnZS52aWV3U3RhdGUubWF0aEVuYWJsZWQ9dGhpcy5tYXRoRW5hYmxlZCksbnVsbCE9dGhpcy5zaGFkb3dWaXNpYmxlJiYodGhpcy5wYWdlLnZpZXdTdGF0ZS5zaGFkb3dWaXNpYmxlPQp0aGlzLnNoYWRvd1Zpc2libGUpKTooRi5hcHBseSh0aGlzLGFyZ3VtZW50cyksbnVsbCE9dGhpcy5tYXRoRW5hYmxlZCYmdGhpcy5tYXRoRW5hYmxlZCE9dGhpcy51aS5pc01hdGhFbmFibGVkKCkmJih0aGlzLnVpLnNldE1hdGhFbmFibGVkKHRoaXMubWF0aEVuYWJsZWQpLHRoaXMubWF0aEVuYWJsZWQ9IXRoaXMubWF0aEVuYWJsZWQpLG51bGwhPXRoaXMuc2hhZG93VmlzaWJsZSYmdGhpcy5zaGFkb3dWaXNpYmxlIT10aGlzLnVpLmVkaXRvci5ncmFwaC5zaGFkb3dWaXNpYmxlJiYodGhpcy51aS5lZGl0b3IuZ3JhcGguc2V0U2hhZG93VmlzaWJsZSh0aGlzLnNoYWRvd1Zpc2libGUpLHRoaXMuc2hhZG93VmlzaWJsZT0hdGhpcy5zaGFkb3dWaXNpYmxlKSl9O0VkaXRvci5wcm90b3R5cGUudXNlQ2FudmFzRm9yRXhwb3J0PSExO3RyeXt2YXIgSD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJjYW52YXMiKSxKPW5ldyBJbWFnZTtKLm9ubG9hZD1mdW5jdGlvbigpe3RyeXtILmdldENvbnRleHQoIjJkIikuZHJhd0ltYWdlKEosCjAsMCk7dmFyIGE9SC50b0RhdGFVUkwoImltYWdlL3BuZyIpO0VkaXRvci5wcm90b3R5cGUudXNlQ2FudmFzRm9yRXhwb3J0PW51bGwhPWEmJjY8YS5sZW5ndGh9Y2F0Y2goSyl7fX07Si5zcmM9ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsIitidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCgnPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMXB4IiBoZWlnaHQ9IjFweCIgdmVyc2lvbj0iMS4xIj48Zm9yZWlnbk9iamVjdCBwb2ludGVyLWV2ZW50cz0iYWxsIiB3aWR0aD0iMSIgaGVpZ2h0PSIxIj48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9zdmc+JykpKX1jYXRjaCh1KXt9fSkoKTsKKGZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14T2JqZWN0Q29kZWMobmV3IENoYW5nZVBhZ2VTZXR1cCxbInVpIiwicHJldmlvdXNDb2xvciIsInByZXZpb3VzSW1hZ2UiLCJwcmV2aW91c0Zvcm1hdCJdKTthLmJlZm9yZURlY29kZT1mdW5jdGlvbihhLGYsZCl7ZC51aT1hLnVpO3JldHVybiBmfTthLmFmdGVyRGVjb2RlPWZ1bmN0aW9uKGEsZixkKXtkLnByZXZpb3VzQ29sb3I9ZC5jb2xvcjtkLnByZXZpb3VzSW1hZ2U9ZC5pbWFnZTtkLnByZXZpb3VzRm9ybWF0PWQuZm9ybWF0O251bGwhPWQuZm9sZGluZ0VuYWJsZWQmJihkLmZvbGRpbmdFbmFibGVkPSFkLmZvbGRpbmdFbmFibGVkKTtudWxsIT1kLm1hdGhFbmFibGVkJiYoZC5tYXRoRW5hYmxlZD0hZC5tYXRoRW5hYmxlZCk7bnVsbCE9ZC5zaGFkb3dWaXNpYmxlJiYoZC5zaGFkb3dWaXNpYmxlPSFkLnNoYWRvd1Zpc2libGUpO3JldHVybiBkfTtteENvZGVjUmVnaXN0cnkucmVnaXN0ZXIoYSl9KSgpOyhmdW5jdGlvbigpe0VkaXRvclVpLlZFUlNJT049IkBEUkFXSU8tVkVSU0lPTkAiO0VkaXRvclVpLmNvbXBhY3RVaT0iYXRsYXMiIT11aVRoZW1lO214R3JhcGhWaWV3LnByb3RvdHlwZS5kZWZhdWx0RGFya0dyaWRDb2xvcj0iIzZlNmU2ZSI7ImRhcmsiPT11aVRoZW1lJiYobXhHcmFwaFZpZXcucHJvdG90eXBlLmdyaWRDb2xvcj1teEdyYXBoVmlldy5wcm90b3R5cGUuZGVmYXVsdERhcmtHcmlkQ29sb3IpO0VkaXRvclVpLmVuYWJsZUxvZ2dpbmc9IjEiIT11cmxQYXJhbXMuc3RlYWx0aCYmKC8uKlwuZHJhd1wuaW8kLy50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSl8fC8uKlwuZGlhZ3JhbXNcLm5ldCQvLnRlc3Qod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKSkmJiJzdXBwb3J0LmRyYXcuaW8iIT13aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7RWRpdG9yVWkuZHJhd0hvc3Q9d2luZG93LkRSQVdJT19CQVNFX1VSTDtFZGl0b3JVaS5sYXN0RXJyb3JNZXNzYWdlPW51bGw7RWRpdG9yVWkuaWdub3JlZEFub255bWl6ZWRDaGFycz0KIlxuXHRgfiFAIyQlXiYqKClfK3t9fDpcIjw+Py09W107Jy4vLFxuXHQiO0VkaXRvclVpLnRlbXBsYXRlRmlsZT1URU1QTEFURV9QQVRIKyIvaW5kZXgueG1sIjtFZGl0b3JVaS5jYWNoZVVybD0iMSI9PXVybFBhcmFtcy5kZXY/Ii9jYWNoZSI6d2luZG93LlJFQUxUSU1FX1VSTDtudWxsPT1FZGl0b3JVaS5jYWNoZVVybCYmInVuZGVmaW5lZCIhPT10eXBlb2YgRHJhd2lvRmlsZSYmKERyYXdpb0ZpbGUuU1lOQz0ibm9uZSIpO0VkaXRvci5jYWNoZVRpbWVvdXQ9MUU0O0VkaXRvclVpLmVuYWJsZVBsYW50VW1sPUVkaXRvclVpLmVuYWJsZUxvZ2dpbmc7RWRpdG9yVWkuaXNFbGVjdHJvbkFwcD1udWxsIT13aW5kb3cmJm51bGwhPXdpbmRvdy5wcm9jZXNzJiZudWxsIT13aW5kb3cucHJvY2Vzcy52ZXJzaW9ucyYmbnVsbCE9d2luZG93LnByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb247RWRpdG9yVWkuZW5hYmxlRHJhZnRzPSFteENsaWVudC5JU19DSFJPTUVBUFAmJmlzTG9jYWxTdG9yYWdlJiYKIUVkaXRvclVpLmlzRWxlY3Ryb25BcHAmJiIwIiE9dXJsUGFyYW1zLmRyYWZ0cztFZGl0b3JVaS5zY3JhdGNocGFkSGVscExpbms9Imh0dHBzOi8vZGVzay5kcmF3LmlvL3N1cHBvcnQvc29sdXRpb25zL2FydGljbGVzLzE2MDAwMDQyMzY3IjtFZGl0b3JVaS5kZWZhdWx0TWVybWFpZENvbmZpZz17dGhlbWU6Im5ldXRyYWwiLGFycm93TWFya2VyQWJzb2x1dGU6ITEsZmxvd2NoYXJ0OntodG1sTGFiZWxzOiExfSxzZXF1ZW5jZTp7ZGlhZ3JhbU1hcmdpblg6NTAsZGlhZ3JhbU1hcmdpblk6MTAsYWN0b3JNYXJnaW46NTAsd2lkdGg6MTUwLGhlaWdodDo2NSxib3hNYXJnaW46MTAsYm94VGV4dE1hcmdpbjo1LG5vdGVNYXJnaW46MTAsbWVzc2FnZU1hcmdpbjozNSxtaXJyb3JBY3RvcnM6ITAsYm90dG9tTWFyZ2luQWRqOjEsdXNlTWF4V2lkdGg6ITAscmlnaHRBbmdsZXM6ITEsc2hvd1NlcXVlbmNlTnVtYmVyczohMX0sZ2FudHQ6e3RpdGxlVG9wTWFyZ2luOjI1LGJhckhlaWdodDoyMCxiYXJHYXA6NCwKdG9wUGFkZGluZzo1MCxsZWZ0UGFkZGluZzo3NSxncmlkTGluZVN0YXJ0UGFkZGluZzozNSxmb250U2l6ZToxMSxmb250RmFtaWx5OiciT3Blbi1TYW5zIiwgInNhbnMtc2VyaWYiJyxudW1iZXJTZWN0aW9uU3R5bGVzOjQsYXhpc0Zvcm1hdDoiJVktJW0tJWQifX07RWRpdG9yVWkubG9nRXJyb3I9ZnVuY3Rpb24oYSxlLGMsZCxmLG4sayl7bj1udWxsIT1uP246MDw9YS5pbmRleE9mKCJOZXR3b3JrRXJyb3IiKXx8MDw9YS5pbmRleE9mKCJTZWN1cml0eUVycm9yIil8fDA8PWEuaW5kZXhPZigiTlNfRVJST1JfRkFJTFVSRSIpfHwwPD1hLmluZGV4T2YoIm91dCBvZiBtZW1vcnkiKT8iQ09ORklHIjoiU0VWRVJFIjtpZihFZGl0b3JVaS5lbmFibGVMb2dnaW5nJiYiMSIhPXVybFBhcmFtcy5kZXYpdHJ5e2lmKGEhPUVkaXRvclVpLmxhc3RFcnJvck1lc3NhZ2UmJihudWxsPT1hfHxudWxsPT1lfHwtMT09YS5pbmRleE9mKCJTY3JpcHQgZXJyb3IiKSYmLTE9PWEuaW5kZXhPZigiZXh0ZW5zaW9uIikpJiYKbnVsbCE9YSYmMD5hLmluZGV4T2YoIkRvY3VtZW50Q2xvc2VkRXJyb3IiKSl7RWRpdG9yVWkubGFzdEVycm9yTWVzc2FnZT1hO3ZhciBiPW51bGwhPXdpbmRvdy5EUkFXSU9fTE9HX1VSTD93aW5kb3cuRFJBV0lPX0xPR19VUkw6IiI7Zj1udWxsIT1mP2Y6RXJyb3IoYSk7KG5ldyBJbWFnZSkuc3JjPWIrIi9sb2c/c2V2ZXJpdHk9IituKyImdj0iK2VuY29kZVVSSUNvbXBvbmVudChFZGl0b3JVaS5WRVJTSU9OKSsiJm1zZz1jbGllbnRFcnJvcjoiK2VuY29kZVVSSUNvbXBvbmVudChhKSsiOnVybDoiK2VuY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24uaHJlZikrIjpsbnVtOiIrZW5jb2RlVVJJQ29tcG9uZW50KGMpKyhudWxsIT1kPyI6Y29sbm86IitlbmNvZGVVUklDb21wb25lbnQoZCk6IiIpKyhudWxsIT1mJiZudWxsIT1mLnN0YWNrPyImc3RhY2s9IitlbmNvZGVVUklDb21wb25lbnQoZi5zdGFjayk6IiIpfX1jYXRjaCh5KXt9dHJ5e2t8fG51bGw9PXdpbmRvdy5jb25zb2xlfHwKY29uc29sZS5lcnJvcihuLGEsZSxjLGQsZil9Y2F0Y2goeSl7fX07RWRpdG9yVWkubG9nRXZlbnQ9ZnVuY3Rpb24oYSl7aWYoIjEiPT11cmxQYXJhbXMuZGV2KUVkaXRvclVpLmRlYnVnKCJsb2dFdmVudCIsYSk7ZWxzZSBpZihFZGl0b3JVaS5lbmFibGVMb2dnaW5nKXRyeXt2YXIgYj1udWxsIT13aW5kb3cuRFJBV0lPX0xPR19VUkw/d2luZG93LkRSQVdJT19MT0dfVVJMOiIiOyhuZXcgSW1hZ2UpLnNyYz1iKyIvaW1hZ2VzLzF4MS5wbmc/dj0iK2VuY29kZVVSSUNvbXBvbmVudChFZGl0b3JVaS5WRVJTSU9OKSsobnVsbCE9YT8iJmRhdGE9IitlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoYSkpOiIiKX1jYXRjaChnKXt9fTtFZGl0b3JVaS5zZW5kUmVwb3J0PWZ1bmN0aW9uKGEsZSl7aWYoIjEiPT11cmxQYXJhbXMuZGV2KUVkaXRvclVpLmRlYnVnKCJzZW5kUmVwb3J0IixhKTtlbHNlIGlmKEVkaXRvclVpLmVuYWJsZUxvZ2dpbmcpdHJ5e2U9bnVsbCE9ZT9lOjVFNCxhLmxlbmd0aD4KZSYmKGE9YS5zdWJzdHJpbmcoMCxlKSsiXG4uLi5bU0hPUlRFTkVEXSIpLG14VXRpbHMucG9zdCgiL2VtYWlsIiwidmVyc2lvbj0iK2VuY29kZVVSSUNvbXBvbmVudChFZGl0b3JVaS5WRVJTSU9OKSsiJnVybD0iK2VuY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24uaHJlZikrIiZkYXRhPSIrZW5jb2RlVVJJQ29tcG9uZW50KGEpKX1jYXRjaChnKXt9fTtFZGl0b3JVaS5kZWJ1Zz1mdW5jdGlvbigpe3RyeXtpZihudWxsIT13aW5kb3cuY29uc29sZSYmIjEiPT11cmxQYXJhbXMudGVzdCl7Zm9yKHZhciBhPVsobmV3IERhdGUpLnRvSVNPU3RyaW5nKCldLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKW51bGwhPWFyZ3VtZW50c1tlXSYmYS5wdXNoKGFyZ3VtZW50c1tlXSk7Y29uc29sZS5sb2cuYXBwbHkoY29uc29sZSxhKX19Y2F0Y2goZyl7fX07RWRpdG9yVWkucGFyc2VQbmc9ZnVuY3Rpb24oYSxlLGMpe2Z1bmN0aW9uIGIoYSxiKXt2YXIgZT1mO2YrPWI7cmV0dXJuIGEuc3Vic3RyaW5nKGUsCmYpfWZ1bmN0aW9uIGQoYSl7YT1iKGEsNCk7cmV0dXJuIGEuY2hhckNvZGVBdCgzKSsoYS5jaGFyQ29kZUF0KDIpPDw4KSsoYS5jaGFyQ29kZUF0KDEpPDwxNikrKGEuY2hhckNvZGVBdCgwKTw8MjQpfXZhciBmPTA7aWYoYihhLDgpIT1TdHJpbmcuZnJvbUNoYXJDb2RlKDEzNykrIlBORyIrU3RyaW5nLmZyb21DaGFyQ29kZSgxMywxMCwyNiwxMCkpbnVsbCE9YyYmYygpO2Vsc2UgaWYoYihhLDQpLCJJSERSIiE9YihhLDQpKW51bGwhPWMmJmMoKTtlbHNle2IoYSwxNyk7ZG97Yz1kKGEpO3ZhciBnPWIoYSw0KTtpZihudWxsIT1lJiZlKGYtOCxnLGMpKWJyZWFrO3ZhbHVlPWIoYSxjKTtiKGEsNCk7aWYoIklFTkQiPT1nKWJyZWFrfXdoaWxlKGMpfX07RWRpdG9yVWkucmVtb3ZlQ2hpbGROb2Rlcz1mdW5jdGlvbihhKXtmb3IoO251bGwhPWEuZmlyc3RDaGlsZDspYS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpfTtFZGl0b3JVaS5wcm90b3R5cGUuZW1wdHlEaWFncmFtWG1sPSc8bXhHcmFwaE1vZGVsPjxyb290PjxteENlbGwgaWQ9IjAiLz48bXhDZWxsIGlkPSIxIiBwYXJlbnQ9IjAiLz48L3Jvb3Q+PC9teEdyYXBoTW9kZWw+JzsKRWRpdG9yVWkucHJvdG90eXBlLmVtcHR5TGlicmFyeVhtbD0iPG14bGlicmFyeT5bXTwvbXhsaWJyYXJ5PiI7RWRpdG9yVWkucHJvdG90eXBlLm1vZGU9bnVsbDtFZGl0b3JVaS5wcm90b3R5cGUudGltZW91dD1FZGl0b3IucHJvdG90eXBlLnRpbWVvdXQ7RWRpdG9yVWkucHJvdG90eXBlLnNpZGViYXJGb290ZXJIZWlnaHQ9Mzg7RWRpdG9yVWkucHJvdG90eXBlLmRlZmF1bHRDdXN0b21TaGFwZVN0eWxlPSJzaGFwZT1zdGVuY2lsKHRaUnRUc1FnRUVCUHcxK0RKUjdBb042RGJXZnRwQWdFME9ydGQvallSR3E3MlIrWU5FMllnVGVQbG9FSkdXYmxnQTE4WnVLRkRjTWo1L1NtOGJvWnErQmdqQ1g0cFR5cWs2WmxLUk9pdHd1c09NWEtRRE9EeDVpeTRwWHhaNXFUSGlGSGF3eEIwSnJRWkg3bENhYlEwRnIrWFdDMS9FOHpjc1QvZ0FpK1N1Ym8yLzNNaDZkL29KYjVuVTFiNXRXN3Iya25hdXRhYTNUK1UzMm83Zjd2WndwSmthTkRMT1JKamN1N3Q1OW0yalh4cVg5dW4rdHQwMjJhY3NmbW9LYVFaK3ZoaHN3WnRTNk5lL1RoUUd0MElWME4zWXl2NlAzQ2VUOS90SE8wWEZJNWNBRT0pO3doaXRlU3BhY2U9d3JhcDtodG1sPTE7IjsKRWRpdG9yVWkucHJvdG90eXBlLm1heEJhY2tncm91bmRTaXplPTE2MDA7RWRpdG9yVWkucHJvdG90eXBlLm1heEltYWdlU2l6ZT01MjA7RWRpdG9yVWkucHJvdG90eXBlLm1heFRleHRXaWR0aD01MjA7RWRpdG9yVWkucHJvdG90eXBlLnJlc2FtcGxlVGhyZXNob2xkPTFFNTtFZGl0b3JVaS5wcm90b3R5cGUubWF4SW1hZ2VCeXRlcz0xRTY7RWRpdG9yVWkucHJvdG90eXBlLm1heEJhY2tncm91bmRCeXRlcz0yNUU1O0VkaXRvclVpLnByb3RvdHlwZS5tYXhUZXh0Qnl0ZXM9NUU1O0VkaXRvclVpLnByb3RvdHlwZS5jdXJyZW50RmlsZT1udWxsO0VkaXRvclVpLnByb3RvdHlwZS5wcmludFBkZkV4cG9ydD0hMTtFZGl0b3JVaS5wcm90b3R5cGUucGRmUGFnZUV4cG9ydD0hMDtFZGl0b3JVaS5wcm90b3R5cGUuZm9ybWF0RW5hYmxlZD0iMCIhPXVybFBhcmFtcy5mb3JtYXQ7RWRpdG9yVWkucHJvdG90eXBlLmluc2VydFRlbXBsYXRlRW5hYmxlZD0hMDtFZGl0b3JVaS5wcm90b3R5cGUuY2xvc2FibGVTY3JhdGNocGFkPQohMDsoZnVuY3Rpb24oKXtFZGl0b3JVaS5wcm90b3R5cGUudXNlQ2FudmFzRm9yRXhwb3J0PSExO0VkaXRvclVpLnByb3RvdHlwZS5qcGdTdXBwb3J0ZWQ9ITE7dHJ5e3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpO0VkaXRvclVpLnByb3RvdHlwZS5jYW52YXNTdXBwb3J0ZWQ9ISghYS5nZXRDb250ZXh0fHwhYS5nZXRDb250ZXh0KCIyZCIpKX1jYXRjaChsKXt9dHJ5e3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpLGM9bmV3IEltYWdlO2Mub25sb2FkPWZ1bmN0aW9uKCl7dHJ5e2UuZ2V0Q29udGV4dCgiMmQiKS5kcmF3SW1hZ2UoYywwLDApO3ZhciBhPWUudG9EYXRhVVJMKCJpbWFnZS9wbmciKTtFZGl0b3JVaS5wcm90b3R5cGUudXNlQ2FudmFzRm9yRXhwb3J0PW51bGwhPWEmJjY8YS5sZW5ndGh9Y2F0Y2gobil7fX07Yy5zcmM9ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsIitidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCgnPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMXB4IiBoZWlnaHQ9IjFweCIgdmVyc2lvbj0iMS4xIj48Zm9yZWlnbk9iamVjdCBwb2ludGVyLWV2ZW50cz0iYWxsIiB3aWR0aD0iMSIgaGVpZ2h0PSIxIj48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9zdmc+JykpKX1jYXRjaChsKXt9dHJ5e2U9CmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpO2Uud2lkdGg9ZS5oZWlnaHQ9MTt2YXIgZD1lLnRvRGF0YVVSTCgiaW1hZ2UvanBlZyIpO0VkaXRvclVpLnByb3RvdHlwZS5qcGdTdXBwb3J0ZWQ9bnVsbCE9PWQubWF0Y2goImltYWdlL2pwZWciKX1jYXRjaChsKXt9fSkoKTtFZGl0b3JVaS5wcm90b3R5cGUub3Blbkxpbms9ZnVuY3Rpb24oYSxlLGMpe3JldHVybiB0aGlzLmVkaXRvci5ncmFwaC5vcGVuTGluayhhLGUsYyl9O0VkaXRvclVpLnByb3RvdHlwZS5zaG93U3BsYXNoPWZ1bmN0aW9uKGEpe307RWRpdG9yVWkucHJvdG90eXBlLmdldExvY2FsRGF0YT1mdW5jdGlvbihhLGUpe2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oYSkpfTtFZGl0b3JVaS5wcm90b3R5cGUuc2V0TG9jYWxEYXRhPWZ1bmN0aW9uKGEsZSxjKXtsb2NhbFN0b3JhZ2Uuc2V0SXRlbShhLGUpO251bGwhPWMmJmMoKX07RWRpdG9yVWkucHJvdG90eXBlLnJlbW92ZUxvY2FsRGF0YT1mdW5jdGlvbihhLGUpe2xvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGEpOwplKCl9O0VkaXRvclVpLnByb3RvdHlwZS5zZXRNYXRoRW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLmVkaXRvci5ncmFwaC5tYXRoRW5hYmxlZD1hO3RoaXMuZWRpdG9yLnVwZGF0ZUdyYXBoQ29tcG9uZW50cygpO3RoaXMuZWRpdG9yLmdyYXBoLnJlZnJlc2goKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgibWF0aEVuYWJsZWRDaGFuZ2VkIikpfTtFZGl0b3JVaS5wcm90b3R5cGUuaXNNYXRoRW5hYmxlZD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5lZGl0b3IuZ3JhcGgubWF0aEVuYWJsZWR9O0VkaXRvclVpLnByb3RvdHlwZS5pc09mZmxpbmVBcHA9ZnVuY3Rpb24oKXtyZXR1cm4iMSI9PXVybFBhcmFtcy5vZmZsaW5lfTtFZGl0b3JVaS5wcm90b3R5cGUuaXNPZmZsaW5lPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmlzT2ZmbGluZUFwcCgpfHwhbmF2aWdhdG9yLm9uTGluZXx8IWEmJiIxIj09dXJsUGFyYW1zLnN0ZWFsdGh9O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVTcGlubmVyPQpmdW5jdGlvbihhLGUsYyl7Yz1udWxsIT1jP2M6MjQ7dmFyIGI9bmV3IFNwaW5uZXIoe2xpbmVzOjEyLGxlbmd0aDpjLHdpZHRoOk1hdGgucm91bmQoYy8zKSxyYWRpdXM6TWF0aC5yb3VuZChjLzIpLHJvdGF0ZTowLGNvbG9yOiJkYXJrIj09dWlUaGVtZT8iI2MwYzBjMCI6IiMwMDAiLHNwZWVkOjEuNSx0cmFpbDo2MCxzaGFkb3c6ITEsaHdhY2NlbDohMSx6SW5kZXg6MkU5fSksZD1iLnNwaW47Yi5zcGluPWZ1bmN0aW9uKGMsZil7dmFyIGc9ITE7dGhpcy5hY3RpdmV8fChkLmNhbGwodGhpcyxjKSx0aGlzLmFjdGl2ZT0hMCxudWxsIT1mJiYoZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxnLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSIsZy5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiLGcuc3R5bGUuYmFja2dyb3VuZD0iIzRCNDI0MyIsZy5zdHlsZS5jb2xvcj0id2hpdGUiLGcuc3R5bGUuZm9udEZhbWlseT0iSGVsdmV0aWNhLCBBcmlhbCIsZy5zdHlsZS5mb250U2l6ZT0KIjlwdCIsZy5zdHlsZS5wYWRkaW5nPSI2cHgiLGcuc3R5bGUucGFkZGluZ0xlZnQ9IjEwcHgiLGcuc3R5bGUucGFkZGluZ1JpZ2h0PSIxMHB4IixnLnN0eWxlLnpJbmRleD0yRTksZy5zdHlsZS5sZWZ0PU1hdGgubWF4KDAsYSkrInB4IixnLnN0eWxlLnRvcD1NYXRoLm1heCgwLGUrNzApKyJweCIsbXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGcuc3R5bGUsImJvcmRlclJhZGl1cyIsIjZweCIpLG14VXRpbHMuc2V0UHJlZml4ZWRTdHlsZShnLnN0eWxlLCJ0cmFuc2Zvcm0iLCJ0cmFuc2xhdGUoLTUwJSwtNTAlKSIpLCJkYXJrIiE9dWlUaGVtZSYmbXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGcuc3R5bGUsImJveFNoYWRvdyIsIjJweCAycHggM3B4IDBweCAjZGRkIiksIi4uLiIhPWYuc3Vic3RyaW5nKGYubGVuZ3RoLTMsZi5sZW5ndGgpJiYiISIhPWYuY2hhckF0KGYubGVuZ3RoLTEpJiYoZis9Ii4uLiIpLGcuaW5uZXJIVE1MPWYsYy5hcHBlbmRDaGlsZChnKSxiLnN0YXR1cz1nLG14Q2xpZW50LklTX1ZNTCYmCihudWxsPT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fDg+PWRvY3VtZW50LmRvY3VtZW50TW9kZSkmJihnLnN0eWxlLmxlZnQ9TWF0aC5yb3VuZChNYXRoLm1heCgwLGEtZy5vZmZzZXRXaWR0aC8yKSkrInB4IixnLnN0eWxlLnRvcD1NYXRoLnJvdW5kKE1hdGgubWF4KDAsZSs3MC1nLm9mZnNldEhlaWdodC8yKSkrInB4IikpLHRoaXMucGF1c2U9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt2YXIgYT1mdW5jdGlvbigpe307dGhpcy5hY3RpdmUmJihhPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5zcGluKGMsZil9KSk7dGhpcy5zdG9wKCk7cmV0dXJuIGF9KSxnPSEwKTtyZXR1cm4gZ307dmFyIGY9Yi5zdG9wO2Iuc3RvcD1mdW5jdGlvbigpe2YuY2FsbCh0aGlzKTt0aGlzLmFjdGl2ZT0hMTtudWxsIT1iLnN0YXR1cyYmbnVsbCE9Yi5zdGF0dXMucGFyZW50Tm9kZSYmYi5zdGF0dXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiLnN0YXR1cyk7Yi5zdGF0dXM9bnVsbH07CmIucGF1c2U9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oKXt9fTtyZXR1cm4gYn07RWRpdG9yVWkucHJvdG90eXBlLmlzQ29tcGF0aWJsZVN0cmluZz1mdW5jdGlvbihhKXt0cnl7dmFyIGI9bXhVdGlscy5wYXJzZVhtbChhKSxjPXRoaXMuZWRpdG9yLmV4dHJhY3RHcmFwaE1vZGVsKGIuZG9jdW1lbnRFbGVtZW50LCEwKTtyZXR1cm4gbnVsbCE9YyYmMD09Yy5nZXRFbGVtZW50c0J5VGFnTmFtZSgicGFyc2VyZXJyb3IiKS5sZW5ndGh9Y2F0Y2gocCl7fXJldHVybiExfTtFZGl0b3JVaS5wcm90b3R5cGUuaXNWaXNpb0RhdGE9ZnVuY3Rpb24oYSl7cmV0dXJuIDg8YS5sZW5ndGgmJigyMDg9PWEuY2hhckNvZGVBdCgwKSYmMjA3PT1hLmNoYXJDb2RlQXQoMSkmJjE3PT1hLmNoYXJDb2RlQXQoMikmJjIyND09YS5jaGFyQ29kZUF0KDMpJiYxNjE9PWEuY2hhckNvZGVBdCg0KSYmMTc3PT1hLmNoYXJDb2RlQXQoNSkmJjI2PT1hLmNoYXJDb2RlQXQoNikmJjIyNT09YS5jaGFyQ29kZUF0KDcpfHwKODA9PWEuY2hhckNvZGVBdCgwKSYmNzU9PWEuY2hhckNvZGVBdCgxKSYmMz09YS5jaGFyQ29kZUF0KDIpJiY0PT1hLmNoYXJDb2RlQXQoMyl8fDgwPT1hLmNoYXJDb2RlQXQoMCkmJjc1PT1hLmNoYXJDb2RlQXQoMSkmJjM9PWEuY2hhckNvZGVBdCgyKSYmNj09YS5jaGFyQ29kZUF0KDMpKX07RWRpdG9yVWkucHJvdG90eXBlLmlzUmVtb3RlVmlzaW9EYXRhPWZ1bmN0aW9uKGEpe3JldHVybiA4PGEubGVuZ3RoJiYoMjA4PT1hLmNoYXJDb2RlQXQoMCkmJjIwNz09YS5jaGFyQ29kZUF0KDEpJiYxNz09YS5jaGFyQ29kZUF0KDIpJiYyMjQ9PWEuY2hhckNvZGVBdCgzKSYmMTYxPT1hLmNoYXJDb2RlQXQoNCkmJjE3Nz09YS5jaGFyQ29kZUF0KDUpJiYyNj09YS5jaGFyQ29kZUF0KDYpJiYyMjU9PWEuY2hhckNvZGVBdCg3KXx8NjA9PWEuY2hhckNvZGVBdCgwKSYmNjM9PWEuY2hhckNvZGVBdCgxKSYmMTIwPT1hLmNoYXJDb2RlQXQoMikmJjEwOT09YS5jaGFyQ29kZUF0KDMpJiYxMDg9PWEuY2hhckNvZGVBdCgzKSl9OwpFZGl0b3JVaS5wcm90b3R5cGUuaXNQbmdEYXRhPWZ1bmN0aW9uKGEpe3JldHVybiA4PGEubGVuZ3RoJiYxMzc9PWEuY2hhckNvZGVBdCgwKSYmODA9PWEuY2hhckNvZGVBdCgxKSYmNzg9PWEuY2hhckNvZGVBdCgyKSYmNzE9PWEuY2hhckNvZGVBdCgzKSYmMTM9PWEuY2hhckNvZGVBdCg0KSYmMTA9PWEuY2hhckNvZGVBdCg1KSYmMjY9PWEuY2hhckNvZGVBdCg2KSYmMTA9PWEuY2hhckNvZGVBdCg3KX07dmFyIGE9RWRpdG9yVWkucHJvdG90eXBlLmV4dHJhY3RHcmFwaE1vZGVsRnJvbUh0bWw7RWRpdG9yVWkucHJvdG90eXBlLmV4dHJhY3RHcmFwaE1vZGVsRnJvbUh0bWw9ZnVuY3Rpb24oYil7dmFyIGU9YS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYobnVsbD09ZSl0cnl7dmFyIGM9Yi5pbmRleE9mKCImbHQ7bXhmaWxlICIpO2lmKDA8PWMpe3ZhciBkPWIubGFzdEluZGV4T2YoIiZsdDsvbXhmaWxlJmd0OyIpO2Q+YyYmKGU9Yi5zdWJzdHJpbmcoYyxkKzE1KS5yZXBsYWNlKC8mZ3Q7L2csCiI+IikucmVwbGFjZSgvJmx0Oy9nLCI8IikucmVwbGFjZSgvXFwmcXVvdDsvZywnIicpLnJlcGxhY2UoL1xuL2csIiIpKX1lbHNlIHZhciBmPW14VXRpbHMucGFyc2VYbWwoYiksbj10aGlzLmVkaXRvci5leHRyYWN0R3JhcGhNb2RlbChmLmRvY3VtZW50RWxlbWVudCxudWxsIT10aGlzLnBhZ2VzfHwiaGlkZGVuIj09dGhpcy5kaWFncmFtQ29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkpLGU9bnVsbCE9bj9teFV0aWxzLmdldFhtbChuKToiIn1jYXRjaCh2KXt9cmV0dXJuIGV9O0VkaXRvclVpLnByb3RvdHlwZS52YWxpZGF0ZUZpbGVEYXRhPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEmJjA8YS5sZW5ndGgpe3ZhciBiPWEuaW5kZXhPZignPG1ldGEgY2hhcnNldD0idXRmLTgiPicpOzA8PWImJihhPWEuc2xpY2UoMCxiKSsnPG1ldGEgY2hhcnNldD0idXRmLTgiLz4nK2Euc2xpY2UoYisyMy0xLGEubGVuZ3RoKSk7YT1HcmFwaC56YXBHcmVtbGlucyhhKX1yZXR1cm4gYX07RWRpdG9yVWkucHJvdG90eXBlLnJlcGxhY2VGaWxlRGF0YT0KZnVuY3Rpb24oYSl7YT10aGlzLnZhbGlkYXRlRmlsZURhdGEoYSk7YT1udWxsIT1hJiYwPGEubGVuZ3RoP214VXRpbHMucGFyc2VYbWwoYSkuZG9jdW1lbnRFbGVtZW50Om51bGw7dmFyIGI9bnVsbCE9YT90aGlzLmVkaXRvci5leHRyYWN0R3JhcGhNb2RlbChhLCEwKTpudWxsO251bGwhPWImJihhPWIpO2lmKG51bGwhPWEpe2I9dGhpcy5lZGl0b3IuZ3JhcGg7Yi5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgYz1udWxsIT10aGlzLnBhZ2VzP3RoaXMucGFnZXMuc2xpY2UoKTpudWxsLGQ9YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGlhZ3JhbSIpO2lmKCIwIiE9dXJsUGFyYW1zLnBhZ2VzfHwxPGQubGVuZ3RofHwxPT1kLmxlbmd0aCYmZFswXS5oYXNBdHRyaWJ1dGUoIm5hbWUiKSl7dGhpcy5maWxlTm9kZT1hO3RoaXMucGFnZXM9bnVsbCE9dGhpcy5wYWdlcz90aGlzLnBhZ2VzOltdO2Zvcih2YXIgZj1kLmxlbmd0aC0xOzA8PWY7Zi0tKXt2YXIgbj10aGlzLnVwZGF0ZVBhZ2VSb290KG5ldyBEaWFncmFtUGFnZShkW2ZdKSk7Cm51bGw9PW4uZ2V0TmFtZSgpJiZuLnNldE5hbWUobXhSZXNvdXJjZXMuZ2V0KCJwYWdlV2l0aE51bWJlciIsW2YrMV0pKTtiLm1vZGVsLmV4ZWN1dGUobmV3IENoYW5nZVBhZ2UodGhpcyxuLDA9PWY/bjpudWxsLDApKX19ZWxzZSIwIiE9dXJsUGFyYW1zLnBhZ2VzJiZudWxsPT10aGlzLmZpbGVOb2RlJiYodGhpcy5maWxlTm9kZT1hLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgibXhmaWxlIiksdGhpcy5jdXJyZW50UGFnZT1uZXcgRGlhZ3JhbVBhZ2UoYS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpYWdyYW0iKSksdGhpcy5jdXJyZW50UGFnZS5zZXROYW1lKG14UmVzb3VyY2VzLmdldCgicGFnZVdpdGhOdW1iZXIiLFsxXSkpLGIubW9kZWwuZXhlY3V0ZShuZXcgQ2hhbmdlUGFnZSh0aGlzLHRoaXMuY3VycmVudFBhZ2UsdGhpcy5jdXJyZW50UGFnZSwwKSkpLHRoaXMuZWRpdG9yLnNldEdyYXBoWG1sKGEpLG51bGwhPXRoaXMuY3VycmVudFBhZ2UmJih0aGlzLmN1cnJlbnRQYWdlLnJvb3Q9CnRoaXMuZWRpdG9yLmdyYXBoLm1vZGVsLnJvb3QpO2lmKG51bGwhPWMpZm9yKGY9MDtmPGMubGVuZ3RoO2YrKyliLm1vZGVsLmV4ZWN1dGUobmV3IENoYW5nZVBhZ2UodGhpcyxjW2ZdLG51bGwpKX1maW5hbGx5e2IubW9kZWwuZW5kVXBkYXRlKCl9fX07RWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZUZpbGVEYXRhPWZ1bmN0aW9uKGEsZSxjLGQsZixuLGssdCxtLHgscSl7ZT1udWxsIT1lP2U6dGhpcy5lZGl0b3IuZ3JhcGg7Zj1udWxsIT1mP2Y6ITE7bT1udWxsIT1tP206ITA7dmFyIGIsZz1udWxsO251bGw9PWN8fGMuZ2V0TW9kZSgpPT1BcHAuTU9ERV9ERVZJQ0V8fGMuZ2V0TW9kZSgpPT1BcHAuTU9ERV9CUk9XU0VSP2I9Il9ibGFuayI6Zz1iPWQ7aWYobnVsbD09YSlyZXR1cm4iIjt2YXIgbD1hO2lmKCJteGZpbGUiIT1sLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpe2lmKHEpe3ZhciBwPWEub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaWFncmFtIik7cC5zZXRBdHRyaWJ1dGUoImlkIiwKRWRpdG9yLmd1aWQoKSk7cC5hcHBlbmRDaGlsZChhKX1lbHNle3A9R3JhcGguemFwR3JlbWxpbnMobXhVdGlscy5nZXRYbWwoYSkpO2w9R3JhcGguY29tcHJlc3MocCk7aWYoR3JhcGguZGVjb21wcmVzcyhsKSE9cClyZXR1cm4gcDtwPWEub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaWFncmFtIik7cC5zZXRBdHRyaWJ1dGUoImlkIixFZGl0b3IuZ3VpZCgpKTtteFV0aWxzLnNldFRleHRDb250ZW50KHAsbCl9bD1hLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgibXhmaWxlIik7bC5hcHBlbmRDaGlsZChwKX14PyhsPWwuY2xvbmVOb2RlKCEwKSxsLnJlbW92ZUF0dHJpYnV0ZSgibW9kaWZpZWQiKSxsLnJlbW92ZUF0dHJpYnV0ZSgiaG9zdCIpLGwucmVtb3ZlQXR0cmlidXRlKCJhZ2VudCIpLGwucmVtb3ZlQXR0cmlidXRlKCJldGFnIiksbC5yZW1vdmVBdHRyaWJ1dGUoInVzZXJBZ2VudCIpLGwucmVtb3ZlQXR0cmlidXRlKCJ2ZXJzaW9uIiksbC5yZW1vdmVBdHRyaWJ1dGUoImVkaXRvciIpLApsLnJlbW92ZUF0dHJpYnV0ZSgidHlwZSIpKToobC5yZW1vdmVBdHRyaWJ1dGUoInVzZXJBZ2VudCIpLGwucmVtb3ZlQXR0cmlidXRlKCJ2ZXJzaW9uIiksbC5yZW1vdmVBdHRyaWJ1dGUoImVkaXRvciIpLGwucmVtb3ZlQXR0cmlidXRlKCJwYWdlcyIpLGwucmVtb3ZlQXR0cmlidXRlKCJ0eXBlIiksbXhDbGllbnQuSVNfQ0hST01FQVBQP2wuc2V0QXR0cmlidXRlKCJob3N0IiwiQ2hyb21lIik6RWRpdG9yVWkuaXNFbGVjdHJvbkFwcD9sLnNldEF0dHJpYnV0ZSgiaG9zdCIsIkVsZWN0cm9uIik6bC5zZXRBdHRyaWJ1dGUoImhvc3QiLHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSksbC5zZXRBdHRyaWJ1dGUoIm1vZGlmaWVkIiwobmV3IERhdGUpLnRvSVNPU3RyaW5nKCkpLGwuc2V0QXR0cmlidXRlKCJhZ2VudCIsbmF2aWdhdG9yLmFwcFZlcnNpb24pLGwuc2V0QXR0cmlidXRlKCJ2ZXJzaW9uIixFZGl0b3JVaS5WRVJTSU9OKSxsLnNldEF0dHJpYnV0ZSgiZXRhZyIsRWRpdG9yLmd1aWQoKSksCmE9bnVsbCE9Yz9jLmdldE1vZGUoKTp0aGlzLm1vZGUsbnVsbCE9YSYmbC5zZXRBdHRyaWJ1dGUoInR5cGUiLGEpLDE8bC5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGlhZ3JhbSIpLmxlbmd0aCYmbnVsbCE9dGhpcy5wYWdlcyYmbC5zZXRBdHRyaWJ1dGUoInBhZ2VzIix0aGlzLnBhZ2VzLmxlbmd0aCkpO3E9cT9teFV0aWxzLmdldFByZXR0eVhtbChsKTpteFV0aWxzLmdldFhtbChsKTtpZighbiYmIWYmJihrfHxudWxsIT1jJiYvKFwuaHRtbCkkL2kudGVzdChjLmdldFRpdGxlKCkpKSlxPXRoaXMuZ2V0SHRtbDIobXhVdGlscy5nZXRYbWwobCksZSxudWxsIT1jP2MuZ2V0VGl0bGUoKTpudWxsLGIsZyk7ZWxzZSBpZihufHwhZiYmbnVsbCE9YyYmLyhcLnN2ZykkL2kudGVzdChjLmdldFRpdGxlKCkpKW51bGw9PWN8fGMuZ2V0TW9kZSgpIT1BcHAuTU9ERV9ERVZJQ0UmJmMuZ2V0TW9kZSgpIT1BcHAuTU9ERV9CUk9XU0VSfHwoZD1udWxsKSxxPXRoaXMuZ2V0RW1iZWRkZWRTdmcocSxlLApkLG51bGwsdCxtLGcpO3JldHVybiBxfTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0WG1sRmlsZURhdGE9ZnVuY3Rpb24oYSxlLGMpe2E9bnVsbCE9YT9hOiEwO2U9bnVsbCE9ZT9lOiExO2M9bnVsbCE9Yz9jOiFFZGl0b3IuY29tcHJlc3NYbWw7dmFyIGI9dGhpcy5lZGl0b3IuZ2V0R3JhcGhYbWwoYSk7aWYoYSYmbnVsbCE9dGhpcy5maWxlTm9kZSYmbnVsbCE9dGhpcy5jdXJyZW50UGFnZSlpZihhPWZ1bmN0aW9uKGEpe3ZhciBlPWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIm14R3JhcGhNb2RlbCIpLGU9MDxlLmxlbmd0aD9lWzBdOm51bGw7bnVsbD09ZSYmYz8oZT1teFV0aWxzLnRyaW0obXhVdGlscy5nZXRUZXh0Q29udGVudChhKSksYT1hLmNsb25lTm9kZSghMSksMDxlLmxlbmd0aCYmKGU9R3JhcGguZGVjb21wcmVzcyhlKSxudWxsIT1lJiYwPGUubGVuZ3RoJiZhLmFwcGVuZENoaWxkKG14VXRpbHMucGFyc2VYbWwoZSkuZG9jdW1lbnRFbGVtZW50KSkpOm51bGw9PWV8fGM/YT1hLmNsb25lTm9kZSghMCk6CihhPWEuY2xvbmVOb2RlKCExKSxteFV0aWxzLnNldFRleHRDb250ZW50KGEsR3JhcGguY29tcHJlc3NOb2RlKGUpKSk7Yi5hcHBlbmRDaGlsZChhKX0sRWRpdG9yVWkucmVtb3ZlQ2hpbGROb2Rlcyh0aGlzLmN1cnJlbnRQYWdlLm5vZGUpLG14VXRpbHMuc2V0VGV4dENvbnRlbnQodGhpcy5jdXJyZW50UGFnZS5ub2RlLEdyYXBoLmNvbXByZXNzTm9kZShiKSksYj10aGlzLmZpbGVOb2RlLmNsb25lTm9kZSghMSksZSlhKHRoaXMuY3VycmVudFBhZ2Uubm9kZSk7ZWxzZSBmb3IoZT0wO2U8dGhpcy5wYWdlcy5sZW5ndGg7ZSsrKXtpZih0aGlzLmN1cnJlbnRQYWdlIT10aGlzLnBhZ2VzW2VdJiZ0aGlzLnBhZ2VzW2VdLm5lZWRzVXBkYXRlKXt2YXIgZD0obmV3IG14Q29kZWMobXhVdGlscy5jcmVhdGVYbWxEb2N1bWVudCgpKSkuZW5jb2RlKG5ldyBteEdyYXBoTW9kZWwodGhpcy5wYWdlc1tlXS5yb290KSk7dGhpcy5lZGl0b3IuZ3JhcGguc2F2ZVZpZXdTdGF0ZSh0aGlzLnBhZ2VzW2VdLnZpZXdTdGF0ZSwKZCk7RWRpdG9yVWkucmVtb3ZlQ2hpbGROb2Rlcyh0aGlzLnBhZ2VzW2VdLm5vZGUpO214VXRpbHMuc2V0VGV4dENvbnRlbnQodGhpcy5wYWdlc1tlXS5ub2RlLEdyYXBoLmNvbXByZXNzTm9kZShkKSk7ZGVsZXRlIHRoaXMucGFnZXNbZV0ubmVlZHNVcGRhdGV9YSh0aGlzLnBhZ2VzW2VdLm5vZGUpfXJldHVybiBifTtFZGl0b3JVaS5wcm90b3R5cGUuYW5vbnltaXplU3RyaW5nPWZ1bmN0aW9uKGEsZSl7Zm9yKHZhciBiPVtdLGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGQ9YS5jaGFyQXQoYyk7MDw9RWRpdG9yVWkuaWdub3JlZEFub255bWl6ZWRDaGFycy5pbmRleE9mKGQpP2IucHVzaChkKTppc05hTihwYXJzZUludChkKSk/ZC50b0xvd2VyQ2FzZSgpIT1kP2IucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDY1K01hdGgucm91bmQoMjUqTWF0aC5yYW5kb20oKSkpKTpkLnRvVXBwZXJDYXNlKCkhPWQ/Yi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoOTcrTWF0aC5yb3VuZCgyNSpNYXRoLnJhbmRvbSgpKSkpOgovXHMvLnRlc3QoZCk/Yi5wdXNoKCIgIik6Yi5wdXNoKCI/Iik6Yi5wdXNoKGU/IjAiOk1hdGgucm91bmQoOSpNYXRoLnJhbmRvbSgpKSl9cmV0dXJuIGIuam9pbigiIil9O0VkaXRvclVpLnByb3RvdHlwZS5hbm9ueW1pemVQYXRjaD1mdW5jdGlvbihhKXtpZihudWxsIT1hW0VkaXRvclVpLkRJRkZfSU5TRVJUXSlmb3IodmFyIGI9MDtiPGFbRWRpdG9yVWkuRElGRl9JTlNFUlRdLmxlbmd0aDtiKyspdHJ5e3ZhciBjPW14VXRpbHMucGFyc2VYbWwoYVtFZGl0b3JVaS5ESUZGX0lOU0VSVF1bYl0uZGF0YSkuZG9jdW1lbnRFbGVtZW50LmNsb25lTm9kZSghMSk7bnVsbCE9Yy5nZXRBdHRyaWJ1dGUoIm5hbWUiKSYmYy5zZXRBdHRyaWJ1dGUoIm5hbWUiLHRoaXMuYW5vbnltaXplU3RyaW5nKGMuZ2V0QXR0cmlidXRlKCJuYW1lIikpKTthW0VkaXRvclVpLkRJRkZfSU5TRVJUXVtiXS5kYXRhPW14VXRpbHMuZ2V0WG1sKGMpfWNhdGNoKG4pe2FbRWRpdG9yVWkuRElGRl9JTlNFUlRdW2JdLmRhdGE9Cm4ubWVzc2FnZX1pZihudWxsIT1hW0VkaXRvclVpLkRJRkZfVVBEQVRFXSl7Zm9yKHZhciBkIGluIGFbRWRpdG9yVWkuRElGRl9VUERBVEVdKXt2YXIgZj1hW0VkaXRvclVpLkRJRkZfVVBEQVRFXVtkXTtudWxsIT1mLm5hbWUmJihmLm5hbWU9dGhpcy5hbm9ueW1pemVTdHJpbmcoZi5uYW1lKSk7bnVsbCE9Zi5jZWxscyYmKGI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dmFyIGI9Zi5jZWxsc1thXTtpZihudWxsIT1iKXtmb3IodmFyIGUgaW4gYiludWxsIT1iW2VdLnZhbHVlJiYoYltlXS52YWx1ZT0iWyIrYltlXS52YWx1ZS5sZW5ndGgrIl0iKSxudWxsIT1iW2VdLnhtbFZhbHVlJiYoYltlXS54bWxWYWx1ZT0iWyIrYltlXS54bWxWYWx1ZS5sZW5ndGgrIl0iKSxudWxsIT1iW2VdLnN0eWxlJiYoYltlXS5zdHlsZT0iWyIrYltlXS5zdHlsZS5sZW5ndGgrIl0iKSwwPT1PYmplY3Qua2V5cyhiW2VdKS5sZW5ndGgmJmRlbGV0ZSBiW2VdOzA9PU9iamVjdC5rZXlzKGIpLmxlbmd0aCYmCmRlbGV0ZSBmLmNlbGxzW2FdfX0pLGIoRWRpdG9yVWkuRElGRl9JTlNFUlQpLGIoRWRpdG9yVWkuRElGRl9VUERBVEUpLDA9PU9iamVjdC5rZXlzKGYuY2VsbHMpLmxlbmd0aCYmZGVsZXRlIGYuY2VsbHMpOzA9PU9iamVjdC5rZXlzKGYpLmxlbmd0aCYmZGVsZXRlIGFbRWRpdG9yVWkuRElGRl9VUERBVEVdW2RdfTA9PU9iamVjdC5rZXlzKGFbRWRpdG9yVWkuRElGRl9VUERBVEVdKS5sZW5ndGgmJmRlbGV0ZSBhW0VkaXRvclVpLkRJRkZfVVBEQVRFXX1yZXR1cm4gYX07RWRpdG9yVWkucHJvdG90eXBlLmFub255bWl6ZUF0dHJpYnV0ZXM9ZnVuY3Rpb24oYSxlKXtpZihudWxsIT1hLmF0dHJpYnV0ZXMpZm9yKHZhciBiPTA7YjxhLmF0dHJpYnV0ZXMubGVuZ3RoO2IrKykiYXMiIT1hLmF0dHJpYnV0ZXNbYl0ubmFtZSYmYS5zZXRBdHRyaWJ1dGUoYS5hdHRyaWJ1dGVzW2JdLm5hbWUsdGhpcy5hbm9ueW1pemVTdHJpbmcoYS5hdHRyaWJ1dGVzW2JdLnZhbHVlLGUpKTtpZihudWxsIT1hLmNoaWxkTm9kZXMpZm9yKGI9CjA7YjxhLmNoaWxkTm9kZXMubGVuZ3RoO2IrKyl0aGlzLmFub255bWl6ZUF0dHJpYnV0ZXMoYS5jaGlsZE5vZGVzW2JdLGUpfTtFZGl0b3JVaS5wcm90b3R5cGUuYW5vbnltaXplTm9kZT1mdW5jdGlvbihhLGUpe2Zvcih2YXIgYj1hLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJteENlbGwiKSxjPTA7YzxiLmxlbmd0aDtjKyspbnVsbCE9YltjXS5nZXRBdHRyaWJ1dGUoInZhbHVlIikmJmJbY10uc2V0QXR0cmlidXRlKCJ2YWx1ZSIsIlsiK2JbY10uZ2V0QXR0cmlidXRlKCJ2YWx1ZSIpLmxlbmd0aCsiXSIpLG51bGwhPWJbY10uZ2V0QXR0cmlidXRlKCJ4bWxWYWx1ZSIpJiZiW2NdLnNldEF0dHJpYnV0ZSgieG1sVmFsdWUiLCJbIitiW2NdLmdldEF0dHJpYnV0ZSgieG1sVmFsdWUiKS5sZW5ndGgrIl0iKSxudWxsIT1iW2NdLmdldEF0dHJpYnV0ZSgic3R5bGUiKSYmYltjXS5zZXRBdHRyaWJ1dGUoInN0eWxlIiwiWyIrYltjXS5nZXRBdHRyaWJ1dGUoInN0eWxlIikubGVuZ3RoKyJdIiksbnVsbCE9CmJbY10ucGFyZW50Tm9kZSYmInJvb3QiIT1iW2NdLnBhcmVudE5vZGUubm9kZU5hbWUmJm51bGwhPWJbY10ucGFyZW50Tm9kZS5wYXJlbnROb2RlJiYoYltjXS5zZXRBdHRyaWJ1dGUoImlkIixiW2NdLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCJpZCIpKSxiW2NdLnBhcmVudE5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoYltjXSxiW2NdLnBhcmVudE5vZGUpKTtyZXR1cm4gYX07RWRpdG9yVWkucHJvdG90eXBlLnN5bmNocm9uaXplQ3VycmVudEZpbGU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5nZXRDdXJyZW50RmlsZSgpO251bGwhPWImJihiLnNhdmluZ0ZpbGU/dGhpcy5oYW5kbGVFcnJvcih7bWVzc2FnZTpteFJlc291cmNlcy5nZXQoImJ1c3kiKX0pOiFhJiZiLmludmFsaWRDaGVja3N1bT9iLmhhbmRsZUZpbGVFcnJvcihudWxsLCEwKTp0aGlzLnNwaW5uZXIuc3Bpbihkb2N1bWVudC5ib2R5LG14UmVzb3VyY2VzLmdldCgidXBkYXRpbmdEb2N1bWVudCIpKSYmKGIuY2xlYXJBdXRvc2F2ZSgpLAp0aGlzLmVkaXRvci5zZXRTdGF0dXMoIiIpLGE/Yi5yZWxvYWRGaWxlKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7Yi5oYW5kbGVGaWxlU3VjY2VzcygibWFudWFsIj09RHJhd2lvRmlsZS5TWU5DKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2IuaGFuZGxlRmlsZUVycm9yKGEsITApfSkpOmIuc3luY2hyb25pemVGaWxlKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7Yi5oYW5kbGVGaWxlU3VjY2VzcygibWFudWFsIj09RHJhd2lvRmlsZS5TWU5DKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2IuaGFuZGxlRmlsZUVycm9yKGEsITApfSkpKSl9O0VkaXRvclVpLnByb3RvdHlwZS5nZXRGaWxlRGF0YT1mdW5jdGlvbihhLGUsYyxkLGYsbixrLHQsbSx4KXtmPW51bGwhPWY/ZjohMDtuPW51bGwhPW4/bjohMTt2YXIgYj10aGlzLmVkaXRvci5ncmFwaDtpZihlfHwhYSYmbnVsbCE9bSYmLyhcLnN2ZykkL2kudGVzdChtLmdldFRpdGxlKCkpKWlmKHg9CiExLG51bGwhPXRoaXMucGFnZXMmJnRoaXMuY3VycmVudFBhZ2UhPXRoaXMucGFnZXNbMF0pe3ZhciBnPWIuZ2V0R2xvYmFsVmFyaWFibGUsYj10aGlzLmNyZWF0ZVRlbXBvcmFyeUdyYXBoKGIuZ2V0U3R5bGVzaGVldCgpKSxsPXRoaXMucGFnZXNbMF07Yi5nZXRHbG9iYWxWYXJpYWJsZT1mdW5jdGlvbihhKXtyZXR1cm4icGFnZSI9PWE/bC5nZXROYW1lKCk6InBhZ2VudW1iZXIiPT1hPzE6Zy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYi5jb250YWluZXIpO2IubW9kZWwuc2V0Um9vdChsLnJvb3QpfWs9bnVsbCE9az9rOnRoaXMuZ2V0WG1sRmlsZURhdGEoZixuLHgpO209bnVsbCE9bT9tOnRoaXMuZ2V0Q3VycmVudEZpbGUoKTthPXRoaXMuY3JlYXRlRmlsZURhdGEoayxiLG0sd2luZG93LmxvY2F0aW9uLmhyZWYsYSxlLGMsZCxmLHQseCk7YiE9dGhpcy5lZGl0b3IuZ3JhcGgmJmIuY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYi5jb250YWluZXIpOwpyZXR1cm4gYX07RWRpdG9yVWkucHJvdG90eXBlLmdldEh0bWw9ZnVuY3Rpb24oYSxlLGMsZCxmLG4pe249bnVsbCE9bj9uOiEwO3ZhciBiPW51bGwsZz1FZGl0b3JVaS5kcmF3SG9zdCsiL2pzL2VtYmVkLXN0YXRpYy5taW4uanMiO2lmKG51bGwhPWUpe3ZhciBiPW4/ZS5nZXRHcmFwaEJvdW5kcygpOmUuZ2V0Qm91bmRpbmdCb3goZS5nZXRTZWxlY3Rpb25DZWxscygpKSxsPWUudmlldy5zY2FsZTtuPU1hdGguZmxvb3IoYi54L2wtZS52aWV3LnRyYW5zbGF0ZS54KTtsPU1hdGguZmxvb3IoYi55L2wtZS52aWV3LnRyYW5zbGF0ZS55KTtiPWUuYmFja2dyb3VuZDtudWxsPT1mJiYoZT10aGlzLmdldEJhc2VuYW1lcygpLmpvaW4oIjsiKSwwPGUubGVuZ3RoJiYoZz1FZGl0b3JVaS5kcmF3SG9zdCsiL2VtYmVkLmpzP3M9IitlKSk7YS5zZXRBdHRyaWJ1dGUoIngwIixuKTthLnNldEF0dHJpYnV0ZSgieTAiLGwpfW51bGwhPWEmJihhLnNldEF0dHJpYnV0ZSgicGFuIiwiMSIpLGEuc2V0QXR0cmlidXRlKCJ6b29tIiwKIjEiKSxhLnNldEF0dHJpYnV0ZSgicmVzaXplIiwiMCIpLGEuc2V0QXR0cmlidXRlKCJmaXQiLCIwIiksYS5zZXRBdHRyaWJ1dGUoImJvcmRlciIsIjIwIiksYS5zZXRBdHRyaWJ1dGUoImxpbmtzIiwiMSIpLG51bGwhPWQmJmEuc2V0QXR0cmlidXRlKCJlZGl0IixkKSk7bnVsbCE9ZiYmKGY9Zi5yZXBsYWNlKC8mL2csIiZhbXA7IikpO2E9bnVsbCE9YT9HcmFwaC56YXBHcmVtbGlucyhteFV0aWxzLmdldFhtbChhKSk6IiI7ZD1HcmFwaC5jb21wcmVzcyhhKTtHcmFwaC5kZWNvbXByZXNzKGQpIT1hJiYoZD1lbmNvZGVVUklDb21wb25lbnQoYSkpO3JldHVybihudWxsPT1mPydceDNjIS0tW2lmIElFXT48bWV0YSBodHRwLWVxdWl2PSJYLVVBLUNvbXBhdGlibGUiIGNvbnRlbnQ9IklFPTUsSUU9OSIgPjwhW2VuZGlmXS0tXHgzZVxuJzoiIikrIjwhRE9DVFlQRSBodG1sPlxuPGh0bWwiKyhudWxsIT1mPycgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPic6Ij4iKSsiXG48aGVhZD5cbiIrCihudWxsPT1mP251bGwhPWM/Ijx0aXRsZT4iK214VXRpbHMuaHRtbEVudGl0aWVzKGMpKyI8L3RpdGxlPlxuIjoiIjoiPHRpdGxlPmRpYWdyYW1zLm5ldDwvdGl0bGU+XG4iKSsobnVsbCE9Zj8nPG1ldGEgaHR0cC1lcXVpdj0icmVmcmVzaCIgY29udGVudD0iMDtVUkw9XCcnK2YrIidcIi8+XG4iOiIiKSsiPC9oZWFkPlxuPGJvZHkiKyhudWxsPT1mJiZudWxsIT1iJiZiIT1teENvbnN0YW50cy5OT05FPycgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6JytiKyc7Ij4nOiI+IikrJ1xuPGRpdiBjbGFzcz0ibXhncmFwaCIgc3R5bGU9InBvc2l0aW9uOnJlbGF0aXZlO292ZXJmbG93OmF1dG87d2lkdGg6MTAwJTsiPlxuPGRpdiBzdHlsZT0id2lkdGg6MXB4O2hlaWdodDoxcHg7b3ZlcmZsb3c6aGlkZGVuOyI+JytkKyI8L2Rpdj5cbjwvZGl2PlxuIisobnVsbD09Zj8nPHNjcmlwdCB0eXBlPSJ0ZXh0L2phdmFzY3JpcHQiIHNyYz0iJytnKyciPlx4M2Mvc2NyaXB0Pic6JzxhIHN0eWxlPSJwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO2xlZnQ6NTAlO21hcmdpbi10b3A6LTEyOHB4O21hcmdpbi1sZWZ0Oi02NHB4OyIgaHJlZj0iJysKZisnIiB0YXJnZXQ9Il9ibGFuayI+PGltZyBib3JkZXI9IjAiIHNyYz0iJytFZGl0b3JVaS5kcmF3SG9zdCsnL2ltYWdlcy9kcmF3bG9nbzEyOC5wbmciLz48L2E+JykrIlxuPC9ib2R5PlxuPC9odG1sPlxuIn07RWRpdG9yVWkucHJvdG90eXBlLmdldEh0bWwyPWZ1bmN0aW9uKGEsZSxjLGQsZil7ZT13aW5kb3cuRFJBV0lPX1ZJRVdFUl9VUkx8fEVkaXRvclVpLmRyYXdIb3N0KyIvanMvdmlld2VyLm1pbi5qcyI7bnVsbCE9ZiYmKGY9Zi5yZXBsYWNlKC8mL2csIiZhbXA7IikpO2E9e2hpZ2hsaWdodDoiIzAwMDBmZiIsbmF2OnRoaXMuZWRpdG9yLmdyYXBoLmZvbGRpbmdFbmFibGVkLHJlc2l6ZTohMCx4bWw6R3JhcGguemFwR3JlbWxpbnMoYSksdG9vbGJhcjoicGFnZXMgem9vbSBsYXllcnMgbGlnaHRib3gifTtudWxsIT10aGlzLnBhZ2VzJiZudWxsIT10aGlzLmN1cnJlbnRQYWdlJiYoYS5wYWdlPW14VXRpbHMuaW5kZXhPZih0aGlzLnBhZ2VzLHRoaXMuY3VycmVudFBhZ2UpKTtyZXR1cm4obnVsbD09CmY/J1x4M2MhLS1baWYgSUVdPjxtZXRhIGh0dHAtZXF1aXY9IlgtVUEtQ29tcGF0aWJsZSIgY29udGVudD0iSUU9NSxJRT05IiA+PCFbZW5kaWZdLS1ceDNlXG4nOiIiKSsiPCFET0NUWVBFIGh0bWw+XG48aHRtbCIrKG51bGwhPWY/JyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+JzoiPiIpKyJcbjxoZWFkPlxuIisobnVsbD09Zj9udWxsIT1jPyI8dGl0bGU+IitteFV0aWxzLmh0bWxFbnRpdGllcyhjKSsiPC90aXRsZT5cbiI6IiI6Ijx0aXRsZT5kaWFncmFtcy5uZXQ8L3RpdGxlPlxuIikrKG51bGwhPWY/JzxtZXRhIGh0dHAtZXF1aXY9InJlZnJlc2giIGNvbnRlbnQ9IjA7VVJMPVwnJytmKyInXCIvPlxuIjoiIikrJzxtZXRhIGNoYXJzZXQ9InV0Zi04Ii8+XG48L2hlYWQ+XG48Ym9keT5cbjxkaXYgY2xhc3M9Im14Z3JhcGgiIHN0eWxlPSJtYXgtd2lkdGg6MTAwJTtib3JkZXI6MXB4IHNvbGlkIHRyYW5zcGFyZW50OyIgZGF0YS1teGdyYXBoPSInK214VXRpbHMuaHRtbEVudGl0aWVzKEpTT04uc3RyaW5naWZ5KGEpKSsKJyI+PC9kaXY+XG4nKyhudWxsPT1mPyc8c2NyaXB0IHR5cGU9InRleHQvamF2YXNjcmlwdCIgc3JjPSInK2UrJyI+XHgzYy9zY3JpcHQ+JzonPGEgc3R5bGU9InBvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7bGVmdDo1MCU7bWFyZ2luLXRvcDotMTI4cHg7bWFyZ2luLWxlZnQ6LTY0cHg7IiBocmVmPSInK2YrJyIgdGFyZ2V0PSJfYmxhbmsiPjxpbWcgYm9yZGVyPSIwIiBzcmM9IicrRWRpdG9yVWkuZHJhd0hvc3QrJy9pbWFnZXMvZHJhd2xvZ28xMjgucG5nIi8+PC9hPicpKyJcbjwvYm9keT5cbjwvaHRtbD5cbiJ9O0VkaXRvclVpLnByb3RvdHlwZS5zZXRGaWxlRGF0YT1mdW5jdGlvbihhKXthPXRoaXMudmFsaWRhdGVGaWxlRGF0YShhKTt0aGlzLnBhZ2VzPXRoaXMuZmlsZU5vZGU9dGhpcy5jdXJyZW50UGFnZT1udWxsO2E9bnVsbCE9YSYmMDxhLmxlbmd0aD9teFV0aWxzLnBhcnNlWG1sKGEpLmRvY3VtZW50RWxlbWVudDpudWxsO3ZhciBiPUVkaXRvci5leHRyYWN0UGFyc2VyRXJyb3IoYSwKbXhSZXNvdXJjZXMuZ2V0KCJpbnZhbGlkT3JNaXNzaW5nRmlsZSIpKTtpZihiKXRocm93IEVycm9yKG14UmVzb3VyY2VzLmdldCgibm90QURpYWdyYW1GaWxlIikrIiAoIitiKyIpIik7Yj1udWxsIT1hP3RoaXMuZWRpdG9yLmV4dHJhY3RHcmFwaE1vZGVsKGEsITApOm51bGw7bnVsbCE9YiYmKGE9Yik7aWYobnVsbCE9YSYmIm14ZmlsZSI9PWEubm9kZU5hbWUmJihiPWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpYWdyYW0iKSwiMCIhPXVybFBhcmFtcy5wYWdlc3x8MTxiLmxlbmd0aHx8MT09Yi5sZW5ndGgmJmJbMF0uaGFzQXR0cmlidXRlKCJuYW1lIikpKXt2YXIgYz1udWxsO3RoaXMuZmlsZU5vZGU9YTt0aGlzLnBhZ2VzPVtdO2Zvcih2YXIgZD0wO2Q8Yi5sZW5ndGg7ZCsrKW51bGw9PWJbZF0uZ2V0QXR0cmlidXRlKCJpZCIpJiZiW2RdLnNldEF0dHJpYnV0ZSgiaWQiLGQpLGE9bmV3IERpYWdyYW1QYWdlKGJbZF0pLG51bGw9PWEuZ2V0TmFtZSgpJiZhLnNldE5hbWUobXhSZXNvdXJjZXMuZ2V0KCJwYWdlV2l0aE51bWJlciIsCltkKzFdKSksdGhpcy5wYWdlcy5wdXNoKGEpLG51bGwhPXVybFBhcmFtc1sicGFnZS1pZCJdJiZhLmdldElkKCk9PXVybFBhcmFtc1sicGFnZS1pZCJdJiYoYz1hKTt0aGlzLmN1cnJlbnRQYWdlPW51bGwhPWM/Yzp0aGlzLnBhZ2VzW01hdGgubWF4KDAsTWF0aC5taW4odGhpcy5wYWdlcy5sZW5ndGgtMSx1cmxQYXJhbXMucGFnZXx8MCkpXTthPXRoaXMuY3VycmVudFBhZ2Uubm9kZX0iMCIhPXVybFBhcmFtcy5wYWdlcyYmbnVsbD09dGhpcy5maWxlTm9kZSYmbnVsbCE9YSYmKHRoaXMuZmlsZU5vZGU9YS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIm14ZmlsZSIpLHRoaXMuY3VycmVudFBhZ2U9bmV3IERpYWdyYW1QYWdlKGEub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaWFncmFtIikpLHRoaXMuY3VycmVudFBhZ2Uuc2V0TmFtZShteFJlc291cmNlcy5nZXQoInBhZ2VXaXRoTnVtYmVyIixbMV0pKSx0aGlzLnBhZ2VzPVt0aGlzLmN1cnJlbnRQYWdlXSk7dGhpcy5lZGl0b3Iuc2V0R3JhcGhYbWwoYSk7Cm51bGwhPXRoaXMuY3VycmVudFBhZ2UmJih0aGlzLmN1cnJlbnRQYWdlLnJvb3Q9dGhpcy5lZGl0b3IuZ3JhcGgubW9kZWwucm9vdCk7aWYobnVsbCE9dXJsUGFyYW1zWyJsYXllci1pZHMiXSl0cnl7dmFyIGY9dXJsUGFyYW1zWyJsYXllci1pZHMiXS5zcGxpdCgiICIpO2E9e307Zm9yKGQ9MDtkPGYubGVuZ3RoO2QrKylhW2ZbZF1dPSEwO2Zvcih2YXIgbj10aGlzLmVkaXRvci5ncmFwaC5nZXRNb2RlbCgpLGs9bi5nZXRDaGlsZHJlbihuLnJvb3QpLGQ9MDtkPGsubGVuZ3RoO2QrKyl7dmFyIHQ9a1tkXTtuLnNldFZpc2libGUodCxhW3QuaWRdfHwhMSl9fWNhdGNoKHkpe319O0VkaXRvclVpLnByb3RvdHlwZS5nZXRCYXNlRmlsZW5hbWU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5nZXRDdXJyZW50RmlsZSgpLGI9bnVsbCE9YiYmbnVsbCE9Yi5nZXRUaXRsZSgpP2IuZ2V0VGl0bGUoKTp0aGlzLmRlZmF1bHRGaWxlbmFtZTtpZigvKFwueG1sKSQvaS50ZXN0KGIpfHwvKFwuaHRtbCkkL2kudGVzdChiKXx8Ci8oXC5zdmcpJC9pLnRlc3QoYil8fC8oXC5wbmcpJC9pLnRlc3QoYil8fC8oXC5kcmF3aW8pJC9pLnRlc3QoYikpYj1iLnN1YnN0cmluZygwLGIubGFzdEluZGV4T2YoIi4iKSk7IWEmJm51bGwhPXRoaXMucGFnZXMmJjE8dGhpcy5wYWdlcy5sZW5ndGgmJm51bGwhPXRoaXMuY3VycmVudFBhZ2UmJm51bGwhPXRoaXMuY3VycmVudFBhZ2Uubm9kZS5nZXRBdHRyaWJ1dGUoIm5hbWUiKSYmMDx0aGlzLmN1cnJlbnRQYWdlLmdldE5hbWUoKS5sZW5ndGgmJihiPWIrIi0iK3RoaXMuY3VycmVudFBhZ2UuZ2V0TmFtZSgpKTtyZXR1cm4gYn07RWRpdG9yVWkucHJvdG90eXBlLmRvd25sb2FkRmlsZT1mdW5jdGlvbihhLGUsYyxkLGYsbixrLHQsbSx4LHEpe3RyeXtkPW51bGwhPWQ/ZDp0aGlzLmVkaXRvci5ncmFwaC5pc1NlbGVjdGlvbkVtcHR5KCk7dmFyIGI9dGhpcy5nZXRCYXNlRmlsZW5hbWUoIWYpLGc9YisiLiIrYTtpZigieG1sIj09YSl7dmFyIGw9Jzw/eG1sIHZlcnNpb249IjEuMCIgZW5jb2Rpbmc9IlVURi04Ij8+XG4nKwp0aGlzLmdldEZpbGVEYXRhKCEwLG51bGwsbnVsbCxudWxsLGQsZixudWxsLG51bGwsbnVsbCxlKTt0aGlzLnNhdmVEYXRhKGcsYSxsLCJ0ZXh0L3htbCIpfWVsc2UgaWYoImh0bWwiPT1hKWw9dGhpcy5nZXRIdG1sMih0aGlzLmdldEZpbGVEYXRhKCEwKSx0aGlzLmVkaXRvci5ncmFwaCxiKSx0aGlzLnNhdmVEYXRhKGcsYSxsLCJ0ZXh0L2h0bWwiKTtlbHNlIGlmKCJzdmciIT1hJiYieG1sc3ZnIiE9YXx8IXRoaXMuc3Bpbm5lci5zcGluKGRvY3VtZW50LmJvZHksbXhSZXNvdXJjZXMuZ2V0KCJleHBvcnQiKSkpInhtbHBuZyI9PWE/Zz1iKyIucG5nIjoianBlZyI9PWEmJihnPWIrIi5qcGciKSx0aGlzLnNhdmVSZXF1ZXN0KGcsYSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiLGUpe3RyeXt2YXIgYz10aGlzLmVkaXRvci5ncmFwaC5wYWdlVmlzaWJsZTtudWxsIT1uJiYodGhpcy5lZGl0b3IuZ3JhcGgucGFnZVZpc2libGU9bik7dmFyIGc9dGhpcy5jcmVhdGVEb3dubG9hZFJlcXVlc3QoYiwKYSxkLGUsayxmLHQsbSx4LHEpO3RoaXMuZWRpdG9yLmdyYXBoLnBhZ2VWaXNpYmxlPWM7cmV0dXJuIGd9Y2F0Y2goTSl7dGhpcy5oYW5kbGVFcnJvcihNKX19KSk7ZWxzZXt2YXIgcD1udWxsLHk9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7YS5sZW5ndGg8PU1BWF9SRVFVRVNUX1NJWkU/dGhpcy5zYXZlRGF0YShnLCJzdmciLGEsImltYWdlL3N2Zyt4bWwiKTp0aGlzLmhhbmRsZUVycm9yKHttZXNzYWdlOm14UmVzb3VyY2VzLmdldCgiZHJhd2luZ1Rvb0xhcmdlIil9LG14UmVzb3VyY2VzLmdldCgiZXJyb3IiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe214VXRpbHMucG9wdXAocCl9KSl9KTtpZigic3ZnIj09YSl7dmFyIHY9dGhpcy5lZGl0b3IuZ3JhcGguYmFja2dyb3VuZDtpZihrfHx2PT1teENvbnN0YW50cy5OT05FKXY9bnVsbDt2YXIgRT10aGlzLmVkaXRvci5ncmFwaC5nZXRTdmcodixudWxsLG51bGwsbnVsbCxudWxsLGQpO2MmJnRoaXMuZWRpdG9yLmdyYXBoLmFkZFN2Z1NoYWRvdyhFKTsKdGhpcy5lZGl0b3IuY29udmVydEltYWdlcyhFLG14VXRpbHMuYmluZCh0aGlzLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuc3Bpbm5lci5zdG9wKCk7eSgnPD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz5cbjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+XG4nK214VXRpbHMuZ2V0WG1sKGEpKX0pKSl9ZWxzZSBnPWIrIi5zdmciLHA9dGhpcy5nZXRGaWxlRGF0YSghMSwhMCxudWxsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuc3Bpbm5lci5zdG9wKCk7eShhKX0pLGQpfX1jYXRjaChKKXt0aGlzLmhhbmRsZUVycm9yKEopfX07RWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZURvd25sb2FkUmVxdWVzdD1mdW5jdGlvbihhLGUsYyxkLGYsbixrLHQsbSx4KXt2YXIgYj10aGlzLmVkaXRvci5ncmFwaCxnPWIuZ2V0R3JhcGhCb3VuZHMoKTsKYz10aGlzLmdldEZpbGVEYXRhKCEwLG51bGwsbnVsbCxudWxsLGMsMD09bj8hMToieG1scG5nIiE9ZSk7dmFyIGw9IiIscD0iIjtpZihnLndpZHRoKmcuaGVpZ2h0Pk1BWF9BUkVBfHxjLmxlbmd0aD5NQVhfUkVRVUVTVF9TSVpFKXRocm93e21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJkcmF3aW5nVG9vTGFyZ2UiKX07eD14PyIxIjoiMCI7InBkZiI9PWUmJjA9PW4mJihwPSImYWxsUGFnZXM9MSIpO2lmKCJ4bWxwbmciPT1lJiYoeD0iMSIsZT0icG5nIixudWxsIT10aGlzLnBhZ2VzJiZudWxsIT10aGlzLmN1cnJlbnRQYWdlKSlmb3Iobj0wO248dGhpcy5wYWdlcy5sZW5ndGg7bisrKWlmKHRoaXMucGFnZXNbbl09PXRoaXMuY3VycmVudFBhZ2Upe2w9IiZmcm9tPSIrbjticmVha31uPWIuYmFja2dyb3VuZDsicG5nIj09ZSYmZj9uPW14Q29uc3RhbnRzLk5PTkU6Znx8bnVsbCE9biYmbiE9bXhDb25zdGFudHMuTk9ORXx8KG49IiNmZmZmZmYiKTtmPXtnbG9iYWxWYXJzOmIuZ2V0RXhwb3J0VmFyaWFibGVzKCl9OwptJiYoZi5ncmlkPXtzaXplOmIuZ3JpZFNpemUsc3RlcHM6Yi52aWV3LmdyaWRTdGVwcyxjb2xvcjpiLnZpZXcuZ3JpZENvbG9yfSk7cmV0dXJuIG5ldyBteFhtbFJlcXVlc3QoRVhQT1JUX1VSTCwiZm9ybWF0PSIrZStsK3ArIiZiZz0iKyhudWxsIT1uP246bXhDb25zdGFudHMuTk9ORSkrIiZiYXNlNjQ9IitkKyImZW1iZWRYbWw9Iit4KyImeG1sPSIrZW5jb2RlVVJJQ29tcG9uZW50KGMpKyhudWxsIT1hPyImZmlsZW5hbWU9IitlbmNvZGVVUklDb21wb25lbnQoYSk6IiIpKyImZXh0cmFzPSIrZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGYpKSsobnVsbCE9az8iJnNjYWxlPSIrazoiIikrKG51bGwhPXQ/IiZib3JkZXI9Iit0OiIiKSl9O0VkaXRvclVpLnByb3RvdHlwZS5zZXRNb2RlPWZ1bmN0aW9uKGEsZSl7dGhpcy5tb2RlPWF9O0VkaXRvclVpLnByb3RvdHlwZS5sb2FkRGVzY3JpcHRvcj1mdW5jdGlvbihhLGUsYyl7dmFyIGI9d2luZG93LmxvY2F0aW9uLmhhc2gsCmQ9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYyl7dmFyIGQ9bnVsbCE9YS5kYXRhP2EuZGF0YToiIjtudWxsIT1jJiYwPGMubGVuZ3RoJiYoMDxkLmxlbmd0aCYmKGQrPSJcbiIpLGQrPWMpO2M9bmV3IExvY2FsRmlsZSh0aGlzLCJjc3YiIT1hLmZvcm1hdCYmMDxkLmxlbmd0aD9kOnRoaXMuZW1wdHlEaWFncmFtWG1sLG51bGwhPXVybFBhcmFtcy50aXRsZT9kZWNvZGVVUklDb21wb25lbnQodXJsUGFyYW1zLnRpdGxlKTp0aGlzLmRlZmF1bHRGaWxlbmFtZSwhMCk7Yy5nZXRIYXNoPWZ1bmN0aW9uKCl7cmV0dXJuIGJ9O3RoaXMuZmlsZUxvYWRlZChjKTsiY3N2Ij09YS5mb3JtYXQmJnRoaXMuaW1wb3J0Q3N2KGQsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5lZGl0b3IudW5kb01hbmFnZXIuY2xlYXIoKTt0aGlzLmVkaXRvci5zZXRNb2RpZmllZCghMSk7dGhpcy5lZGl0b3Iuc2V0U3RhdHVzKCIiKX0pKTtpZihudWxsIT1hLnVwZGF0ZSl7dmFyIGY9bnVsbCE9YS5pbnRlcnZhbD8KcGFyc2VJbnQoYS5pbnRlcnZhbCk6NkU0LGc9bnVsbCxsPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5jdXJyZW50UGFnZTtteFV0aWxzLnBvc3QoYS51cGRhdGUsInhtbD0iK2VuY29kZVVSSUNvbXBvbmVudChteFV0aWxzLmdldFhtbCh0aGlzLmVkaXRvci5nZXRHcmFwaFhtbCgpKSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7Yj09PXRoaXMuY3VycmVudFBhZ2UmJigyMDA8PWEuZ2V0U3RhdHVzKCkmJjMwMD49YS5nZXRTdGF0dXMoKT8odGhpcy51cGRhdGVEaWFncmFtKGEuZ2V0VGV4dCgpKSxwKCkpOnRoaXMuaGFuZGxlRXJyb3Ioe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJlcnJvciIpKyIgIithLmdldFN0YXR1cygpfSkpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5oYW5kbGVFcnJvcihhKX0pKX0pLHA9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt3aW5kb3cuY2xlYXJUaW1lb3V0KGcpO2c9d2luZG93LnNldFRpbWVvdXQobCwKZil9KTt0aGlzLmVkaXRvci5hZGRMaXN0ZW5lcigicGFnZVNlbGVjdGVkIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3AoKTtsKCl9KSk7cCgpO2woKX1udWxsIT1lJiZlKCl9KTtpZihudWxsIT1hLnVybCYmMDxhLnVybC5sZW5ndGgpe3ZhciBmPWEudXJsOy9eaHR0cHM/OlwvXC8vLnRlc3QoZikmJiF0aGlzLmVkaXRvci5pc0NvcnNFbmFibGVkRm9yVXJsKGYpJiYoZj1QUk9YWV9VUkwrIj91cmw9IitlbmNvZGVVUklDb21wb25lbnQoZikpO3RoaXMuZWRpdG9yLmxvYWRVcmwoZixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtkKGEpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bnVsbCE9YyYmYyhhKX0pKX1lbHNlIGQoIiIpfTtFZGl0b3JVaS5wcm90b3R5cGUudXBkYXRlRGlhZ3JhbT1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEpe3ZhciBiPW5ldyBteENlbGxPdmVybGF5KGEuaW1hZ2V8fGYud2FybmluZ0ltYWdlLGEudG9vbHRpcCxhLmFsaWduLGEudmFsaWduLAphLm9mZnNldCk7Yi5hZGRMaXN0ZW5lcihteEV2ZW50LkNMSUNLLGZ1bmN0aW9uKGIsZSl7ZC5hbGVydChhLnRvb2x0aXApfSk7cmV0dXJuIGJ9dmFyIGM9bnVsbCxkPXRoaXM7aWYobnVsbCE9YSYmMDxhLmxlbmd0aCYmKGM9bXhVdGlscy5wYXJzZVhtbChhKSxhPW51bGwhPWM/Yy5kb2N1bWVudEVsZW1lbnQ6bnVsbCxudWxsIT1hJiYidXBkYXRlcyI9PWEubm9kZU5hbWUpKXt2YXIgZj10aGlzLmVkaXRvci5ncmFwaCxuPWYuZ2V0TW9kZWwoKTtuLmJlZ2luVXBkYXRlKCk7dmFyIGs9bnVsbDt0cnl7Zm9yKGE9YS5maXJzdENoaWxkO251bGwhPWE7KXtpZigidXBkYXRlIj09YS5ub2RlTmFtZSl7dmFyIHQ9bi5nZXRDZWxsKGEuZ2V0QXR0cmlidXRlKCJpZCIpKTtpZihudWxsIT10KXt0cnl7dmFyIG09YS5nZXRBdHRyaWJ1dGUoInZhbHVlIik7aWYobnVsbCE9bSl7dmFyIHg9bXhVdGlscy5wYXJzZVhtbChtKS5kb2N1bWVudEVsZW1lbnQ7aWYobnVsbCE9eClpZigiMSI9PXguZ2V0QXR0cmlidXRlKCJyZXBsYWNlLXZhbHVlIikpbi5zZXRWYWx1ZSh0LAp4KTtlbHNlIGZvcih2YXIgcT14LmF0dHJpYnV0ZXMsQT0wO0E8cS5sZW5ndGg7QSsrKWYuc2V0QXR0cmlidXRlRm9yQ2VsbCh0LHFbQV0ubm9kZU5hbWUsMDxxW0FdLm5vZGVWYWx1ZS5sZW5ndGg/cVtBXS5ub2RlVmFsdWU6bnVsbCl9fWNhdGNoKHUpe251bGwhPXdpbmRvdy5jb25zb2xlJiZjb25zb2xlLmxvZygiRXJyb3IgaW4gdmFsdWUgZm9yICIrdC5pZCsiOiAiK3UpfXRyeXt2YXIgQz1hLmdldEF0dHJpYnV0ZSgic3R5bGUiKTtudWxsIT1DJiZmLm1vZGVsLnNldFN0eWxlKHQsQyl9Y2F0Y2godSl7bnVsbCE9d2luZG93LmNvbnNvbGUmJmNvbnNvbGUubG9nKCJFcnJvciBpbiBzdHlsZSBmb3IgIit0LmlkKyI6ICIrdSl9dHJ5e3ZhciB6PWEuZ2V0QXR0cmlidXRlKCJpY29uIik7aWYobnVsbCE9eil7dmFyIEQ9MDx6Lmxlbmd0aD9KU09OLnBhcnNlKHopOm51bGw7bnVsbCE9RCYmRC5hcHBlbmR8fGYucmVtb3ZlQ2VsbE92ZXJsYXlzKHQpO251bGwhPUQmJmYuYWRkQ2VsbE92ZXJsYXkodCwKYihEKSl9fWNhdGNoKHUpe251bGwhPXdpbmRvdy5jb25zb2xlJiZjb25zb2xlLmxvZygiRXJyb3IgaW4gaWNvbiBmb3IgIit0LmlkKyI6ICIrdSl9dHJ5e3ZhciBHPWEuZ2V0QXR0cmlidXRlKCJnZW9tZXRyeSIpO2lmKG51bGwhPUcpe3ZhciBHPUpTT04ucGFyc2UoRyksRj1mLmdldENlbGxHZW9tZXRyeSh0KTtpZihudWxsIT1GKXtGPUYuY2xvbmUoKTtmb3Ioa2V5IGluIEcpe3ZhciBIPXBhcnNlRmxvYXQoR1trZXldKTsiZHgiPT1rZXk/Ri54Kz1IOiJkeSI9PWtleT9GLnkrPUg6ImR3Ij09a2V5P0Yud2lkdGgrPUg6ImRoIj09a2V5P0YuaGVpZ2h0Kz1IOkZba2V5XT1wYXJzZUZsb2F0KEdba2V5XSl9Zi5tb2RlbC5zZXRHZW9tZXRyeSh0LEYpfX19Y2F0Y2godSl7bnVsbCE9d2luZG93LmNvbnNvbGUmJmNvbnNvbGUubG9nKCJFcnJvciBpbiBpY29uIGZvciAiK3QuaWQrIjogIit1KX19fWVsc2UgaWYoIm1vZGVsIj09YS5ub2RlTmFtZSl7Zm9yKHZhciBKPWEuZmlyc3RDaGlsZDtudWxsIT0KSiYmSi5ub2RlVHlwZSE9bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVDspSj1KLm5leHRTaWJsaW5nO251bGwhPUomJihuZXcgbXhDb2RlYyhhLmZpcnN0Q2hpbGQpKS5kZWNvZGUoSixuKX1lbHNlIGlmKCJ2aWV3Ij09YS5ub2RlTmFtZSl7aWYoYS5oYXNBdHRyaWJ1dGUoInNjYWxlIikmJihmLnZpZXcuc2NhbGU9cGFyc2VGbG9hdChhLmdldEF0dHJpYnV0ZSgic2NhbGUiKSkpLGEuaGFzQXR0cmlidXRlKCJkeCIpfHxhLmhhc0F0dHJpYnV0ZSgiZHkiKSlmLnZpZXcudHJhbnNsYXRlPW5ldyBteFBvaW50KHBhcnNlRmxvYXQoYS5nZXRBdHRyaWJ1dGUoImR4Iil8fDApLHBhcnNlRmxvYXQoYS5nZXRBdHRyaWJ1dGUoImR5Iil8fDApKX1lbHNlImZpdCI9PWEubm9kZU5hbWUmJihrPWEuaGFzQXR0cmlidXRlKCJtYXgtc2NhbGUiKT9wYXJzZUZsb2F0KGEuZ2V0QXR0cmlidXRlKCJtYXgtc2NhbGUiKSk6MSk7YT1hLm5leHRTaWJsaW5nfX1maW5hbGx5e24uZW5kVXBkYXRlKCl9bnVsbCE9CmsmJnRoaXMuY2hyb21lbGVzc1Jlc2l6ZSYmdGhpcy5jaHJvbWVsZXNzUmVzaXplKCEwLGspfXJldHVybiBjfTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0Q29weUZpbGVuYW1lPWZ1bmN0aW9uKGEsZSl7dmFyIGI9bnVsbCE9YSYmbnVsbCE9YS5nZXRUaXRsZSgpP2EuZ2V0VGl0bGUoKTp0aGlzLmRlZmF1bHRGaWxlbmFtZSxjPSIiLGQ9Yi5sYXN0SW5kZXhPZigiLiIpOzA8PWQmJihjPWIuc3Vic3RyaW5nKGQpLGI9Yi5zdWJzdHJpbmcoMCxkKSk7aWYoZSl2YXIgZj1uZXcgRGF0ZSxkPWYuZ2V0RnVsbFllYXIoKSxrPWYuZ2V0TW9udGgoKSsxLHQ9Zi5nZXREYXRlKCksbT1mLmdldEhvdXJzKCkseD1mLmdldE1pbnV0ZXMoKSxmPWYuZ2V0U2Vjb25kcygpLGI9YisoIiAiKyhkKyItIitrKyItIit0KyItIittKyItIit4KyItIitmKSk7cmV0dXJuIGI9bXhSZXNvdXJjZXMuZ2V0KCJjb3B5T2YiLFtiXSkrY307RWRpdG9yVWkucHJvdG90eXBlLmZpbGVMb2FkZWQ9ZnVuY3Rpb24oYSxlKXt2YXIgYj0KdGhpcy5nZXRDdXJyZW50RmlsZSgpO3RoaXMuZmlsZUxvYWRlZEVycm9yPW51bGw7dGhpcy5zZXRDdXJyZW50RmlsZShudWxsKTt2YXIgYz0hMTt0aGlzLmhpZGVEaWFsb2coKTtudWxsIT1iJiYoRWRpdG9yVWkuZGVidWcoIkZpbGUuY2xvc2VkIixbYl0pLGIucmVtb3ZlTGlzdGVuZXIodGhpcy5kZXNjcmlwdG9yQ2hhbmdlZExpc3RlbmVyKSxiLmNsb3NlKCkpO3RoaXMuZWRpdG9yLmdyYXBoLm1vZGVsLmNsZWFyKCk7dGhpcy5lZGl0b3IudW5kb01hbmFnZXIuY2xlYXIoKTt2YXIgZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuc2V0R3JhcGhFbmFibGVkKCExKTt0aGlzLnNldEN1cnJlbnRGaWxlKG51bGwpO251bGwhPWImJnRoaXMudXBkYXRlRG9jdW1lbnRUaXRsZSgpO3RoaXMuZWRpdG9yLmdyYXBoLm1vZGVsLmNsZWFyKCk7dGhpcy5lZGl0b3IudW5kb01hbmFnZXIuY2xlYXIoKTt0aGlzLnNldEJhY2tncm91bmRJbWFnZShudWxsKTshZSYmbnVsbCE9d2luZG93LmxvY2F0aW9uLmhhc2gmJgowPHdpbmRvdy5sb2NhdGlvbi5oYXNoLmxlbmd0aCYmKHdpbmRvdy5sb2NhdGlvbi5oYXNoPSIiKTtudWxsIT10aGlzLmZuYW1lJiYodGhpcy5mbmFtZVdyYXBwZXIuc3R5bGUuZGlzcGxheT0ibm9uZSIsdGhpcy5mbmFtZS5pbm5lckhUTUw9IiIsdGhpcy5mbmFtZS5zZXRBdHRyaWJ1dGUoInRpdGxlIixteFJlc291cmNlcy5nZXQoInJlbmFtZSIpKSk7dGhpcy5lZGl0b3Iuc2V0U3RhdHVzKCIiKTt0aGlzLnVwZGF0ZVVpKCk7ZXx8dGhpcy5zaG93U3BsYXNoKCl9KTtpZihudWxsIT1hKXRyeXtteENsaWVudC5JU19TRiYmIm1pbiI9PXVpVGhlbWUmJih0aGlzLmRpYWdyYW1Db250YWluZXIuc3R5bGUudmlzaWJpbGl0eT0iIik7dGhpcy5vcGVuaW5nRmlsZT0hMDt0aGlzLnNldEN1cnJlbnRGaWxlKGEpO2EuYWRkTGlzdGVuZXIoImRlc2NyaXB0b3JDaGFuZ2VkIix0aGlzLmRlc2NyaXB0b3JDaGFuZ2VkTGlzdGVuZXIpO2EuYWRkTGlzdGVuZXIoImNvbnRlbnRDaGFuZ2VkIix0aGlzLmRlc2NyaXB0b3JDaGFuZ2VkTGlzdGVuZXIpOwphLm9wZW4oKTtkZWxldGUgdGhpcy5vcGVuaW5nRmlsZTt0aGlzLnNldEdyYXBoRW5hYmxlZCghMCk7dGhpcy5zZXRNb2RlKGEuZ2V0TW9kZSgpKTt0aGlzLmVkaXRvci5ncmFwaC5tb2RlbC5wcmVmaXg9RWRpdG9yLmd1aWQoKSsiLSI7dGhpcy5lZGl0b3IudW5kb01hbmFnZXIuY2xlYXIoKTt0aGlzLmRlc2NyaXB0b3JDaGFuZ2VkKCk7dGhpcy51cGRhdGVVaSgpO2EuaXNFZGl0YWJsZSgpP2EuaXNNb2RpZmllZCgpPyhhLmFkZFVuc2F2ZWRTdGF0dXMoKSxudWxsIT1hLmJhY2t1cFBhdGNoJiZhLnBhdGNoKFthLmJhY2t1cFBhdGNoXSkpOnRoaXMuZWRpdG9yLnNldFN0YXR1cygiIik6dGhpcy5lZGl0b3Iuc2V0U3RhdHVzKCc8c3BhbiBjbGFzcz0iZ2VTdGF0dXNBbGVydCIgc3R5bGU9Im1hcmdpbi1sZWZ0OjhweDsiPicrbXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KCJyZWFkT25seSIpKSsiPC9zcGFuPiIpOyF0aGlzLmVkaXRvci5pc0Nocm9tZWxlc3NWaWV3KCl8fAp0aGlzLmVkaXRvci5lZGl0YWJsZT8odGhpcy5lZGl0b3IuZ3JhcGguc2VsZWN0VW5sb2NrZWRMYXllcigpLHRoaXMuc2hvd0xheWVyc0RpYWxvZygpLHRoaXMucmVzdG9yZUxpYnJhcmllcygpLHdpbmRvdy5zZWxmIT09d2luZG93LnRvcCYmd2luZG93LmZvY3VzKCkpOnRoaXMuZWRpdG9yLmdyYXBoLmlzTGlnaHRib3hWaWV3KCkmJnRoaXMubGlnaHRib3hGaXQoKTt0aGlzLmNocm9tZWxlc3NSZXNpemUmJnRoaXMuY2hyb21lbGVzc1Jlc2l6ZSgpO3RoaXMuZWRpdG9yLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgiZmlsZUxvYWRlZCIpKTtjPSEwO3RoaXMuaXNPZmZsaW5lKCl8fG51bGw9PWEuZ2V0TW9kZSgpfHxFZGl0b3JVaS5sb2dFdmVudCh7Y2F0ZWdvcnk6YS5nZXRNb2RlKCkudG9VcHBlckNhc2UoKSsiLU9QRU4tRklMRS0iK2EuZ2V0SGFzaCgpLGFjdGlvbjoic2l6ZV8iK2EuZ2V0U2l6ZSgpLGxhYmVsOiJhdXRvc2F2ZV8iKyh0aGlzLmVkaXRvci5hdXRvc2F2ZT8ib24iOgoib2ZmIil9KTtFZGl0b3JVaS5kZWJ1ZygiRmlsZS5vcGVuZWQiLFthXSk7aWYodGhpcy5lZGl0b3IuZWRpdGFibGUmJnRoaXMubW9kZT09YS5nZXRNb2RlKCkmJmEuZ2V0TW9kZSgpIT1BcHAuTU9ERV9ERVZJQ0UmJm51bGwhPWEuZ2V0TW9kZSgpKXRyeXt0aGlzLmFkZFJlY2VudCh7aWQ6YS5nZXRIYXNoKCksdGl0bGU6YS5nZXRUaXRsZSgpLG1vZGU6YS5nZXRNb2RlKCl9KX1jYXRjaCh2KXt9dHJ5e214U2V0dGluZ3Muc2V0T3BlbkNvdW50ZXIobXhTZXR0aW5ncy5nZXRPcGVuQ291bnRlcigpKzEpLG14U2V0dGluZ3Muc2F2ZSgpfWNhdGNoKHYpe319Y2F0Y2godil7dGhpcy5maWxlTG9hZGVkRXJyb3I9djtpZihFZGl0b3JVaS5lbmFibGVMb2dnaW5nJiYhdGhpcy5pc09mZmxpbmUoKSl0cnl7RWRpdG9yVWkubG9nRXZlbnQoe2NhdGVnb3J5OiJFUlJPUi1MT0FELUZJTEUtIisobnVsbCE9YT9hLmdldEhhc2goKToibm9uZSIpLGFjdGlvbjoibWVzc2FnZV8iK3YubWVzc2FnZSxsYWJlbDoic3RhY2tfIisKdi5zdGFja30pfWNhdGNoKHQpe312YXIgZj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe251bGwhPXVybFBhcmFtcy51cmwmJnRoaXMuc3Bpbm5lci5zcGluKGRvY3VtZW50LmJvZHksbXhSZXNvdXJjZXMuZ2V0KCJyZWNvbm5lY3RpbmciKSk/d2luZG93LmxvY2F0aW9uLnNlYXJjaD10aGlzLmdldFNlYXJjaChbInVybCJdKTpudWxsIT1iP3RoaXMuZmlsZUxvYWRlZChiKTpkKCl9KTtlP2YoKTp0aGlzLmhhbmRsZUVycm9yKHYsbXhSZXNvdXJjZXMuZ2V0KCJlcnJvckxvYWRpbmdGaWxlIiksZiwhMCxudWxsLG51bGwsITApfWVsc2UgZCgpO3JldHVybiBjfTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0SGFzaFZhbHVlRm9yUGFnZXM9ZnVuY3Rpb24oYSxlKXt2YXIgYj0wLGM9bmV3IG14R3JhcGhNb2RlbCxkPW5ldyBteENvZGVjO251bGwhPWUmJihlLmJ5dGVDb3VudD0wLGUuYXR0ckNvdW50PTAsZS5lbHRDb3VudD0wLGUubm9kZUNvdW50PTApO2Zvcih2YXIgZj0wO2Y8YS5sZW5ndGg7ZisrKXt0aGlzLnVwZGF0ZVBhZ2VSb290KGFbZl0pOwp2YXIgaz1hW2ZdLm5vZGUuY2xvbmVOb2RlKCExKTtrLnJlbW92ZUF0dHJpYnV0ZSgibmFtZSIpO2Mucm9vdD1hW2ZdLnJvb3Q7dmFyIHQ9ZC5lbmNvZGUoYyk7dGhpcy5lZGl0b3IuZ3JhcGguc2F2ZVZpZXdTdGF0ZShhW2ZdLnZpZXdTdGF0ZSx0LCEwKTt0LnJlbW92ZUF0dHJpYnV0ZSgicGFnZVdpZHRoIik7dC5yZW1vdmVBdHRyaWJ1dGUoInBhZ2VIZWlnaHQiKTtrLmFwcGVuZENoaWxkKHQpO251bGwhPWUmJihlLmVsdENvdW50Kz1rLmdldEVsZW1lbnRzQnlUYWdOYW1lKCIqIikubGVuZ3RoLGUubm9kZUNvdW50Kz1rLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJteENlbGwiKS5sZW5ndGgpO2I9KGI8PDUpLWIrdGhpcy5oYXNoVmFsdWUoayxmdW5jdGlvbihhLGIsZSxjKXtyZXR1cm4hY3x8Im14R2VvbWV0cnkiIT1hLm5vZGVOYW1lJiYibXhQb2ludCIhPWEubm9kZU5hbWV8fCJ4IiE9YiYmInkiIT1iJiYid2lkdGgiIT1iJiYiaGVpZ2h0IiE9Yj9jJiYibXhDZWxsIj09YS5ub2RlTmFtZSYmCiJwcmV2aW91cyI9PWI/bnVsbDplOk1hdGgucm91bmQoZSl9LGUpPDwwfXJldHVybiBifTtFZGl0b3JVaS5wcm90b3R5cGUuaGFzaFZhbHVlPWZ1bmN0aW9uKGEsZSxjKXt2YXIgYj0wO2lmKG51bGwhPWEmJiJvYmplY3QiPT09dHlwZW9mIGEmJiJudW1iZXIiPT09dHlwZW9mIGEubm9kZVR5cGUmJiJzdHJpbmciPT09dHlwZW9mIGEubm9kZU5hbWUmJiJmdW5jdGlvbiI9PT10eXBlb2YgYS5nZXRBdHRyaWJ1dGUpe251bGwhPWEubm9kZU5hbWUmJihiXj10aGlzLmhhc2hWYWx1ZShhLm5vZGVOYW1lLGUsYykpO2lmKG51bGwhPWEuYXR0cmlidXRlcyl7bnVsbCE9YyYmKGMuYXR0ckNvdW50Kz1hLmF0dHJpYnV0ZXMubGVuZ3RoKTtmb3IodmFyIGQ9MDtkPGEuYXR0cmlidXRlcy5sZW5ndGg7ZCsrKXt2YXIgZj1hLmF0dHJpYnV0ZXNbZF0ubmFtZSxnPW51bGwhPWU/ZShhLGYsYS5hdHRyaWJ1dGVzW2RdLnZhbHVlLCEwKTphLmF0dHJpYnV0ZXNbZF0udmFsdWU7bnVsbCE9ZyYmKGJePXRoaXMuaGFzaFZhbHVlKGYsCmUsYykrdGhpcy5oYXNoVmFsdWUoZyxlLGMpKX19aWYobnVsbCE9YS5jaGlsZE5vZGVzKWZvcihkPTA7ZDxhLmNoaWxkTm9kZXMubGVuZ3RoO2QrKyliPShiPDw1KS1iK3RoaXMuaGFzaFZhbHVlKGEuY2hpbGROb2Rlc1tkXSxlLGMpPDwwfWVsc2UgaWYobnVsbCE9YSYmImZ1bmN0aW9uIiE9PXR5cGVvZiBhKXthPVN0cmluZyhhKTtlPTA7bnVsbCE9YyYmKGMuYnl0ZUNvdW50Kz1hLmxlbmd0aCk7Zm9yKGQ9MDtkPGEubGVuZ3RoO2QrKyllPShlPDw1KS1lK2EuY2hhckNvZGVBdChkKTw8MDtiXj1lfXJldHVybiBifTtFZGl0b3JVaS5wcm90b3R5cGUuZGVzY3JpcHRvckNoYW5nZWQ9ZnVuY3Rpb24oKXt9O0VkaXRvclVpLnByb3RvdHlwZS5yZXN0b3JlTGlicmFyaWVzPWZ1bmN0aW9uKCl7fTtFZGl0b3JVaS5wcm90b3R5cGUuc2F2ZUxpYnJhcnk9ZnVuY3Rpb24oYSxlLGMsZCxmLG4sayl7fTtFZGl0b3JVaS5wcm90b3R5cGUuaXNTY3JhdGNocGFkRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiBpc0xvY2FsU3RvcmFnZXx8Cm14Q2xpZW50LklTX0NIUk9NRUFQUH07RWRpdG9yVWkucHJvdG90eXBlLnRvZ2dsZVNjcmF0Y2hwYWQ9ZnVuY3Rpb24oKXt0aGlzLmlzU2NyYXRjaHBhZEVuYWJsZWQoKSYmKG51bGw9PXRoaXMuc2NyYXRjaHBhZD9TdG9yYWdlRmlsZS5nZXRGaWxlQ29udGVudCh0aGlzLCIuc2NyYXRjaHBhZCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bnVsbD09YSYmKGE9dGhpcy5lbXB0eUxpYnJhcnlYbWwpO3RoaXMubG9hZExpYnJhcnkobmV3IFN0b3JhZ2VMaWJyYXJ5KHRoaXMsYSwiLnNjcmF0Y2hwYWQiKSl9KSk6dGhpcy5jbG9zZUxpYnJhcnkodGhpcy5zY3JhdGNocGFkKSl9O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVMaWJyYXJ5RGF0YUZyb21JbWFnZXM9ZnVuY3Rpb24oYSl7dmFyIGI9bXhVdGlscy5jcmVhdGVYbWxEb2N1bWVudCgpLGM9Yi5jcmVhdGVFbGVtZW50KCJteGxpYnJhcnkiKTtteFV0aWxzLnNldFRleHRDb250ZW50KGMsSlNPTi5zdHJpbmdpZnkoYSkpO2IuYXBwZW5kQ2hpbGQoYyk7CnJldHVybiBteFV0aWxzLmdldFhtbChiKX07RWRpdG9yVWkucHJvdG90eXBlLmNsb3NlTGlicmFyeT1mdW5jdGlvbihhKXtudWxsIT1hJiYodGhpcy5yZW1vdmVMaWJyYXJ5U2lkZWJhcihhLmdldEhhc2goKSksYS5jb25zdHJ1Y3RvciE9TG9jYWxMaWJyYXJ5JiZteFNldHRpbmdzLnJlbW92ZUN1c3RvbUxpYnJhcnkoYS5nZXRIYXNoKCkpLCIuc2NyYXRjaHBhZCI9PWEudGl0bGUmJih0aGlzLnNjcmF0Y2hwYWQ9bnVsbCkpfTtFZGl0b3JVaS5wcm90b3R5cGUucmVtb3ZlTGlicmFyeVNpZGViYXI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5zaWRlYmFyLnBhbGV0dGVzW2FdO2lmKG51bGwhPWIpe2Zvcih2YXIgYz0wO2M8Yi5sZW5ndGg7YysrKWJbY10ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiW2NdKTtkZWxldGUgdGhpcy5zaWRlYmFyLnBhbGV0dGVzW2FdfX07RWRpdG9yVWkucHJvdG90eXBlLnJlcG9zaXRpb25MaWJyYXJ5PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc2lkZWJhci5jb250YWluZXI7CmlmKG51bGw9PWEpe3ZhciBjPXRoaXMuc2lkZWJhci5wYWxldHRlc1siTC5zY3JhdGNocGFkIl07bnVsbD09YyYmKGM9dGhpcy5zaWRlYmFyLnBhbGV0dGVzLnNlYXJjaCk7bnVsbCE9YyYmKGE9Y1tjLmxlbmd0aC0xXS5uZXh0U2libGluZyl9YT1udWxsIT1hP2E6Yi5maXJzdENoaWxkLm5leHRTaWJsaW5nLm5leHRTaWJsaW5nO3ZhciBjPWIubGFzdENoaWxkLGQ9Yy5wcmV2aW91c1NpYmxpbmc7Yi5pbnNlcnRCZWZvcmUoYyxhKTtiLmluc2VydEJlZm9yZShkLGMpfTtFZGl0b3JVaS5wcm90b3R5cGUubG9hZExpYnJhcnk9ZnVuY3Rpb24oYSxjKXt2YXIgYj1teFV0aWxzLnBhcnNlWG1sKGEuZ2V0RGF0YSgpKTtpZigibXhsaWJyYXJ5Ij09Yi5kb2N1bWVudEVsZW1lbnQubm9kZU5hbWUpe3ZhciBlPUpTT04ucGFyc2UobXhVdGlscy5nZXRUZXh0Q29udGVudChiLmRvY3VtZW50RWxlbWVudCkpO3RoaXMubGlicmFyeUxvYWRlZChhLGUsYi5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCJ0aXRsZSIpLApjKX1lbHNlIHRocm93e21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJub3RBTGlicmFyeUZpbGUiKX07fTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0TGlicmFyeVN0b3JhZ2VIaW50PWZ1bmN0aW9uKGEpe3JldHVybiIifTtFZGl0b3JVaS5wcm90b3R5cGUubGlicmFyeUxvYWRlZD1mdW5jdGlvbihhLGMsZCxmKXtpZihudWxsIT10aGlzLnNpZGViYXIpe2EuY29uc3RydWN0b3IhPUxvY2FsTGlicmFyeSYmbXhTZXR0aW5ncy5hZGRDdXN0b21MaWJyYXJ5KGEuZ2V0SGFzaCgpKTsiLnNjcmF0Y2hwYWQiPT1hLnRpdGxlJiYodGhpcy5zY3JhdGNocGFkPWEpO3ZhciBiPXRoaXMuc2lkZWJhci5wYWxldHRlc1thLmdldEhhc2goKV0sYj1udWxsIT1iP2JbYi5sZW5ndGgtMV0ubmV4dFNpYmxpbmc6bnVsbDt0aGlzLnJlbW92ZUxpYnJhcnlTaWRlYmFyKGEuZ2V0SGFzaCgpKTt2YXIgZT1udWxsLGc9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYixjKXswPT1iLmxlbmd0aCYmYS5pc0VkaXRhYmxlKCk/CihudWxsPT1lJiYoZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxlLmNsYXNzTmFtZT0iZ2VEcm9wVGFyZ2V0IixteFV0aWxzLndyaXRlKGUsbXhSZXNvdXJjZXMuZ2V0KCJkcmFnRWxlbWVudHNIZXJlIikpKSxjLmFwcGVuZENoaWxkKGUpKTp0aGlzLmFkZExpYnJhcnlFbnRyaWVzKGIsYyl9KTtudWxsIT10aGlzLnNpZGViYXImJm51bGwhPWMmJnRoaXMuc2lkZWJhci5hZGRFbnRyaWVzKGMpO2Q9bnVsbCE9ZCYmMDxkLmxlbmd0aD9kOmEuZ2V0VGl0bGUoKTt2YXIgcD10aGlzLnNpZGViYXIuYWRkUGFsZXR0ZShhLmdldEhhc2goKSxkLG51bGwhPWY/ZjohMCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtnKGMsYSl9KSk7dGhpcy5yZXBvc2l0aW9uTGlicmFyeShiKTt2YXIgaz1wLnBhcmVudE5vZGUucHJldmlvdXNTaWJsaW5nO2Y9ay5nZXRBdHRyaWJ1dGUoInRpdGxlIik7bnVsbCE9ZiYmMDxmLmxlbmd0aCYmIi5zY3JhdGNocGFkIiE9YS50aXRsZSYmay5zZXRBdHRyaWJ1dGUoInRpdGxlIiwKdGhpcy5nZXRMaWJyYXJ5U3RvcmFnZUhpbnQoYSkrIlxuIitmKTt2YXIgbT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTttLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7bS5zdHlsZS5yaWdodD0iMHB4IjttLnN0eWxlLnRvcD0iMHB4IjttLnN0eWxlLnBhZGRpbmc9IjhweCI7bXhDbGllbnQuSVNfUVVJUktTfHw4PT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fChtLnN0eWxlLmJhY2tncm91bmRDb2xvcj0iaW5oZXJpdCIpO2suc3R5bGUucG9zaXRpb249InJlbGF0aXZlIjt2YXIgcT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTtxLnNldEF0dHJpYnV0ZSgic3JjIixEaWFsb2cucHJvdG90eXBlLmNsb3NlSW1hZ2UpO3Euc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJjbG9zZSIpKTtxLnNldEF0dHJpYnV0ZSgidmFsaWduIiwiYWJzbWlkZGxlIik7cS5zZXRBdHRyaWJ1dGUoImJvcmRlciIsIjAiKTtxLnN0eWxlLmN1cnNvcj0icG9pbnRlciI7cS5zdHlsZS5tYXJnaW49CiIwIDNweCI7dmFyIEE9bnVsbDtpZigiLnNjcmF0Y2hwYWQiIT1hLnRpdGxlfHx0aGlzLmNsb3NhYmxlU2NyYXRjaHBhZCltLmFwcGVuZENoaWxkKHEpLG14RXZlbnQuYWRkTGlzdGVuZXIocSwiY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe2lmKCFteEV2ZW50LmlzQ29uc3VtZWQoYikpe3ZhciBjPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5jbG9zZUxpYnJhcnkoYSl9KTtudWxsIT1BP3RoaXMuY29uZmlybShteFJlc291cmNlcy5nZXQoImFsbENoYW5nZXNMb3N0IiksbnVsbCxjLG14UmVzb3VyY2VzLmdldCgiY2FuY2VsIiksbXhSZXNvdXJjZXMuZ2V0KCJkaXNjYXJkQ2hhbmdlcyIpKTpjKCk7bXhFdmVudC5jb25zdW1lKGIpfX0pKTtpZihhLmlzRWRpdGFibGUoKSl7dmFyIEM9dGhpcy5lZGl0b3IuZ3JhcGgsej1udWxsLEQ9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7dGhpcy5zaG93TGlicmFyeURpYWxvZyhhLmdldFRpdGxlKCkscCwKYyxhLGEuZ2V0TW9kZSgpKTtteEV2ZW50LmNvbnN1bWUoYil9KSxHPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe2Euc2V0TW9kaWZpZWQoITApO2EuaXNBdXRvc2F2ZSgpPyhudWxsIT16JiZudWxsIT16LnBhcmVudE5vZGUmJnoucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh6KSx6PXEuY2xvbmVOb2RlKCExKSx6LnNldEF0dHJpYnV0ZSgic3JjIixFZGl0b3Iuc3BpbkltYWdlKSx6LnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgic2F2aW5nIikpLHouc3R5bGUuY3Vyc29yPSJkZWZhdWx0Iix6LnN0eWxlLm1hcmdpblJpZ2h0PSIycHgiLHouc3R5bGUubWFyZ2luVG9wPSItMnB4IixtLmluc2VydEJlZm9yZSh6LG0uZmlyc3RDaGlsZCksay5zdHlsZS5wYWRkaW5nUmlnaHQ9MTgqbS5jaGlsZE5vZGVzLmxlbmd0aCsicHgiLHRoaXMuc2F2ZUxpYnJhcnkoYS5nZXRUaXRsZSgpLGMsYSxhLmdldE1vZGUoKSwhMCwhMCxmdW5jdGlvbigpe251bGwhPXomJm51bGwhPQp6LnBhcmVudE5vZGUmJih6LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoeiksay5zdHlsZS5wYWRkaW5nUmlnaHQ9MTgqbS5jaGlsZE5vZGVzLmxlbmd0aCsicHgiKX0pKTpudWxsPT1BJiYoQT1xLmNsb25lTm9kZSghMSksQS5zZXRBdHRyaWJ1dGUoInNyYyIsSU1BR0VfUEFUSCsiL2Rvd25sb2FkLnBuZyIpLEEuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJzYXZlIikpLG0uaW5zZXJ0QmVmb3JlKEEsbS5maXJzdENoaWxkKSxteEV2ZW50LmFkZExpc3RlbmVyKEEsImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXt0aGlzLnNhdmVMaWJyYXJ5KGEuZ2V0VGl0bGUoKSxjLGEsYS5nZXRNb2RlKCksYS5jb25zdHJ1Y3Rvcj09TG9jYWxMaWJyYXJ5LCEwLGZ1bmN0aW9uKCl7bnVsbD09QXx8YS5pc01vZGlmaWVkKCl8fChrLnN0eWxlLnBhZGRpbmdSaWdodD0xOCptLmNoaWxkTm9kZXMubGVuZ3RoKyJweCIsQS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKEEpLApBPW51bGwpfSk7bXhFdmVudC5jb25zdW1lKGIpfSkpLGsuc3R5bGUucGFkZGluZ1JpZ2h0PTE4Km0uY2hpbGROb2Rlcy5sZW5ndGgrInB4Iil9KSxGPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYixkLGYpe2E9Qy5jbG9uZUNlbGxzKG14VXRpbHMuc29ydENlbGxzKEMubW9kZWwuZ2V0VG9wbW9zdENlbGxzKGEpKSk7Zm9yKHZhciBnPTA7ZzxhLmxlbmd0aDtnKyspe3ZhciBsPUMuZ2V0Q2VsbEdlb21ldHJ5KGFbZ10pO251bGwhPWwmJmwudHJhbnNsYXRlKC1iLngsLWIueSl9cC5hcHBlbmRDaGlsZCh0aGlzLnNpZGViYXIuY3JlYXRlVmVydGV4VGVtcGxhdGVGcm9tQ2VsbHMoYSxiLndpZHRoLGIuaGVpZ2h0LGZ8fCIiLCEwLCExLCExKSk7YT17eG1sOkdyYXBoLmNvbXByZXNzKG14VXRpbHMuZ2V0WG1sKHRoaXMuZWRpdG9yLmdyYXBoLmVuY29kZUNlbGxzKGEpKSksdzpiLndpZHRoLGg6Yi5oZWlnaHR9O251bGwhPWYmJihhLnRpdGxlPWYpO2MucHVzaChhKTtHKGQpO251bGwhPQplJiZudWxsIT1lLnBhcmVudE5vZGUmJjA8Yy5sZW5ndGgmJihlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSksZT1udWxsKX0pLEg9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7aWYoQy5pc1NlbGVjdGlvbkVtcHR5KCkpQy5nZXRSdWJiZXJiYW5kKCkuaXNBY3RpdmUoKT8oQy5nZXRSdWJiZXJiYW5kKCkuZXhlY3V0ZShhKSxDLmdldFJ1YmJlcmJhbmQoKS5yZXNldCgpKTp0aGlzLnNob3dFcnJvcihteFJlc291cmNlcy5nZXQoImVycm9yIiksbXhSZXNvdXJjZXMuZ2V0KCJub3RoaW5nSXNTZWxlY3RlZCIpLG14UmVzb3VyY2VzLmdldCgib2siKSk7ZWxzZXt2YXIgYj1DLmdldFNlbGVjdGlvbkNlbGxzKCksYz1DLnZpZXcuZ2V0Qm91bmRzKGIpLGU9Qy52aWV3LnNjYWxlO2MueC89ZTtjLnkvPWU7Yy53aWR0aC89ZTtjLmhlaWdodC89ZTtjLngtPUMudmlldy50cmFuc2xhdGUueDtjLnktPUMudmlldy50cmFuc2xhdGUueTtGKGIsYyl9bXhFdmVudC5jb25zdW1lKGEpfSk7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKHAsCmZ1bmN0aW9uKCl7fSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtDLmlzTW91c2VEb3duJiZudWxsIT1DLnBhbm5pbmdNYW5hZ2VyJiZudWxsIT1DLmdyYXBoSGFuZGxlci5maXJzdCYmKEMuZ3JhcGhIYW5kbGVyLnN1c3BlbmQoKSxudWxsIT1DLmdyYXBoSGFuZGxlci5oaW50JiYoQy5ncmFwaEhhbmRsZXIuaGludC5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4iKSxwLnN0eWxlLmJhY2tncm91bmRDb2xvcj0iI2YxZjNmNCIscC5zdHlsZS5jdXJzb3I9ImNvcHkiLEMucGFubmluZ01hbmFnZXIuc3RvcCgpLEMuYXV0b1Njcm9sbD0hMSxteEV2ZW50LmNvbnN1bWUoYSkpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7Qy5pc01vdXNlRG93biYmbnVsbCE9Qy5wYW5uaW5nTWFuYWdlciYmbnVsbCE9Qy5ncmFwaEhhbmRsZXImJihwLnN0eWxlLmJhY2tncm91bmRDb2xvcj0iIixwLnN0eWxlLmN1cnNvcj0iZGVmYXVsdCIsdGhpcy5zaWRlYmFyLnNob3dUb29sdGlwcz0hMCwKQy5wYW5uaW5nTWFuYWdlci5zdG9wKCksQy5ncmFwaEhhbmRsZXIucmVzZXQoKSxDLmlzTW91c2VEb3duPSExLEMuYXV0b1Njcm9sbD0hMCxIKGEpLG14RXZlbnQuY29uc3VtZShhKSl9KSk7bXhFdmVudC5hZGRMaXN0ZW5lcihwLCJtb3VzZWxlYXZlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtDLmlzTW91c2VEb3duJiZudWxsIT1DLmdyYXBoSGFuZGxlci5maXJzdCYmKEMuZ3JhcGhIYW5kbGVyLnJlc3VtZSgpLG51bGwhPUMuZ3JhcGhIYW5kbGVyLmhpbnQmJihDLmdyYXBoSGFuZGxlci5oaW50LnN0eWxlLnZpc2liaWxpdHk9InZpc2libGUiKSxwLnN0eWxlLmJhY2tncm91bmRDb2xvcj0iIixwLnN0eWxlLmN1cnNvcj0iIixDLmF1dG9TY3JvbGw9ITApfSkpO0dyYXBoLmZpbGVTdXBwb3J0JiYobXhFdmVudC5hZGRMaXN0ZW5lcihwLCJkcmFnb3ZlciIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7cC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9IiNmMWYzZjQiO2EuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3Q9CiJjb3B5IjtwLnN0eWxlLmN1cnNvcj0iY29weSI7dGhpcy5zaWRlYmFyLmhpZGVUb29sdGlwKCk7YS5zdG9wUHJvcGFnYXRpb24oKTthLnByZXZlbnREZWZhdWx0KCl9KSksbXhFdmVudC5hZGRMaXN0ZW5lcihwLCJkcm9wIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtwLnN0eWxlLmN1cnNvcj0iIjtwLnN0eWxlLmJhY2tncm91bmRDb2xvcj0iIjswPGEuZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aCYmdGhpcy5pbXBvcnRGaWxlcyhhLmRhdGFUcmFuc2Zlci5maWxlcywwLDAsdGhpcy5tYXhJbWFnZVNpemUsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYixkLGYsbCxuLHQsayxtLHkpe2lmKG51bGwhPWImJiJpbWFnZS8iPT1kLnN1YnN0cmluZygwLDYpKWI9InNoYXBlPWltYWdlO3ZlcnRpY2FsTGFiZWxQb3NpdGlvbj1ib3R0b207dmVydGljYWxBbGlnbj10b3A7aW1hZ2VBc3BlY3Q9MDthc3BlY3Q9Zml4ZWQ7aW1hZ2U9Iit0aGlzLmNvbnZlcnREYXRhVXJpKGIpLGI9W25ldyBteENlbGwoIiIsCm5ldyBteEdlb21ldHJ5KDAsMCxuLHQpLGIpXSxiWzBdLnZlcnRleD0hMCxGKGIsbmV3IG14UmVjdGFuZ2xlKDAsMCxuLHQpLGEsbXhFdmVudC5pc0FsdERvd24oYSk/bnVsbDprLnN1YnN0cmluZygwLGsubGFzdEluZGV4T2YoIi4iKSkucmVwbGFjZSgvXy9nLCIgIikpLG51bGwhPWUmJm51bGwhPWUucGFyZW50Tm9kZSYmMDxjLmxlbmd0aCYmKGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKSxlPW51bGwpO2Vsc2V7dmFyIHY9ITEseD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiLGQpe2lmKG51bGwhPWImJiJhcHBsaWNhdGlvbi9wZGYiPT1kKXt2YXIgZj1FZGl0b3IuZXh0cmFjdEdyYXBoTW9kZWxGcm9tUGRmKGIpO251bGwhPWYmJjA8Zi5sZW5ndGgmJihiPWYpfWlmKG51bGwhPWIpaWYoZj1teFV0aWxzLnBhcnNlWG1sKGIpLCJteGxpYnJhcnkiPT1mLmRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSl0cnl7dmFyIGw9SlNPTi5wYXJzZShteFV0aWxzLmdldFRleHRDb250ZW50KGYuZG9jdW1lbnRFbGVtZW50KSk7CmcobCxwKTtjPWMuY29uY2F0KGwpO0coYSk7dGhpcy5zcGlubmVyLnN0b3AoKTt2PSEwfWNhdGNoKEwpe31lbHNlIGlmKCJteGZpbGUiPT1mLmRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSl0cnl7Zm9yKHZhciBuPWYuZG9jdW1lbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaWFncmFtIiksbD0wO2w8bi5sZW5ndGg7bCsrKXt2YXIgdD10aGlzLnN0cmluZ1RvQ2VsbHMoRWRpdG9yLmdldERpYWdyYW1Ob2RlWG1sKG5bbF0pKSxrPXRoaXMuZWRpdG9yLmdyYXBoLmdldEJvdW5kaW5nQm94RnJvbUdlb21ldHJ5KHQpO0YodCxuZXcgbXhSZWN0YW5nbGUoMCwwLGsud2lkdGgsay5oZWlnaHQpLGEpfXY9ITB9Y2F0Y2goTCl7bnVsbCE9d2luZG93LmNvbnNvbGUmJmNvbnNvbGUubG9nKCJlcnJvciBpbiBkcm9wIGhhbmRsZXI6IixMKX12fHwodGhpcy5zcGlubmVyLnN0b3AoKSx0aGlzLmhhbmRsZUVycm9yKHttZXNzYWdlOm14UmVzb3VyY2VzLmdldCgiZXJyb3JMb2FkaW5nRmlsZSIpfSkpOwpudWxsIT1lJiZudWxsIT1lLnBhcmVudE5vZGUmJjA8Yy5sZW5ndGgmJihlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSksZT1udWxsKX0pO251bGwhPXkmJm51bGwhPWsmJigvKFwudihkeHxzZHg/KSkoJHxcPykvaS50ZXN0KGspfHwvKFwudnMoeHxzeD8pKSgkfFw/KS9pLnRlc3QoaykpP3RoaXMuaW1wb3J0VmlzaW8oeSxmdW5jdGlvbihhKXt4KGEsInRleHQveG1sIil9LG51bGwsayk6IXRoaXMuaXNPZmZsaW5lKCkmJihuZXcgWE1MSHR0cFJlcXVlc3QpLnVwbG9hZCYmdGhpcy5pc1JlbW90ZUZpbGVGb3JtYXQoYixrKSYmbnVsbCE9eT90aGlzLnBhcnNlRmlsZSh5LG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpezQ9PWEucmVhZHlTdGF0ZSYmKHRoaXMuc3Bpbm5lci5zdG9wKCksMjAwPD1hLnN0YXR1cyYmMjk5Pj1hLnN0YXR1cz94KGEucmVzcG9uc2VUZXh0LCJ0ZXh0L3htbCIpOnRoaXMuaGFuZGxlRXJyb3Ioe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KDQxMz09YS5zdGF0dXM/CiJkcmF3aW5nVG9vTGFyZ2UiOiJpbnZhbGlkT3JNaXNzaW5nRmlsZSIpfSxteFJlc291cmNlcy5nZXQoImVycm9yTG9hZGluZ0ZpbGUiKSkpfSkpOngoYixkKX19KSk7YS5zdG9wUHJvcGFnYXRpb24oKTthLnByZXZlbnREZWZhdWx0KCl9KSksbXhFdmVudC5hZGRMaXN0ZW5lcihwLCJkcmFnbGVhdmUiLGZ1bmN0aW9uKGEpe3Auc3R5bGUuY3Vyc29yPSIiO3Auc3R5bGUuYmFja2dyb3VuZENvbG9yPSIiO2Euc3RvcFByb3BhZ2F0aW9uKCk7YS5wcmV2ZW50RGVmYXVsdCgpfSkpO3E9cS5jbG9uZU5vZGUoITEpO3Euc2V0QXR0cmlidXRlKCJzcmMiLEVkaXRvci5lZGl0SW1hZ2UpO3Euc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJlZGl0IikpO20uaW5zZXJ0QmVmb3JlKHEsbS5maXJzdENoaWxkKTtteEV2ZW50LmFkZExpc3RlbmVyKHEsImNsaWNrIixEKTtteEV2ZW50LmFkZExpc3RlbmVyKHAsImRibGNsaWNrIixmdW5jdGlvbihhKXtteEV2ZW50LmdldFNvdXJjZShhKT09CnAmJkQoYSl9KTtmPXEuY2xvbmVOb2RlKCExKTtmLnNldEF0dHJpYnV0ZSgic3JjIixFZGl0b3IucGx1c0ltYWdlKTtmLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgiYWRkIikpO20uaW5zZXJ0QmVmb3JlKGYsbS5maXJzdENoaWxkKTtteEV2ZW50LmFkZExpc3RlbmVyKGYsImNsaWNrIixIKTt0aGlzLmlzT2ZmbGluZSgpfHwiLnNjcmF0Y2hwYWQiIT1hLnRpdGxlfHxudWxsPT1FZGl0b3JVaS5zY3JhdGNocGFkSGVscExpbmt8fChmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNwYW4iKSxmLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgiaGVscCIpKSxmLnN0eWxlLmNzc1RleHQ9ImNvbG9yOiNhM2EzYTM7dGV4dC1kZWNvcmF0aW9uOm5vbmU7bWFyZ2luLXJpZ2h0OjJweDsiLG14VXRpbHMud3JpdGUoZiwiPyIpLG14RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyhmLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMub3BlbkxpbmsoRWRpdG9yVWkuc2NyYXRjaHBhZEhlbHBMaW5rKTsKbXhFdmVudC5jb25zdW1lKGEpfSkpLG0uaW5zZXJ0QmVmb3JlKGYsbS5maXJzdENoaWxkKSl9ay5hcHBlbmRDaGlsZChtKTtrLnN0eWxlLnBhZGRpbmdSaWdodD0xOCptLmNoaWxkTm9kZXMubGVuZ3RoKyJweCJ9fTtFZGl0b3JVaS5wcm90b3R5cGUuYWRkTGlicmFyeUVudHJpZXM9ZnVuY3Rpb24oYSxjKXtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGU9YVtiXSxkPWUuZGF0YTtpZihudWxsIT1kKXt2YXIgZD10aGlzLmNvbnZlcnREYXRhVXJpKGQpLGY9InNoYXBlPWltYWdlO3ZlcnRpY2FsTGFiZWxQb3NpdGlvbj1ib3R0b207dmVydGljYWxBbGlnbj10b3A7aW1hZ2VBc3BlY3Q9MDsiOyJmaXhlZCI9PWUuYXNwZWN0JiYoZis9ImFzcGVjdD1maXhlZDsiKTtjLmFwcGVuZENoaWxkKHRoaXMuc2lkZWJhci5jcmVhdGVWZXJ0ZXhUZW1wbGF0ZShmKyJpbWFnZT0iK2QsZS53LGUuaCwiIixlLnRpdGxlfHwiIiwhMSwhMSwhMCkpfWVsc2UgbnVsbCE9ZS54bWwmJihkPXRoaXMuc3RyaW5nVG9DZWxscyhHcmFwaC5kZWNvbXByZXNzKGUueG1sKSksCjA8ZC5sZW5ndGgmJmMuYXBwZW5kQ2hpbGQodGhpcy5zaWRlYmFyLmNyZWF0ZVZlcnRleFRlbXBsYXRlRnJvbUNlbGxzKGQsZS53LGUuaCxlLnRpdGxlfHwiIiwhMCwhMSwhMCkpKX19O0VkaXRvclVpLnByb3RvdHlwZS5nZXRSZXNvdXJjZT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YT9hW214TGFuZ3VhZ2VdfHxhLm1haW46bnVsbH07RWRpdG9yVWkucHJvdG90eXBlLmZvb3RlckhlaWdodD0wOyIxIj09dXJsUGFyYW1zLnNhdmVzaWRlYmFyJiYoU2lkZWJhci5wcm90b3R5cGUudGh1bWJXaWR0aD02NCxTaWRlYmFyLnByb3RvdHlwZS50aHVtYkhlaWdodD02NCk7RWRpdG9yVWkuaW5pdFRoZW1lPWZ1bmN0aW9uKCl7ImF0bGFzIj09dWlUaGVtZT8obXhDbGllbnQubGluaygic3R5bGVzaGVldCIsU1RZTEVfUEFUSCsiL2F0bGFzLmNzcyIpLCJ1bmRlZmluZWQiIT09dHlwZW9mIFRvb2xiYXImJihUb29sYmFyLnByb3RvdHlwZS51bnNlbGVjdGVkQmFja2dyb3VuZD1teENsaWVudC5JU19RVUlSS1M/CiJub25lIjoibGluZWFyLWdyYWRpZW50KHJnYigyNTUsIDI1NSwgMjU1KSAwcHgsIHJnYigyNDIsIDI0MiwgMjQyKSAxMDAlKSIsVG9vbGJhci5wcm90b3R5cGUuc2VsZWN0ZWRCYWNrZ3JvdW5kPSJyZ2IoMjQyLCAyNDIsIDI0MikiKSxFZGl0b3IucHJvdG90eXBlLmluaXRpYWxUb3BTcGFjaW5nPTMsRWRpdG9yVWkucHJvdG90eXBlLm1lbnViYXJIZWlnaHQ9NDEsRWRpdG9yVWkucHJvdG90eXBlLnRvb2xiYXJIZWlnaHQ9MzgpOiJkYXJrIj09dWlUaGVtZSYmKG14Q2xpZW50LmxpbmsoInN0eWxlc2hlZXQiLFNUWUxFX1BBVEgrIi9kYXJrLmNzcyIpLERpYWxvZy5iYWNrZHJvcENvbG9yPSIjMmEyYTJhIixHcmFwaC5wcm90b3R5cGUuZGVmYXVsdFRoZW1lTmFtZT0iZGFya1RoZW1lIixHcmFwaC5wcm90b3R5cGUuZGVmYXVsdFBhZ2VCYWNrZ3JvdW5kQ29sb3I9IiMyYTJhMmEiLEdyYXBoLnByb3RvdHlwZS5kZWZhdWx0UGFnZUJvcmRlckNvbG9yPSIjNTA1NzU5IixGb3JtYXQucHJvdG90eXBlLmluYWN0aXZlVGFiQmFja2dyb3VuZENvbG9yPQoiYmxhY2siLEJhc2VGb3JtYXRQYW5lbC5wcm90b3R5cGUuYnV0dG9uQmFja2dyb3VuZENvbG9yPSIjMmEyYTJhIixTaWRlYmFyLnByb3RvdHlwZS5kcmFnUHJldmlld0JvcmRlcj0iMXB4IGRhc2hlZCAjY2NjY2NjIixteEdyYXBoSGFuZGxlci5wcm90b3R5cGUucHJldmlld0NvbG9yPSIjY2NjY2NjIixTdHlsZUZvcm1hdFBhbmVsLnByb3RvdHlwZS5kZWZhdWx0U3Ryb2tlQ29sb3I9IiNjY2NjY2MiLG14Q29uc3RhbnRzLkRST1BfVEFSR0VUX0NPTE9SPSIjMDBmZjAwIixteENsaWVudC5JU19TVkcmJihFZGl0b3IuaGVscEltYWdlPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFDQU1BQUFBb0xROVRBQUFBUDFCTVZFVUFBQUQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vOUR1L3BxQUFBQUZYUlNUbE1BVDMwcUNKUkJib3lEWnlDZ1J6VVVkRjQ2TUpsZ1hFVGdBQUFBZWtsRVFWUVkwMjJPMnc0RElRaEVRVVVSZGEvOS8yOHRVTzIrN0NRUzVzZ1E0RjFSYXBYNzhZVXdScVFqVFU4SUxxUWZLZXJUS1R2QUNKNG5MWDNrcnQrOGFTODJvSThhUUM0S2F2Umd0dkVXL21EdnNJQ2dBMDNQU0dScjc5TXFYMVlQTkl4emp5cXR3OFpublJvNHQ1YTV1bmR0SllSeXdhdStkczRDeXphM0U2WUFBQUFBU1VWT1JLNUNZSUk9IiwKRWRpdG9yLmNoZWNrbWFya0ltYWdlPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJVQUFBQVZDQU1BQUFDZXlWV2tBQUFBUlZCTVZFVUFBQUNabVprSUNBZ0VCQVNOalkyRGc0TVlHQmlUazVONWVYbDFkWFZtWm1aUVVGQkNRa0kzTnpjZUhoNE1EQXlrcEtTSmlZbCtmbjVzYkd4YVdsby9QejhTRWhLOTZ1UGxBQUFBQVhSU1RsTUFRT2JZWmdBQUFFNUpSRUZVR05QRnpUY1NnREFRUTFISkdVZnkvWTlLN1YxcWVPVWZ6UWlmQ1FaYWkxWEhhejExTEZ5c2JEYnpnRFNTV01aaUVUejMrYjh5TlVjL01Nc2t0eHVDOFhRQlNuY2RMd3orOGdDQ2dnR1h6QmNvekFBQUFBQkpSVTVFcmtKZ2dnPT0iKSl9O0VkaXRvclVpLmluaXRUaGVtZSgpO0VkaXRvclVpLnByb3RvdHlwZS5zaG93SW1hZ2VEaWFsb2c9ZnVuY3Rpb24oYSxjLGQsZixsKXthPW5ldyBJbWFnZURpYWxvZyh0aGlzLGEsYyxkLGYsbCk7dGhpcy5zaG93RGlhbG9nKGEuY29udGFpbmVyLEdyYXBoLmZpbGVTdXBwb3J0Pwo0ODA6MzYwLEdyYXBoLmZpbGVTdXBwb3J0PzIwMDo5MCwhMCwhMCk7YS5pbml0KCl9O0VkaXRvclVpLnByb3RvdHlwZS5zaG93QmFja2dyb3VuZEltYWdlRGlhbG9nPWZ1bmN0aW9uKGEsYyl7YT1udWxsIT1hP2E6bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiKXtpZighYil7dmFyIGM9bmV3IENoYW5nZVBhZ2VTZXR1cCh0aGlzLG51bGwsYSk7Yy5pZ25vcmVDb2xvcj0hMDt0aGlzLmVkaXRvci5ncmFwaC5tb2RlbC5leGVjdXRlKGMpfX0pO3ZhciBiPW5ldyBCYWNrZ3JvdW5kSW1hZ2VEaWFsb2codGhpcyxhLGMpO3RoaXMuc2hvd0RpYWxvZyhiLmNvbnRhaW5lciwzNjAsMjAwLCEwLCEwKTtiLmluaXQoKX07RWRpdG9yVWkucHJvdG90eXBlLnNob3dMaWJyYXJ5RGlhbG9nPWZ1bmN0aW9uKGEsYyxkLGYsbCl7YT1uZXcgTGlicmFyeURpYWxvZyh0aGlzLGEsYyxkLGYsbCk7dGhpcy5zaG93RGlhbG9nKGEuY29udGFpbmVyLDY0MCw0NDAsITAsITEsbXhVdGlscy5iaW5kKHRoaXMsCmZ1bmN0aW9uKGEpe2EmJm51bGw9PXRoaXMuZ2V0Q3VycmVudEZpbGUoKSYmIjEiIT11cmxQYXJhbXMuZW1iZWQmJnRoaXMuc2hvd1NwbGFzaCgpfSkpO2EuaW5pdCgpfTt2YXIgYz1FZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlRm9ybWF0O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVGb3JtYXQ9ZnVuY3Rpb24oYSl7dmFyIGI9Yy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy5lZGl0b3IuZ3JhcGguYWRkTGlzdGVuZXIoInZpZXdTdGF0ZUNoYW5nZWQiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuZWRpdG9yLmdyYXBoLmlzU2VsZWN0aW9uRW1wdHkoKSYmYi5yZWZyZXNoKCl9KSk7cmV0dXJuIGJ9O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVTaWRlYmFyRm9vdGVyQ29udGFpbmVyPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jcmVhdGVEaXYoImdlU2lkZWJhckNvbnRhaW5lciBnZVNpZGViYXJGb290ZXIiKTthLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7YS5zdHlsZS5vdmVyZmxvdz0KImhpZGRlbiI7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYSIpO2MuY2xhc3NOYW1lPSJnZVRpdGxlIjtjLnN0eWxlLmNvbG9yPSIjREY2QzBDIjtjLnN0eWxlLmZvbnRXZWlnaHQ9ImJvbGQiO2Muc3R5bGUuaGVpZ2h0PSIxMDAlIjtjLnN0eWxlLnBhZGRpbmdUb3A9IjlweCI7Yy5pbm5lckhUTUw9JzxzcGFuIHN0eWxlPSJmb250LXNpemU6MThweDttYXJnaW4tcmlnaHQ6NXB4OyI+Kzwvc3Bhbj4nO214VXRpbHMud3JpdGUoYyxteFJlc291cmNlcy5nZXQoIm1vcmVTaGFwZXMiKSsiLi4uIik7bXhFdmVudC5hZGRMaXN0ZW5lcihjLG14Q2xpZW50LklTX1BPSU5URVI/InBvaW50ZXJkb3duIjoibW91c2Vkb3duIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXthLnByZXZlbnREZWZhdWx0KCl9KSk7bXhFdmVudC5hZGRMaXN0ZW5lcihjLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5hY3Rpb25zLmdldCgic2hhcGVzIikuZnVuY3QoKTtteEV2ZW50LmNvbnN1bWUoYSl9KSk7CmEuYXBwZW5kQ2hpbGQoYyk7cmV0dXJuIGF9O0VkaXRvclVpLnByb3RvdHlwZS5oYW5kbGVFcnJvcj1mdW5jdGlvbihhLGMsZCxmLGwsbixrKXt2YXIgYj1udWxsIT10aGlzLnNwaW5uZXImJm51bGwhPXRoaXMuc3Bpbm5lci5wYXVzZT90aGlzLnNwaW5uZXIucGF1c2UoKTpmdW5jdGlvbigpe30sZT1udWxsIT1hJiZudWxsIT1hLmVycm9yP2EuZXJyb3I6YTtpZihudWxsIT1hJiZudWxsIT1hLnN0YWNrJiZudWxsIT1hLm1lc3NhZ2UpdHJ5e2s/bnVsbCE9d2luZG93LmNvbnNvbGUmJmNvbnNvbGUuZXJyb3IoIkVkaXRvclVpLmhhbmRsZUVycm9yOiIsYSk6RWRpdG9yVWkubG9nRXJyb3IoIkNhdWdodDogIisobnVsbCE9YS5tZXNzYWdlP2EubWVzc2FnZToibnVsbCIpLG51bGwsbnVsbCxudWxsLGEsIklORk8iKX1jYXRjaCh6KXt9aWYobnVsbCE9ZXx8bnVsbCE9Yyl7az1teFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQoInVua25vd25FcnJvciIpKTt2YXIgZz1teFJlc291cmNlcy5nZXQoIm9rIiksCnA9bnVsbDtjPW51bGwhPWM/YzpteFJlc291cmNlcy5nZXQoImVycm9yIik7aWYobnVsbCE9ZSl7bnVsbCE9ZS5yZXRyeSYmKGc9bXhSZXNvdXJjZXMuZ2V0KCJjYW5jZWwiKSxwPWZ1bmN0aW9uKCl7YigpO2UucmV0cnkoKX0pO2lmKDQwND09ZS5jb2RlfHw0MDQ9PWUuc3RhdHVzfHw0MDM9PWUuY29kZSl7az00MDM9PWUuY29kZT9udWxsIT1lLm1lc3NhZ2U/bXhVdGlscy5odG1sRW50aXRpZXMoZS5tZXNzYWdlKTpteFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQoImFjY2Vzc0RlbmllZCIpKTpudWxsIT1sP2w6bXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KCJmaWxlTm90Rm91bmRPckRlbmllZCIpKyhudWxsIT10aGlzLmRyaXZlJiZudWxsIT10aGlzLmRyaXZlLnVzZXI/IiAoIit0aGlzLmRyaXZlLnVzZXIuZGlzcGxheU5hbWUrIiwgIit0aGlzLmRyaXZlLnVzZXIuZW1haWwrIikiOiIiKSk7dmFyIG09bnVsbCE9bj9uOndpbmRvdy5sb2NhdGlvbi5oYXNoOwppZihudWxsIT1tJiYoIiNHIj09bS5zdWJzdHJpbmcoMCwyKXx8IiNVaHR0cHMlM0ElMkYlMkZkcml2ZS5nb29nbGUuY29tJTJGdWMlM0ZpZCUzRCI9PW0uc3Vic3RyaW5nKDAsNDUpKSYmKG51bGwhPWEmJm51bGwhPWEuZXJyb3ImJihudWxsIT1hLmVycm9yLmVycm9ycyYmMDxhLmVycm9yLmVycm9ycy5sZW5ndGgmJiJmaWxlQWNjZXNzIj09YS5lcnJvci5lcnJvcnNbMF0ucmVhc29ufHxudWxsIT1hLmVycm9yLmRhdGEmJjA8YS5lcnJvci5kYXRhLmxlbmd0aCYmImZpbGVBY2Nlc3MiPT1hLmVycm9yLmRhdGFbMF0ucmVhc29uKXx8NDA0PT1lLmNvZGV8fDQwND09ZS5zdGF0dXMpKXttPSIjVSI9PW0uc3Vic3RyaW5nKDAsMik/bS5zdWJzdHJpbmcoNDUsbS5sYXN0SW5kZXhPZigiJTI2ZXgiKSk6bS5zdWJzdHJpbmcoMik7dGhpcy5zaG93RXJyb3IoYyxrLG14UmVzb3VyY2VzLmdldCgib3BlbkluTmV3V2luZG93IiksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmVkaXRvci5ncmFwaC5vcGVuTGluaygiaHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL29wZW4/aWQ9IisKbSk7dGhpcy5oYW5kbGVFcnJvcihhLGMsZCxmLGwpfSkscCxteFJlc291cmNlcy5nZXQoImNoYW5nZVVzZXIiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXtkLmlubmVySFRNTD0iIjtmb3IodmFyIGE9MDthPGIubGVuZ3RoO2ErKyl7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgib3B0aW9uIik7bXhVdGlscy53cml0ZShjLGJbYV0uZGlzcGxheU5hbWUpO2MudmFsdWU9YTtkLmFwcGVuZENoaWxkKGMpO2M9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgib3B0aW9uIik7Yy5pbm5lckhUTUw9IiZuYnNwOyZuYnNwOyZuYnNwOyI7bXhVdGlscy53cml0ZShjLCI8IitiW2FdLmVtYWlsKyI+Iik7Yy5zZXRBdHRyaWJ1dGUoImRpc2FibGVkIiwiZGlzYWJsZWQiKTtkLmFwcGVuZENoaWxkKGMpfWM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgib3B0aW9uIik7bXhVdGlscy53cml0ZShjLG14UmVzb3VyY2VzLmdldCgiYWRkQWNjb3VudCIpKTtjLnZhbHVlPWIubGVuZ3RoOwpkLmFwcGVuZENoaWxkKGMpfXZhciBiPXRoaXMuZHJpdmUuZ2V0VXNlcnNMaXN0KCksYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNwYW4iKTtlLnN0eWxlLm1hcmdpblRvcD0iNnB4IjtteFV0aWxzLndyaXRlKGUsbXhSZXNvdXJjZXMuZ2V0KCJjaGFuZ2VVc2VyIikrIjogIik7Yy5hcHBlbmRDaGlsZChlKTt2YXIgZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzZWxlY3QiKTtkLnN0eWxlLndpZHRoPSIyMDBweCI7YSgpO214RXZlbnQuYWRkTGlzdGVuZXIoZCwiY2hhbmdlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3ZhciBjPWQudmFsdWUsZT1iLmxlbmd0aCE9YztlJiZ0aGlzLmRyaXZlLnNldFVzZXIoYltjXSk7dGhpcy5kcml2ZS5hdXRob3JpemUoZSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2V8fChiPXRoaXMuZHJpdmUuZ2V0VXNlcnNMaXN0KCksYSgpKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuaGFuZGxlRXJyb3IoYSl9KSwKITApfSkpO2MuYXBwZW5kQ2hpbGQoZCk7Yz1uZXcgQ3VzdG9tRGlhbG9nKHRoaXMsYyxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMubG9hZEZpbGUod2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyKDEpLCEwKX0pKTt0aGlzLnNob3dEaWFsb2coYy5jb250YWluZXIsMzAwLDc1LCEwLCEwKX0pLG14UmVzb3VyY2VzLmdldCgiY2FuY2VsIiksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmhpZGVEaWFsb2coKTtudWxsIT1kJiZkKCl9KSw0ODAsMTUwKTtyZXR1cm59fW51bGwhPWUubWVzc2FnZT9rPW14VXRpbHMuaHRtbEVudGl0aWVzKGUubWVzc2FnZSk6bnVsbCE9ZS5yZXNwb25zZSYmbnVsbCE9ZS5yZXNwb25zZS5lcnJvcj9rPW14VXRpbHMuaHRtbEVudGl0aWVzKGUucmVzcG9uc2UuZXJyb3IpOiJ1bmRlZmluZWQiIT09dHlwZW9mIHdpbmRvdy5BcHAmJihlLmNvZGU9PUFwcC5FUlJPUl9USU1FT1VUP2s9bXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KCJ0aW1lb3V0IikpOgplLmNvZGU9PUFwcC5FUlJPUl9CVVNZJiYoaz1teFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQoImJ1c3kiKSkpKX12YXIgdj1uPW51bGw7bnVsbCE9ZSYmbnVsbCE9ZS5oZWxwTGluayYmKG49bXhSZXNvdXJjZXMuZ2V0KCJoZWxwIiksdj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkaXRvci5ncmFwaC5vcGVuTGluayhlLmhlbHBMaW5rKX0pKTt0aGlzLnNob3dFcnJvcihjLGssZyxkLHAsbnVsbCxudWxsLG4sdixudWxsLG51bGwsbnVsbCxmP2Q6bnVsbCl9ZWxzZSBudWxsIT1kJiZkKCl9O0VkaXRvclVpLnByb3RvdHlwZS5hbGVydD1mdW5jdGlvbihhLGMpe3ZhciBiPW5ldyBFcnJvckRpYWxvZyh0aGlzLG51bGwsYSxteFJlc291cmNlcy5nZXQoIm9rIiksYyk7dGhpcy5zaG93RGlhbG9nKGIuY29udGFpbmVyLDM0MCwxMDAsITAsITEpO2IuaW5pdCgpfTtFZGl0b3JVaS5wcm90b3R5cGUuY29uZmlybT1mdW5jdGlvbihhLGMsZCxmLGwsCm4pe3ZhciBiPW51bGwhPXRoaXMuc3Bpbm5lciYmbnVsbCE9dGhpcy5zcGlubmVyLnBhdXNlP3RoaXMuc3Bpbm5lci5wYXVzZSgpOmZ1bmN0aW9uKCl7fSxlPU1hdGgubWluKDIwMCwyOCpNYXRoLmNlaWwoYS5sZW5ndGgvNTApKTthPW5ldyBDb25maXJtRGlhbG9nKHRoaXMsYSxmdW5jdGlvbigpe2IoKTtudWxsIT1jJiZjKCl9LGZ1bmN0aW9uKCl7YigpO251bGwhPWQmJmQoKX0sZixsLG51bGwsbnVsbCxudWxsLG51bGwsZSk7dGhpcy5zaG93RGlhbG9nKGEuY29udGFpbmVyLDM0MCw0NitlLCEwLG4pO2EuaW5pdCgpfTtFZGl0b3JVaS5wcm90b3R5cGUuc2hvd0Jhbm5lcj1mdW5jdGlvbihhLGMsZCl7dmFyIGI9ITE7aWYoISh0aGlzLmJhbm5lclNob3dpbmd8fHRoaXNbImhpZGVCYW5uZXIiK2FdfHxpc0xvY2FsU3RvcmFnZSYmbnVsbCE9bXhTZXR0aW5ncy5zZXR0aW5ncyYmbnVsbCE9bXhTZXR0aW5ncy5zZXR0aW5nc1siY2xvc2UiK2FdKSl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7CmUuc3R5bGUuY3NzVGV4dD0icG9zaXRpb246YWJzb2x1dGU7Ym90dG9tOjEwcHg7bGVmdDo1MCU7bWF4LXdpZHRoOjkwJTtwYWRkaW5nOjE4cHggMzRweCAxMnB4IDIwcHg7Zm9udC1zaXplOjE2cHg7Zm9udC13ZWlnaHQ6Ym9sZDt3aGl0ZS1zcGFjZTpub3dyYXA7Y3Vyc29yOnBvaW50ZXI7ei1pbmRleDoiK214UG9wdXBNZW51LnByb3RvdHlwZS56SW5kZXgrIjsiO214VXRpbHMuc2V0UHJlZml4ZWRTdHlsZShlLnN0eWxlLCJib3gtc2hhZG93IiwiMXB4IDFweCAycHggMHB4ICNkZGQiKTtteFV0aWxzLnNldFByZWZpeGVkU3R5bGUoZS5zdHlsZSwidHJhbnNmb3JtIiwidHJhbnNsYXRlKC01MCUsMTIwJSkiKTtteFV0aWxzLnNldFByZWZpeGVkU3R5bGUoZS5zdHlsZSwidHJhbnNpdGlvbiIsImFsbCAxcyBlYXNlIik7ZS5jbGFzc05hbWU9ImdlQnRuIGdlUHJpbWFyeUJ0biI7Yj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTtiLnNldEF0dHJpYnV0ZSgic3JjIixJTUFHRV9QQVRIKwoiL2xvZ28ucG5nIik7Yi5zZXRBdHRyaWJ1dGUoImJvcmRlciIsIjAiKTtiLnNldEF0dHJpYnV0ZSgiYWxpZ24iLCJhYnNtaWRkbGUiKTtiLnN0eWxlLmNzc1RleHQ9Im1hcmdpbi10b3A6LTRweDttYXJnaW4tbGVmdDo4cHg7bWFyZ2luLXJpZ2h0OjEycHg7d2lkdGg6MjZweDtoZWlnaHQ6MjZweDsiO2UuYXBwZW5kQ2hpbGQoYik7Yj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTtiLnNldEF0dHJpYnV0ZSgic3JjIixEaWFsb2cucHJvdG90eXBlLmNsb3NlSW1hZ2UpO2Iuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJjbG9zZSIpKTtiLnNldEF0dHJpYnV0ZSgiYm9yZGVyIiwiMCIpO2Iuc3R5bGUuY3NzVGV4dD0icG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MTBweDt0b3A6MTJweDtmaWx0ZXI6aW52ZXJ0KDEpO3BhZGRpbmc6NnB4O21hcmdpbjotNnB4O2N1cnNvcjpkZWZhdWx0OyI7ZS5hcHBlbmRDaGlsZChiKTtteFV0aWxzLndyaXRlKGUsYyk7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlKTsKdGhpcy5iYW5uZXJTaG93aW5nPSEwO3ZhciBmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Yuc3R5bGUuY3NzVGV4dD0iZm9udC1zaXplOjExcHg7dGV4dC1hbGlnbjpjZW50ZXI7Zm9udC13ZWlnaHQ6bm9ybWFsOyI7dmFyIGc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTtnLnNldEF0dHJpYnV0ZSgidHlwZSIsImNoZWNrYm94Iik7Zy5zZXRBdHRyaWJ1dGUoImlkIiwiZ2VEb05vdFNob3dBZ2FpbkNoZWNrYm94Iik7Zy5zdHlsZS5tYXJnaW5SaWdodD0iNnB4IjtmLmFwcGVuZENoaWxkKGcpO2M9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgibGFiZWwiKTtjLnNldEF0dHJpYnV0ZSgiZm9yIiwiZ2VEb05vdFNob3dBZ2FpbkNoZWNrYm94Iik7bXhVdGlscy53cml0ZShjLG14UmVzb3VyY2VzLmdldCgiZG9Ob3RTaG93QWdhaW4iKSk7Zi5hcHBlbmRDaGlsZChjKTtlLnN0eWxlLnBhZGRpbmdCb3R0b209IjMwcHgiO2UuYXBwZW5kQ2hpbGQoZik7dmFyIGs9bXhVdGlscy5iaW5kKHRoaXMsCmZ1bmN0aW9uKCl7bnVsbCE9ZS5wYXJlbnROb2RlJiYoZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpLHRoaXMuYmFubmVyU2hvd2luZz0hMSxnLmNoZWNrZWQmJih0aGlzWyJoaWRlQmFubmVyIithXT0hMCxpc0xvY2FsU3RvcmFnZSYmbnVsbCE9bXhTZXR0aW5ncy5zZXR0aW5ncyYmKG14U2V0dGluZ3Muc2V0dGluZ3NbImNsb3NlIithXT1EYXRlLm5vdygpLG14U2V0dGluZ3Muc2F2ZSgpKSkpfSk7bXhFdmVudC5hZGRMaXN0ZW5lcihiLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bXhFdmVudC5jb25zdW1lKGEpO2soKX0pKTt2YXIgbT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe214VXRpbHMuc2V0UHJlZml4ZWRTdHlsZShlLnN0eWxlLCJ0cmFuc2Zvcm0iLCJ0cmFuc2xhdGUoLTUwJSwxMjAlKSIpO3dpbmRvdy5zZXRUaW1lb3V0KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7aygpfSksMUUzKX0pO214RXZlbnQuYWRkTGlzdGVuZXIoZSwiY2xpY2siLApteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt2YXIgYj1teEV2ZW50LmdldFNvdXJjZShhKTtiIT1nJiZiIT1jPyhkKCksaygpLG14RXZlbnQuY29uc3VtZShhKSk6bSgpfSkpO3dpbmRvdy5zZXRUaW1lb3V0KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGUuc3R5bGUsInRyYW5zZm9ybSIsInRyYW5zbGF0ZSgtNTAlLDAlKSIpfSksNTAwKTt3aW5kb3cuc2V0VGltZW91dChtLDNFNCk7Yj0hMH1yZXR1cm4gYn07RWRpdG9yVWkucHJvdG90eXBlLnNldEN1cnJlbnRGaWxlPWZ1bmN0aW9uKGEpe251bGwhPWEmJihhLm9wZW5lZD1uZXcgRGF0ZSk7dGhpcy5jdXJyZW50RmlsZT1hfTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0Q3VycmVudEZpbGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdXJyZW50RmlsZX07RWRpdG9yVWkucHJvdG90eXBlLmlzRXhwb3J0VG9DYW52YXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGl0b3IuaXNFeHBvcnRUb0NhbnZhcygpfTsKRWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZUltYWdlRGF0YVVyaT1mdW5jdGlvbihhLGMsZCxmKXt2YXIgYj1hLnRvRGF0YVVSTCgiaW1hZ2UvIitkKTtpZig2Pj1iLmxlbmd0aHx8Yj09YS5jbG9uZU5vZGUoITEpLnRvRGF0YVVSTCgiaW1hZ2UvIitkKSl0aHJvd3ttZXNzYWdlOiJJbnZhbGlkIGltYWdlIn07bnVsbCE9YyYmKGI9RWRpdG9yLndyaXRlR3JhcGhNb2RlbFRvUG5nKGIsInRFWHQiLCJteGZpbGUiLGVuY29kZVVSSUNvbXBvbmVudChjKSkpOzA8ZiYmKGI9RWRpdG9yLndyaXRlR3JhcGhNb2RlbFRvUG5nKGIsInBIWXMiLCJkcGkiLGYpKTtyZXR1cm4gYn07RWRpdG9yVWkucHJvdG90eXBlLnNhdmVDYW52YXM9ZnVuY3Rpb24oYSxjLGQsZixsKXt2YXIgYj0ianBlZyI9PWQ/ImpwZyI6ZDtmPXRoaXMuZ2V0QmFzZUZpbGVuYW1lKGYpKyIuIitiO2E9dGhpcy5jcmVhdGVJbWFnZURhdGFVcmkoYSxjLGQsbCk7dGhpcy5zYXZlRGF0YShmLGIsYS5zdWJzdHJpbmcoYS5sYXN0SW5kZXhPZigiLCIpKwoxKSwiaW1hZ2UvIitkLCEwKX07RWRpdG9yVWkucHJvdG90eXBlLmlzTG9jYWxGaWxlU2F2ZT1mdW5jdGlvbigpe3JldHVybiJyZW1vdGUiIT11cmxQYXJhbXMuc2F2ZSYmKG14Q2xpZW50LklTX0lFfHwidW5kZWZpbmVkIiE9PXR5cGVvZiB3aW5kb3cuQmxvYiYmInVuZGVmaW5lZCIhPT10eXBlb2Ygd2luZG93LlVSTCkmJjkhPWRvY3VtZW50LmRvY3VtZW50TW9kZSYmOCE9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlJiY3IT1kb2N1bWVudC5kb2N1bWVudE1vZGUmJiFteENsaWVudC5JU19RVUlSS1N8fHRoaXMuaXNPZmZsaW5lQXBwKCl8fG14Q2xpZW50LklTX0lPU307RWRpdG9yVWkucHJvdG90eXBlLnNob3dUZXh0RGlhbG9nPWZ1bmN0aW9uKGEsYyl7dmFyIGI9bmV3IFRleHRhcmVhRGlhbG9nKHRoaXMsYSxjLG51bGwsbnVsbCxteFJlc291cmNlcy5nZXQoImNsb3NlIikpO2IudGV4dGFyZWEuc3R5bGUud2lkdGg9IjYwMHB4IjtiLnRleHRhcmVhLnN0eWxlLmhlaWdodD0iMzgwcHgiO3RoaXMuc2hvd0RpYWxvZyhiLmNvbnRhaW5lciwKNjIwLDQ2MCwhMCwhMCxudWxsLG51bGwsbnVsbCxudWxsLCEwKTtiLmluaXQoKTtkb2N1bWVudC5leGVjQ29tbWFuZCgic2VsZWN0YWxsIiwhMSxudWxsKX07RWRpdG9yVWkucHJvdG90eXBlLmRvU2F2ZUxvY2FsRmlsZT1mdW5jdGlvbihhLGMsZCxmLGwpeyJ0ZXh0L3htbCIhPWR8fC8oXC5kcmF3aW8pJC9pLnRlc3QoYyl8fC8oXC54bWwpJC9pLnRlc3QoYyl8fChjKz0iLmRyYXdpbyIpO2lmKHdpbmRvdy5CbG9iJiZuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYilhPWY/dGhpcy5iYXNlNjRUb0Jsb2IoYSxkKTpuZXcgQmxvYihbYV0se3R5cGU6ZH0pLG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKGEsYyk7ZWxzZSBpZihteENsaWVudC5JU19JRSlkPXdpbmRvdy5vcGVuKCJhYm91dDpibGFuayIsIl9ibGFuayIpLG51bGw9PWQ/bXhVdGlscy5wb3B1cChhLCEwKTooZC5kb2N1bWVudC53cml0ZShhKSxkLmRvY3VtZW50LmNsb3NlKCksZC5kb2N1bWVudC5leGVjQ29tbWFuZCgiU2F2ZUFzIiwKITAsYyksZC5jbG9zZSgpKTtlbHNlIGlmKG14Q2xpZW50LklTX0lPUyYmdGhpcy5pc09mZmxpbmUoKSluYXZpZ2F0b3Iuc3RhbmRhbG9uZXx8bnVsbD09ZHx8ImltYWdlLyIhPWQuc3Vic3RyaW5nKDAsNik/dGhpcy5zaG93VGV4dERpYWxvZyhjKyI6IixhKTp0aGlzLm9wZW5Jbk5ld1dpbmRvdyhhLGQsZik7ZWxzZXt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJhIiksZT0obnVsbD09bmF2aWdhdG9yLnVzZXJBZ2VudHx8MD5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIlBhbGVNb29uLyIpKSYmInVuZGVmaW5lZCIhPT10eXBlb2YgYi5kb3dubG9hZDtpZihteENsaWVudC5JU19HQyYmbnVsbCE9bmF2aWdhdG9yLnVzZXJBZ2VudCl2YXIgZz1uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9DaHJvbShlfGl1bSlcLyhbMC05XSspXC4vKSxlPTY1PT0oZz9wYXJzZUludChnWzJdLDEwKTohMSk/ITE6ZTtpZihlfHx0aGlzLmlzT2ZmbGluZSgpKXtiLmhyZWY9VVJMLmNyZWF0ZU9iamVjdFVSTChmPwp0aGlzLmJhc2U2NFRvQmxvYihhLGQpOm5ldyBCbG9iKFthXSx7dHlwZTpkfSkpO2U/Yi5kb3dubG9hZD1jOmIuc2V0QXR0cmlidXRlKCJ0YXJnZXQiLCJfYmxhbmsiKTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGIpO3RyeXt3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe1VSTC5yZXZva2VPYmplY3RVUkwoYi5ocmVmKX0sMkU0KSxiLmNsaWNrKCksYi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpfWNhdGNoKHkpe319ZWxzZSB0aGlzLmNyZWF0ZUVjaG9SZXF1ZXN0KGEsYyxkLGYsbCkuc2ltdWxhdGUoZG9jdW1lbnQsIl9ibGFuayIpfX07RWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZUVjaG9SZXF1ZXN0PWZ1bmN0aW9uKGEsYyxkLGYsbCxuKXthPSJ4bWw9IitlbmNvZGVVUklDb21wb25lbnQoYSk7cmV0dXJuIG5ldyBteFhtbFJlcXVlc3QoU0FWRV9VUkwsYSsobnVsbCE9ZD8iJm1pbWU9IitkOiIiKSsobnVsbCE9bD8iJmZvcm1hdD0iK2w6IiIpKyhudWxsIT1uPyImYmFzZTY0PSIrCm46IiIpKyhudWxsIT1jPyImZmlsZW5hbWU9IitlbmNvZGVVUklDb21wb25lbnQoYyk6IiIpKyhmPyImYmluYXJ5PTEiOiIiKSl9O0VkaXRvclVpLnByb3RvdHlwZS5iYXNlNjRUb0Jsb2I9ZnVuY3Rpb24oYSxjKXtjPWN8fCIiO2Zvcih2YXIgYj1hdG9iKGEpLGU9Yi5sZW5ndGgsZD1NYXRoLmNlaWwoZS8xMDI0KSxmPUFycmF5KGQpLGs9MDtrPGQ7KytrKXtmb3IodmFyIHQ9MTAyNCprLG09TWF0aC5taW4odCsxMDI0LGUpLHg9QXJyYXkobS10KSxxPTA7dDxtOysrcSwrK3QpeFtxXT1iW3RdLmNoYXJDb2RlQXQoMCk7ZltrXT1uZXcgVWludDhBcnJheSh4KX1yZXR1cm4gbmV3IEJsb2IoZix7dHlwZTpjfSl9O0VkaXRvclVpLnByb3RvdHlwZS5zYXZlTG9jYWxGaWxlPWZ1bmN0aW9uKGEsYyxkLGYsbCxuLGspe249bnVsbCE9bj9uOiExO2s9bnVsbCE9az9rOiJ2c2R4IiE9bCYmKCFteENsaWVudC5JU19JT1N8fCFuYXZpZ2F0b3Iuc3RhbmRhbG9uZSk7bD10aGlzLmdldFNlcnZpY2VDb3VudChuKTsKaXNMb2NhbFN0b3JhZ2UmJmwrKzt2YXIgYj00Pj1sPzI6NjxsPzQ6MztjPW5ldyBDcmVhdGVEaWFsb2codGhpcyxjLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIsYyl7dHJ5e2lmKCJfYmxhbmsiPT1jKWlmKG51bGwhPWQmJiJpbWFnZS8iPT1kLnN1YnN0cmluZygwLDYpKXRoaXMub3BlbkluTmV3V2luZG93KGEsZCxmKTtlbHNle3ZhciBlPXdpbmRvdy5vcGVuKCJhYm91dDpibGFuayIpO251bGw9PWU/bXhVdGlscy5wb3B1cChhLCEwKTooZS5kb2N1bWVudC53cml0ZSgiPHByZT4iK214VXRpbHMuaHRtbEVudGl0aWVzKGEsITEpKyI8L3ByZT4iKSxlLmRvY3VtZW50LmNsb3NlKCkpfWVsc2UgYz09QXBwLk1PREVfREVWSUNFfHwiZG93bmxvYWQiPT1jP3RoaXMuZG9TYXZlTG9jYWxGaWxlKGEsYixkLGYpOm51bGwhPWImJjA8Yi5sZW5ndGgmJnRoaXMucGlja0ZvbGRlcihjLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGUpe3RyeXt0aGlzLmV4cG9ydEZpbGUoYSxiLGQsZixjLAplKX1jYXRjaChDKXt0aGlzLmhhbmRsZUVycm9yKEMpfX0pKX1jYXRjaChBKXt0aGlzLmhhbmRsZUVycm9yKEEpfX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5oaWRlRGlhbG9nKCl9KSxteFJlc291cmNlcy5nZXQoInNhdmVBcyIpLG14UmVzb3VyY2VzLmdldCgiZG93bmxvYWQiKSwhMSxuLGssbnVsbCwxPGwsYixhLGQsZik7bj10aGlzLmlzU2VydmljZXMobCk/bD5iPzM5MDoyNzA6MTYwO3RoaXMuc2hvd0RpYWxvZyhjLmNvbnRhaW5lciw0MDAsbiwhMCwhMCk7Yy5pbml0KCl9O0VkaXRvclVpLnByb3RvdHlwZS5vcGVuSW5OZXdXaW5kb3c9ZnVuY3Rpb24oYSxjLGQpe3ZhciBiPXdpbmRvdy5vcGVuKCJhYm91dDpibGFuayIpO251bGw9PWJ8fG51bGw9PWIuZG9jdW1lbnQ/bXhVdGlscy5wb3B1cChhLCEwKTooImltYWdlL3N2Zyt4bWwiIT1jfHxteENsaWVudC5JU19TVkc/ImltYWdlL3N2Zyt4bWwiPT1jP2IuZG9jdW1lbnQud3JpdGUoIjxodG1sPiIrYSsiPC9odG1sPiIpOgooYT1kP2E6YnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYSkpKSxiLmRvY3VtZW50LndyaXRlKCc8aHRtbD48aW1nIHN0eWxlPSJtYXgtd2lkdGg6MTAwJTsiIHNyYz0iZGF0YTonK2MrIjtiYXNlNjQsIithKyciLz48L2h0bWw+JykpOmIuZG9jdW1lbnQud3JpdGUoIjxodG1sPjxwcmU+IitteFV0aWxzLmh0bWxFbnRpdGllcyhhLCExKSsiPC9wcmU+PC9odG1sPiIpLGIuZG9jdW1lbnQuY2xvc2UoKSl9O3ZhciBmPUVkaXRvclVpLnByb3RvdHlwZS5hZGRDaHJvbWVsZXNzVG9vbGJhckl0ZW1zO0VkaXRvclVpLnByb3RvdHlwZS5hZGRDaHJvbWVsZXNzVG9vbGJhckl0ZW1zPWZ1bmN0aW9uKGEpe2lmKHRoaXMuaXNFeHBvcnRUb0NhbnZhcygpKXt0aGlzLmV4cG9ydERpYWxvZz1udWxsO3ZhciBiPWEobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dmFyIGM9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtteEV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuZWRpdG9yLmdyYXBoLmNvbnRhaW5lciwKImNsaWNrIixjKTtudWxsIT10aGlzLmV4cG9ydERpYWxvZyYmKHRoaXMuZXhwb3J0RGlhbG9nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5leHBvcnREaWFsb2cpLHRoaXMuZXhwb3J0RGlhbG9nPW51bGwpfSk7aWYobnVsbCE9dGhpcy5leHBvcnREaWFsb2cpYy5hcHBseSh0aGlzKTtlbHNle3RoaXMuZXhwb3J0RGlhbG9nPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO3ZhciBlPWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7bXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKHRoaXMuZXhwb3J0RGlhbG9nLnN0eWxlLCJib3JkZXJSYWRpdXMiLCI1cHgiKTt0aGlzLmV4cG9ydERpYWxvZy5zdHlsZS5wb3NpdGlvbj0iZml4ZWQiO3RoaXMuZXhwb3J0RGlhbG9nLnN0eWxlLnRleHRBbGlnbj0iY2VudGVyIjt0aGlzLmV4cG9ydERpYWxvZy5zdHlsZS5mb250RmFtaWx5PSJIZWx2ZXRpY2EsQXJpYWwiO3RoaXMuZXhwb3J0RGlhbG9nLnN0eWxlLmJhY2tncm91bmRDb2xvcj0iIzAwMDAwMCI7CnRoaXMuZXhwb3J0RGlhbG9nLnN0eWxlLndpZHRoPSI1MHB4Ijt0aGlzLmV4cG9ydERpYWxvZy5zdHlsZS5oZWlnaHQ9IjUwcHgiO3RoaXMuZXhwb3J0RGlhbG9nLnN0eWxlLnBhZGRpbmc9IjRweCAycHggNHB4IDJweCI7dGhpcy5leHBvcnREaWFsb2cuc3R5bGUuY29sb3I9IiNmZmZmZmYiO214VXRpbHMuc2V0T3BhY2l0eSh0aGlzLmV4cG9ydERpYWxvZyw3MCk7dGhpcy5leHBvcnREaWFsb2cuc3R5bGUubGVmdD1lLmxlZnQrInB4Ijt0aGlzLmV4cG9ydERpYWxvZy5zdHlsZS5ib3R0b209cGFyc2VJbnQodGhpcy5jaHJvbWVsZXNzVG9vbGJhci5zdHlsZS5ib3R0b20pK3RoaXMuY2hyb21lbGVzc1Rvb2xiYXIub2Zmc2V0SGVpZ2h0KzQrInB4IjtlPW14VXRpbHMuZ2V0Q3VycmVudFN0eWxlKHRoaXMuZWRpdG9yLmdyYXBoLmNvbnRhaW5lcik7dGhpcy5leHBvcnREaWFsb2cuc3R5bGUuekluZGV4PWUuekluZGV4O3ZhciBkPW5ldyBTcGlubmVyKHtsaW5lczo4LGxlbmd0aDo2LHdpZHRoOjUsCnJhZGl1czo2LHJvdGF0ZTowLGNvbG9yOiIjZmZmIixzcGVlZDoxLjUsdHJhaWw6NjAsc2hhZG93OiExLGh3YWNjZWw6ITEsdG9wOiIyOHB4Iix6SW5kZXg6MkU5fSk7ZC5zcGluKHRoaXMuZXhwb3J0RGlhbG9nKTt0aGlzLmVkaXRvci5leHBvcnRUb0NhbnZhcyhteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtkLnN0b3AoKTt0aGlzLmV4cG9ydERpYWxvZy5zdHlsZS53aWR0aD0iYXV0byI7dGhpcy5leHBvcnREaWFsb2cuc3R5bGUuaGVpZ2h0PSJhdXRvIjt0aGlzLmV4cG9ydERpYWxvZy5zdHlsZS5wYWRkaW5nPSIxMHB4Ijt2YXIgYj10aGlzLmNyZWF0ZUltYWdlRGF0YVVyaShhLG51bGwsInBuZyIpO2E9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIik7YS5zdHlsZS5tYXhXaWR0aD0iMTQwcHgiO2Euc3R5bGUubWF4SGVpZ2h0PSIxNDBweCI7YS5zdHlsZS5jdXJzb3I9InBvaW50ZXIiO2Euc3R5bGUuYmFja2dyb3VuZENvbG9yPSJ3aGl0ZSI7YS5zZXRBdHRyaWJ1dGUoInRpdGxlIiwKbXhSZXNvdXJjZXMuZ2V0KCJvcGVuSW5OZXdXaW5kb3ciKSk7YS5zZXRBdHRyaWJ1dGUoImJvcmRlciIsIjAiKTthLnNldEF0dHJpYnV0ZSgic3JjIixiKTt0aGlzLmV4cG9ydERpYWxvZy5hcHBlbmRDaGlsZChhKTtteEV2ZW50LmFkZExpc3RlbmVyKGEsImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMub3BlbkluTmV3V2luZG93KGIuc3Vic3RyaW5nKGIuaW5kZXhPZigiLCIpKzEpLCJpbWFnZS9wbmciLCEwKTtjLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pKX0pLG51bGwsdGhpcy50aHVtYkltYWdlQ2FjaGUsbnVsbCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLnNwaW5uZXIuc3RvcCgpO3RoaXMuaGFuZGxlRXJyb3IoYSl9KSk7bXhFdmVudC5hZGRMaXN0ZW5lcih0aGlzLmVkaXRvci5ncmFwaC5jb250YWluZXIsImNsaWNrIixjKTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZXhwb3J0RGlhbG9nKX1teEV2ZW50LmNvbnN1bWUoYSl9KSwKRWRpdG9yLmNhbWVyYUxhcmdlSW1hZ2UsbXhSZXNvdXJjZXMuZ2V0KCJleHBvcnQiKSl9Zi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O0VkaXRvclVpLnByb3RvdHlwZS5zYXZlRGF0YT1mdW5jdGlvbihhLGMsZCxmLGwpe3RoaXMuaXNMb2NhbEZpbGVTYXZlKCk/dGhpcy5zYXZlTG9jYWxGaWxlKGQsYSxmLGwsYyk6dGhpcy5zYXZlUmVxdWVzdChhLGMsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5jcmVhdGVFY2hvUmVxdWVzdChkLGEsZixsLGMsYil9KSxkLGwsZil9O0VkaXRvclVpLnByb3RvdHlwZS5zYXZlUmVxdWVzdD1mdW5jdGlvbihhLGMsZCxmLGwsbixrKXtrPW51bGwhPWs/azohbXhDbGllbnQuSVNfSU9TfHwhbmF2aWdhdG9yLnN0YW5kYWxvbmU7dmFyIGI9dGhpcy5nZXRTZXJ2aWNlQ291bnQoITEpO2lzTG9jYWxTdG9yYWdlJiZiKys7dmFyIGU9ND49Yj8yOjY8Yj80OjM7YT1uZXcgQ3JlYXRlRGlhbG9nKHRoaXMsYSxteFV0aWxzLmJpbmQodGhpcywKZnVuY3Rpb24oYSxiKXtpZigiX2JsYW5rIj09Ynx8bnVsbCE9YSYmMDxhLmxlbmd0aCl7dmFyIGU9ZCgiX2JsYW5rIj09Yj9udWxsOmEsYj09QXBwLk1PREVfREVWSUNFfHwiZG93bmxvYWQiPT1ifHxudWxsPT1ifHwiX2JsYW5rIj09Yj8iMCI6IjEiKTtudWxsIT1lJiYoYj09QXBwLk1PREVfREVWSUNFfHwiZG93bmxvYWQiPT1ifHwiX2JsYW5rIj09Yj9lLnNpbXVsYXRlKGRvY3VtZW50LCJfYmxhbmsiKTp0aGlzLnBpY2tGb2xkZXIoYixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihkKXtuPW51bGwhPW4/bjoicGRmIj09Yz8iYXBwbGljYXRpb24vcGRmIjoiaW1hZ2UvIitjO2lmKG51bGwhPWYpdHJ5e3RoaXMuZXhwb3J0RmlsZShmLGEsbiwhMCxiLGQpfWNhdGNoKHope3RoaXMuaGFuZGxlRXJyb3Ioeil9ZWxzZSB0aGlzLnNwaW5uZXIuc3Bpbihkb2N1bWVudC5ib2R5LG14UmVzb3VyY2VzLmdldCgic2F2aW5nIikpJiZlLnNlbmQobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnNwaW5uZXIuc3RvcCgpOwppZigyMDA8PWUuZ2V0U3RhdHVzKCkmJjI5OT49ZS5nZXRTdGF0dXMoKSl0cnl7dGhpcy5leHBvcnRGaWxlKGUuZ2V0VGV4dCgpLGEsbiwhMCxiLGQpfWNhdGNoKHope3RoaXMuaGFuZGxlRXJyb3Ioeil9ZWxzZSB0aGlzLmhhbmRsZUVycm9yKHttZXNzYWdlOm14UmVzb3VyY2VzLmdldCgiZXJyb3JTYXZpbmdGaWxlIil9KX0pLGZ1bmN0aW9uKGEpe3RoaXMuc3Bpbm5lci5zdG9wKCk7dGhpcy5oYW5kbGVFcnJvcihhKX0pfSkpKX19KSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuaGlkZURpYWxvZygpfSksbXhSZXNvdXJjZXMuZ2V0KCJzYXZlQXMiKSxteFJlc291cmNlcy5nZXQoImRvd25sb2FkIiksITEsITEsayxudWxsLDE8YixlLGYsbixsKTtiPXRoaXMuaXNTZXJ2aWNlcyhiKT80PGI/MzkwOjI3MDoxNjA7dGhpcy5zaG93RGlhbG9nKGEuY29udGFpbmVyLDM4MCxiLCEwLCEwKTthLmluaXQoKX07RWRpdG9yVWkucHJvdG90eXBlLmlzU2VydmljZXM9ZnVuY3Rpb24oYSl7cmV0dXJuIDEhPQphfTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0RWRpdEJsYW5rWG1sPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RmlsZURhdGEoITApfTtFZGl0b3JVaS5wcm90b3R5cGUuZXhwb3J0RmlsZT1mdW5jdGlvbihhLGMsZCxmLGwsbil7fTtFZGl0b3JVaS5wcm90b3R5cGUucGlja0ZvbGRlcj1mdW5jdGlvbihhLGMsZCl7YyhudWxsKX07RWRpdG9yVWkucHJvdG90eXBlLmV4cG9ydFN2Zz1mdW5jdGlvbihhLGMsZCxmLGwsbixrLHQsbSx4LHEpe2lmKHRoaXMuc3Bpbm5lci5zcGluKGRvY3VtZW50LmJvZHksbXhSZXNvdXJjZXMuZ2V0KCJleHBvcnQiKSkpdHJ5e3ZhciBiPXRoaXMuZWRpdG9yLmdyYXBoLmlzU2VsZWN0aW9uRW1wdHkoKTtkPW51bGwhPWQ/ZDpiO3ZhciBlPWM/bnVsbDp0aGlzLmVkaXRvci5ncmFwaC5iYWNrZ3JvdW5kO2U9PW14Q29uc3RhbnRzLk5PTkUmJihlPW51bGwpO251bGw9PWUmJjA9PWMmJihlPXE/dGhpcy5lZGl0b3IuZ3JhcGguZGVmYXVsdFBhZ2VCYWNrZ3JvdW5kQ29sb3I6CiIjZmZmZmZmIik7dmFyIGc9dGhpcy5lZGl0b3IuZ3JhcGguZ2V0U3ZnKGUsYSxrLHQsbnVsbCxkLG51bGwsbnVsbCwiYmxhbmsiPT14PyJfYmxhbmsiOiJzZWxmIj09eD8iX3RvcCI6bnVsbCxudWxsLCEwLHEpO2YmJnRoaXMuZWRpdG9yLmdyYXBoLmFkZFN2Z1NoYWRvdyhnKTt2YXIgcD10aGlzLmdldEJhc2VGaWxlbmFtZSgpKyIuc3ZnIix5PW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuc3Bpbm5lci5zdG9wKCk7bCYmYS5zZXRBdHRyaWJ1dGUoImNvbnRlbnQiLHRoaXMuZ2V0RmlsZURhdGEoITAsbnVsbCxudWxsLG51bGwsZCxtLG51bGwsbnVsbCxudWxsLCExKSk7dmFyIGI9Jzw/eG1sIHZlcnNpb249IjEuMCIgZW5jb2Rpbmc9IlVURi04Ij8+XG48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPlxuJytteFV0aWxzLmdldFhtbChhKTt0aGlzLmlzTG9jYWxGaWxlU2F2ZSgpfHwKYi5sZW5ndGg8PU1BWF9SRVFVRVNUX1NJWkU/dGhpcy5zYXZlRGF0YShwLCJzdmciLGIsImltYWdlL3N2Zyt4bWwiKTp0aGlzLmhhbmRsZUVycm9yKHttZXNzYWdlOm14UmVzb3VyY2VzLmdldCgiZHJhd2luZ1Rvb0xhcmdlIil9LG14UmVzb3VyY2VzLmdldCgiZXJyb3IiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe214VXRpbHMucG9wdXAoYil9KSl9KTt0aGlzLmVkaXRvci5hZGRGb250Q3NzKGcpO3RoaXMuZWRpdG9yLmdyYXBoLm1hdGhFbmFibGVkJiZ0aGlzLmVkaXRvci5hZGRNYXRoQ3NzKGcpO24/KG51bGw9PXRoaXMudGh1bWJJbWFnZUNhY2hlJiYodGhpcy50aHVtYkltYWdlQ2FjaGU9e30pLHRoaXMuZWRpdG9yLmNvbnZlcnRJbWFnZXMoZyx5LHRoaXMudGh1bWJJbWFnZUNhY2hlKSk6eShnKX1jYXRjaChGKXt0aGlzLmhhbmRsZUVycm9yKEYpfX07RWRpdG9yVWkucHJvdG90eXBlLmFkZFJhZGlvYm94PWZ1bmN0aW9uKGEsYyxkLGYsbCxuLGspe3JldHVybiB0aGlzLmFkZENoZWNrYm94KGEsCmQsZixsLG4saywhMCxjKX07RWRpdG9yVWkucHJvdG90eXBlLmFkZENoZWNrYm94PWZ1bmN0aW9uKGEsYyxkLGYsbCxuLGssbSl7bj1udWxsIT1uP246ITA7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTtiLnN0eWxlLm1hcmdpblJpZ2h0PSI4cHgiO2Iuc3R5bGUubWFyZ2luVG9wPSIxNnB4IjtiLnNldEF0dHJpYnV0ZSgidHlwZSIsaz8icmFkaW8iOiJjaGVja2JveCIpO2s9ImdlQ2hlY2tib3gtIitFZGl0b3IuZ3VpZCgpO2IuaWQ9aztudWxsIT1tJiZiLnNldEF0dHJpYnV0ZSgibmFtZSIsbSk7ZCYmKGIuc2V0QXR0cmlidXRlKCJjaGVja2VkIiwiY2hlY2tlZCIpLGIuZGVmYXVsdENoZWNrZWQ9ITApO2YmJmIuc2V0QXR0cmlidXRlKCJkaXNhYmxlZCIsImRpc2FibGVkIik7biYmKGEuYXBwZW5kQ2hpbGQoYiksZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJsYWJlbCIpLG14VXRpbHMud3JpdGUoZCxjKSxkLnNldEF0dHJpYnV0ZSgiZm9yIixrKSxhLmFwcGVuZENoaWxkKGQpLApsfHxteFV0aWxzLmJyKGEpKTtyZXR1cm4gYn07RWRpdG9yVWkucHJvdG90eXBlLmFkZEVkaXRCdXR0b249ZnVuY3Rpb24oYSxjKXt2YXIgYj10aGlzLmFkZENoZWNrYm94KGEsbXhSZXNvdXJjZXMuZ2V0KCJlZGl0IikrIjoiLCEwLG51bGwsITApO2Iuc3R5bGUubWFyZ2luTGVmdD0iMjRweCI7dmFyIGU9dGhpcy5nZXRDdXJyZW50RmlsZSgpLGQ9IiI7bnVsbCE9ZSYmZS5nZXRNb2RlKCkhPUFwcC5NT0RFX0RFVklDRSYmZS5nZXRNb2RlKCkhPUFwcC5NT0RFX0JST1dTRVImJihkPXdpbmRvdy5sb2NhdGlvbi5ocmVmKTt2YXIgZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzZWxlY3QiKTtmLnN0eWxlLndpZHRoPSIxMjBweCI7Zi5zdHlsZS5tYXJnaW5MZWZ0PSI4cHgiO2Yuc3R5bGUubWFyZ2luUmlnaHQ9IjEwcHgiO2YuY2xhc3NOYW1lPSJnZUJ0biI7ZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJvcHRpb24iKTtlLnNldEF0dHJpYnV0ZSgidmFsdWUiLCJibGFuayIpO214VXRpbHMud3JpdGUoZSwKbXhSZXNvdXJjZXMuZ2V0KCJtYWtlQ29weSIpKTtmLmFwcGVuZENoaWxkKGUpO2U9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgib3B0aW9uIik7ZS5zZXRBdHRyaWJ1dGUoInZhbHVlIiwiY3VzdG9tIik7bXhVdGlscy53cml0ZShlLG14UmVzb3VyY2VzLmdldCgiY3VzdG9tIikrIi4uLiIpO2YuYXBwZW5kQ2hpbGQoZSk7YS5hcHBlbmRDaGlsZChmKTtteEV2ZW50LmFkZExpc3RlbmVyKGYsImNoYW5nZSIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtpZigiY3VzdG9tIj09Zi52YWx1ZSl7dmFyIGE9bmV3IEZpbGVuYW1lRGlhbG9nKHRoaXMsZCxteFJlc291cmNlcy5nZXQoIm9rIiksZnVuY3Rpb24oYSl7bnVsbCE9YT9kPWE6Zi52YWx1ZT0iYmxhbmsifSxteFJlc291cmNlcy5nZXQoInVybCIpLG51bGwsbnVsbCxudWxsLG51bGwsZnVuY3Rpb24oKXtmLnZhbHVlPSJibGFuayJ9KTt0aGlzLnNob3dEaWFsb2coYS5jb250YWluZXIsMzAwLDgwLCEwLCExKTthLmluaXQoKX19KSk7Cm14RXZlbnQuYWRkTGlzdGVuZXIoYiwiY2hhbmdlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2IuY2hlY2tlZCYmKG51bGw9PWN8fGMuY2hlY2tlZCk/Zi5yZW1vdmVBdHRyaWJ1dGUoImRpc2FibGVkIik6Zi5zZXRBdHRyaWJ1dGUoImRpc2FibGVkIiwiZGlzYWJsZWQiKX0pKTtteFV0aWxzLmJyKGEpO3JldHVybntnZXRMaW5rOmZ1bmN0aW9uKCl7cmV0dXJuIGIuY2hlY2tlZD8iYmxhbmsiPT09Zi52YWx1ZT8iX2JsYW5rIjpkOm51bGx9LGdldEVkaXRJbnB1dDpmdW5jdGlvbigpe3JldHVybiBifSxnZXRFZGl0U2VsZWN0OmZ1bmN0aW9uKCl7cmV0dXJuIGZ9fX07RWRpdG9yVWkucHJvdG90eXBlLmFkZExpbmtTZWN0aW9uPWZ1bmN0aW9uKGEsYyl7ZnVuY3Rpb24gYigpe2suaW5uZXJIVE1MPSc8ZGl2IHN0eWxlPSJ3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2JveC1zaXppbmc6Ym9yZGVyLWJveDsnKyhudWxsIT1mJiZmIT1teENvbnN0YW50cy5OT05FPyJib3JkZXI6MXB4IHNvbGlkIGJsYWNrO2JhY2tncm91bmQtY29sb3I6IisKZjoiYmFja2dyb3VuZC1wb3NpdGlvbjpjZW50ZXIgY2VudGVyO2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybCgnIitEaWFsb2cucHJvdG90eXBlLmNsb3NlSW1hZ2UrIicpIikrJzsiPjwvZGl2Pid9bXhVdGlscy53cml0ZShhLG14UmVzb3VyY2VzLmdldCgibGlua3MiKSsiOiIpO3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNlbGVjdCIpO2Uuc3R5bGUud2lkdGg9IjEwMHB4IjtlLnN0eWxlLm1hcmdpbkxlZnQ9IjhweCI7ZS5zdHlsZS5tYXJnaW5SaWdodD0iMTBweCI7ZS5jbGFzc05hbWU9ImdlQnRuIjt2YXIgZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJvcHRpb24iKTtkLnNldEF0dHJpYnV0ZSgidmFsdWUiLCJhdXRvIik7bXhVdGlscy53cml0ZShkLG14UmVzb3VyY2VzLmdldCgiYXV0b21hdGljIikpO2UuYXBwZW5kQ2hpbGQoZCk7ZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJvcHRpb24iKTtkLnNldEF0dHJpYnV0ZSgidmFsdWUiLAoiYmxhbmsiKTtteFV0aWxzLndyaXRlKGQsbXhSZXNvdXJjZXMuZ2V0KCJvcGVuSW5OZXdXaW5kb3ciKSk7ZS5hcHBlbmRDaGlsZChkKTtkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIm9wdGlvbiIpO2Quc2V0QXR0cmlidXRlKCJ2YWx1ZSIsInNlbGYiKTtteFV0aWxzLndyaXRlKGQsbXhSZXNvdXJjZXMuZ2V0KCJvcGVuSW5UaGlzV2luZG93IikpO2UuYXBwZW5kQ2hpbGQoZCk7YyYmKGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgib3B0aW9uIiksZC5zZXRBdHRyaWJ1dGUoInZhbHVlIiwiZnJhbWUiKSxteFV0aWxzLndyaXRlKGQsbXhSZXNvdXJjZXMuZ2V0KCJvcGVuSW5UaGlzV2luZG93IikrIiAoIitteFJlc291cmNlcy5nZXQoImlmcmFtZSIpKyIpIiksZS5hcHBlbmRDaGlsZChkKSk7YS5hcHBlbmRDaGlsZChlKTtteFV0aWxzLndyaXRlKGEsbXhSZXNvdXJjZXMuZ2V0KCJib3JkZXJDb2xvciIpKyI6Iik7dmFyIGY9IiMwMDAwZmYiLGs9bnVsbCxrPW14VXRpbHMuYnV0dG9uKCIiLApteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLnBpY2tDb2xvcihmfHwibm9uZSIsZnVuY3Rpb24oYSl7Zj1hO2IoKX0pO214RXZlbnQuY29uc3VtZShhKX0pKTtiKCk7ay5zdHlsZS5wYWRkaW5nPW14Q2xpZW50LklTX0ZGPyI0cHggMnB4IDRweCAycHgiOiI0cHgiO2suc3R5bGUubWFyZ2luTGVmdD0iNHB4IjtrLnN0eWxlLmhlaWdodD0iMjJweCI7ay5zdHlsZS53aWR0aD0iMjJweCI7ay5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiO2suc3R5bGUudG9wPW14Q2xpZW50LklTX0lFfHxteENsaWVudC5JU19JRTExfHxteENsaWVudC5JU19FREdFPyI2cHgiOiIxcHgiO2suY2xhc3NOYW1lPSJnZUNvbG9yQnRuIjthLmFwcGVuZENoaWxkKGspO214VXRpbHMuYnIoYSk7cmV0dXJue2dldENvbG9yOmZ1bmN0aW9uKCl7cmV0dXJuIGZ9LGdldFRhcmdldDpmdW5jdGlvbigpe3JldHVybiBlLnZhbHVlfSxmb2N1czpmdW5jdGlvbigpe2UuZm9jdXMoKX19fTtFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlTGluaz0KZnVuY3Rpb24oYSxjLGQsZixsLG4sayxtKXt2YXIgYj10aGlzLmdldEN1cnJlbnRGaWxlKCksZT1bXTtmJiYoZS5wdXNoKCJsaWdodGJveD0xIiksImF1dG8iIT1hJiZlLnB1c2goInRhcmdldD0iK2EpLG51bGwhPWMmJmMhPW14Q29uc3RhbnRzLk5PTkUmJmUucHVzaCgiaGlnaGxpZ2h0PSIrKCIjIj09Yy5jaGFyQXQoMCk/Yy5zdWJzdHJpbmcoMSk6YykpLG51bGwhPWwmJjA8bC5sZW5ndGgmJmUucHVzaCgiZWRpdD0iK2VuY29kZVVSSUNvbXBvbmVudChsKSksbiYmZS5wdXNoKCJsYXllcnM9MSIpLHRoaXMuZWRpdG9yLmdyYXBoLmZvbGRpbmdFbmFibGVkJiZlLnB1c2goIm5hdj0xIikpO2QmJm51bGwhPXRoaXMuY3VycmVudFBhZ2UmJm51bGwhPXRoaXMucGFnZXMmJnRoaXMuY3VycmVudFBhZ2UhPXRoaXMucGFnZXNbMF0mJmUucHVzaCgicGFnZS1pZD0iK3RoaXMuY3VycmVudFBhZ2UuZ2V0SWQoKSk7YT0hMDtudWxsIT1rP2Q9IiNVIitlbmNvZGVVUklDb21wb25lbnQoayk6KGI9CnRoaXMuZ2V0Q3VycmVudEZpbGUoKSxtfHxudWxsPT1ifHxiLmNvbnN0cnVjdG9yIT13aW5kb3cuRHJpdmVGaWxlP2Q9IiNSIitlbmNvZGVVUklDb21wb25lbnQoZD90aGlzLmdldEZpbGVEYXRhKCEwLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLCEwLG51bGwsITEpOkdyYXBoLmNvbXByZXNzKG14VXRpbHMuZ2V0WG1sKHRoaXMuZWRpdG9yLmdldEdyYXBoWG1sKCkpKSk6KGQ9IiMiK2IuZ2V0SGFzaCgpLGE9ITEpKTthJiZudWxsIT1iJiZudWxsIT1iLmdldFRpdGxlKCkmJmIuZ2V0VGl0bGUoKSE9dGhpcy5kZWZhdWx0RmlsZW5hbWUmJmUucHVzaCgidGl0bGU9IitlbmNvZGVVUklDb21wb25lbnQoYi5nZXRUaXRsZSgpKSk7cmV0dXJuKG14Q2xpZW50LklTX0NIUk9NRUFQUHx8RWRpdG9yVWkuaXNFbGVjdHJvbkFwcHx8IS8uKlwuZHJhd1wuaW8kLy50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSk/RWRpdG9yVWkuZHJhd0hvc3Q6Imh0dHBzOi8vIit3aW5kb3cubG9jYXRpb24uaG9zdCkrCiIvIisoMDxlLmxlbmd0aD8iPyIrZS5qb2luKCImIik6IiIpK2R9O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVIdG1sPWZ1bmN0aW9uKGEsYyxkLGYsbCxuLGssbSx5LHgscSl7dGhpcy5nZXRCYXNlbmFtZXMoKTt2YXIgYj17fTsiIiE9bCYmbCE9bXhDb25zdGFudHMuTk9ORSYmKGIuaGlnaGxpZ2h0PWwpOyJhdXRvIiE9PWYmJihiLnRhcmdldD1mKTt5fHwoYi5saWdodGJveD0hMSk7Yi5uYXY9dGhpcy5lZGl0b3IuZ3JhcGguZm9sZGluZ0VuYWJsZWQ7ZD1wYXJzZUludChkKTtpc05hTihkKXx8MTAwPT1kfHwoYi56b29tPWQvMTAwKTtkPVtdO2smJihkLnB1c2goInBhZ2VzIiksYi5yZXNpemU9ITAsbnVsbCE9dGhpcy5wYWdlcyYmbnVsbCE9dGhpcy5jdXJyZW50UGFnZSYmKGIucGFnZT1teFV0aWxzLmluZGV4T2YodGhpcy5wYWdlcyx0aGlzLmN1cnJlbnRQYWdlKSkpO2MmJihkLnB1c2goInpvb20iKSxiLnJlc2l6ZT0hMCk7bSYmZC5wdXNoKCJsYXllcnMiKTswPGQubGVuZ3RoJiYKKHkmJmQucHVzaCgibGlnaHRib3giKSxiLnRvb2xiYXI9ZC5qb2luKCIgIikpO251bGwhPXgmJjA8eC5sZW5ndGgmJihiLmVkaXQ9eCk7bnVsbCE9YT9iLnVybD1hOmIueG1sPXRoaXMuZ2V0RmlsZURhdGEoITAsbnVsbCxudWxsLG51bGwsbnVsbCwhayk7Yz0nPGRpdiBjbGFzcz0ibXhncmFwaCIgc3R5bGU9IicrKG4/Im1heC13aWR0aDoxMDAlOyI6IiIpKygiIiE9ZD8iYm9yZGVyOjFweCBzb2xpZCB0cmFuc3BhcmVudDsiOiIiKSsnIiBkYXRhLW14Z3JhcGg9IicrbXhVdGlscy5odG1sRW50aXRpZXMoSlNPTi5zdHJpbmdpZnkoYikpKyciPjwvZGl2Pic7YT1udWxsIT1hPyImZmV0Y2g9IitlbmNvZGVVUklDb21wb25lbnQoYSk6IiI7cShjLCc8c2NyaXB0IHR5cGU9InRleHQvamF2YXNjcmlwdCIgc3JjPSInKygwPGEubGVuZ3RoPygiMSI9PXVybFBhcmFtcy5kZXY/Imh0dHBzOi8vdGVzdC5kcmF3LmlvL2VtYmVkMi5qcz9kZXY9MSI6RWRpdG9yVWkuZHJhd0hvc3QrIi9lbWJlZDIuanM/IikrCmE6IjEiPT11cmxQYXJhbXMuZGV2PyJodHRwczovL3Rlc3QuZHJhdy5pby9qcy92aWV3ZXIubWluLmpzIjp3aW5kb3cuVklFV0VSX1VSTD93aW5kb3cuVklFV0VSX1VSTDpFZGl0b3JVaS5kcmF3SG9zdCsiL2pzL3ZpZXdlci5taW4uanMiKSsnIj5ceDNjL3NjcmlwdD4nKX07RWRpdG9yVWkucHJvdG90eXBlLnNob3dIdG1sRGlhbG9nPWZ1bmN0aW9uKGEsYyxkLGYpe3ZhciBiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Iuc3R5bGUud2hpdGVTcGFjZT0ibm93cmFwIjt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJoMyIpO214VXRpbHMud3JpdGUoZSxteFJlc291cmNlcy5nZXQoImh0bWwiKSk7ZS5zdHlsZS5jc3NUZXh0PSJ3aWR0aDoxMDAlO3RleHQtYWxpZ246Y2VudGVyO21hcmdpbi10b3A6MHB4O21hcmdpbi1ib3R0b206MTJweCI7Yi5hcHBlbmRDaGlsZChlKTt2YXIgZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtnLnN0eWxlLmNzc1RleHQ9ImJvcmRlci1ib3R0b206MXB4IHNvbGlkIGxpZ2h0R3JheTtwYWRkaW5nLWJvdHRvbTo4cHg7bWFyZ2luLWJvdHRvbToxMnB4OyI7CnZhciBwPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7cC5zdHlsZS5jc3NUZXh0PSJtYXJnaW4tcmlnaHQ6OHB4O21hcmdpbi10b3A6OHB4O21hcmdpbi1ib3R0b206OHB4OyI7cC5zZXRBdHRyaWJ1dGUoInZhbHVlIiwidXJsIik7cC5zZXRBdHRyaWJ1dGUoInR5cGUiLCJyYWRpbyIpO3Auc2V0QXR0cmlidXRlKCJuYW1lIiwidHlwZS1lbWJlZGh0bWxkaWFsb2ciKTtlPXAuY2xvbmVOb2RlKCEwKTtlLnNldEF0dHJpYnV0ZSgidmFsdWUiLCJjb3B5Iik7Zy5hcHBlbmRDaGlsZChlKTt2YXIgaz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIik7bXhVdGlscy53cml0ZShrLG14UmVzb3VyY2VzLmdldCgiaW5jbHVkZUNvcHlPZk15RGlhZ3JhbSIpKTtnLmFwcGVuZENoaWxkKGspO214VXRpbHMuYnIoZyk7Zy5hcHBlbmRDaGlsZChwKTtrPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNwYW4iKTtteFV0aWxzLndyaXRlKGssbXhSZXNvdXJjZXMuZ2V0KCJwdWJsaWNEaWFncmFtVXJsIikpOwpnLmFwcGVuZENoaWxkKGspO3ZhciBtPXRoaXMuZ2V0Q3VycmVudEZpbGUoKTtudWxsPT1kJiZudWxsIT1tJiZtLmNvbnN0cnVjdG9yPT13aW5kb3cuRHJpdmVGaWxlJiYoaz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJhIiksay5zdHlsZS5wYWRkaW5nTGVmdD0iMTJweCIsay5zdHlsZS5jb2xvcj0iZ3JheSIsay5zdHlsZS5jdXJzb3I9InBvaW50ZXIiLG14VXRpbHMud3JpdGUoayxteFJlc291cmNlcy5nZXQoInNoYXJlIikpLGcuYXBwZW5kQ2hpbGQoayksbXhFdmVudC5hZGRMaXN0ZW5lcihrLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmhpZGVEaWFsb2coKTt0aGlzLmRyaXZlLnNob3dQZXJtaXNzaW9ucyhtLmdldElkKCkpfSkpKTtlLnNldEF0dHJpYnV0ZSgiY2hlY2tlZCIsImNoZWNrZWQiKTtudWxsPT1kJiZwLnNldEF0dHJpYnV0ZSgiZGlzYWJsZWQiLCJkaXNhYmxlZCIpO2IuYXBwZW5kQ2hpbGQoZyk7dmFyIHE9dGhpcy5hZGRMaW5rU2VjdGlvbihiKSwKQT10aGlzLmFkZENoZWNrYm94KGIsbXhSZXNvdXJjZXMuZ2V0KCJ6b29tIiksITAsbnVsbCwhMCk7bXhVdGlscy53cml0ZShiLCI6Iik7dmFyIEM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTtDLnNldEF0dHJpYnV0ZSgidHlwZSIsInRleHQiKTtDLnN0eWxlLm1hcmdpblJpZ2h0PSIxNnB4IjtDLnN0eWxlLndpZHRoPSI2MHB4IjtDLnN0eWxlLm1hcmdpbkxlZnQ9IjRweCI7Qy5zdHlsZS5tYXJnaW5SaWdodD0iMTJweCI7Qy52YWx1ZT0iMTAwJSI7Yi5hcHBlbmRDaGlsZChDKTt2YXIgej10aGlzLmFkZENoZWNrYm94KGIsbXhSZXNvdXJjZXMuZ2V0KCJmaXQiKSwhMCksZz1udWxsIT10aGlzLnBhZ2VzJiYxPHRoaXMucGFnZXMubGVuZ3RoLEQ9RD10aGlzLmFkZENoZWNrYm94KGIsbXhSZXNvdXJjZXMuZ2V0KCJhbGxQYWdlcyIpLGcsIWcpLEc9dGhpcy5hZGRDaGVja2JveChiLG14UmVzb3VyY2VzLmdldCgibGF5ZXJzIiksITApLEY9dGhpcy5hZGRDaGVja2JveChiLG14UmVzb3VyY2VzLmdldCgibGlnaHRib3giKSwKITApLEg9dGhpcy5hZGRFZGl0QnV0dG9uKGIsRiksSj1ILmdldEVkaXRJbnB1dCgpO0ouc3R5bGUubWFyZ2luQm90dG9tPSIxNnB4IjtteEV2ZW50LmFkZExpc3RlbmVyKEYsImNoYW5nZSIsZnVuY3Rpb24oKXtGLmNoZWNrZWQ/Si5yZW1vdmVBdHRyaWJ1dGUoImRpc2FibGVkIik6Si5zZXRBdHRyaWJ1dGUoImRpc2FibGVkIiwiZGlzYWJsZWQiKTtKLmNoZWNrZWQmJkYuY2hlY2tlZD9ILmdldEVkaXRTZWxlY3QoKS5yZW1vdmVBdHRyaWJ1dGUoImRpc2FibGVkIik6SC5nZXRFZGl0U2VsZWN0KCkuc2V0QXR0cmlidXRlKCJkaXNhYmxlZCIsImRpc2FibGVkIil9KTthPW5ldyBDdXN0b21EaWFsb2codGhpcyxiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7ZihwLmNoZWNrZWQ/ZDpudWxsLEEuY2hlY2tlZCxDLnZhbHVlLHEuZ2V0VGFyZ2V0KCkscS5nZXRDb2xvcigpLHouY2hlY2tlZCxELmNoZWNrZWQsRy5jaGVja2VkLEYuY2hlY2tlZCxILmdldExpbmsoKSl9KSxudWxsLGEsCmMpO3RoaXMuc2hvd0RpYWxvZyhhLmNvbnRhaW5lciwzNDAsMzg0LCEwLCEwKTtlLmZvY3VzKCl9O0VkaXRvclVpLnByb3RvdHlwZS5zaG93UHVibGlzaExpbmtEaWFsb2c9ZnVuY3Rpb24oYSxjLGQsZixsLG4pe3ZhciBiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Iuc3R5bGUud2hpdGVTcGFjZT0ibm93cmFwIjt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJoMyIpO214VXRpbHMud3JpdGUoZSxhfHxteFJlc291cmNlcy5nZXQoImxpbmsiKSk7ZS5zdHlsZS5jc3NUZXh0PSJ3aWR0aDoxMDAlO3RleHQtYWxpZ246Y2VudGVyO21hcmdpbi10b3A6MHB4O21hcmdpbi1ib3R0b206MTJweCI7Yi5hcHBlbmRDaGlsZChlKTt2YXIgZz10aGlzLmdldEN1cnJlbnRGaWxlKCksZT0iaHR0cHM6Ly9kZXNrLmRyYXcuaW8vc3VwcG9ydC9zb2x1dGlvbnMvYXJ0aWNsZXMvMTYwMDAwNTE5NDEiO2E9MDtpZihudWxsIT1nJiZnLmNvbnN0cnVjdG9yPT13aW5kb3cuRHJpdmVGaWxlJiYKIWMpe2E9ODA7dmFyIGU9Imh0dHBzOi8vZGVzay5kcmF3LmlvL3N1cHBvcnQvc29sdXRpb25zL2FydGljbGVzLzE2MDAwMDM5Mzg0IixwPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO3Auc3R5bGUuY3NzVGV4dD0iYm9yZGVyLWJvdHRvbToxcHggc29saWQgbGlnaHRHcmF5O3BhZGRpbmctYm90dG9tOjE0cHg7cGFkZGluZy10b3A6NnB4O21hcmdpbi1ib3R0b206MTRweDt0ZXh0LWFsaWduOmNlbnRlcjsiO3ZhciBrPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2suc3R5bGUud2hpdGVTcGFjZT0ibm9ybWFsIjtteFV0aWxzLndyaXRlKGssbXhSZXNvdXJjZXMuZ2V0KCJsaW5rQWNjb3VudFJlcXVpcmVkIikpO3AuYXBwZW5kQ2hpbGQoayk7az1teFV0aWxzLmJ1dHRvbihteFJlc291cmNlcy5nZXQoInNoYXJlIiksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmRyaXZlLnNob3dQZXJtaXNzaW9ucyhnLmdldElkKCkpfSkpO2suc3R5bGUubWFyZ2luVG9wPQoiMTJweCI7ay5jbGFzc05hbWU9ImdlQnRuIjtwLmFwcGVuZENoaWxkKGspO2IuYXBwZW5kQ2hpbGQocCk7az1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJhIik7ay5zdHlsZS5wYWRkaW5nTGVmdD0iMTJweCI7ay5zdHlsZS5jb2xvcj0iZ3JheSI7ay5zdHlsZS5mb250U2l6ZT0iMTFweCI7ay5zdHlsZS5jdXJzb3I9InBvaW50ZXIiO214VXRpbHMud3JpdGUoayxteFJlc291cmNlcy5nZXQoImNoZWNrIikpO3AuYXBwZW5kQ2hpbGQoayk7bXhFdmVudC5hZGRMaXN0ZW5lcihrLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnNwaW5uZXIuc3Bpbihkb2N1bWVudC5ib2R5LG14UmVzb3VyY2VzLmdldCgibG9hZGluZyIpKSYmdGhpcy5nZXRQdWJsaWNVcmwodGhpcy5nZXRDdXJyZW50RmlsZSgpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuc3Bpbm5lci5zdG9wKCk7YT1uZXcgRXJyb3JEaWFsb2codGhpcyxudWxsLG14UmVzb3VyY2VzLmdldChudWxsIT0KYT8iZGlhZ3JhbUlzUHVibGljIjoiZGlhZ3JhbUlzTm90UHVibGljIiksbXhSZXNvdXJjZXMuZ2V0KCJvayIpKTt0aGlzLnNob3dEaWFsb2coYS5jb250YWluZXIsMzAwLDgwLCEwLCExKTthLmluaXQoKX0pKX0pKX12YXIgbT1udWxsLHE9bnVsbDtpZihudWxsIT1kfHxudWxsIT1mKWErPTMwLG14VXRpbHMud3JpdGUoYixteFJlc291cmNlcy5nZXQoIndpZHRoIikrIjoiKSxtPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0IiksbS5zZXRBdHRyaWJ1dGUoInR5cGUiLCJ0ZXh0IiksbS5zdHlsZS5tYXJnaW5SaWdodD0iMTZweCIsbS5zdHlsZS53aWR0aD0iNTBweCIsbS5zdHlsZS5tYXJnaW5MZWZ0PSI2cHgiLG0uc3R5bGUubWFyZ2luUmlnaHQ9IjE2cHgiLG0uc3R5bGUubWFyZ2luQm90dG9tPSIxMHB4IixtLnZhbHVlPSIxMDAlIixiLmFwcGVuZENoaWxkKG0pLG14VXRpbHMud3JpdGUoYixteFJlc291cmNlcy5nZXQoImhlaWdodCIpKyI6IikscT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpLApxLnNldEF0dHJpYnV0ZSgidHlwZSIsInRleHQiKSxxLnN0eWxlLndpZHRoPSI1MHB4IixxLnN0eWxlLm1hcmdpbkxlZnQ9IjZweCIscS5zdHlsZS5tYXJnaW5Cb3R0b209IjEwcHgiLHEudmFsdWU9ZisicHgiLGIuYXBwZW5kQ2hpbGQocSksbXhVdGlscy5icihiKTt2YXIgej10aGlzLmFkZExpbmtTZWN0aW9uKGIsbik7ZD1udWxsIT10aGlzLnBhZ2VzJiYxPHRoaXMucGFnZXMubGVuZ3RoO3ZhciBEPW51bGw7aWYobnVsbD09Z3x8Zy5jb25zdHJ1Y3RvciE9d2luZG93LkRyaXZlRmlsZXx8YylEPXRoaXMuYWRkQ2hlY2tib3goYixteFJlc291cmNlcy5nZXQoImFsbFBhZ2VzIiksZCwhZCk7dmFyIEc9dGhpcy5hZGRDaGVja2JveChiLG14UmVzb3VyY2VzLmdldCgibGlnaHRib3giKSwhMCksRj10aGlzLmFkZEVkaXRCdXR0b24oYixHKSxIPUYuZ2V0RWRpdElucHV0KCksSj10aGlzLmFkZENoZWNrYm94KGIsbXhSZXNvdXJjZXMuZ2V0KCJsYXllcnMiKSwhMCk7Si5zdHlsZS5tYXJnaW5MZWZ0PQpILnN0eWxlLm1hcmdpbkxlZnQ7Si5zdHlsZS5tYXJnaW5Cb3R0b209IjE2cHgiO0ouc3R5bGUubWFyZ2luVG9wPSI4cHgiO214RXZlbnQuYWRkTGlzdGVuZXIoRywiY2hhbmdlIixmdW5jdGlvbigpe0cuY2hlY2tlZD8oSi5yZW1vdmVBdHRyaWJ1dGUoImRpc2FibGVkIiksSC5yZW1vdmVBdHRyaWJ1dGUoImRpc2FibGVkIikpOihKLnNldEF0dHJpYnV0ZSgiZGlzYWJsZWQiLCJkaXNhYmxlZCIpLEguc2V0QXR0cmlidXRlKCJkaXNhYmxlZCIsImRpc2FibGVkIikpO0guY2hlY2tlZCYmRy5jaGVja2VkP0YuZ2V0RWRpdFNlbGVjdCgpLnJlbW92ZUF0dHJpYnV0ZSgiZGlzYWJsZWQiKTpGLmdldEVkaXRTZWxlY3QoKS5zZXRBdHRyaWJ1dGUoImRpc2FibGVkIiwiZGlzYWJsZWQiKX0pO2M9bmV3IEN1c3RvbURpYWxvZyh0aGlzLGIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtsKHouZ2V0VGFyZ2V0KCksei5nZXRDb2xvcigpLG51bGw9PUQ/ITA6RC5jaGVja2VkLEcuY2hlY2tlZCwKRi5nZXRMaW5rKCksSi5jaGVja2VkLG51bGwhPW0/bS52YWx1ZTpudWxsLG51bGwhPXE/cS52YWx1ZTpudWxsKX0pLG51bGwsbXhSZXNvdXJjZXMuZ2V0KCJjcmVhdGUiKSxlKTt0aGlzLnNob3dEaWFsb2coYy5jb250YWluZXIsMzQwLDI1NCthLCEwLCEwKTtudWxsIT1tPyhtLmZvY3VzKCksbXhDbGllbnQuSVNfR0N8fG14Q2xpZW50LklTX0ZGfHw1PD1kb2N1bWVudC5kb2N1bWVudE1vZGV8fG14Q2xpZW50LklTX1FVSVJLUz9tLnNlbGVjdCgpOmRvY3VtZW50LmV4ZWNDb21tYW5kKCJzZWxlY3RBbGwiLCExLG51bGwpKTp6LmZvY3VzKCl9O0VkaXRvclVpLnByb3RvdHlwZS5zaG93UmVtb3RlRXhwb3J0RGlhbG9nPWZ1bmN0aW9uKGEsYyxkLGYsbCl7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Yi5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiO3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImgzIik7bXhVdGlscy53cml0ZShlLG14UmVzb3VyY2VzLmdldCgiaW1hZ2UiKSk7CmUuc3R5bGUuY3NzVGV4dD0id2lkdGg6MTAwJTt0ZXh0LWFsaWduOmNlbnRlcjttYXJnaW4tdG9wOjBweDttYXJnaW4tYm90dG9tOiIrKGw/IjEwIjoiNCIpKyJweCI7Yi5hcHBlbmRDaGlsZChlKTtpZihsKXtteFV0aWxzLndyaXRlKGIsbXhSZXNvdXJjZXMuZ2V0KCJ6b29tIikrIjoiKTt2YXIgZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpO2cuc2V0QXR0cmlidXRlKCJ0eXBlIiwidGV4dCIpO2cuc3R5bGUubWFyZ2luUmlnaHQ9IjE2cHgiO2cuc3R5bGUud2lkdGg9IjYwcHgiO2cuc3R5bGUubWFyZ2luTGVmdD0iNHB4IjtnLnN0eWxlLm1hcmdpblJpZ2h0PSIxMnB4IjtnLnZhbHVlPXRoaXMubGFzdEV4cG9ydFpvb218fCIxMDAlIjtiLmFwcGVuZENoaWxkKGcpO214VXRpbHMud3JpdGUoYixteFJlc291cmNlcy5nZXQoImJvcmRlcldpZHRoIikrIjoiKTt2YXIgcD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpO3Auc2V0QXR0cmlidXRlKCJ0eXBlIiwidGV4dCIpOwpwLnN0eWxlLm1hcmdpblJpZ2h0PSIxNnB4IjtwLnN0eWxlLndpZHRoPSI2MHB4IjtwLnN0eWxlLm1hcmdpbkxlZnQ9IjRweCI7cC52YWx1ZT10aGlzLmxhc3RFeHBvcnRCb3JkZXJ8fCIwIjtiLmFwcGVuZENoaWxkKHApO214VXRpbHMuYnIoYil9dmFyIGs9dGhpcy5hZGRDaGVja2JveChiLG14UmVzb3VyY2VzLmdldCgic2VsZWN0aW9uT25seSIpLCExLHRoaXMuZWRpdG9yLmdyYXBoLmlzU2VsZWN0aW9uRW1wdHkoKSksbT1mP251bGw6dGhpcy5hZGRDaGVja2JveChiLG14UmVzb3VyY2VzLmdldCgiaW5jbHVkZUNvcHlPZk15RGlhZ3JhbSIpLCEwKSxlPXRoaXMuZWRpdG9yLmdyYXBoLHE9Zj9udWxsOnRoaXMuYWRkQ2hlY2tib3goYixteFJlc291cmNlcy5nZXQoInRyYW5zcGFyZW50QmFja2dyb3VuZCIpLGUuYmFja2dyb3VuZD09bXhDb25zdGFudHMuTk9ORXx8bnVsbD09ZS5iYWNrZ3JvdW5kKTtudWxsIT1xJiYocS5zdHlsZS5tYXJnaW5Cb3R0b209IjE2cHgiKTthPW5ldyBDdXN0b21EaWFsb2codGhpcywKYixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3ZhciBhPXBhcnNlSW50KGcudmFsdWUpLzEwMHx8MSxiPXBhcnNlSW50KHAudmFsdWUpfHwwO2QoIWsuY2hlY2tlZCxudWxsIT1tP20uY2hlY2tlZDohMSxudWxsIT1xP3EuY2hlY2tlZDohMSxhLGIpfSksbnVsbCxhLGMpO3RoaXMuc2hvd0RpYWxvZyhhLmNvbnRhaW5lciwzMDAsKGw/MjU6MCkrKGY/MTI1OjIxMCksITAsITApfTtFZGl0b3JVaS5wcm90b3R5cGUuc2hvd0V4cG9ydERpYWxvZz1mdW5jdGlvbihhLGMsZCxmLGwsbixrLG0pe2s9bnVsbCE9az9rOiEwO3ZhciBiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Iuc3R5bGUud2hpdGVTcGFjZT0ibm93cmFwIjt2YXIgZT10aGlzLmVkaXRvci5ncmFwaCxnPSJqcGVnIj09bT8xOTY6MzAwLHA9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaDMiKTtteFV0aWxzLndyaXRlKHAsYSk7cC5zdHlsZS5jc3NUZXh0PSJ3aWR0aDoxMDAlO3RleHQtYWxpZ246Y2VudGVyO21hcmdpbi10b3A6MHB4O21hcmdpbi1ib3R0b206MTBweCI7CmIuYXBwZW5kQ2hpbGQocCk7bXhVdGlscy53cml0ZShiLG14UmVzb3VyY2VzLmdldCgiem9vbSIpKyI6Iik7dmFyIHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTt0LnNldEF0dHJpYnV0ZSgidHlwZSIsInRleHQiKTt0LnN0eWxlLm1hcmdpblJpZ2h0PSIxNnB4Ijt0LnN0eWxlLndpZHRoPSI2MHB4Ijt0LnN0eWxlLm1hcmdpbkxlZnQ9IjRweCI7dC5zdHlsZS5tYXJnaW5SaWdodD0iMTJweCI7dC52YWx1ZT10aGlzLmxhc3RFeHBvcnRab29tfHwiMTAwJSI7Yi5hcHBlbmRDaGlsZCh0KTtteFV0aWxzLndyaXRlKGIsbXhSZXNvdXJjZXMuZ2V0KCJib3JkZXJXaWR0aCIpKyI6Iik7dmFyIHE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTtxLnNldEF0dHJpYnV0ZSgidHlwZSIsInRleHQiKTtxLnN0eWxlLm1hcmdpblJpZ2h0PSIxNnB4IjtxLnN0eWxlLndpZHRoPSI2MHB4IjtxLnN0eWxlLm1hcmdpbkxlZnQ9IjRweCI7cS52YWx1ZT10aGlzLmxhc3RFeHBvcnRCb3JkZXJ8fAoiMCI7Yi5hcHBlbmRDaGlsZChxKTtteFV0aWxzLmJyKGIpO3ZhciB2PXRoaXMuYWRkQ2hlY2tib3goYixteFJlc291cmNlcy5nZXQoInRyYW5zcGFyZW50QmFja2dyb3VuZCIpLCExLG51bGwsbnVsbCwianBlZyIhPW0pLEc9bnVsbDsiZGFyayI9PXVpVGhlbWUmJihHPXRoaXMuYWRkQ2hlY2tib3goYixteFJlc291cmNlcy5nZXQoImRhcmsiKSwhMCksZys9MjYpO3ZhciBGPXRoaXMuYWRkQ2hlY2tib3goYixteFJlc291cmNlcy5nZXQoInNlbGVjdGlvbk9ubHkiKSwhMSxlLmlzU2VsZWN0aW9uRW1wdHkoKSksSD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpO0guc3R5bGUubWFyZ2luVG9wPSIxNnB4IjtILnN0eWxlLm1hcmdpblJpZ2h0PSI4cHgiO0guc3R5bGUubWFyZ2luTGVmdD0iMjRweCI7SC5zZXRBdHRyaWJ1dGUoImRpc2FibGVkIiwiZGlzYWJsZWQiKTtILnNldEF0dHJpYnV0ZSgidHlwZSIsImNoZWNrYm94Iik7biYmKGIuYXBwZW5kQ2hpbGQoSCksbXhVdGlscy53cml0ZShiLApteFJlc291cmNlcy5nZXQoImNyb3AiKSksbXhVdGlscy5icihiKSxnKz0yNixteEV2ZW50LmFkZExpc3RlbmVyKEYsImNoYW5nZSIsZnVuY3Rpb24oKXtGLmNoZWNrZWQ/SC5yZW1vdmVBdHRyaWJ1dGUoImRpc2FibGVkIik6SC5zZXRBdHRyaWJ1dGUoImRpc2FibGVkIiwiZGlzYWJsZWQiKX0pKTtlLmlzU2VsZWN0aW9uRW1wdHkoKXx8KEguc2V0QXR0cmlidXRlKCJjaGVja2VkIiwiY2hlY2tlZCIpLEguZGVmYXVsdENoZWNrZWQ9ITApO3ZhciBKPXRoaXMuYWRkQ2hlY2tib3goYixteFJlc291cmNlcy5nZXQoInNoYWRvdyIpLGUuc2hhZG93VmlzaWJsZSksdT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpO3Uuc3R5bGUubWFyZ2luVG9wPSIxNnB4Ijt1LnN0eWxlLm1hcmdpblJpZ2h0PSI4cHgiO3Uuc2V0QXR0cmlidXRlKCJ0eXBlIiwiY2hlY2tib3giKTshdGhpcy5pc09mZmxpbmUoKSYmdGhpcy5jYW52YXNTdXBwb3J0ZWR8fHUuc2V0QXR0cmlidXRlKCJkaXNhYmxlZCIsCiJkaXNhYmxlZCIpO2MmJihiLmFwcGVuZENoaWxkKHUpLG14VXRpbHMud3JpdGUoYixteFJlc291cmNlcy5nZXQoImVtYmVkSW1hZ2VzIikpLG14VXRpbHMuYnIoYiksZys9MjYpO3ZhciBLPW51bGw7aWYoInBuZyI9PW18fCJqcGVnIj09bSlLPXRoaXMuYWRkQ2hlY2tib3goYixteFJlc291cmNlcy5nZXQoImdyaWQiKSwhMSx0aGlzLmlzT2ZmbGluZSgpfHwhdGhpcy5jYW52YXNTdXBwb3J0ZWQsITEsITApLGcrPTI2O3ZhciBCPXRoaXMuYWRkQ2hlY2tib3goYixteFJlc291cmNlcy5nZXQoImluY2x1ZGVDb3B5T2ZNeURpYWdyYW0iKSxrLG51bGwsbnVsbCwianBlZyIhPW0pLE09bnVsbCE9dGhpcy5wYWdlcyYmMTx0aGlzLnBhZ2VzLmxlbmd0aCxQPXRoaXMuYWRkQ2hlY2tib3goYixNP214UmVzb3VyY2VzLmdldCgiYWxsUGFnZXMiKToiIixNLCFNLG51bGwsImpwZWciIT1tKTtQLnN0eWxlLm1hcmdpbkxlZnQ9IjI0cHgiO1Auc3R5bGUubWFyZ2luQm90dG9tPSIxNnB4IjtNP2crPQoyNjpQLnN0eWxlLmRpc3BsYXk9Im5vbmUiO214RXZlbnQuYWRkTGlzdGVuZXIoQiwiY2hhbmdlIixmdW5jdGlvbigpe0IuY2hlY2tlZCYmTT9QLnJlbW92ZUF0dHJpYnV0ZSgiZGlzYWJsZWQiKTpQLnNldEF0dHJpYnV0ZSgiZGlzYWJsZWQiLCJkaXNhYmxlZCIpfSk7ayYmTXx8UC5zZXRBdHRyaWJ1dGUoImRpc2FibGVkIiwiZGlzYWJsZWQiKTt2YXIgST1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzZWxlY3QiKTtJLnN0eWxlLm1heFdpZHRoPSIyNjBweCI7SS5zdHlsZS5tYXJnaW5MZWZ0PSI4cHgiO0kuc3R5bGUubWFyZ2luUmlnaHQ9IjEwcHgiO0kuY2xhc3NOYW1lPSJnZUJ0biI7YT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJvcHRpb24iKTthLnNldEF0dHJpYnV0ZSgidmFsdWUiLCJhdXRvIik7bXhVdGlscy53cml0ZShhLG14UmVzb3VyY2VzLmdldCgiYXV0b21hdGljIikpO0kuYXBwZW5kQ2hpbGQoYSk7YT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJvcHRpb24iKTthLnNldEF0dHJpYnV0ZSgidmFsdWUiLAoiYmxhbmsiKTtteFV0aWxzLndyaXRlKGEsbXhSZXNvdXJjZXMuZ2V0KCJvcGVuSW5OZXdXaW5kb3ciKSk7SS5hcHBlbmRDaGlsZChhKTthPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIm9wdGlvbiIpO2Euc2V0QXR0cmlidXRlKCJ2YWx1ZSIsInNlbGYiKTtteFV0aWxzLndyaXRlKGEsbXhSZXNvdXJjZXMuZ2V0KCJvcGVuSW5UaGlzV2luZG93IikpO0kuYXBwZW5kQ2hpbGQoYSk7InN2ZyI9PW0mJihteFV0aWxzLndyaXRlKGIsbXhSZXNvdXJjZXMuZ2V0KCJsaW5rcyIpKyI6IiksYi5hcHBlbmRDaGlsZChJKSxteFV0aWxzLmJyKGIpLG14VXRpbHMuYnIoYiksZys9MjYpO2Q9bmV3IEN1c3RvbURpYWxvZyh0aGlzLGIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmxhc3RFeHBvcnRCb3JkZXI9cS52YWx1ZTt0aGlzLmxhc3RFeHBvcnRab29tPXQudmFsdWU7bCh0LnZhbHVlLHYuY2hlY2tlZCwhRi5jaGVja2VkLEouY2hlY2tlZCxCLmNoZWNrZWQsdS5jaGVja2VkLHEudmFsdWUsCkguY2hlY2tlZCwhUC5jaGVja2VkLEkudmFsdWUsbnVsbCE9Sz9LLmNoZWNrZWQ6bnVsbCxudWxsIT1HP0cuY2hlY2tlZDpudWxsKX0pLG51bGwsZCxmKTt0aGlzLnNob3dEaWFsb2coZC5jb250YWluZXIsMzQwLGcsITAsITAsbnVsbCxudWxsLG51bGwsbnVsbCwhMCk7dC5mb2N1cygpO214Q2xpZW50LklTX0dDfHxteENsaWVudC5JU19GRnx8NTw9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHxteENsaWVudC5JU19RVUlSS1M/dC5zZWxlY3QoKTpkb2N1bWVudC5leGVjQ29tbWFuZCgic2VsZWN0QWxsIiwhMSxudWxsKX07RWRpdG9yVWkucHJvdG90eXBlLnNob3dFbWJlZEltYWdlRGlhbG9nPWZ1bmN0aW9uKGEsYyxkLGYsbCl7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Yi5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiO3ZhciBlPXRoaXMuZWRpdG9yLmdyYXBoO2lmKG51bGwhPWMpe3ZhciBnPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImgzIik7bXhVdGlscy53cml0ZShnLApjKTtnLnN0eWxlLmNzc1RleHQ9IndpZHRoOjEwMCU7dGV4dC1hbGlnbjpjZW50ZXI7bWFyZ2luLXRvcDowcHg7bWFyZ2luLWJvdHRvbTo0cHgiO2IuYXBwZW5kQ2hpbGQoZyl9dmFyIHA9dGhpcy5hZGRDaGVja2JveChiLG14UmVzb3VyY2VzLmdldCgiZml0IiksITApLGs9dGhpcy5hZGRDaGVja2JveChiLG14UmVzb3VyY2VzLmdldCgic2hhZG93IiksZS5zaGFkb3dWaXNpYmxlJiZmLCFmKSxtPXRoaXMuYWRkQ2hlY2tib3goYixkKSxxPXRoaXMuYWRkQ2hlY2tib3goYixteFJlc291cmNlcy5nZXQoImxpZ2h0Ym94IiksITApLEM9dGhpcy5hZGRFZGl0QnV0dG9uKGIscSksej1DLmdldEVkaXRJbnB1dCgpLEQ9MTxlLm1vZGVsLmdldENoaWxkQ291bnQoZS5tb2RlbC5nZXRSb290KCkpLEc9dGhpcy5hZGRDaGVja2JveChiLG14UmVzb3VyY2VzLmdldCgibGF5ZXJzIiksRCwhRCk7Ry5zdHlsZS5tYXJnaW5MZWZ0PXouc3R5bGUubWFyZ2luTGVmdDtHLnN0eWxlLm1hcmdpbkJvdHRvbT0KIjEycHgiO0cuc3R5bGUubWFyZ2luVG9wPSI4cHgiO214RXZlbnQuYWRkTGlzdGVuZXIocSwiY2hhbmdlIixmdW5jdGlvbigpe3EuY2hlY2tlZD8oRCYmRy5yZW1vdmVBdHRyaWJ1dGUoImRpc2FibGVkIiksei5yZW1vdmVBdHRyaWJ1dGUoImRpc2FibGVkIikpOihHLnNldEF0dHJpYnV0ZSgiZGlzYWJsZWQiLCJkaXNhYmxlZCIpLHouc2V0QXR0cmlidXRlKCJkaXNhYmxlZCIsImRpc2FibGVkIikpO3ouY2hlY2tlZCYmcS5jaGVja2VkP0MuZ2V0RWRpdFNlbGVjdCgpLnJlbW92ZUF0dHJpYnV0ZSgiZGlzYWJsZWQiKTpDLmdldEVkaXRTZWxlY3QoKS5zZXRBdHRyaWJ1dGUoImRpc2FibGVkIiwiZGlzYWJsZWQiKX0pO2M9bmV3IEN1c3RvbURpYWxvZyh0aGlzLGIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXthKHAuY2hlY2tlZCxrLmNoZWNrZWQsbS5jaGVja2VkLHEuY2hlY2tlZCxDLmdldExpbmsoKSxHLmNoZWNrZWQpfSksbnVsbCxteFJlc291cmNlcy5nZXQoImVtYmVkIiksCmwpO3RoaXMuc2hvd0RpYWxvZyhjLmNvbnRhaW5lciwyODAsMjgwLCEwLCEwKX07RWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZUVtYmVkSW1hZ2U9ZnVuY3Rpb24oYSxjLGQsZixsLG4sayxtKXtmdW5jdGlvbiBiKGIpe3ZhciBjPSIgIixnPSIiO2YmJihjPSIgb25jbGljaz1cIihmdW5jdGlvbihpbWcpe2lmKGltZy53bmQhPW51bGwmJiFpbWcud25kLmNsb3NlZCl7aW1nLnduZC5mb2N1cygpO31lbHNle3ZhciByPWZ1bmN0aW9uKGV2dCl7aWYoZXZ0LmRhdGE9PSdyZWFkeScmJmV2dC5zb3VyY2U9PWltZy53bmQpe2ltZy53bmQucG9zdE1lc3NhZ2UoZGVjb2RlVVJJQ29tcG9uZW50KGltZy5nZXRBdHRyaWJ1dGUoJ3NyYycpKSwnKicpO3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJyxyKTt9fTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScscik7aW1nLnduZD13aW5kb3cub3BlbignIitFZGl0b3JVaS5kcmF3SG9zdCsiLz9jbGllbnQ9MSZsaWdodGJveD0xIisKKGw/IiZlZGl0PV9ibGFuayI6IiIpKyhuPyImbGF5ZXJzPTEiOiIiKSsiJyk7fX0pKHRoaXMpO1wiIixnKz0iY3Vyc29yOnBvaW50ZXI7Iik7YSYmKGcrPSJtYXgtd2lkdGg6MTAwJTsiKTt2YXIgcD0iIjtkJiYocD0nIHdpZHRoPSInK01hdGgucm91bmQoZS53aWR0aCkrJyIgaGVpZ2h0PSInK01hdGgucm91bmQoZS5oZWlnaHQpKyciJyk7aygnPGltZyBzcmM9IicrYisnIicrcCsoIiIhPWc/JyBzdHlsZT0iJytnKyciJzoiIikrYysiLz4iKX12YXIgZT10aGlzLmVkaXRvci5ncmFwaC5nZXRHcmFwaEJvdW5kcygpO2lmKHRoaXMuaXNFeHBvcnRUb0NhbnZhcygpKXRoaXMuZWRpdG9yLmV4cG9ydFRvQ2FudmFzKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBjPWY/dGhpcy5nZXRGaWxlRGF0YSghMCk6bnVsbDthPXRoaXMuY3JlYXRlSW1hZ2VEYXRhVXJpKGEsYywicG5nIik7YihhKX0pLG51bGwsbnVsbCxudWxsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe20oe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJ1bmtub3duRXJyb3IiKX0pfSksCm51bGwsITAsZD8yOjEsbnVsbCxjKTtlbHNlIGlmKGM9dGhpcy5nZXRGaWxlRGF0YSghMCksZS53aWR0aCplLmhlaWdodDw9TUFYX0FSRUEmJmMubGVuZ3RoPD1NQVhfUkVRVUVTVF9TSVpFKXt2YXIgZz0iIjtkJiYoZz0iJnc9IitNYXRoLnJvdW5kKDIqZS53aWR0aCkrIiZoPSIrTWF0aC5yb3VuZCgyKmUuaGVpZ2h0KSk7dmFyIHA9bmV3IG14WG1sUmVxdWVzdChFWFBPUlRfVVJMLCJmb3JtYXQ9cG5nJmJhc2U2ND0xJmVtYmVkWG1sPSIrKGY/IjEiOiIwIikrZysiJnhtbD0iK2VuY29kZVVSSUNvbXBvbmVudChjKSk7cC5zZW5kKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7MjAwPD1wLmdldFN0YXR1cygpJiYyOTk+PXAuZ2V0U3RhdHVzKCk/YigiZGF0YTppbWFnZS9wbmc7YmFzZTY0LCIrcC5nZXRUZXh0KCkpOm0oe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJ1bmtub3duRXJyb3IiKX0pfSkpfWVsc2UgbSh7bWVzc2FnZTpteFJlc291cmNlcy5nZXQoImRyYXdpbmdUb29MYXJnZSIpfSl9OwpFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlRW1iZWRTdmc9ZnVuY3Rpb24oYSxjLGQsZixsLG4sayl7dmFyIGI9dGhpcy5lZGl0b3IuZ3JhcGguZ2V0U3ZnKG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsIWQpLGU9Yi5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYSIpO2lmKG51bGwhPWUpZm9yKHZhciBnPTA7ZzxlLmxlbmd0aDtnKyspe3ZhciBwPWVbZ10uZ2V0QXR0cmlidXRlKCJocmVmIik7bnVsbCE9cCYmIiMiPT1wLmNoYXJBdCgwKSYmIl9ibGFuayI9PWVbZ10uZ2V0QXR0cmlidXRlKCJ0YXJnZXQiKSYmZVtnXS5yZW1vdmVBdHRyaWJ1dGUoInRhcmdldCIpfWYmJmIuc2V0QXR0cmlidXRlKCJjb250ZW50Iix0aGlzLmdldEZpbGVEYXRhKCEwKSk7YyYmdGhpcy5lZGl0b3IuZ3JhcGguYWRkU3ZnU2hhZG93KGIpO2lmKGQpe3ZhciBtPSIgIixxPSIiO2YmJihtPSJvbmNsaWNrPVwiKGZ1bmN0aW9uKGltZyl7aWYoaW1nLnduZCE9bnVsbCYmIWltZy53bmQuY2xvc2VkKXtpbWcud25kLmZvY3VzKCk7fWVsc2V7dmFyIHI9ZnVuY3Rpb24oZXZ0KXtpZihldnQuZGF0YT09J3JlYWR5JyYmZXZ0LnNvdXJjZT09aW1nLnduZCl7aW1nLnduZC5wb3N0TWVzc2FnZShkZWNvZGVVUklDb21wb25lbnQoaW1nLmdldEF0dHJpYnV0ZSgnc3JjJykpLCcqJyk7d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLHIpO319O3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJyxyKTtpbWcud25kPXdpbmRvdy5vcGVuKCciKwpFZGl0b3JVaS5kcmF3SG9zdCsiLz9jbGllbnQ9MSZsaWdodGJveD0xIisobD8iJmVkaXQ9X2JsYW5rIjoiIikrKG4/IiZsYXllcnM9MSI6IiIpKyInKTt9fSkodGhpcyk7XCIiLHErPSJjdXJzb3I6cG9pbnRlcjsiKTthJiYocSs9Im1heC13aWR0aDoxMDAlOyIpO3RoaXMuZWRpdG9yLmNvbnZlcnRJbWFnZXMoYixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtrKCc8aW1nIHNyYz0iJytFZGl0b3IuY3JlYXRlU3ZnRGF0YVVyaShteFV0aWxzLmdldFhtbChhKSkrJyInKygiIiE9cT8nIHN0eWxlPSInK3ErJyInOiIiKSttKyIvPiIpfSkpfWVsc2UgcT0iIixmJiYoYi5zZXRBdHRyaWJ1dGUoIm9uY2xpY2siLCIoZnVuY3Rpb24oc3ZnKXt2YXIgc3JjPXdpbmRvdy5ldmVudC50YXJnZXR8fHdpbmRvdy5ldmVudC5zcmNFbGVtZW50O3doaWxlIChzcmMhPW51bGwmJnNyYy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIT0nYScpe3NyYz1zcmMucGFyZW50Tm9kZTt9aWYoc3JjPT1udWxsKXtpZihzdmcud25kIT1udWxsJiYhc3ZnLnduZC5jbG9zZWQpe3N2Zy53bmQuZm9jdXMoKTt9ZWxzZXt2YXIgcj1mdW5jdGlvbihldnQpe2lmKGV2dC5kYXRhPT0ncmVhZHknJiZldnQuc291cmNlPT1zdmcud25kKXtzdmcud25kLnBvc3RNZXNzYWdlKGRlY29kZVVSSUNvbXBvbmVudChzdmcuZ2V0QXR0cmlidXRlKCdjb250ZW50JykpLCcqJyk7d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLHIpO319O3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJyxyKTtzdmcud25kPXdpbmRvdy5vcGVuKCciKwpFZGl0b3JVaS5kcmF3SG9zdCsiLz9jbGllbnQ9MSZsaWdodGJveD0xIisobD8iJmVkaXQ9X2JsYW5rIjoiIikrKG4/IiZsYXllcnM9MSI6IiIpKyInKTt9fX0pKHRoaXMpOyIpLHErPSJjdXJzb3I6cG9pbnRlcjsiKSxhJiYoYT1wYXJzZUludChiLmdldEF0dHJpYnV0ZSgid2lkdGgiKSksYz1wYXJzZUludChiLmdldEF0dHJpYnV0ZSgiaGVpZ2h0IikpLGIuc2V0QXR0cmlidXRlKCJ2aWV3Qm94IiwiLTAuNSAtMC41ICIrYSsiICIrYykscSs9Im1heC13aWR0aDoxMDAlO21heC1oZWlnaHQ6IitjKyJweDsiLGIucmVtb3ZlQXR0cmlidXRlKCJoZWlnaHQiKSksIiIhPXEmJmIuc2V0QXR0cmlidXRlKCJzdHlsZSIscSksdGhpcy5lZGl0b3IuYWRkRm9udENzcyhiKSx0aGlzLmVkaXRvci5ncmFwaC5tYXRoRW5hYmxlZCYmdGhpcy5lZGl0b3IuYWRkTWF0aENzcyhiKSxrKG14VXRpbHMuZ2V0WG1sKGIpKX07RWRpdG9yVWkucHJvdG90eXBlLnRpbWVTaW5jZT1mdW5jdGlvbihhKXthPU1hdGguZmxvb3IoKG5ldyBEYXRlLQphKS8xRTMpO3ZhciBiPU1hdGguZmxvb3IoYS8zMTUzNkUzKTtpZigxPGIpcmV0dXJuIGIrIiAiK214UmVzb3VyY2VzLmdldCgieWVhcnMiKTtiPU1hdGguZmxvb3IoYS8yNTkyRTMpO2lmKDE8YilyZXR1cm4gYisiICIrbXhSZXNvdXJjZXMuZ2V0KCJtb250aHMiKTtiPU1hdGguZmxvb3IoYS84NjQwMCk7aWYoMTxiKXJldHVybiBiKyIgIitteFJlc291cmNlcy5nZXQoImRheXMiKTtiPU1hdGguZmxvb3IoYS8zNjAwKTtpZigxPGIpcmV0dXJuIGIrIiAiK214UmVzb3VyY2VzLmdldCgiaG91cnMiKTtiPU1hdGguZmxvb3IoYS82MCk7cmV0dXJuIDE8Yj9iKyIgIitteFJlc291cmNlcy5nZXQoIm1pbnV0ZXMiKToxPT1iP2IrIiAiK214UmVzb3VyY2VzLmdldCgibWludXRlIik6bnVsbH07RWRpdG9yVWkucHJvdG90eXBlLmRlY29kZU5vZGVJbnRvR3JhcGg9ZnVuY3Rpb24oYSxjKXtpZihudWxsIT1hKXt2YXIgYj1udWxsO2lmKCJkaWFncmFtIj09YS5ub2RlTmFtZSliPWE7ZWxzZSBpZigibXhmaWxlIj09CmEubm9kZU5hbWUpe3ZhciBlPWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpYWdyYW0iKTtpZigwPGUubGVuZ3RoKXt2YXIgYj1lWzBdLGQ9Yy5nZXRHbG9iYWxWYXJpYWJsZTtjLmdldEdsb2JhbFZhcmlhYmxlPWZ1bmN0aW9uKGEpe3JldHVybiJwYWdlIj09YT9iLmdldEF0dHJpYnV0ZSgibmFtZSIpfHxteFJlc291cmNlcy5nZXQoInBhZ2VXaXRoTnVtYmVyIixbMV0pOiJwYWdlbnVtYmVyIj09YT8xOmQuYXBwbHkodGhpcyxhcmd1bWVudHMpfX19bnVsbCE9YiYmKGE9RWRpdG9yLnBhcnNlRGlhZ3JhbU5vZGUoYikpfWU9dGhpcy5lZGl0b3IuZ3JhcGg7dHJ5e3RoaXMuZWRpdG9yLmdyYXBoPWMsdGhpcy5lZGl0b3Iuc2V0R3JhcGhYbWwoYSl9Y2F0Y2gobil7fWZpbmFsbHl7dGhpcy5lZGl0b3IuZ3JhcGg9ZX1yZXR1cm4gYX07RWRpdG9yVWkucHJvdG90eXBlLmdldFBuZ0ZpbGVQcm9wZXJ0aWVzPWZ1bmN0aW9uKGEpe3ZhciBiPTEsYz0wO2lmKG51bGwhPWEpe2lmKGEuaGFzQXR0cmlidXRlKCJzY2FsZSIpKXt2YXIgZD0KcGFyc2VGbG9hdChhLmdldEF0dHJpYnV0ZSgic2NhbGUiKSk7IWlzTmFOKGQpJiYwPGQmJihiPWQpfWEuaGFzQXR0cmlidXRlKCJib3JkZXIiKSYmKGQ9cGFyc2VJbnQoYS5nZXRBdHRyaWJ1dGUoImJvcmRlciIpKSwhaXNOYU4oZCkmJjA8ZCYmKGM9ZCkpfXJldHVybntzY2FsZTpiLGJvcmRlcjpjfX07RWRpdG9yVWkucHJvdG90eXBlLmdldEVtYmVkZGVkUG5nPWZ1bmN0aW9uKGEsYyxkLGYsbCl7dHJ5e3ZhciBiPXRoaXMuZWRpdG9yLmdyYXBoLGU9bnVsbCE9Yi50aGVtZXMmJiJkYXJrVGhlbWUiPT1iLmRlZmF1bHRUaGVtZU5hbWUsZz1udWxsO2lmKG51bGwhPWQmJjA8ZC5sZW5ndGgpYj10aGlzLmNyZWF0ZVRlbXBvcmFyeUdyYXBoKHRoaXMuZWRpdG9yLmdyYXBoLmdldFN0eWxlc2hlZXQoKSksZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChiLmNvbnRhaW5lciksdGhpcy5kZWNvZGVOb2RlSW50b0dyYXBoKHRoaXMuZWRpdG9yLmV4dHJhY3RHcmFwaE1vZGVsKG14VXRpbHMucGFyc2VYbWwoZCkuZG9jdW1lbnRFbGVtZW50LAohMCksYiksZz1kO2Vsc2UgaWYoZXx8bnVsbCE9dGhpcy5wYWdlcyYmdGhpcy5jdXJyZW50UGFnZSE9dGhpcy5wYWdlc1swXSl7dmFyIGI9dGhpcy5jcmVhdGVUZW1wb3JhcnlHcmFwaChiLmdldFN0eWxlc2hlZXQoKSkscD1iLmdldEdsb2JhbFZhcmlhYmxlLGs9dGhpcy5wYWdlc1swXTtiLmdldEdsb2JhbFZhcmlhYmxlPWZ1bmN0aW9uKGEpe3JldHVybiJwYWdlIj09YT9rLmdldE5hbWUoKToicGFnZW51bWJlciI9PWE/MTpwLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChiLmNvbnRhaW5lcik7Yi5tb2RlbC5zZXRSb290KGsucm9vdCl9dGhpcy5lZGl0b3IuZXhwb3J0VG9DYW52YXMobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oZSl7dHJ5e251bGw9PWcmJihnPXRoaXMuZ2V0RmlsZURhdGEoITAsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLCExKSk7dmFyIGQ9ZS50b0RhdGFVUkwoImltYWdlL3BuZyIpLGQ9RWRpdG9yLndyaXRlR3JhcGhNb2RlbFRvUG5nKGQsCiJ0RVh0IiwibXhmaWxlIixlbmNvZGVVUklDb21wb25lbnQoZykpO2EoZC5zdWJzdHJpbmcoZC5sYXN0SW5kZXhPZigiLCIpKzEpKTtiIT10aGlzLmVkaXRvci5ncmFwaCYmYi5jb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiLmNvbnRhaW5lcil9Y2F0Y2goQyl7bnVsbCE9YyYmYyhDKX19KSxudWxsLG51bGwsbnVsbCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsIT1jJiZjKGEpfSksbnVsbCxudWxsLGYsbnVsbCxiLnNoYWRvd1Zpc2libGUsbnVsbCxiLGwpfWNhdGNoKEUpe251bGwhPWMmJmMoRSl9fTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0RW1iZWRkZWRTdmc9ZnVuY3Rpb24oYSxjLGQsZixsLGssbSx0KXt0PW51bGwhPXQ/dDohMDttPWMuYmFja2dyb3VuZDttPT1teENvbnN0YW50cy5OT05FJiYobT1udWxsKTtrPWMuZ2V0U3ZnKG0sbnVsbCxudWxsLG51bGwsbnVsbCxrKTtjLnNoYWRvd1Zpc2libGUmJmMuYWRkU3ZnU2hhZG93KGspO251bGwhPWEmJgprLnNldEF0dHJpYnV0ZSgiY29udGVudCIsYSk7bnVsbCE9ZCYmay5zZXRBdHRyaWJ1dGUoInJlc291cmNlIixkKTtpZihudWxsIT1sKXRoaXMuZW1iZWRGb250cyhrLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3Q/dGhpcy5lZGl0b3IuY29udmVydEltYWdlcyhhLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2woKGY/IiI6Jzw/eG1sIHZlcnNpb249IjEuMCIgZW5jb2Rpbmc9IlVURi04Ij8+XG48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPlxuJykrbXhVdGlscy5nZXRYbWwoYSkpfSkpOmwoKGY/IiI6Jzw/eG1sIHZlcnNpb249IjEuMCIgZW5jb2Rpbmc9IlVURi04Ij8+XG48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPlxuJykrCm14VXRpbHMuZ2V0WG1sKGEpKX0pKTtlbHNlIHJldHVybihmPyIiOic8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSJVVEYtOCI/PlxuPCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj5cbicpK214VXRpbHMuZ2V0WG1sKGspfTtFZGl0b3JVaS5wcm90b3R5cGUuZW1iZWRGb250cz1mdW5jdGlvbihhLGMpe3RoaXMuZWRpdG9yLmxvYWRGb250cyhteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RyeXtudWxsIT10aGlzLmVkaXRvci5yZXNvbHZlZEZvbnRDc3MmJnRoaXMuZWRpdG9yLmFkZEZvbnRDc3MoYSx0aGlzLmVkaXRvci5yZXNvbHZlZEZvbnRDc3MpLHRoaXMuZWRpdG9yLmVtYmVkRXh0Rm9udHMobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7dHJ5e251bGwhPWImJnRoaXMuZWRpdG9yLmFkZEZvbnRDc3MoYSxiKSxjKGEpfWNhdGNoKHApe2MoYSl9fSkpfWNhdGNoKGcpe2MoYSl9fSkpfTsKRWRpdG9yVWkucHJvdG90eXBlLmV4cG9ydEltYWdlPWZ1bmN0aW9uKGEsYyxkLGYsbCxrLG0sdCxxLHgsRSxBKXtxPW51bGwhPXE/cToicG5nIjtpZih0aGlzLnNwaW5uZXIuc3Bpbihkb2N1bWVudC5ib2R5LG14UmVzb3VyY2VzLmdldCgiZXhwb3J0aW5nIikpKXt2YXIgYj10aGlzLmVkaXRvci5ncmFwaC5pc1NlbGVjdGlvbkVtcHR5KCk7ZD1udWxsIT1kP2Q6YjtudWxsPT10aGlzLnRodW1iSW1hZ2VDYWNoZSYmKHRoaXMudGh1bWJJbWFnZUNhY2hlPXt9KTt0cnl7dGhpcy5lZGl0b3IuZXhwb3J0VG9DYW52YXMobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5zcGlubmVyLnN0b3AoKTt0cnl7dGhpcy5zYXZlQ2FudmFzKGEsbD90aGlzLmdldEZpbGVEYXRhKCEwLG51bGwsbnVsbCxudWxsLGQsdCk6bnVsbCxxLG51bGw9PXRoaXMucGFnZXN8fDA9PXRoaXMucGFnZXMubGVuZ3RoLEUpfWNhdGNoKEQpeyJJbnZhbGlkIGltYWdlIj09RC5tZXNzYWdlP3RoaXMuZG93bmxvYWRGaWxlKHEpOgp0aGlzLmhhbmRsZUVycm9yKEQpfX0pLG51bGwsdGhpcy50aHVtYkltYWdlQ2FjaGUsbnVsbCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLnNwaW5uZXIuc3RvcCgpO3RoaXMuaGFuZGxlRXJyb3IoYSl9KSxudWxsLGQsYXx8MSxjLGYsbnVsbCxudWxsLGssbSx4LEEpfWNhdGNoKHope3RoaXMuc3Bpbm5lci5zdG9wKCksdGhpcy5oYW5kbGVFcnJvcih6KX19fTtFZGl0b3JVaS5wcm90b3R5cGUuaXNDb3JzRW5hYmxlZEZvclVybD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5lZGl0b3IuaXNDb3JzRW5hYmxlZEZvclVybChhKX07RWRpdG9yVWkucHJvdG90eXBlLmltcG9ydFhtbD1mdW5jdGlvbihhLGMsZCxmLGwpe2M9bnVsbCE9Yz9jOjA7ZD1udWxsIT1kP2Q6MDt2YXIgYj1bXTt0cnl7dmFyIGU9dGhpcy5lZGl0b3IuZ3JhcGg7aWYobnVsbCE9YSYmMDxhLmxlbmd0aCl7ZS5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgZz1teFV0aWxzLnBhcnNlWG1sKGEpO2E9e307CnZhciBwPXRoaXMuZWRpdG9yLmV4dHJhY3RHcmFwaE1vZGVsKGcuZG9jdW1lbnRFbGVtZW50LG51bGwhPXRoaXMucGFnZXMpO2lmKG51bGwhPXAmJiJteGZpbGUiPT1wLm5vZGVOYW1lJiZudWxsIT10aGlzLnBhZ2VzKXt2YXIgaz1wLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaWFncmFtIik7aWYoMT09ay5sZW5ndGgpcD1FZGl0b3IucGFyc2VEaWFncmFtTm9kZShrWzBdKSxudWxsIT10aGlzLmN1cnJlbnRQYWdlJiYoYVtrWzBdLmdldEF0dHJpYnV0ZSgiaWQiKV09dGhpcy5jdXJyZW50UGFnZS5nZXRJZCgpKTtlbHNlIGlmKDE8ay5sZW5ndGgpe3ZhciBnPVtdLG09MDtudWxsIT10aGlzLnBhZ2VzJiYxPT10aGlzLnBhZ2VzLmxlbmd0aCYmdGhpcy5pc0RpYWdyYW1FbXB0eSgpJiYoYVtrWzBdLmdldEF0dHJpYnV0ZSgiaWQiKV09dGhpcy5wYWdlc1swXS5nZXRJZCgpLHA9RWRpdG9yLnBhcnNlRGlhZ3JhbU5vZGUoa1swXSksZj0hMSxtPTEpO2Zvcig7bTxrLmxlbmd0aDttKyspe3ZhciBxPQprW21dLmdldEF0dHJpYnV0ZSgiaWQiKTtrW21dLnJlbW92ZUF0dHJpYnV0ZSgiaWQiKTt2YXIgQz10aGlzLnVwZGF0ZVBhZ2VSb290KG5ldyBEaWFncmFtUGFnZShrW21dKSk7YVtxXT1rW21dLmdldEF0dHJpYnV0ZSgiaWQiKTt2YXIgej10aGlzLnBhZ2VzLmxlbmd0aDtudWxsPT1DLmdldE5hbWUoKSYmQy5zZXROYW1lKG14UmVzb3VyY2VzLmdldCgicGFnZVdpdGhOdW1iZXIiLFt6KzFdKSk7ZS5tb2RlbC5leGVjdXRlKG5ldyBDaGFuZ2VQYWdlKHRoaXMsQyxDLHosITApKTtnLnB1c2goQyl9dGhpcy51cGRhdGVQYWdlTGlua3MoYSxnKX19aWYobnVsbCE9cCYmIm14R3JhcGhNb2RlbCI9PT1wLm5vZGVOYW1lJiYoYj1lLmltcG9ydEdyYXBoTW9kZWwocCxjLGQsZiksbnVsbCE9YikpZm9yKG09MDttPGIubGVuZ3RoO20rKyl0aGlzLnVwZGF0ZVBhZ2VMaW5rc0ZvckNlbGwoYSxiW21dKX1maW5hbGx5e2UubW9kZWwuZW5kVXBkYXRlKCl9fX1jYXRjaChEKXtpZihsKXRocm93IEQ7dGhpcy5oYW5kbGVFcnJvcihEKX1yZXR1cm4gYn07CkVkaXRvclVpLnByb3RvdHlwZS51cGRhdGVQYWdlTGlua3M9ZnVuY3Rpb24oYSxjKXtmb3IodmFyIGI9MDtiPGMubGVuZ3RoO2IrKyl0aGlzLnVwZGF0ZVBhZ2VMaW5rc0ZvckNlbGwoYSxjW2JdLnJvb3QpfTtFZGl0b3JVaS5wcm90b3R5cGUudXBkYXRlUGFnZUxpbmtzRm9yQ2VsbD1mdW5jdGlvbihhLGMpe3ZhciBiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLGU9dGhpcy5lZGl0b3IuZ3JhcGgsZD1lLmdldExpbmtGb3JDZWxsKGMpO251bGwhPWQmJmUuc2V0TGlua0ZvckNlbGwoYyx0aGlzLnVwZGF0ZVBhZ2VMaW5rKGEsZCkpO2lmKGUuaXNIdG1sTGFiZWwoYykpe2IuaW5uZXJIVE1MPWUuc2FuaXRpemVIdG1sKGUuZ2V0TGFiZWwoYykpO2Zvcih2YXIgZj1iLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJhIiksaz0hMSxtPTA7bTxmLmxlbmd0aDttKyspZD1mW21dLmdldEF0dHJpYnV0ZSgiaHJlZiIpLG51bGwhPWQmJihmW21dLnNldEF0dHJpYnV0ZSgiaHJlZiIsdGhpcy51cGRhdGVQYWdlTGluayhhLApkKSksaz0hMCk7ayYmZS5sYWJlbENoYW5nZWQoYyxiLmlubmVySFRNTCl9Zm9yKG09MDttPGUubW9kZWwuZ2V0Q2hpbGRDb3VudChjKTttKyspdGhpcy51cGRhdGVQYWdlTGlua3NGb3JDZWxsKGEsZS5tb2RlbC5nZXRDaGlsZEF0KGMsbSkpfTtFZGl0b3JVaS5wcm90b3R5cGUudXBkYXRlUGFnZUxpbms9ZnVuY3Rpb24oYSxjKXtpZigiZGF0YTpwYWdlL2lkLCI9PWMuc3Vic3RyaW5nKDAsMTMpKXt2YXIgYj1hW2Muc3Vic3RyaW5nKGMuaW5kZXhPZigiLCIpKzEpXTtjPW51bGwhPWI/ImRhdGE6cGFnZS9pZCwiK2I6bnVsbH1lbHNlIGlmKCJkYXRhOmFjdGlvbi9qc29uLCI9PWMuc3Vic3RyaW5nKDAsMTcpKXRyeXt2YXIgZT1KU09OLnBhcnNlKGMuc3Vic3RyaW5nKDE3KSk7aWYobnVsbCE9ZS5hY3Rpb25zKXtmb3IodmFyIGQ9MDtkPGUuYWN0aW9ucy5sZW5ndGg7ZCsrKXt2YXIgZj1lLmFjdGlvbnNbZF07bnVsbCE9Zi5vcGVuJiYiZGF0YTpwYWdlL2lkLCI9PWYub3Blbi5zdWJzdHJpbmcoMCwKMTMpJiYoYj1hW2Yub3Blbi5zdWJzdHJpbmcoZi5vcGVuLmluZGV4T2YoIiwiKSsxKV0sbnVsbCE9Yj9mLm9wZW49ImRhdGE6cGFnZS9pZCwiK2I6ZGVsZXRlIGYub3Blbil9Yz0iZGF0YTphY3Rpb24vanNvbiwiK0pTT04uc3RyaW5naWZ5KGUpfX1jYXRjaCh2KXt9cmV0dXJuIGN9O0VkaXRvclVpLnByb3RvdHlwZS5pc1JlbW90ZVZpc2lvRm9ybWF0PWZ1bmN0aW9uKGEpe3JldHVybi8oXC52KHNkfGR4KSkoJHxcPykvaS50ZXN0KGEpfHwvKFwudnMoc3x4KSkoJHxcPykvaS50ZXN0KGEpfTtFZGl0b3JVaS5wcm90b3R5cGUuaW1wb3J0VmlzaW89ZnVuY3Rpb24oYSxjLGQsZil7Zj1udWxsIT1mP2Y6YS5uYW1lO2Q9bnVsbCE9ZD9kOm14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuaGFuZGxlRXJyb3IoYSl9KTt2YXIgYj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMubG9hZGluZ0V4dGVuc2lvbnM9ITE7aWYodGhpcy5kb0ltcG9ydFZpc2lvKXt2YXIgYj10aGlzLmlzUmVtb3RlVmlzaW9Gb3JtYXQoZik7CnRyeXt2YXIgZT0iVU5LTk9XTi1WSVNJTyIsZz1mLmxhc3RJbmRleE9mKCIuIik7aWYoMDw9ZyYmZzxmLmxlbmd0aCllPWYuc3Vic3RyaW5nKGcrMSkudG9VcHBlckNhc2UoKTtlbHNle3ZhciBsPWYubGFzdEluZGV4T2YoIi8iKTswPD1sJiZsPGYubGVuZ3RoJiYoZj1mLnN1YnN0cmluZyhsKzEpKX1FZGl0b3JVaS5sb2dFdmVudCh7Y2F0ZWdvcnk6ZSsiLU1TLUlNUE9SVC1GSUxFIixhY3Rpb246ImZpbGVuYW1lXyIrZixsYWJlbDpiPyJyZW1vdGUiOiJsb2NhbCJ9KX1jYXRjaChFKXt9aWYoYilpZihudWxsPT1WU0RfQ09OVkVSVF9VUkx8fHRoaXMuaXNPZmZsaW5lKCkpZCh7bWVzc2FnZToiY29uZiI9PXRoaXMuZ2V0U2VydmljZU5hbWUoKT9teFJlc291cmNlcy5nZXQoInZzZE5vQ29uZmlnIik6bXhSZXNvdXJjZXMuZ2V0KCJzZXJ2aWNlVW5hdmFpbGFibGVPckJsb2NrZWQiKX0pO2Vsc2V7Yj1uZXcgRm9ybURhdGE7Yi5hcHBlbmQoImZpbGUxIixhLGYpO3ZhciBrPW5ldyBYTUxIdHRwUmVxdWVzdDsKay5vcGVuKCJQT1NUIixWU0RfQ09OVkVSVF9VUkwpO2sucmVzcG9uc2VUeXBlPSJibG9iIjt0aGlzLmFkZFJlbW90ZVNlcnZpY2VTZWN1cml0eUNoZWNrKGspO2sub25yZWFkeXN0YXRlY2hhbmdlPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7aWYoND09ay5yZWFkeVN0YXRlKWlmKDIwMDw9ay5zdGF0dXMmJjI5OT49ay5zdGF0dXMpdHJ5e3ZhciBhPWsucmVzcG9uc2U7aWYoInRleHQveG1sIj09YS50eXBlKXt2YXIgYj1uZXcgRmlsZVJlYWRlcjtiLm9ubG9hZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0cnl7YyhhLnRhcmdldC5yZXN1bHQpfWNhdGNoKHope2Qoe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJlcnJvckxvYWRpbmdGaWxlIil9KX19KTtiLnJlYWRBc1RleHQoYSl9ZWxzZSB0aGlzLmRvSW1wb3J0VmlzaW8oYSxjLGQsZil9Y2F0Y2goQyl7ZChDKX1lbHNlIGQoe30pfSk7ay5zZW5kKGIpfWVsc2UgdHJ5e3RoaXMuZG9JbXBvcnRWaXNpbyhhLGMsZCxmKX1jYXRjaChFKXtkKEUpfX1lbHNlIHRoaXMuc3Bpbm5lci5zdG9wKCksCnRoaXMuaGFuZGxlRXJyb3Ioe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJzZXJ2aWNlVW5hdmFpbGFibGVPckJsb2NrZWQiKX0pfSk7dGhpcy5kb0ltcG9ydFZpc2lvfHx0aGlzLmxvYWRpbmdFeHRlbnNpb25zfHx0aGlzLmlzT2ZmbGluZSghMCk/YigpOih0aGlzLmxvYWRpbmdFeHRlbnNpb25zPSEwLG14c2NyaXB0KCJqcy9leHRlbnNpb25zLm1pbi5qcyIsYikpfTtFZGl0b3JVaS5wcm90b3R5cGUuaW1wb3J0R3JhcGhNTD1mdW5jdGlvbihhLGMsZCl7ZD1udWxsIT1kP2Q6bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5oYW5kbGVFcnJvcihhKX0pO3ZhciBiPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5sb2FkaW5nRXh0ZW5zaW9ucz0hMTtpZih0aGlzLmRvSW1wb3J0R3JhcGhNTCl0cnl7dGhpcy5kb0ltcG9ydEdyYXBoTUwoYSxjLGQpfWNhdGNoKGwpe2QobCl9ZWxzZSB0aGlzLnNwaW5uZXIuc3RvcCgpLHRoaXMuaGFuZGxlRXJyb3Ioe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJzZXJ2aWNlVW5hdmFpbGFibGVPckJsb2NrZWQiKX0pfSk7CnRoaXMuZG9JbXBvcnRHcmFwaE1MfHx0aGlzLmxvYWRpbmdFeHRlbnNpb25zfHx0aGlzLmlzT2ZmbGluZSghMCk/YigpOih0aGlzLmxvYWRpbmdFeHRlbnNpb25zPSEwLG14c2NyaXB0KCJqcy9leHRlbnNpb25zLm1pbi5qcyIsYikpfTtFZGl0b3JVaS5wcm90b3R5cGUuZXhwb3J0VmlzaW89ZnVuY3Rpb24oKXt2YXIgYT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMubG9hZGluZ0V4dGVuc2lvbnM9ITE7aWYoInVuZGVmaW5lZCIhPT10eXBlb2YgVnNkeEV4cG9ydCl0cnl7KG5ldyBWc2R4RXhwb3J0KHRoaXMpKS5leHBvcnRDdXJyZW50RGlhZ3JhbXMoKXx8dGhpcy5oYW5kbGVFcnJvcih7bWVzc2FnZTpteFJlc291cmNlcy5nZXQoInVua25vd25FcnJvciIpfSl9Y2F0Y2goZSl7dGhpcy5oYW5kbGVFcnJvcihlKX1lbHNlIHRoaXMuc3Bpbm5lci5zdG9wKCksdGhpcy5oYW5kbGVFcnJvcih7bWVzc2FnZTpteFJlc291cmNlcy5nZXQoInNlcnZpY2VVbmF2YWlsYWJsZU9yQmxvY2tlZCIpfSl9KTsKInVuZGVmaW5lZCIhPT10eXBlb2YgVnNkeEV4cG9ydHx8dGhpcy5sb2FkaW5nRXh0ZW5zaW9uc3x8dGhpcy5pc09mZmxpbmUoITApP2EoKToodGhpcy5sb2FkaW5nRXh0ZW5zaW9ucz0hMCxteHNjcmlwdCgianMvZXh0ZW5zaW9ucy5taW4uanMiLGEpKX07RWRpdG9yVWkucHJvdG90eXBlLmNvbnZlcnRMdWNpZENoYXJ0PWZ1bmN0aW9uKGEsYyxkKXt2YXIgYj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMubG9hZGluZ0V4dGVuc2lvbnM9ITE7aWYoInVuZGVmaW5lZCIhPT10eXBlb2Ygd2luZG93Lkx1Y2lkSW1wb3J0ZXIpe3RyeXtFZGl0b3JVaS5sb2dFdmVudCh7Y2F0ZWdvcnk6IkxVQ0lEQ0hBUlQtSU1QT1JULUZJTEUiLGFjdGlvbjoic2l6ZV8iK2EubGVuZ3RofSksRWRpdG9yVWkuZGVidWcoImNvbnZlcnRMdWNpZENoYXJ0IixhKX1jYXRjaChsKXt9dHJ5e2MoTHVjaWRJbXBvcnRlci5pbXBvcnRTdGF0ZShKU09OLnBhcnNlKGEpKSl9Y2F0Y2gobCl7bnVsbCE9d2luZG93LmNvbnNvbGUmJgpjb25zb2xlLmVycm9yKGwpLGQobCl9fWVsc2UgZCh7bWVzc2FnZTpteFJlc291cmNlcy5nZXQoInNlcnZpY2VVbmF2YWlsYWJsZU9yQmxvY2tlZCIpfSl9KTsidW5kZWZpbmVkIiE9PXR5cGVvZiB3aW5kb3cuTHVjaWRJbXBvcnRlcnx8dGhpcy5sb2FkaW5nRXh0ZW5zaW9uc3x8dGhpcy5pc09mZmxpbmUoITApP3dpbmRvdy5zZXRUaW1lb3V0KGIsMCk6KHRoaXMubG9hZGluZ0V4dGVuc2lvbnM9ITAsIjEiPT11cmxQYXJhbXMuZGV2P214c2NyaXB0KCJqcy9kaWFncmFtbHkvRXh0ZW5zaW9ucy5qcyIsYik6bXhzY3JpcHQoImpzL2V4dGVuc2lvbnMubWluLmpzIixiKSl9O0VkaXRvclVpLnByb3RvdHlwZS5nZW5lcmF0ZU1lcm1haWRJbWFnZT1mdW5jdGlvbihhLGMsZCxmKXt2YXIgYj10aGlzLGU9ZnVuY3Rpb24oKXt0cnl7dGhpcy5sb2FkaW5nTWVybWFpZD0hMSxjPW51bGwhPWM/YzpFZGl0b3JVaS5kZWZhdWx0TWVybWFpZENvbmZpZyxjLnNlY3VyaXR5TGV2ZWw9InN0cmljdCIsYy5zdGFydE9uTG9hZD0KITEsbWVybWFpZC5tZXJtYWlkQVBJLmluaXRpYWxpemUoYyksbWVybWFpZC5tZXJtYWlkQVBJLnJlbmRlcigiZ2VNZXJtYWlkT3V0cHV0LSIrKG5ldyBEYXRlKS5nZXRUaW1lKCksYSxmdW5jdGlvbihhKXt0cnl7aWYobXhDbGllbnQuSVNfSUV8fG14Q2xpZW50LklTX0lFMTEpYT1hLnJlcGxhY2UoLyB4bWxuczpcUyo9Imh0dHA6XC9cL3d3dy53My5vcmdcL1hNTFwvMTk5OFwvbmFtZXNwYWNlIi9nLCIiKS5yZXBsYWNlKC8gKE5TIHhtbHxcUyopOnNwYWNlPSJwcmVzZXJ2ZSIvZywnIHhtbDpzcGFjZT0icHJlc2VydmUiJyk7dmFyIGM9bXhVdGlscy5wYXJzZVhtbChhKS5nZXRFbGVtZW50c0J5VGFnTmFtZSgic3ZnIik7aWYoMDxjLmxlbmd0aCl7dmFyIGU9cGFyc2VGbG9hdChjWzBdLmdldEF0dHJpYnV0ZSgid2lkdGgiKSksZz1wYXJzZUZsb2F0KGNbMF0uZ2V0QXR0cmlidXRlKCJoZWlnaHQiKSk7ZChiLmNvbnZlcnREYXRhVXJpKEVkaXRvci5jcmVhdGVTdmdEYXRhVXJpKGEpKSxlLApnKX1lbHNlIGYoe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJpbnZhbGlkSW5wdXQiKX0pfWNhdGNoKEUpe2YoRSl9fSl9Y2F0Y2godil7Zih2KX19OyJ1bmRlZmluZWQiIT09dHlwZW9mIG1lcm1haWR8fHRoaXMubG9hZGluZ01lcm1haWR8fHRoaXMuaXNPZmZsaW5lKCEwKT9lKCk6KHRoaXMubG9hZGluZ01lcm1haWQ9ITAsIjEiPT11cmxQYXJhbXMuZGV2P214c2NyaXB0KCJqcy9tZXJtYWlkL21lcm1haWQubWluLmpzIixlKTpteHNjcmlwdCgianMvZXh0ZW5zaW9ucy5taW4uanMiLGUpKX07RWRpdG9yVWkucHJvdG90eXBlLmdlbmVyYXRlUGxhbnRVbWxJbWFnZT1mdW5jdGlvbihhLGMsZCxmKXtmdW5jdGlvbiBiKGEsYixjKXtjMT1hPj4yO2MyPShhJjMpPDw0fGI+PjQ7YzM9KGImMTUpPDwyfGM+PjY7YzQ9YyY2MztyPSIiO3IrPWUoYzEmNjMpO3IrPWUoYzImNjMpO3IrPWUoYzMmNjMpO3JldHVybiByKz1lKGM0JjYzKX1mdW5jdGlvbiBlKGEpe2lmKDEwPmEpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoNDgrCmEpO2EtPTEwO2lmKDI2PmEpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoNjUrYSk7YS09MjY7aWYoMjY+YSlyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg5NythKTthLT0yNjtyZXR1cm4gMD09YT8iLSI6MT09YT8iXyI6Ij8ifXZhciBnPW5ldyBYTUxIdHRwUmVxdWVzdDtnLm9wZW4oIkdFVCIsKCJ0eHQiPT1jP1BMQU5UX1VSTCsiL3R4dC8iOiJwbmciPT1jP1BMQU5UX1VSTCsiL3BuZy8iOlBMQU5UX1VSTCsiL3N2Zy8iKStmdW5jdGlvbihhKXtyPSIiO2ZvcihpPTA7aTxhLmxlbmd0aDtpKz0zKXI9aSsyPT1hLmxlbmd0aD9yK2IoYS5jaGFyQ29kZUF0KGkpLGEuY2hhckNvZGVBdChpKzEpLDApOmkrMT09YS5sZW5ndGg/citiKGEuY2hhckNvZGVBdChpKSwwLDApOnIrYihhLmNoYXJDb2RlQXQoaSksYS5jaGFyQ29kZUF0KGkrMSksYS5jaGFyQ29kZUF0KGkrMikpO3JldHVybiByfShwYWtvLmRlZmxhdGVSYXcoYSx7dG86InN0cmluZyJ9KSksITApOyJ0eHQiIT1jJiYoZy5yZXNwb25zZVR5cGU9CiJibG9iIik7Zy5vbmxvYWQ9ZnVuY3Rpb24oYSl7aWYoMjAwPD10aGlzLnN0YXR1cyYmMzAwPnRoaXMuc3RhdHVzKWlmKCJ0eHQiPT1jKWQodGhpcy5yZXNwb25zZSk7ZWxzZXt2YXIgYj1uZXcgRmlsZVJlYWRlcjtiLnJlYWRBc0RhdGFVUkwodGhpcy5yZXNwb25zZSk7Yi5vbmxvYWRlbmQ9ZnVuY3Rpb24oYSl7dmFyIGM9bmV3IEltYWdlO2Mub25sb2FkPWZ1bmN0aW9uKCl7dHJ5e3ZhciBhPWMud2lkdGgsZT1jLmhlaWdodDtpZigwPT1hJiYwPT1lKXt2YXIgZz1iLnJlc3VsdCxsPWcuaW5kZXhPZigiLCIpLGs9ZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShhdG9iKGcuc3Vic3RyaW5nKGwrMSkpKSkscD1teFV0aWxzLnBhcnNlWG1sKGspLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJzdmciKTswPHAubGVuZ3RoJiYoYT1wYXJzZUZsb2F0KHBbMF0uZ2V0QXR0cmlidXRlKCJ3aWR0aCIpKSxlPXBhcnNlRmxvYXQocFswXS5nZXRBdHRyaWJ1dGUoImhlaWdodCIpKSl9ZChiLnJlc3VsdCxhLAplKX1jYXRjaChIKXtmKEgpfX07Yy5zcmM9Yi5yZXN1bHR9O2Iub25lcnJvcj1mdW5jdGlvbihhKXtmKGEpfX1lbHNlIGYoYSl9O2cub25lcnJvcj1mdW5jdGlvbihhKXtmKGEpfTtnLnNlbmQoKX07RWRpdG9yVWkucHJvdG90eXBlLmluc2VydEFzUHJlVGV4dD1mdW5jdGlvbihhLGMsZCl7dmFyIGI9dGhpcy5lZGl0b3IuZ3JhcGgsZT1udWxsO2IuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtlPWIuaW5zZXJ0VmVydGV4KG51bGwsbnVsbCwiPHByZT4iK2ErIjwvcHJlPiIsYyxkLDEsMSwidGV4dDtodG1sPTE7YWxpZ249bGVmdDt2ZXJ0aWNhbEFsaWduPXRvcDsiKSxiLnVwZGF0ZUNlbGxTaXplKGUsITApfWZpbmFsbHl7Yi5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfXJldHVybiBlfTtFZGl0b3JVaS5wcm90b3R5cGUuaW5zZXJ0VGV4dEF0PWZ1bmN0aW9uKGEsYyxkLGYsbCxrLG0pe2s9bnVsbCE9az9rOiEwO209bnVsbCE9bT9tOiEwO2lmKG51bGwhPWEpaWYoR3JhcGguZmlsZVN1cHBvcnQmJgohdGhpcy5pc09mZmxpbmUoKSYmKG5ldyBYTUxIdHRwUmVxdWVzdCkudXBsb2FkJiZ0aGlzLmlzUmVtb3RlRmlsZUZvcm1hdChhKSl0aGlzLnBhcnNlRmlsZShuZXcgQmxvYihbYS5yZXBsYWNlKC9ccysvZywiICIpXSx7dHlwZToiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtIn0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpezQ9PWEucmVhZHlTdGF0ZSYmMjAwPD1hLnN0YXR1cyYmMjk5Pj1hLnN0YXR1cyYmdGhpcy5lZGl0b3IuZ3JhcGguc2V0U2VsZWN0aW9uQ2VsbHModGhpcy5pbnNlcnRUZXh0QXQoYS5yZXNwb25zZVRleHQsYyxkLCEwKSl9KSk7ZWxzZSBpZigiZGF0YToiPT1hLnN1YnN0cmluZygwLDUpfHwhdGhpcy5pc09mZmxpbmUoKSYmKGx8fC9cLihnaWZ8anBnfGpwZWd8dGlmZnxwbmd8c3ZnKSQvaS50ZXN0KGEpKSl7dmFyIGI9dGhpcy5lZGl0b3IuZ3JhcGg7aWYoImRhdGE6YXBwbGljYXRpb24vcGRmO2Jhc2U2NCwiPT1hLnN1YnN0cmluZygwLDI4KSl7dmFyIGU9CkVkaXRvci5leHRyYWN0R3JhcGhNb2RlbEZyb21QZGYoYSk7aWYobnVsbCE9ZSYmMDxlLmxlbmd0aClyZXR1cm4gdGhpcy5pbXBvcnRYbWwoZSxjLGQsaywhMCl9aWYoImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwiPT1hLnN1YnN0cmluZygwLDIyKSYmKGU9dGhpcy5leHRyYWN0R3JhcGhNb2RlbEZyb21QbmcoYSksbnVsbCE9ZSYmMDxlLmxlbmd0aCkpcmV0dXJuIHRoaXMuaW1wb3J0WG1sKGUsYyxkLGssITApO2lmKCJkYXRhOmltYWdlL3N2Zyt4bWw7Ij09YS5zdWJzdHJpbmcoMCwxOSkpdHJ5e2U9bnVsbDsiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwiPT1hLnN1YnN0cmluZygwLDI2KT8oZT1hLnN1YnN0cmluZyhhLmluZGV4T2YoIiwiKSsxKSxlPXdpbmRvdy5hdG9iJiYhbXhDbGllbnQuSVNfU0Y/YXRvYihlKTpCYXNlNjQuZGVjb2RlKGUsITApKTplPWRlY29kZVVSSUNvbXBvbmVudChhLnN1YnN0cmluZyhhLmluZGV4T2YoIiwiKSsxKSk7dmFyIGc9dGhpcy5pbXBvcnRYbWwoZSwKYyxkLGssITApO2lmKDA8Zy5sZW5ndGgpcmV0dXJuIGd9Y2F0Y2goQSl7fXRoaXMubG9hZEltYWdlKGEsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oZSl7aWYoImRhdGE6Ij09YS5zdWJzdHJpbmcoMCw1KSl0aGlzLnJlc2l6ZUltYWdlKGUsYSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGUsZil7Yi5zZXRTZWxlY3Rpb25DZWxsKGIuaW5zZXJ0VmVydGV4KG51bGwsbnVsbCwiIixiLnNuYXAoYyksYi5zbmFwKGQpLGUsZiwic2hhcGU9aW1hZ2U7dmVydGljYWxMYWJlbFBvc2l0aW9uPWJvdHRvbTtsYWJlbEJhY2tncm91bmRDb2xvcj0jZmZmZmZmO3ZlcnRpY2FsQWxpZ249dG9wO2FzcGVjdD1maXhlZDtpbWFnZUFzcGVjdD0wO2ltYWdlPSIrdGhpcy5jb252ZXJ0RGF0YVVyaShhKSsiOyIpKX0pLG0sdGhpcy5tYXhJbWFnZVNpemUpO2Vsc2V7dmFyIGY9TWF0aC5taW4oMSxNYXRoLm1pbih0aGlzLm1heEltYWdlU2l6ZS9lLndpZHRoLHRoaXMubWF4SW1hZ2VTaXplL2UuaGVpZ2h0KSksCmc9TWF0aC5yb3VuZChlLndpZHRoKmYpO2U9TWF0aC5yb3VuZChlLmhlaWdodCpmKTtiLnNldFNlbGVjdGlvbkNlbGwoYi5pbnNlcnRWZXJ0ZXgobnVsbCxudWxsLCIiLGIuc25hcChjKSxiLnNuYXAoZCksZyxlLCJzaGFwZT1pbWFnZTt2ZXJ0aWNhbExhYmVsUG9zaXRpb249Ym90dG9tO2xhYmVsQmFja2dyb3VuZENvbG9yPSNmZmZmZmY7dmVydGljYWxBbGlnbj10b3A7YXNwZWN0PWZpeGVkO2ltYWdlQXNwZWN0PTA7aW1hZ2U9IithKyI7IikpfX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGU9bnVsbDtiLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7ZT1iLmluc2VydFZlcnRleChiLmdldERlZmF1bHRQYXJlbnQoKSxudWxsLGEsYi5zbmFwKGMpLGIuc25hcChkKSwxLDEsInRleHQ7IisoZj8iaHRtbD0xOyI6IiIpKSxiLnVwZGF0ZUNlbGxTaXplKGUpLGIuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJ0ZXh0SW5zZXJ0ZWQiLCJjZWxscyIsW2VdKSl9ZmluYWxseXtiLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9Yi5zZXRTZWxlY3Rpb25DZWxsKGUpfSkpfWVsc2V7YT0KR3JhcGguemFwR3JlbWxpbnMobXhVdGlscy50cmltKGEpKTtpZih0aGlzLmlzQ29tcGF0aWJsZVN0cmluZyhhKSlyZXR1cm4gdGhpcy5pbXBvcnRYbWwoYSxjLGQsayk7aWYoMDxhLmxlbmd0aClpZih0aGlzLmlzTHVjaWRDaGFydERhdGEoYSkpdGhpcy5jb252ZXJ0THVjaWRDaGFydChhLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3RoaXMuZWRpdG9yLmdyYXBoLnNldFNlbGVjdGlvbkNlbGxzKHRoaXMuaW1wb3J0WG1sKGIsYyxkLGspKTshdGhpcy5pc09mZmxpbmUoKSYmKC8uKlwuZGlhZ3JhbXNcLm5ldCQvLnRlc3Qod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKXx8Ly4qXC5hcHBzcG90XC5jb20kLy50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSl8fC8uKlwuZHJhd1wuaW8kLy50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSkpJiZ0aGlzLnNob3dCYW5uZXIoIkx1Y2lkQ2hhcnRJbXBvcnRTdXJ2ZXkiLG14UmVzb3VyY2VzLmdldCgibm90U2F0aXNmaWVkV2l0aEltcG9ydCIpLApteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3ZhciBiPW5ldyBGZWVkYmFja0RpYWxvZyh0aGlzLCJMdWNpZGNoYXJ0IEltcG9ydCBGZWVkYmFjayIsITAsYSk7dGhpcy5zaG93RGlhbG9nKGIuY29udGFpbmVyLDYxMCwzNjAsITAsITEpO2IuaW5pdCgpfSkpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5oYW5kbGVFcnJvcihhKX0pKTtlbHNle2I9dGhpcy5lZGl0b3IuZ3JhcGg7bD1udWxsO2IuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtsPWIuaW5zZXJ0VmVydGV4KGIuZ2V0RGVmYXVsdFBhcmVudCgpLG51bGwsIiIsYi5zbmFwKGMpLGIuc25hcChkKSwxLDEsInRleHQ7d2hpdGVTcGFjZT13cmFwOyIrKGY/Imh0bWw9MTsiOiIiKSk7Yi5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInRleHRJbnNlcnRlZCIsImNlbGxzIixbbF0pKTsiPCI9PWEuY2hhckF0KDApJiZhLmluZGV4T2YoIj4iKT09YS5sZW5ndGgtMSYmKGE9bXhVdGlscy5odG1sRW50aXRpZXMoYSkpOwphLmxlbmd0aD50aGlzLm1heFRleHRCeXRlcyYmKGE9YS5zdWJzdHJpbmcoMCx0aGlzLm1heFRleHRCeXRlcykrIi4uLiIpO2wudmFsdWU9YTtiLnVwZGF0ZUNlbGxTaXplKGwpO2lmKDA8dGhpcy5tYXhUZXh0V2lkdGgmJmwuZ2VvbWV0cnkud2lkdGg+dGhpcy5tYXhUZXh0V2lkdGgpe3ZhciBwPWIuZ2V0UHJlZmVycmVkU2l6ZUZvckNlbGwobCx0aGlzLm1heFRleHRXaWR0aCk7bC5nZW9tZXRyeS53aWR0aD1wLndpZHRoO2wuZ2VvbWV0cnkuaGVpZ2h0PXAuaGVpZ2h0fUdyYXBoLmlzTGluayhsLnZhbHVlKSYmYi5zZXRMaW5rRm9yQ2VsbChsLGwudmFsdWUpO2wuZ2VvbWV0cnkud2lkdGgrPWIuZ3JpZFNpemU7bC5nZW9tZXRyeS5oZWlnaHQrPWIuZ3JpZFNpemV9ZmluYWxseXtiLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9cmV0dXJuW2xdfX1yZXR1cm5bXX07RWRpdG9yVWkucHJvdG90eXBlLmZvcm1hdEZpbGVTaXplPWZ1bmN0aW9uKGEpe3ZhciBiPS0xO2RvIGEvPTEwMjQsYisrO3doaWxlKDEwMjQ8CmEpO3JldHVybiBNYXRoLm1heChhLC4xKS50b0ZpeGVkKDEpKyIga0I7IE1COyBHQjsgVEI7UEI7RUI7WkI7WUIiLnNwbGl0KCI7IilbYl19O0VkaXRvclVpLnByb3RvdHlwZS5jb252ZXJ0RGF0YVVyaT1mdW5jdGlvbihhKXtpZigiZGF0YToiPT1hLnN1YnN0cmluZygwLDUpKXt2YXIgYj1hLmluZGV4T2YoIjsiKTswPGImJihhPWEuc3Vic3RyaW5nKDAsYikrYS5zdWJzdHJpbmcoYS5pbmRleE9mKCIsIixiKzEpKSl9cmV0dXJuIGF9O0VkaXRvclVpLnByb3RvdHlwZS5pc1JlbW90ZUZpbGVGb3JtYXQ9ZnVuY3Rpb24oYSxjKXtyZXR1cm4vKFwiY29udGVudFR5cGVcIjpccypcImFwcGxpY2F0aW9uXC9nbGlmZnlcK2pzb25cIikvLnRlc3QoYSl9O0VkaXRvclVpLnByb3RvdHlwZS5pc0x1Y2lkQ2hhcnREYXRhPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiYoJ3sic3RhdGUiOiJ7XFwiUHJvcGVydGllc1xcIjonPT1hLnN1YnN0cmluZygwLDI2KXx8J3siUHJvcGVydGllcyI6Jz09YS5zdWJzdHJpbmcoMCwKMTQpKX07RWRpdG9yVWkucHJvdG90eXBlLmltcG9ydExvY2FsRmlsZT1mdW5jdGlvbihhLGMpe2lmKGEmJkdyYXBoLmZpbGVTdXBwb3J0KXtpZihudWxsPT10aGlzLmltcG9ydEZpbGVJbnB1dEVsdCl7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTtiLnNldEF0dHJpYnV0ZSgidHlwZSIsImZpbGUiKTtteEV2ZW50LmFkZExpc3RlbmVyKGIsImNoYW5nZSIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtudWxsIT1iLmZpbGVzJiYodGhpcy5pbXBvcnRGaWxlcyhiLmZpbGVzLG51bGwsbnVsbCx0aGlzLm1heEltYWdlU2l6ZSksYi50eXBlPSIiLGIudHlwZT0iZmlsZSIsYi52YWx1ZT0iIil9KSk7Yi5zdHlsZS5kaXNwbGF5PSJub25lIjtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGIpO3RoaXMuaW1wb3J0RmlsZUlucHV0RWx0PWJ9dGhpcy5pbXBvcnRGaWxlSW5wdXRFbHQuY2xpY2soKX1lbHNle3dpbmRvdy5vcGVuTmV3PSExO3dpbmRvdy5vcGVuS2V5PSJpbXBvcnQiOwppZighYyl7dmFyIGU9RWRpdG9yLnVzZUxvY2FsU3RvcmFnZTtFZGl0b3IudXNlTG9jYWxTdG9yYWdlPSFhfXdpbmRvdy5vcGVuRmlsZT1uZXcgT3BlbkZpbGUobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5oaWRlRGlhbG9nKGEpfSkpO3dpbmRvdy5vcGVuRmlsZS5zZXRDb25zdW1lcihteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIpe2lmKG51bGwhPWImJkdyYXBoLmZpbGVTdXBwb3J0JiYvKFwudihkeHxzZHg/KSkoJHxcPykvaS50ZXN0KGIpKXt2YXIgYz1uZXcgQmxvYihbYV0se3R5cGU6ImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSJ9KTt0aGlzLmltcG9ydFZpc2lvKGMsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5pbXBvcnRYbWwoYSwwLDAsITApfSksbnVsbCxiKX1lbHNlIHRoaXMuZWRpdG9yLmdyYXBoLnNldFNlbGVjdGlvbkNlbGxzKHRoaXMuaW1wb3J0WG1sKGEsMCwwLCEwKSl9KSk7dGhpcy5zaG93RGlhbG9nKChuZXcgT3BlbkRpYWxvZyh0aGlzKSkuY29udGFpbmVyLAozNjAsMjIwLCEwLCEwLGZ1bmN0aW9uKCl7d2luZG93Lm9wZW5GaWxlPW51bGx9KTtpZighYyl7dmFyIGQ9dGhpcy5kaWFsb2csZj1kLmNsb3NlO3RoaXMuZGlhbG9nLmNsb3NlPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe0VkaXRvci51c2VMb2NhbFN0b3JhZ2U9ZTtmLmFwcGx5KGQsYXJndW1lbnRzKTthJiZudWxsPT10aGlzLmdldEN1cnJlbnRGaWxlKCkmJiIxIiE9dXJsUGFyYW1zLmVtYmVkJiZ0aGlzLnNob3dTcGxhc2goKX0pfX19O0VkaXRvclVpLnByb3RvdHlwZS5pbXBvcnRaaXBGaWxlPWZ1bmN0aW9uKGEsYyxkKXt2YXIgYj10aGlzLGU9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmxvYWRpbmdFeHRlbnNpb25zPSExOyJ1bmRlZmluZWQiIT09dHlwZW9mIEpTWmlwP0pTWmlwLmxvYWRBc3luYyhhKS50aGVuKGZ1bmN0aW9uKGUpe2lmKDA9PU9iamVjdC5rZXlzKGUuZmlsZXMpLmxlbmd0aClkKCk7ZWxzZXt2YXIgZj0wLGcsbD0hMTtlLmZvckVhY2goZnVuY3Rpb24oYSwKYil7dmFyIGU9Yi5uYW1lLnRvTG93ZXJDYXNlKCk7ImRpYWdyYW0vZGlhZ3JhbS54bWwiPT1lPyhsPSEwLGIuYXN5bmMoInN0cmluZyIpLnRoZW4oZnVuY3Rpb24oYSl7MD09YS5pbmRleE9mKCI8bXhmaWxlICIpP2MoYSk6ZCgpfSkpOjA9PWUuaW5kZXhPZigidmVyc2lvbnMvIikmJihlPXBhcnNlSW50KGUuc3Vic3RyKDkpKSxlPmYmJihmPWUsZz1iKSl9KTswPGY/Zy5hc3luYygic3RyaW5nIikudGhlbihmdW5jdGlvbihlKXshYi5pc09mZmxpbmUoKSYmKG5ldyBYTUxIdHRwUmVxdWVzdCkudXBsb2FkJiZiLmlzUmVtb3RlRmlsZUZvcm1hdChlLGEubmFtZSk/Yi5wYXJzZUZpbGUobmV3IEJsb2IoW2VdLHt0eXBlOiJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0ifSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7ND09YS5yZWFkeVN0YXRlJiYoMjAwPD1hLnN0YXR1cyYmMjk5Pj1hLnN0YXR1cz9jKGEucmVzcG9uc2VUZXh0KTpkKCkpfSksYS5uYW1lKTpkKCl9KTpsfHxkKCl9fSwKZnVuY3Rpb24oYSl7ZChhKX0pOmQoKX0pOyJ1bmRlZmluZWQiIT09dHlwZW9mIEpTWmlwfHx0aGlzLmxvYWRpbmdFeHRlbnNpb25zfHx0aGlzLmlzT2ZmbGluZSghMCk/ZSgpOih0aGlzLmxvYWRpbmdFeHRlbnNpb25zPSEwLG14c2NyaXB0KCJqcy9leHRlbnNpb25zLm1pbi5qcyIsZSkpfTtFZGl0b3JVaS5wcm90b3R5cGUuaW1wb3J0RmlsZT1mdW5jdGlvbihhLGMsZCxmLGwsayxtLHQscSx4LEUpe3g9bnVsbCE9eD94OiEwO3ZhciBiPSExLGU9bnVsbCxnPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7bnVsbCE9YSYmIjxteGxpYnJhcnkiPT1hLnN1YnN0cmluZygwLDEwKT90aGlzLmxvYWRMaWJyYXJ5KG5ldyBMb2NhbExpYnJhcnkodGhpcyxhLG0pKTpiPXRoaXMuaW1wb3J0WG1sKGEsZCxmLHgpO251bGwhPXQmJnQoYil9KTsiaW1hZ2UiPT1jLnN1YnN0cmluZygwLDUpPyhxPSExLCJpbWFnZS9wbmciPT1jLnN1YnN0cmluZygwLDkpJiYoYz1FP251bGw6CnRoaXMuZXh0cmFjdEdyYXBoTW9kZWxGcm9tUG5nKGEpLG51bGwhPWMmJjA8Yy5sZW5ndGgmJihlPXRoaXMuaW1wb3J0WG1sKGMsZCxmLHgpLHE9ITApKSxxfHwoYz10aGlzLmVkaXRvci5ncmFwaCxFPWEuaW5kZXhPZigiOyIpLDA8RSYmKGE9YS5zdWJzdHJpbmcoMCxFKSthLnN1YnN0cmluZyhhLmluZGV4T2YoIiwiLEUrMSkpKSx4JiZjLmlzR3JpZEVuYWJsZWQoKSYmKGQ9Yy5zbmFwKGQpLGY9Yy5zbmFwKGYpKSxlPVtjLmluc2VydFZlcnRleChudWxsLG51bGwsIiIsZCxmLGwsaywic2hhcGU9aW1hZ2U7dmVydGljYWxMYWJlbFBvc2l0aW9uPWJvdHRvbTtsYWJlbEJhY2tncm91bmRDb2xvcj0jZmZmZmZmO3ZlcnRpY2FsQWxpZ249dG9wO2FzcGVjdD1maXhlZDtpbWFnZUFzcGVjdD0wO2ltYWdlPSIrYSsiOyIpXSkpOi8oXC4qPGdyYXBobWwgKS8udGVzdChhKT8oYj0hMCx0aGlzLmltcG9ydEdyYXBoTUwoYSxnKSk6bnVsbCE9cSYmbnVsbCE9bSYmKC8oXC52KGR4fHNkeD8pKSgkfFw/KS9pLnRlc3QobSl8fAovKFwudnMoeHxzeD8pKSgkfFw/KS9pLnRlc3QobSkpPyhiPSEwLHRoaXMuaW1wb3J0VmlzaW8ocSxnKSk6IXRoaXMuaXNPZmZsaW5lKCkmJihuZXcgWE1MSHR0cFJlcXVlc3QpLnVwbG9hZCYmdGhpcy5pc1JlbW90ZUZpbGVGb3JtYXQoYSxtKT8oYj0hMCx0aGlzLnBhcnNlRmlsZShudWxsIT1xP3E6bmV3IEJsb2IoW2FdLHt0eXBlOiJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0ifSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7ND09YS5yZWFkeVN0YXRlJiYoMjAwPD1hLnN0YXR1cyYmMjk5Pj1hLnN0YXR1cz9nKGEucmVzcG9uc2VUZXh0KTpudWxsIT10JiZ0KG51bGwpKX0pLG0pKTowPT1hLmluZGV4T2YoIlBLIikmJm51bGwhPXE/KGI9ITAsdGhpcy5pbXBvcnRaaXBGaWxlKHEsZyxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2U9dGhpcy5pbnNlcnRUZXh0QXQodGhpcy52YWxpZGF0ZUZpbGVEYXRhKGEpLGQsZiwhMCxudWxsLHgpO3QoZSl9KSkpOi8oXC52KHNkfGR4KSkoJHxcPykvaS50ZXN0KG0pfHwKLyhcLnZzKHN8eCkpKCR8XD8pL2kudGVzdChtKXx8KGU9dGhpcy5pbnNlcnRUZXh0QXQodGhpcy52YWxpZGF0ZUZpbGVEYXRhKGEpLGQsZiwhMCxudWxsLHgpKTtifHxudWxsPT10fHx0KGUpO3JldHVybiBlfTtFZGl0b3JVaS5wcm90b3R5cGUuaW1wb3J0RmlsZXM9ZnVuY3Rpb24oYSxjLGQsZixsLGssbSx0LHEseCxFLEEpe2Y9bnVsbCE9Zj9mOnRoaXMubWF4SW1hZ2VTaXplO3g9bnVsbCE9eD94OnRoaXMubWF4SW1hZ2VCeXRlczt2YXIgYj1udWxsIT1jJiZudWxsIT1kLGU9ITA7Yz1udWxsIT1jP2M6MDtkPW51bGwhPWQ/ZDowO3ZhciBnPSExO2lmKCFteENsaWVudC5JU19DSFJPTUVBUFAmJm51bGwhPWEpZm9yKHZhciBwPUV8fHRoaXMucmVzYW1wbGVUaHJlc2hvbGQsbj0wO248YS5sZW5ndGg7bisrKWlmKCJpbWFnZS8iPT1hW25dLnR5cGUuc3Vic3RyaW5nKDAsNikmJmFbbl0uc2l6ZT5wKXtnPSEwO2JyZWFrfXZhciB5PW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGc9CnRoaXMuZWRpdG9yLmdyYXBoLHA9Zy5ncmlkU2l6ZTtsPW51bGwhPWw/bDpteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGMsZSxkLGYsZyxsLGsscCl7dHJ5e3JldHVybiBudWxsIT1hJiYiPG14bGlicmFyeSI9PWEuc3Vic3RyaW5nKDAsMTApPyh0aGlzLnNwaW5uZXIuc3RvcCgpLHRoaXMubG9hZExpYnJhcnkobmV3IExvY2FsTGlicmFyeSh0aGlzLGEsbCkpLG51bGwpOnRoaXMuaW1wb3J0RmlsZShhLGMsZSxkLGYsZyxsLGsscCxiLEEpfWNhdGNoKFUpe3JldHVybiB0aGlzLmhhbmRsZUVycm9yKFUpLG51bGx9fSk7az1udWxsIT1rP2s6bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7Zy5zZXRTZWxlY3Rpb25DZWxscyhhKX0pO2lmKHRoaXMuc3Bpbm5lci5zcGluKGRvY3VtZW50LmJvZHksbXhSZXNvdXJjZXMuZ2V0KCJsb2FkaW5nIikpKWZvcih2YXIgbj1hLmxlbmd0aCxxPW4seT1bXSx2PW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYil7eVthXT1iO2lmKDA9PQotLXEpe3RoaXMuc3Bpbm5lci5zdG9wKCk7aWYobnVsbCE9dCl0KHkpO2Vsc2V7dmFyIGM9W107Zy5nZXRNb2RlbCgpLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgZT0wO2U8eS5sZW5ndGg7ZSsrKXt2YXIgZD15W2VdKCk7bnVsbCE9ZCYmKGM9Yy5jb25jYXQoZCkpfX1maW5hbGx5e2cuZ2V0TW9kZWwoKS5lbmRVcGRhdGUoKX19ayhjKX19KSx6PTA7ejxuO3orKylteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXt2YXIgaz1hW2JdO2lmKG51bGwhPWspe3ZhciBuPW5ldyBGaWxlUmVhZGVyO24ub25sb2FkPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2lmKG51bGw9PW18fG0oaykpaWYoImltYWdlLyI9PWsudHlwZS5zdWJzdHJpbmcoMCw2KSlpZigiaW1hZ2Uvc3ZnIj09ay50eXBlLnN1YnN0cmluZygwLDkpKXt2YXIgbj1hLnRhcmdldC5yZXN1bHQsdD1uLmluZGV4T2YoIiwiKSxxPWRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoYXRvYihuLnN1YnN0cmluZyh0KzEpKSkpLAp1PW14VXRpbHMucGFyc2VYbWwocSkscT11LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJzdmciKTtpZigwPHEubGVuZ3RoKXt2YXIgcT1xWzBdLHk9QT9udWxsOnEuZ2V0QXR0cmlidXRlKCJjb250ZW50Iik7bnVsbCE9eSYmIjwiIT15LmNoYXJBdCgwKSYmIiUiIT15LmNoYXJBdCgwKSYmKHk9dW5lc2NhcGUod2luZG93LmF0b2I/YXRvYih5KTpCYXNlNjQuZGVjb2RlKHksITApKSk7bnVsbCE9eSYmIiUiPT15LmNoYXJBdCgwKSYmKHk9ZGVjb2RlVVJJQ29tcG9uZW50KHkpKTtudWxsPT15fHwiPG14ZmlsZSAiIT09eS5zdWJzdHJpbmcoMCw4KSYmIjxteEdyYXBoTW9kZWwgIiE9PXkuc3Vic3RyaW5nKDAsMTQpP3YoYixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RyeXtpZihuLnN1YnN0cmluZygwLHQrMSksbnVsbCE9dSl7dmFyIGE9dS5nZXRFbGVtZW50c0J5VGFnTmFtZSgic3ZnIik7aWYoMDxhLmxlbmd0aCl7dmFyIGU9YVswXSxtPWUuZ2V0QXR0cmlidXRlKCJ3aWR0aCIpLHE9CmUuZ2V0QXR0cmlidXRlKCJoZWlnaHQiKSxtPW51bGwhPW0mJiIlIiE9bS5jaGFyQXQobS5sZW5ndGgtMSk/cGFyc2VGbG9hdChtKTpOYU4scT1udWxsIT1xJiYiJSIhPXEuY2hhckF0KHEubGVuZ3RoLTEpP3BhcnNlRmxvYXQocSk6TmFOLHg9ZS5nZXRBdHRyaWJ1dGUoInZpZXdCb3giKTtpZihudWxsPT14fHwwPT14Lmxlbmd0aCllLnNldEF0dHJpYnV0ZSgidmlld0JveCIsIjAgMCAiK20rIiAiK3EpO2Vsc2UgaWYoaXNOYU4obSl8fGlzTmFOKHEpKXt2YXIgeT14LnNwbGl0KCIgIik7Mzx5Lmxlbmd0aCYmKG09cGFyc2VGbG9hdCh5WzJdKSxxPXBhcnNlRmxvYXQoeVszXSkpfW49RWRpdG9yLmNyZWF0ZVN2Z0RhdGFVcmkobXhVdGlscy5nZXRYbWwoZSkpO3ZhciB2PU1hdGgubWluKDEsTWF0aC5taW4oZi9NYXRoLm1heCgxLG0pKSxmL01hdGgubWF4KDEscSkpLHo9bChuLGsudHlwZSxjK2IqcCxkK2IqcCxNYXRoLm1heCgxLE1hdGgucm91bmQobSp2KSksTWF0aC5tYXgoMSxNYXRoLnJvdW5kKHEqCnYpKSxrLm5hbWUpO2lmKGlzTmFOKG0pfHxpc05hTihxKSl7dmFyIEI9bmV3IEltYWdlO0Iub25sb2FkPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bT1NYXRoLm1heCgxLEIud2lkdGgpO3E9TWF0aC5tYXgoMSxCLmhlaWdodCk7elswXS5nZW9tZXRyeS53aWR0aD1tO3pbMF0uZ2VvbWV0cnkuaGVpZ2h0PXE7ZS5zZXRBdHRyaWJ1dGUoInZpZXdCb3giLCIwIDAgIittKyIgIitxKTtuPUVkaXRvci5jcmVhdGVTdmdEYXRhVXJpKG14VXRpbHMuZ2V0WG1sKGUpKTt2YXIgYT1uLmluZGV4T2YoIjsiKTswPGEmJihuPW4uc3Vic3RyaW5nKDAsYSkrbi5zdWJzdHJpbmcobi5pbmRleE9mKCIsIixhKzEpKSk7Zy5zZXRDZWxsU3R5bGVzKCJpbWFnZSIsbixbelswXV0pfSk7Qi5zcmM9RWRpdG9yLmNyZWF0ZVN2Z0RhdGFVcmkobXhVdGlscy5nZXRYbWwoZSkpfXJldHVybiB6fX19Y2F0Y2goVyl7fXJldHVybiBudWxsfSkpOnYoYixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3JldHVybiBsKHksCiJ0ZXh0L3htbCIsYytiKnAsZCtiKnAsMCwwLGsubmFtZSl9KSl9ZWxzZSB2KGIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0pKX1lbHNle3E9ITE7aWYoImltYWdlL3BuZyI9PWsudHlwZSl7dmFyIHo9QT9udWxsOnRoaXMuZXh0cmFjdEdyYXBoTW9kZWxGcm9tUG5nKGEudGFyZ2V0LnJlc3VsdCk7aWYobnVsbCE9eiYmMDx6Lmxlbmd0aCl7dmFyIEI9bmV3IEltYWdlO0Iuc3JjPWEudGFyZ2V0LnJlc3VsdDt2KGIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gbCh6LCJ0ZXh0L3htbCIsYytiKnAsZCtiKnAsQi53aWR0aCxCLmhlaWdodCxrLm5hbWUpfSkpO3E9ITB9fXF8fChteENsaWVudC5JU19DSFJPTUVBUFA/KHRoaXMuc3Bpbm5lci5zdG9wKCksdGhpcy5zaG93RXJyb3IobXhSZXNvdXJjZXMuZ2V0KCJlcnJvciIpLG14UmVzb3VyY2VzLmdldCgiZHJhZ0FuZERyb3BOb3RTdXBwb3J0ZWQiKSxteFJlc291cmNlcy5nZXQoImNhbmNlbCIpLApteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe30pLG51bGwsbXhSZXNvdXJjZXMuZ2V0KCJvayIpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5hY3Rpb25zLmdldCgiaW1wb3J0IikuZnVuY3QoKX0pKSk6dGhpcy5sb2FkSW1hZ2UoYS50YXJnZXQucmVzdWx0LG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGcpe3RoaXMucmVzaXplSW1hZ2UoZyxhLnRhcmdldC5yZXN1bHQsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oZyxtLG4pe3YoYixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2lmKG51bGwhPWcmJmcubGVuZ3RoPHgpe3ZhciB0PWUmJnRoaXMuaXNSZXNhbXBsZUltYWdlKGEudGFyZ2V0LnJlc3VsdCxFKT9NYXRoLm1pbigxLE1hdGgubWluKGYvbSxmL24pKToxO3JldHVybiBsKGcsay50eXBlLGMrYipwLGQrYipwLE1hdGgucm91bmQobSp0KSxNYXRoLnJvdW5kKG4qdCksay5uYW1lKX10aGlzLmhhbmRsZUVycm9yKHttZXNzYWdlOm14UmVzb3VyY2VzLmdldCgiaW1hZ2VUb29CaWciKX0pOwpyZXR1cm4gbnVsbH0pKX0pLGUsZixFKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5oYW5kbGVFcnJvcih7bWVzc2FnZTpteFJlc291cmNlcy5nZXQoImludmFsaWRPck1pc3NpbmdGaWxlIil9KX0pKSl9ZWxzZSBuPWEudGFyZ2V0LnJlc3VsdCxsKG4say50eXBlLGMrYipwLGQrYipwLDI0MCwxNjAsay5uYW1lLGZ1bmN0aW9uKGEpe3YoYixmdW5jdGlvbigpe3JldHVybiBhfSl9LGspfSk7LyhcLnYoZHh8c2R4PykpKCR8XD8pL2kudGVzdChrLm5hbWUpfHwvKFwudnMoeHxzeD8pKSgkfFw/KS9pLnRlc3Qoay5uYW1lKT9sKG51bGwsay50eXBlLGMrYipwLGQrYipwLDI0MCwxNjAsay5uYW1lLGZ1bmN0aW9uKGEpe3YoYixmdW5jdGlvbigpe3JldHVybiBhfSl9LGspOiJpbWFnZSI9PWsudHlwZS5zdWJzdHJpbmcoMCw1KXx8ImFwcGxpY2F0aW9uL3BkZiI9PWsudHlwZT9uLnJlYWRBc0RhdGFVUkwoayk6bi5yZWFkQXNUZXh0KGspfX0pKHopfSk7aWYoZyl7Zz1bXTsKZm9yKG49MDtuPGEubGVuZ3RoO24rKylnLnB1c2goYVtuXSk7YT1nO3RoaXMuY29uZmlybUltYWdlUmVzaXplKGZ1bmN0aW9uKGEpe2U9YTt5KCl9LHEpfWVsc2UgeSgpfTtFZGl0b3JVaS5wcm90b3R5cGUuY29uZmlybUltYWdlUmVzaXplPWZ1bmN0aW9uKGEsYyl7Yz1udWxsIT1jP2M6ITE7dmFyIGI9bnVsbCE9dGhpcy5zcGlubmVyJiZudWxsIT10aGlzLnNwaW5uZXIucGF1c2U/dGhpcy5zcGlubmVyLnBhdXNlKCk6ZnVuY3Rpb24oKXt9LGU9aXNMb2NhbFN0b3JhZ2V8fG14Q2xpZW50LklTX0NIUk9NRUFQUD9teFNldHRpbmdzLmdldFJlc2l6ZUltYWdlcygpOm51bGwsZD1mdW5jdGlvbihlLGQpe2lmKGV8fGMpbXhTZXR0aW5ncy5zZXRSZXNpemVJbWFnZXMoZT9kOm51bGwpLG14U2V0dGluZ3Muc2F2ZSgpO2IoKTthKGQpfTtudWxsPT1lfHxjP3RoaXMuc2hvd0RpYWxvZygobmV3IENvbmZpcm1EaWFsb2codGhpcyxteFJlc291cmNlcy5nZXQoInJlc2l6ZUxhcmdlSW1hZ2VzIiksCmZ1bmN0aW9uKGEpe2QoYSwhMCl9LGZ1bmN0aW9uKGEpe2QoYSwhMSl9LG14UmVzb3VyY2VzLmdldCgicmVzaXplIiksbXhSZXNvdXJjZXMuZ2V0KCJhY3R1YWxTaXplIiksJzxpbWcgc3R5bGU9Im1hcmdpbi10b3A6OHB4OyIgc3JjPSInK0VkaXRvci5sb1Jlc0ltYWdlKyciLz4nLCc8aW1nIHN0eWxlPSJtYXJnaW4tdG9wOjhweDsiIHNyYz0iJytFZGl0b3IuaGlSZXNJbWFnZSsnIi8+Jyxpc0xvY2FsU3RvcmFnZXx8bXhDbGllbnQuSVNfQ0hST01FQVBQKSkuY29udGFpbmVyLDM0MCxpc0xvY2FsU3RvcmFnZXx8bXhDbGllbnQuSVNfQ0hST01FQVBQPzIyMDoyMDAsITAsITApOmQoITEsZSl9O0VkaXRvclVpLnByb3RvdHlwZS5wYXJzZUZpbGU9ZnVuY3Rpb24oYSxjLGQpe2Q9bnVsbCE9ZD9kOmEubmFtZTt2YXIgYj1uZXcgRm9ybURhdGE7Yi5hcHBlbmQoImZvcm1hdCIsInhtbCIpO2IuYXBwZW5kKCJ1cGZpbGUiLGEsZCk7dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O2Uub3BlbigiUE9TVCIsCk9QRU5fVVJMKTtlLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2MoZSl9O2Uuc2VuZChiKTt0cnl7RWRpdG9yVWkubG9nRXZlbnQoe2NhdGVnb3J5OiJHTElGRlktSU1QT1JULUZJTEUiLGFjdGlvbjoic2l6ZV8iK2Euc2l6ZX0pfWNhdGNoKG4pe319O0VkaXRvclVpLnByb3RvdHlwZS5pc1Jlc2FtcGxlSW1hZ2U9ZnVuY3Rpb24oYSxjKXtjPW51bGwhPWM/Yzp0aGlzLnJlc2FtcGxlVGhyZXNob2xkO3JldHVybiBhLmxlbmd0aD5jfTtFZGl0b3JVaS5wcm90b3R5cGUucmVzaXplSW1hZ2U9ZnVuY3Rpb24oYSxjLGQsZixsLGspe2w9bnVsbCE9bD9sOnRoaXMubWF4SW1hZ2VTaXplO3ZhciBiPU1hdGgubWF4KDEsYS53aWR0aCksZT1NYXRoLm1heCgxLGEuaGVpZ2h0KTtpZihmJiZ0aGlzLmlzUmVzYW1wbGVJbWFnZShjLGspKXRyeXt2YXIgZz1NYXRoLm1heChiL2wsZS9sKTtpZigxPGcpe3ZhciBtPU1hdGgucm91bmQoYi9nKSxwPU1hdGgucm91bmQoZS9nKSxuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpOwpuLndpZHRoPW07bi5oZWlnaHQ9cDtuLmdldENvbnRleHQoIjJkIikuZHJhd0ltYWdlKGEsMCwwLG0scCk7dmFyIHE9bi50b0RhdGFVUkwoKTtpZihxLmxlbmd0aDxjLmxlbmd0aCl7dmFyIHo9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIik7ei53aWR0aD1tO3ouaGVpZ2h0PXA7dmFyIEQ9ei50b0RhdGFVUkwoKTtxIT09RCYmKGM9cSxiPW0sZT1wKX19fWNhdGNoKEcpe31kKGMsYixlKX07RWRpdG9yVWkucHJvdG90eXBlLmV4dHJhY3RHcmFwaE1vZGVsRnJvbVBuZz1mdW5jdGlvbihhKXtyZXR1cm4gRWRpdG9yLmV4dHJhY3RHcmFwaE1vZGVsRnJvbVBuZyhhKX07RWRpdG9yVWkucHJvdG90eXBlLmxvYWRJbWFnZT1mdW5jdGlvbihhLGMsZCl7dHJ5e3ZhciBiPW5ldyBJbWFnZTtiLm9ubG9hZD1mdW5jdGlvbigpe2Iud2lkdGg9MDxiLndpZHRoP2Iud2lkdGg6MTIwO2IuaGVpZ2h0PTA8Yi5oZWlnaHQ/Yi5oZWlnaHQ6MTIwO2MoYil9O251bGwhPWQmJihiLm9uZXJyb3I9ZCk7CmIuc3JjPWF9Y2F0Y2gobCl7aWYobnVsbCE9ZClkKGwpO2Vsc2UgdGhyb3cgbDt9fTt2YXIgZD1FZGl0b3JVaS5wcm90b3R5cGUuaW5pdDtFZGl0b3JVaS5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe214U3RlbmNpbFJlZ2lzdHJ5LmFsbG93RXZhbD1teFN0ZW5jaWxSZWdpc3RyeS5hbGxvd0V2YWwmJiF0aGlzLmlzT2ZmbGluZUFwcCgpOyJ1bmRlZmluZWQiIT09dHlwZW9mIHdpbmRvdy5teFNldHRpbmdzJiYodGhpcy5mb3JtYXRXaWR0aD1teFNldHRpbmdzLmdldEZvcm1hdFdpZHRoKCkpO3ZhciBhPXRoaXMsYz10aGlzLmVkaXRvci5ncmFwaDtjLmNlbGxFZGl0b3IuZWRpdFBsYW50VW1sRGF0YT1mdW5jdGlvbihiLGUsZCl7dmFyIGY9SlNPTi5wYXJzZShkKTtlPW5ldyBUZXh0YXJlYURpYWxvZyhhLG14UmVzb3VyY2VzLmdldCgicGxhbnRVbWwiKSsiOiIsZi5kYXRhLGZ1bmN0aW9uKGUpe251bGwhPWUmJmEuc3Bpbm5lci5zcGluKGRvY3VtZW50LmJvZHksbXhSZXNvdXJjZXMuZ2V0KCJpbnNlcnRpbmciKSkmJgphLmdlbmVyYXRlUGxhbnRVbWxJbWFnZShlLGYuZm9ybWF0LGZ1bmN0aW9uKGQsZyxsKXthLnNwaW5uZXIuc3RvcCgpO2MuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtpZigidHh0Ij09Zi5mb3JtYXQpYy5sYWJlbENoYW5nZWQoYiwiPHByZT4iK2QrIjwvcHJlPiIpLGMudXBkYXRlQ2VsbFNpemUoYiwhMCk7ZWxzZXtjLnNldENlbGxTdHlsZXMoImltYWdlIixhLmNvbnZlcnREYXRhVXJpKGQpLFtiXSk7dmFyIGs9Yy5tb2RlbC5nZXRHZW9tZXRyeShiKTtudWxsIT1rJiYoaz1rLmNsb25lKCksay53aWR0aD1nLGsuaGVpZ2h0PWwsYy5jZWxsc1Jlc2l6ZWQoW2JdLFtrXSwhMSkpfWMuc2V0QXR0cmlidXRlRm9yQ2VsbChiLCJwbGFudFVtbERhdGEiLEpTT04uc3RyaW5naWZ5KHtkYXRhOmUsZm9ybWF0OmYuZm9ybWF0fSkpfWZpbmFsbHl7Yy5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX0sZnVuY3Rpb24oYil7YS5oYW5kbGVFcnJvcihiKX0pfSxudWxsLG51bGwsNDAwLDIyMCk7YS5zaG93RGlhbG9nKGUuY29udGFpbmVyLAo0MjAsMzAwLCEwLCEwKTtlLmluaXQoKX07Yy5jZWxsRWRpdG9yLmVkaXRNZXJtYWlkRGF0YT1mdW5jdGlvbihiLGUsZCl7dmFyIGY9SlNPTi5wYXJzZShkKTtlPW5ldyBUZXh0YXJlYURpYWxvZyhhLG14UmVzb3VyY2VzLmdldCgibWVybWFpZCIpKyI6IixmLmRhdGEsZnVuY3Rpb24oZSl7bnVsbCE9ZSYmYS5zcGlubmVyLnNwaW4oZG9jdW1lbnQuYm9keSxteFJlc291cmNlcy5nZXQoImluc2VydGluZyIpKSYmYS5nZW5lcmF0ZU1lcm1haWRJbWFnZShlLGYuY29uZmlnLGZ1bmN0aW9uKGQsZyxsKXthLnNwaW5uZXIuc3RvcCgpO2MuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtjLnNldENlbGxTdHlsZXMoImltYWdlIixkLFtiXSk7dmFyIGs9Yy5tb2RlbC5nZXRHZW9tZXRyeShiKTtudWxsIT1rJiYoaz1rLmNsb25lKCksay53aWR0aD1NYXRoLm1heChrLndpZHRoLGcpLGsuaGVpZ2h0PU1hdGgubWF4KGsuaGVpZ2h0LGwpLGMuY2VsbHNSZXNpemVkKFtiXSxba10sITEpKTtjLnNldEF0dHJpYnV0ZUZvckNlbGwoYiwKIm1lcm1haWREYXRhIixKU09OLnN0cmluZ2lmeSh7ZGF0YTplLGNvbmZpZzpmLmNvbmZpZ30sbnVsbCwyKSl9ZmluYWxseXtjLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9fSxmdW5jdGlvbihiKXthLmhhbmRsZUVycm9yKGIpfSl9LG51bGwsbnVsbCw0MDAsMjIwKTthLnNob3dEaWFsb2coZS5jb250YWluZXIsNDIwLDMwMCwhMCwhMCk7ZS5pbml0KCl9O3ZhciBmPWMuY2VsbEVkaXRvci5zdGFydEVkaXRpbmc7Yy5jZWxsRWRpdG9yLnN0YXJ0RWRpdGluZz1mdW5jdGlvbihiLGMpe3RyeXt2YXIgZT10aGlzLmdyYXBoLmdldEF0dHJpYnV0ZUZvckNlbGwoYiwicGxhbnRVbWxEYXRhIik7bnVsbCE9ZT90aGlzLmVkaXRQbGFudFVtbERhdGEoYixjLGUpOihlPXRoaXMuZ3JhcGguZ2V0QXR0cmlidXRlRm9yQ2VsbChiLCJtZXJtYWlkRGF0YSIpLG51bGwhPWU/dGhpcy5lZGl0TWVybWFpZERhdGEoYixjLGUpOmYuYXBwbHkodGhpcyxhcmd1bWVudHMpKX1jYXRjaChHKXthLmhhbmRsZUVycm9yKEcpfX07CmMuZ2V0TGlua1RpdGxlPWZ1bmN0aW9uKGIpe3JldHVybiBhLmdldExpbmtUaXRsZShiKX07Yy5jdXN0b21MaW5rQ2xpY2tlZD1mdW5jdGlvbihiKXt2YXIgYz0hMTt0cnl7YS5oYW5kbGVDdXN0b21MaW5rKGIpLGM9ITB9Y2F0Y2goRCl7YS5oYW5kbGVFcnJvcihEKX1yZXR1cm4gY307dmFyIGs9dGhpcy5jbGVhckRlZmF1bHRTdHlsZTt0aGlzLmNsZWFyRGVmYXVsdFN0eWxlPWZ1bmN0aW9uKCl7ay5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3RoaXMuaXNPZmZsaW5lKCl8fCJ1bmRlZmluZWQiPT09dHlwZW9mIHdpbmRvdy5FZGl0RGF0YURpYWxvZ3x8KEVkaXREYXRhRGlhbG9nLnBsYWNlaG9sZGVySGVscExpbms9Imh0dHBzOi8vZGVzay5kcmF3LmlvL3N1cHBvcnQvc29sdXRpb25zL2FydGljbGVzLzE2MDAwMDUxOTc5Iik7dmFyIGw9YS5lZGl0b3IuZ2V0RWRpdEJsYW5rVXJsO3RoaXMuZWRpdG9yLmdldEVkaXRCbGFua1VybD1mdW5jdGlvbihiKXtiPW51bGwhPWI/YjoiIjtpZihudWxsIT0KYS5wYWdlcyYmbnVsbCE9YS5jdXJyZW50UGFnZSlmb3IodmFyIGM9MDtjPGEucGFnZXMubGVuZ3RoO2MrKylpZihhLnBhZ2VzW2NdPT1hLmN1cnJlbnRQYWdlKXswPGMmJihiKz0oMDxiLmxlbmd0aD8iJiI6Ij8iKSsicGFnZT0iK2MpO2JyZWFrfSIxIj09dXJsUGFyYW1zLmRldiYmKGIrPSgwPGIubGVuZ3RoPyImIjoiPyIpKyJkZXY9MSZkcmF3ZGV2PTEiKTtyZXR1cm4gbC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBtPWMuYWRkQ2xpY2tIYW5kbGVyO2MuYWRkQ2xpY2tIYW5kbGVyPWZ1bmN0aW9uKGEsYixlKXt2YXIgZD1iO2I9ZnVuY3Rpb24oYSxiKXtpZihudWxsPT1iKXt2YXIgZT1teEV2ZW50LmdldFNvdXJjZShhKTsiYSI9PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSYmKGI9ZS5nZXRBdHRyaWJ1dGUoImhyZWYiKSl9bnVsbCE9YiYmYy5pc0N1c3RvbUxpbmsoYikmJihteEV2ZW50LmlzVG91Y2hFdmVudChhKXx8IW14RXZlbnQuaXNQb3B1cFRyaWdnZXIoYSkpJiZjLmN1c3RvbUxpbmtDbGlja2VkKGIpJiYKbXhFdmVudC5jb25zdW1lKGEpO251bGwhPWQmJmQoYSxiKX07bS5jYWxsKHRoaXMsYSxiLGUpfTtkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtteENsaWVudC5JU19TVkcmJnRoaXMuZWRpdG9yLmdyYXBoLmFkZFN2Z1NoYWRvdyhjLnZpZXcuY2FudmFzLm93bmVyU1ZHRWxlbWVudCxudWxsLCEwKTthLmFjdGlvbnMuZ2V0KCJwcmludCIpLmZ1bmN0PWZ1bmN0aW9uKCl7YS5zaG93RGlhbG9nKChuZXcgUHJpbnREaWFsb2coYSkpLmNvbnRhaW5lciwzNjAsbnVsbCE9YS5wYWdlcyYmMTxhLnBhZ2VzLmxlbmd0aD80NTA6MzcwLCEwLCEwKX07dGhpcy5kZWZhdWx0RmlsZW5hbWU9bXhSZXNvdXJjZXMuZ2V0KCJ1bnRpdGxlZERpYWdyYW0iKTt2YXIgcT1jLmdldEV4cG9ydFZhcmlhYmxlcztjLmdldEV4cG9ydFZhcmlhYmxlcz1mdW5jdGlvbigpe3ZhciBiPXEuYXBwbHkodGhpcyxhcmd1bWVudHMpLGM9YS5nZXRDdXJyZW50RmlsZSgpO251bGwhPWMmJihiLmZpbGVuYW1lPWMuZ2V0VGl0bGUoKSk7CmIucGFnZWNvdW50PW51bGwhPWEucGFnZXM/YS5wYWdlcy5sZW5ndGg6MTtiLnBhZ2U9bnVsbCE9YS5jdXJyZW50UGFnZT9hLmN1cnJlbnRQYWdlLmdldE5hbWUoKToiIjtiLnBhZ2VudW1iZXI9bnVsbCE9YS5wYWdlcyYmbnVsbCE9YS5jdXJyZW50UGFnZT9teFV0aWxzLmluZGV4T2YoYS5wYWdlcyxhLmN1cnJlbnRQYWdlKSsxOjE7cmV0dXJuIGJ9O3ZhciB0PWMuZ2V0R2xvYmFsVmFyaWFibGU7Yy5nZXRHbG9iYWxWYXJpYWJsZT1mdW5jdGlvbihiKXt2YXIgYz1hLmdldEN1cnJlbnRGaWxlKCk7cmV0dXJuImZpbGVuYW1lIj09YiYmbnVsbCE9Yz9jLmdldFRpdGxlKCk6InBhZ2UiPT1iJiZudWxsIT1hLmN1cnJlbnRQYWdlP2EuY3VycmVudFBhZ2UuZ2V0TmFtZSgpOiJwYWdlbnVtYmVyIj09Yj9udWxsIT1hLmN1cnJlbnRQYWdlJiZudWxsIT1hLnBhZ2VzP214VXRpbHMuaW5kZXhPZihhLnBhZ2VzLGEuY3VycmVudFBhZ2UpKzE6MToicGFnZWNvdW50Ij09Yj9udWxsIT1hLnBhZ2VzPwphLnBhZ2VzLmxlbmd0aDoxOnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgeT1jLmxhYmVsTGlua0NsaWNrZWQ7Yy5sYWJlbExpbmtDbGlja2VkPWZ1bmN0aW9uKGEsYixlKXt2YXIgZD1iLmdldEF0dHJpYnV0ZSgiaHJlZiIpO2lmKG51bGw9PWR8fCFjLmlzQ3VzdG9tTGluayhkKXx8IW14RXZlbnQuaXNUb3VjaEV2ZW50KGUpJiZteEV2ZW50LmlzUG9wdXBUcmlnZ2VyKGUpKXkuYXBwbHkodGhpcyxhcmd1bWVudHMpO2Vsc2V7aWYoIWMuaXNFbmFibGVkKCl8fG51bGwhPWEmJmMuaXNDZWxsTG9ja2VkKGEuY2VsbCkpYy5jdXN0b21MaW5rQ2xpY2tlZChkKSxjLmdldFJ1YmJlcmJhbmQoKS5yZXNldCgpO214RXZlbnQuY29uc3VtZShlKX19O3RoaXMuZWRpdG9yLmdldE9yQ3JlYXRlRmlsZW5hbWU9ZnVuY3Rpb24oKXt2YXIgYj1hLmRlZmF1bHRGaWxlbmFtZSxjPWEuZ2V0Q3VycmVudEZpbGUoKTtudWxsIT1jJiYoYj1udWxsIT1jLmdldFRpdGxlKCk/Yy5nZXRUaXRsZSgpOmIpO3JldHVybiBifTsKdmFyIHg9dGhpcy5hY3Rpb25zLmdldCgicHJpbnQiKTt4LnNldEVuYWJsZWQoIW14Q2xpZW50LklTX0lPU3x8IW5hdmlnYXRvci5zdGFuZGFsb25lKTt4LnZpc2libGU9eC5pc0VuYWJsZWQoKTtpZighdGhpcy5lZGl0b3IuY2hyb21lbGVzc3x8dGhpcy5lZGl0b3IuZWRpdGFibGUpdGhpcy5rZXlIYW5kbGVyLmJpbmRBY3Rpb24oNzAsITAsImZpbmQiKSx0aGlzLmtleUhhbmRsZXIuYmluZEFjdGlvbig2NywhMCwiY29weVN0eWxlIiwhMCksdGhpcy5rZXlIYW5kbGVyLmJpbmRBY3Rpb24oODYsITAsInBhc3RlU3R5bGUiLCEwKSx0aGlzLmtleUhhbmRsZXIuYmluZEFjdGlvbig3NywhMCwiZWRpdEdlb21ldHJ5IiwhMCksdGhpcy5rZXlIYW5kbGVyLmJpbmRBY3Rpb24oODgsITAsImluc2VydFRleHQiLCEwKSx0aGlzLmtleUhhbmRsZXIuYmluZEFjdGlvbig3NSwhMCwiaW5zZXJ0UmVjdGFuZ2xlIiksdGhpcy5rZXlIYW5kbGVyLmJpbmRBY3Rpb24oNzUsITAsImluc2VydEVsbGlwc2UiLAohMCksbXhDbGllbnQuSVNfQ0hST01FQVBQfHxFZGl0b3JVaS5pc0VsZWN0cm9uQXBwfHwodGhpcy5hbHRTaGlmdEFjdGlvbnNbODNdPSJzeW5jaHJvbml6ZSIpLHRoaXMuaW5zdGFsbEltYWdlUGFzdGVIYW5kbGVyKCksdGhpcy5pbnN0YWxsTmF0aXZlQ2xpcGJvYXJkSGFuZGxlcigpO3RoaXMuc3Bpbm5lcj10aGlzLmNyZWF0ZVNwaW5uZXIoZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aC8yLTIsTWF0aC5tYXgoZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHR8fDAsZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodHx8MCkvMiwyNCk7R3JhcGguZmlsZVN1cHBvcnQmJnRoaXMuZWRpdG9yLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuRURJVElOR19TVEFSVEVELG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZWRpdG9yLmdyYXBoLGM9Yi5jZWxsRWRpdG9yLnRleHQyLGU9bnVsbDtudWxsIT1jJiYobXhFdmVudC5hZGRMaXN0ZW5lcihjLCJkcmFnbGVhdmUiLApmdW5jdGlvbihhKXtudWxsIT1lJiYoZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpLGU9bnVsbCk7YS5zdG9wUHJvcGFnYXRpb24oKTthLnByZXZlbnREZWZhdWx0KCl9KSxteEV2ZW50LmFkZExpc3RlbmVyKGMsImRyYWdvdmVyIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsPT1lJiYoIW14Q2xpZW50LklTX0lFfHwxMDxkb2N1bWVudC5kb2N1bWVudE1vZGUpJiYoZT10aGlzLmhpZ2hsaWdodEVsZW1lbnQoYykpO2Euc3RvcFByb3BhZ2F0aW9uKCk7YS5wcmV2ZW50RGVmYXVsdCgpfSkpLG14RXZlbnQuYWRkTGlzdGVuZXIoYywiZHJvcCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bnVsbCE9ZSYmKGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKSxlPW51bGwpO2lmKDA8YS5kYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoKXRoaXMuaW1wb3J0RmlsZXMoYS5kYXRhVHJhbnNmZXIuZmlsZXMsMCwwLHRoaXMubWF4SW1hZ2VTaXplLGZ1bmN0aW9uKGEsYyxlLGQsCmYsZyl7Yi5pbnNlcnRJbWFnZShhLGYsZyl9LGZ1bmN0aW9uKCl7fSxmdW5jdGlvbihhKXtyZXR1cm4iaW1hZ2UvIj09YS50eXBlLnN1YnN0cmluZygwLDYpfSxmdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKylhW2JdKCl9LG14RXZlbnQuaXNDb250cm9sRG93bihhKSk7ZWxzZSBpZigwPD1teFV0aWxzLmluZGV4T2YoYS5kYXRhVHJhbnNmZXIudHlwZXMsInRleHQvdXJpLWxpc3QiKSl7dmFyIGM9YS5kYXRhVHJhbnNmZXIuZ2V0RGF0YSgidGV4dC91cmktbGlzdCIpOy9cLihnaWZ8anBnfGpwZWd8dGlmZnxwbmd8c3ZnKSQvaS50ZXN0KGMpP3RoaXMubG9hZEltYWdlKGRlY29kZVVSSUNvbXBvbmVudChjKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt2YXIgZT1NYXRoLm1heCgxLGEud2lkdGgpO2E9TWF0aC5tYXgoMSxhLmhlaWdodCk7dmFyIGQ9dGhpcy5tYXhJbWFnZVNpemUsZD1NYXRoLm1pbigxLE1hdGgubWluKGQvTWF0aC5tYXgoMSxlKSksZC9NYXRoLm1heCgxLAphKSk7Yi5pbnNlcnRJbWFnZShkZWNvZGVVUklDb21wb25lbnQoYyksZSpkLGEqZCl9KSk6ZG9jdW1lbnQuZXhlY0NvbW1hbmQoImluc2VydEhUTUwiLCExLGEuZGF0YVRyYW5zZmVyLmdldERhdGEoInRleHQvcGxhaW4iKSl9ZWxzZSAwPD1teFV0aWxzLmluZGV4T2YoYS5kYXRhVHJhbnNmZXIudHlwZXMsInRleHQvaHRtbCIpP2RvY3VtZW50LmV4ZWNDb21tYW5kKCJpbnNlcnRIVE1MIiwhMSxhLmRhdGFUcmFuc2Zlci5nZXREYXRhKCJ0ZXh0L2h0bWwiKSk6MDw9bXhVdGlscy5pbmRleE9mKGEuZGF0YVRyYW5zZmVyLnR5cGVzLCJ0ZXh0L3BsYWluIikmJmRvY3VtZW50LmV4ZWNDb21tYW5kKCJpbnNlcnRIVE1MIiwhMSxhLmRhdGFUcmFuc2Zlci5nZXREYXRhKCJ0ZXh0L3BsYWluIikpO2Euc3RvcFByb3BhZ2F0aW9uKCk7YS5wcmV2ZW50RGVmYXVsdCgpfSkpKX0pKTsidW5kZWZpbmVkIiE9PXR5cGVvZiB3aW5kb3cubXhTZXR0aW5ncyYmKHg9dGhpcy5lZGl0b3IuZ3JhcGgudmlldywKeC5zZXRVbml0KG14U2V0dGluZ3MuZ2V0VW5pdCgpKSx4LmFkZExpc3RlbmVyKCJ1bml0Q2hhbmdlZCIsZnVuY3Rpb24oYSxiKXtteFNldHRpbmdzLnNldFVuaXQoYi5nZXRQcm9wZXJ0eSgidW5pdCIpKTtteFNldHRpbmdzLnNhdmUoKX0pLHRoaXMucnVsZXI9IXRoaXMuY2FudmFzU3VwcG9ydGVkfHw5PT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fCIxIiE9dXJsUGFyYW1zLnJ1bGVyJiYhbXhTZXR0aW5ncy5pc1J1bGVyT24oKXx8dGhpcy5lZGl0b3IuaXNDaHJvbWVsZXNzVmlldygpJiYhdGhpcy5lZGl0b3IuZWRpdGFibGU/bnVsbDpuZXcgbXhEdWFsUnVsZXIodGhpcyx4LnVuaXQpLHRoaXMucmVmcmVzaCgpKTtpZigiMSI9PXVybFBhcmFtcy5zdHlsZWRldil7eD1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiZ2VGb290ZXIiKTtudWxsIT14JiYodGhpcy5zdHlsZUlucHV0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0IiksdGhpcy5zdHlsZUlucHV0LnNldEF0dHJpYnV0ZSgidHlwZSIsCiJ0ZXh0IiksdGhpcy5zdHlsZUlucHV0LnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSIsdGhpcy5zdHlsZUlucHV0LnN0eWxlLnRvcD0iMTRweCIsdGhpcy5zdHlsZUlucHV0LnN0eWxlLmxlZnQ9IjJweCIsdGhpcy5zdHlsZUlucHV0LnN0eWxlLndpZHRoPSI5OCUiLHRoaXMuc3R5bGVJbnB1dC5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4iLHRoaXMuc3R5bGVJbnB1dC5zdHlsZS5vcGFjaXR5PSIwLjkiLG14RXZlbnQuYWRkTGlzdGVuZXIodGhpcy5zdHlsZUlucHV0LCJjaGFuZ2UiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5lZGl0b3IuZ3JhcGguZ2V0TW9kZWwoKS5zZXRTdHlsZSh0aGlzLmVkaXRvci5ncmFwaC5nZXRTZWxlY3Rpb25DZWxsKCksdGhpcy5zdHlsZUlucHV0LnZhbHVlKX0pKSx4LmFwcGVuZENoaWxkKHRoaXMuc3R5bGVJbnB1dCksdGhpcy5lZGl0b3IuZ3JhcGguZ2V0U2VsZWN0aW9uTW9kZWwoKS5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSxteFV0aWxzLmJpbmQodGhpcywKZnVuY3Rpb24oYSxiKXtpZigwPHRoaXMuZWRpdG9yLmdyYXBoLmdldFNlbGVjdGlvbkNvdW50KCkpe3ZhciBjPXRoaXMuZWRpdG9yLmdyYXBoLmdldFNlbGVjdGlvbkNlbGwoKSxjPXRoaXMuZWRpdG9yLmdyYXBoLmdldE1vZGVsKCkuZ2V0U3R5bGUoYyk7dGhpcy5zdHlsZUlucHV0LnZhbHVlPWN8fCIiO3RoaXMuc3R5bGVJbnB1dC5zdHlsZS52aXNpYmlsaXR5PSJ2aXNpYmxlIn1lbHNlIHRoaXMuc3R5bGVJbnB1dC5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4ifSkpKTt2YXIgRT10aGlzLmlzU2VsZWN0aW9uQWxsb3dlZDt0aGlzLmlzU2VsZWN0aW9uQWxsb3dlZD1mdW5jdGlvbihhKXtyZXR1cm4gbXhFdmVudC5nZXRTb3VyY2UoYSk9PXRoaXMuc3R5bGVJbnB1dD8hMDpFLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19eD1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiZ2VJbmZvIik7bnVsbCE9eCYmeC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHgpO2lmKEdyYXBoLmZpbGVTdXBwb3J0JiYoIXRoaXMuZWRpdG9yLmNocm9tZWxlc3N8fAp0aGlzLmVkaXRvci5lZGl0YWJsZSkpe3ZhciBBPW51bGw7bXhFdmVudC5hZGRMaXN0ZW5lcihjLmNvbnRhaW5lciwiZHJhZ2xlYXZlIixmdW5jdGlvbihhKXtjLmlzRW5hYmxlZCgpJiYobnVsbCE9QSYmKEEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChBKSxBPW51bGwpLGEuc3RvcFByb3BhZ2F0aW9uKCksYS5wcmV2ZW50RGVmYXVsdCgpKX0pO214RXZlbnQuYWRkTGlzdGVuZXIoYy5jb250YWluZXIsImRyYWdvdmVyIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsPT1BJiYoIW14Q2xpZW50LklTX0lFfHwxMDxkb2N1bWVudC5kb2N1bWVudE1vZGUpJiYoQT10aGlzLmhpZ2hsaWdodEVsZW1lbnQoYy5jb250YWluZXIpKTtudWxsIT10aGlzLnNpZGViYXImJnRoaXMuc2lkZWJhci5oaWRlVG9vbHRpcCgpO2Euc3RvcFByb3BhZ2F0aW9uKCk7YS5wcmV2ZW50RGVmYXVsdCgpfSkpO214RXZlbnQuYWRkTGlzdGVuZXIoYy5jb250YWluZXIsImRyb3AiLG14VXRpbHMuYmluZCh0aGlzLApmdW5jdGlvbihhKXtudWxsIT1BJiYoQS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKEEpLEE9bnVsbCk7aWYoYy5pc0VuYWJsZWQoKSl7dmFyIGI9bXhVdGlscy5jb252ZXJ0UG9pbnQoYy5jb250YWluZXIsbXhFdmVudC5nZXRDbGllbnRYKGEpLG14RXZlbnQuZ2V0Q2xpZW50WShhKSksZT1jLnZpZXcudHJhbnNsYXRlLGQ9Yy52aWV3LnNjYWxlLGY9Yi54L2QtZS54LGc9Yi55L2QtZS55O2lmKDA8YS5kYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoKW14RXZlbnQuaXNBbHREb3duKGEpJiYoZz1mPW51bGwpLHRoaXMuaW1wb3J0RmlsZXMoYS5kYXRhVHJhbnNmZXIuZmlsZXMsZixnLHRoaXMubWF4SW1hZ2VTaXplLG51bGwsbnVsbCxudWxsLG51bGwsbXhFdmVudC5pc0NvbnRyb2xEb3duKGEpLG51bGwsbnVsbCxteEV2ZW50LmlzU2hpZnREb3duKGEpKTtlbHNle214RXZlbnQuaXNBbHREb3duKGEpJiYoZz1mPTApO3ZhciBsPTA8PW14VXRpbHMuaW5kZXhPZihhLmRhdGFUcmFuc2Zlci50eXBlcywKInRleHQvdXJpLWxpc3QiKT9hLmRhdGFUcmFuc2Zlci5nZXREYXRhKCJ0ZXh0L3VyaS1saXN0Iik6bnVsbCxiPXRoaXMuZXh0cmFjdEdyYXBoTW9kZWxGcm9tRXZlbnQoYSxudWxsIT10aGlzLnBhZ2VzKTtpZihudWxsIT1iKWMuc2V0U2VsZWN0aW9uQ2VsbHModGhpcy5pbXBvcnRYbWwoYixmLGcsITApKTtlbHNlIGlmKDA8PW14VXRpbHMuaW5kZXhPZihhLmRhdGFUcmFuc2Zlci50eXBlcywidGV4dC9odG1sIikpe3ZhciBrPWEuZGF0YVRyYW5zZmVyLmdldERhdGEoInRleHQvaHRtbCIpLGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Yi5pbm5lckhUTUw9Yy5zYW5pdGl6ZUh0bWwoayk7dmFyIG09bnVsbCxlPWIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImltZyIpO251bGwhPWUmJjE9PWUubGVuZ3RoPyhrPWVbMF0uZ2V0QXR0cmlidXRlKCJzcmMiKSxudWxsPT1rJiYoaz1lWzBdLmdldEF0dHJpYnV0ZSgic3Jjc2V0IikpLC9cLihnaWZ8anBnfGpwZWd8dGlmZnxwbmd8c3ZnKSQvaS50ZXN0KGspfHwKKG09ITApKTooZT1iLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJhIiksbnVsbCE9ZSYmMT09ZS5sZW5ndGg/az1lWzBdLmdldEF0dHJpYnV0ZSgiaHJlZiIpOihiPWIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoInByZSIpLG51bGwhPWImJjE9PWIubGVuZ3RoJiYoaz1teFV0aWxzLmdldFRleHRDb250ZW50KGJbMF0pKSkpO3ZhciBwPSEwLG49bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtjLnNldFNlbGVjdGlvbkNlbGxzKHRoaXMuaW5zZXJ0VGV4dEF0KGssZixnLCEwLG0sbnVsbCxwKSl9KTttJiZudWxsIT1rJiZrLmxlbmd0aD50aGlzLnJlc2FtcGxlVGhyZXNob2xkP3RoaXMuY29uZmlybUltYWdlUmVzaXplKGZ1bmN0aW9uKGEpe3A9YTtuKCl9LG14RXZlbnQuaXNDb250cm9sRG93bihhKSk6bigpfWVsc2UgbnVsbCE9bCYmL1wuKGdpZnxqcGd8anBlZ3x0aWZmfHBuZ3xzdmcpJC9pLnRlc3QobCk/dGhpcy5sb2FkSW1hZ2UoZGVjb2RlVVJJQ29tcG9uZW50KGwpLG14VXRpbHMuYmluZCh0aGlzLApmdW5jdGlvbihhKXt2YXIgYj1NYXRoLm1heCgxLGEud2lkdGgpO2E9TWF0aC5tYXgoMSxhLmhlaWdodCk7dmFyIGU9dGhpcy5tYXhJbWFnZVNpemUsZT1NYXRoLm1pbigxLE1hdGgubWluKGUvTWF0aC5tYXgoMSxiKSksZS9NYXRoLm1heCgxLGEpKTtjLnNldFNlbGVjdGlvbkNlbGwoYy5pbnNlcnRWZXJ0ZXgobnVsbCxudWxsLCIiLGYsZyxiKmUsYSplLCJzaGFwZT1pbWFnZTt2ZXJ0aWNhbExhYmVsUG9zaXRpb249Ym90dG9tO2xhYmVsQmFja2dyb3VuZENvbG9yPSNmZmZmZmY7dmVydGljYWxBbGlnbj10b3A7YXNwZWN0PWZpeGVkO2ltYWdlQXNwZWN0PTA7aW1hZ2U9IitsKyI7IikpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7Yy5zZXRTZWxlY3Rpb25DZWxscyh0aGlzLmluc2VydFRleHRBdChsLGYsZywhMCkpfSkpOjA8PW14VXRpbHMuaW5kZXhPZihhLmRhdGFUcmFuc2Zlci50eXBlcywidGV4dC9wbGFpbiIpJiZjLnNldFNlbGVjdGlvbkNlbGxzKHRoaXMuaW5zZXJ0VGV4dEF0KGEuZGF0YVRyYW5zZmVyLmdldERhdGEoInRleHQvcGxhaW4iKSwKZixnLCEwKSl9fWEuc3RvcFByb3BhZ2F0aW9uKCk7YS5wcmV2ZW50RGVmYXVsdCgpfSksITEpfXRoaXMuaW5pdFBhZ2VzKCk7IjEiPT11cmxQYXJhbXMuZW1iZWQmJnRoaXMuaW5pdGlhbGl6ZUVtYmVkTW9kZSgpO3RoaXMuaW5zdGFsbFNldHRpbmdzKCl9O0VkaXRvclVpLnByb3RvdHlwZS5pbnN0YWxsSW1hZ2VQYXN0ZUhhbmRsZXI9ZnVuY3Rpb24oKXtpZighbXhDbGllbnQuSVNfSUUpe3ZhciBhPXRoaXMuZWRpdG9yLmdyYXBoO2EuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoInBhc3RlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXtpZighbXhFdmVudC5pc0NvbnN1bWVkKGIpKXRyeXtmb3IodmFyIGM9Yi5jbGlwYm9hcmREYXRhfHxiLm9yaWdpbmFsRXZlbnQuY2xpcGJvYXJkRGF0YSxlPSExLGQ9MDtkPGMudHlwZXMubGVuZ3RoO2QrKylpZigidGV4dC8iPT09Yy50eXBlc1tkXS5zdWJzdHJpbmcoMCw1KSl7ZT0hMDticmVha31pZighZSl7dmFyIGY9Yy5pdGVtcztmb3IoaW5kZXggaW4gZil7dmFyIGs9CmZbaW5kZXhdO2lmKCJmaWxlIj09PWsua2luZCl7aWYoYS5pc0VkaXRpbmcoKSl0aGlzLmltcG9ydEZpbGVzKFtrLmdldEFzRmlsZSgpXSwwLDAsdGhpcy5tYXhJbWFnZVNpemUsZnVuY3Rpb24oYixjLGUsZCxmLGcpe2EuaW5zZXJ0SW1hZ2UoYixmLGcpfSxmdW5jdGlvbigpe30sZnVuY3Rpb24oYSl7cmV0dXJuImltYWdlLyI9PWEudHlwZS5zdWJzdHJpbmcoMCw2KX0sZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspYVtiXSgpfSk7ZWxzZXt2YXIgbT10aGlzLmVkaXRvci5ncmFwaC5nZXRJbnNlcnRQb2ludCgpO3RoaXMuaW1wb3J0RmlsZXMoW2suZ2V0QXNGaWxlKCldLG0ueCxtLnksdGhpcy5tYXhJbWFnZVNpemUpO214RXZlbnQuY29uc3VtZShiKX1icmVha319fX1jYXRjaCh5KXt9fSksITEpfX07RWRpdG9yVWkucHJvdG90eXBlLmluc3RhbGxOYXRpdmVDbGlwYm9hcmRIYW5kbGVyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSgpe3dpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZC5pbm5lckhUTUw9CiImbmJzcDsiO2QuZm9jdXMoKTtkb2N1bWVudC5leGVjQ29tbWFuZCgic2VsZWN0QWxsIiwhMSxudWxsKX0sMCl9dmFyIGM9dGhpcy5lZGl0b3IuZ3JhcGgsZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtkLnNldEF0dHJpYnV0ZSgiYXV0b2NvbXBsZXRlIiwib2ZmIik7ZC5zZXRBdHRyaWJ1dGUoImF1dG9jb3JyZWN0Iiwib2ZmIik7ZC5zZXRBdHRyaWJ1dGUoImF1dG9jYXBpdGFsaXplIiwib2ZmIik7ZC5zZXRBdHRyaWJ1dGUoInNwZWxsY2hlY2siLCJmYWxzZSIpO2Quc3R5bGUudGV4dFJlbmRlcmluZz0ib3B0aW1pemVTcGVlZCI7ZC5zdHlsZS5mb250RmFtaWx5PSJtb25vc3BhY2UiO2Quc3R5bGUud29yZEJyZWFrPSJicmVhay1hbGwiO2Quc3R5bGUuYmFja2dyb3VuZD0idHJhbnNwYXJlbnQiO2Quc3R5bGUuY29sb3I9InRyYW5zcGFyZW50IjtkLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7ZC5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiO2Quc3R5bGUub3ZlcmZsb3c9CiJoaWRkZW4iO2Quc3R5bGUuZGlzcGxheT0iYmxvY2siO2Quc3R5bGUuZm9udFNpemU9IjEiO2Quc3R5bGUuekluZGV4PSItMSI7ZC5zdHlsZS5yZXNpemU9Im5vbmUiO2Quc3R5bGUub3V0bGluZT0ibm9uZSI7ZC5zdHlsZS53aWR0aD0iMXB4IjtkLnN0eWxlLmhlaWdodD0iMXB4IjtteFV0aWxzLnNldE9wYWNpdHkoZCwwKTtkLmNvbnRlbnRFZGl0YWJsZT0hMDtkLmlubmVySFRNTD0iJm5ic3A7Ijt2YXIgZj0hMTt0aGlzLmtleUhhbmRsZXIuYmluZENvbnRyb2xLZXkoODgsbnVsbCk7dGhpcy5rZXlIYW5kbGVyLmJpbmRDb250cm9sS2V5KDY3LG51bGwpO3RoaXMua2V5SGFuZGxlci5iaW5kQ29udHJvbEtleSg4NixudWxsKTtteEV2ZW50LmFkZExpc3RlbmVyKGRvY3VtZW50LCJrZXlkb3duIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt2YXIgYj1teEV2ZW50LmdldFNvdXJjZShhKTtudWxsPT1jLmNvbnRhaW5lcnx8IWMuaXNFbmFibGVkKCl8fGMuaXNNb3VzZURvd258fApjLmlzRWRpdGluZygpfHxudWxsIT10aGlzLmRpYWxvZ3x8IklOUFVUIj09Yi5ub2RlTmFtZXx8IlRFWFRBUkVBIj09Yi5ub2RlTmFtZXx8ISgyMjQ9PWEua2V5Q29kZXx8IW14Q2xpZW50LklTX01BQyYmMTc9PWEua2V5Q29kZXx8bXhDbGllbnQuSVNfTUFDJiY5MT09YS5rZXlDb2RlKXx8Znx8KGQuc3R5bGUubGVmdD1jLmNvbnRhaW5lci5zY3JvbGxMZWZ0KzEwKyJweCIsZC5zdHlsZS50b3A9Yy5jb250YWluZXIuc2Nyb2xsVG9wKzEwKyJweCIsYy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZCksZj0hMCxteENsaWVudC5JU19RVUlSS1M/d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtkLmZvY3VzKCk7ZG9jdW1lbnQuZXhlY0NvbW1hbmQoInNlbGVjdEFsbCIsITEsbnVsbCl9LDApOihkLmZvY3VzKCksZG9jdW1lbnQuZXhlY0NvbW1hbmQoInNlbGVjdEFsbCIsITEsbnVsbCkpKX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKGRvY3VtZW50LCJrZXl1cCIsbXhVdGlscy5iaW5kKHRoaXMsCmZ1bmN0aW9uKGEpe3ZhciBiPWEua2V5Q29kZTt3aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpeyFmfHwyMjQhPWImJjE3IT1iJiY5MSE9Ynx8KGY9ITEsYy5pc0VkaXRpbmcoKXx8bnVsbCE9dGhpcy5kaWFsb2d8fG51bGw9PWMuY29udGFpbmVyfHxjLmNvbnRhaW5lci5mb2N1cygpLGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkKSxudWxsPT10aGlzLmRpYWxvZyYmbXhVdGlscy5jbGVhclNlbGVjdGlvbigpKX0pLDApfSkpO214RXZlbnQuYWRkTGlzdGVuZXIoZCwiY29weSIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7aWYoYy5pc0VuYWJsZWQoKSl0cnl7bXhDbGlwYm9hcmQuY29weShjKSx0aGlzLmNvcHlDZWxscyhkKSxhKCl9Y2F0Y2godil7dGhpcy5oYW5kbGVFcnJvcih2KX19KSk7bXhFdmVudC5hZGRMaXN0ZW5lcihkLCJjdXQiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe2lmKGMuaXNFbmFibGVkKCkpdHJ5e214Q2xpcGJvYXJkLmNvcHkoYyksCnRoaXMuY29weUNlbGxzKGQsITApLGEoKX1jYXRjaCh2KXt0aGlzLmhhbmRsZUVycm9yKHYpfX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKGQsInBhc3RlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtjLmlzRW5hYmxlZCgpJiYhYy5pc0NlbGxMb2NrZWQoYy5nZXREZWZhdWx0UGFyZW50KCkpJiYoKG5ldyBEYXRlKS5nZXRUaW1lKCksZC5pbm5lckhUTUw9IiZuYnNwOyIsZC5mb2N1cygpLG51bGwhPWEuY2xpcGJvYXJkRGF0YSYmdGhpcy5wYXN0ZUNlbGxzKGEsZCwhMCwhMCksbXhFdmVudC5pc0NvbnN1bWVkKGEpfHx3aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMucGFzdGVDZWxscyhhLGQsITEsITApfSksMCkpfSksITApO3ZhciBsPXRoaXMuaXNTZWxlY3Rpb25BbGxvd2VkO3RoaXMuaXNTZWxlY3Rpb25BbGxvd2VkPWZ1bmN0aW9uKGEpe3JldHVybiBteEV2ZW50LmdldFNvdXJjZShhKT09ZD8hMDpsLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19OwpFZGl0b3JVaS5wcm90b3R5cGUuZ2V0TGlua1RpdGxlPWZ1bmN0aW9uKGEpe3ZhciBiPUdyYXBoLnByb3RvdHlwZS5nZXRMaW5rVGl0bGUuYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKCJkYXRhOnBhZ2UvaWQsIj09YS5zdWJzdHJpbmcoMCwxMykpe3ZhciBjPWEuaW5kZXhPZigiLCIpOzA8YyYmKGI9dGhpcy5nZXRQYWdlQnlJZChhLnN1YnN0cmluZyhjKzEpKSxiPW51bGwhPWI/Yi5nZXROYW1lKCk6bXhSZXNvdXJjZXMuZ2V0KCJwYWdlTm90Rm91bmQiKSl9ZWxzZSJkYXRhOiI9PWEuc3Vic3RyaW5nKDAsNSkmJihiPW14UmVzb3VyY2VzLmdldCgiYWN0aW9uIikpO3JldHVybiBifTtFZGl0b3JVaS5wcm90b3R5cGUuaGFuZGxlQ3VzdG9tTGluaz1mdW5jdGlvbihhKXtpZigiZGF0YTpwYWdlL2lkLCI9PWEuc3Vic3RyaW5nKDAsMTMpKXt2YXIgYj1hLmluZGV4T2YoIiwiKTtpZihhPXRoaXMuZ2V0UGFnZUJ5SWQoYS5zdWJzdHJpbmcoYisxKSkpdGhpcy5zZWxlY3RQYWdlKGEpO2Vsc2UgdGhyb3cgRXJyb3IobXhSZXNvdXJjZXMuZ2V0KCJwYWdlTm90Rm91bmQiKXx8CiJQYWdlIG5vdCBmb3VuZCIpO31lbHNlIHRoaXMuZWRpdG9yLmdyYXBoLmhhbmRsZUN1c3RvbUxpbmsoYSl9O0VkaXRvclVpLnByb3RvdHlwZS5pc1NldHRpbmdzRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiJ1bmRlZmluZWQiIT09dHlwZW9mIHdpbmRvdy5teFNldHRpbmdzJiYoaXNMb2NhbFN0b3JhZ2V8fG14Q2xpZW50LklTX0NIUk9NRUFQUCl9O0VkaXRvclVpLnByb3RvdHlwZS5pbnN0YWxsU2V0dGluZ3M9ZnVuY3Rpb24oKXtpZih0aGlzLmlzU2V0dGluZ3NFbmFibGVkKCkpe0NvbG9yRGlhbG9nLnJlY2VudENvbG9ycz1teFNldHRpbmdzLmdldFJlY2VudENvbG9ycygpO2lmKGlzTG9jYWxTdG9yYWdlKXRyeXt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigic3RvcmFnZSIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7YS5rZXk9PW14U2V0dGluZ3Mua2V5JiYobXhTZXR0aW5ncy5sb2FkKCksQ29sb3JEaWFsb2cucmVjZW50Q29sb3JzPW14U2V0dGluZ3MuZ2V0UmVjZW50Q29sb3JzKCksCnRoaXMubWVudXMuY3VzdG9tRm9udHM9bXhTZXR0aW5ncy5nZXRDdXN0b21Gb250cygpKX0pLCExKX1jYXRjaChiKXt9dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInN0eWxlQ2hhbmdlZCIsImtleXMiLFtdLCJ2YWx1ZXMiLFtdLCJjZWxscyIsW10pKTt0aGlzLm1lbnVzLmN1c3RvbUZvbnRzPW14U2V0dGluZ3MuZ2V0Q3VzdG9tRm9udHMoKTt0aGlzLmFkZExpc3RlbmVyKCJjdXN0b21Gb250c0NoYW5nZWQiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7dmFyIGI9Yy5nZXRQcm9wZXJ0eSgiY3VzdG9tRm9udHMiKTt0aGlzLm1lbnVzLmN1c3RvbUZvbnRzPWI7bXhTZXR0aW5ncy5zZXRDdXN0b21Gb250cyhiKTtteFNldHRpbmdzLnNhdmUoKX0pKTt0aGlzLmVkaXRvci5ncmFwaC5jb25uZWN0aW9uSGFuZGxlci5zZXRDcmVhdGVUYXJnZXQobXhTZXR0aW5ncy5pc0NyZWF0ZVRhcmdldCgpKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgiY29weUNvbm5lY3RDaGFuZ2VkIikpOwp0aGlzLmFkZExpc3RlbmVyKCJjb3B5Q29ubmVjdENoYW5nZWQiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7bXhTZXR0aW5ncy5zZXRDcmVhdGVUYXJnZXQodGhpcy5lZGl0b3IuZ3JhcGguY29ubmVjdGlvbkhhbmRsZXIuaXNDcmVhdGVUYXJnZXQoKSk7bXhTZXR0aW5ncy5zYXZlKCl9KSk7dGhpcy5lZGl0b3IuZ3JhcGgucGFnZUZvcm1hdD1teFNldHRpbmdzLmdldFBhZ2VGb3JtYXQoKTt0aGlzLmFkZExpc3RlbmVyKCJwYWdlRm9ybWF0Q2hhbmdlZCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXtteFNldHRpbmdzLnNldFBhZ2VGb3JtYXQodGhpcy5lZGl0b3IuZ3JhcGgucGFnZUZvcm1hdCk7bXhTZXR0aW5ncy5zYXZlKCl9KSk7dGhpcy5lZGl0b3IuZ3JhcGgudmlldy5ncmlkQ29sb3I9bXhTZXR0aW5ncy5nZXRHcmlkQ29sb3IoImRhcmsiPT11aVRoZW1lKTt0aGlzLmFkZExpc3RlbmVyKCJncmlkQ29sb3JDaGFuZ2VkIixteFV0aWxzLmJpbmQodGhpcywKZnVuY3Rpb24oYSxjKXtteFNldHRpbmdzLnNldEdyaWRDb2xvcih0aGlzLmVkaXRvci5ncmFwaC52aWV3LmdyaWRDb2xvciwiZGFyayI9PXVpVGhlbWUpO214U2V0dGluZ3Muc2F2ZSgpfSkpO2lmKG14Q2xpZW50LklTX0NIUk9NRUFQUHx8RWRpdG9yVWkuaXNFbGVjdHJvbkFwcCl0aGlzLmVkaXRvci5hZGRMaXN0ZW5lcigiYXV0b3NhdmVDaGFuZ2VkIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGMpe214U2V0dGluZ3Muc2V0QXV0b3NhdmUodGhpcy5lZGl0b3IuYXV0b3NhdmUpO214U2V0dGluZ3Muc2F2ZSgpfSkpLHRoaXMuZWRpdG9yLmF1dG9zYXZlPW14U2V0dGluZ3MuZ2V0QXV0b3NhdmUoKTtudWxsIT10aGlzLnNpZGViYXImJnRoaXMuc2lkZWJhci5zaG93UGFsZXR0ZSgic2VhcmNoIixteFNldHRpbmdzLnNldHRpbmdzLnNlYXJjaCk7dGhpcy5lZGl0b3IuY2hyb21lbGVzcyYmIXRoaXMuZWRpdG9yLmVkaXRhYmxlfHxudWxsPT10aGlzLnNpZGViYXJ8fCEobXhTZXR0aW5ncy5zZXR0aW5ncy5pc05ld3x8Cjg+PXBhcnNlSW50KG14U2V0dGluZ3Muc2V0dGluZ3MudmVyc2lvbnx8MCkpfHwodGhpcy50b2dnbGVTY3JhdGNocGFkKCksbXhTZXR0aW5ncy5zYXZlKCkpO3RoaXMuYWRkTGlzdGVuZXIoImZvcm1hdFdpZHRoQ2hhbmdlZCIsZnVuY3Rpb24oKXtteFNldHRpbmdzLnNldEZvcm1hdFdpZHRoKHRoaXMuZm9ybWF0V2lkdGgpO214U2V0dGluZ3Muc2F2ZSgpfSl9fTtFZGl0b3JVaS5wcm90b3R5cGUuY29weUNlbGxzPWZ1bmN0aW9uKGEsYyl7dmFyIGI9dGhpcy5lZGl0b3IuZ3JhcGg7aWYoYi5pc1NlbGVjdGlvbkVtcHR5KCkpYS5pbm5lckhUTUw9IiI7ZWxzZXt2YXIgZD1teFV0aWxzLnNvcnRDZWxscyhiLm1vZGVsLmdldFRvcG1vc3RDZWxscyhiLmdldFNlbGVjdGlvbkNlbGxzKCkpKSxlPW14VXRpbHMuZ2V0WG1sKGIuZW5jb2RlQ2VsbHMoZCkpO214VXRpbHMuc2V0VGV4dENvbnRlbnQoYSxlbmNvZGVVUklDb21wb25lbnQoZSkpO2M/KGIucmVtb3ZlQ2VsbHMoZCwhMSksYi5sYXN0UGFzdGVYbWw9Cm51bGwpOihiLmxhc3RQYXN0ZVhtbD1lLGIucGFzdGVDb3VudGVyPTApO2EuZm9jdXMoKTtkb2N1bWVudC5leGVjQ29tbWFuZCgic2VsZWN0QWxsIiwhMSxudWxsKX19O0VkaXRvclVpLnByb3RvdHlwZS5wYXN0ZUNlbGxzPWZ1bmN0aW9uKGEsYyxkLGYpe2lmKCFteEV2ZW50LmlzQ29uc3VtZWQoYSkpe3ZhciBiPWMsZT0hMTtpZihkJiZudWxsIT1hLmNsaXBib2FyZERhdGEmJmEuY2xpcGJvYXJkRGF0YS5nZXREYXRhKXt2YXIgZz1hLmNsaXBib2FyZERhdGEuZ2V0RGF0YSgidGV4dC9odG1sIik7aWYobnVsbCE9ZyYmMDxnLmxlbmd0aCl7dmFyIGs9IjxtZXRhICI9PWcuc3Vic3RyaW5nKDAsNiksYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtiLmlubmVySFRNTD0oaz8nPG1ldGEgY2hhcnNldD0idXRmLTgiPic6IiIpK3RoaXMuZWRpdG9yLmdyYXBoLnNhbml0aXplSHRtbChnKTtlPSEwO2c9Yi5nZXRFbGVtZW50c0J5VGFnTmFtZSgic3R5bGUiKTtpZihudWxsIT1nKWZvcig7MDwKZy5sZW5ndGg7KWdbMF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChnWzBdKTtudWxsIT1iLmZpcnN0Q2hpbGQmJmIuZmlyc3RDaGlsZC5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVCYmbnVsbCE9Yi5maXJzdENoaWxkLm5leHRTaWJsaW5nJiZiLmZpcnN0Q2hpbGQubmV4dFNpYmxpbmcubm9kZVR5cGU9PW14Q29uc3RhbnRzLk5PREVUWVBFX0VMRU1FTlQmJiJNRVRBIj09Yi5maXJzdENoaWxkLm5vZGVOYW1lJiYiQSI9PWIuZmlyc3RDaGlsZC5uZXh0U2libGluZy5ub2RlTmFtZSYmbnVsbD09Yi5maXJzdENoaWxkLm5leHRTaWJsaW5nLm5leHRTaWJsaW5nJiYoZz1udWxsPT1iLmZpcnN0Q2hpbGQubmV4dFNpYmxpbmcuaW5uZXJUZXh0P214VXRpbHMuZ2V0VGV4dENvbnRlbnQoYi5maXJzdENoaWxkLm5leHRTaWJsaW5nKTpiLmZpcnN0Q2hpbGQubmV4dFNpYmxpbmcuaW5uZXJUZXh0LGc9PWIuZmlyc3RDaGlsZC5uZXh0U2libGluZy5nZXRBdHRyaWJ1dGUoImhyZWYiKSYmCihteFV0aWxzLnNldFRleHRDb250ZW50KGIsZyksZT0hMSkpO2s9ayYmbnVsbCE9Yi5maXJzdENoaWxkP2IuZmlyc3RDaGlsZC5uZXh0U2libGluZzpiLmZpcnN0Q2hpbGQ7bnVsbCE9ayYmbnVsbD09ay5uZXh0U2libGluZyYmay5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVCYmIklNRyI9PWsubm9kZU5hbWUmJihnPWsuZ2V0QXR0cmlidXRlKCJzcmMiKSxudWxsIT1nJiYobXhVdGlscy5zZXRUZXh0Q29udGVudChiLGcpLGU9ITEpKTtlJiZHcmFwaC5yZW1vdmVQYXN0ZUZvcm1hdHRpbmcoYil9ZWxzZSBnPWEuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCJ0ZXh0L3BsYWluIiksbnVsbCE9ZyYmMDxnLmxlbmd0aCYmKGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2IiksbXhVdGlscy5zZXRUZXh0Q29udGVudChiLGcpKX1rPWIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoInNwYW4iKTtpZihudWxsIT1rJiYwPGsubGVuZ3RoJiYiYXBwbGljYXRpb24vdm5kLmx1Y2lkLmNoYXJ0Lm9iamVjdHMiPT09CmtbMF0uZ2V0QXR0cmlidXRlKCJkYXRhLWx1Y2lkLXR5cGUiKSlkPWtbMF0uZ2V0QXR0cmlidXRlKCJkYXRhLWx1Y2lkLWNvbnRlbnQiKSxudWxsIT1kJiYwPGQubGVuZ3RoJiYodGhpcy5jb252ZXJ0THVjaWRDaGFydChkLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZWRpdG9yLmdyYXBoO2IubGFzdFBhc3RlWG1sPT1hP2IucGFzdGVDb3VudGVyKys6KGIubGFzdFBhc3RlWG1sPWEsYi5wYXN0ZUNvdW50ZXI9MCk7dmFyIGM9Yi5wYXN0ZUNvdW50ZXIqYi5ncmlkU2l6ZTtiLnNldFNlbGVjdGlvbkNlbGxzKHRoaXMuaW1wb3J0WG1sKGEsYyxjKSk7Yi5zY3JvbGxDZWxsVG9WaXNpYmxlKGIuZ2V0U2VsZWN0aW9uQ2VsbCgpKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuaGFuZGxlRXJyb3IoYSl9KSksbXhFdmVudC5jb25zdW1lKGEpKTtlbHNle2U9ZT9iLmlubmVySFRNTDpteFV0aWxzLnRyaW0obnVsbD09Yi5pbm5lclRleHQ/bXhVdGlscy5nZXRUZXh0Q29udGVudChiKToKYi5pbm5lclRleHQpO2c9ITE7dHJ5e3ZhciBtPWUubGFzdEluZGV4T2YoIiUzRSIpOzA8PW0mJm08ZS5sZW5ndGgtMyYmKGU9ZS5zdWJzdHJpbmcoMCxtKzMpKX1jYXRjaChEKXt9dHJ5e3ZhciBrPWIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoInNwYW4iKSxwPW51bGwhPWsmJjA8ay5sZW5ndGg/bXhVdGlscy50cmltKGRlY29kZVVSSUNvbXBvbmVudChrWzBdLnRleHRDb250ZW50KSk6ZGVjb2RlVVJJQ29tcG9uZW50KGUpO3RoaXMuaXNDb21wYXRpYmxlU3RyaW5nKHApJiYoZz0hMCxlPXApfWNhdGNoKEQpe310cnl7dmFyIHE9dGhpcy5lZGl0b3IuZ3JhcGg7aWYobnVsbCE9ZSYmMDxlLmxlbmd0aCl7cS5sYXN0UGFzdGVYbWw9PWU/cS5wYXN0ZUNvdW50ZXIrKzoocS5sYXN0UGFzdGVYbWw9ZSxxLnBhc3RlQ291bnRlcj0wKTt2YXIgQT1xLnBhc3RlQ291bnRlcipxLmdyaWRTaXplO2lmKGd8fHRoaXMuaXNDb21wYXRpYmxlU3RyaW5nKGUpKXEuc2V0U2VsZWN0aW9uQ2VsbHModGhpcy5pbXBvcnRYbWwoZSwKQSxBKSk7ZWxzZSBpZihmJiYxPT1xLmdldFNlbGVjdGlvbkNvdW50KCkpe3ZhciBDPXEuZ2V0U3RhcnRFZGl0aW5nQ2VsbChxLmdldFNlbGVjdGlvbkNlbGwoKSxhKTsvXC4oZ2lmfGpwZ3xqcGVnfHRpZmZ8cG5nfHN2ZykkL2kudGVzdChlKSYmImltYWdlIj09cS5nZXRDdXJyZW50Q2VsbFN0eWxlKEMpW214Q29uc3RhbnRzLlNUWUxFX1NIQVBFXT9xLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfSU1BR0UsZSxbQ10pOihxLmxhYmVsQ2hhbmdlZChDLGUpLEdyYXBoLmlzTGluayhlKSYmcS5zZXRMaW5rRm9yQ2VsbChDLGUpKTtxLnNldFNlbGVjdGlvbkNlbGwoQyl9ZWxzZXt2YXIgej1xLmdldEluc2VydFBvaW50KCk7cS5pc01vdXNlSW5zZXJ0UG9pbnQoKSYmKEE9MCxxLmxhc3RQYXN0ZVhtbD09ZSYmMDxxLnBhc3RlQ291bnRlciYmcS5wYXN0ZUNvdW50ZXItLSk7cS5zZXRTZWxlY3Rpb25DZWxscyh0aGlzLmluc2VydFRleHRBdChlLHoueCtBLHoueStBLCEwKSl9cS5pc1NlbGVjdGlvbkVtcHR5KCl8fAoocS5zY3JvbGxDZWxsVG9WaXNpYmxlKHEuZ2V0U2VsZWN0aW9uQ2VsbCgpKSxudWxsIT10aGlzLmhvdmVySWNvbnMmJnRoaXMuaG92ZXJJY29ucy51cGRhdGUocS52aWV3LmdldFN0YXRlKHEuZ2V0U2VsZWN0aW9uQ2VsbCgpKSkpO3RyeXtteEV2ZW50LmNvbnN1bWUoYSl9Y2F0Y2goRCl7fX1lbHNlIGR8fChxLmxhc3RQYXN0ZVhtbD1udWxsLHEucGFzdGVDb3VudGVyPTApfWNhdGNoKEQpe3RoaXMuaGFuZGxlRXJyb3IoRCl9fX1jLmlubmVySFRNTD0iJm5ic3A7In07RWRpdG9yVWkucHJvdG90eXBlLmFkZEZpbGVEcm9wSGFuZGxlcj1mdW5jdGlvbihhKXtpZihHcmFwaC5maWxlU3VwcG9ydClmb3IodmFyIGI9bnVsbCxjPTA7YzxhLmxlbmd0aDtjKyspbXhFdmVudC5hZGRMaXN0ZW5lcihhW2NdLCJkcmFnbGVhdmUiLGZ1bmN0aW9uKGEpe251bGwhPWImJihiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYiksYj1udWxsKTthLnN0b3BQcm9wYWdhdGlvbigpO2EucHJldmVudERlZmF1bHQoKX0pLApteEV2ZW50LmFkZExpc3RlbmVyKGFbY10sImRyYWdvdmVyIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXsodGhpcy5lZGl0b3IuZ3JhcGguaXNFbmFibGVkKCl8fCIxIiE9dXJsUGFyYW1zLmVtYmVkKSYmbnVsbD09YiYmKCFteENsaWVudC5JU19JRXx8MTA8ZG9jdW1lbnQuZG9jdW1lbnRNb2RlJiYxMj5kb2N1bWVudC5kb2N1bWVudE1vZGUpJiYoYj10aGlzLmhpZ2hsaWdodEVsZW1lbnQoKSk7YS5zdG9wUHJvcGFnYXRpb24oKTthLnByZXZlbnREZWZhdWx0KCl9KSksbXhFdmVudC5hZGRMaXN0ZW5lcihhW2NdLCJkcm9wIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsIT1iJiYoYi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpLGI9bnVsbCk7aWYodGhpcy5lZGl0b3IuZ3JhcGguaXNFbmFibGVkKCl8fCIxIiE9dXJsUGFyYW1zLmVtYmVkKWlmKDA8YS5kYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoKXRoaXMuaGlkZURpYWxvZygpLCIxIj09dXJsUGFyYW1zLmVtYmVkPwp0aGlzLmltcG9ydEZpbGVzKGEuZGF0YVRyYW5zZmVyLmZpbGVzLDAsMCx0aGlzLm1heEltYWdlU2l6ZSxudWxsLG51bGwsbnVsbCxudWxsLCFteEV2ZW50LmlzQ29udHJvbERvd24oYSkmJiFteEV2ZW50LmlzU2hpZnREb3duKGEpKTp0aGlzLm9wZW5GaWxlcyhhLmRhdGFUcmFuc2Zlci5maWxlcywhMCk7ZWxzZXt2YXIgYz10aGlzLmV4dHJhY3RHcmFwaE1vZGVsRnJvbUV2ZW50KGEpO2lmKG51bGw9PWMpe3ZhciBkPW51bGwhPWEuZGF0YVRyYW5zZmVyP2EuZGF0YVRyYW5zZmVyOmEuY2xpcGJvYXJkRGF0YTtudWxsIT1kJiYoMTA9PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8MTE9PWRvY3VtZW50LmRvY3VtZW50TW9kZT9jPWQuZ2V0RGF0YSgiVGV4dCIpOihjPW51bGwsYz0wPD1teFV0aWxzLmluZGV4T2YoZC50eXBlcywidGV4dC91cmktbGlzdCIpP2EuZGF0YVRyYW5zZmVyLmdldERhdGEoInRleHQvdXJpLWxpc3QiKTowPD1teFV0aWxzLmluZGV4T2YoZC50eXBlcywidGV4dC9odG1sIik/CmQuZ2V0RGF0YSgidGV4dC9odG1sIik6bnVsbCxudWxsIT1jJiYwPGMubGVuZ3RoPyhkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLGQuaW5uZXJIVE1MPXRoaXMuZWRpdG9yLmdyYXBoLnNhbml0aXplSHRtbChjKSxkPWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImltZyIpLDA8ZC5sZW5ndGgmJihjPWRbMF0uZ2V0QXR0cmlidXRlKCJzcmMiKSkpOjA8PW14VXRpbHMuaW5kZXhPZihkLnR5cGVzLCJ0ZXh0L3BsYWluIikmJihjPWQuZ2V0RGF0YSgidGV4dC9wbGFpbiIpKSksbnVsbCE9YyYmKCJkYXRhOmltYWdlL3BuZztiYXNlNjQsIj09Yy5zdWJzdHJpbmcoMCwyMik/KGM9dGhpcy5leHRyYWN0R3JhcGhNb2RlbEZyb21QbmcoYyksbnVsbCE9YyYmMDxjLmxlbmd0aCYmdGhpcy5vcGVuTG9jYWxGaWxlKGMsbnVsbCwhMCkpOiF0aGlzLmlzT2ZmbGluZSgpJiZ0aGlzLmlzUmVtb3RlRmlsZUZvcm1hdChjKT8obmV3IG14WG1sUmVxdWVzdChPUEVOX1VSTCwiZm9ybWF0PXhtbCZkYXRhPSIrCmVuY29kZVVSSUNvbXBvbmVudChjKSkpLnNlbmQobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7MjAwPD1hLmdldFN0YXR1cygpJiYyOTk+PWEuZ2V0U3RhdHVzKCkmJnRoaXMub3BlbkxvY2FsRmlsZShhLmdldFRleHQoKSxudWxsLCEwKX0pKTovXmh0dHBzPzpcL1wvLy50ZXN0KGMpJiYobnVsbD09dGhpcy5nZXRDdXJyZW50RmlsZSgpP3dpbmRvdy5sb2NhdGlvbi5oYXNoPSIjVSIrZW5jb2RlVVJJQ29tcG9uZW50KGMpOndpbmRvdy5vcGVuV2luZG93KChteENsaWVudC5JU19DSFJPTUVBUFA/RWRpdG9yVWkuZHJhd0hvc3QrIi8iOiJodHRwczovLyIrbG9jYXRpb24uaG9zdCsiLyIpK3dpbmRvdy5sb2NhdGlvbi5zZWFyY2grIiNVIitlbmNvZGVVUklDb21wb25lbnQoYykpKSkpfWVsc2UgdGhpcy5vcGVuTG9jYWxGaWxlKGMsbnVsbCwhMCl9YS5zdG9wUHJvcGFnYXRpb24oKTthLnByZXZlbnREZWZhdWx0KCl9KSl9O0VkaXRvclVpLnByb3RvdHlwZS5oaWdobGlnaHRFbGVtZW50PQpmdW5jdGlvbihhKXt2YXIgYj0wLGM9MCxkLGY7aWYobnVsbD09YSl7Zj1kb2N1bWVudC5ib2R5O3ZhciBrPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtkPShmLmNsaWVudFdpZHRofHxrLmNsaWVudFdpZHRoKS0zO2Y9TWF0aC5tYXgoZi5jbGllbnRIZWlnaHR8fDAsay5jbGllbnRIZWlnaHQpLTN9ZWxzZSBiPWEub2Zmc2V0VG9wLGM9YS5vZmZzZXRMZWZ0LGQ9YS5jbGllbnRXaWR0aCxmPWEuY2xpZW50SGVpZ2h0O2s9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7ay5zdHlsZS56SW5kZXg9bXhQb3B1cE1lbnUucHJvdG90eXBlLnpJbmRleCsyO2suc3R5bGUuYm9yZGVyPSIzcHggZG90dGVkIHJnYigyNTQsIDEzNywgMTIpIjtrLnN0eWxlLnBvaW50ZXJFdmVudHM9Im5vbmUiO2suc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtrLnN0eWxlLnRvcD1iKyJweCI7ay5zdHlsZS5sZWZ0PWMrInB4IjtrLnN0eWxlLndpZHRoPU1hdGgubWF4KDAsZC0zKSsicHgiO2suc3R5bGUuaGVpZ2h0PQpNYXRoLm1heCgwLGYtMykrInB4IjtudWxsIT1hJiZhLnBhcmVudE5vZGU9PXRoaXMuZWRpdG9yLmdyYXBoLmNvbnRhaW5lcj90aGlzLmVkaXRvci5ncmFwaC5jb250YWluZXIuYXBwZW5kQ2hpbGQoayk6ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChrKTtyZXR1cm4ga307RWRpdG9yVWkucHJvdG90eXBlLnN0cmluZ1RvQ2VsbHM9ZnVuY3Rpb24oYSl7YT1teFV0aWxzLnBhcnNlWG1sKGEpO3ZhciBiPXRoaXMuZWRpdG9yLmV4dHJhY3RHcmFwaE1vZGVsKGEuZG9jdW1lbnRFbGVtZW50KTthPVtdO2lmKG51bGwhPWIpe3ZhciBjPW5ldyBteENvZGVjKGIub3duZXJEb2N1bWVudCksZD1uZXcgbXhHcmFwaE1vZGVsO2MuZGVjb2RlKGIsZCk7Yj1kLmdldENoaWxkQXQoZC5nZXRSb290KCksMCk7Zm9yKGM9MDtjPGQuZ2V0Q2hpbGRDb3VudChiKTtjKyspYS5wdXNoKGQuZ2V0Q2hpbGRBdChiLGMpKX1yZXR1cm4gYX07RWRpdG9yVWkucHJvdG90eXBlLm9wZW5GaWxlcz1mdW5jdGlvbihhLGMpe2lmKHRoaXMuc3Bpbm5lci5zcGluKGRvY3VtZW50LmJvZHksCm14UmVzb3VyY2VzLmdldCgibG9hZGluZyIpKSlmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKylteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt2YXIgYj1uZXcgRmlsZVJlYWRlcjtiLm9ubG9hZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXt0cnl7dmFyIGQ9Yi50YXJnZXQucmVzdWx0LGU9YS5uYW1lO2lmKG51bGwhPWUmJjA8ZS5sZW5ndGgpeyF0aGlzLnVzZUNhbnZhc0ZvckV4cG9ydCYmLyhcLnBuZykkL2kudGVzdChlKT9lPWUuc3Vic3RyaW5nKDAsZS5sZW5ndGgtNCkrIi5kcmF3aW8iOi8oXC5wZGYpJC9pLnRlc3QoZSkmJihlPWUuc3Vic3RyaW5nKDAsZS5sZW5ndGgtNCkrIi5kcmF3aW8iKTt2YXIgZj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtlPTA8PWUubGFzdEluZGV4T2YoIi4iKT9lLnN1YnN0cmluZygwLGUubGFzdEluZGV4T2YoIi4iKSkrIi5kcmF3aW8iOmUrIi5kcmF3aW8iO2lmKCI8bXhsaWJyYXJ5Ij09YS5zdWJzdHJpbmcoMCwxMCkpe251bGw9PQp0aGlzLmdldEN1cnJlbnRGaWxlKCkmJiIxIiE9dXJsUGFyYW1zLmVtYmVkJiZ0aGlzLm9wZW5Mb2NhbEZpbGUodGhpcy5lbXB0eURpYWdyYW1YbWwsdGhpcy5kZWZhdWx0RmlsZW5hbWUsYyk7dHJ5e3RoaXMubG9hZExpYnJhcnkobmV3IExvY2FsTGlicmFyeSh0aGlzLGEsZSkpfWNhdGNoKEEpe3RoaXMuaGFuZGxlRXJyb3IoQSxteFJlc291cmNlcy5nZXQoImVycm9yTG9hZGluZ0ZpbGUiKSl9fWVsc2UgdGhpcy5vcGVuTG9jYWxGaWxlKGEsZSxjKX0pO2lmKC8oXC52KGR4fHNkeD8pKSgkfFw/KS9pLnRlc3QoZSl8fC8oXC52cyh4fHN4PykpKCR8XD8pL2kudGVzdChlKSl0aGlzLmltcG9ydFZpc2lvKGEsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5zcGlubmVyLnN0b3AoKTtmKGEpfSkpO2Vsc2UgaWYoLyhcLio8Z3JhcGhtbCApLy50ZXN0KGQpKXRoaXMuaW1wb3J0R3JhcGhNTChkLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuc3Bpbm5lci5zdG9wKCk7CmYoYSl9KSk7ZWxzZSBpZihHcmFwaC5maWxlU3VwcG9ydCYmIXRoaXMuaXNPZmZsaW5lKCkmJihuZXcgWE1MSHR0cFJlcXVlc3QpLnVwbG9hZCYmdGhpcy5pc1JlbW90ZUZpbGVGb3JtYXQoZCxlKSl0aGlzLnBhcnNlRmlsZShhLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpezQ9PWEucmVhZHlTdGF0ZSYmKHRoaXMuc3Bpbm5lci5zdG9wKCksMjAwPD1hLnN0YXR1cyYmMjk5Pj1hLnN0YXR1cz9mKGEucmVzcG9uc2VUZXh0KTp0aGlzLmhhbmRsZUVycm9yKHttZXNzYWdlOm14UmVzb3VyY2VzLmdldCg0MTM9PWEuc3RhdHVzPyJkcmF3aW5nVG9vTGFyZ2UiOiJpbnZhbGlkT3JNaXNzaW5nRmlsZSIpfSxteFJlc291cmNlcy5nZXQoImVycm9yTG9hZGluZ0ZpbGUiKSkpfSkpO2Vsc2UgaWYodGhpcy5pc0x1Y2lkQ2hhcnREYXRhKGQpKS8oXC5qc29uKSQvaS50ZXN0KGUpJiYoZT1lLnN1YnN0cmluZygwLGUubGVuZ3RoLTUpKyIuZHJhd2lvIiksdGhpcy5jb252ZXJ0THVjaWRDaGFydChkLApteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLnNwaW5uZXIuc3RvcCgpO3RoaXMub3BlbkxvY2FsRmlsZShhLGUsYyl9KSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLnNwaW5uZXIuc3RvcCgpO3RoaXMuaGFuZGxlRXJyb3IoYSl9KSk7ZWxzZSBpZigiPG14bGlicmFyeSI9PWIudGFyZ2V0LnJlc3VsdC5zdWJzdHJpbmcoMCwxMCkpe3RoaXMuc3Bpbm5lci5zdG9wKCk7bnVsbD09dGhpcy5nZXRDdXJyZW50RmlsZSgpJiYiMSIhPXVybFBhcmFtcy5lbWJlZCYmdGhpcy5vcGVuTG9jYWxGaWxlKHRoaXMuZW1wdHlEaWFncmFtWG1sLHRoaXMuZGVmYXVsdEZpbGVuYW1lLGMpO3RyeXt0aGlzLmxvYWRMaWJyYXJ5KG5ldyBMb2NhbExpYnJhcnkodGhpcyxiLnRhcmdldC5yZXN1bHQsYS5uYW1lKSl9Y2F0Y2goRSl7dGhpcy5oYW5kbGVFcnJvcihFLG14UmVzb3VyY2VzLmdldCgiZXJyb3JMb2FkaW5nRmlsZSIpKX19ZWxzZSBpZigwPT1kLmluZGV4T2YoIlBLIikpdGhpcy5pbXBvcnRaaXBGaWxlKGEsCm14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuc3Bpbm5lci5zdG9wKCk7ZihhKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5zcGlubmVyLnN0b3AoKTt0aGlzLm9wZW5Mb2NhbEZpbGUoZCxlLGMpfSkpO2Vsc2V7aWYoImltYWdlL3BuZyI9PWEudHlwZS5zdWJzdHJpbmcoMCw5KSlkPXRoaXMuZXh0cmFjdEdyYXBoTW9kZWxGcm9tUG5nKGQpO2Vsc2UgaWYoImFwcGxpY2F0aW9uL3BkZiI9PWEudHlwZSl7dmFyIGc9RWRpdG9yLmV4dHJhY3RHcmFwaE1vZGVsRnJvbVBkZihkKTtudWxsIT1nJiYoZD1nKX10aGlzLnNwaW5uZXIuc3RvcCgpO3RoaXMub3BlbkxvY2FsRmlsZShkLGUsYyl9fX1jYXRjaChFKXt0aGlzLmhhbmRsZUVycm9yKEUpfX0pO2Iub25lcnJvcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLnNwaW5uZXIuc3RvcCgpO3RoaXMuaGFuZGxlRXJyb3IoYSk7d2luZG93Lm9wZW5GaWxlPW51bGx9KTsiaW1hZ2UiIT09YS50eXBlLnN1YnN0cmluZygwLAo1KSYmImFwcGxpY2F0aW9uL3BkZiIhPT1hLnR5cGV8fCJpbWFnZS9zdmciPT09YS50eXBlLnN1YnN0cmluZygwLDkpP2IucmVhZEFzVGV4dChhKTpiLnJlYWRBc0RhdGFVUkwoYSl9KShhW2JdKX07RWRpdG9yVWkucHJvdG90eXBlLm9wZW5Mb2NhbEZpbGU9ZnVuY3Rpb24oYSxjLGQpe3ZhciBiPXRoaXMuZ2V0Q3VycmVudEZpbGUoKSxlPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7d2luZG93Lm9wZW5GaWxlPW51bGw7aWYobnVsbD09YyYmbnVsbCE9dGhpcy5nZXRDdXJyZW50RmlsZSgpJiZ0aGlzLmlzRGlhZ3JhbUVtcHR5KCkpe3ZhciBiPW14VXRpbHMucGFyc2VYbWwoYSk7bnVsbCE9YiYmKHRoaXMuZWRpdG9yLnNldEdyYXBoWG1sKGIuZG9jdW1lbnRFbGVtZW50KSx0aGlzLmVkaXRvci5ncmFwaC5zZWxlY3RBbGwoKSl9ZWxzZSB0aGlzLmZpbGVMb2FkZWQobmV3IExvY2FsRmlsZSh0aGlzLGEsY3x8dGhpcy5kZWZhdWx0RmlsZW5hbWUsZCkpfSk7aWYobnVsbCE9YSYmMDwKYS5sZW5ndGgpbnVsbD09Ynx8IWIuaXNNb2RpZmllZCgpJiYobXhDbGllbnQuSVNfQ0hST01FQVBQfHxFZGl0b3JVaS5pc0VsZWN0cm9uQXBwKT9lKCk6KG14Q2xpZW50LklTX0NIUk9NRUFQUHx8RWRpdG9yVWkuaXNFbGVjdHJvbkFwcCkmJm51bGwhPWImJmIuaXNNb2RpZmllZCgpP3RoaXMuY29uZmlybShteFJlc291cmNlcy5nZXQoImFsbENoYW5nZXNMb3N0IiksbnVsbCxlLG14UmVzb3VyY2VzLmdldCgiY2FuY2VsIiksbXhSZXNvdXJjZXMuZ2V0KCJkaXNjYXJkQ2hhbmdlcyIpKTood2luZG93Lm9wZW5GaWxlPW5ldyBPcGVuRmlsZShmdW5jdGlvbigpe3dpbmRvdy5vcGVuRmlsZT1udWxsfSksd2luZG93Lm9wZW5GaWxlLnNldERhdGEoYSxjKSx3aW5kb3cub3BlbldpbmRvdyh0aGlzLmdldFVybCgpLG51bGwsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtudWxsIT1iJiZiLmlzTW9kaWZpZWQoKT90aGlzLmNvbmZpcm0obXhSZXNvdXJjZXMuZ2V0KCJhbGxDaGFuZ2VzTG9zdCIpLApudWxsLGUsbXhSZXNvdXJjZXMuZ2V0KCJjYW5jZWwiKSxteFJlc291cmNlcy5nZXQoImRpc2NhcmRDaGFuZ2VzIikpOmUoKX0pKSk7ZWxzZSB0aHJvdyBFcnJvcihteFJlc291cmNlcy5nZXQoIm5vdEFEaWFncmFtRmlsZSIpKTt9O0VkaXRvclVpLnByb3RvdHlwZS5nZXRCYXNlbmFtZXM9ZnVuY3Rpb24oKXt2YXIgYT17fTtpZihudWxsIT10aGlzLnBhZ2VzKWZvcih2YXIgYz0wO2M8dGhpcy5wYWdlcy5sZW5ndGg7YysrKXRoaXMudXBkYXRlUGFnZVJvb3QodGhpcy5wYWdlc1tjXSksdGhpcy5hZGRCYXNlbmFtZXNGb3JDZWxsKHRoaXMucGFnZXNbY10ucm9vdCxhKTtlbHNlIHRoaXMuYWRkQmFzZW5hbWVzRm9yQ2VsbCh0aGlzLmVkaXRvci5ncmFwaC5tb2RlbC5nZXRSb290KCksYSk7dmFyIGM9W10sZDtmb3IoZCBpbiBhKWMucHVzaChkKTtyZXR1cm4gY307RWRpdG9yVWkucHJvdG90eXBlLmFkZEJhc2VuYW1lc0ZvckNlbGw9ZnVuY3Rpb24oYSxjKXtmdW5jdGlvbiBiKGEpe2lmKG51bGwhPQphKXt2YXIgYj1hLmxhc3RJbmRleE9mKCIuIik7MDxiJiYoYT1hLnN1YnN0cmluZyhiKzEsYS5sZW5ndGgpKTtudWxsPT1jW2FdJiYoY1thXT0hMCl9fXZhciBkPXRoaXMuZWRpdG9yLmdyYXBoLGU9ZC5nZXRDZWxsU3R5bGUoYSk7YihteFN0ZW5jaWxSZWdpc3RyeS5nZXRCYXNlbmFtZUZvclN0ZW5jaWwoZVtteENvbnN0YW50cy5TVFlMRV9TSEFQRV0pKTtkLm1vZGVsLmlzRWRnZShhKSYmKGIobXhNYXJrZXIuZ2V0UGFja2FnZUZvclR5cGUoZVtteENvbnN0YW50cy5TVFlMRV9TVEFSVEFSUk9XXSkpLGIobXhNYXJrZXIuZ2V0UGFja2FnZUZvclR5cGUoZVtteENvbnN0YW50cy5TVFlMRV9FTkRBUlJPV10pKSk7Zm9yKHZhciBlPWQubW9kZWwuZ2V0Q2hpbGRDb3VudChhKSxmPTA7ZjxlO2YrKyl0aGlzLmFkZEJhc2VuYW1lc0ZvckNlbGwoZC5tb2RlbC5nZXRDaGlsZEF0KGEsZiksYyl9O0VkaXRvclVpLnByb3RvdHlwZS5zZXRHcmFwaEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5kaWFncmFtQ29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHk9CmE/IiI6ImhpZGRlbiI7dGhpcy5mb3JtYXRDb250YWluZXIuc3R5bGUudmlzaWJpbGl0eT1hPyIiOiJoaWRkZW4iO3RoaXMuc2lkZWJhckZvb3RlckNvbnRhaW5lci5zdHlsZS5kaXNwbGF5PWE/IiI6Im5vbmUiO3RoaXMuc2lkZWJhckNvbnRhaW5lci5zdHlsZS5kaXNwbGF5PWE/IiI6Im5vbmUiO3RoaXMuaHNwbGl0LnN0eWxlLmRpc3BsYXk9YT8iIjoibm9uZSI7dGhpcy5lZGl0b3IuZ3JhcGguc2V0RW5hYmxlZChhKTtudWxsIT10aGlzLnJ1bGVyJiYodGhpcy5ydWxlci5oUnVsZXIuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHk9YT8iIjoiaGlkZGVuIix0aGlzLnJ1bGVyLnZSdWxlci5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eT1hPyIiOiJoaWRkZW4iKTtudWxsIT10aGlzLnRhYkNvbnRhaW5lciYmKHRoaXMudGFiQ29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHk9YT8iIjoiaGlkZGVuIik7YXx8KG51bGwhPXRoaXMuYWN0aW9ucy5vdXRsaW5lV2luZG93JiZ0aGlzLmFjdGlvbnMub3V0bGluZVdpbmRvdy53aW5kb3cuc2V0VmlzaWJsZSghMSksCm51bGwhPXRoaXMuYWN0aW9ucy5sYXllcnNXaW5kb3cmJnRoaXMuYWN0aW9ucy5sYXllcnNXaW5kb3cud2luZG93LnNldFZpc2libGUoITEpLG51bGwhPXRoaXMubWVudXMudGFnc1dpbmRvdyYmdGhpcy5tZW51cy50YWdzV2luZG93LndpbmRvdy5zZXRWaXNpYmxlKCExKSxudWxsIT10aGlzLm1lbnVzLmZpbmRXaW5kb3cmJnRoaXMubWVudXMuZmluZFdpbmRvdy53aW5kb3cuc2V0VmlzaWJsZSghMSkpfTtFZGl0b3JVaS5wcm90b3R5cGUuaW5pdGlhbGl6ZUVtYmVkTW9kZT1mdW5jdGlvbigpe3RoaXMuc2V0R3JhcGhFbmFibGVkKCExKTsod2luZG93Lm9wZW5lcnx8d2luZG93LnBhcmVudCkhPXdpbmRvdyYmKCIxIiE9dXJsUGFyYW1zLnNwaW58fHRoaXMuc3Bpbm5lci5zcGluKGRvY3VtZW50LmJvZHksbXhSZXNvdXJjZXMuZ2V0KCJsb2FkaW5nIikpKSYmdGhpcy5pbnN0YWxsTWVzc2FnZUhhbmRsZXIobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjLGQpe3RoaXMuc3Bpbm5lci5zdG9wKCk7CnRoaXMuYWRkRW1iZWRCdXR0b25zKCk7dGhpcy5zZXRHcmFwaEVuYWJsZWQoITApO2lmKG51bGw9PWF8fDA9PWEubGVuZ3RoKWE9dGhpcy5lbXB0eURpYWdyYW1YbWw7dGhpcy5zZXRDdXJyZW50RmlsZShuZXcgTG9jYWxGaWxlKHRoaXMsYSx0aGlzLmRlZmF1bHRGaWxlbmFtZSwhMCkpO3RoaXMuc2V0RmlsZURhdGEoYSk7dGhpcy5lZGl0b3IuaXNDaHJvbWVsZXNzVmlldygpP3RoaXMuZWRpdG9yLmdyYXBoLmlzTGlnaHRib3hWaWV3KCkmJnRoaXMubGlnaHRib3hGaXQoKTp0aGlzLnNob3dMYXllcnNEaWFsb2coKTt0aGlzLmNocm9tZWxlc3NSZXNpemUmJnRoaXMuY2hyb21lbGVzc1Jlc2l6ZSgpO3RoaXMuZWRpdG9yLnVuZG9NYW5hZ2VyLmNsZWFyKCk7dGhpcy5lZGl0b3IubW9kaWZpZWQ9bnVsbCE9ZD9kOiExO3RoaXMudXBkYXRlVWkoKTt3aW5kb3cuc2VsZiE9PXdpbmRvdy50b3AmJndpbmRvdy5mb2N1cygpO251bGwhPXRoaXMuZm9ybWF0JiZ0aGlzLmZvcm1hdC5yZWZyZXNoKCl9KSl9OwpFZGl0b3JVaS5wcm90b3R5cGUuc2hvd0xheWVyc0RpYWxvZz1mdW5jdGlvbigpezE8dGhpcy5lZGl0b3IuZ3JhcGguZ2V0TW9kZWwoKS5nZXRDaGlsZENvdW50KHRoaXMuZWRpdG9yLmdyYXBoLmdldE1vZGVsKCkuZ2V0Um9vdCgpKSYmKG51bGw9PXRoaXMuYWN0aW9ucy5sYXllcnNXaW5kb3c/dGhpcy5hY3Rpb25zLmdldCgibGF5ZXJzIikuZnVuY3QoKTp0aGlzLmFjdGlvbnMubGF5ZXJzV2luZG93LndpbmRvdy5zZXRWaXNpYmxlKCEwKSl9O0VkaXRvclVpLnByb3RvdHlwZS5nZXRQdWJsaWNVcmw9ZnVuY3Rpb24oYSxjKXtudWxsIT1hP2EuZ2V0UHVibGljVXJsKGMpOmMobnVsbCl9O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVMb2FkTWVzc2FnZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmVkaXRvci5ncmFwaDtyZXR1cm57ZXZlbnQ6YSxwYWdlVmlzaWJsZTpiLnBhZ2VWaXNpYmxlLHRyYW5zbGF0ZTpiLnZpZXcudHJhbnNsYXRlLGJvdW5kczpiLmdldEdyYXBoQm91bmRzKCksY3VycmVudFBhZ2U6dGhpcy5nZXRTZWxlY3RlZFBhZ2VJbmRleCgpLApzY2FsZTpiLnZpZXcuc2NhbGUscGFnZTpiLnZpZXcuZ2V0QmFja2dyb3VuZFBhZ2VCb3VuZHMoKX19O0VkaXRvclVpLnByb3RvdHlwZS5pbnN0YWxsTWVzc2FnZUhhbmRsZXI9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbCxjPSExLGQ9ITEsZj1udWxsLGs9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiKXt0aGlzLmVkaXRvci5tb2RpZmllZCYmIjAiIT11cmxQYXJhbXMubW9kaWZpZWQ/bnVsbCE9dXJsUGFyYW1zLm1vZGlmaWVkJiZ0aGlzLmVkaXRvci5zZXRTdGF0dXMobXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KHVybFBhcmFtcy5tb2RpZmllZCkpKTp0aGlzLmVkaXRvci5zZXRTdGF0dXMoIiIpfSk7dGhpcy5lZGl0b3IuZ3JhcGgubW9kZWwuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0Usayk7bXhFdmVudC5hZGRMaXN0ZW5lcih3aW5kb3csIm1lc3NhZ2UiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGUpe2lmKGUuc291cmNlPT0od2luZG93Lm9wZW5lcnx8CndpbmRvdy5wYXJlbnQpKXt2YXIgZz1lLmRhdGEsbD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtpZihudWxsIT1hJiYiZnVuY3Rpb24iPT09dHlwZW9mIGEuY2hhckF0JiYiPCIhPWEuY2hhckF0KDApKXRyeXsiZGF0YTppbWFnZS9wbmc7YmFzZTY0LCI9PWEuc3Vic3RyaW5nKDAsMjIpP2E9dGhpcy5leHRyYWN0R3JhcGhNb2RlbEZyb21QbmcoYSk6ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsIj09YS5zdWJzdHJpbmcoMCwyNik/YT1hdG9iKGEuc3Vic3RyaW5nKDI2KSk6ImRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LCI9PWEuc3Vic3RyaW5nKDAsMjQpJiYoYT1hLnN1YnN0cmluZygyNCkpLG51bGwhPWEmJigiJSI9PWEuY2hhckF0KDApP2E9ZGVjb2RlVVJJQ29tcG9uZW50KGEpOiI8IiE9YS5jaGFyQXQoMCkmJihhPUdyYXBoLmRlY29tcHJlc3MoYSkpKX1jYXRjaChjYSl7fXJldHVybiBhfSk7aWYoImpzb24iPT11cmxQYXJhbXMucHJvdG8pe3RyeXtnPUpTT04ucGFyc2UoZyl9Y2F0Y2goVSl7Zz0KbnVsbH10cnl7aWYobnVsbD09ZylyZXR1cm47aWYoImRpYWxvZyI9PWcuYWN0aW9uKXt0aGlzLnNob3dFcnJvcihudWxsIT1nLnRpdGxlS2V5P214UmVzb3VyY2VzLmdldChnLnRpdGxlS2V5KTpnLnRpdGxlLG51bGwhPWcubWVzc2FnZUtleT9teFJlc291cmNlcy5nZXQoZy5tZXNzYWdlS2V5KTpnLm1lc3NhZ2UsbnVsbCE9Zy5idXR0b25LZXk/bXhSZXNvdXJjZXMuZ2V0KGcuYnV0dG9uS2V5KTpnLmJ1dHRvbik7bnVsbCE9Zy5tb2RpZmllZCYmKHRoaXMuZWRpdG9yLm1vZGlmaWVkPWcubW9kaWZpZWQpO3JldHVybn1pZigicHJvbXB0Ij09Zy5hY3Rpb24pe3RoaXMuc3Bpbm5lci5zdG9wKCk7dmFyIGs9bmV3IEZpbGVuYW1lRGlhbG9nKHRoaXMsZy5kZWZhdWx0VmFsdWV8fCIiLG51bGwhPWcub2tLZXk/bXhSZXNvdXJjZXMuZ2V0KGcub2tLZXkpOmcub2ssZnVuY3Rpb24oYSl7bnVsbCE9YT9tLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtldmVudDoicHJvbXB0Iix2YWx1ZTphLAptZXNzYWdlOmd9KSwiKiIpOm0ucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe2V2ZW50OiJwcm9tcHQtY2FuY2VsIixtZXNzYWdlOmd9KSwiKiIpfSxudWxsIT1nLnRpdGxlS2V5P214UmVzb3VyY2VzLmdldChnLnRpdGxlS2V5KTpnLnRpdGxlKTt0aGlzLnNob3dEaWFsb2coay5jb250YWluZXIsMzAwLDgwLCEwLCExKTtrLmluaXQoKTtyZXR1cm59aWYoImRyYWZ0Ij09Zy5hY3Rpb24pe3ZhciBwPWwoZy54bWwpO3RoaXMuc3Bpbm5lci5zdG9wKCk7az1uZXcgRHJhZnREaWFsb2codGhpcyxteFJlc291cmNlcy5nZXQoImRyYWZ0Rm91bmQiLFtnLm5hbWV8fHRoaXMuZGVmYXVsdEZpbGVuYW1lXSkscCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuaGlkZURpYWxvZygpO20ucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe2V2ZW50OiJkcmFmdCIscmVzdWx0OiJlZGl0IixtZXNzYWdlOmd9KSwiKiIpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmhpZGVEaWFsb2coKTsKbS5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh7ZXZlbnQ6ImRyYWZ0IixyZXN1bHQ6ImRpc2NhcmQiLG1lc3NhZ2U6Z30pLCIqIil9KSxnLmVkaXRLZXk/bXhSZXNvdXJjZXMuZ2V0KGcuZWRpdEtleSk6bnVsbCxnLmRpc2NhcmRLZXk/bXhSZXNvdXJjZXMuZ2V0KGcuZGlzY2FyZEtleSk6bnVsbCxnLmlnbm9yZT9teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuaGlkZURpYWxvZygpO20ucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe2V2ZW50OiJkcmFmdCIscmVzdWx0OiJpZ25vcmUiLG1lc3NhZ2U6Z30pLCIqIil9KTpudWxsKTt0aGlzLnNob3dEaWFsb2coay5jb250YWluZXIsNjQwLDQ4MCwhMCwhMSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXthJiZ0aGlzLmFjdGlvbnMuZ2V0KCJleGl0IikuZnVuY3QoKX0pKTt0cnl7ay5pbml0KCl9Y2F0Y2goVSl7bS5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh7ZXZlbnQ6ImRyYWZ0IixlcnJvcjpVLnRvU3RyaW5nKCksCm1lc3NhZ2U6Z30pLCIqIil9cmV0dXJufWlmKCJ0ZW1wbGF0ZSI9PWcuYWN0aW9uKXt0aGlzLnNwaW5uZXIuc3RvcCgpO3ZhciBuPTE9PWcuZW5hYmxlUmVjZW50LHE9MT09Zy5lbmFibGVTZWFyY2gsdD0xPT1nLmVuYWJsZUN1c3RvbVRlbXAsaz1uZXcgTmV3RGlhbG9nKHRoaXMsITEsbnVsbCE9Zy5jYWxsYmFjayxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiLGMpe2I9Ynx8dGhpcy5lbXB0eURpYWdyYW1YbWw7bnVsbCE9Zy5jYWxsYmFjaz9tLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtldmVudDoidGVtcGxhdGUiLHhtbDpiLGJsYW5rOmI9PXRoaXMuZW1wdHlEaWFncmFtWG1sLG5hbWU6YyxtZXNzYWdlOmd9KSwiKiIpOihhKGIsZSxiIT10aGlzLmVtcHR5RGlhZ3JhbVhtbCksdGhpcy5lZGl0b3IubW9kaWZpZWR8fHRoaXMuZWRpdG9yLnNldFN0YXR1cygiIikpfSksbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxuP214VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMucmVtb3RlSW52b2tlKCJnZXRSZWNlbnREaWFncmFtcyIsCm51bGwsbnVsbCxhLGZ1bmN0aW9uKCl7YShudWxsLCJOZXR3b3JrIEVycm9yISIpfSl9KTpudWxsLHE/bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiKXt0aGlzLnJlbW90ZUludm9rZSgic2VhcmNoRGlhZ3JhbXMiLFthXSxudWxsLGIsZnVuY3Rpb24oKXtiKG51bGwsIk5ldHdvcmsgRXJyb3IhIil9KX0pOm51bGwsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiLGMpe20ucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe2V2ZW50OiJ0ZW1wbGF0ZSIsZG9jVXJsOmEsaW5mbzpiLG5hbWU6Y30pLCIqIil9KSxudWxsLG51bGwsdD9teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLnJlbW90ZUludm9rZSgiZ2V0Q3VzdG9tVGVtcGxhdGVzIixudWxsLG51bGwsYSxmdW5jdGlvbigpe2Eoe30sMCl9KX0pOm51bGwpO3RoaXMuc2hvd0RpYWxvZyhrLmNvbnRhaW5lciw2MjAsNDQwLCEwLCExLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2EmJnRoaXMuYWN0aW9ucy5nZXQoImV4aXQiKS5mdW5jdCgpfSkpOwprLmluaXQoKTtyZXR1cm59aWYoInRleHRDb250ZW50Ij09Zy5hY3Rpb24pe3ZhciB5PXRoaXMuZ2V0RGlhZ3JhbVRleHRDb250ZW50KCk7bS5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh7ZXZlbnQ6InRleHRDb250ZW50IixkYXRhOnksbWVzc2FnZTpnfSksIioiKTtyZXR1cm59aWYoInN0YXR1cyI9PWcuYWN0aW9uKXtudWxsIT1nLm1lc3NhZ2VLZXk/dGhpcy5lZGl0b3Iuc2V0U3RhdHVzKG14VXRpbHMuaHRtbEVudGl0aWVzKG14UmVzb3VyY2VzLmdldChnLm1lc3NhZ2VLZXkpKSk6bnVsbCE9Zy5tZXNzYWdlJiZ0aGlzLmVkaXRvci5zZXRTdGF0dXMobXhVdGlscy5odG1sRW50aXRpZXMoZy5tZXNzYWdlKSk7bnVsbCE9Zy5tb2RpZmllZCYmKHRoaXMuZWRpdG9yLm1vZGlmaWVkPWcubW9kaWZpZWQpO3JldHVybn1pZigic3Bpbm5lciI9PWcuYWN0aW9uKXt2YXIgdj1udWxsIT1nLm1lc3NhZ2VLZXk/bXhSZXNvdXJjZXMuZ2V0KGcubWVzc2FnZUtleSk6Zy5tZXNzYWdlO251bGw9PQpnLnNob3d8fGcuc2hvdz90aGlzLnNwaW5uZXIuc3Bpbihkb2N1bWVudC5ib2R5LHYpOnRoaXMuc3Bpbm5lci5zdG9wKCk7cmV0dXJufWlmKCJleHBvcnQiPT1nLmFjdGlvbil7aWYoInBuZyI9PWcuZm9ybWF0fHwieG1scG5nIj09Zy5mb3JtYXQpe2lmKG51bGw9PWcuc3BpbiYmbnVsbD09Zy5zcGluS2V5fHx0aGlzLnNwaW5uZXIuc3Bpbihkb2N1bWVudC5ib2R5LG51bGwhPWcuc3BpbktleT9teFJlc291cmNlcy5nZXQoZy5zcGluS2V5KTpnLnNwaW4pKXt2YXIgSj1udWxsIT1nLnhtbD9nLnhtbDp0aGlzLmdldEZpbGVEYXRhKCEwKTt0aGlzLmVkaXRvci5ncmFwaC5zZXRFbmFibGVkKCExKTt2YXIgdT10aGlzLmVkaXRvci5ncmFwaCxLPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuZWRpdG9yLmdyYXBoLnNldEVuYWJsZWQoITApO3RoaXMuc3Bpbm5lci5zdG9wKCk7dmFyIGI9dGhpcy5jcmVhdGVMb2FkTWVzc2FnZSgiZXhwb3J0Iik7Yi5mb3JtYXQ9Zy5mb3JtYXQ7CmIubWVzc2FnZT1nO2IuZGF0YT1hO2IueG1sPUo7bS5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeShiKSwiKiIpfSksQj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsPT1hJiYoYT1FZGl0b3IuYmxhbmtJbWFnZSk7InhtbHBuZyI9PWcuZm9ybWF0JiYoYT1FZGl0b3Iud3JpdGVHcmFwaE1vZGVsVG9QbmcoYSwidEVYdCIsIm14ZmlsZSIsZW5jb2RlVVJJQ29tcG9uZW50KEopKSk7dSE9dGhpcy5lZGl0b3IuZ3JhcGgmJnUuY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodS5jb250YWluZXIpO0soYSl9KSxNPWcucGFnZUlkfHwobnVsbCE9dGhpcy5wYWdlcz90aGlzLnBhZ2VzWzBdLmdldElkKCk6bnVsbCk7aWYodGhpcy5pc0V4cG9ydFRvQ2FudmFzKCkpe2lmKG51bGwhPXRoaXMucGFnZXMmJnRoaXMuY3VycmVudFBhZ2UuZ2V0SWQoKSE9TSl7Zm9yKHZhciBQPXUuZ2V0R2xvYmFsVmFyaWFibGUsdT10aGlzLmNyZWF0ZVRlbXBvcmFyeUdyYXBoKHUuZ2V0U3R5bGVzaGVldCgpKSwKSSxSPTA7Ujx0aGlzLnBhZ2VzLmxlbmd0aDtSKyspaWYodGhpcy5wYWdlc1tSXS5nZXRJZCgpPT1NKXtJPXRoaXMudXBkYXRlUGFnZVJvb3QodGhpcy5wYWdlc1tSXSk7YnJlYWt9dS5nZXRHbG9iYWxWYXJpYWJsZT1mdW5jdGlvbihhKXtyZXR1cm4icGFnZSI9PWE/SS5nZXROYW1lKCk6InBhZ2VudW1iZXIiPT1hPzE6UC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodS5jb250YWluZXIpO3UubW9kZWwuc2V0Um9vdChJLnJvb3QpfWlmKG51bGwhPWcubGF5ZXJJZHMpe2Zvcih2YXIgZWE9dS5tb2RlbCxmYT1lYS5nZXRDaGlsZENlbGxzKGVhLmdldFJvb3QoKSksaz17fSxSPTA7UjxnLmxheWVySWRzLmxlbmd0aDtSKyspa1tnLmxheWVySWRzW1JdXT0hMDtmb3IoUj0wO1I8ZmEubGVuZ3RoO1IrKyllYS5zZXRWaXNpYmxlKGZhW1JdLGtbZmFbUl0uaWRdfHwhMSl9dGhpcy5lZGl0b3IuZXhwb3J0VG9DYW52YXMobXhVdGlscy5iaW5kKHRoaXMsCmZ1bmN0aW9uKGEpe0IoYS50b0RhdGFVUkwoImltYWdlL3BuZyIpKX0pLG51bGwsbnVsbCxudWxsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7QihudWxsKX0pLG51bGwsbnVsbCxnLnNjYWxlLG51bGwsbnVsbCxudWxsLHUpfWVsc2UobmV3IG14WG1sUmVxdWVzdChFWFBPUlRfVVJMLCJmb3JtYXQ9cG5nJmVtYmVkWG1sPSIrKCJ4bWxwbmciPT1nLmZvcm1hdD8iMSI6IjAiKSsobnVsbCE9TT8iJnBhZ2VJZD0iK006IiIpKyhudWxsIT1nLmxheWVySWRzPyImZXh0cmFzPSIrZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHtsYXllcklkczpnLmxheWVySWRzfSkpOiIiKSsobnVsbCE9Zy5zY2FsZT8iJnNjYWxlPSIrZy5zY2FsZToiIikrIiZiYXNlNjQ9MSZ4bWw9IitlbmNvZGVVUklDb21wb25lbnQoSikpKS5zZW5kKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpezIwMDw9YS5nZXRTdGF0dXMoKSYmMjk5Pj1hLmdldFN0YXR1cygpP0soImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwiKwphLmdldFRleHQoKSk6QihudWxsKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7QihudWxsKX0pKX19ZWxzZXtudWxsIT1nLnhtbCYmMDxnLnhtbC5sZW5ndGgmJnRoaXMuc2V0RmlsZURhdGEoZy54bWwpO3Y9dGhpcy5jcmVhdGVMb2FkTWVzc2FnZSgiZXhwb3J0Iik7di5tZXNzYWdlPWc7aWYoImh0bWwyIj09Zy5mb3JtYXR8fCJodG1sIj09Zy5mb3JtYXQmJigiMCIhPXVybFBhcmFtcy5wYWdlc3x8bnVsbCE9dGhpcy5wYWdlcyYmMTx0aGlzLnBhZ2VzLmxlbmd0aCkpe3ZhciBZPXRoaXMuZ2V0WG1sRmlsZURhdGEoKTt2LnhtbD1teFV0aWxzLmdldFhtbChZKTt2LmRhdGE9dGhpcy5nZXRGaWxlRGF0YShudWxsLG51bGwsITAsbnVsbCxudWxsLG51bGwsWSk7di5mb3JtYXQ9Zy5mb3JtYXR9ZWxzZSBpZigiaHRtbCI9PWcuZm9ybWF0KUo9dGhpcy5lZGl0b3IuZ2V0R3JhcGhYbWwoKSx2LmRhdGE9dGhpcy5nZXRIdG1sKEosdGhpcy5lZGl0b3IuZ3JhcGgpLHYueG1sPW14VXRpbHMuZ2V0WG1sKEopLAp2LmZvcm1hdD1nLmZvcm1hdDtlbHNle214U3ZnQ2FudmFzMkQucHJvdG90eXBlLmZvQWx0VGV4dD1udWxsO3ZhciBaPXRoaXMuZWRpdG9yLmdyYXBoLmJhY2tncm91bmQ7Wj09bXhDb25zdGFudHMuTk9ORSYmKFo9bnVsbCk7di54bWw9dGhpcy5nZXRGaWxlRGF0YSghMCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsITEpO3YuZm9ybWF0PSJzdmciO3ZhciBYPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuZWRpdG9yLmdyYXBoLnNldEVuYWJsZWQoITApO3RoaXMuc3Bpbm5lci5zdG9wKCk7di5kYXRhPUVkaXRvci5jcmVhdGVTdmdEYXRhVXJpKGEpO20ucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkodiksIioiKX0pO2lmKCJ4bWxzdmciPT1nLmZvcm1hdCkobnVsbD09Zy5zcGluJiZudWxsPT1nLnNwaW5LZXl8fHRoaXMuc3Bpbm5lci5zcGluKGRvY3VtZW50LmJvZHksbnVsbCE9Zy5zcGluS2V5P214UmVzb3VyY2VzLmdldChnLnNwaW5LZXkpOgpnLnNwaW4pKSYmdGhpcy5nZXRFbWJlZGRlZFN2Zyh2LnhtbCx0aGlzLmVkaXRvci5ncmFwaCxudWxsLCEwLFgsbnVsbCxudWxsLGcuZW1iZWRJbWFnZXMpO2Vsc2UgaWYobnVsbD09Zy5zcGluJiZudWxsPT1nLnNwaW5LZXl8fHRoaXMuc3Bpbm5lci5zcGluKGRvY3VtZW50LmJvZHksbnVsbCE9Zy5zcGluS2V5P214UmVzb3VyY2VzLmdldChnLnNwaW5LZXkpOmcuc3Bpbikpe3RoaXMuZWRpdG9yLmdyYXBoLnNldEVuYWJsZWQoITEpO3ZhciBhYT10aGlzLmVkaXRvci5ncmFwaC5nZXRTdmcoWik7dGhpcy5lbWJlZEZvbnRzKGFhLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2cuZW1iZWRJbWFnZXN8fG51bGw9PWcuZW1iZWRJbWFnZXM/dGhpcy5lZGl0b3IuY29udmVydEltYWdlcyhhLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe1gobXhVdGlscy5nZXRYbWwoYSkpfSkpOlgobXhVdGlscy5nZXRYbWwoYSkpfSkpfXJldHVybn1tLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHYpLAoiKiIpfXJldHVybn1pZigibG9hZCI9PWcuYWN0aW9uKWQ9MT09Zy5hdXRvc2F2ZSx0aGlzLmhpZGVEaWFsb2coKSxudWxsIT1nLm1vZGlmaWVkJiZudWxsPT11cmxQYXJhbXMubW9kaWZpZWQmJih1cmxQYXJhbXMubW9kaWZpZWQ9Zy5tb2RpZmllZCksbnVsbCE9Zy5zYXZlQW5kRXhpdCYmbnVsbD09dXJsUGFyYW1zLnNhdmVBbmRFeGl0JiYodXJsUGFyYW1zLnNhdmVBbmRFeGl0PWcuc2F2ZUFuZEV4aXQpLG51bGwhPWcubm9TYXZlQnRuJiZudWxsPT11cmxQYXJhbXMubm9TYXZlQnRuJiYodXJsUGFyYW1zLm5vU2F2ZUJ0bj1nLm5vU2F2ZUJ0biksbnVsbCE9Zy5ub0V4aXRCdG4mJm51bGw9PXVybFBhcmFtcy5ub0V4aXRCdG4mJih1cmxQYXJhbXMubm9FeGl0QnRuPWcubm9FeGl0QnRuKSxudWxsIT1nLnRpdGxlJiZudWxsIT10aGlzLmJ1dHRvbkNvbnRhaW5lciYmKHA9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3BhbiIpLG14VXRpbHMud3JpdGUocCxnLnRpdGxlKSwiYXRsYXMiPT0KdWlUaGVtZT8odGhpcy5idXR0b25Db250YWluZXIuc3R5bGUucGFkZGluZ1JpZ2h0PSIxMnB4Iix0aGlzLmJ1dHRvbkNvbnRhaW5lci5zdHlsZS5wYWRkaW5nVG9wPSI2cHgiLHRoaXMuYnV0dG9uQ29udGFpbmVyLnN0eWxlLnJpZ2h0PSIyNXB4Iik6Im1pbiIhPXVpVGhlbWUmJih0aGlzLmJ1dHRvbkNvbnRhaW5lci5zdHlsZS5wYWRkaW5nUmlnaHQ9IjM4cHgiLHRoaXMuYnV0dG9uQ29udGFpbmVyLnN0eWxlLnBhZGRpbmdUb3A9IjZweCIpLG51bGwhPXRoaXMuZW1iZWRGaWxlbmFtZVNwYW4mJnRoaXMuZW1iZWRGaWxlbmFtZVNwYW4ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVtYmVkRmlsZW5hbWVTcGFuKSx0aGlzLmJ1dHRvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChwKSx0aGlzLmVtYmVkRmlsZW5hbWVTcGFuPXApLGc9bnVsbCE9Zy54bWxwbmc/dGhpcy5leHRyYWN0R3JhcGhNb2RlbEZyb21QbmcoZy54bWxwbmcpOmcueG1sO2Vsc2V7aWYoIm1lcmdlIj09Zy5hY3Rpb24pe3ZhciBnYT0KdGhpcy5nZXRDdXJyZW50RmlsZSgpO251bGwhPWdhJiYocD1sKGcueG1sKSxudWxsIT1wJiYiIiE9cCYmZ2EubWVyZ2VGaWxlKG5ldyBMb2NhbEZpbGUodGhpcyxwKSxmdW5jdGlvbigpe20ucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe2V2ZW50OiJtZXJnZSIsbWVzc2FnZTpnfSksIioiKX0sZnVuY3Rpb24oYSl7bS5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh7ZXZlbnQ6Im1lcmdlIixtZXNzYWdlOmcsZXJyb3I6YX0pLCIqIil9KSl9ZWxzZSJyZW1vdGVJbnZva2VSZWFkeSI9PWcuYWN0aW9uP3RoaXMuaGFuZGxlUmVtb3RlSW52b2tlUmVhZHkobSk6InJlbW90ZUludm9rZSI9PWcuYWN0aW9uP3RoaXMuaGFuZGxlUmVtb3RlSW52b2tlKGcsZS5vcmlnaW4pOiJyZW1vdGVJbnZva2VSZXNwb25zZSI9PWcuYWN0aW9uP3RoaXMuaGFuZGxlUmVtb3RlSW52b2tlUmVzcG9uc2UoZyk6bS5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh7ZXJyb3I6InVua25vd25NZXNzYWdlIixkYXRhOkpTT04uc3RyaW5naWZ5KGcpfSksCiIqIik7cmV0dXJufX1jYXRjaChVKXt0aGlzLmhhbmRsZUVycm9yKFUpfX12YXIgZGE9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oZSxnKXtjPSEwO3RyeXthKGUsZyl9Y2F0Y2goamEpe3RoaXMuaGFuZGxlRXJyb3IoamEpfWM9ITE7bnVsbCE9dXJsUGFyYW1zLm1vZGlmaWVkJiZ0aGlzLmVkaXRvci5zZXRTdGF0dXMoIiIpO3ZhciBrPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIjAiIT11cmxQYXJhbXMucGFnZXN8fG51bGwhPXRoaXMucGFnZXMmJjE8dGhpcy5wYWdlcy5sZW5ndGg/dGhpcy5nZXRGaWxlRGF0YSghMCk6bXhVdGlscy5nZXRYbWwodGhpcy5lZGl0b3IuZ2V0R3JhcGhYbWwoKSl9KTtmPWsoKTtkJiZudWxsPT1iJiYoYj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIpe3ZhciBkPWsoKTtpZihkIT1mJiYhYyl7dmFyIGU9dGhpcy5jcmVhdGVMb2FkTWVzc2FnZSgiYXV0b3NhdmUiKTtlLnhtbD1kO2Q9SlNPTi5zdHJpbmdpZnkoZSk7KHdpbmRvdy5vcGVuZXJ8fAp3aW5kb3cucGFyZW50KS5wb3N0TWVzc2FnZShkLCIqIil9Zj1kfSksdGhpcy5lZGl0b3IuZ3JhcGgubW9kZWwuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsYiksdGhpcy5lZGl0b3IuZ3JhcGguYWRkTGlzdGVuZXIoImdyaWRTaXplQ2hhbmdlZCIsYiksdGhpcy5lZGl0b3IuZ3JhcGguYWRkTGlzdGVuZXIoInNoYWRvd1Zpc2libGVDaGFuZ2VkIixiKSx0aGlzLmFkZExpc3RlbmVyKCJwYWdlRm9ybWF0Q2hhbmdlZCIsYiksdGhpcy5hZGRMaXN0ZW5lcigicGFnZVNjYWxlQ2hhbmdlZCIsYiksdGhpcy5hZGRMaXN0ZW5lcigiYmFja2dyb3VuZENvbG9yQ2hhbmdlZCIsYiksdGhpcy5hZGRMaXN0ZW5lcigiYmFja2dyb3VuZEltYWdlQ2hhbmdlZCIsYiksdGhpcy5hZGRMaXN0ZW5lcigiZm9sZGluZ0VuYWJsZWRDaGFuZ2VkIixiKSx0aGlzLmFkZExpc3RlbmVyKCJtYXRoRW5hYmxlZENoYW5nZWQiLGIpLHRoaXMuYWRkTGlzdGVuZXIoImdyaWRFbmFibGVkQ2hhbmdlZCIsYiksdGhpcy5hZGRMaXN0ZW5lcigiZ3VpZGVzRW5hYmxlZENoYW5nZWQiLApiKSx0aGlzLmFkZExpc3RlbmVyKCJwYWdlVmlld0NoYW5nZWQiLGIpKTtpZigiMSI9PXVybFBhcmFtcy5yZXR1cm5ib3VuZHN8fCJqc29uIj09dXJsUGFyYW1zLnByb3RvKXt2YXIgbD10aGlzLmNyZWF0ZUxvYWRNZXNzYWdlKCJsb2FkIik7bC54bWw9ZTttLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KGwpLCIqIil9fSk7bnVsbCE9ZyYmImZ1bmN0aW9uIj09PXR5cGVvZiBnLnN1YnN0cmluZyYmImRhdGE6YXBwbGljYXRpb24vdm5kLnZpc2lvO2Jhc2U2NCwiPT1nLnN1YnN0cmluZygwLDM0KT8obD0iME04UjRLR3hHdUUiPT1nLnN1YnN0cmluZygzNCw0NSk/InJhdy52c2QiOiJyYXcudnNkeCIsdGhpcy5pbXBvcnRWaXNpbyh0aGlzLmJhc2U2NFRvQmxvYihnLnN1YnN0cmluZyhnLmluZGV4T2YoIiwiKSsxKSksZnVuY3Rpb24oYSl7ZGEoYSxlKX0sbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5oYW5kbGVFcnJvcihhKX0pLGwpKTpudWxsIT1nJiYiZnVuY3Rpb24iPT09CnR5cGVvZiBnLnN1YnN0cmluZyYmIXRoaXMuaXNPZmZsaW5lKCkmJihuZXcgWE1MSHR0cFJlcXVlc3QpLnVwbG9hZCYmdGhpcy5pc1JlbW90ZUZpbGVGb3JtYXQoZywiIik/dGhpcy5wYXJzZUZpbGUobmV3IEJsb2IoW2ddLHt0eXBlOiJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0ifSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7ND09YS5yZWFkeVN0YXRlJiYyMDA8PWEuc3RhdHVzJiYyOTk+PWEuc3RhdHVzJiYiPG14R3JhcGhNb2RlbCI9PWEucmVzcG9uc2VUZXh0LnN1YnN0cmluZygwLDEzKSYmZGEoYS5yZXNwb25zZVRleHQsZSl9KSwiIik6bnVsbCE9ZyYmImZ1bmN0aW9uIj09PXR5cGVvZiBnLnN1YnN0cmluZyYmdGhpcy5pc0x1Y2lkQ2hhcnREYXRhKGcpP3RoaXMuY29udmVydEx1Y2lkQ2hhcnQoZyxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtkYShhKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuaGFuZGxlRXJyb3IoYSl9KSk6KGc9bChnKSwKZGEoZyxlKSl9fSkpO3ZhciBtPXdpbmRvdy5vcGVuZXJ8fHdpbmRvdy5wYXJlbnQsaz0ianNvbiI9PXVybFBhcmFtcy5wcm90bz9KU09OLnN0cmluZ2lmeSh7ZXZlbnQ6ImluaXQifSk6dXJsUGFyYW1zLnJlYWR5fHwicmVhZHkiO20ucG9zdE1lc3NhZ2UoaywiKiIpO2lmKCJqc29uIj09dXJsUGFyYW1zLnByb3RvKXt2YXIgcT10aGlzLmVkaXRvci5ncmFwaC5vcGVuTGluazt0aGlzLmVkaXRvci5ncmFwaC5vcGVuTGluaz1mdW5jdGlvbihhLGIsYyl7cS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bS5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh7ZXZlbnQ6Im9wZW5MaW5rIixocmVmOmEsdGFyZ2V0OmIsYWxsb3dPcGVuZXI6Y30pLCIqIil9fX07RWRpdG9yVWkucHJvdG90eXBlLmFkZEVtYmVkQnV0dG9ucz1mdW5jdGlvbigpe2lmKG51bGwhPXRoaXMubWVudWJhcil7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7YS5zdHlsZS5kaXNwbGF5PSJpbmxpbmUtYmxvY2siOwphLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7YS5zdHlsZS5wYWRkaW5nVG9wPSJhdGxhcyI9PXVpVGhlbWU/IjJweCI6IjBweCI7YS5zdHlsZS5wYWRkaW5nTGVmdD0iOHB4IjthLnN0eWxlLnBhZGRpbmdCb3R0b209IjJweCI7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYnV0dG9uIik7Yy5jbGFzc05hbWU9ImdlQmlnQnV0dG9uIjt2YXIgZD1jOyIxIj09dXJsUGFyYW1zLm5vU2F2ZUJ0bj8iMCIhPXVybFBhcmFtcy5zYXZlQW5kRXhpdCYmKG14VXRpbHMud3JpdGUoYyxteFJlc291cmNlcy5nZXQoInNhdmVBbmRFeGl0IikpLGMuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJzYXZlQW5kRXhpdCIpKSxteEV2ZW50LmFkZExpc3RlbmVyKGMsImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuYWN0aW9ucy5nZXQoInNhdmVBbmRFeGl0IikuZnVuY3QoKX0pKSxhLmFwcGVuZENoaWxkKGMpKToobXhVdGlscy53cml0ZShjLG14UmVzb3VyY2VzLmdldCgic2F2ZSIpKSwKYy5zZXRBdHRyaWJ1dGUoInRpdGxlIixteFJlc291cmNlcy5nZXQoInNhdmUiKSsiICgiK0VkaXRvci5jdHJsS2V5KyIrUykiKSxteEV2ZW50LmFkZExpc3RlbmVyKGMsImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuYWN0aW9ucy5nZXQoInNhdmUiKS5mdW5jdCgpfSkpLGEuYXBwZW5kQ2hpbGQoYyksIjEiPT11cmxQYXJhbXMuc2F2ZUFuZEV4aXQmJihjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImEiKSxteFV0aWxzLndyaXRlKGMsbXhSZXNvdXJjZXMuZ2V0KCJzYXZlQW5kRXhpdCIpKSxjLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgic2F2ZUFuZEV4aXQiKSksYy5jbGFzc05hbWU9ImdlQmlnQnV0dG9uIGdlQmlnU3RhbmRhcmRCdXR0b24iLGMuc3R5bGUubWFyZ2luTGVmdD0iNnB4IixteEV2ZW50LmFkZExpc3RlbmVyKGMsImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuYWN0aW9ucy5nZXQoInNhdmVBbmRFeGl0IikuZnVuY3QoKX0pKSwKYS5hcHBlbmRDaGlsZChjKSxkPWMpKTsiMSIhPXVybFBhcmFtcy5ub0V4aXRCdG4mJihjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImEiKSxteFV0aWxzLndyaXRlKGMsbXhSZXNvdXJjZXMuZ2V0KCJleGl0IikpLGMuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJleGl0IikpLGMuY2xhc3NOYW1lPSJnZUJpZ0J1dHRvbiBnZUJpZ1N0YW5kYXJkQnV0dG9uIixjLnN0eWxlLm1hcmdpbkxlZnQ9IjZweCIsbXhFdmVudC5hZGRMaXN0ZW5lcihjLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmFjdGlvbnMuZ2V0KCJleGl0IikuZnVuY3QoKX0pKSxhLmFwcGVuZENoaWxkKGMpLGQ9Yyk7ZC5zdHlsZS5tYXJnaW5SaWdodD0iMjBweCI7dGhpcy50b29sYmFyLmNvbnRhaW5lci5hcHBlbmRDaGlsZChhKTt0aGlzLnRvb2xiYXIuc3RhdGljRWxlbWVudHMucHVzaChhKTthLnN0eWxlLnJpZ2h0PSJhdGxhcyIhPXVpVGhlbWU/IjUycHgiOiI0MnB4In19OwpFZGl0b3JVaS5wcm90b3R5cGUuc2hvd0ltcG9ydENzdkRpYWxvZz1mdW5jdGlvbigpe251bGw9PXRoaXMuaW1wb3J0Q3N2RGlhbG9nJiYodGhpcy5pbXBvcnRDc3ZEaWFsb2c9bmV3IFRleHRhcmVhRGlhbG9nKHRoaXMsbXhSZXNvdXJjZXMuZ2V0KCJjc3YiKSsiOiIsRWRpdG9yLmRlZmF1bHRDc3ZWYWx1ZSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmltcG9ydENzdihhKX0pLG51bGwsbnVsbCw2MjAsNDMwLG51bGwsITAsITAsbXhSZXNvdXJjZXMuZ2V0KCJpbXBvcnQiKSx0aGlzLmlzT2ZmbGluZSgpP251bGw6Imh0dHBzOi8vZHJhd2lvLWFwcC5jb20vaW1wb3J0LWZyb20tY3N2LXRvLWRyYXdpby8iKSk7dGhpcy5zaG93RGlhbG9nKHRoaXMuaW1wb3J0Q3N2RGlhbG9nLmNvbnRhaW5lciw2NDAsNTIwLCEwLCEwLG51bGwsbnVsbCxudWxsLG51bGwsITApO3RoaXMuaW1wb3J0Q3N2RGlhbG9nLmluaXQoKX07RWRpdG9yVWkucHJvdG90eXBlLmV4ZWN1dGVMYXlvdXRMaXN0PQpmdW5jdGlvbihhLGMpe2Zvcih2YXIgYj10aGlzLmVkaXRvci5ncmFwaCxkPWIuZ2V0U2VsZWN0aW9uQ2VsbHMoKSxlPTA7ZTxhLmxlbmd0aDtlKyspe3ZhciBmPW5ldyB3aW5kb3dbYVtlXS5sYXlvdXRdKGIpO2lmKG51bGwhPWFbZV0uY29uZmlnKWZvcih2YXIgayBpbiBhW2VdLmNvbmZpZylmW2tdPWFbZV0uY29uZmlnW2tdO3RoaXMuZXhlY3V0ZUxheW91dChmdW5jdGlvbigpe2YuZXhlY3V0ZShiLmdldERlZmF1bHRQYXJlbnQoKSwwPT1kLmxlbmd0aD9udWxsOmQpfSxlPT1hLmxlbmd0aC0xLGMpfX07RWRpdG9yVWkucHJvdG90eXBlLmltcG9ydENzdj1mdW5jdGlvbihhLGMpe3RyeXt2YXIgYj1hLnNwbGl0KCJcbiIpLGQ9W10sZT1bXSxmPXt9O2lmKDA8Yi5sZW5ndGgpe3ZhciBrPXt9LG09bnVsbCxxPW51bGwseD1udWxsLEU9bnVsbCxBPW51bGwsQz1udWxsLHo9bnVsbCxEPW51bGwsRz0iIixGPSJhdXRvIixIPSJhdXRvIixKPW51bGwsdT1udWxsLEs9NDAsQj00MCxNPTEwMCwKUD0wLEk9dGhpcy5lZGl0b3IuZ3JhcGg7SS5nZXRHcmFwaEJvdW5kcygpO2Zvcih2YXIgUj1mdW5jdGlvbigpe251bGwhPWM/YyhuYSk6KEkuc2V0U2VsZWN0aW9uQ2VsbHMobmEpLEkuc2Nyb2xsQ2VsbFRvVmlzaWJsZShJLmdldFNlbGVjdGlvbkNlbGwoKSkpfSxlYT1JLmdldEZyZWVJbnNlcnRQb2ludCgpLGZhPWVhLngsWT1lYS55LGVhPVksWj1udWxsLFg9ImF1dG8iLEQ9bnVsbCxhYT1bXSxnYT1udWxsLGRhPW51bGwsVT0wO1U8Yi5sZW5ndGgmJiIjIj09YltVXS5jaGFyQXQoMCk7KXthPWJbVV07Zm9yKFUrKztVPGIubGVuZ3RoJiYiXFwiPT1hLmNoYXJBdChhLmxlbmd0aC0xKSYmIiMiPT1iW1VdLmNoYXJBdCgwKTspYT1hLnN1YnN0cmluZygwLGEubGVuZ3RoLTEpK214VXRpbHMudHJpbShiW1VdLnN1YnN0cmluZygxKSksVSsrO2lmKCIjIiE9YS5jaGFyQXQoMSkpe3ZhciBjYT1hLmluZGV4T2YoIjoiKTtpZigwPGNhKXt2YXIgUT1teFV0aWxzLnRyaW0oYS5zdWJzdHJpbmcoMSwKY2EpKSxMPW14VXRpbHMudHJpbShhLnN1YnN0cmluZyhjYSsxKSk7ImxhYmVsIj09UT9aPUkuc2FuaXRpemVIdG1sKEwpOiJsYWJlbG5hbWUiPT1RJiYwPEwubGVuZ3RoJiYiLSIhPUw/RT1MOiJsYWJlbHMiPT1RJiYwPEwubGVuZ3RoJiYiLSIhPUw/QT1KU09OLnBhcnNlKEwpOiJzdHlsZSI9PVE/bT1MOiJwYXJlbnRzdHlsZSI9PVE/Qz1MOiJzdHlsZW5hbWUiPT1RJiYwPEwubGVuZ3RoJiYiLSIhPUw/eD1MOiJzdHlsZXMiPT1RJiYwPEwubGVuZ3RoJiYiLSIhPUw/cT1KU09OLnBhcnNlKEwpOiJpZGVudGl0eSI9PVEmJjA8TC5sZW5ndGgmJiItIiE9TD96PUw6InBhcmVudCI9PVEmJjA8TC5sZW5ndGgmJiItIiE9TD9EPUw6Im5hbWVzcGFjZSI9PVEmJjA8TC5sZW5ndGgmJiItIiE9TD9HPUw6IndpZHRoIj09UT9GPUw6ImhlaWdodCI9PVE/SD1MOiJsZWZ0Ij09USYmMDxMLmxlbmd0aD9KPUw6InRvcCI9PVEmJjA8TC5sZW5ndGg/dT1MOiJpZ25vcmUiPT1RP2RhPUwuc3BsaXQoIiwiKToKImNvbm5lY3QiPT1RP2FhLnB1c2goSlNPTi5wYXJzZShMKSk6ImxpbmsiPT1RP2dhPUw6InBhZGRpbmciPT1RP1A9cGFyc2VGbG9hdChMKToiZWRnZXNwYWNpbmciPT1RP0s9cGFyc2VGbG9hdChMKToibm9kZXNwYWNpbmciPT1RP0I9cGFyc2VGbG9hdChMKToibGV2ZWxzcGFjaW5nIj09UT9NPXBhcnNlRmxvYXQoTCk6ImxheW91dCI9PVEmJihYPUwpfX19aWYobnVsbD09YltVXSl0aHJvdyBFcnJvcihteFJlc291cmNlcy5nZXQoImludmFsaWRPck1pc3NpbmdGaWxlIikpO2Zvcih2YXIgamE9dGhpcy5lZGl0b3IuY3N2VG9BcnJheShiW1VdKSxRPWNhPW51bGwsTD1bXSxPPTA7TzxqYS5sZW5ndGg7TysrKXo9PWphW09dJiYoY2E9TyksRD09amFbT10mJihRPU8pLEwucHVzaChteFV0aWxzLnRyaW0oamFbT10pLnJlcGxhY2UoL1teYS16MC05XSsvaWcsIl8iKS5yZXBsYWNlKC9eXGQrLywiIikucmVwbGFjZSgvXyskLywiIikpO251bGw9PVomJihaPSIlIitMWzBdKyIlIik7aWYobnVsbCE9CmFhKWZvcih2YXIgUz0wO1M8YWEubGVuZ3RoO1MrKyludWxsPT1rW2FhW1NdLnRvXSYmKGtbYWFbU10udG9dPXt9KTt6PVtdO2ZvcihPPVUrMTtPPGIubGVuZ3RoO08rKyl7dmFyIGlhPXRoaXMuZWRpdG9yLmNzdlRvQXJyYXkoYltPXSk7aWYobnVsbD09aWEpe3ZhciByYT00MDxiW09dLmxlbmd0aD9iW09dLnN1YnN0cmluZygwLDQwKSsiLi4uIjpiW09dO3Rocm93IEVycm9yKHJhKyIgKCIrTysiKTpcbiIrbXhSZXNvdXJjZXMuZ2V0KCJjb250YWluc1ZhbGlkYXRpb25FcnJvcnMiKSk7fTA8aWEubGVuZ3RoJiZ6LnB1c2goaWEpfUkubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKE89MDtPPHoubGVuZ3RoO08rKyl7dmFyIGlhPXpbT10sTj1udWxsLG1hPW51bGwhPWNhP0craWFbY2FdOm51bGw7bnVsbCE9bWEmJihOPUkubW9kZWwuZ2V0Q2VsbChtYSkpO3ZhciBiPW51bGwhPU4sVz1uZXcgbXhDZWxsKFosbmV3IG14R2VvbWV0cnkoZmEsZWEsMCwwKSxtfHwid2hpdGVTcGFjZT13cmFwO2h0bWw9MTsiKTsKVy52ZXJ0ZXg9ITA7Vy5pZD1tYTtmb3IodmFyIFQ9MDtUPGlhLmxlbmd0aDtUKyspSS5zZXRBdHRyaWJ1dGVGb3JDZWxsKFcsTFtUXSxpYVtUXSk7aWYobnVsbCE9RSYmbnVsbCE9QSl7dmFyIHBhPUFbVy5nZXRBdHRyaWJ1dGUoRSldO251bGwhPXBhJiZJLmxhYmVsQ2hhbmdlZChXLHBhKX1pZihudWxsIT14JiZudWxsIT1xKXt2YXIgc2E9cVtXLmdldEF0dHJpYnV0ZSh4KV07bnVsbCE9c2EmJihXLnN0eWxlPXNhKX1JLnNldEF0dHJpYnV0ZUZvckNlbGwoVywicGxhY2Vob2xkZXJzIiwiMSIpO1cuc3R5bGU9SS5yZXBsYWNlUGxhY2Vob2xkZXJzKFcsVy5zdHlsZSk7YiYmKEkubW9kZWwuc2V0R2VvbWV0cnkoTixXLmdlb21ldHJ5KSxJLm1vZGVsLnNldFN0eWxlKE4sVy5zdHlsZSksMD5teFV0aWxzLmluZGV4T2YoZSxOKSYmZS5wdXNoKE4pKTtOPVc7aWYoIWIpZm9yKFM9MDtTPGFhLmxlbmd0aDtTKyspa1thYVtTXS50b11bTi5nZXRBdHRyaWJ1dGUoYWFbU10udG8pXT1OO251bGwhPQpnYSYmImxpbmsiIT1nYSYmKEkuc2V0TGlua0ZvckNlbGwoTixOLmdldEF0dHJpYnV0ZShnYSkpLEkuc2V0QXR0cmlidXRlRm9yQ2VsbChOLGdhLG51bGwpKTtJLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgiY2VsbHNJbnNlcnRlZCIsImNlbGxzIixbTl0pKTt2YXIgaGE9dGhpcy5lZGl0b3IuZ3JhcGguZ2V0UHJlZmVycmVkU2l6ZUZvckNlbGwoTik7Ti52ZXJ0ZXgmJihudWxsIT1KJiZudWxsIT1OLmdldEF0dHJpYnV0ZShKKSYmKE4uZ2VvbWV0cnkueD1mYStwYXJzZUZsb2F0KE4uZ2V0QXR0cmlidXRlKEopKSksbnVsbCE9dSYmbnVsbCE9Ti5nZXRBdHRyaWJ1dGUodSkmJihOLmdlb21ldHJ5Lnk9WStwYXJzZUZsb2F0KE4uZ2V0QXR0cmlidXRlKHUpKSksIkAiPT1GLmNoYXJBdCgwKSYmbnVsbCE9Ti5nZXRBdHRyaWJ1dGUoRi5zdWJzdHJpbmcoMSkpP04uZ2VvbWV0cnkud2lkdGg9cGFyc2VGbG9hdChOLmdldEF0dHJpYnV0ZShGLnN1YnN0cmluZygxKSkpOk4uZ2VvbWV0cnkud2lkdGg9CiJhdXRvIj09Rj9oYS53aWR0aCtQOnBhcnNlRmxvYXQoRiksIkAiPT1ILmNoYXJBdCgwKSYmbnVsbCE9Ti5nZXRBdHRyaWJ1dGUoSC5zdWJzdHJpbmcoMSkpP04uZ2VvbWV0cnkuaGVpZ2h0PXBhcnNlRmxvYXQoTi5nZXRBdHRyaWJ1dGUoSC5zdWJzdHJpbmcoMSkpKTpOLmdlb21ldHJ5LmhlaWdodD0iYXV0byI9PUg/aGEuaGVpZ2h0K1A6cGFyc2VGbG9hdChIKSxlYSs9Ti5nZW9tZXRyeS5oZWlnaHQrQik7Yj8obnVsbD09ZlttYV0mJihmW21hXT1bXSksZlttYV0ucHVzaChOKSk6KEQ9bnVsbCE9UT9JLm1vZGVsLmdldENlbGwoRytpYVtRXSk6bnVsbCxkLnB1c2goTiksbnVsbCE9RD8oRC5zdHlsZT1JLnJlcGxhY2VQbGFjZWhvbGRlcnMoRCxDKSxJLmFkZENlbGwoTixEKSk6ZS5wdXNoKEkuYWRkQ2VsbChOKSkpfWZvcih2YXIgcWE9ZS5zbGljZSgpLG5hPWUuc2xpY2UoKSxTPTA7UzxhYS5sZW5ndGg7UysrKWZvcih2YXIgemE9YWFbU10sTz0wO088ZC5sZW5ndGg7TysrKXt2YXIgTj0KZFtPXSxCYT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIsYyl7dmFyIGQ9Yi5nZXRBdHRyaWJ1dGUoYy5mcm9tKTtpZihudWxsIT1kJiYoSS5zZXRBdHRyaWJ1dGVGb3JDZWxsKGIsYy5mcm9tLG51bGwpLCIiIT1kKSlmb3IodmFyIGQ9ZC5zcGxpdCgiLCIpLGU9MDtlPGQubGVuZ3RoO2UrKyl7dmFyIGY9a1tjLnRvXVtkW2VdXTtpZihudWxsIT1mKXt2YXIgZz1jLmxhYmVsO251bGwhPWMuZnJvbWxhYmVsJiYoZz0oYi5nZXRBdHRyaWJ1dGUoYy5mcm9tbGFiZWwpfHwiIikrKGd8fCIiKSk7bnVsbCE9Yy50b2xhYmVsJiYoZz0oZ3x8IiIpKyhmLmdldEF0dHJpYnV0ZShjLnRvbGFiZWwpfHwiIikpO3ZhciBsPSJ0YXJnZXQiPT1jLnBsYWNlaG9sZGVycz09IWMuaW52ZXJ0P2Y6YSxsPW51bGwhPWMuc3R5bGU/SS5yZXBsYWNlUGxhY2Vob2xkZXJzKGwsYy5zdHlsZSk6SS5jcmVhdGVDdXJyZW50RWRnZVN0eWxlKCksZz1JLmluc2VydEVkZ2UobnVsbCxudWxsLGd8fCIiLGMuaW52ZXJ0PwpmOmEsYy5pbnZlcnQ/YTpmLGwpO2lmKG51bGwhPWMubGFiZWxzKWZvcihsPTA7bDxjLmxhYmVscy5sZW5ndGg7bCsrKXt2YXIgbT1jLmxhYmVsc1tsXSxwPW5ldyBteENlbGwobS5sYWJlbHx8bCxuZXcgbXhHZW9tZXRyeShudWxsIT1tLng/bS54OjAsbnVsbCE9bS55P20ueTowLDAsMCksInJlc2l6YWJsZT0wO2h0bWw9MTsiKTtwLnZlcnRleD0hMDtwLmNvbm5lY3RhYmxlPSExO3AuZ2VvbWV0cnkucmVsYXRpdmU9ITA7aWYobnVsbCE9bS5keHx8bnVsbCE9bS5keSlwLmdlb21ldHJ5Lm9mZnNldD1uZXcgbXhQb2ludChudWxsIT1tLmR4P20uZHg6MCxudWxsIT1tLmR5P20uZHk6MCk7Zy5pbnNlcnQocCl9bmEucHVzaChnKTtteFV0aWxzLnJlbW92ZShjLmludmVydD9hOmYscWEpfX19KTtCYShOLE4semEpO2lmKG51bGwhPWZbTi5pZF0pZm9yKFQ9MDtUPGZbTi5pZF0ubGVuZ3RoO1QrKylCYShOLGZbTi5pZF1bVF0semEpfWlmKG51bGwhPWRhKWZvcihPPTA7TzxkLmxlbmd0aDtPKyspZm9yKE49CmRbT10sVD0wO1Q8ZGEubGVuZ3RoO1QrKylJLnNldEF0dHJpYnV0ZUZvckNlbGwoTixteFV0aWxzLnRyaW0oZGFbVF0pLG51bGwpO2lmKDA8ZS5sZW5ndGgpe3ZhciBvYT1uZXcgbXhQYXJhbGxlbEVkZ2VMYXlvdXQoSSk7b2Euc3BhY2luZz1LO3ZhciB3YT1mdW5jdGlvbigpezA8b2Euc3BhY2luZyYmb2EuZXhlY3V0ZShJLmdldERlZmF1bHRQYXJlbnQoKSk7Zm9yKHZhciBhPTA7YTxlLmxlbmd0aDthKyspe3ZhciBiPUkuZ2V0Q2VsbEdlb21ldHJ5KGVbYV0pO2IueD1NYXRoLnJvdW5kKEkuc25hcChiLngpKTtiLnk9TWF0aC5yb3VuZChJLnNuYXAoYi55KSk7ImF1dG8iPT1GJiYoYi53aWR0aD1NYXRoLnJvdW5kKEkuc25hcChiLndpZHRoKSkpOyJhdXRvIj09SCYmKGIuaGVpZ2h0PU1hdGgucm91bmQoSS5zbmFwKGIuaGVpZ2h0KSkpfX07aWYoIlsiPT1YLmNoYXJBdCgwKSl7dmFyIHhhPVI7SS52aWV3LnZhbGlkYXRlKCk7dGhpcy5leGVjdXRlTGF5b3V0TGlzdChKU09OLnBhcnNlKFgpLApmdW5jdGlvbigpe3dhKCk7eGEoKX0pO1I9bnVsbH1lbHNlIGlmKCJjaXJjbGUiPT1YKXt2YXIga2E9bmV3IG14Q2lyY2xlTGF5b3V0KEkpO2thLnJlc2V0RWRnZXM9ITE7dmFyIHRhPWthLmlzVmVydGV4SWdub3JlZDtrYS5pc1ZlcnRleElnbm9yZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRhLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8MD5teFV0aWxzLmluZGV4T2YoZSxhKX07dGhpcy5leGVjdXRlTGF5b3V0KGZ1bmN0aW9uKCl7a2EuZXhlY3V0ZShJLmdldERlZmF1bHRQYXJlbnQoKSk7d2EoKX0sITAsUik7Uj1udWxsfWVsc2UgaWYoImhvcml6b250YWx0cmVlIj09WHx8InZlcnRpY2FsdHJlZSI9PVh8fCJhdXRvIj09WCYmbmEubGVuZ3RoPT0yKmUubGVuZ3RoLTEmJjE9PXFhLmxlbmd0aCl7SS52aWV3LnZhbGlkYXRlKCk7dmFyIEFhPW5ldyBteENvbXBhY3RUcmVlTGF5b3V0KEksImhvcml6b250YWx0cmVlIj09WCk7QWEubGV2ZWxEaXN0YW5jZT1CO0FhLmVkZ2VSb3V0aW5nPSExO0FhLnJlc2V0RWRnZXM9CiExO3RoaXMuZXhlY3V0ZUxheW91dChmdW5jdGlvbigpe0FhLmV4ZWN1dGUoSS5nZXREZWZhdWx0UGFyZW50KCksMDxxYS5sZW5ndGg/cWFbMF06bnVsbCl9LCEwLFIpO1I9bnVsbH1lbHNlIGlmKCJob3Jpem9udGFsZmxvdyI9PVh8fCJ2ZXJ0aWNhbGZsb3ciPT1YfHwiYXV0byI9PVgmJjE9PXFhLmxlbmd0aCl7SS52aWV3LnZhbGlkYXRlKCk7dmFyIHVhPW5ldyBteEhpZXJhcmNoaWNhbExheW91dChJLCJob3Jpem9udGFsZmxvdyI9PVg/bXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1Q6bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIKTt1YS5pbnRyYUNlbGxTcGFjaW5nPUI7dWEucGFyYWxsZWxFZGdlU3BhY2luZz1LO3VhLmludGVyUmFua0NlbGxTcGFjaW5nPU07dWEuZGlzYWJsZUVkZ2VTdHlsZT0hMTt0aGlzLmV4ZWN1dGVMYXlvdXQoZnVuY3Rpb24oKXt1YS5leGVjdXRlKEkuZ2V0RGVmYXVsdFBhcmVudCgpLG5hKTtJLm1vdmVDZWxscyhuYSxmYSxZKX0sITAsUik7Uj1udWxsfWVsc2UgaWYoIm9yZ2FuaWMiPT0KWHx8ImF1dG8iPT1YJiZuYS5sZW5ndGg+ZS5sZW5ndGgpe0kudmlldy52YWxpZGF0ZSgpO3ZhciBsYT1uZXcgbXhGYXN0T3JnYW5pY0xheW91dChJKTtsYS5mb3JjZUNvbnN0YW50PTMqQjtsYS5yZXNldEVkZ2VzPSExO3ZhciBJYT1sYS5pc1ZlcnRleElnbm9yZWQ7bGEuaXNWZXJ0ZXhJZ25vcmVkPWZ1bmN0aW9uKGEpe3JldHVybiBJYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fDA+bXhVdGlscy5pbmRleE9mKGUsYSl9O29hPW5ldyBteFBhcmFsbGVsRWRnZUxheW91dChJKTtvYS5zcGFjaW5nPUs7dGhpcy5leGVjdXRlTGF5b3V0KGZ1bmN0aW9uKCl7bGEuZXhlY3V0ZShJLmdldERlZmF1bHRQYXJlbnQoKSk7d2EoKX0sITAsUik7Uj1udWxsfX10aGlzLmhpZGVEaWFsb2coKX1maW5hbGx5e0kubW9kZWwuZW5kVXBkYXRlKCl9bnVsbCE9UiYmUigpfX1jYXRjaChKYSl7dGhpcy5oYW5kbGVFcnJvcihKYSl9fTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0U2VhcmNoPWZ1bmN0aW9uKGEpe3ZhciBiPQoiIjtpZigiMSIhPXVybFBhcmFtcy5vZmZsaW5lJiYiMSIhPXVybFBhcmFtcy5kZW1vJiZudWxsIT1hJiYwPHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gubGVuZ3RoKXt2YXIgYz0iPyIsZDtmb3IoZCBpbiB1cmxQYXJhbXMpMD5teFV0aWxzLmluZGV4T2YoYSxkKSYmbnVsbCE9dXJsUGFyYW1zW2RdJiYoYis9YytkKyI9Iit1cmxQYXJhbXNbZF0sYz0iJiIpfWVsc2UgYj13aW5kb3cubG9jYXRpb24uc2VhcmNoO3JldHVybiBifTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0VXJsPWZ1bmN0aW9uKGEpe2E9bnVsbCE9YT9hOndpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTt2YXIgYj0wPGEuaW5kZXhPZigiPyIpPzE6MDtpZigiMSI9PXVybFBhcmFtcy5vZmZsaW5lKWErPXdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7ZWxzZXt2YXIgYz0idG1wIGxpYnMgY2xpYnMgc3RhdGUgZmlsZUlkIGNvZGUgc2hhcmUgbm90aXRsZSBkYXRhIHVybCBlbWJlZCBjbGllbnQgY3JlYXRlIHRpdGxlIHNwbGFzaCIuc3BsaXQoIiAiKSwKZDtmb3IoZCBpbiB1cmxQYXJhbXMpMD5teFV0aWxzLmluZGV4T2YoYyxkKSYmKGE9MD09Yj9hKyI/IjphKyImIixudWxsIT11cmxQYXJhbXNbZF0mJihhKz1kKyI9Iit1cmxQYXJhbXNbZF0sYisrKSl9cmV0dXJuIGF9O0VkaXRvclVpLnByb3RvdHlwZS5zaG93TGlua0RpYWxvZz1mdW5jdGlvbihhLGMsZCl7YT1uZXcgTGlua0RpYWxvZyh0aGlzLGEsYyxkLCEwKTt0aGlzLnNob3dEaWFsb2coYS5jb250YWluZXIsNTYwLDEzMCwhMCwhMCk7YS5pbml0KCl9O3ZhciBtPUVkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVPdXRsaW5lO0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVPdXRsaW5lPWZ1bmN0aW9uKGEpe3ZhciBiPW0uYXBwbHkodGhpcyxhcmd1bWVudHMpLGM9dGhpcy5lZGl0b3IuZ3JhcGgsZD1iLmdldFNvdXJjZUdyYXBoQm91bmRzO2IuZ2V0U291cmNlR3JhcGhCb3VuZHM9ZnVuY3Rpb24oKXtpZihteFV0aWxzLmhhc1Njcm9sbGJhcnMoYy5jb250YWluZXIpJiZjLnBhZ2VWaXNpYmxlJiYKbnVsbCE9dGhpcy5zb3VyY2UubWluaW11bUdyYXBoU2l6ZSl7dmFyIGE9dGhpcy5zb3VyY2UuZ2V0UGFnZVBhZGRpbmcoKSxiPXRoaXMuc291cmNlLnZpZXcuc2NhbGU7cmV0dXJuIG5ldyBteFJlY3RhbmdsZSgwLDAsTWF0aC5jZWlsKHRoaXMuc291cmNlLm1pbmltdW1HcmFwaFNpemUud2lkdGgtMiphLngvYiksTWF0aC5jZWlsKHRoaXMuc291cmNlLm1pbmltdW1HcmFwaFNpemUuaGVpZ2h0LTIqYS55L2IpKX1yZXR1cm4gZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBmPWIuZ2V0U291cmNlQ29udGFpbmVyU2l6ZTtiLmdldFNvdXJjZUNvbnRhaW5lclNpemU9ZnVuY3Rpb24oKXtpZihteFV0aWxzLmhhc1Njcm9sbGJhcnMoYy5jb250YWluZXIpJiZudWxsIT10aGlzLnNvdXJjZS5taW5pbXVtR3JhcGhTaXplKXt2YXIgYT10aGlzLnNvdXJjZS5nZXRQYWdlUGFkZGluZygpLGI9dGhpcy5zb3VyY2Uudmlldy5zY2FsZTtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKDAsMCxNYXRoLmNlaWwodGhpcy5zb3VyY2UubWluaW11bUdyYXBoU2l6ZS53aWR0aCoKYi0yKmEueCksTWF0aC5jZWlsKHRoaXMuc291cmNlLm1pbmltdW1HcmFwaFNpemUuaGVpZ2h0KmItMiphLnkpKX1yZXR1cm4gZi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2IuZ2V0T3V0bGluZU9mZnNldD1mdW5jdGlvbihhKXtpZihteFV0aWxzLmhhc1Njcm9sbGJhcnMoYy5jb250YWluZXIpJiZudWxsIT10aGlzLnNvdXJjZS5taW5pbXVtR3JhcGhTaXplKXt2YXIgZD10aGlzLnNvdXJjZS5nZXRQYWdlUGFkZGluZygpO3JldHVybiBuZXcgbXhQb2ludChNYXRoLnJvdW5kKE1hdGgubWF4KDAsKGIub3V0bGluZS5jb250YWluZXIuY2xpZW50V2lkdGgvYS0odGhpcy5zb3VyY2UubWluaW11bUdyYXBoU2l6ZS53aWR0aC0yKmQueCkpLzIpLWQueCksTWF0aC5yb3VuZChNYXRoLm1heCgwLChiLm91dGxpbmUuY29udGFpbmVyLmNsaWVudEhlaWdodC9hLSh0aGlzLnNvdXJjZS5taW5pbXVtR3JhcGhTaXplLmhlaWdodC0yKmQueSkpLzIpLWQueS01L2EpKX1yZXR1cm4gbmV3IG14UG9pbnQoOC8KYSw4L2EpfTt2YXIgaz1iLmluaXQ7Yi5pbml0PWZ1bmN0aW9uKCl7ay5hcHBseSh0aGlzLGFyZ3VtZW50cyk7Yi5vdXRsaW5lLnZpZXcuZ2V0QmFja2dyb3VuZFBhZ2VCb3VuZHM9ZnVuY3Rpb24oKXt2YXIgYT1jLmdldFBhZ2VMYXlvdXQoKSxiPWMuZ2V0UGFnZVNpemUoKTtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKHRoaXMuc2NhbGUqKHRoaXMudHJhbnNsYXRlLngrYS54KmIud2lkdGgpLHRoaXMuc2NhbGUqKHRoaXMudHJhbnNsYXRlLnkrYS55KmIuaGVpZ2h0KSx0aGlzLnNjYWxlKmEud2lkdGgqYi53aWR0aCx0aGlzLnNjYWxlKmEuaGVpZ2h0KmIuaGVpZ2h0KX07Yi5vdXRsaW5lLnZpZXcudmFsaWRhdGVCYWNrZ3JvdW5kUGFnZSgpfTt0aGlzLmVkaXRvci5hZGRMaXN0ZW5lcigicGFnZVNlbGVjdGVkIixmdW5jdGlvbihhLGMpe3ZhciBkPWMuZ2V0UHJvcGVydHkoImNoYW5nZSIpLGU9Yi5zb3VyY2UsZj1iLm91dGxpbmU7Zi5wYWdlU2NhbGU9ZS5wYWdlU2NhbGU7Zi5wYWdlRm9ybWF0PQplLnBhZ2VGb3JtYXQ7Zi5iYWNrZ3JvdW5kPWUuYmFja2dyb3VuZDtmLnBhZ2VWaXNpYmxlPWUucGFnZVZpc2libGU7Zi5iYWNrZ3JvdW5kPWUuYmFja2dyb3VuZDt2YXIgZz1teFV0aWxzLmdldEN1cnJlbnRTdHlsZShlLmNvbnRhaW5lcik7Zi5jb250YWluZXIuc3R5bGUuYmFja2dyb3VuZENvbG9yPWcuYmFja2dyb3VuZENvbG9yO251bGwhPWUudmlldy5iYWNrZ3JvdW5kUGFnZVNoYXBlJiZudWxsIT1mLnZpZXcuYmFja2dyb3VuZFBhZ2VTaGFwZSYmKGYudmlldy5iYWNrZ3JvdW5kUGFnZVNoYXBlLmZpbGw9ZS52aWV3LmJhY2tncm91bmRQYWdlU2hhcGUuZmlsbCk7Yi5vdXRsaW5lLnZpZXcuY2xlYXIoZC5wcmV2aW91c1BhZ2Uucm9vdCwhMCk7Yi5vdXRsaW5lLnZpZXcudmFsaWRhdGUoKX0pO3JldHVybiBifTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0U2VydmljZUNvdW50PWZ1bmN0aW9uKGEsYyl7dmFyIGI9MTtudWxsPT10aGlzLmRyaXZlJiYiZnVuY3Rpb24iIT09dHlwZW9mIHdpbmRvdy5Ecml2ZUNsaWVudHx8CmIrKztjfHxudWxsPT10aGlzLmRyb3Bib3gmJiJmdW5jdGlvbiIhPT10eXBlb2Ygd2luZG93LkRyb3Bib3hDbGllbnR8fGIrKztudWxsPT10aGlzLm9uZURyaXZlJiYiZnVuY3Rpb24iIT09dHlwZW9mIHdpbmRvdy5PbmVEcml2ZUNsaWVudHx8YisrO2N8fG51bGw9PXRoaXMuZ2l0SHVifHxiKys7Y3x8bnVsbD09dGhpcy5naXRMYWJ8fGIrKztjJiZhJiZpc0xvY2FsU3RvcmFnZSYmIjEiPT11cmxQYXJhbXMuYnJvd3NlciYmYisrO3JldHVybiBifTtFZGl0b3JVaS5wcm90b3R5cGUudXBkYXRlVWk9ZnVuY3Rpb24oKXt0aGlzLnVwZGF0ZUJ1dHRvbkNvbnRhaW5lcigpO3RoaXMudXBkYXRlQWN0aW9uU3RhdGVzKCk7dmFyIGE9dGhpcy5nZXRDdXJyZW50RmlsZSgpLGM9bnVsbCE9YXx8IjEiPT11cmxQYXJhbXMuZW1iZWQmJnRoaXMuZWRpdG9yLmdyYXBoLmlzRW5hYmxlZCgpO3RoaXMubWVudXMuZ2V0KCJ2aWV3UGFuZWxzIikuc2V0RW5hYmxlZChjKTt0aGlzLm1lbnVzLmdldCgidmlld1pvb20iKS5zZXRFbmFibGVkKGMpOwp2YXIgZD0oIjEiIT11cmxQYXJhbXMuZW1iZWR8fCF0aGlzLmVkaXRvci5ncmFwaC5pc0VuYWJsZWQoKSkmJihudWxsPT1hfHxhLmlzUmVzdHJpY3RlZCgpKTt0aGlzLmFjdGlvbnMuZ2V0KCJtYWtlQ29weSIpLnNldEVuYWJsZWQoIWQpO3RoaXMuYWN0aW9ucy5nZXQoInByaW50Iikuc2V0RW5hYmxlZCghZCk7dGhpcy5tZW51cy5nZXQoImV4cG9ydEFzIikuc2V0RW5hYmxlZCghZCk7dGhpcy5tZW51cy5nZXQoImVtYmVkIikuc2V0RW5hYmxlZCghZCk7ZD0iMSIhPXVybFBhcmFtcy5lbWJlZHx8dGhpcy5lZGl0b3IuZ3JhcGguaXNFbmFibGVkKCk7dGhpcy5tZW51cy5nZXQoImV4dHJhcyIpLnNldEVuYWJsZWQoZCk7RWRpdG9yLmVuYWJsZUN1c3RvbUxpYnJhcmllcyYmKHRoaXMubWVudXMuZ2V0KCJvcGVuTGlicmFyeUZyb20iKS5zZXRFbmFibGVkKGQpLHRoaXMubWVudXMuZ2V0KCJuZXdMaWJyYXJ5Iikuc2V0RW5hYmxlZChkKSk7YT0iMSI9PXVybFBhcmFtcy5lbWJlZCYmdGhpcy5lZGl0b3IuZ3JhcGguaXNFbmFibGVkKCl8fApudWxsIT1hJiZhLmlzRWRpdGFibGUoKTt0aGlzLmFjdGlvbnMuZ2V0KCJpbWFnZSIpLnNldEVuYWJsZWQoYyk7dGhpcy5hY3Rpb25zLmdldCgiem9vbUluIikuc2V0RW5hYmxlZChjKTt0aGlzLmFjdGlvbnMuZ2V0KCJ6b29tT3V0Iikuc2V0RW5hYmxlZChjKTt0aGlzLmFjdGlvbnMuZ2V0KCJyZXNldFZpZXciKS5zZXRFbmFibGVkKGMpO3RoaXMuYWN0aW9ucy5nZXQoInVuZG8iKS5zZXRFbmFibGVkKHRoaXMuY2FuVW5kbygpJiZhKTt0aGlzLmFjdGlvbnMuZ2V0KCJyZWRvIikuc2V0RW5hYmxlZCh0aGlzLmNhblJlZG8oKSYmYSk7dGhpcy5tZW51cy5nZXQoImVkaXQiKS5zZXRFbmFibGVkKGMpO3RoaXMubWVudXMuZ2V0KCJ2aWV3Iikuc2V0RW5hYmxlZChjKTt0aGlzLm1lbnVzLmdldCgiaW1wb3J0RnJvbSIpLnNldEVuYWJsZWQoYSk7dGhpcy5tZW51cy5nZXQoImFycmFuZ2UiKS5zZXRFbmFibGVkKGEpO251bGwhPXRoaXMudG9vbGJhciYmKG51bGwhPXRoaXMudG9vbGJhci5lZGdlU2hhcGVNZW51JiYKdGhpcy50b29sYmFyLmVkZ2VTaGFwZU1lbnUuc2V0RW5hYmxlZChhKSxudWxsIT10aGlzLnRvb2xiYXIuZWRnZVN0eWxlTWVudSYmdGhpcy50b29sYmFyLmVkZ2VTdHlsZU1lbnUuc2V0RW5hYmxlZChhKSk7dGhpcy51cGRhdGVVc2VyRWxlbWVudCgpfTtFZGl0b3JVaS5wcm90b3R5cGUudXBkYXRlQnV0dG9uQ29udGFpbmVyPWZ1bmN0aW9uKCl7fTtFZGl0b3JVaS5wcm90b3R5cGUudXBkYXRlVXNlckVsZW1lbnQ9ZnVuY3Rpb24oKXt9O0VkaXRvclVpLnByb3RvdHlwZS5zY2hlZHVsZVNhbml0eUNoZWNrPWZ1bmN0aW9uKCl7fTtFZGl0b3JVaS5wcm90b3R5cGUuc3RvcFNhbml0eUNoZWNrPWZ1bmN0aW9uKCl7fTtFZGl0b3JVaS5wcm90b3R5cGUuaXNEaWFncmFtQWN0aXZlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRDdXJyZW50RmlsZSgpO3JldHVybiBudWxsIT1hJiZhLmlzRWRpdGFibGUoKXx8IjEiPT11cmxQYXJhbXMuZW1iZWQmJnRoaXMuZWRpdG9yLmdyYXBoLmlzRW5hYmxlZCgpfTsKdmFyIGs9RWRpdG9yVWkucHJvdG90eXBlLnVwZGF0ZUFjdGlvblN0YXRlcztFZGl0b3JVaS5wcm90b3R5cGUudXBkYXRlQWN0aW9uU3RhdGVzPWZ1bmN0aW9uKCl7ay5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGE9dGhpcy5lZGl0b3IuZ3JhcGgsYz10aGlzLmlzRGlhZ3JhbUFjdGl2ZSgpLGQ9dGhpcy5nZXRDdXJyZW50RmlsZSgpO3RoaXMuYWN0aW9ucy5nZXQoInBhZ2VTZXR1cCIpLnNldEVuYWJsZWQoYyk7dGhpcy5hY3Rpb25zLmdldCgiYXV0b3NhdmUiKS5zZXRFbmFibGVkKG51bGwhPWQmJmQuaXNFZGl0YWJsZSgpJiZkLmlzQXV0b3NhdmVPcHRpb25hbCgpKTt0aGlzLmFjdGlvbnMuZ2V0KCJndWlkZXMiKS5zZXRFbmFibGVkKGMpO3RoaXMuYWN0aW9ucy5nZXQoImVkaXREYXRhIikuc2V0RW5hYmxlZChjKTt0aGlzLmFjdGlvbnMuZ2V0KCJzaGFkb3dWaXNpYmxlIikuc2V0RW5hYmxlZChjKTt0aGlzLmFjdGlvbnMuZ2V0KCJjb25uZWN0aW9uQXJyb3dzIikuc2V0RW5hYmxlZChjKTsKdGhpcy5hY3Rpb25zLmdldCgiY29ubmVjdGlvblBvaW50cyIpLnNldEVuYWJsZWQoYyk7dGhpcy5hY3Rpb25zLmdldCgiY29weVN0eWxlIikuc2V0RW5hYmxlZChjJiYhYS5pc1NlbGVjdGlvbkVtcHR5KCkpO3RoaXMuYWN0aW9ucy5nZXQoInBhc3RlU3R5bGUiKS5zZXRFbmFibGVkKGMmJiFhLmlzU2VsZWN0aW9uRW1wdHkoKSk7dGhpcy5hY3Rpb25zLmdldCgiZWRpdEdlb21ldHJ5Iikuc2V0RW5hYmxlZChhLmdldE1vZGVsKCkuaXNWZXJ0ZXgoYS5nZXRTZWxlY3Rpb25DZWxsKCkpKTt0aGlzLmFjdGlvbnMuZ2V0KCJjcmVhdGVTaGFwZSIpLnNldEVuYWJsZWQoYyk7dGhpcy5hY3Rpb25zLmdldCgiY3JlYXRlUmV2aXNpb24iKS5zZXRFbmFibGVkKGMpO3RoaXMuYWN0aW9ucy5nZXQoIm1vdmVUb0ZvbGRlciIpLnNldEVuYWJsZWQobnVsbCE9ZCk7dGhpcy5hY3Rpb25zLmdldCgibWFrZUNvcHkiKS5zZXRFbmFibGVkKG51bGwhPWQmJiFkLmlzUmVzdHJpY3RlZCgpKTt0aGlzLmFjdGlvbnMuZ2V0KCJlZGl0RGlhZ3JhbSIpLnNldEVuYWJsZWQoYyYmCihudWxsPT1kfHwhZC5pc1Jlc3RyaWN0ZWQoKSkpO3RoaXMuYWN0aW9ucy5nZXQoInB1Ymxpc2hMaW5rIikuc2V0RW5hYmxlZChudWxsIT1kJiYhZC5pc1Jlc3RyaWN0ZWQoKSk7dGhpcy5hY3Rpb25zLmdldCgidGFncyIpLnNldEVuYWJsZWQoImhpZGRlbiIhPXRoaXMuZGlhZ3JhbUNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5KTt0aGlzLmFjdGlvbnMuZ2V0KCJmaW5kIikuc2V0RW5hYmxlZCgiaGlkZGVuIiE9dGhpcy5kaWFncmFtQ29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkpO3RoaXMuYWN0aW9ucy5nZXQoImxheWVycyIpLnNldEVuYWJsZWQoImhpZGRlbiIhPXRoaXMuZGlhZ3JhbUNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5KTt0aGlzLmFjdGlvbnMuZ2V0KCJvdXRsaW5lIikuc2V0RW5hYmxlZCgiaGlkZGVuIiE9dGhpcy5kaWFncmFtQ29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkpO3RoaXMuYWN0aW9ucy5nZXQoInJlbmFtZSIpLnNldEVuYWJsZWQobnVsbCE9ZCYmZC5pc1JlbmFtYWJsZSgpfHwKIjEiPT11cmxQYXJhbXMuZW1iZWQpO3RoaXMuYWN0aW9ucy5nZXQoImNsb3NlIikuc2V0RW5hYmxlZChudWxsIT1kKTt0aGlzLm1lbnVzLmdldCgicHVibGlzaCIpLnNldEVuYWJsZWQobnVsbCE9ZCYmIWQuaXNSZXN0cmljdGVkKCkpO2E9YS52aWV3LmdldFN0YXRlKGEuZ2V0U2VsZWN0aW9uQ2VsbCgpKTt0aGlzLmFjdGlvbnMuZ2V0KCJlZGl0U2hhcGUiKS5zZXRFbmFibGVkKGMmJm51bGwhPWEmJm51bGwhPWEuc2hhcGUmJm51bGwhPWEuc2hhcGUuc3RlbmNpbCl9O3ZhciBxPUVkaXRvclVpLnByb3RvdHlwZS5kZXN0cm95O0VkaXRvclVpLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5leHBvcnREaWFsb2cmJih0aGlzLmV4cG9ydERpYWxvZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZXhwb3J0RGlhbG9nKSx0aGlzLmV4cG9ydERpYWxvZz1udWxsKTtxLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07bnVsbCE9d2luZG93LkV4cG9ydERpYWxvZyYmKEV4cG9ydERpYWxvZy5zaG93WG1sT3B0aW9uPQohMSxFeHBvcnREaWFsb2cuc2hvd0dpZk9wdGlvbj0hMSxFeHBvcnREaWFsb2cuZXhwb3J0RmlsZT1mdW5jdGlvbihhLGMsZCxmLGssbSxxKXt2YXIgYj1hLmVkaXRvci5ncmFwaDtpZigieG1sIj09ZClhLmhpZGVEaWFsb2coKSxhLnNhdmVEYXRhKGMsInhtbCIsbXhVdGlscy5nZXRYbWwoYS5lZGl0b3IuZ2V0R3JhcGhYbWwoKSksInRleHQveG1sIik7ZWxzZSBpZigic3ZnIj09ZClhLmhpZGVEaWFsb2coKSxhLnNhdmVEYXRhKGMsInN2ZyIsbXhVdGlscy5nZXRYbWwoYi5nZXRTdmcoZixrLG0pKSwiaW1hZ2Uvc3ZnK3htbCIpO2Vsc2V7dmFyIGU9YS5nZXRGaWxlRGF0YSghMCxudWxsLG51bGwsbnVsbCxudWxsLCEwKSxnPWIuZ2V0R3JhcGhCb3VuZHMoKSxsPU1hdGguZmxvb3IoZy53aWR0aCprL2Iudmlldy5zY2FsZSkscD1NYXRoLmZsb29yKGcuaGVpZ2h0KmsvYi52aWV3LnNjYWxlKTtpZihlLmxlbmd0aDw9TUFYX1JFUVVFU1RfU0laRSYmbCpwPE1BWF9BUkVBKWlmKGEuaGlkZURpYWxvZygpLAoicG5nIiE9ZCYmImpwZyIhPWQmJiJqcGVnIiE9ZHx8IWEuaXNFeHBvcnRUb0NhbnZhcygpKXt2YXIgbj17Z2xvYmFsVmFyczpiLmdldEV4cG9ydFZhcmlhYmxlcygpfTthLnNhdmVSZXF1ZXN0KGMsZCxmdW5jdGlvbihhLGIpe3JldHVybiBuZXcgbXhYbWxSZXF1ZXN0KEVYUE9SVF9VUkwsImZvcm1hdD0iK2QrIiZiYXNlNjQ9IisoYnx8IjAiKSsobnVsbCE9YT8iJmZpbGVuYW1lPSIrZW5jb2RlVVJJQ29tcG9uZW50KGEpOiIiKSsiJmV4dHJhcz0iK2VuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShuKSkrKDA8cT8iJmRwaT0iK3E6IiIpKyImYmc9IisobnVsbCE9Zj9mOiJub25lIikrIiZ3PSIrbCsiJmg9IitwKyImYm9yZGVyPSIrbSsiJnhtbD0iK2VuY29kZVVSSUNvbXBvbmVudChlKSl9KX1lbHNlInBuZyI9PWQ/YS5leHBvcnRJbWFnZShrLG51bGw9PWZ8fCJub25lIj09ZiwhMCwhMSwhMSxtLCEwLCExLG51bGwsbnVsbCxxKTphLmV4cG9ydEltYWdlKGssITEsITAsITEsCiExLG0sITAsITEsImpwZWciKTtlbHNlIG14VXRpbHMuYWxlcnQobXhSZXNvdXJjZXMuZ2V0KCJkcmF3aW5nVG9vTGFyZ2UiKSl9fSk7RWRpdG9yVWkucHJvdG90eXBlLmdldERpYWdyYW1UZXh0Q29udGVudD1mdW5jdGlvbigpe3RoaXMuZWRpdG9yLmdyYXBoLnNldEVuYWJsZWQoITEpO3ZhciBhPXRoaXMuZWRpdG9yLmdyYXBoLGM9IiI7aWYobnVsbCE9dGhpcy5wYWdlcylmb3IodmFyIGQ9MDtkPHRoaXMucGFnZXMubGVuZ3RoO2QrKyl7dmFyIGY9YTt0aGlzLmN1cnJlbnRQYWdlIT10aGlzLnBhZ2VzW2RdJiYoZj10aGlzLmNyZWF0ZVRlbXBvcmFyeUdyYXBoKGEuZ2V0U3R5bGVzaGVldCgpKSx0aGlzLnVwZGF0ZVBhZ2VSb290KHRoaXMucGFnZXNbZF0pLGYubW9kZWwuc2V0Um9vdCh0aGlzLnBhZ2VzW2RdLnJvb3QpKTtjKz10aGlzLnBhZ2VzW2RdLmdldE5hbWUoKSsiICIrZi5nZXRJbmRleGFibGVUZXh0KCkrIiAifWVsc2UgYz1hLmdldEluZGV4YWJsZVRleHQoKTt0aGlzLmVkaXRvci5ncmFwaC5zZXRFbmFibGVkKCEwKTsKcmV0dXJuIGN9O0VkaXRvclVpLnByb3RvdHlwZS5zaG93UmVtb3RlbHlTdG9yZWRMaWJyYXJ5PWZ1bmN0aW9uKGEpe3ZhciBiPXt9LGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Yy5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiO3ZhciBkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImgzIik7bXhVdGlscy53cml0ZShkLG14VXRpbHMuaHRtbEVudGl0aWVzKGEpKTtkLnN0eWxlLmNzc1RleHQ9IndpZHRoOjEwMCU7dGV4dC1hbGlnbjpjZW50ZXI7bWFyZ2luLXRvcDowcHg7bWFyZ2luLWJvdHRvbToxMnB4IjtjLmFwcGVuZENoaWxkKGQpO3ZhciBmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Yuc3R5bGUuY3NzVGV4dD0iYm9yZGVyOjFweCBzb2xpZCBsaWdodEdyYXk7b3ZlcmZsb3c6IGF1dG87aGVpZ2h0OjMwMHB4IjtmLmlubmVySFRNTD0nPGRpdiBzdHlsZT0idGV4dC1hbGlnbjpjZW50ZXI7cGFkZGluZzo4cHg7Ij48aW1nIHNyYz0iL2ltYWdlcy9zcGluLmdpZiI+PC9kaXY+JzsKdmFyIGs9e307dHJ5e3ZhciBtPW14U2V0dGluZ3MuZ2V0Q3VzdG9tTGlicmFyaWVzKCk7Zm9yKGE9MDthPG0ubGVuZ3RoO2ErKyl7dmFyIHE9bVthXTtpZigiUiI9PXEuc3Vic3RyaW5nKDAsMSkpe3ZhciB5PUpTT04ucGFyc2UoZGVjb2RlVVJJQ29tcG9uZW50KHEuc3Vic3RyaW5nKDEpKSk7a1t5WzBdXT17aWQ6eVswXSx0aXRsZTp5WzFdLGRvd25sb2FkVXJsOnlbMl19fX19Y2F0Y2goeCl7fXRoaXMucmVtb3RlSW52b2tlKCJnZXRDdXN0b21MaWJyYXJpZXMiLG51bGwsbnVsbCxmdW5jdGlvbihhKXtmLmlubmVySFRNTD0iIjtpZigwPT1hLmxlbmd0aClmLmlubmVySFRNTD0nPGRpdiBzdHlsZT0idGV4dC1hbGlnbjpjZW50ZXI7cGFkZGluZy10b3A6MjBweDtjb2xvcjpncmF5OyI+JytteFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQoIm5vTGlicmFyaWVzIikpKyI8L2Rpdj4iO2Vsc2UgZm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBkPWFbY107a1tkLmlkXSYmCihiW2QuaWRdPWQpO3ZhciBlPXRoaXMuYWRkQ2hlY2tib3goZixkLnRpdGxlLGtbZC5pZF0pOyhmdW5jdGlvbihhLGMpe214RXZlbnQuYWRkTGlzdGVuZXIoYywiY2hhbmdlIixmdW5jdGlvbigpe3RoaXMuY2hlY2tlZD9iW2EuaWRdPWE6ZGVsZXRlIGJbYS5pZF19KX0pKGQsZSl9fSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtmLmlubmVySFRNTD0iIjt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtiLnN0eWxlLnBhZGRpbmc9IjhweCI7Yi5zdHlsZS50ZXh0QWxpZ249ImNlbnRlciI7bXhVdGlscy53cml0ZShiLG14UmVzb3VyY2VzLmdldCgiZXJyb3IiKSsiOiAiKTtteFV0aWxzLndyaXRlKGIsbnVsbCE9YSYmbnVsbCE9YS5tZXNzYWdlP2EubWVzc2FnZTpteFJlc291cmNlcy5nZXQoInVua25vd25FcnJvciIpKTtmLmFwcGVuZENoaWxkKGIpfSkpO2MuYXBwZW5kQ2hpbGQoZik7Yz1uZXcgQ3VzdG9tRGlhbG9nKHRoaXMsYyxteFV0aWxzLmJpbmQodGhpcywKZnVuY3Rpb24oKXt0aGlzLnNwaW5uZXIuc3Bpbihkb2N1bWVudC5ib2R5LG14UmVzb3VyY2VzLmdldCgibG9hZGluZyIpKTt2YXIgYT0wLGM7Zm9yKGMgaW4gYiludWxsPT1rW2NdJiYoYSsrLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3RoaXMucmVtb3RlSW52b2tlKCJnZXRGaWxlQ29udGVudCIsW2IuZG93bmxvYWRVcmxdLG51bGwsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYyl7YS0tOzA9PWEmJnRoaXMuc3Bpbm5lci5zdG9wKCk7dHJ5e3RoaXMubG9hZExpYnJhcnkobmV3IFJlbW90ZUxpYnJhcnkodGhpcyxjLGIpKX1jYXRjaCh6KXt0aGlzLmhhbmRsZUVycm9yKHosbXhSZXNvdXJjZXMuZ2V0KCJlcnJvckxvYWRpbmdGaWxlIikpfX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7YS0tOzA9PWEmJnRoaXMuc3Bpbm5lci5zdG9wKCk7dGhpcy5oYW5kbGVFcnJvcihudWxsLG14UmVzb3VyY2VzLmdldCgiZXJyb3JMb2FkaW5nRmlsZSIpKX0pKX0pKGJbY10pKTsKZm9yKGMgaW4gayliW2NdfHx0aGlzLmNsb3NlTGlicmFyeShuZXcgUmVtb3RlTGlicmFyeSh0aGlzLG51bGwsa1tjXSkpOzA9PWEmJnRoaXMuc3Bpbm5lci5zdG9wKCl9KSxudWxsLG51bGwsImh0dHBzOi8vZGVzay5kcmF3LmlvL3N1cHBvcnQvc29sdXRpb25zL2FydGljbGVzLzE2MDAwMDkyNzYzIik7dGhpcy5zaG93RGlhbG9nKGMuY29udGFpbmVyLDM0MCwzNzUsITAsITAsbnVsbCxudWxsLG51bGwsbnVsbCwhMCl9O0VkaXRvclVpLnByb3RvdHlwZS5yZW1vdGVJbnZva2FibGVGbnM9e2dldERpYWdyYW1UZXh0Q29udGVudDp7aXNBc3luYzohMX0sZ2V0TG9jYWxTdG9yYWdlRmlsZTp7aXNBc3luYzohMSxhbGxvd2VkRG9tYWluczpbImFwcC5kaWFncmFtcy5uZXQiXX0sZ2V0TG9jYWxTdG9yYWdlRmlsZU5hbWVzOntpc0FzeW5jOiExLGFsbG93ZWREb21haW5zOlsiYXBwLmRpYWdyYW1zLm5ldCJdfSxzZXRNaWdyYXRlZEZsYWc6e2lzQXN5bmM6ITEsYWxsb3dlZERvbWFpbnM6WyJhcHAuZGlhZ3JhbXMubmV0Il19fTsKRWRpdG9yVWkucHJvdG90eXBlLnJlbW90ZUludm9rZUNhbGxiYWNrcz1bXTtFZGl0b3JVaS5wcm90b3R5cGUucmVtb3RlSW52b2tlUXVldWU9W107RWRpdG9yVWkucHJvdG90eXBlLmhhbmRsZVJlbW90ZUludm9rZVJlYWR5PWZ1bmN0aW9uKGEpe3RoaXMucmVtb3RlV2luPWE7Zm9yKHZhciBiPTA7Yjx0aGlzLnJlbW90ZUludm9rZVF1ZXVlLmxlbmd0aDtiKyspYS5wb3N0TWVzc2FnZSh0aGlzLnJlbW90ZUludm9rZVF1ZXVlW2JdLCIqIik7dGhpcy5yZW1vdGVJbnZva2VRdWV1ZT1bXX07RWRpdG9yVWkucHJvdG90eXBlLmhhbmRsZVJlbW90ZUludm9rZVJlc3BvbnNlPWZ1bmN0aW9uKGEpe3ZhciBiPWEubXNnTWFya2VycyxjPXRoaXMucmVtb3RlSW52b2tlQ2FsbGJhY2tzW2IuY2FsbGJhY2tJZF07aWYobnVsbD09Yyl0aHJvdyBFcnJvcigiTm8gY2FsbGJhY2sgZm9yICIrKG51bGwhPWI/Yi5jYWxsYmFja0lkOiJudWxsIikpO2EuZXJyb3I/Yy5lcnJvciYmYy5lcnJvcihhLmVycm9yLmVyclJlc3ApOgpjLmNhbGxiYWNrJiZjLmNhbGxiYWNrLmFwcGx5KHRoaXMsYS5yZXNwKTt0aGlzLnJlbW90ZUludm9rZUNhbGxiYWNrc1tiLmNhbGxiYWNrSWRdPW51bGx9O0VkaXRvclVpLnByb3RvdHlwZS5yZW1vdGVJbnZva2U9ZnVuY3Rpb24oYSxjLGQsZixrKXt2YXIgYj0hMCxlPXdpbmRvdy5zZXRUaW1lb3V0KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7Yj0hMTtrKHtjb2RlOkFwcC5FUlJPUl9USU1FT1VULG1lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJ0aW1lb3V0Iil9KX0pLHRoaXMudGltZW91dCksZz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3dpbmRvdy5jbGVhclRpbWVvdXQoZSk7YiYmZi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KTtkPWR8fHt9O2QuY2FsbGJhY2tJZD10aGlzLnJlbW90ZUludm9rZUNhbGxiYWNrcy5sZW5ndGg7dGhpcy5yZW1vdGVJbnZva2VDYWxsYmFja3MucHVzaCh7Y2FsbGJhY2s6ZyxlcnJvcjprfSk7YT1KU09OLnN0cmluZ2lmeSh7ZXZlbnQ6InJlbW90ZUludm9rZSIsCmZ1bnRpb25OYW1lOmEsZnVuY3Rpb25BcmdzOmMsbXNnTWFya2VyczpkfSk7bnVsbCE9dGhpcy5yZW1vdGVXaW4/dGhpcy5yZW1vdGVXaW4ucG9zdE1lc3NhZ2UoYSwiKiIpOnRoaXMucmVtb3RlSW52b2tlUXVldWUucHVzaChhKX07RWRpdG9yVWkucHJvdG90eXBlLmhhbmRsZVJlbW90ZUludm9rZT1mdW5jdGlvbihhLGMpe3ZhciBiPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIsYyl7dmFyIGQ9e2V2ZW50OiJyZW1vdGVJbnZva2VSZXNwb25zZSIsbXNnTWFya2VyczphLm1zZ01hcmtlcnN9O251bGwhPWM/ZC5lcnJvcj17ZXJyUmVzcDpjfTpudWxsIT1iJiYoZC5yZXNwPWIpO3RoaXMucmVtb3RlV2luLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KGQpLCIqIil9KTt0cnl7dmFyIGQ9YS5mdW50aW9uTmFtZSxlPXRoaXMucmVtb3RlSW52b2thYmxlRm5zW2RdO2lmKG51bGwhPWUmJiJmdW5jdGlvbiI9PT10eXBlb2YgdGhpc1tkXSl7aWYoZS5hbGxvd2VkRG9tYWlucyl7Zm9yKHZhciBmPQohMSxrPTA7azxlLmFsbG93ZWREb21haW5zLmxlbmd0aDtrKyspaWYoYz09Imh0dHBzOi8vIitlLmFsbG93ZWREb21haW5zW2tdKXtmPSEwO2JyZWFrfWlmKCFmKXtiKG51bGwsIkludmFsaWQgQ2FsbDogIitkKyIgaXMgbm90IGFsbG93ZWQuIik7cmV0dXJufX12YXIgbT1hLmZ1bmN0aW9uQXJncztBcnJheS5pc0FycmF5KG0pfHwobT1bXSk7aWYoZS5pc0FzeW5jKW0ucHVzaChmdW5jdGlvbigpe2IoQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykpfSksbS5wdXNoKGZ1bmN0aW9uKGEpe2IobnVsbCxhfHwiVW5rb3duIEVycm9yIil9KSx0aGlzW2RdLmFwcGx5KHRoaXMsbSk7ZWxzZXt2YXIgcT10aGlzW2RdLmFwcGx5KHRoaXMsbSk7YihbcV0pfX1lbHNlIGIobnVsbCwiSW52YWxpZCBDYWxsOiAiK2QrIiBpcyBub3QgZm91bmQuIil9Y2F0Y2goeCl7YihudWxsLCJJbnZhbGlkIENhbGw6IEFuIGVycm9yIG9jY3VyZWQsICIreC5tZXNzYWdlKX19O0VkaXRvclVpLnByb3RvdHlwZS5vcGVuRGF0YWJhc2U9CmZ1bmN0aW9uKGEsYyl7aWYobnVsbD09dGhpcy5kYXRhYmFzZSl7dmFyIGI9d2luZG93LmluZGV4ZWREQnx8d2luZG93Lm1vekluZGV4ZWREQnx8d2luZG93LndlYmtpdEluZGV4ZWREQjtpZihudWxsIT1iKXRyeXt2YXIgZD1iLm9wZW4oImRhdGFiYXNlIiwyKTtkLm9udXBncmFkZW5lZWRlZD1mdW5jdGlvbihhKXt0cnl7dmFyIGI9ZC5yZXN1bHQ7MT5hLm9sZFZlcnNpb24mJmIuY3JlYXRlT2JqZWN0U3RvcmUoIm9iamVjdHMiLHtrZXlQYXRoOiJrZXkifSk7Mj5hLm9sZFZlcnNpb24mJihiLmNyZWF0ZU9iamVjdFN0b3JlKCJmaWxlcyIse2tleVBhdGg6InRpdGxlIn0pLGIuY3JlYXRlT2JqZWN0U3RvcmUoImZpbGVzSW5mbyIse2tleVBhdGg6InRpdGxlIn0pLEVkaXRvclVpLm1pZ3JhdGVTdG9yYWdlRmlsZXM9aXNMb2NhbFN0b3JhZ2UpfWNhdGNoKHYpe251bGwhPWMmJmModil9fTtkLm9uc3VjY2Vzcz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXt2YXIgYz1kLnJlc3VsdDsKdGhpcy5kYXRhYmFzZT1jO0VkaXRvclVpLm1pZ3JhdGVTdG9yYWdlRmlsZXMmJihTdG9yYWdlRmlsZS5taWdyYXRlKGMpLEVkaXRvclVpLm1pZ3JhdGVTdG9yYWdlRmlsZXM9ITEpOyJhcHAuZGlhZ3JhbXMubmV0IiE9bG9jYXRpb24uaG9zdHx8dGhpcy5kcmF3aW9NaWdyYXRpb25TdGFydGVkfHwodGhpcy5kcmF3aW9NaWdyYXRpb25TdGFydGVkPSEwLHRoaXMuZ2V0RGF0YWJhc2VJdGVtKCIuZHJhd2lvTWlncmF0ZWQzIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtpZighYXx8IjEiPT11cmxQYXJhbXMuZm9yY2VNaWdyYXRpb24pe3ZhciBiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlmcmFtZSIpO2Iuc3R5bGUuZGlzcGxheT0ibm9uZSI7Yi5zZXRBdHRyaWJ1dGUoInNyYyIsImh0dHBzOi8vd3d3LmRyYXcuaW8/ZW1iZWQ9MSZwcm90bz1qc29uJmZvcmNlTWlncmF0aW9uPSIrdXJsUGFyYW1zLmZvcmNlTWlncmF0aW9uKTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGIpOwp2YXIgYz0hMCxkPSExLGUsZj0wLGc9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtkPSEwO3RoaXMuc2V0RGF0YWJhc2VJdGVtKCIuZHJhd2lvTWlncmF0ZWQzIiwhMCk7Yi5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHthY3Rpb246InJlbW90ZUludm9rZSIsZnVudGlvbk5hbWU6InNldE1pZ3JhdGVkRmxhZyJ9KSwiKiIpfSksaz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2YrKztsKCl9KSxsPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dHJ5e2lmKGY+PWUubGVuZ3RoKWcoKTtlbHNle3ZhciBhPWVbZl07U3RvcmFnZUZpbGUuZ2V0RmlsZUNvbnRlbnQodGhpcyxhLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGMpe251bGw9PWN8fCIuc2NyYXRjaHBhZCI9PWEmJmM9PXRoaXMuZW1wdHlMaWJyYXJ5WG1sP2IuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh7YWN0aW9uOiJyZW1vdGVJbnZva2UiLGZ1bnRpb25OYW1lOiJnZXRMb2NhbFN0b3JhZ2VGaWxlIiwKZnVuY3Rpb25BcmdzOlthXX0pLCIqIik6aygpfSksayl9fWNhdGNoKEgpe2NvbnNvbGUubG9nKEgpfX0pLG09bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dHJ5e3RoaXMuc2V0RGF0YWJhc2VJdGVtKG51bGwsW3t0aXRsZTphLnRpdGxlLHNpemU6YS5kYXRhLmxlbmd0aCxsYXN0TW9kaWZpZWQ6RGF0ZS5ub3coKSx0eXBlOmEuaXNMaWI/IkwiOiJGIn0se3RpdGxlOmEudGl0bGUsZGF0YTphLmRhdGF9XSxrLGssWyJmaWxlc0luZm8iLCJmaWxlcyJdKX1jYXRjaChIKXtjb25zb2xlLmxvZyhIKX19KTthPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RyeXtpZihhLnNvdXJjZT09Yi5jb250ZW50V2luZG93KXt2YXIgZj17fTt0cnl7Zj1KU09OLnBhcnNlKGEuZGF0YSl9Y2F0Y2goSil7fSJpbml0Ij09Zi5ldmVudD8oYi5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHthY3Rpb246InJlbW90ZUludm9rZVJlYWR5In0pLCIqIiksYi5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHthY3Rpb246InJlbW90ZUludm9rZSIsCmZ1bnRpb25OYW1lOiJnZXRMb2NhbFN0b3JhZ2VGaWxlTmFtZXMifSksIioiKSk6InJlbW90ZUludm9rZVJlc3BvbnNlIiE9Zi5ldmVudHx8ZHx8KGM/bnVsbCE9Zi5yZXNwJiYwPGYucmVzcC5sZW5ndGgmJm51bGwhPWYucmVzcFswXT8oZT1mLnJlc3BbMF0sYz0hMSxsKCkpOmcoKTpudWxsIT1mLnJlc3AmJjA8Zi5yZXNwLmxlbmd0aCYmbnVsbCE9Zi5yZXNwWzBdP20oZi5yZXNwWzBdKTprKCkpfX1jYXRjaChKKXtjb25zb2xlLmxvZyhKKX19KTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsYSl9fSkpKTthKGMpO2Mub252ZXJzaW9uY2hhbmdlPWZ1bmN0aW9uKCl7Yy5jbG9zZSgpfX0pO2Qub25lcnJvcj1jO2Qub25ibG9ja2VkPWZ1bmN0aW9uKCl7fX1jYXRjaChsKXtudWxsIT1jJiZjKGwpfWVsc2UgbnVsbCE9YyYmYygpfWVsc2UgYSh0aGlzLmRhdGFiYXNlKX07RWRpdG9yVWkucHJvdG90eXBlLnNldERhdGFiYXNlSXRlbT1mdW5jdGlvbihhLGMsZCxmLGspe3RoaXMub3BlbkRhdGFiYXNlKG14VXRpbHMuYmluZCh0aGlzLApmdW5jdGlvbihiKXt0cnl7az1rfHwib2JqZWN0cyI7QXJyYXkuaXNBcnJheShrKXx8KGs9W2tdLGE9W2FdLGM9W2NdKTt2YXIgZT1iLnRyYW5zYWN0aW9uKGssInJlYWR3cml0ZSIpO2Uub25jb21wbGV0ZT1kO2Uub25lcnJvcj1mO2ZvcihiPTA7YjxrLmxlbmd0aDtiKyspZS5vYmplY3RTdG9yZShrW2JdKS5wdXQobnVsbCE9YSYmbnVsbCE9YVtiXT97a2V5OmFbYl0sZGF0YTpjW2JdfTpjW2JdKX1jYXRjaCh0KXtudWxsIT1mJiZmKHQpfX0pLGYpfTtFZGl0b3JVaS5wcm90b3R5cGUucmVtb3ZlRGF0YWJhc2VJdGVtPWZ1bmN0aW9uKGEsYyxkLGYpe3RoaXMub3BlbkRhdGFiYXNlKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe2Y9Znx8Im9iamVjdHMiO0FycmF5LmlzQXJyYXkoZil8fChmPVtmXSxhPVthXSk7Yj1iLnRyYW5zYWN0aW9uKGYsInJlYWR3cml0ZSIpO2Iub25jb21wbGV0ZT1jO2Iub25lcnJvcj1kO2Zvcih2YXIgZT0wO2U8Zi5sZW5ndGg7ZSsrKWIub2JqZWN0U3RvcmUoZltlXSlbImRlbGV0ZSJdKGFbZV0pfSksCmQpfTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0RGF0YWJhc2VJdGVtPWZ1bmN0aW9uKGEsYyxkLGYpe3RoaXMub3BlbkRhdGFiYXNlKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3RyeXtmPWZ8fCJvYmplY3RzIjt2YXIgZT1iLnRyYW5zYWN0aW9uKFtmXSwicmVhZG9ubHkiKS5vYmplY3RTdG9yZShmKS5nZXQoYSk7ZS5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtjKGUucmVzdWx0KX07ZS5vbmVycm9yPWR9Y2F0Y2godil7bnVsbCE9ZCYmZCh2KX19KSxkKX07RWRpdG9yVWkucHJvdG90eXBlLmdldERhdGFiYXNlSXRlbXM9ZnVuY3Rpb24oYSxjLGQpe3RoaXMub3BlbkRhdGFiYXNlKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3RyeXtkPWR8fCJvYmplY3RzIjt2YXIgZT1iLnRyYW5zYWN0aW9uKFtkXSwicmVhZG9ubHkiKS5vYmplY3RTdG9yZShkKS5vcGVuQ3Vyc29yKElEQktleVJhbmdlLmxvd2VyQm91bmQoMCkpLGY9W107ZS5vbnN1Y2Nlc3M9ZnVuY3Rpb24oYil7bnVsbD09CmIudGFyZ2V0LnJlc3VsdD9hKGYpOihmLnB1c2goYi50YXJnZXQucmVzdWx0LnZhbHVlKSxiLnRhcmdldC5yZXN1bHRbImNvbnRpbnVlIl0oKSl9O2Uub25lcnJvcj1jfWNhdGNoKHYpe251bGwhPWMmJmModil9fSksYyl9O0VkaXRvclVpLnByb3RvdHlwZS5nZXREYXRhYmFzZUl0ZW1LZXlzPWZ1bmN0aW9uKGEsYyxkKXt0aGlzLm9wZW5EYXRhYmFzZShteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXt0cnl7ZD1kfHwib2JqZWN0cyI7dmFyIGU9Yi50cmFuc2FjdGlvbihbZF0sInJlYWRvbmx5Iikub2JqZWN0U3RvcmUoZCkuZ2V0QWxsS2V5cygpO2Uub25zdWNjZXNzPWZ1bmN0aW9uKCl7YShlLnJlc3VsdCl9O2Uub25lcnJvcj1jfWNhdGNoKG4pe251bGwhPWMmJmMobil9fSksYyl9O0VkaXRvclVpLnByb3RvdHlwZS5jb21tZW50c1N1cHBvcnRlZD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0Q3VycmVudEZpbGUoKTtyZXR1cm4gbnVsbCE9YT9hLmNvbW1lbnRzU3VwcG9ydGVkKCk6CiExfTtFZGl0b3JVaS5wcm90b3R5cGUuY29tbWVudHNSZWZyZXNoTmVlZGVkPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRDdXJyZW50RmlsZSgpO3JldHVybiBudWxsIT1hP2EuY29tbWVudHNSZWZyZXNoTmVlZGVkKCk6ITB9O0VkaXRvclVpLnByb3RvdHlwZS5jb21tZW50c1NhdmVOZWVkZWQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdldEN1cnJlbnRGaWxlKCk7cmV0dXJuIG51bGwhPWE/YS5jb21tZW50c1NhdmVOZWVkZWQoKTohMX07RWRpdG9yVWkucHJvdG90eXBlLmdldENvbW1lbnRzPWZ1bmN0aW9uKGEsYyl7dmFyIGI9dGhpcy5nZXRDdXJyZW50RmlsZSgpO251bGwhPWI/Yi5nZXRDb21tZW50cyhhLGMpOmEoW10pfTtFZGl0b3JVaS5wcm90b3R5cGUuYWRkQ29tbWVudD1mdW5jdGlvbihhLGMsZCl7dmFyIGI9dGhpcy5nZXRDdXJyZW50RmlsZSgpO251bGwhPWI/Yi5hZGRDb21tZW50KGEsYyxkKTpjKERhdGUubm93KCkpfTtFZGl0b3JVaS5wcm90b3R5cGUuY2FuUmVwbHlUb1JlcGxpZXM9CmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRDdXJyZW50RmlsZSgpO3JldHVybiBudWxsIT1hP2EuY2FuUmVwbHlUb1JlcGxpZXMoKTohMH07RWRpdG9yVWkucHJvdG90eXBlLmNhbkNvbW1lbnQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdldEN1cnJlbnRGaWxlKCk7cmV0dXJuIG51bGwhPWE/YS5jYW5Db21tZW50KCk6ITB9O0VkaXRvclVpLnByb3RvdHlwZS5uZXdDb21tZW50PWZ1bmN0aW9uKGEsYyl7dmFyIGI9dGhpcy5nZXRDdXJyZW50RmlsZSgpO3JldHVybiBudWxsIT1iP2IubmV3Q29tbWVudChhLGMpOm5ldyBEcmF3aW9Db21tZW50KHRoaXMsbnVsbCxhLERhdGUubm93KCksRGF0ZS5ub3coKSwhMSxjKX07RWRpdG9yVWkucHJvdG90eXBlLmlzUmV2aXNpb25IaXN0b3J5U3VwcG9ydGVkPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRDdXJyZW50RmlsZSgpO3JldHVybiBudWxsIT1hJiZhLmlzUmV2aXNpb25IaXN0b3J5U3VwcG9ydGVkKCl9O0VkaXRvclVpLnByb3RvdHlwZS5nZXRSZXZpc2lvbnM9CmZ1bmN0aW9uKGEsYyl7dmFyIGI9dGhpcy5nZXRDdXJyZW50RmlsZSgpO251bGwhPWImJmIuZ2V0UmV2aXNpb25zP2IuZ2V0UmV2aXNpb25zKGEsYyk6Yyh7bWVzc2FnZTpteFJlc291cmNlcy5nZXQoInVua25vd25FcnJvciIpfSl9O0VkaXRvclVpLnByb3RvdHlwZS5pc1JldmlzaW9uSGlzdG9yeUVuYWJsZWQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdldEN1cnJlbnRGaWxlKCk7cmV0dXJuIG51bGwhPWEmJihhLmNvbnN0cnVjdG9yPT1Ecml2ZUZpbGUmJmEuaXNFZGl0YWJsZSgpfHxhLmNvbnN0cnVjdG9yPT1Ecm9wYm94RmlsZSl9O0VkaXRvclVpLnByb3RvdHlwZS5nZXRTZXJ2aWNlTmFtZT1mdW5jdGlvbigpe3JldHVybiJkcmF3LmlvIn07RWRpdG9yVWkucHJvdG90eXBlLmFkZFJlbW90ZVNlcnZpY2VTZWN1cml0eUNoZWNrPWZ1bmN0aW9uKGEpe2Euc2V0UmVxdWVzdEhlYWRlcigiQ29udGVudC1MYW5ndWFnZSIsImRhLCBtaSwgZW4sIGRlLURFIil9O0VkaXRvclVpLnByb3RvdHlwZS5sb2FkVXJsPQpmdW5jdGlvbihhLGMsZCxmLGssbSxxLHQpe0VkaXRvclVpLmxvZ0V2ZW50KCJTSE9VTEQgTk9UIEJFIENBTExFRDogbG9hZFVybCIpO3JldHVybiB0aGlzLmVkaXRvci5sb2FkVXJsKGEsYyxkLGYsayxtLHEsdCl9O0VkaXRvclVpLnByb3RvdHlwZS5sb2FkRm9udHM9ZnVuY3Rpb24oYSl7RWRpdG9yVWkubG9nRXZlbnQoIlNIT1VMRCBOT1QgQkUgQ0FMTEVEOiBsb2FkRm9udHMiKTtyZXR1cm4gdGhpcy5lZGl0b3IubG9hZEZvbnRzKGEpfTtFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlU3ZnRGF0YVVyaT1mdW5jdGlvbihhKXtFZGl0b3JVaS5sb2dFdmVudCgiU0hPVUxEIE5PVCBCRSBDQUxMRUQ6IGNyZWF0ZVN2Z0RhdGFVcmkiKTtyZXR1cm4gRWRpdG9yLmNyZWF0ZVN2Z0RhdGFVcmkoYSl9O0VkaXRvclVpLnByb3RvdHlwZS5lbWJlZENzc0ZvbnRzPWZ1bmN0aW9uKGEsYyl7RWRpdG9yVWkubG9nRXZlbnQoIlNIT1VMRCBOT1QgQkUgQ0FMTEVEOiBlbWJlZENzc0ZvbnRzIik7cmV0dXJuIHRoaXMuZWRpdG9yLmVtYmVkQ3NzRm9udHMoYSwKYyl9O0VkaXRvclVpLnByb3RvdHlwZS5lbWJlZEV4dEZvbnRzPWZ1bmN0aW9uKGEpe0VkaXRvclVpLmxvZ0V2ZW50KCJTSE9VTEQgTk9UIEJFIENBTExFRDogZW1iZWRFeHRGb250cyIpO3JldHVybiB0aGlzLmVkaXRvci5lbWJlZEV4dEZvbnRzKGEpfTtFZGl0b3JVaS5wcm90b3R5cGUuZXhwb3J0VG9DYW52YXM9ZnVuY3Rpb24oYSxjLGQsZixrLG0scSx0LHkseCxFLEEsQyx6LEQsRyl7RWRpdG9yVWkubG9nRXZlbnQoIlNIT1VMRCBOT1QgQkUgQ0FMTEVEOiBleHBvcnRUb0NhbnZhcyIpO3JldHVybiB0aGlzLmVkaXRvci5leHBvcnRUb0NhbnZhcyhhLGMsZCxmLGssbSxxLHQseSx4LEUsQSxDLHosRCxHKX07RWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZUltYWdlVXJsQ29udmVydGVyPWZ1bmN0aW9uKCl7RWRpdG9yVWkubG9nRXZlbnQoIlNIT1VMRCBOT1QgQkUgQ0FMTEVEOiBjcmVhdGVJbWFnZVVybENvbnZlcnRlciIpO3JldHVybiB0aGlzLmVkaXRvci5jcmVhdGVJbWFnZVVybENvbnZlcnRlcigpfTsKRWRpdG9yVWkucHJvdG90eXBlLmNvbnZlcnRJbWFnZXM9ZnVuY3Rpb24oYSxjLGQsZil7RWRpdG9yVWkubG9nRXZlbnQoIlNIT1VMRCBOT1QgQkUgQ0FMTEVEOiBjb252ZXJ0SW1hZ2VzIik7cmV0dXJuIHRoaXMuZWRpdG9yLmNvbnZlcnRJbWFnZXMoYSxjLGQsZil9O0VkaXRvclVpLnByb3RvdHlwZS5jb252ZXJ0SW1hZ2VUb0RhdGFVcmk9ZnVuY3Rpb24oYSxjKXtFZGl0b3JVaS5sb2dFdmVudCgiU0hPVUxEIE5PVCBCRSBDQUxMRUQ6IGNvbnZlcnRJbWFnZVRvRGF0YVVyaSIpO3JldHVybiB0aGlzLmVkaXRvci5jb252ZXJ0SW1hZ2VUb0RhdGFVcmkoYSxjKX07RWRpdG9yVWkucHJvdG90eXBlLmJhc2U2NEVuY29kZT1mdW5jdGlvbihhKXtFZGl0b3JVaS5sb2dFdmVudCgiU0hPVUxEIE5PVCBCRSBDQUxMRUQ6IGJhc2U2NEVuY29kZSIpO3JldHVybiBFZGl0b3IuYmFzZTY0RW5jb2RlKGEpfTtFZGl0b3JVaS5wcm90b3R5cGUudXBkYXRlQ1JDPWZ1bmN0aW9uKGEsYyxkLGYpe0VkaXRvclVpLmxvZ0V2ZW50KCJTSE9VTEQgTk9UIEJFIENBTExFRDogdXBkYXRlQ1JDIik7CnJldHVybiBFZGl0b3IudXBkYXRlQ1JDKGEsYyxkLGYpfTtFZGl0b3JVaS5wcm90b3R5cGUuY3JjMzI9ZnVuY3Rpb24oYSl7RWRpdG9yVWkubG9nRXZlbnQoIlNIT1VMRCBOT1QgQkUgQ0FMTEVEOiBjcmMzMiIpO3JldHVybiBFZGl0b3IuY3JjMzIoYSl9O0VkaXRvclVpLnByb3RvdHlwZS53cml0ZUdyYXBoTW9kZWxUb1BuZz1mdW5jdGlvbihhLGMsZCxmLGspe0VkaXRvclVpLmxvZ0V2ZW50KCJTSE9VTEQgTk9UIEJFIENBTExFRDogd3JpdGVHcmFwaE1vZGVsVG9QbmciKTtyZXR1cm4gRWRpdG9yLndyaXRlR3JhcGhNb2RlbFRvUG5nKGEsYyxkLGYsayl9O0VkaXRvclVpLnByb3RvdHlwZS5nZXRMb2NhbFN0b3JhZ2VGaWxlTmFtZXM9ZnVuY3Rpb24oKXtpZigiMSI9PWxvY2FsU3RvcmFnZS5nZXRJdGVtKCIubG9jYWxTdG9yYWdlTWlncmF0ZWQiKSYmIjEiIT11cmxQYXJhbXMuZm9yY2VNaWdyYXRpb24pcmV0dXJuIG51bGw7Zm9yKHZhciBhPVtdLGM9MDtjPGxvY2FsU3RvcmFnZS5sZW5ndGg7YysrKXt2YXIgZD0KbG9jYWxTdG9yYWdlLmtleShjKSxmPWxvY2FsU3RvcmFnZS5nZXRJdGVtKGQpO2lmKDA8ZC5sZW5ndGgmJigiLnNjcmF0Y2hwYWQiPT1kfHwiLiIhPWQuY2hhckF0KDApKSYmMDxmLmxlbmd0aCl7dmFyIGs9IjxteGZpbGUgIj09PWYuc3Vic3RyaW5nKDAsOCl8fCI8P3htbCI9PT1mLnN1YnN0cmluZygwLDUpfHwiXHgzYyEtLVtpZiBJRV0+Ij09PWYuc3Vic3RyaW5nKDAsMTIpLGY9IjxteGxpYnJhcnk+Ij09PWYuc3Vic3RyaW5nKDAsMTEpOyhrfHxmKSYmYS5wdXNoKGQpfX1yZXR1cm4gYX07RWRpdG9yVWkucHJvdG90eXBlLmdldExvY2FsU3RvcmFnZUZpbGU9ZnVuY3Rpb24oYSl7aWYoIjEiPT1sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgiLmxvY2FsU3RvcmFnZU1pZ3JhdGVkIikmJiIxIiE9dXJsUGFyYW1zLmZvcmNlTWlncmF0aW9uKXJldHVybiBudWxsO3ZhciBiPWxvY2FsU3RvcmFnZS5nZXRJdGVtKGEpO3JldHVybnt0aXRsZTphLGRhdGE6Yixpc0xpYjoiPG14bGlicmFyeT4iPT09CmIuc3Vic3RyaW5nKDAsMTEpfX07RWRpdG9yVWkucHJvdG90eXBlLnNldE1pZ3JhdGVkRmxhZz1mdW5jdGlvbigpe2xvY2FsU3RvcmFnZS5zZXRJdGVtKCIubG9jYWxTdG9yYWdlTWlncmF0ZWQiLCIxIil9fSkoKTsKdmFyIENvbW1lbnRzV2luZG93PWZ1bmN0aW9uKGEsYyxmLGQsbSxrKXtmdW5jdGlvbiBxKCl7Zm9yKHZhciBhPUEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpLGI9MCxjPTA7YzxhLmxlbmd0aDtjKyspIm5vbmUiIT1hW2NdLnN0eWxlLmRpc3BsYXkmJmFbY10ucGFyZW50Tm9kZT09QSYmYisrO0Muc3R5bGUuZGlzcGxheT0wPT1iPyJibG9jayI6Im5vbmUifWZ1bmN0aW9uIGIoYSxiLGMsZCl7ZnVuY3Rpb24gZSgpe2IucmVtb3ZlQ2hpbGQoayk7Yi5yZW1vdmVDaGlsZChsKTtnLnN0eWxlLmRpc3BsYXk9ImJsb2NrIjtmLnN0eWxlLmRpc3BsYXk9ImJsb2NrIn15PXtkaXY6Yixjb21tZW50OmEsc2F2ZUNhbGxiYWNrOmMsZGVsZXRlT25DYW5jZWw6ZH07dmFyIGY9Yi5xdWVyeVNlbGVjdG9yKCIuZ2VDb21tZW50VHh0IiksZz1iLnF1ZXJ5U2VsZWN0b3IoIi5nZUNvbW1lbnRBY3Rpb25zTGlzdCIpLGs9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGV4dGFyZWEiKTtrLmNsYXNzTmFtZT0KImdlQ29tbWVudEVkaXRUeHRBcmVhIjtrLnN0eWxlLm1pbkhlaWdodD1mLm9mZnNldEhlaWdodCsicHgiO2sudmFsdWU9YS5jb250ZW50O2IuaW5zZXJ0QmVmb3JlKGssZik7dmFyIGw9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7bC5jbGFzc05hbWU9ImdlQ29tbWVudEVkaXRCdG5zIjt2YXIgbT1teFV0aWxzLmJ1dHRvbihteFJlc291cmNlcy5nZXQoImNhbmNlbCIpLGZ1bmN0aW9uKCl7ZD8oYi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpLHEoKSk6ZSgpO3k9bnVsbH0pO20uY2xhc3NOYW1lPSJnZUNvbW1lbnRFZGl0QnRuIjtsLmFwcGVuZENoaWxkKG0pO3ZhciBwPW14VXRpbHMuYnV0dG9uKG14UmVzb3VyY2VzLmdldCgic2F2ZSIpLGZ1bmN0aW9uKCl7Zi5pbm5lckhUTUw9IiI7YS5jb250ZW50PWsudmFsdWU7bXhVdGlscy53cml0ZShmLGEuY29udGVudCk7ZSgpO2MoYSk7eT1udWxsfSk7bXhFdmVudC5hZGRMaXN0ZW5lcihrLCJrZXlkb3duIixteFV0aWxzLmJpbmQodGhpcywKZnVuY3Rpb24oYSl7bXhFdmVudC5pc0NvbnN1bWVkKGEpfHwoKG14RXZlbnQuaXNDb250cm9sRG93bihhKXx8bXhDbGllbnQuSVNfTUFDJiZteEV2ZW50LmlzTWV0YURvd24oYSkpJiYxMz09YS5rZXlDb2RlPyhwLmNsaWNrKCksbXhFdmVudC5jb25zdW1lKGEpKToyNz09YS5rZXlDb2RlJiYobS5jbGljaygpLG14RXZlbnQuY29uc3VtZShhKSkpfSkpO3AuZm9jdXMoKTtwLmNsYXNzTmFtZT0iZ2VDb21tZW50RWRpdEJ0biBnZVByaW1hcnlCdG4iO2wuYXBwZW5kQ2hpbGQocCk7Yi5pbnNlcnRCZWZvcmUobCxmKTtnLnN0eWxlLmRpc3BsYXk9Im5vbmUiO2Yuc3R5bGUuZGlzcGxheT0ibm9uZSI7ay5mb2N1cygpfWZ1bmN0aW9uIGUoYixjKXtjLmlubmVySFRNTD0iIjt2YXIgZD1uZXcgRGF0ZShiLm1vZGlmaWVkRGF0ZSksZT1hLnRpbWVTaW5jZShkKTtudWxsPT1lJiYoZT1teFJlc291cmNlcy5nZXQoImxlc3NUaGFuQU1pbnV0ZSIpKTtteFV0aWxzLndyaXRlKGMsbXhSZXNvdXJjZXMuZ2V0KCJ0aW1lQWdvIiwKW2VdLCJ7MX0gYWdvIikpO2Muc2V0QXR0cmlidXRlKCJ0aXRsZSIsZC50b0xvY2FsZURhdGVTdHJpbmcoKSsiICIrZC50b0xvY2FsZVRpbWVTdHJpbmcoKSl9ZnVuY3Rpb24gZyhhKXt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTtiLmNsYXNzTmFtZT0iZ2VDb21tZW50QnVzeUltZyI7Yi5zcmM9SU1BR0VfUEFUSCsiL3NwaW4uZ2lmIjthLmFwcGVuZENoaWxkKGIpO2EuYnVzeUltZz1ifWZ1bmN0aW9uIHAoYSl7YS5zdHlsZS5ib3JkZXI9IjFweCBzb2xpZCByZWQiO2EucmVtb3ZlQ2hpbGQoYS5idXN5SW1nKX1mdW5jdGlvbiBsKGEpe2Euc3R5bGUuYm9yZGVyPSIiO2EucmVtb3ZlQ2hpbGQoYS5idXN5SW1nKX1mdW5jdGlvbiBuKGMsZCxmLGssbSl7ZnVuY3Rpb24gdShhLGIsZCl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgibGkiKTtlLmNsYXNzTmFtZT0iZ2VDb21tZW50QWN0aW9uIjt2YXIgZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJhIik7Zi5jbGFzc05hbWU9CiJnZUNvbW1lbnRBY3Rpb25MbmsiO214VXRpbHMud3JpdGUoZixhKTtlLmFwcGVuZENoaWxkKGYpO214RXZlbnQuYWRkTGlzdGVuZXIoZiwiY2xpY2siLGZ1bmN0aW9uKGEpe2IoYSxjKTthLnByZXZlbnREZWZhdWx0KCk7bXhFdmVudC5jb25zdW1lKGEpfSk7RS5hcHBlbmRDaGlsZChlKTtkJiYoZS5zdHlsZS5kaXNwbGF5PSJub25lIil9ZnVuY3Rpb24gQigpe2Z1bmN0aW9uIGEoYyl7Yi5wdXNoKGQpO2lmKG51bGwhPWMucmVwbGllcylmb3IodmFyIGU9MDtlPGMucmVwbGllcy5sZW5ndGg7ZSsrKWQ9ZC5uZXh0U2libGluZyxhKGMucmVwbGllc1tlXSl9dmFyIGI9W10sZD14O2EoYyk7cmV0dXJue3BkaXY6ZCxyZXBsaWVzOmJ9fWZ1bmN0aW9uIHooZCxlLGYsbSxxKXtmdW5jdGlvbiB0KCl7Zyh4KTtjLmFkZFJlcGx5KHosZnVuY3Rpb24oYSl7ei5pZD1hO2MucmVwbGllcy5wdXNoKHopO2woeCk7ZiYmZigpfSxmdW5jdGlvbihiKXt5KCk7cCh4KTthLmhhbmRsZUVycm9yKGIsbnVsbCwKbnVsbCxudWxsLG14VXRpbHMuaHRtbEVudGl0aWVzKG14UmVzb3VyY2VzLmdldCgib2JqZWN0Tm90Rm91bmQiKSkpfSxtLHEpfWZ1bmN0aW9uIHkoKXtiKHoseCxmdW5jdGlvbihhKXt0KCl9LCEwKX12YXIgdT1CKCkucGRpdix6PWEubmV3Q29tbWVudChkLGEuZ2V0Q3VycmVudFVzZXIoKSk7ei5wQ29tbWVudElkPWMuaWQ7bnVsbD09Yy5yZXBsaWVzJiYoYy5yZXBsaWVzPVtdKTt2YXIgeD1uKHosYy5yZXBsaWVzLHUsaysxKTtlP3koKTp0KCl9aWYobXx8IWMuaXNSZXNvbHZlZCl7Qy5zdHlsZS5kaXNwbGF5PSJub25lIjt2YXIgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTt4LmNsYXNzTmFtZT0iZ2VDb21tZW50Q29udGFpbmVyIjt4LnNldEF0dHJpYnV0ZSgiZGF0YS1jb21tZW50SWQiLGMuaWQpO3guc3R5bGUubWFyZ2luTGVmdD0yMCprKzUrInB4IjtjLmlzUmVzb2x2ZWQmJiJkYXJrIiE9dWlUaGVtZSYmKHguc3R5bGUuYmFja2dyb3VuZENvbG9yPSJnaG9zdFdoaXRlIik7CnZhciBEPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO0QuY2xhc3NOYW1lPSJnZUNvbW1lbnRIZWFkZXIiO3ZhciBNPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImltZyIpO00uY2xhc3NOYW1lPSJnZUNvbW1lbnRVc2VySW1nIjtNLnNyYz1jLnVzZXIucGljdHVyZVVybHx8RWRpdG9yLnVzZXJJbWFnZTtELmFwcGVuZENoaWxkKE0pO009ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7TS5jbGFzc05hbWU9ImdlQ29tbWVudEhlYWRlclR4dCI7RC5hcHBlbmRDaGlsZChNKTt2YXIgRj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtGLmNsYXNzTmFtZT0iZ2VDb21tZW50VXNlcm5hbWUiO214VXRpbHMud3JpdGUoRixjLnVzZXIuZGlzcGxheU5hbWV8fCIiKTtNLmFwcGVuZENoaWxkKEYpO0Y9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Ri5jbGFzc05hbWU9ImdlQ29tbWVudERhdGUiO0Yuc2V0QXR0cmlidXRlKCJkYXRhLWNvbW1lbnRJZCIsYy5pZCk7ZShjLApGKTtNLmFwcGVuZENoaWxkKEYpO3guYXBwZW5kQ2hpbGQoRCk7RD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtELmNsYXNzTmFtZT0iZ2VDb21tZW50VHh0IjtteFV0aWxzLndyaXRlKEQsYy5jb250ZW50fHwiIik7eC5hcHBlbmRDaGlsZChEKTtEPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO0QuY2xhc3NOYW1lPSJnZUNvbW1lbnRBY3Rpb25zIjt2YXIgRT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ1bCIpO0UuY2xhc3NOYW1lPSJnZUNvbW1lbnRBY3Rpb25zTGlzdCI7RC5hcHBlbmRDaGlsZChFKTt2fHwwIT1rJiYhdHx8dShteFJlc291cmNlcy5nZXQoInJlcGx5IiksZnVuY3Rpb24oKXt6KCIiLCEwKX0sYy5pc1Jlc29sdmVkKTtNPWEuZ2V0Q3VycmVudFVzZXIoKTtudWxsPT1NfHxNLmlkIT1jLnVzZXIuaWR8fHZ8fCh1KG14UmVzb3VyY2VzLmdldCgiZWRpdCIpLGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZCgpe2IoYyx4LGZ1bmN0aW9uKCl7Zyh4KTtjLmVkaXRDb21tZW50KGMuY29udGVudCwKZnVuY3Rpb24oKXtsKHgpfSxmdW5jdGlvbihiKXtwKHgpO2QoKTthLmhhbmRsZUVycm9yKGIsbnVsbCxudWxsLG51bGwsbXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KCJvYmplY3ROb3RGb3VuZCIpKSl9KX0pfWQoKX0sYy5pc1Jlc29sdmVkKSx1KG14UmVzb3VyY2VzLmdldCgiZGVsZXRlIiksZnVuY3Rpb24oKXthLmNvbmZpcm0obXhSZXNvdXJjZXMuZ2V0KCJhcmVZb3VTdXJlIiksZnVuY3Rpb24oKXtnKHgpO2MuZGVsZXRlQ29tbWVudChmdW5jdGlvbigpe2Zvcih2YXIgYT1CKGMpLnJlcGxpZXMsYj0wO2I8YS5sZW5ndGg7YisrKUEucmVtb3ZlQ2hpbGQoYVtiXSk7Zm9yKGI9MDtiPGQubGVuZ3RoO2IrKylpZihkW2JdPT1jKXtkLnNwbGljZShiLDEpO2JyZWFrfUMuc3R5bGUuZGlzcGxheT0wPT1BLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaXYiKS5sZW5ndGg/ImJsb2NrIjoibm9uZSJ9LGZ1bmN0aW9uKGIpe3AoeCk7YS5oYW5kbGVFcnJvcihiLG51bGwsbnVsbCwKbnVsbCxteFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQoIm9iamVjdE5vdEZvdW5kIikpKX0pfSl9LGMuaXNSZXNvbHZlZCkpO3Z8fDAhPWt8fHUoYy5pc1Jlc29sdmVkP214UmVzb3VyY2VzLmdldCgicmVvcGVuIik6bXhSZXNvdXJjZXMuZ2V0KCJyZXNvbHZlIiksZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYigpe3ZhciBiPWEudGFyZ2V0O2IuaW5uZXJIVE1MPSIiO2MuaXNSZXNvbHZlZD0hYy5pc1Jlc29sdmVkO214VXRpbHMud3JpdGUoYixjLmlzUmVzb2x2ZWQ/bXhSZXNvdXJjZXMuZ2V0KCJyZW9wZW4iKTpteFJlc291cmNlcy5nZXQoInJlc29sdmUiKSk7Zm9yKHZhciBkPWMuaXNSZXNvbHZlZD8ibm9uZSI6IiIsZT1CKGMpLnJlcGxpZXMsZj0iZGFyayI9PXVpVGhlbWU/InRyYW5zcGFyZW50IjpjLmlzUmVzb2x2ZWQ/Imdob3N0V2hpdGUiOiJ3aGl0ZSIsZz0wO2c8ZS5sZW5ndGg7ZysrKXtlW2ddLnN0eWxlLmJhY2tncm91bmRDb2xvcj1mO2Zvcih2YXIgaz1lW2ddLnF1ZXJ5U2VsZWN0b3JBbGwoIi5nZUNvbW1lbnRBY3Rpb24iKSwKbD0wO2w8ay5sZW5ndGg7bCsrKWtbbF0hPWIucGFyZW50Tm9kZSYmKGtbbF0uc3R5bGUuZGlzcGxheT1kKTtHfHwoZVtnXS5zdHlsZS5kaXNwbGF5PSJub25lIil9cSgpfWMuaXNSZXNvbHZlZD96KG14UmVzb3VyY2VzLmdldCgicmVPcGVuZWQiKSsiOiAiLCEwLGIsITEsITApOnoobXhSZXNvdXJjZXMuZ2V0KCJtYXJrZWRBc1Jlc29sdmVkIiksITEsYiwhMCl9KTt4LmFwcGVuZENoaWxkKEQpO251bGwhPWY/QS5pbnNlcnRCZWZvcmUoeCxmLm5leHRTaWJsaW5nKTpBLmFwcGVuZENoaWxkKHgpO2ZvcihmPTA7bnVsbCE9Yy5yZXBsaWVzJiZmPGMucmVwbGllcy5sZW5ndGg7ZisrKUQ9Yy5yZXBsaWVzW2ZdLEQuaXNSZXNvbHZlZD1jLmlzUmVzb2x2ZWQsbihELGMucmVwbGllcyxudWxsLGsrMSxtKTtudWxsIT15JiYoeS5jb21tZW50LmlkPT1jLmlkPyhtPWMuY29udGVudCxjLmNvbnRlbnQ9eS5jb21tZW50LmNvbnRlbnQsYihjLHgseS5zYXZlQ2FsbGJhY2sseS5kZWxldGVPbkNhbmNlbCksCmMuY29udGVudD1tKTpudWxsPT15LmNvbW1lbnQuaWQmJnkuY29tbWVudC5wQ29tbWVudElkPT1jLmlkJiYoQS5hcHBlbmRDaGlsZCh5LmRpdiksYih5LmNvbW1lbnQseS5kaXYseS5zYXZlQ2FsbGJhY2sseS5kZWxldGVPbkNhbmNlbCkpKTtyZXR1cm4geH19dmFyIHY9IWEuY2FuQ29tbWVudCgpLHQ9YS5jYW5SZXBseVRvUmVwbGllcygpLHk9bnVsbCx4PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO3guY2xhc3NOYW1lPSJnZUNvbW1lbnRzV2luIjt4LnN0eWxlLmJhY2tncm91bmQ9IndoaXRlIj09RGlhbG9nLmJhY2tkcm9wQ29sb3I/IndoaXRlU21va2UiOkRpYWxvZy5iYWNrZHJvcENvbG9yO3ZhciBFPUVkaXRvclVpLmNvbXBhY3RVaT8iMjZweCI6IjMwcHgiLEE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7QS5jbGFzc05hbWU9ImdlQ29tbWVudHNMaXN0IjtBLnN0eWxlLmJhY2tncm91bmRDb2xvcj0id2hpdGUiPT1EaWFsb2cuYmFja2Ryb3BDb2xvcj8id2hpdGVTbW9rZSI6CkRpYWxvZy5iYWNrZHJvcENvbG9yO0Euc3R5bGUuYm90dG9tPXBhcnNlSW50KEUpKzcrInB4Ijt4LmFwcGVuZENoaWxkKEEpO3ZhciBDPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNwYW4iKTtDLnN0eWxlLmNzc1RleHQ9ImRpc3BsYXk6bm9uZTtwYWRkaW5nLXRvcDoxMHB4O3RleHQtYWxpZ246Y2VudGVyOyI7bXhVdGlscy53cml0ZShDLG14UmVzb3VyY2VzLmdldCgibm9Db21tZW50c0ZvdW5kIikpO3ZhciB6PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO3ouY2xhc3NOYW1lPSJnZVRvb2xiYXJDb250YWluZXIgZ2VDb21tZW50c1Rvb2xiYXIiO3ouc3R5bGUuaGVpZ2h0PUU7ei5zdHlsZS5wYWRkaW5nPUVkaXRvclVpLmNvbXBhY3RVaT8iNHB4IDBweCAzcHggMHB4IjoiMXB4Ijt6LnN0eWxlLmJhY2tncm91bmRDb2xvcj0id2hpdGUiPT1EaWFsb2cuYmFja2Ryb3BDb2xvcj8id2hpdGVTbW9rZSI6RGlhbG9nLmJhY2tkcm9wQ29sb3I7bXhDbGllbnQuSVNfUVVJUktTJiYoei5zdHlsZS5maWx0ZXI9CiJub25lIik7RT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJhIik7RS5jbGFzc05hbWU9ImdlQnV0dG9uIjtteENsaWVudC5JU19RVUlSS1MmJihFLnN0eWxlLmZpbHRlcj0ibm9uZSIpO2lmKCF2KXt2YXIgRD1FLmNsb25lTm9kZSgpO0QuaW5uZXJIVE1MPSc8ZGl2IGNsYXNzPSJnZVNwcml0ZSBnZVNwcml0ZS1wbHVzIiBzdHlsZT0iZGlzcGxheTppbmxpbmUtYmxvY2s7Ij48L2Rpdj4nO0Quc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJjcmVhdGUiKSsiLi4uIik7bXhFdmVudC5hZGRMaXN0ZW5lcihELCJjbGljayIsZnVuY3Rpb24oYyl7ZnVuY3Rpb24gZCgpe2IoZSxmLGZ1bmN0aW9uKGIpe2coZik7YS5hZGRDb21tZW50KGIsZnVuY3Rpb24oYSl7Yi5pZD1hO0YucHVzaChiKTtsKGYpfSxmdW5jdGlvbihiKXtwKGYpO2QoKTthLmhhbmRsZUVycm9yKGIsbnVsbCxudWxsLG51bGwsbXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KCJvYmplY3ROb3RGb3VuZCIpKSl9KX0sCiEwKX12YXIgZT1hLm5ld0NvbW1lbnQoIiIsYS5nZXRDdXJyZW50VXNlcigpKSxmPW4oZSxGLG51bGwsMCk7ZCgpO2MucHJldmVudERlZmF1bHQoKTtteEV2ZW50LmNvbnN1bWUoYyl9KTt6LmFwcGVuZENoaWxkKEQpfUQ9RS5jbG9uZU5vZGUoKTtELmlubmVySFRNTD0nPGltZyBzcmM9IicrSU1BR0VfUEFUSCsnL2NoZWNrLnBuZyIgc3R5bGU9IndpZHRoOiAxNnB4OyBwYWRkaW5nOiAycHg7Ij4nO0Quc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJzaG93UmVzb2x2ZWQiKSk7dmFyIEc9ITE7ImRhcmsiPT11aVRoZW1lJiYoRC5zdHlsZS5maWx0ZXI9ImludmVydCgxMDAlKSIpO214RXZlbnQuYWRkTGlzdGVuZXIoRCwiY2xpY2siLGZ1bmN0aW9uKGEpe3RoaXMuY2xhc3NOYW1lPShHPSFHKT8iZ2VCdXR0b24gZ2VDaGVja2VkQnRuIjoiZ2VCdXR0b24iO0goKTthLnByZXZlbnREZWZhdWx0KCk7bXhFdmVudC5jb25zdW1lKGEpfSk7ei5hcHBlbmRDaGlsZChEKTthLmNvbW1lbnRzUmVmcmVzaE5lZWRlZCgpJiYKKEQ9RS5jbG9uZU5vZGUoKSxELmlubmVySFRNTD0nPGltZyBzcmM9IicrSU1BR0VfUEFUSCsnL3VwZGF0ZTE2LnBuZyIgc3R5bGU9IndpZHRoOiAxNnB4OyBwYWRkaW5nOiAycHg7Ij4nLEQuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJyZWZyZXNoIikpLCJkYXJrIj09dWlUaGVtZSYmKEQuc3R5bGUuZmlsdGVyPSJpbnZlcnQoMTAwJSkiKSxteEV2ZW50LmFkZExpc3RlbmVyKEQsImNsaWNrIixmdW5jdGlvbihhKXtIKCk7YS5wcmV2ZW50RGVmYXVsdCgpO214RXZlbnQuY29uc3VtZShhKX0pLHouYXBwZW5kQ2hpbGQoRCkpO2EuY29tbWVudHNTYXZlTmVlZGVkKCkmJihFPUUuY2xvbmVOb2RlKCksRS5pbm5lckhUTUw9JzxpbWcgc3JjPSInK0lNQUdFX1BBVEgrJy9zYXZlLnBuZyIgc3R5bGU9IndpZHRoOiAyMHB4OyBwYWRkaW5nOiAycHg7Ij4nLEUuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJzYXZlIikpLCJkYXJrIj09dWlUaGVtZSYmCihFLnN0eWxlLmZpbHRlcj0iaW52ZXJ0KDEwMCUpIiksbXhFdmVudC5hZGRMaXN0ZW5lcihFLCJjbGljayIsZnVuY3Rpb24oYSl7aygpO2EucHJldmVudERlZmF1bHQoKTtteEV2ZW50LmNvbnN1bWUoYSl9KSx6LmFwcGVuZENoaWxkKEUpKTt4LmFwcGVuZENoaWxkKHopO3ZhciBGPVtdLEg9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmhhc0Vycm9yPSExO2lmKG51bGwhPXkpdHJ5e3kuZGl2PXkuZGl2LmNsb25lTm9kZSghMCk7dmFyIGM9eS5kaXYucXVlcnlTZWxlY3RvcigiLmdlQ29tbWVudEVkaXRUeHRBcmVhIiksZD15LmRpdi5xdWVyeVNlbGVjdG9yKCIuZ2VDb21tZW50RWRpdEJ0bnMiKTt5LmNvbW1lbnQuY29udGVudD1jLnZhbHVlO2MucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKTtkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCl9Y2F0Y2goQil7YS5oYW5kbGVFcnJvcihCKX1BLmlubmVySFRNTD0nPGRpdiBzdHlsZT0icGFkZGluZy10b3A6MTBweDt0ZXh0LWFsaWduOmNlbnRlcjsiPjxpbWcgc3JjPSInKwpJTUFHRV9QQVRIKycvc3Bpbi5naWYiIHZhbGlnbj0ibWlkZGxlIj4gJytteFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQoImxvYWRpbmciKSkrIi4uLjwvZGl2PiI7dD1hLmNhblJlcGx5VG9SZXBsaWVzKCk7YS5jb21tZW50c1N1cHBvcnRlZCgpP2EuZ2V0Q29tbWVudHMoZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYyhhKXtpZihudWxsIT1hKXthLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IERhdGUoYS5tb2RpZmllZERhdGUpLW5ldyBEYXRlKGIubW9kaWZpZWREYXRlKX0pO2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKWMoYVtiXS5yZXBsaWVzKX19YS5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBEYXRlKGEubW9kaWZpZWREYXRlKS1uZXcgRGF0ZShiLm1vZGlmaWVkRGF0ZSl9KTtBLmlubmVySFRNTD0iIjtBLmFwcGVuZENoaWxkKEMpO0Muc3R5bGUuZGlzcGxheT0iYmxvY2siO0Y9YTtmb3IoYT0wO2E8Ri5sZW5ndGg7YSsrKWMoRlthXS5yZXBsaWVzKSwKbihGW2FdLEYsbnVsbCwwLEcpO251bGwhPXkmJm51bGw9PXkuY29tbWVudC5pZCYmbnVsbD09eS5jb21tZW50LnBDb21tZW50SWQmJihBLmFwcGVuZENoaWxkKHkuZGl2KSxiKHkuY29tbWVudCx5LmRpdix5LnNhdmVDYWxsYmFjayx5LmRlbGV0ZU9uQ2FuY2VsKSl9LG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe0EuaW5uZXJIVE1MPW14VXRpbHMuaHRtbEVudGl0aWVzKG14UmVzb3VyY2VzLmdldCgiZXJyb3IiKSsoYSYmYS5tZXNzYWdlPyI6ICIrYS5tZXNzYWdlOiIiKSk7dGhpcy5oYXNFcnJvcj0hMH0pKTpBLmlubmVySFRNTD1teFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQoImVycm9yIikpfSk7SCgpO3RoaXMucmVmcmVzaENvbW1lbnRzPUg7ej1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2Z1bmN0aW9uIGEoYil7dmFyIGQ9Y1tiLmlkXTtpZihudWxsIT1kKWZvcihlKGIsZCksZD0wO251bGwhPWIucmVwbGllcyYmZDxiLnJlcGxpZXMubGVuZ3RoO2QrKylhKGIucmVwbGllc1tkXSl9CmlmKHRoaXMud2luZG93LmlzVmlzaWJsZSgpKXtmb3IodmFyIGI9QS5xdWVyeVNlbGVjdG9yQWxsKCIuZ2VDb21tZW50RGF0ZSIpLGM9e30sZD0wO2Q8Yi5sZW5ndGg7ZCsrKXt2YXIgZj1iW2RdO2NbZi5nZXRBdHRyaWJ1dGUoImRhdGEtY29tbWVudElkIildPWZ9Zm9yKGQ9MDtkPEYubGVuZ3RoO2QrKylhKEZbZF0pfX0pO3NldEludGVydmFsKHosNkU0KTt0aGlzLnJlZnJlc2hDb21tZW50c1RpbWU9ejt0aGlzLndpbmRvdz1uZXcgbXhXaW5kb3cobXhSZXNvdXJjZXMuZ2V0KCJjb21tZW50cyIpLHgsYyxmLGQsbSwhMCwhMCk7dGhpcy53aW5kb3cubWluaW11bVNpemU9bmV3IG14UmVjdGFuZ2xlKDAsMCwzMDAsMjAwKTt0aGlzLndpbmRvdy5kZXN0cm95T25DbG9zZT0hMTt0aGlzLndpbmRvdy5zZXRNYXhpbWl6YWJsZSghMSk7dGhpcy53aW5kb3cuc2V0UmVzaXphYmxlKCEwKTt0aGlzLndpbmRvdy5zZXRDbG9zYWJsZSghMCk7dGhpcy53aW5kb3cuc2V0VmlzaWJsZSghMCk7dGhpcy53aW5kb3cuYWRkTGlzdGVuZXIobXhFdmVudC5TSE9XLApteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMud2luZG93LmZpdCgpfSkpO3RoaXMud2luZG93LnNldExvY2F0aW9uPWZ1bmN0aW9uKGEsYil7dmFyIGM9d2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDthPU1hdGgubWF4KDAsTWF0aC5taW4oYSwod2luZG93LmlubmVyV2lkdGh8fGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGh8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCktdGhpcy50YWJsZS5jbGllbnRXaWR0aCkpO2I9TWF0aC5tYXgoMCxNYXRoLm1pbihiLGMtdGhpcy50YWJsZS5jbGllbnRIZWlnaHQtNDgpKTt0aGlzLmdldFgoKT09YSYmdGhpcy5nZXRZKCk9PWJ8fG14V2luZG93LnByb3RvdHlwZS5zZXRMb2NhdGlvbi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBKPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGE9dGhpcy53aW5kb3cuZ2V0WCgpLApiPXRoaXMud2luZG93LmdldFkoKTt0aGlzLndpbmRvdy5zZXRMb2NhdGlvbihhLGIpfSk7bXhFdmVudC5hZGRMaXN0ZW5lcih3aW5kb3csInJlc2l6ZSIsSik7dGhpcy5kZXN0cm95PWZ1bmN0aW9uKCl7bXhFdmVudC5yZW1vdmVMaXN0ZW5lcih3aW5kb3csInJlc2l6ZSIsSik7dGhpcy53aW5kb3cuZGVzdHJveSgpfX0sQ29uZmlybURpYWxvZz1mdW5jdGlvbihhLGMsZixkLG0sayxxLGIsZSxnLHApe3ZhciBsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2wuc3R5bGUudGV4dEFsaWduPSJjZW50ZXIiO3A9bnVsbCE9cD9wOjQ0O3ZhciBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO24uc3R5bGUucGFkZGluZz0iNnB4IjtuLnN0eWxlLm92ZXJmbG93PSJhdXRvIjtuLnN0eWxlLm1heEhlaWdodD1wKyJweCI7bi5zdHlsZS5saW5lSGVpZ2h0PSIxLjJlbSI7bXhDbGllbnQuSVNfUVVJUktTJiYobi5zdHlsZS5oZWlnaHQ9IjYwcHgiKTtteFV0aWxzLndyaXRlKG4sYyk7CmwuYXBwZW5kQ2hpbGQobik7bnVsbCE9ZyYmKG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iiksbi5zdHlsZS5wYWRkaW5nPSI2cHggMCA2cHggMCIsYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKSxjLnNldEF0dHJpYnV0ZSgic3JjIixnKSxuLmFwcGVuZENoaWxkKGMpLGwuYXBwZW5kQ2hpbGQobikpO2c9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Zy5zdHlsZS50ZXh0QWxpZ249ImNlbnRlciI7Zy5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiO3ZhciB2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7di5zZXRBdHRyaWJ1dGUoInR5cGUiLCJjaGVja2JveCIpO2s9bXhVdGlscy5idXR0b24oa3x8bXhSZXNvdXJjZXMuZ2V0KCJjYW5jZWwiKSxmdW5jdGlvbigpe2EuaGlkZURpYWxvZygpO251bGwhPWQmJmQodi5jaGVja2VkKX0pO2suY2xhc3NOYW1lPSJnZUJ0biI7bnVsbCE9YiYmKGsuaW5uZXJIVE1MPWIrIjxicj4iK2suaW5uZXJIVE1MLGsuc3R5bGUucGFkZGluZ0JvdHRvbT0KIjhweCIsay5zdHlsZS5wYWRkaW5nVG9wPSI4cHgiLGsuc3R5bGUuaGVpZ2h0PSJhdXRvIixrLnN0eWxlLndpZHRoPSI0MCUiKTthLmVkaXRvci5jYW5jZWxGaXJzdCYmZy5hcHBlbmRDaGlsZChrKTt2YXIgdD1teFV0aWxzLmJ1dHRvbihtfHxteFJlc291cmNlcy5nZXQoIm9rIiksZnVuY3Rpb24oKXthLmhpZGVEaWFsb2coKTtudWxsIT1mJiZmKHYuY2hlY2tlZCl9KTtnLmFwcGVuZENoaWxkKHQpO251bGwhPXE/KHQuaW5uZXJIVE1MPXErIjxicj4iK3QuaW5uZXJIVE1MKyI8YnI+Iix0LnN0eWxlLnBhZGRpbmdCb3R0b209IjhweCIsdC5zdHlsZS5wYWRkaW5nVG9wPSI4cHgiLHQuc3R5bGUuaGVpZ2h0PSJhdXRvIix0LmNsYXNzTmFtZT0iZ2VCdG4iLHQuc3R5bGUud2lkdGg9IjQwJSIpOnQuY2xhc3NOYW1lPSJnZUJ0biBnZVByaW1hcnlCdG4iO2EuZWRpdG9yLmNhbmNlbEZpcnN0fHxnLmFwcGVuZENoaWxkKGspO2wuYXBwZW5kQ2hpbGQoZyk7ZT8oZy5zdHlsZS5tYXJnaW5Ub3A9CiIxMHB4IixuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInAiKSxuLnN0eWxlLm1hcmdpblRvcD0iMjBweCIsbi5hcHBlbmRDaGlsZCh2KSxtPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNwYW4iKSxteFV0aWxzLndyaXRlKG0sIiAiK214UmVzb3VyY2VzLmdldCgicmVtZW1iZXJUaGlzU2V0dGluZyIpKSxuLmFwcGVuZENoaWxkKG0pLGwuYXBwZW5kQ2hpbGQobiksbXhFdmVudC5hZGRMaXN0ZW5lcihtLCJjbGljayIsZnVuY3Rpb24oYSl7di5jaGVja2VkPSF2LmNoZWNrZWQ7bXhFdmVudC5jb25zdW1lKGEpfSkpOmcuc3R5bGUubWFyZ2luVG9wPSIxMnB4Ijt0aGlzLmluaXQ9ZnVuY3Rpb24oKXt0LmZvY3VzKCl9O3RoaXMuY29udGFpbmVyPWx9O2Z1bmN0aW9uIERpYWdyYW1QYWdlKGEsYyl7dGhpcy5ub2RlPWE7bnVsbCE9Yz90aGlzLm5vZGUuc2V0QXR0cmlidXRlKCJpZCIsYyk6bnVsbD09dGhpcy5nZXRJZCgpJiZ0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCJpZCIsRWRpdG9yLmd1aWQoKSl9RGlhZ3JhbVBhZ2UucHJvdG90eXBlLm5vZGU9bnVsbDtEaWFncmFtUGFnZS5wcm90b3R5cGUucm9vdD1udWxsO0RpYWdyYW1QYWdlLnByb3RvdHlwZS52aWV3U3RhdGU9bnVsbDtEaWFncmFtUGFnZS5wcm90b3R5cGUuZ2V0SWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlLmdldEF0dHJpYnV0ZSgiaWQiKX07RGlhZ3JhbVBhZ2UucHJvdG90eXBlLmdldE5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlLmdldEF0dHJpYnV0ZSgibmFtZSIpfTsKRGlhZ3JhbVBhZ2UucHJvdG90eXBlLnNldE5hbWU9ZnVuY3Rpb24oYSl7bnVsbD09YT90aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKCJuYW1lIik6dGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgibmFtZSIsYSl9O2Z1bmN0aW9uIFJlbmFtZVBhZ2UoYSxjLGYpe3RoaXMudWk9YTt0aGlzLnBhZ2U9Yzt0aGlzLnByZXZpb3VzPXRoaXMubmFtZT1mfVJlbmFtZVBhZ2UucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnBhZ2UuZ2V0TmFtZSgpO3RoaXMucGFnZS5zZXROYW1lKHRoaXMucHJldmlvdXMpO3RoaXMubmFtZT10aGlzLnByZXZpb3VzO3RoaXMucHJldmlvdXM9YTt0aGlzLnVpLmVkaXRvci5ncmFwaC51cGRhdGVQbGFjZWhvbGRlcnMoKTt0aGlzLnVpLmVkaXRvci5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInBhZ2VSZW5hbWVkIikpfTsKZnVuY3Rpb24gTW92ZVBhZ2UoYSxjLGYpe3RoaXMudWk9YTt0aGlzLm9sZEluZGV4PWM7dGhpcy5uZXdJbmRleD1mfU1vdmVQYWdlLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKCl7dGhpcy51aS5wYWdlcy5zcGxpY2UodGhpcy5uZXdJbmRleCwwLHRoaXMudWkucGFnZXMuc3BsaWNlKHRoaXMub2xkSW5kZXgsMSlbMF0pO3ZhciBhPXRoaXMub2xkSW5kZXg7dGhpcy5vbGRJbmRleD10aGlzLm5ld0luZGV4O3RoaXMubmV3SW5kZXg9YTt0aGlzLnVpLmVkaXRvci5ncmFwaC51cGRhdGVQbGFjZWhvbGRlcnMoKTt0aGlzLnVpLmVkaXRvci5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInBhZ2VNb3ZlZCIpKX07CmZ1bmN0aW9uIFNlbGVjdFBhZ2UoYSxjLGYpe3RoaXMudWk9YTt0aGlzLnByZXZpb3VzUGFnZT10aGlzLnBhZ2U9Yzt0aGlzLm5ldmVyU2hvd249ITA7bnVsbCE9YyYmKHRoaXMubmV2ZXJTaG93bj1udWxsPT1jLnZpZXdTdGF0ZSx0aGlzLnVpLnVwZGF0ZVBhZ2VSb290KGMpLG51bGwhPWYmJihjLnZpZXdTdGF0ZT1mLHRoaXMubmV2ZXJTaG93bj0hMSkpfQpTZWxlY3RQYWdlLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKCl7dmFyIGE9bXhVdGlscy5pbmRleE9mKHRoaXMudWkucGFnZXMsdGhpcy5wcmV2aW91c1BhZ2UpO2lmKG51bGwhPXRoaXMucGFnZSYmMDw9YSl7dmFyIGE9dGhpcy51aS5jdXJyZW50UGFnZSxjPXRoaXMudWkuZWRpdG9yLGY9Yy5ncmFwaCxkPUdyYXBoLmNvbXByZXNzTm9kZShjLmdldEdyYXBoWG1sKCEwKSk7bXhVdGlscy5zZXRUZXh0Q29udGVudChhLm5vZGUsZCk7YS52aWV3U3RhdGU9Zi5nZXRWaWV3U3RhdGUoKTthLnJvb3Q9Zi5tb2RlbC5yb290O251bGwhPWEubW9kZWwmJmEubW9kZWwucm9vdENoYW5nZWQoYS5yb290KTtmLnZpZXcuY2xlYXIoYS5yb290LCEwKTtmLmNsZWFyU2VsZWN0aW9uKCk7dGhpcy51aS5jdXJyZW50UGFnZT10aGlzLnByZXZpb3VzUGFnZTt0aGlzLnByZXZpb3VzUGFnZT1hO2E9dGhpcy51aS5jdXJyZW50UGFnZTtmLm1vZGVsLnByZWZpeD1FZGl0b3IuZ3VpZCgpKyItIjtmLm1vZGVsLnJvb3RDaGFuZ2VkKGEucm9vdCk7CmYuc2V0Vmlld1N0YXRlKGEudmlld1N0YXRlKTtmLmdyaWRFbmFibGVkPWYuZ3JpZEVuYWJsZWQmJighdGhpcy51aS5lZGl0b3IuaXNDaHJvbWVsZXNzVmlldygpfHwiMSI9PXVybFBhcmFtcy5ncmlkKTtjLnVwZGF0ZUdyYXBoQ29tcG9uZW50cygpO2Yudmlldy52YWxpZGF0ZSgpO2YuYmxvY2tNYXRoUmVuZGVyPSEwO2Yuc2l6ZURpZENoYW5nZSgpO2YuYmxvY2tNYXRoUmVuZGVyPSExO3RoaXMubmV2ZXJTaG93biYmKHRoaXMubmV2ZXJTaG93bj0hMSxmLnNlbGVjdFVubG9ja2VkTGF5ZXIoKSk7Yy5ncmFwaC5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5ST09UKSk7Yy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInBhZ2VTZWxlY3RlZCIsImNoYW5nZSIsdGhpcykpfX07CmZ1bmN0aW9uIENoYW5nZVBhZ2UoYSxjLGYsZCxtKXtTZWxlY3RQYWdlLmNhbGwodGhpcyxhLGYpO3RoaXMucmVsYXRlZFBhZ2U9Yzt0aGlzLmluZGV4PWQ7dGhpcy5wcmV2aW91c0luZGV4PW51bGw7dGhpcy5ub1NlbGVjdD1tfW14VXRpbHMuZXh0ZW5kKENoYW5nZVBhZ2UsU2VsZWN0UGFnZSk7CkNoYW5nZVBhZ2UucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXt0aGlzLnVpLmVkaXRvci5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImJlZm9yZVBhZ2VDaGFuZ2UiLCJjaGFuZ2UiLHRoaXMpKTt0aGlzLnByZXZpb3VzSW5kZXg9dGhpcy5pbmRleDtpZihudWxsPT10aGlzLmluZGV4KXt2YXIgYT1teFV0aWxzLmluZGV4T2YodGhpcy51aS5wYWdlcyx0aGlzLnJlbGF0ZWRQYWdlKTt0aGlzLnVpLnBhZ2VzLnNwbGljZShhLDEpO3RoaXMuaW5kZXg9YX1lbHNlIHRoaXMudWkucGFnZXMuc3BsaWNlKHRoaXMuaW5kZXgsMCx0aGlzLnJlbGF0ZWRQYWdlKSx0aGlzLmluZGV4PW51bGw7dGhpcy5ub1NlbGVjdHx8U2VsZWN0UGFnZS5wcm90b3R5cGUuZXhlY3V0ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O0VkaXRvclVpLnByb3RvdHlwZS50YWJDb250YWluZXJIZWlnaHQ9Mzg7CkVkaXRvclVpLnByb3RvdHlwZS5nZXRTZWxlY3RlZFBhZ2VJbmRleD1mdW5jdGlvbigpe3ZhciBhPW51bGw7aWYobnVsbCE9dGhpcy5wYWdlcyYmbnVsbCE9dGhpcy5jdXJyZW50UGFnZSlmb3IodmFyIGM9MDtjPHRoaXMucGFnZXMubGVuZ3RoO2MrKylpZih0aGlzLnBhZ2VzW2NdPT10aGlzLmN1cnJlbnRQYWdlKXthPWM7YnJlYWt9cmV0dXJuIGF9O0VkaXRvclVpLnByb3RvdHlwZS5nZXRQYWdlQnlJZD1mdW5jdGlvbihhKXtpZihudWxsIT10aGlzLnBhZ2VzKWZvcih2YXIgYz0wO2M8dGhpcy5wYWdlcy5sZW5ndGg7YysrKWlmKHRoaXMucGFnZXNbY10uZ2V0SWQoKT09YSlyZXR1cm4gdGhpcy5wYWdlc1tjXTtyZXR1cm4gbnVsbH07CkVkaXRvclVpLnByb3RvdHlwZS5pbml0UGFnZXM9ZnVuY3Rpb24oKXtpZighdGhpcy5lZGl0b3IuZ3JhcGguc3RhbmRhbG9uZSl7dGhpcy5hY3Rpb25zLmFkZEFjdGlvbigicHJldmlvdXNQYWdlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuc2VsZWN0TmV4dFBhZ2UoITEpfSkpO3RoaXMuYWN0aW9ucy5hZGRBY3Rpb24oIm5leHRQYWdlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuc2VsZWN0TmV4dFBhZ2UoITApfSkpO3RoaXMua2V5SGFuZGxlci5iaW5kQWN0aW9uKDMzLCEwLCJwcmV2aW91c1BhZ2UiLCEwKTt0aGlzLmtleUhhbmRsZXIuYmluZEFjdGlvbigzNCwhMCwibmV4dFBhZ2UiLCEwKTt2YXIgYT10aGlzLmVkaXRvci5ncmFwaCxjPWEudmlldy52YWxpZGF0ZUJhY2tncm91bmQ7YS52aWV3LnZhbGlkYXRlQmFja2dyb3VuZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2lmKG51bGwhPXRoaXMudGFiQ29udGFpbmVyKXt2YXIgZD10aGlzLnRhYkNvbnRhaW5lci5zdHlsZS5oZWlnaHQ7CnRoaXMudGFiQ29udGFpbmVyLnN0eWxlLmhlaWdodD1udWxsPT10aGlzLmZpbGVOb2RlfHxudWxsPT10aGlzLnBhZ2VzfHwxPT10aGlzLnBhZ2VzLmxlbmd0aCYmIjAiPT11cmxQYXJhbXMucGFnZXM/IjBweCI6dGhpcy50YWJDb250YWluZXJIZWlnaHQrInB4IjtkIT10aGlzLnRhYkNvbnRhaW5lci5zdHlsZS5oZWlnaHQmJnRoaXMucmVmcmVzaCghMSl9Yy5hcHBseShhLnZpZXcsYXJndW1lbnRzKX0pO3ZhciBmPW51bGwsZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMudXBkYXRlVGFiQ29udGFpbmVyKCk7dmFyIGM9dGhpcy5jdXJyZW50UGFnZTtudWxsIT1jJiZjIT1mJiYobnVsbD09Yy52aWV3U3RhdGV8fG51bGw9PWMudmlld1N0YXRlLnNjcm9sbExlZnQ/KHRoaXMucmVzZXRTY3JvbGxiYXJzKCksYS5pc0xpZ2h0Ym94VmlldygpJiZ0aGlzLmxpZ2h0Ym94Rml0KCksbnVsbCE9dGhpcy5jaHJvbWVsZXNzUmVzaXplJiYoYS5jb250YWluZXIuc2Nyb2xsTGVmdD0wLAphLmNvbnRhaW5lci5zY3JvbGxUb3A9MCx0aGlzLmNocm9tZWxlc3NSZXNpemUoKSkpOihhLmNvbnRhaW5lci5zY3JvbGxMZWZ0PWEudmlldy50cmFuc2xhdGUueCphLnZpZXcuc2NhbGUrYy52aWV3U3RhdGUuc2Nyb2xsTGVmdCxhLmNvbnRhaW5lci5zY3JvbGxUb3A9YS52aWV3LnRyYW5zbGF0ZS55KmEudmlldy5zY2FsZStjLnZpZXdTdGF0ZS5zY3JvbGxUb3ApLGY9Yyk7bnVsbCE9dGhpcy5hY3Rpb25zLmxheWVyc1dpbmRvdyYmdGhpcy5hY3Rpb25zLmxheWVyc1dpbmRvdy5yZWZyZXNoTGF5ZXJzKCk7InVuZGVmaW5lZCIhPT10eXBlb2YgTWF0aEpheCYmInVuZGVmaW5lZCIhPT10eXBlb2YgTWF0aEpheC5IdWI/MSE9TWF0aEpheC5IdWIucXVldWUucGVuZGluZ3x8bnVsbD09dGhpcy5lZGl0b3J8fHRoaXMuZWRpdG9yLmdyYXBoLm1hdGhFbmFibGVkfHxNYXRoSmF4Lkh1Yi5RdWV1ZShteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe251bGwhPXRoaXMuZWRpdG9yJiZ0aGlzLmVkaXRvci5ncmFwaC5yZWZyZXNoKCl9KSk6CiJ1bmRlZmluZWQiPT09dHlwZW9mIEVkaXRvci5NYXRoSmF4Q2xlYXJ8fG51bGwhPXRoaXMuZWRpdG9yJiZ0aGlzLmVkaXRvci5ncmFwaC5tYXRoRW5hYmxlZHx8RWRpdG9yLk1hdGhKYXhDbGVhcigpfSk7dGhpcy5lZGl0b3IuZ3JhcGgubW9kZWwuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXtmb3IodmFyIGY9Yy5nZXRQcm9wZXJ0eSgiZWRpdCIpLmNoYW5nZXMsYj0wO2I8Zi5sZW5ndGg7YisrKWlmKGZbYl1pbnN0YW5jZW9mIFNlbGVjdFBhZ2V8fGZbYl1pbnN0YW5jZW9mIFJlbmFtZVBhZ2V8fGZbYl1pbnN0YW5jZW9mIE1vdmVQYWdlfHxmW2JdaW5zdGFuY2VvZiBteFJvb3RDaGFuZ2Upe2QoKTticmVha319KSk7bnVsbCE9dGhpcy50b29sYmFyJiZ0aGlzLmVkaXRvci5hZGRMaXN0ZW5lcigicGFnZVNlbGVjdGVkIix0aGlzLnRvb2xiYXIudXBkYXRlWm9vbSl9fTsKRWRpdG9yVWkucHJvdG90eXBlLnJlc3RvcmVWaWV3U3RhdGU9ZnVuY3Rpb24oYSxjLGYpe2E9bnVsbCE9YT90aGlzLmdldFBhZ2VCeUlkKGEuZ2V0SWQoKSk6bnVsbDt2YXIgZD10aGlzLmVkaXRvci5ncmFwaDtudWxsIT1hJiZudWxsIT10aGlzLmN1cnJlbnRQYWdlJiZudWxsIT10aGlzLnBhZ2VzJiYoYSE9dGhpcy5jdXJyZW50UGFnZT90aGlzLnNlbGVjdFBhZ2UoYSwhMCxjKTooZC5zZXRWaWV3U3RhdGUoYyksdGhpcy5lZGl0b3IudXBkYXRlR3JhcGhDb21wb25lbnRzKCksZC52aWV3LnJldmFsaWRhdGUoKSxkLnNpemVEaWRDaGFuZ2UoKSksZC5jb250YWluZXIuc2Nyb2xsTGVmdD1kLnZpZXcudHJhbnNsYXRlLngqZC52aWV3LnNjYWxlK2Muc2Nyb2xsTGVmdCxkLmNvbnRhaW5lci5zY3JvbGxUb3A9ZC52aWV3LnRyYW5zbGF0ZS55KmQudmlldy5zY2FsZStjLnNjcm9sbFRvcCxkLnJlc3RvcmVTZWxlY3Rpb24oZikpfTsKR3JhcGgucHJvdG90eXBlLmNyZWF0ZVZpZXdTdGF0ZT1mdW5jdGlvbihhKXt2YXIgYz1hLmdldEF0dHJpYnV0ZSgicGFnZSIpLGY9cGFyc2VGbG9hdChhLmdldEF0dHJpYnV0ZSgicGFnZVNjYWxlIikpLGQ9cGFyc2VGbG9hdChhLmdldEF0dHJpYnV0ZSgicGFnZVdpZHRoIikpLG09cGFyc2VGbG9hdChhLmdldEF0dHJpYnV0ZSgicGFnZUhlaWdodCIpKSxrPWEuZ2V0QXR0cmlidXRlKCJiYWNrZ3JvdW5kIikscT1hLmdldEF0dHJpYnV0ZSgiYmFja2dyb3VuZEltYWdlIikscT1udWxsIT1xJiYwPHEubGVuZ3RoP0pTT04ucGFyc2UocSk6bnVsbCxiPWEuZ2V0QXR0cmlidXRlKCJleHRGb250cyIpO2lmKGIpdHJ5e2I9Yi5zcGxpdCgifCIpLm1hcChmdW5jdGlvbihhKXthPWEuc3BsaXQoIl4iKTtyZXR1cm57bmFtZTphWzBdLHVybDphWzFdfX0pfWNhdGNoKGUpe2NvbnNvbGUubG9nKCJFeHRGb250cyBmb3JtYXQgZXJyb3I6ICIrZS5tZXNzYWdlKX1yZXR1cm57Z3JpZEVuYWJsZWQ6IjAiIT0KYS5nZXRBdHRyaWJ1dGUoImdyaWQiKSxncmlkU2l6ZTpwYXJzZUZsb2F0KGEuZ2V0QXR0cmlidXRlKCJncmlkU2l6ZSIpKXx8bXhHcmFwaC5wcm90b3R5cGUuZ3JpZFNpemUsZ3VpZGVzRW5hYmxlZDoiMCIhPWEuZ2V0QXR0cmlidXRlKCJndWlkZXMiKSxmb2xkaW5nRW5hYmxlZDoiMCIhPWEuZ2V0QXR0cmlidXRlKCJmb2xkIiksc2hhZG93VmlzaWJsZToiMSI9PWEuZ2V0QXR0cmlidXRlKCJzaGFkb3ciKSxwYWdlVmlzaWJsZTp0aGlzLmlzTGlnaHRib3hWaWV3KCk/ITE6bnVsbCE9Yz8iMCIhPWM6dGhpcy5kZWZhdWx0UGFnZVZpc2libGUsYmFja2dyb3VuZDpudWxsIT1rJiYwPGsubGVuZ3RoP2s6bnVsbCxiYWNrZ3JvdW5kSW1hZ2U6bnVsbCE9cT9uZXcgbXhJbWFnZShxLnNyYyxxLndpZHRoLHEuaGVpZ2h0KTpudWxsLHBhZ2VTY2FsZTppc05hTihmKT9teEdyYXBoLnByb3RvdHlwZS5wYWdlU2NhbGU6ZixwYWdlRm9ybWF0OmlzTmFOKGQpfHxpc05hTihtKT8idW5kZWZpbmVkIj09PQp0eXBlb2YgbXhTZXR0aW5ncz9teEdyYXBoLnByb3RvdHlwZS5wYWdlRm9ybWF0Om14U2V0dGluZ3MuZ2V0UGFnZUZvcm1hdCgpOm5ldyBteFJlY3RhbmdsZSgwLDAsZCxtKSx0b29sdGlwczoiMCIhPWEuZ2V0QXR0cmlidXRlKCJ0b29sdGlwcyIpLGNvbm5lY3Q6IjAiIT1hLmdldEF0dHJpYnV0ZSgiY29ubmVjdCIpLGFycm93czoiMCIhPWEuZ2V0QXR0cmlidXRlKCJhcnJvd3MiKSxtYXRoRW5hYmxlZDoiMSI9PWEuZ2V0QXR0cmlidXRlKCJtYXRoIiksc2VsZWN0aW9uQ2VsbHM6bnVsbCxkZWZhdWx0UGFyZW50Om51bGwsc2Nyb2xsYmFyczp0aGlzLmRlZmF1bHRTY3JvbGxiYXJzLHNjYWxlOjEsZXh0Rm9udHM6Ynx8W119fTsKR3JhcGgucHJvdG90eXBlLnNhdmVWaWV3U3RhdGU9ZnVuY3Rpb24oYSxjLGYpe2Z8fChjLnNldEF0dHJpYnV0ZSgiZ3JpZCIsbnVsbD09YXx8YS5ncmlkRW5hYmxlZD8iMSI6IjAiKSxjLnNldEF0dHJpYnV0ZSgiZ3JpZFNpemUiLG51bGwhPWE/YS5ncmlkU2l6ZTpteEdyYXBoLnByb3RvdHlwZS5ncmlkU2l6ZSksYy5zZXRBdHRyaWJ1dGUoImd1aWRlcyIsbnVsbD09YXx8YS5ndWlkZXNFbmFibGVkPyIxIjoiMCIpLGMuc2V0QXR0cmlidXRlKCJ0b29sdGlwcyIsbnVsbD09YXx8YS50b29sdGlwcz8iMSI6IjAiKSxjLnNldEF0dHJpYnV0ZSgiY29ubmVjdCIsbnVsbD09YXx8YS5jb25uZWN0PyIxIjoiMCIpLGMuc2V0QXR0cmlidXRlKCJhcnJvd3MiLG51bGw9PWF8fGEuYXJyb3dzPyIxIjoiMCIpLGMuc2V0QXR0cmlidXRlKCJwYWdlIixudWxsPT1hJiZ0aGlzLmRlZmF1bHRQYWdlVmlzaWJsZXx8bnVsbCE9YSYmYS5wYWdlVmlzaWJsZT8iMSI6IjAiKSxjLnNldEF0dHJpYnV0ZSgiZm9sZCIsCm51bGw9PWF8fGEuZm9sZGluZ0VuYWJsZWQ/IjEiOiIwIikpO2Muc2V0QXR0cmlidXRlKCJwYWdlU2NhbGUiLG51bGwhPWEmJm51bGwhPWEucGFnZVNjYWxlP2EucGFnZVNjYWxlOm14R3JhcGgucHJvdG90eXBlLnBhZ2VTY2FsZSk7Zj1udWxsIT1hP2EucGFnZUZvcm1hdDoidW5kZWZpbmVkIj09PXR5cGVvZiBteFNldHRpbmdzP214R3JhcGgucHJvdG90eXBlLnBhZ2VGb3JtYXQ6bXhTZXR0aW5ncy5nZXRQYWdlRm9ybWF0KCk7bnVsbCE9ZiYmKGMuc2V0QXR0cmlidXRlKCJwYWdlV2lkdGgiLGYud2lkdGgpLGMuc2V0QXR0cmlidXRlKCJwYWdlSGVpZ2h0IixmLmhlaWdodCkpO251bGwhPWEmJm51bGwhPWEuYmFja2dyb3VuZCYmYy5zZXRBdHRyaWJ1dGUoImJhY2tncm91bmQiLGEuYmFja2dyb3VuZCk7bnVsbCE9YSYmbnVsbCE9YS5iYWNrZ3JvdW5kSW1hZ2UmJmMuc2V0QXR0cmlidXRlKCJiYWNrZ3JvdW5kSW1hZ2UiLEpTT04uc3RyaW5naWZ5KGEuYmFja2dyb3VuZEltYWdlKSk7Yy5zZXRBdHRyaWJ1dGUoIm1hdGgiLApudWxsIT1hJiZhLm1hdGhFbmFibGVkPyIxIjoiMCIpO2Muc2V0QXR0cmlidXRlKCJzaGFkb3ciLG51bGwhPWEmJmEuc2hhZG93VmlzaWJsZT8iMSI6IjAiKTtudWxsIT1hJiZudWxsIT1hLmV4dEZvbnRzJiYwPGEuZXh0Rm9udHMubGVuZ3RoJiZjLnNldEF0dHJpYnV0ZSgiZXh0Rm9udHMiLGEuZXh0Rm9udHMubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBhLm5hbWUrIl4iK2EudXJsfSkuam9pbigifCIpKX07CkdyYXBoLnByb3RvdHlwZS5nZXRWaWV3U3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm57ZGVmYXVsdFBhcmVudDp0aGlzLmRlZmF1bHRQYXJlbnQsY3VycmVudFJvb3Q6dGhpcy52aWV3LmN1cnJlbnRSb290LGdyaWRFbmFibGVkOnRoaXMuZ3JpZEVuYWJsZWQsZ3JpZFNpemU6dGhpcy5ncmlkU2l6ZSxndWlkZXNFbmFibGVkOnRoaXMuZ3JhcGhIYW5kbGVyLmd1aWRlc0VuYWJsZWQsZm9sZGluZ0VuYWJsZWQ6dGhpcy5mb2xkaW5nRW5hYmxlZCxzaGFkb3dWaXNpYmxlOnRoaXMuc2hhZG93VmlzaWJsZSxzY3JvbGxiYXJzOnRoaXMuc2Nyb2xsYmFycyxwYWdlVmlzaWJsZTp0aGlzLnBhZ2VWaXNpYmxlLGJhY2tncm91bmQ6dGhpcy5iYWNrZ3JvdW5kLGJhY2tncm91bmRJbWFnZTp0aGlzLmJhY2tncm91bmRJbWFnZSxwYWdlU2NhbGU6dGhpcy5wYWdlU2NhbGUscGFnZUZvcm1hdDp0aGlzLnBhZ2VGb3JtYXQsdG9vbHRpcHM6dGhpcy50b29sdGlwSGFuZGxlci5pc0VuYWJsZWQoKSxjb25uZWN0OnRoaXMuY29ubmVjdGlvbkhhbmRsZXIuaXNFbmFibGVkKCksCmFycm93czp0aGlzLmNvbm5lY3Rpb25BcnJvd3NFbmFibGVkLHNjYWxlOnRoaXMudmlldy5zY2FsZSxzY3JvbGxMZWZ0OnRoaXMuY29udGFpbmVyLnNjcm9sbExlZnQtdGhpcy52aWV3LnRyYW5zbGF0ZS54KnRoaXMudmlldy5zY2FsZSxzY3JvbGxUb3A6dGhpcy5jb250YWluZXIuc2Nyb2xsVG9wLXRoaXMudmlldy50cmFuc2xhdGUueSp0aGlzLnZpZXcuc2NhbGUsdHJhbnNsYXRlOnRoaXMudmlldy50cmFuc2xhdGUuY2xvbmUoKSxsYXN0UGFzdGVYbWw6dGhpcy5sYXN0UGFzdGVYbWwscGFzdGVDb3VudGVyOnRoaXMucGFzdGVDb3VudGVyLG1hdGhFbmFibGVkOnRoaXMubWF0aEVuYWJsZWQsZXh0Rm9udHM6dGhpcy5leHRGb250c319OwpHcmFwaC5wcm90b3R5cGUuc2V0Vmlld1N0YXRlPWZ1bmN0aW9uKGEsYyl7aWYobnVsbCE9YSl7dGhpcy5sYXN0UGFzdGVYbWw9YS5sYXN0UGFzdGVYbWw7dGhpcy5wYXN0ZUNvdW50ZXI9YS5wYXN0ZUNvdW50ZXJ8fDA7dGhpcy5tYXRoRW5hYmxlZD1hLm1hdGhFbmFibGVkO3RoaXMuZ3JpZEVuYWJsZWQ9YS5ncmlkRW5hYmxlZDt0aGlzLmdyaWRTaXplPWEuZ3JpZFNpemU7dGhpcy5ncmFwaEhhbmRsZXIuZ3VpZGVzRW5hYmxlZD1hLmd1aWRlc0VuYWJsZWQ7dGhpcy5mb2xkaW5nRW5hYmxlZD1hLmZvbGRpbmdFbmFibGVkO3RoaXMuc2V0U2hhZG93VmlzaWJsZShhLnNoYWRvd1Zpc2libGUsITEpO3RoaXMuc2Nyb2xsYmFycz1hLnNjcm9sbGJhcnM7dGhpcy5wYWdlVmlzaWJsZT0hdGhpcy5pc1ZpZXdlcigpJiZhLnBhZ2VWaXNpYmxlO3RoaXMuYmFja2dyb3VuZD1hLmJhY2tncm91bmQ7dGhpcy5iYWNrZ3JvdW5kSW1hZ2U9YS5iYWNrZ3JvdW5kSW1hZ2U7dGhpcy5wYWdlU2NhbGU9YS5wYWdlU2NhbGU7CnRoaXMucGFnZUZvcm1hdD1hLnBhZ2VGb3JtYXQ7dGhpcy52aWV3LmN1cnJlbnRSb290PWEuY3VycmVudFJvb3Q7dGhpcy5kZWZhdWx0UGFyZW50PWEuZGVmYXVsdFBhcmVudDt0aGlzLmNvbm5lY3Rpb25BcnJvd3NFbmFibGVkPWEuYXJyb3dzO3RoaXMuc2V0VG9vbHRpcHMoYS50b29sdGlwcyk7dGhpcy5zZXRDb25uZWN0YWJsZShhLmNvbm5lY3QpO3ZhciBmPXRoaXMuZXh0Rm9udHM7dGhpcy5leHRGb250cz1hLmV4dEZvbnRzfHxbXTtpZihjJiZudWxsIT1mKWZvcih2YXIgZD0wO2Q8Zi5sZW5ndGg7ZCsrKXt2YXIgbT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiZXh0Rm9udF8iK2ZbZF0ubmFtZSk7bnVsbCE9bSYmbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG0pfWZvcihkPTA7ZDx0aGlzLmV4dEZvbnRzLmxlbmd0aDtkKyspdGhpcy5hZGRFeHRGb250KHRoaXMuZXh0Rm9udHNbZF0ubmFtZSx0aGlzLmV4dEZvbnRzW2RdLnVybCwhMCk7dGhpcy52aWV3LnNjYWxlPW51bGwhPWEuc2NhbGU/CmEuc2NhbGU6MTtudWxsPT10aGlzLnZpZXcuY3VycmVudFJvb3R8fHRoaXMubW9kZWwuY29udGFpbnModGhpcy52aWV3LmN1cnJlbnRSb290KXx8KHRoaXMudmlldy5jdXJyZW50Um9vdD1udWxsKTtudWxsPT10aGlzLmRlZmF1bHRQYXJlbnR8fHRoaXMubW9kZWwuY29udGFpbnModGhpcy5kZWZhdWx0UGFyZW50KXx8KHRoaXMuc2V0RGVmYXVsdFBhcmVudChudWxsKSx0aGlzLnNlbGVjdFVubG9ja2VkTGF5ZXIoKSk7bnVsbCE9YS50cmFuc2xhdGUmJih0aGlzLnZpZXcudHJhbnNsYXRlPWEudHJhbnNsYXRlKX1lbHNlIHRoaXMudmlldy5jdXJyZW50Um9vdD1udWxsLHRoaXMudmlldy5zY2FsZT0xLHRoaXMuZ3JpZEVuYWJsZWQ9ITAsdGhpcy5ncmlkU2l6ZT1teEdyYXBoLnByb3RvdHlwZS5ncmlkU2l6ZSx0aGlzLnBhZ2VTY2FsZT1teEdyYXBoLnByb3RvdHlwZS5wYWdlU2NhbGUsdGhpcy5wYWdlRm9ybWF0PSJ1bmRlZmluZWQiPT09dHlwZW9mIG14U2V0dGluZ3M/bXhHcmFwaC5wcm90b3R5cGUucGFnZUZvcm1hdDoKbXhTZXR0aW5ncy5nZXRQYWdlRm9ybWF0KCksdGhpcy5wYWdlVmlzaWJsZT10aGlzLmRlZmF1bHRQYWdlVmlzaWJsZSx0aGlzLmJhY2tncm91bmRJbWFnZT10aGlzLmJhY2tncm91bmQ9bnVsbCx0aGlzLnNjcm9sbGJhcnM9dGhpcy5kZWZhdWx0U2Nyb2xsYmFycyx0aGlzLmZvbGRpbmdFbmFibGVkPXRoaXMuZ3JhcGhIYW5kbGVyLmd1aWRlc0VuYWJsZWQ9ITAsdGhpcy5zZXRTaGFkb3dWaXNpYmxlKCExLCExKSx0aGlzLmRlZmF1bHRQYXJlbnQ9bnVsbCx0aGlzLnNldFRvb2x0aXBzKCEwKSx0aGlzLnNldENvbm5lY3RhYmxlKCEwKSx0aGlzLmxhc3RQYXN0ZVhtbD1udWxsLHRoaXMucGFzdGVDb3VudGVyPTAsdGhpcy5tYXRoRW5hYmxlZD0hMSx0aGlzLmNvbm5lY3Rpb25BcnJvd3NFbmFibGVkPSEwLHRoaXMuZXh0Rm9udHM9W107dGhpcy5wcmVmZXJQYWdlU2l6ZT10aGlzLnBhZ2VCcmVha3NWaXNpYmxlPXRoaXMucGFnZVZpc2libGU7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInZpZXdTdGF0ZUNoYW5nZWQiLAoic3RhdGUiLGEpKX07CkdyYXBoLnByb3RvdHlwZS5hZGRFeHRGb250PWZ1bmN0aW9uKGEsYyxmKXtpZihhJiZjKXt2YXIgZD0iZXh0Rm9udF8iK2E7aWYobnVsbD09ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZCkpaWYoMD09Yy5pbmRleE9mKEVkaXRvci5HT09HTEVfRk9OVFMpKW14Q2xpZW50LmxpbmsoInN0eWxlc2hlZXQiLGMsbnVsbCxkKTtlbHNle2RvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJoZWFkIik7dmFyIG09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3R5bGUiKTttLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdAZm9udC1mYWNlIHtcblx0Zm9udC1mYW1pbHk6ICInK2ErJyI7XG5cdHNyYzogdXJsKCInK2MrJyIpO1xufScpKTttLnNldEF0dHJpYnV0ZSgiaWQiLGQpO2RvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJoZWFkIilbMF0uYXBwZW5kQ2hpbGQobSl9aWYoIWYpe251bGw9PXRoaXMuZXh0Rm9udHMmJih0aGlzLmV4dEZvbnRzPVtdKTtmPXRoaXMuZXh0Rm9udHM7CmQ9ITA7Zm9yKG09MDttPGYubGVuZ3RoO20rKylpZihmW21dLm5hbWU9PWEpe2Q9ITE7YnJlYWt9ZCYmdGhpcy5leHRGb250cy5wdXNoKHtuYW1lOmEsdXJsOmN9KX19fTsKRWRpdG9yVWkucHJvdG90eXBlLnVwZGF0ZVBhZ2VSb290PWZ1bmN0aW9uKGEsYyl7aWYobnVsbD09YS5yb290KXt2YXIgZj10aGlzLmVkaXRvci5leHRyYWN0R3JhcGhNb2RlbChhLm5vZGUsbnVsbCxjKSxkPUVkaXRvci5leHRyYWN0UGFyc2VyRXJyb3IoZik7aWYoZCl0aHJvdyBFcnJvcihkKTtudWxsIT1mPyhhLmdyYXBoTW9kZWxOb2RlPWYsYS52aWV3U3RhdGU9dGhpcy5lZGl0b3IuZ3JhcGguY3JlYXRlVmlld1N0YXRlKGYpLGQ9bmV3IG14Q29kZWMoZi5vd25lckRvY3VtZW50KSxhLnJvb3Q9ZC5kZWNvZGUoZikucm9vdCk6YS5yb290PXRoaXMuZWRpdG9yLmdyYXBoLm1vZGVsLmNyZWF0ZVJvb3QoKX1lbHNlIGlmKG51bGw9PWEudmlld1N0YXRlKXtpZihudWxsPT1hLmdyYXBoTW9kZWxOb2RlKXtmPXRoaXMuZWRpdG9yLmV4dHJhY3RHcmFwaE1vZGVsKGEubm9kZSk7aWYoZD1FZGl0b3IuZXh0cmFjdFBhcnNlckVycm9yKGYpKXRocm93IEVycm9yKGQpO251bGwhPWYmJihhLmdyYXBoTW9kZWxOb2RlPQpmKX1udWxsIT1hLmdyYXBoTW9kZWxOb2RlJiYoYS52aWV3U3RhdGU9dGhpcy5lZGl0b3IuZ3JhcGguY3JlYXRlVmlld1N0YXRlKGEuZ3JhcGhNb2RlbE5vZGUpKX1yZXR1cm4gYX07CkVkaXRvclVpLnByb3RvdHlwZS5zZWxlY3RQYWdlPWZ1bmN0aW9uKGEsYyxmKXt0cnl7aWYoYSE9dGhpcy5jdXJyZW50UGFnZSl7dGhpcy5lZGl0b3IuZ3JhcGguaXNFZGl0aW5nKCkmJnRoaXMuZWRpdG9yLmdyYXBoLnN0b3BFZGl0aW5nKCExKTtjPW51bGwhPWM/YzohMTt0aGlzLmVkaXRvci5ncmFwaC5pc01vdXNlRG93bj0hMTt0aGlzLmVkaXRvci5ncmFwaC5yZXNldCgpO3ZhciBkPXRoaXMuZWRpdG9yLmdyYXBoLm1vZGVsLmNyZWF0ZVVuZG9hYmxlRWRpdCgpO2QuaWdub3JlRWRpdD0hMDt2YXIgbT1uZXcgU2VsZWN0UGFnZSh0aGlzLGEsZik7bS5leGVjdXRlKCk7ZC5hZGQobSk7ZC5ub3RpZnkoKTt0aGlzLmVkaXRvci5ncmFwaC50b29sdGlwSGFuZGxlci5oaWRlKCk7Y3x8dGhpcy5lZGl0b3IuZ3JhcGgubW9kZWwuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuVU5ETywiZWRpdCIsZCkpfX1jYXRjaChrKXt0aGlzLmhhbmRsZUVycm9yKGspfX07CkVkaXRvclVpLnByb3RvdHlwZS5zZWxlY3ROZXh0UGFnZT1mdW5jdGlvbihhKXt2YXIgYz10aGlzLmN1cnJlbnRQYWdlO251bGwhPWMmJm51bGwhPXRoaXMucGFnZXMmJihjPW14VXRpbHMuaW5kZXhPZih0aGlzLnBhZ2VzLGMpLGE/dGhpcy5zZWxlY3RQYWdlKHRoaXMucGFnZXNbbXhVdGlscy5tb2QoYysxLHRoaXMucGFnZXMubGVuZ3RoKV0pOmF8fHRoaXMuc2VsZWN0UGFnZSh0aGlzLnBhZ2VzW214VXRpbHMubW9kKGMtMSx0aGlzLnBhZ2VzLmxlbmd0aCldKSl9OwpFZGl0b3JVaS5wcm90b3R5cGUuaW5zZXJ0UGFnZT1mdW5jdGlvbihhLGMpe2lmKHRoaXMuZWRpdG9yLmdyYXBoLmlzRW5hYmxlZCgpKXt0aGlzLmVkaXRvci5ncmFwaC5pc0VkaXRpbmcoKSYmdGhpcy5lZGl0b3IuZ3JhcGguc3RvcEVkaXRpbmcoITEpO2E9bnVsbCE9YT9hOnRoaXMuY3JlYXRlUGFnZShudWxsLHRoaXMuY3JlYXRlUGFnZUlkKCkpO2M9bnVsbCE9Yz9jOnRoaXMucGFnZXMubGVuZ3RoO3ZhciBmPW5ldyBDaGFuZ2VQYWdlKHRoaXMsYSxhLGMpO3RoaXMuZWRpdG9yLmdyYXBoLm1vZGVsLmV4ZWN1dGUoZil9cmV0dXJuIGF9O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVQYWdlSWQ9ZnVuY3Rpb24oKXt2YXIgYTtkbyBhPUVkaXRvci5ndWlkKCk7d2hpbGUobnVsbCE9dGhpcy5nZXRQYWdlQnlJZChhKSk7cmV0dXJuIGF9OwpFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlUGFnZT1mdW5jdGlvbihhLGMpe3ZhciBmPW5ldyBEaWFncmFtUGFnZSh0aGlzLmZpbGVOb2RlLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGlhZ3JhbSIpLGMpO2Yuc2V0TmFtZShudWxsIT1hP2E6dGhpcy5jcmVhdGVQYWdlTmFtZSgpKTtyZXR1cm4gZn07RWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZVBhZ2VOYW1lPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPXt9LGM9MDtjPHRoaXMucGFnZXMubGVuZ3RoO2MrKyl7dmFyIGY9dGhpcy5wYWdlc1tjXS5nZXROYW1lKCk7bnVsbCE9ZiYmMDxmLmxlbmd0aCYmKGFbZl09Zil9Yz10aGlzLnBhZ2VzLmxlbmd0aDtkbyBmPW14UmVzb3VyY2VzLmdldCgicGFnZVdpdGhOdW1iZXIiLFsrK2NdKTt3aGlsZShudWxsIT1hW2ZdKTtyZXR1cm4gZn07CkVkaXRvclVpLnByb3RvdHlwZS5yZW1vdmVQYWdlPWZ1bmN0aW9uKGEpe3RyeXt2YXIgYz10aGlzLmVkaXRvci5ncmFwaCxmPW14VXRpbHMuaW5kZXhPZih0aGlzLnBhZ2VzLGEpO2lmKGMuaXNFbmFibGVkKCkmJjA8PWYpe3RoaXMuZWRpdG9yLmdyYXBoLmlzRWRpdGluZygpJiZ0aGlzLmVkaXRvci5ncmFwaC5zdG9wRWRpdGluZyghMSk7Yy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgZD10aGlzLmN1cnJlbnRQYWdlO2Q9PWEmJjE8dGhpcy5wYWdlcy5sZW5ndGg/KGY9PXRoaXMucGFnZXMubGVuZ3RoLTE/Zi0tOmYrKyxkPXRoaXMucGFnZXNbZl0pOjE+PXRoaXMucGFnZXMubGVuZ3RoJiYoZD10aGlzLmluc2VydFBhZ2UoKSxjLm1vZGVsLmV4ZWN1dGUobmV3IFJlbmFtZVBhZ2UodGhpcyxkLG14UmVzb3VyY2VzLmdldCgicGFnZVdpdGhOdW1iZXIiLFsxXSkpKSk7Yy5tb2RlbC5leGVjdXRlKG5ldyBDaGFuZ2VQYWdlKHRoaXMsYSxkKSl9ZmluYWxseXtjLm1vZGVsLmVuZFVwZGF0ZSgpfX19Y2F0Y2gobSl7dGhpcy5oYW5kbGVFcnJvcihtKX1yZXR1cm4gYX07CkVkaXRvclVpLnByb3RvdHlwZS5kdXBsaWNhdGVQYWdlPWZ1bmN0aW9uKGEsYyl7dmFyIGY9bnVsbDt0cnl7dmFyIGQ9dGhpcy5lZGl0b3IuZ3JhcGg7aWYoZC5pc0VuYWJsZWQoKSl7ZC5pc0VkaXRpbmcoKSYmZC5zdG9wRWRpdGluZygpO3ZhciBtPWEubm9kZS5jbG9uZU5vZGUoITEpO20ucmVtb3ZlQXR0cmlidXRlKCJpZCIpO2Y9bmV3IERpYWdyYW1QYWdlKG0pO2Yucm9vdD1kLmNsb25lQ2VsbChkLm1vZGVsLnJvb3QpO2Yudmlld1N0YXRlPWQuZ2V0Vmlld1N0YXRlKCk7Zi52aWV3U3RhdGUuc2NhbGU9MTtmLnZpZXdTdGF0ZS5zY3JvbGxMZWZ0PW51bGw7Zi52aWV3U3RhdGUuc2Nyb2xsVG9wPW51bGw7Zi52aWV3U3RhdGUuY3VycmVudFJvb3Q9bnVsbDtmLnZpZXdTdGF0ZS5kZWZhdWx0UGFyZW50PW51bGw7Zi5zZXROYW1lKGMpO2Y9dGhpcy5pbnNlcnRQYWdlKGYsbXhVdGlscy5pbmRleE9mKHRoaXMucGFnZXMsYSkrMSl9fWNhdGNoKGspe3RoaXMuaGFuZGxlRXJyb3Ioayl9cmV0dXJuIGZ9OwpFZGl0b3JVaS5wcm90b3R5cGUucmVuYW1lUGFnZT1mdW5jdGlvbihhKXtpZih0aGlzLmVkaXRvci5ncmFwaC5pc0VuYWJsZWQoKSl7dmFyIGM9bmV3IEZpbGVuYW1lRGlhbG9nKHRoaXMsYS5nZXROYW1lKCksbXhSZXNvdXJjZXMuZ2V0KCJyZW5hbWUiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihjKXtudWxsIT1jJiYwPGMubGVuZ3RoJiZ0aGlzLmVkaXRvci5ncmFwaC5tb2RlbC5leGVjdXRlKG5ldyBSZW5hbWVQYWdlKHRoaXMsYSxjKSl9KSxteFJlc291cmNlcy5nZXQoInJlbmFtZSIpKTt0aGlzLnNob3dEaWFsb2coYy5jb250YWluZXIsMzAwLDgwLCEwLCEwKTtjLmluaXQoKX1yZXR1cm4gYX07RWRpdG9yVWkucHJvdG90eXBlLm1vdmVQYWdlPWZ1bmN0aW9uKGEsYyl7dGhpcy5lZGl0b3IuZ3JhcGgubW9kZWwuZXhlY3V0ZShuZXcgTW92ZVBhZ2UodGhpcyxhLGMpKX07CkVkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVUYWJDb250YWluZXI9ZnVuY3Rpb24oKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTthLmNsYXNzTmFtZT0iZ2VUYWJDb250YWluZXIiO2Euc3R5bGUucG9zaXRpb249ImFic29sdXRlIjthLnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCI7YS5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjthLnN0eWxlLmhlaWdodD0iMHB4IjtyZXR1cm4gYX07CkVkaXRvclVpLnByb3RvdHlwZS51cGRhdGVUYWJDb250YWluZXI9ZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLnRhYkNvbnRhaW5lciYmbnVsbCE9dGhpcy5wYWdlcyl7dmFyIGE9dGhpcy5lZGl0b3IuZ3JhcGgsYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtjLnN0eWxlLnBvc2l0aW9uPSJyZWxhdGl2ZSI7Yy5zdHlsZS5kaXNwbGF5PW14Q2xpZW50LklTX1FVSVJLUz8iaW5saW5lIjoiaW5saW5lLWJsb2NrIjtjLnN0eWxlLnZlcnRpY2FsQWxpZ249InRvcCI7Yy5zdHlsZS5oZWlnaHQ9dGhpcy50YWJDb250YWluZXIuc3R5bGUuaGVpZ2h0O2Muc3R5bGUud2hpdGVTcGFjZT0ibm93cmFwIjtjLnN0eWxlLm92ZXJmbG93PSJoaWRkZW4iO2Muc3R5bGUuZm9udFNpemU9IjEzcHgiO2Muc3R5bGUubWFyZ2luTGVmdD0iMzBweCI7Zm9yKHZhciBmPXRoaXMuZWRpdG9yLmlzQ2hyb21lbGVzc1ZpZXcoKT8yOTo1OSxkPU1hdGgubWluKDE0MCxNYXRoLm1heCgyMCwodGhpcy50YWJDb250YWluZXIuY2xpZW50V2lkdGgtCmYpL3RoaXMucGFnZXMubGVuZ3RoKSsxKSxtPW51bGwsaz0wO2s8dGhpcy5wYWdlcy5sZW5ndGg7aysrKW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIsZCl7dGhpcy5wYWdlc1tiXT09dGhpcy5jdXJyZW50UGFnZT8oZC5jbGFzc05hbWU9ImdlQWN0aXZlUGFnZSIsZC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9ImRhcmsiPT11aVRoZW1lPyIjMmEyYTJhIjoiI2ZmZiIpOmQuY2xhc3NOYW1lPSJnZUluYWN0aXZlUGFnZSI7ZC5zZXRBdHRyaWJ1dGUoImRyYWdnYWJsZSIsInRydWUiKTtteEV2ZW50LmFkZExpc3RlbmVyKGQsImRyYWdzdGFydCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYyl7YS5pc0VuYWJsZWQoKT8obXhDbGllbnQuSVNfRkYmJmMuZGF0YVRyYW5zZmVyLnNldERhdGEoIlRleHQiLCI8ZGlhZ3JhbS8+IiksbT1iKTpteEV2ZW50LmNvbnN1bWUoYyl9KSk7bXhFdmVudC5hZGRMaXN0ZW5lcihkLCJkcmFnZW5kIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXttPQpudWxsO2Euc3RvcFByb3BhZ2F0aW9uKCk7YS5wcmV2ZW50RGVmYXVsdCgpfSkpO214RXZlbnQuYWRkTGlzdGVuZXIoZCwiZHJhZ292ZXIiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe251bGwhPW0mJihhLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0PSJtb3ZlIik7YS5zdG9wUHJvcGFnYXRpb24oKTthLnByZXZlbnREZWZhdWx0KCl9KSk7bXhFdmVudC5hZGRMaXN0ZW5lcihkLCJkcm9wIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsIT1tJiZiIT1tJiZ0aGlzLm1vdmVQYWdlKG0sYik7YS5zdG9wUHJvcGFnYXRpb24oKTthLnByZXZlbnREZWZhdWx0KCl9KSk7Yy5hcHBlbmRDaGlsZChkKX0pKGssdGhpcy5jcmVhdGVUYWJGb3JQYWdlKHRoaXMucGFnZXNba10sZCx0aGlzLnBhZ2VzW2tdIT10aGlzLmN1cnJlbnRQYWdlLGsrMSkpO3RoaXMudGFiQ29udGFpbmVyLmlubmVySFRNTD0iIjt0aGlzLnRhYkNvbnRhaW5lci5hcHBlbmRDaGlsZChjKTtkPXRoaXMuY3JlYXRlUGFnZU1lbnVUYWIoKTsKdGhpcy50YWJDb250YWluZXIuYXBwZW5kQ2hpbGQoZCk7ZD1udWxsO3RoaXMuaXNQYWdlSW5zZXJ0VGFiVmlzaWJsZSgpJiYoZD10aGlzLmNyZWF0ZVBhZ2VJbnNlcnRUYWIoKSx0aGlzLnRhYkNvbnRhaW5lci5hcHBlbmRDaGlsZChkKSk7aWYoYy5jbGllbnRXaWR0aD50aGlzLnRhYkNvbnRhaW5lci5jbGllbnRXaWR0aC1mKXtudWxsIT1kJiYoZC5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiLGQuc3R5bGUucmlnaHQ9IjBweCIsYy5zdHlsZS5tYXJnaW5SaWdodD0iMzBweCIpO3ZhciBxPXRoaXMuY3JlYXRlQ29udHJvbFRhYig0LCImbmJzcDsmIzEwMDk0OyZuYnNwOyIpO3Euc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtxLnN0eWxlLnJpZ2h0PXRoaXMuZWRpdG9yLmNocm9tZWxlc3M/IjI5cHgiOiI1NXB4IjtxLnN0eWxlLmZvbnRTaXplPSIxM3B0Ijt0aGlzLnRhYkNvbnRhaW5lci5hcHBlbmRDaGlsZChxKTt2YXIgYj10aGlzLmNyZWF0ZUNvbnRyb2xUYWIoNCwiJm5ic3A7JiMxMDA5NTsiKTsKYi5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO2Iuc3R5bGUucmlnaHQ9dGhpcy5lZGl0b3IuY2hyb21lbGVzcz8iMHB4IjoiMjlweCI7Yi5zdHlsZS5mb250U2l6ZT0iMTNwdCI7dGhpcy50YWJDb250YWluZXIuYXBwZW5kQ2hpbGQoYik7dmFyIGU9TWF0aC5tYXgoMCx0aGlzLnRhYkNvbnRhaW5lci5jbGllbnRXaWR0aC0odGhpcy5lZGl0b3IuY2hyb21lbGVzcz84NjoxMTYpKTtjLnN0eWxlLndpZHRoPWUrInB4IjtteEV2ZW50LmFkZExpc3RlbmVyKHEsImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtjLnNjcm9sbExlZnQtPU1hdGgubWF4KDIwLGUtMjApO214VXRpbHMuc2V0T3BhY2l0eShxLDA8Yy5zY3JvbGxMZWZ0PzEwMDo1MCk7bXhVdGlscy5zZXRPcGFjaXR5KGIsYy5zY3JvbGxMZWZ0PGMuc2Nyb2xsV2lkdGgtYy5jbGllbnRXaWR0aD8xMDA6NTApO214RXZlbnQuY29uc3VtZShhKX0pKTtteFV0aWxzLnNldE9wYWNpdHkocSwwPGMuc2Nyb2xsTGVmdD8xMDA6CjUwKTtteFV0aWxzLnNldE9wYWNpdHkoYixjLnNjcm9sbExlZnQ8Yy5zY3JvbGxXaWR0aC1jLmNsaWVudFdpZHRoPzEwMDo1MCk7bXhFdmVudC5hZGRMaXN0ZW5lcihiLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7Yy5zY3JvbGxMZWZ0Kz1NYXRoLm1heCgyMCxlLTIwKTtteFV0aWxzLnNldE9wYWNpdHkocSwwPGMuc2Nyb2xsTGVmdD8xMDA6NTApO214VXRpbHMuc2V0T3BhY2l0eShiLGMuc2Nyb2xsTGVmdDxjLnNjcm9sbFdpZHRoLWMuY2xpZW50V2lkdGg/MTAwOjUwKTtteEV2ZW50LmNvbnN1bWUoYSl9KSl9fX07RWRpdG9yVWkucHJvdG90eXBlLmlzUGFnZUluc2VydFRhYlZpc2libGU9ZnVuY3Rpb24oKXtyZXR1cm4gMT09dXJsUGFyYW1zLmVtYmVkfHxudWxsIT10aGlzLmdldEN1cnJlbnRGaWxlKCkmJnRoaXMuZ2V0Q3VycmVudEZpbGUoKS5pc0VkaXRhYmxlKCl9OwpFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlVGFiPWZ1bmN0aW9uKGEpe3ZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Muc3R5bGUuZGlzcGxheT1teENsaWVudC5JU19RVUlSS1M/ImlubGluZSI6ImlubGluZS1ibG9jayI7Yy5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiO2Muc3R5bGUuYm94U2l6aW5nPSJib3JkZXItYm94IjtjLnN0eWxlLnBvc2l0aW9uPSJyZWxhdGl2ZSI7Yy5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjtjLnN0eWxlLnRleHRBbGlnbj0iY2VudGVyIjtjLnN0eWxlLm1hcmdpbkxlZnQ9Ii0xcHgiO2Muc3R5bGUuaGVpZ2h0PXRoaXMudGFiQ29udGFpbmVyLmNsaWVudEhlaWdodCsicHgiO2Muc3R5bGUucGFkZGluZz0iMTJweCA0cHggOHB4IDRweCI7Yy5zdHlsZS5ib3JkZXI9ImRhcmsiPT11aVRoZW1lPyIxcHggc29saWQgIzUwNTc1OSI6IjFweCBzb2xpZCAjZThlYWVkIjtjLnN0eWxlLmJvcmRlclRvcFN0eWxlPSJub25lIjtjLnN0eWxlLmJvcmRlckJvdHRvbVN0eWxlPQoibm9uZSI7Yy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9dGhpcy50YWJDb250YWluZXIuc3R5bGUuYmFja2dyb3VuZENvbG9yO2Muc3R5bGUuY3Vyc29yPSJtb3ZlIjtjLnN0eWxlLmNvbG9yPSJncmF5IjthJiYobXhFdmVudC5hZGRMaXN0ZW5lcihjLCJtb3VzZWVudGVyIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmVkaXRvci5ncmFwaC5pc01vdXNlRG93bnx8KGMuc3R5bGUuYmFja2dyb3VuZENvbG9yPSJkYXJrIj09dWlUaGVtZT8iYmxhY2siOiIjZThlYWVkIixteEV2ZW50LmNvbnN1bWUoYSkpfSkpLG14RXZlbnQuYWRkTGlzdGVuZXIoYywibW91c2VsZWF2ZSIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7Yy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9dGhpcy50YWJDb250YWluZXIuc3R5bGUuYmFja2dyb3VuZENvbG9yO214RXZlbnQuY29uc3VtZShhKX0pKSk7cmV0dXJuIGN9OwpFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlQ29udHJvbFRhYj1mdW5jdGlvbihhLGMpe3ZhciBmPXRoaXMuY3JlYXRlVGFiKCEwKTtmLnN0eWxlLmxpbmVIZWlnaHQ9dGhpcy50YWJDb250YWluZXJIZWlnaHQrInB4IjtmLnN0eWxlLnBhZGRpbmdUb3A9YSsicHgiO2Yuc3R5bGUuY3Vyc29yPSJwb2ludGVyIjtmLnN0eWxlLndpZHRoPSIzMHB4IjtmLmlubmVySFRNTD1jO251bGwhPWYuZmlyc3RDaGlsZCYmbnVsbCE9Zi5maXJzdENoaWxkLnN0eWxlJiZteFV0aWxzLnNldE9wYWNpdHkoZi5maXJzdENoaWxkLDQwKTtyZXR1cm4gZn07CkVkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVQYWdlTWVudVRhYj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuY3JlYXRlQ29udHJvbFRhYigzLCc8ZGl2IGNsYXNzPSJnZVNwcml0ZSBnZVNwcml0ZS1kb3RzIiBzdHlsZT0iZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luLXRvcDo1cHg7d2lkdGg6MjFweDtoZWlnaHQ6MjFweDsiPjwvZGl2PicpO2Euc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJwYWdlcyIpKTthLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7YS5zdHlsZS5tYXJnaW5MZWZ0PSIwcHgiO2Euc3R5bGUudG9wPSIwcHgiO2Euc3R5bGUubGVmdD0iMXB4IjtteEV2ZW50LmFkZExpc3RlbmVyKGEsImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmVkaXRvci5ncmFwaC5wb3B1cE1lbnVIYW5kbGVyLmhpZGVNZW51KCk7dmFyIGM9bmV3IG14UG9wdXBNZW51KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7Zm9yKHZhciBiPQowO2I8dGhpcy5wYWdlcy5sZW5ndGg7YisrKW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3ZhciBkPWEuYWRkSXRlbSh0aGlzLnBhZ2VzW2JdLmdldE5hbWUoKSxudWxsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5zZWxlY3RQYWdlKHRoaXMucGFnZXNbYl0pfSksYyk7dGhpcy5wYWdlc1tiXT09dGhpcy5jdXJyZW50UGFnZSYmYS5hZGRDaGVja21hcmsoZCxFZGl0b3IuY2hlY2ttYXJrSW1hZ2UpfSkoYik7aWYodGhpcy5lZGl0b3IuZ3JhcGguaXNFbmFibGVkKCkpe2EuYWRkU2VwYXJhdG9yKGMpO2EuYWRkSXRlbShteFJlc291cmNlcy5nZXQoImluc2VydFBhZ2UiKSxudWxsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5pbnNlcnRQYWdlKCl9KSxjKTt2YXIgZD10aGlzLmN1cnJlbnRQYWdlO251bGwhPWQmJihhLmFkZFNlcGFyYXRvcihjKSxhLmFkZEl0ZW0obXhSZXNvdXJjZXMuZ2V0KCJkZWxldGUiKSxudWxsLG14VXRpbHMuYmluZCh0aGlzLApmdW5jdGlvbigpe3RoaXMucmVtb3ZlUGFnZShkKX0pLGMpLGEuYWRkSXRlbShteFJlc291cmNlcy5nZXQoInJlbmFtZSIpLG51bGwsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnJlbmFtZVBhZ2UoZCxkLmdldE5hbWUoKSl9KSxjKSxhLmFkZFNlcGFyYXRvcihjKSxhLmFkZEl0ZW0obXhSZXNvdXJjZXMuZ2V0KCJkdXBsaWNhdGUiKSxudWxsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5kdXBsaWNhdGVQYWdlKGQsbXhSZXNvdXJjZXMuZ2V0KCJjb3B5T2YiLFtkLmdldE5hbWUoKV0pKX0pLGMpKX19KSk7Yy5kaXYuY2xhc3NOYW1lKz0iIGdlTWVudWJhck1lbnUiO2Muc21hcnRTZXBhcmF0b3JzPSEwO2Muc2hvd0Rpc2FibGVkPSEwO2MuYXV0b0V4cGFuZD0hMDtjLmhpZGVNZW51PW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bXhQb3B1cE1lbnUucHJvdG90eXBlLmhpZGVNZW51LmFwcGx5KGMsYXJndW1lbnRzKTtjLmRlc3Ryb3koKX0pO3ZhciBkPQpteEV2ZW50LmdldENsaWVudFgoYSksbT1teEV2ZW50LmdldENsaWVudFkoYSk7Yy5wb3B1cChkLG0sbnVsbCxhKTt0aGlzLnNldEN1cnJlbnRNZW51KGMpO214RXZlbnQuY29uc3VtZShhKX0pKTtyZXR1cm4gYX07RWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZVBhZ2VJbnNlcnRUYWI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNyZWF0ZUNvbnRyb2xUYWIoNCwnPGRpdiBjbGFzcz0iZ2VTcHJpdGUgZ2VTcHJpdGUtcGx1cyIgc3R5bGU9ImRpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOjIxcHg7aGVpZ2h0OjIxcHg7Ij48L2Rpdj4nKTthLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgiaW5zZXJ0UGFnZSIpKTtteEV2ZW50LmFkZExpc3RlbmVyKGEsImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmluc2VydFBhZ2UoKTtteEV2ZW50LmNvbnN1bWUoYSl9KSk7cmV0dXJuIGF9OwpFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlVGFiRm9yUGFnZT1mdW5jdGlvbihhLGMsZixkKXtmPXRoaXMuY3JlYXRlVGFiKGYpO3ZhciBtPWEuZ2V0TmFtZSgpfHxteFJlc291cmNlcy5nZXQoInVudGl0bGVkIiksaz1hLmdldElkKCk7Zi5zZXRBdHRyaWJ1dGUoInRpdGxlIixtKyhudWxsIT1rPyIgKCIraysiKSI6IiIpKyIgWyIrZCsiXSIpO214VXRpbHMud3JpdGUoZixtKTtmLnN0eWxlLm1heFdpZHRoPWMrInB4IjtmLnN0eWxlLndpZHRoPWMrInB4Ijt0aGlzLmFkZFRhYkxpc3RlbmVycyhhLGYpOzQyPGMmJihmLnN0eWxlLnRleHRPdmVyZmxvdz0iZWxsaXBzaXMiKTtyZXR1cm4gZn07CkVkaXRvclVpLnByb3RvdHlwZS5hZGRUYWJMaXN0ZW5lcnM9ZnVuY3Rpb24oYSxjKXtteEV2ZW50LmRpc2FibGVDb250ZXh0TWVudShjKTt2YXIgZj10aGlzLmVkaXRvci5ncmFwaDtteEV2ZW50LmFkZExpc3RlbmVyKGMsImRibGNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihjKXt0aGlzLnJlbmFtZVBhZ2UoYSk7bXhFdmVudC5jb25zdW1lKGMpfSkpO3ZhciBkPSExLG09ITE7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKGMsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYyl7ZD1udWxsIT10aGlzLmN1cnJlbnRNZW51O209YT09dGhpcy5jdXJyZW50UGFnZTtmLmlzTW91c2VEb3dufHxtfHx0aGlzLnNlbGVjdFBhZ2UoYSl9KSxudWxsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGspe2lmKGYuaXNFbmFibGVkKCkmJiFmLmlzTW91c2VEb3duJiYobXhFdmVudC5pc1RvdWNoRXZlbnQoaykmJm18fG14RXZlbnQuaXNQb3B1cFRyaWdnZXIoaykpKXtmLnBvcHVwTWVudUhhbmRsZXIuaGlkZU1lbnUoKTsKdGhpcy5oaWRlQ3VycmVudE1lbnUoKTtpZighbXhFdmVudC5pc1RvdWNoRXZlbnQoayl8fCFkKXt2YXIgcT1uZXcgbXhQb3B1cE1lbnUodGhpcy5jcmVhdGVQYWdlTWVudShhKSk7cS5kaXYuY2xhc3NOYW1lKz0iIGdlTWVudWJhck1lbnUiO3Euc21hcnRTZXBhcmF0b3JzPSEwO3Euc2hvd0Rpc2FibGVkPSEwO3EuYXV0b0V4cGFuZD0hMDtxLmhpZGVNZW51PW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bXhQb3B1cE1lbnUucHJvdG90eXBlLmhpZGVNZW51LmFwcGx5KHEsYXJndW1lbnRzKTt0aGlzLnJlc2V0Q3VycmVudE1lbnUoKTtxLmRlc3Ryb3koKX0pO3ZhciBiPW14RXZlbnQuZ2V0Q2xpZW50WChrKSxlPW14RXZlbnQuZ2V0Q2xpZW50WShrKTtxLnBvcHVwKGIsZSxudWxsLGspO3RoaXMuc2V0Q3VycmVudE1lbnUocSxjKX1teEV2ZW50LmNvbnN1bWUoayl9fSkpfTsKRWRpdG9yVWkucHJvdG90eXBlLmdldExpbmtGb3JQYWdlPWZ1bmN0aW9uKGEpe2lmKCFteENsaWVudC5JU19DSFJPTUVBUFAmJiFFZGl0b3JVaS5pc0VsZWN0cm9uQXBwKXt2YXIgYz10aGlzLmdldEN1cnJlbnRGaWxlKCk7aWYobnVsbCE9YyYmYy5jb25zdHJ1Y3RvciE9TG9jYWxGaWxlJiYiZHJhdy5pbyI9PXRoaXMuZ2V0U2VydmljZU5hbWUoKSl7dmFyIGY9dGhpcy5nZXRTZWFyY2goImNyZWF0ZSB0aXRsZSBtb2RlIHVybCBkcml2ZSBzcGxhc2ggc3RhdGUgY2xpYnMgdWkiLnNwbGl0KCIgIikpLGY9ZisoKDA9PWYubGVuZ3RoPyI/IjoiJiIpKyJwYWdlLWlkPSIrYS5nZXRJZCgpKTtyZXR1cm4gd2luZG93LmxvY2F0aW9uLnByb3RvY29sKyIvLyIrd2luZG93LmxvY2F0aW9uLmhvc3QrIi8iK2YrIiMiK2MuZ2V0SGFzaCgpfX1yZXR1cm4gbnVsbH07CkVkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVQYWdlTWVudT1mdW5jdGlvbihhLGMpe3JldHVybiBteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihmLGQpe2YuYWRkSXRlbShteFJlc291cmNlcy5nZXQoImluc2VydCIpLG51bGwsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmluc2VydFBhZ2UobnVsbCxteFV0aWxzLmluZGV4T2YodGhpcy5wYWdlcyxhKSsxKX0pLGQpO2YuYWRkSXRlbShteFJlc291cmNlcy5nZXQoImRlbGV0ZSIpLG51bGwsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnJlbW92ZVBhZ2UoYSl9KSxkKTtmLmFkZEl0ZW0obXhSZXNvdXJjZXMuZ2V0KCJyZW5hbWUiKSxudWxsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5yZW5hbWVQYWdlKGEsYyl9KSxkKTt2YXIgbT10aGlzLmdldExpbmtGb3JQYWdlKGEpO251bGwhPW0mJihmLmFkZFNlcGFyYXRvcihkKSxmLmFkZEl0ZW0obXhSZXNvdXJjZXMuZ2V0KCJsaW5rIiksbnVsbCwKbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt2YXIgYT1uZXcgRW1iZWREaWFsb2codGhpcyxtKTt0aGlzLnNob3dEaWFsb2coYS5jb250YWluZXIsNDQwLDI0MCwhMCwhMCk7YS5pbml0KCl9KSxkKSk7Zi5hZGRTZXBhcmF0b3IoZCk7Zi5hZGRJdGVtKG14UmVzb3VyY2VzLmdldCgiZHVwbGljYXRlIiksbnVsbCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuZHVwbGljYXRlUGFnZShhLG14UmVzb3VyY2VzLmdldCgiY29weU9mIixbYS5nZXROYW1lKCldKSl9KSxkKTtteENsaWVudC5JU19DSFJPTUVBUFB8fEVkaXRvclVpLmlzRWxlY3Ryb25BcHB8fCJkcmF3LmlvIiE9dGhpcy5nZXRTZXJ2aWNlTmFtZSgpfHwoZi5hZGRTZXBhcmF0b3IoZCksZi5hZGRJdGVtKG14UmVzb3VyY2VzLmdldCgib3BlbkluTmV3V2luZG93IiksbnVsbCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuZWRpdG9yLmVkaXRBc05ldyh0aGlzLmdldEZpbGVEYXRhKCEwLG51bGwsCm51bGwsbnVsbCwhMCwhMCkpfSksZCkpfSl9OyhmdW5jdGlvbigpe3ZhciBhPUVkaXRvclVpLnByb3RvdHlwZS5yZWZyZXNoO0VkaXRvclVpLnByb3RvdHlwZS5yZWZyZXNoPWZ1bmN0aW9uKGMpe2EuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMudXBkYXRlVGFiQ29udGFpbmVyKCl9fSkoKTsoZnVuY3Rpb24oKXtteENvZGVjUmVnaXN0cnkuZ2V0Q29kZWMoQ2hhbmdlUGFnZVNldHVwKS5leGNsdWRlLnB1c2goInBhZ2UiKX0pKCk7KGZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14T2JqZWN0Q29kZWMobmV3IE1vdmVQYWdlLFsidWkiXSk7YS5iZWZvcmVEZWNvZGU9ZnVuY3Rpb24oYSxmLGQpe2QudWk9YS51aTtyZXR1cm4gZn07YS5hZnRlckRlY29kZT1mdW5jdGlvbihhLGYsZCl7YT1kLm9sZEluZGV4O2Qub2xkSW5kZXg9ZC5uZXdJbmRleDtkLm5ld0luZGV4PWE7cmV0dXJuIGR9O214Q29kZWNSZWdpc3RyeS5yZWdpc3RlcihhKX0pKCk7CihmdW5jdGlvbigpe3ZhciBhPW5ldyBteE9iamVjdENvZGVjKG5ldyBSZW5hbWVQYWdlLFsidWkiLCJwYWdlIl0pO2EuYmVmb3JlRGVjb2RlPWZ1bmN0aW9uKGEsZixkKXtkLnVpPWEudWk7cmV0dXJuIGZ9O2EuYWZ0ZXJEZWNvZGU9ZnVuY3Rpb24oYSxmLGQpe2E9ZC5wcmV2aW91cztkLnByZXZpb3VzPWQubmFtZTtkLm5hbWU9YTtyZXR1cm4gZH07bXhDb2RlY1JlZ2lzdHJ5LnJlZ2lzdGVyKGEpfSkoKTsKKGZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14T2JqZWN0Q29kZWMobmV3IENoYW5nZVBhZ2UsInVpIHJlbGF0ZWRQYWdlIGluZGV4IG5ldmVyU2hvd24gcGFnZSBwcmV2aW91c1BhZ2UiLnNwbGl0KCIgIikpLGM9ImRlZmF1bHRQYXJlbnQgY3VycmVudFJvb3Qgc2Nyb2xsTGVmdCBzY3JvbGxUb3Agc2NhbGUgdHJhbnNsYXRlIGxhc3RQYXN0ZVhtbCBwYXN0ZUNvdW50ZXIiLnNwbGl0KCIgIik7YS5hZnRlckVuY29kZT1mdW5jdGlvbihhLGQsbSl7bS5zZXRBdHRyaWJ1dGUoInJlbGF0ZWRQYWdlIixkLnJlbGF0ZWRQYWdlLmdldElkKCkpO251bGw9PWQuaW5kZXgmJihtLnNldEF0dHJpYnV0ZSgibmFtZSIsZC5yZWxhdGVkUGFnZS5nZXROYW1lKCkpLG51bGwhPWQucmVsYXRlZFBhZ2Uudmlld1N0YXRlJiZtLnNldEF0dHJpYnV0ZSgidmlld1N0YXRlIixKU09OLnN0cmluZ2lmeShkLnJlbGF0ZWRQYWdlLnZpZXdTdGF0ZSxmdW5jdGlvbihhLGQpe3JldHVybiAwPm14VXRpbHMuaW5kZXhPZihjLAphKT9kOnZvaWQgMH0pKSxudWxsIT1kLnJlbGF0ZWRQYWdlLnJvb3QmJmEuZW5jb2RlQ2VsbChkLnJlbGF0ZWRQYWdlLnJvb3QsbSkpO3JldHVybiBtfTthLmJlZm9yZURlY29kZT1mdW5jdGlvbihhLGMsbSl7bS51aT1hLnVpO20ucmVsYXRlZFBhZ2U9bS51aS5nZXRQYWdlQnlJZChjLmdldEF0dHJpYnV0ZSgicmVsYXRlZFBhZ2UiKSk7aWYobnVsbD09bS5yZWxhdGVkUGFnZSl7dmFyIGQ9Yy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpYWdyYW0iKTtkLnNldEF0dHJpYnV0ZSgiaWQiLGMuZ2V0QXR0cmlidXRlKCJyZWxhdGVkUGFnZSIpKTtkLnNldEF0dHJpYnV0ZSgibmFtZSIsYy5nZXRBdHRyaWJ1dGUoIm5hbWUiKSk7bS5yZWxhdGVkUGFnZT1uZXcgRGlhZ3JhbVBhZ2UoZCk7ZD1jLmdldEF0dHJpYnV0ZSgidmlld1N0YXRlIik7bnVsbCE9ZCYmKG0ucmVsYXRlZFBhZ2Uudmlld1N0YXRlPUpTT04ucGFyc2UoZCksYy5yZW1vdmVBdHRyaWJ1dGUoInZpZXdTdGF0ZSIpKTsKYz1jLmNsb25lTm9kZSghMCk7ZD1jLmZpcnN0Q2hpbGQ7aWYobnVsbCE9ZClmb3IobS5yZWxhdGVkUGFnZS5yb290PWEuZGVjb2RlQ2VsbChkLCExKSxtPWQubmV4dFNpYmxpbmcsZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGQpLGQ9bTtudWxsIT1kOyl7bT1kLm5leHRTaWJsaW5nO2lmKGQubm9kZVR5cGU9PW14Q29uc3RhbnRzLk5PREVUWVBFX0VMRU1FTlQpe3ZhciBmPWQuZ2V0QXR0cmlidXRlKCJpZCIpO251bGw9PWEubG9va3VwKGYpJiZhLmRlY29kZUNlbGwoZCl9ZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGQpO2Q9bX19cmV0dXJuIGN9O2EuYWZ0ZXJEZWNvZGU9ZnVuY3Rpb24oYSxjLG0pe20uaW5kZXg9bS5wcmV2aW91c0luZGV4O3JldHVybiBtfTtteENvZGVjUmVnaXN0cnkucmVnaXN0ZXIoYSl9KSgpOyhmdW5jdGlvbigpe0VkaXRvclVpLnByb3RvdHlwZS5hbHRTaGlmdEFjdGlvbnNbNjhdPSJzZWxlY3REZXNjZW5kYW50cyI7dmFyIGE9R3JhcGgucHJvdG90eXBlLmZvbGRDZWxscztHcmFwaC5wcm90b3R5cGUuZm9sZENlbGxzPWZ1bmN0aW9uKGMsZixrLHEsYil7Zj1udWxsIT1mP2Y6ITE7bnVsbD09ayYmKGs9dGhpcy5nZXRGb2xkYWJsZUNlbGxzKHRoaXMuZ2V0U2VsZWN0aW9uQ2VsbHMoKSxjKSk7dGhpcy5zdG9wRWRpdGluZygpO3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBkPWsuc2xpY2UoKSxnPVtdLG09MDttPGsubGVuZ3RoO20rKyl7dmFyIGw9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGtbbV0pOyIxIj09bXhVdGlscy5nZXRWYWx1ZShsLCJ0cmVlRm9sZGluZyIsIjAiKSYmKHRoaXMudHJhdmVyc2Uoa1ttXSwhMCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIpe251bGwhPWImJmcucHVzaChiKTthIT1rW21dJiZnLnB1c2goYSk7cmV0dXJuIGE9PQprW21dfHwhdGhpcy5tb2RlbC5pc0NvbGxhcHNlZChhKX0pKSx0aGlzLm1vZGVsLnNldENvbGxhcHNlZChrW21dLGMpKX1mb3IobT0wO208Zy5sZW5ndGg7bSsrKXRoaXMubW9kZWwuc2V0VmlzaWJsZShnW21dLCFjKTtrPWQ7az1hLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9cmV0dXJuIGt9O3ZhciBjPUVkaXRvclVpLnByb3RvdHlwZS5pbml0O0VkaXRvclVpLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7Yy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy5lZGl0b3IuaXNDaHJvbWVsZXNzVmlldygpJiYhdGhpcy5lZGl0b3IuZWRpdGFibGV8fHRoaXMuYWRkVHJlZXMoKX07RWRpdG9yVWkucHJvdG90eXBlLmFkZFRyZWVzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhKXtyZXR1cm4geS5pc1ZlcnRleChhKSYmZihhKX1mdW5jdGlvbiBjKGEpe3ZhciBiPSExO251bGwhPWEmJihiPSIxIj09dC5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpLnRyZWVNb3ZpbmcpOwpyZXR1cm4gYn1mdW5jdGlvbiBmKGEpe3ZhciBiPSExO251bGwhPWEmJihhPXkuZ2V0UGFyZW50KGEpLGI9dC52aWV3LmdldFN0YXRlKGEpLGI9InRyZWUiPT0obnVsbCE9Yj9iLnN0eWxlOnQuZ2V0Q2VsbFN0eWxlKGEpKS5jb250YWluZXJUeXBlKTtyZXR1cm4gYn1mdW5jdGlvbiBxKGEpe3ZhciBiPSExO251bGwhPWEmJihhPXkuZ2V0UGFyZW50KGEpLGI9dC52aWV3LmdldFN0YXRlKGEpLHQudmlldy5nZXRTdGF0ZShhKSxiPW51bGwhPShudWxsIT1iP2Iuc3R5bGU6dC5nZXRDZWxsU3R5bGUoYSkpLmNoaWxkTGF5b3V0KTtyZXR1cm4gYn1mdW5jdGlvbiBiKGEpe2E9dC52aWV3LmdldFN0YXRlKGEpO2lmKG51bGwhPWEpe3ZhciBiPXQuZ2V0SW5jb21pbmdFZGdlcyhhLmNlbGwpO2lmKDA8Yi5sZW5ndGgmJihiPXQudmlldy5nZXRTdGF0ZShiWzBdKSxudWxsIT1iJiYoYj1iLmFic29sdXRlUG9pbnRzLG51bGwhPWImJjA8Yi5sZW5ndGgmJihiPWJbYi5sZW5ndGgtMV0sbnVsbCE9YikpKSl7aWYoYi55PT0KYS55JiZNYXRoLmFicyhiLngtYS5nZXRDZW50ZXJYKCkpPGEud2lkdGgvMilyZXR1cm4gbXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIO2lmKGIueT09YS55K2EuaGVpZ2h0JiZNYXRoLmFicyhiLngtYS5nZXRDZW50ZXJYKCkpPGEud2lkdGgvMilyZXR1cm4gbXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIO2lmKGIueD5hLmdldENlbnRlclgoKSlyZXR1cm4gbXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1R9fXJldHVybiBteENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVH1mdW5jdGlvbiBlKGEsYyl7Yz1udWxsIT1jP2M6ITA7dC5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgZD10Lm1vZGVsLmdldFBhcmVudChhKSxlPXQuZ2V0SW5jb21pbmdFZGdlcyhhKSxmPXQuY2xvbmVDZWxscyhbZVswXSxhXSk7dC5tb2RlbC5zZXRUZXJtaW5hbChmWzBdLHQubW9kZWwuZ2V0VGVybWluYWwoZVswXSwhMCksITApO3ZhciBnPWIoYSksaz1kLmdlb21ldHJ5O2c9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSHx8Cmc9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSD9mWzFdLmdlb21ldHJ5LngrPWM/YS5nZW9tZXRyeS53aWR0aCsxMDotZlsxXS5nZW9tZXRyeS53aWR0aC0xMDpmWzFdLmdlb21ldHJ5LnkrPWM/YS5nZW9tZXRyeS5oZWlnaHQrMTA6LWZbMV0uZ2VvbWV0cnkuaGVpZ2h0LTEwO3Qudmlldy5jdXJyZW50Um9vdCE9ZCYmKGZbMV0uZ2VvbWV0cnkueC09ay54LGZbMV0uZ2VvbWV0cnkueS09ay55KTt2YXIgbD10LnZpZXcuZ2V0U3RhdGUoYSksbT10LnZpZXcuc2NhbGU7aWYobnVsbCE9bCl7dmFyIHA9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShsKTtnPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEh8fGc9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSD9wLngrPShjP2EuZ2VvbWV0cnkud2lkdGgrMTA6LWZbMV0uZ2VvbWV0cnkud2lkdGgtMTApKm06cC55Kz0oYz9hLmdlb21ldHJ5LmhlaWdodCsxMDotZlsxXS5nZW9tZXRyeS5oZWlnaHQtMTApKm07dmFyIG49dC5nZXRPdXRnb2luZ0VkZ2VzKHQubW9kZWwuZ2V0VGVybWluYWwoZVswXSwKITApKTtpZihudWxsIT1uKXtmb3IodmFyIHE9Zz09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIfHxnPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEgseT1rPWU9MDt5PG4ubGVuZ3RoO3krKyl7dmFyIHU9dC5tb2RlbC5nZXRUZXJtaW5hbChuW3ldLCExKTtpZihnPT1iKHUpKXt2YXIgej10LnZpZXcuZ2V0U3RhdGUodSk7dSE9YSYmbnVsbCE9eiYmKHEmJmMhPXouZ2V0Q2VudGVyWCgpPGwuZ2V0Q2VudGVyWCgpfHwhcSYmYyE9ei5nZXRDZW50ZXJZKCk8bC5nZXRDZW50ZXJZKCkpJiZteFV0aWxzLmludGVyc2VjdHMocCx6KSYmKGU9MTArTWF0aC5tYXgoZSwoTWF0aC5taW4ocC54K3Aud2lkdGgsei54K3oud2lkdGgpLU1hdGgubWF4KHAueCx6LngpKS9tKSxrPTEwK01hdGgubWF4KGssKE1hdGgubWluKHAueStwLmhlaWdodCx6Lnkrei5oZWlnaHQpLU1hdGgubWF4KHAueSx6LnkpKS9tKSl9fXE/az0wOmU9MDtmb3IoeT0wO3k8bi5sZW5ndGg7eSsrKWlmKHU9dC5tb2RlbC5nZXRUZXJtaW5hbChuW3ldLAohMSksZz09Yih1KSYmKHo9dC52aWV3LmdldFN0YXRlKHUpLHUhPWEmJm51bGwhPXomJihxJiZjIT16LmdldENlbnRlclgoKTxsLmdldENlbnRlclgoKXx8IXEmJmMhPXouZ2V0Q2VudGVyWSgpPGwuZ2V0Q2VudGVyWSgpKSkpe3ZhciBCPVtdO3QudHJhdmVyc2Uoei5jZWxsLCEwLGZ1bmN0aW9uKGEsYil7bnVsbCE9YiYmQi5wdXNoKGIpO0IucHVzaChhKTtyZXR1cm4hMH0pO3QubW92ZUNlbGxzKEIsKGM/MTotMSkqZSwoYz8xOi0xKSprKX19fXJldHVybiB0LmFkZENlbGxzKGYsZCl9ZmluYWxseXt0Lm1vZGVsLmVuZFVwZGF0ZSgpfX1mdW5jdGlvbiBnKGEpe3QubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7dmFyIGM9YihhKSxkPXQuZ2V0SW5jb21pbmdFZGdlcyhhKSxlPXQuY2xvbmVDZWxscyhbZFswXSxhXSk7dC5tb2RlbC5zZXRUZXJtaW5hbChkWzBdLGVbMV0sITEpO3QubW9kZWwuc2V0VGVybWluYWwoZVswXSxlWzFdLCEwKTt0Lm1vZGVsLnNldFRlcm1pbmFsKGVbMF0sYSwhMSk7CnZhciBmPXQubW9kZWwuZ2V0UGFyZW50KGEpLGc9Zi5nZW9tZXRyeSxrPVtdO3Qudmlldy5jdXJyZW50Um9vdCE9ZiYmKGVbMV0uZ2VvbWV0cnkueC09Zy54LGVbMV0uZ2VvbWV0cnkueS09Zy55KTt0LnRyYXZlcnNlKGEsITAsZnVuY3Rpb24oYSxiKXtudWxsIT1iJiZrLnB1c2goYik7ay5wdXNoKGEpO3JldHVybiEwfSk7dmFyIGw9YS5nZW9tZXRyeS53aWR0aCs0MCxtPWEuZ2VvbWV0cnkuaGVpZ2h0KzQwO2M9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSD9sPTA6Yz09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIPyhsPTAsbT0tbSk6Yz09bXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1Q/KGw9LWwsbT0wKTpjPT1teENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVCYmKG09MCk7dC5tb3ZlQ2VsbHMoayxsLG0pO3JldHVybiB0LmFkZENlbGxzKGUsZil9ZmluYWxseXt0Lm1vZGVsLmVuZFVwZGF0ZSgpfX1mdW5jdGlvbiBwKGEsYyl7dC5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgZD0KdC5tb2RlbC5nZXRQYXJlbnQoYSksZT10LmdldEluY29taW5nRWRnZXMoYSksZj1iKGEpOzA9PWUubGVuZ3RoJiYoZT1bdC5jcmVhdGVFZGdlKGQsbnVsbCwiIixudWxsLG51bGwsdC5jcmVhdGVDdXJyZW50RWRnZVN0eWxlKCkpXSxmPWMpO3ZhciBnPXQuY2xvbmVDZWxscyhbZVswXSxhXSk7dC5tb2RlbC5zZXRUZXJtaW5hbChnWzBdLGEsITApO2lmKG51bGw9PXQubW9kZWwuZ2V0VGVybWluYWwoZ1swXSwhMSkpe3QubW9kZWwuc2V0VGVybWluYWwoZ1swXSxnWzFdLCExKTt2YXIgaz10LmdldENlbGxTdHlsZShnWzFdKS5uZXdFZGdlU3R5bGU7aWYobnVsbCE9ayl0cnl7dmFyIGw9SlNPTi5wYXJzZShrKSxtO2ZvcihtIGluIGwpdC5zZXRDZWxsU3R5bGVzKG0sbFttXSxbZ1swXV0pLCJlZGdlU3R5bGUiPT1tJiYiZWxib3dFZGdlU3R5bGUiPT1sW21dJiZ0LnNldENlbGxTdHlsZXMoImVsYm93IixmPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEh8fGY9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1RIPwoidmVydGljYWwiOiJob3Jpem9udGFsIixbZ1swXV0pfWNhdGNoKGNhKXt9fXZhciBlPXQuZ2V0T3V0Z29pbmdFZGdlcyhhKSxwPWQuZ2VvbWV0cnksaz1bXTt0LnZpZXcuY3VycmVudFJvb3Q9PWQmJihwPW5ldyBteFJlY3RhbmdsZSk7Zm9yKGw9MDtsPGUubGVuZ3RoO2wrKyl7dmFyIG49dC5tb2RlbC5nZXRUZXJtaW5hbChlW2xdLCExKTtudWxsIT1uJiZrLnB1c2gobil9dmFyIHE9dC52aWV3LmdldEJvdW5kcyhrKSx5PXQudmlldy50cmFuc2xhdGUsej10LnZpZXcuc2NhbGU7Zj09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIPyhnWzFdLmdlb21ldHJ5Lng9bnVsbD09cT9hLmdlb21ldHJ5LngrKGEuZ2VvbWV0cnkud2lkdGgtZ1sxXS5nZW9tZXRyeS53aWR0aCkvMjoocS54K3Eud2lkdGgpL3oteS54LXAueCsxMCxnWzFdLmdlb21ldHJ5LnkrPWdbMV0uZ2VvbWV0cnkuaGVpZ2h0LXAueSs0MCk6Zj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIPyhnWzFdLmdlb21ldHJ5Lng9Cm51bGw9PXE/YS5nZW9tZXRyeS54KyhhLmdlb21ldHJ5LndpZHRoLWdbMV0uZ2VvbWV0cnkud2lkdGgpLzI6KHEueCtxLndpZHRoKS96LXkueCstcC54KzEwLGdbMV0uZ2VvbWV0cnkueS09Z1sxXS5nZW9tZXRyeS5oZWlnaHQrcC55KzQwKTooZ1sxXS5nZW9tZXRyeS54PWY9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUP2dbMV0uZ2VvbWV0cnkueC0oZ1sxXS5nZW9tZXRyeS53aWR0aCtwLngrNDApOmdbMV0uZ2VvbWV0cnkueCsoZ1sxXS5nZW9tZXRyeS53aWR0aC1wLngrNDApLGdbMV0uZ2VvbWV0cnkueT1udWxsPT1xP2EuZ2VvbWV0cnkueSsoYS5nZW9tZXRyeS5oZWlnaHQtZ1sxXS5nZW9tZXRyeS5oZWlnaHQpLzI6KHEueStxLmhlaWdodCkvei15LnkrLXAueSsxMCk7cmV0dXJuIHQuYWRkQ2VsbHMoZyxkKX1maW5hbGx5e3QubW9kZWwuZW5kVXBkYXRlKCl9fWZ1bmN0aW9uIGwoYSxiLGMpe2E9dC5nZXRPdXRnb2luZ0VkZ2VzKGEpO2M9dC52aWV3LmdldFN0YXRlKGMpO3ZhciBkPQpbXTtpZihudWxsIT1jJiZudWxsIT1hKXtmb3IodmFyIGU9MDtlPGEubGVuZ3RoO2UrKyl7dmFyIGY9dC52aWV3LmdldFN0YXRlKHQubW9kZWwuZ2V0VGVybWluYWwoYVtlXSwhMSkpO251bGwhPWYmJighYiYmTWF0aC5taW4oZi54K2Yud2lkdGgsYy54K2Mud2lkdGgpPj1NYXRoLm1heChmLngsYy54KXx8YiYmTWF0aC5taW4oZi55K2YuaGVpZ2h0LGMueStjLmhlaWdodCk+PU1hdGgubWF4KGYueSxjLnkpKSYmZC5wdXNoKGYpfWQuc29ydChmdW5jdGlvbihhLGMpe3JldHVybiBiP2EueCthLndpZHRoLWMueC1jLndpZHRoOmEueSthLmhlaWdodC1jLnktYy5oZWlnaHR9KX1yZXR1cm4gZH1mdW5jdGlvbiBuKGEsYyl7dmFyIGQ9YihhKSxlPWM9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNUfHxjPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVDsoZD09bXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1R8fGQ9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUKT09ZSYmZCE9Yz92LmFjdGlvbnMuZ2V0KCJzZWxlY3RQYXJlbnQiKS5mdW5jdCgpOgpkPT1jPyhlPXQuZ2V0T3V0Z29pbmdFZGdlcyhhKSxudWxsIT1lJiYwPGUubGVuZ3RoJiZ0LnNldFNlbGVjdGlvbkNlbGwodC5tb2RlbC5nZXRUZXJtaW5hbChlWzBdLCExKSkpOihkPXQuZ2V0SW5jb21pbmdFZGdlcyhhKSxudWxsIT1kJiYwPGQubGVuZ3RoJiYoZT1sKHQubW9kZWwuZ2V0VGVybWluYWwoZFswXSwhMCksZSxhKSxkPXQudmlldy5nZXRTdGF0ZShhKSxudWxsIT1kJiYoZD1teFV0aWxzLmluZGV4T2YoZSxkKSwwPD1kJiYoZCs9Yz09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIfHxjPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVD8tMToxLDA8PWQmJmQ8PWUubGVuZ3RoLTEmJnQuc2V0U2VsZWN0aW9uQ2VsbChlW2RdLmNlbGwpKSkpKX12YXIgdj10aGlzLHQ9di5lZGl0b3IuZ3JhcGgseT10LmdldE1vZGVsKCkseD12Lm1lbnVzLmNyZWF0ZVBvcHVwTWVudTt2Lm1lbnVzLmNyZWF0ZVBvcHVwTWVudT1mdW5jdGlvbihiLGMsZCl7eC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7CmlmKDE9PXQuZ2V0U2VsZWN0aW9uQ291bnQoKSl7Yz10LmdldFNlbGVjdGlvbkNlbGwoKTt2YXIgZT10LmdldE91dGdvaW5nRWRnZXMoYyk7Yi5hZGRTZXBhcmF0b3IoKTswPGUubGVuZ3RoJiYoYSh0LmdldFNlbGVjdGlvbkNlbGwoKSkmJnRoaXMuYWRkTWVudUl0ZW1zKGIsWyJzZWxlY3RDaGlsZHJlbiJdLG51bGwsZCksdGhpcy5hZGRNZW51SXRlbXMoYixbInNlbGVjdERlc2NlbmRhbnRzIl0sbnVsbCxkKSk7YSh0LmdldFNlbGVjdGlvbkNlbGwoKSkmJihiLmFkZFNlcGFyYXRvcigpLDA8dC5nZXRJbmNvbWluZ0VkZ2VzKGMpLmxlbmd0aCYmdGhpcy5hZGRNZW51SXRlbXMoYixbInNlbGVjdFNpYmxpbmdzIiwic2VsZWN0UGFyZW50Il0sbnVsbCxkKSl9fTt2LmFjdGlvbnMuYWRkQWN0aW9uKCJzZWxlY3RDaGlsZHJlbiIsZnVuY3Rpb24oKXtpZih0LmlzRW5hYmxlZCgpJiYxPT10LmdldFNlbGVjdGlvbkNvdW50KCkpe3ZhciBhPXQuZ2V0U2VsZWN0aW9uQ2VsbCgpLGE9dC5nZXRPdXRnb2luZ0VkZ2VzKGEpOwppZihudWxsIT1hKXtmb3IodmFyIGI9W10sYz0wO2M8YS5sZW5ndGg7YysrKWIucHVzaCh0Lm1vZGVsLmdldFRlcm1pbmFsKGFbY10sITEpKTt0LnNldFNlbGVjdGlvbkNlbGxzKGIpfX19LG51bGwsbnVsbCwiQWx0K1NoaWZ0K1giKTt2LmFjdGlvbnMuYWRkQWN0aW9uKCJzZWxlY3RTaWJsaW5ncyIsZnVuY3Rpb24oKXtpZih0LmlzRW5hYmxlZCgpJiYxPT10LmdldFNlbGVjdGlvbkNvdW50KCkpe3ZhciBhPXQuZ2V0U2VsZWN0aW9uQ2VsbCgpLGE9dC5nZXRJbmNvbWluZ0VkZ2VzKGEpO2lmKG51bGwhPWEmJjA8YS5sZW5ndGgmJihhPXQuZ2V0T3V0Z29pbmdFZGdlcyh0Lm1vZGVsLmdldFRlcm1pbmFsKGFbMF0sITApKSxudWxsIT1hKSl7Zm9yKHZhciBiPVtdLGM9MDtjPGEubGVuZ3RoO2MrKyliLnB1c2godC5tb2RlbC5nZXRUZXJtaW5hbChhW2NdLCExKSk7dC5zZXRTZWxlY3Rpb25DZWxscyhiKX19fSxudWxsLG51bGwsIkFsdCtTaGlmdCtTIik7di5hY3Rpb25zLmFkZEFjdGlvbigic2VsZWN0UGFyZW50IiwKZnVuY3Rpb24oKXtpZih0LmlzRW5hYmxlZCgpJiYxPT10LmdldFNlbGVjdGlvbkNvdW50KCkpe3ZhciBhPXQuZ2V0U2VsZWN0aW9uQ2VsbCgpLGE9dC5nZXRJbmNvbWluZ0VkZ2VzKGEpO251bGwhPWEmJjA8YS5sZW5ndGgmJnQuc2V0U2VsZWN0aW9uQ2VsbCh0Lm1vZGVsLmdldFRlcm1pbmFsKGFbMF0sITApKX19LG51bGwsbnVsbCwiQWx0K1NoaWZ0K1AiKTt2LmFjdGlvbnMuYWRkQWN0aW9uKCJzZWxlY3REZXNjZW5kYW50cyIsZnVuY3Rpb24oKXtpZih0LmlzRW5hYmxlZCgpJiYxPT10LmdldFNlbGVjdGlvbkNvdW50KCkpe3ZhciBhPXQuZ2V0U2VsZWN0aW9uQ2VsbCgpLGI9W107dC50cmF2ZXJzZShhLCEwLGZ1bmN0aW9uKGEsYyl7bnVsbCE9YyYmYi5wdXNoKGMpO2IucHVzaChhKTtyZXR1cm4hMH0pO3Quc2V0U2VsZWN0aW9uQ2VsbHMoYil9fSxudWxsLG51bGwsIkFsdCtTaGlmdCtEIik7dmFyIEU9dC5yZW1vdmVDZWxsczt0LnJlbW92ZUNlbGxzPWZ1bmN0aW9uKGIsYyl7Yz1udWxsIT0KYz9jOiEwO251bGw9PWImJihiPXRoaXMuZ2V0RGVsZXRhYmxlQ2VsbHModGhpcy5nZXRTZWxlY3Rpb25DZWxscygpKSk7YyYmKGI9dGhpcy5nZXREZWxldGFibGVDZWxscyh0aGlzLmFkZEFsbEVkZ2VzKGIpKSk7Zm9yKHZhciBkPVtdLGU9MDtlPGIubGVuZ3RoO2UrKyl7dmFyIGc9YltlXTt5LmlzRWRnZShnKSYmZihnKSYmKGQucHVzaChnKSxnPXkuZ2V0VGVybWluYWwoZywhMSkpO2lmKGEoZykpe3ZhciBrPVtdO3QudHJhdmVyc2UoZywhMCxmdW5jdGlvbihhLGIpe251bGwhPWImJmsucHVzaChiKTtrLnB1c2goYSk7cmV0dXJuITB9KTswPGsubGVuZ3RoJiYoZD1kLmNvbmNhdChrKSxnPXQuZ2V0SW5jb21pbmdFZGdlcyhiW2VdKSxiPWIuY29uY2F0KGcpKX1lbHNlIG51bGwhPWcmJmQucHVzaChiW2VdKX1iPWQ7cmV0dXJuIEUuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2LmhvdmVySWNvbnMuZ2V0U3RhdGVBdD1mdW5jdGlvbihiLGMsZCl7cmV0dXJuIGEoYi5jZWxsKT9udWxsOnRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZSh0aGlzLmdyYXBoLmdldENlbGxBdChjLApkKSl9O3ZhciBBPXQuZHVwbGljYXRlQ2VsbHM7dC5kdXBsaWNhdGVDZWxscz1mdW5jdGlvbihiLGMpe2I9bnVsbCE9Yj9iOnRoaXMuZ2V0U2VsZWN0aW9uQ2VsbHMoKTtmb3IodmFyIGQ9Yi5zbGljZSgwKSxlPTA7ZTxkLmxlbmd0aDtlKyspe3ZhciBmPXQudmlldy5nZXRTdGF0ZShkW2VdKTtpZihudWxsIT1mJiZhKGYuY2VsbCkpZm9yKHZhciBnPXQuZ2V0SW5jb21pbmdFZGdlcyhmLmNlbGwpLGY9MDtmPGcubGVuZ3RoO2YrKylteFV0aWxzLnJlbW92ZShnW2ZdLGIpfXRoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7dmFyIGs9QS5jYWxsKHRoaXMsYixjKTtpZihrLmxlbmd0aD09Yi5sZW5ndGgpZm9yKGU9MDtlPGIubGVuZ3RoO2UrKylpZihhKGJbZV0pKXt2YXIgbD10LmdldEluY29taW5nRWRnZXMoa1tlXSksZz10LmdldEluY29taW5nRWRnZXMoYltlXSk7aWYoMD09bC5sZW5ndGgmJjA8Zy5sZW5ndGgpe3ZhciBtPXRoaXMuY2xvbmVDZWxsKGdbMF0pO3RoaXMuYWRkRWRnZShtLAp0LmdldERlZmF1bHRQYXJlbnQoKSx0aGlzLm1vZGVsLmdldFRlcm1pbmFsKGdbMF0sITApLGtbZV0pfX19ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfXJldHVybiBrfTt2YXIgQz10Lm1vdmVDZWxsczt0Lm1vdmVDZWxscz1mdW5jdGlvbihiLGMsZCxlLGYsZyxrKXt2YXIgbD1udWxsO3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7dmFyIG09ZixwPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShmKTtpZihudWxsIT1iJiZhKGYpJiYiMSI9PW14VXRpbHMuZ2V0VmFsdWUocCwidHJlZUZvbGRpbmciLCIwIikpe2Zvcih2YXIgbj0wO248Yi5sZW5ndGg7bisrKWlmKGEoYltuXSl8fHQubW9kZWwuaXNFZGdlKGJbbl0pJiZudWxsPT10Lm1vZGVsLmdldFRlcm1pbmFsKGJbbl0sITApKXtmPXQubW9kZWwuZ2V0UGFyZW50KGJbbl0pO2JyZWFrfWlmKG51bGwhPW0mJmYhPW0mJm51bGwhPXRoaXMudmlldy5nZXRTdGF0ZShiWzBdKSl7dmFyIHE9dC5nZXRJbmNvbWluZ0VkZ2VzKGJbMF0pOwppZigwPHEubGVuZ3RoKXt2YXIgeT10LnZpZXcuZ2V0U3RhdGUodC5tb2RlbC5nZXRUZXJtaW5hbChxWzBdLCEwKSk7aWYobnVsbCE9eSl7dmFyIHo9dC52aWV3LmdldFN0YXRlKG0pO251bGwhPXomJihjPSh6LmdldENlbnRlclgoKS15LmdldENlbnRlclgoKSkvdC52aWV3LnNjYWxlLGQ9KHouZ2V0Q2VudGVyWSgpLXkuZ2V0Q2VudGVyWSgpKS90LnZpZXcuc2NhbGUpfX19fWw9Qy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYobnVsbCE9bCYmbnVsbCE9YiYmbC5sZW5ndGg9PWIubGVuZ3RoKWZvcihuPTA7bjxsLmxlbmd0aDtuKyspaWYodGhpcy5tb2RlbC5pc0VkZ2UobFtuXSkpYShtKSYmMD5teFV0aWxzLmluZGV4T2YobCx0aGlzLm1vZGVsLmdldFRlcm1pbmFsKGxbbl0sITApKSYmdGhpcy5tb2RlbC5zZXRUZXJtaW5hbChsW25dLG0sITApO2Vsc2UgaWYoYShiW25dKSYmKHE9dC5nZXRJbmNvbWluZ0VkZ2VzKGJbbl0pLDA8cS5sZW5ndGgpKWlmKCFlKWEobSkmJjA+bXhVdGlscy5pbmRleE9mKGIsCnRoaXMubW9kZWwuZ2V0VGVybWluYWwocVswXSwhMCkpJiZ0aGlzLm1vZGVsLnNldFRlcm1pbmFsKHFbMF0sbSwhMCk7ZWxzZSBpZigwPT10LmdldEluY29taW5nRWRnZXMobFtuXSkubGVuZ3RoKXtwPW07aWYobnVsbD09cHx8cD09dC5tb2RlbC5nZXRQYXJlbnQoYltuXSkpcD10Lm1vZGVsLmdldFRlcm1pbmFsKHFbMF0sITApO2U9dGhpcy5jbG9uZUNlbGwocVswXSk7dGhpcy5hZGRFZGdlKGUsdC5nZXREZWZhdWx0UGFyZW50KCkscCxsW25dKX19ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfXJldHVybiBsfTtpZihudWxsIT12LnNpZGViYXIpe3ZhciB6PXYuc2lkZWJhci5kcm9wQW5kQ29ubmVjdDt2LnNpZGViYXIuZHJvcEFuZENvbm5lY3Q9ZnVuY3Rpb24oYixjLGQsZSl7dmFyIGY9dC5tb2RlbCxnPW51bGw7Zi5iZWdpblVwZGF0ZSgpO3RyeXtpZihnPXouYXBwbHkodGhpcyxhcmd1bWVudHMpLGEoYikpZm9yKHZhciBrPTA7azxnLmxlbmd0aDtrKyspaWYoZi5pc0VkZ2UoZ1trXSkmJgpudWxsPT1mLmdldFRlcm1pbmFsKGdba10sITApKXtmLnNldFRlcm1pbmFsKGdba10sYiwhMCk7dmFyIGw9dC5nZXRDZWxsR2VvbWV0cnkoZ1trXSk7bC5wb2ludHM9bnVsbDtudWxsIT1sLmdldFRlcm1pbmFsUG9pbnQoITApJiZsLnNldFRlcm1pbmFsUG9pbnQobnVsbCwhMCl9fWZpbmFsbHl7Zi5lbmRVcGRhdGUoKX1yZXR1cm4gZ319dmFyIEQ9ezg4OnYuYWN0aW9ucy5nZXQoInNlbGVjdENoaWxkcmVuIiksODQ6di5hY3Rpb25zLmdldCgic2VsZWN0U3VidHJlZSIpLDgwOnYuYWN0aW9ucy5nZXQoInNlbGVjdFBhcmVudCIpLDgzOnYuYWN0aW9ucy5nZXQoInNlbGVjdFNpYmxpbmdzIil9LEc9di5vbktleURvd247di5vbktleURvd249ZnVuY3Rpb24oYil7dHJ5e2lmKHQuaXNFbmFibGVkKCkmJiF0LmlzRWRpdGluZygpJiZhKHQuZ2V0U2VsZWN0aW9uQ2VsbCgpKSYmMT09dC5nZXRTZWxlY3Rpb25Db3VudCgpKXt2YXIgYz1udWxsOzA8dC5nZXRJbmNvbWluZ0VkZ2VzKHQuZ2V0U2VsZWN0aW9uQ2VsbCgpKS5sZW5ndGgmJgooOT09Yi53aGljaD9jPW14RXZlbnQuaXNTaGlmdERvd24oYik/Zyh0LmdldFNlbGVjdGlvbkNlbGwoKSk6cCh0LmdldFNlbGVjdGlvbkNlbGwoKSk6MTM9PWIud2hpY2gmJihjPWUodC5nZXRTZWxlY3Rpb25DZWxsKCksIW14RXZlbnQuaXNTaGlmdERvd24oYikpKSk7aWYobnVsbCE9YyYmMDxjLmxlbmd0aCkxPT1jLmxlbmd0aCYmdC5tb2RlbC5pc0VkZ2UoY1swXSk/dC5zZXRTZWxlY3Rpb25DZWxsKHQubW9kZWwuZ2V0VGVybWluYWwoY1swXSwhMSkpOnQuc2V0U2VsZWN0aW9uQ2VsbChjW2MubGVuZ3RoLTFdKSxudWxsIT12LmhvdmVySWNvbnMmJnYuaG92ZXJJY29ucy51cGRhdGUodC52aWV3LmdldFN0YXRlKHQuZ2V0U2VsZWN0aW9uQ2VsbCgpKSksdC5zdGFydEVkaXRpbmdBdENlbGwodC5nZXRTZWxlY3Rpb25DZWxsKCkpLG14RXZlbnQuY29uc3VtZShiKTtlbHNlIGlmKG14RXZlbnQuaXNBbHREb3duKGIpJiZteEV2ZW50LmlzU2hpZnREb3duKGIpKXt2YXIgZD1EW2Iua2V5Q29kZV07Cm51bGwhPWQmJihkLmZ1bmN0KGIpLG14RXZlbnQuY29uc3VtZShiKSl9ZWxzZSAzNz09Yi5rZXlDb2RlPyhuKHQuZ2V0U2VsZWN0aW9uQ2VsbCgpLG14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUKSxteEV2ZW50LmNvbnN1bWUoYikpOjM4PT1iLmtleUNvZGU/KG4odC5nZXRTZWxlY3Rpb25DZWxsKCksbXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIKSxteEV2ZW50LmNvbnN1bWUoYikpOjM5PT1iLmtleUNvZGU/KG4odC5nZXRTZWxlY3Rpb25DZWxsKCksbXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1QpLG14RXZlbnQuY29uc3VtZShiKSk6NDA9PWIua2V5Q29kZSYmKG4odC5nZXRTZWxlY3Rpb25DZWxsKCksbXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIKSxteEV2ZW50LmNvbnN1bWUoYikpfX1jYXRjaChJKXt2LmhhbmRsZUVycm9yKEkpfW14RXZlbnQuaXNDb25zdW1lZChiKXx8Ry5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBGPXQuY29ubmVjdFZlcnRleDt0LmNvbm5lY3RWZXJ0ZXg9CmZ1bmN0aW9uKGMsZCxmLGssbCxtKXt2YXIgbj10LmdldEluY29taW5nRWRnZXMoYyk7cmV0dXJuIGEoYyk/KGY9YihjKSxrPWY9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNUfHxmPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVCxsPWQ9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNUfHxkPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVCxmPT1kfHwwPT1uLmxlbmd0aD9wKGMsZCk6az09bD9nKGMpOmUoYyxkIT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEgmJmQhPW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUKSk6Ri5jYWxsKHRoaXMsYyxkLGYsayxsLG0pfTt0LmdldFN1YnRyZWU9ZnVuY3Rpb24oYil7dmFyIGQ9W2JdOyFjKGIpJiYhYShiKXx8cShiKXx8dC50cmF2ZXJzZShiLCEwLGZ1bmN0aW9uKGEsYil7bnVsbCE9YiYmMD5teFV0aWxzLmluZGV4T2YoZCxiKSYmZC5wdXNoKGIpOzA+bXhVdGlscy5pbmRleE9mKGQsYSkmJmQucHVzaChhKTtyZXR1cm4hMH0pO3JldHVybiBkfTsKdmFyIEg9bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5pbml0O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe0guYXBwbHkodGhpcyxhcmd1bWVudHMpOyhjKHRoaXMuc3RhdGUuY2VsbCl8fGEodGhpcy5zdGF0ZS5jZWxsKSkmJiFxKHRoaXMuc3RhdGUuY2VsbCkmJjA8dGhpcy5ncmFwaC5nZXRPdXRnb2luZ0VkZ2VzKHRoaXMuc3RhdGUuY2VsbCkubGVuZ3RoJiYodGhpcy5tb3ZlSGFuZGxlPW14VXRpbHMuY3JlYXRlSW1hZ2UoRWRpdG9yLm1vdmVJbWFnZSksdGhpcy5tb3ZlSGFuZGxlLnNldEF0dHJpYnV0ZSgidGl0bGUiLCJNb3ZlIFN1YnRyZWUiKSx0aGlzLm1vdmVIYW5kbGUuc3R5bGUucG9zaXRpb249ImFic29sdXRlIix0aGlzLm1vdmVIYW5kbGUuc3R5bGUuY3Vyc29yPSJwb2ludGVyIix0aGlzLm1vdmVIYW5kbGUuc3R5bGUud2lkdGg9IjI0cHgiLHRoaXMubW92ZUhhbmRsZS5zdHlsZS5oZWlnaHQ9IjI0cHgiLHRoaXMuZ3JhcGguY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubW92ZUhhbmRsZSksCm14RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyh0aGlzLm1vdmVIYW5kbGUsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5ncmFwaC5ncmFwaEhhbmRsZXIuc3RhcnQodGhpcy5zdGF0ZS5jZWxsLG14RXZlbnQuZ2V0Q2xpZW50WChhKSxteEV2ZW50LmdldENsaWVudFkoYSksdGhpcy5ncmFwaC5nZXRTdWJ0cmVlKHRoaXMuc3RhdGUuY2VsbCkpO3RoaXMuZ3JhcGguZ3JhcGhIYW5kbGVyLmNlbGxXYXNDbGlja2VkPSEwO3RoaXMuZ3JhcGguaXNNb3VzZVRyaWdnZXI9bXhFdmVudC5pc01vdXNlRXZlbnQoYSk7dGhpcy5ncmFwaC5pc01vdXNlRG93bj0hMDt2LmhvdmVySWNvbnMucmVzZXQoKTtteEV2ZW50LmNvbnN1bWUoYSl9KSkpfTt2YXIgSj1teFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJlZHJhd0hhbmRsZXM7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5yZWRyYXdIYW5kbGVzPWZ1bmN0aW9uKCl7Si5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbCE9dGhpcy5tb3ZlSGFuZGxlJiYKKHRoaXMubW92ZUhhbmRsZS5zdHlsZS5sZWZ0PXRoaXMuc3RhdGUueCt0aGlzLnN0YXRlLndpZHRoKyg0MD50aGlzLnN0YXRlLndpZHRoPzEwOjApKzIrInB4Iix0aGlzLm1vdmVIYW5kbGUuc3R5bGUudG9wPXRoaXMuc3RhdGUueSt0aGlzLnN0YXRlLmhlaWdodCsoNDA+dGhpcy5zdGF0ZS5oZWlnaHQ/MTA6MCkrMisicHgiKX07dmFyIHU9bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5zZXRIYW5kbGVzVmlzaWJsZTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnNldEhhbmRsZXNWaXNpYmxlPWZ1bmN0aW9uKGEpe3UuYXBwbHkodGhpcyxhcmd1bWVudHMpO251bGwhPXRoaXMubW92ZUhhbmRsZSYmKHRoaXMubW92ZUhhbmRsZS5zdHlsZS5kaXNwbGF5PWE/IiI6Im5vbmUiKX07dmFyIEs9bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbihhLGIpe0suYXBwbHkodGhpcyxhcmd1bWVudHMpO251bGwhPQp0aGlzLm1vdmVIYW5kbGUmJih0aGlzLm1vdmVIYW5kbGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm1vdmVIYW5kbGUpLHRoaXMubW92ZUhhbmRsZT1udWxsKX19O2lmKCJ1bmRlZmluZWQiIT09dHlwZW9mIFNpZGViYXIpe3ZhciBmPVNpZGViYXIucHJvdG90eXBlLmNyZWF0ZUFkdmFuY2VkU2hhcGVzO1NpZGViYXIucHJvdG90eXBlLmNyZWF0ZUFkdmFuY2VkU2hhcGVzPWZ1bmN0aW9uKCl7dmFyIGE9Zi5hcHBseSh0aGlzLGFyZ3VtZW50cyksYz10aGlzLmdyYXBoO3JldHVybiBhLmNvbmNhdChbdGhpcy5hZGRFbnRyeSgidHJlZSBjb250YWluZXIiLGZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14Q2VsbCgiVHJlZSBDb250YWluZXIiLG5ldyBteEdlb21ldHJ5KDAsMCw0MDAsMzIwKSwic3dpbWxhbmU7aHRtbD0xO3N0YXJ0U2l6ZT0yMDtob3Jpem9udGFsPTE7Y29udGFpbmVyVHlwZT10cmVlOyIpO2EudmVydGV4PSEwO3ZhciBjPW5ldyBteENlbGwoIlBhcmVudCIsbmV3IG14R2VvbWV0cnkoMTQwLAo2MCwxMjAsNDApLCd3aGl0ZVNwYWNlPXdyYXA7aHRtbD0xO3RyZWVGb2xkaW5nPTE7dHJlZU1vdmluZz0xO25ld0VkZ2VTdHlsZT17ImVkZ2VTdHlsZSI6ImVsYm93RWRnZVN0eWxlIiwic3RhcnRBcnJvdyI6Im5vbmUiLCJlbmRBcnJvdyI6Im5vbmUifTsnKTtjLnZlcnRleD0hMDt2YXIgYj1uZXcgbXhDZWxsKCJDaGlsZCIsbmV3IG14R2VvbWV0cnkoMTQwLDE0MCwxMjAsNDApLCd3aGl0ZVNwYWNlPXdyYXA7aHRtbD0xO3RyZWVGb2xkaW5nPTE7dHJlZU1vdmluZz0xO25ld0VkZ2VTdHlsZT17ImVkZ2VTdHlsZSI6ImVsYm93RWRnZVN0eWxlIiwic3RhcnRBcnJvdyI6Im5vbmUiLCJlbmRBcnJvdyI6Im5vbmUifTsnKTtiLnZlcnRleD0hMDt2YXIgZD1uZXcgbXhDZWxsKCIiLG5ldyBteEdlb21ldHJ5KDAsMCwwLDApLCJlZGdlU3R5bGU9ZWxib3dFZGdlU3R5bGU7ZWxib3c9dmVydGljYWw7c3RhcnRBcnJvdz1ub25lO2VuZEFycm93PW5vbmU7cm91bmRlZD0wOyIpO2QuZ2VvbWV0cnkucmVsYXRpdmU9CiEwO2QuZWRnZT0hMDtjLmluc2VydEVkZ2UoZCwhMCk7Yi5pbnNlcnRFZGdlKGQsITEpO2EuaW5zZXJ0KGQpO2EuaW5zZXJ0KGMpO2EuaW5zZXJ0KGIpO3JldHVybiBzYi5jcmVhdGVWZXJ0ZXhUZW1wbGF0ZUZyb21DZWxscyhbYV0sYS5nZW9tZXRyeS53aWR0aCxhLmdlb21ldHJ5LmhlaWdodCxhLnZhbHVlKX0pLHRoaXMuYWRkRW50cnkoInRyZWUgbWluZG1hcCBtaW5kbWFwcyBjZW50cmFsIGlkZWEgYnJhbmNoIHRvcGljIixmdW5jdGlvbigpe3ZhciBhPW5ldyBteENlbGwoIk1pbmRtYXAiLG5ldyBteEdlb21ldHJ5KDAsMCw0MjAsMTI2KSwic3dpbWxhbmU7aHRtbD0xO3N0YXJ0U2l6ZT0yMDtob3Jpem9udGFsPTE7Y29udGFpbmVyVHlwZT10cmVlOyIpO2EudmVydGV4PSEwO3ZhciBjPW5ldyBteENlbGwoIkNlbnRyYWwgSWRlYSIsbmV3IG14R2VvbWV0cnkoMTYwLDYwLDEwMCw0MCksJ2VsbGlwc2U7d2hpdGVTcGFjZT13cmFwO2h0bWw9MTthbGlnbj1jZW50ZXI7dHJlZUZvbGRpbmc9MTt0cmVlTW92aW5nPTE7bmV3RWRnZVN0eWxlPXsiZWRnZVN0eWxlIjoiZW50aXR5UmVsYXRpb25FZGdlU3R5bGUiLCJzdGFydEFycm93Ijoibm9uZSIsImVuZEFycm93Ijoibm9uZSIsInNlZ21lbnQiOjEwLCJjdXJ2ZWQiOjF9OycpOwpjLnZlcnRleD0hMDt2YXIgYj1uZXcgbXhDZWxsKCJUb3BpYyIsbmV3IG14R2VvbWV0cnkoMzIwLDQwLDgwLDIwKSwnd2hpdGVTcGFjZT13cmFwO2h0bWw9MTtyb3VuZGVkPTE7YXJjU2l6ZT01MDthbGlnbj1jZW50ZXI7dmVydGljYWxBbGlnbj1taWRkbGU7c3Ryb2tlV2lkdGg9MTthdXRvc2l6ZT0xO3NwYWNpbmc9NDt0cmVlRm9sZGluZz0xO3RyZWVNb3Zpbmc9MTtuZXdFZGdlU3R5bGU9eyJlZGdlU3R5bGUiOiJlbnRpdHlSZWxhdGlvbkVkZ2VTdHlsZSIsInN0YXJ0QXJyb3ciOiJub25lIiwiZW5kQXJyb3ciOiJub25lIiwic2VnbWVudCI6MTAsImN1cnZlZCI6MX07Jyk7Yi52ZXJ0ZXg9ITA7dmFyIGQ9bmV3IG14Q2VsbCgiIixuZXcgbXhHZW9tZXRyeSgwLDAsMCwwKSwiZWRnZVN0eWxlPWVudGl0eVJlbGF0aW9uRWRnZVN0eWxlO3N0YXJ0QXJyb3c9bm9uZTtlbmRBcnJvdz1ub25lO3NlZ21lbnQ9MTA7Y3VydmVkPTE7Iik7ZC5nZW9tZXRyeS5yZWxhdGl2ZT0hMDtkLmVkZ2U9ITA7CmMuaW5zZXJ0RWRnZShkLCEwKTtiLmluc2VydEVkZ2UoZCwhMSk7dmFyIGY9bmV3IG14Q2VsbCgiQnJhbmNoIixuZXcgbXhHZW9tZXRyeSgzMjAsODAsNzIsMjYpLCd3aGl0ZVNwYWNlPXdyYXA7aHRtbD0xO3NoYXBlPXBhcnRpYWxSZWN0YW5nbGU7dG9wPTA7bGVmdD0wO2JvdHRvbT0xO3JpZ2h0PTA7cG9pbnRzPVtbMCwxXSxbMSwxXV07ZmlsbENvbG9yPW5vbmU7YWxpZ249Y2VudGVyO3ZlcnRpY2FsQWxpZ249Ym90dG9tO3JvdXRpbmdDZW50ZXJZPTAuNTtzbmFwVG9Qb2ludD0xO2F1dG9zaXplPTE7dHJlZUZvbGRpbmc9MTt0cmVlTW92aW5nPTE7bmV3RWRnZVN0eWxlPXsiZWRnZVN0eWxlIjoiZW50aXR5UmVsYXRpb25FZGdlU3R5bGUiLCJzdGFydEFycm93Ijoibm9uZSIsImVuZEFycm93Ijoibm9uZSIsInNlZ21lbnQiOjEwLCJjdXJ2ZWQiOjF9OycpO2YudmVydGV4PSEwO3ZhciBtPW5ldyBteENlbGwoIiIsbmV3IG14R2VvbWV0cnkoMCwwLDAsMCksImVkZ2VTdHlsZT1lbnRpdHlSZWxhdGlvbkVkZ2VTdHlsZTtzdGFydEFycm93PW5vbmU7ZW5kQXJyb3c9bm9uZTtzZWdtZW50PTEwO2N1cnZlZD0xOyIpOwptLmdlb21ldHJ5LnJlbGF0aXZlPSEwO20uZWRnZT0hMDtjLmluc2VydEVkZ2UobSwhMCk7Zi5pbnNlcnRFZGdlKG0sITEpO3ZhciBsPW5ldyBteENlbGwoIlRvcGljIixuZXcgbXhHZW9tZXRyeSgyMCw0MCw4MCwyMCksJ3doaXRlU3BhY2U9d3JhcDtodG1sPTE7cm91bmRlZD0xO2FyY1NpemU9NTA7YWxpZ249Y2VudGVyO3ZlcnRpY2FsQWxpZ249bWlkZGxlO3N0cm9rZVdpZHRoPTE7YXV0b3NpemU9MTtzcGFjaW5nPTQ7dHJlZUZvbGRpbmc9MTt0cmVlTW92aW5nPTE7bmV3RWRnZVN0eWxlPXsiZWRnZVN0eWxlIjoiZW50aXR5UmVsYXRpb25FZGdlU3R5bGUiLCJzdGFydEFycm93Ijoibm9uZSIsImVuZEFycm93Ijoibm9uZSIsInNlZ21lbnQiOjEwLCJjdXJ2ZWQiOjF9OycpO2wudmVydGV4PSEwO3ZhciBuPW5ldyBteENlbGwoIiIsbmV3IG14R2VvbWV0cnkoMCwwLDAsMCksImVkZ2VTdHlsZT1lbnRpdHlSZWxhdGlvbkVkZ2VTdHlsZTtzdGFydEFycm93PW5vbmU7ZW5kQXJyb3c9bm9uZTtzZWdtZW50PTEwO2N1cnZlZD0xOyIpOwpuLmdlb21ldHJ5LnJlbGF0aXZlPSEwO24uZWRnZT0hMDtjLmluc2VydEVkZ2UobiwhMCk7bC5pbnNlcnRFZGdlKG4sITEpO3ZhciB2PW5ldyBteENlbGwoIkJyYW5jaCIsbmV3IG14R2VvbWV0cnkoMjAsODAsNzIsMjYpLCd3aGl0ZVNwYWNlPXdyYXA7aHRtbD0xO3NoYXBlPXBhcnRpYWxSZWN0YW5nbGU7dG9wPTA7bGVmdD0wO2JvdHRvbT0xO3JpZ2h0PTA7cG9pbnRzPVtbMCwxXSxbMSwxXV07ZmlsbENvbG9yPW5vbmU7YWxpZ249Y2VudGVyO3ZlcnRpY2FsQWxpZ249Ym90dG9tO3JvdXRpbmdDZW50ZXJZPTAuNTtzbmFwVG9Qb2ludD0xO2F1dG9zaXplPTE7dHJlZUZvbGRpbmc9MTt0cmVlTW92aW5nPTE7bmV3RWRnZVN0eWxlPXsiZWRnZVN0eWxlIjoiZW50aXR5UmVsYXRpb25FZGdlU3R5bGUiLCJzdGFydEFycm93Ijoibm9uZSIsImVuZEFycm93Ijoibm9uZSIsInNlZ21lbnQiOjEwLCJjdXJ2ZWQiOjF9OycpO3YudmVydGV4PSEwO3ZhciB0PW5ldyBteENlbGwoIiIsbmV3IG14R2VvbWV0cnkoMCwKMCwwLDApLCJlZGdlU3R5bGU9ZW50aXR5UmVsYXRpb25FZGdlU3R5bGU7c3RhcnRBcnJvdz1ub25lO2VuZEFycm93PW5vbmU7c2VnbWVudD0xMDtjdXJ2ZWQ9MTsiKTt0Lmdlb21ldHJ5LnJlbGF0aXZlPSEwO3QuZWRnZT0hMDtjLmluc2VydEVkZ2UodCwhMCk7di5pbnNlcnRFZGdlKHQsITEpO2EuaW5zZXJ0KGQpO2EuaW5zZXJ0KG0pO2EuaW5zZXJ0KG4pO2EuaW5zZXJ0KHQpO2EuaW5zZXJ0KGMpO2EuaW5zZXJ0KGIpO2EuaW5zZXJ0KGYpO2EuaW5zZXJ0KGwpO2EuaW5zZXJ0KHYpO3JldHVybiBzYi5jcmVhdGVWZXJ0ZXhUZW1wbGF0ZUZyb21DZWxscyhbYV0sYS5nZW9tZXRyeS53aWR0aCxhLmdlb21ldHJ5LmhlaWdodCxhLnZhbHVlKX0pLHRoaXMuYWRkRW50cnkoInRyZWUgbWluZG1hcCBtaW5kbWFwcyBjZW50cmFsIGlkZWEiLGZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14Q2VsbCgiQ2VudHJhbCBJZGVhIixuZXcgbXhHZW9tZXRyeSgwLDAsMTAwLDQwKSwnZWxsaXBzZTt3aGl0ZVNwYWNlPXdyYXA7aHRtbD0xO2FsaWduPWNlbnRlcjtuZXdFZGdlU3R5bGU9eyJlZGdlU3R5bGUiOiJlbnRpdHlSZWxhdGlvbkVkZ2VTdHlsZSIsInN0YXJ0QXJyb3ciOiJub25lIiwiZW5kQXJyb3ciOiJub25lIiwic2VnbWVudCI6MTAsImN1cnZlZCI6MX07dHJlZUZvbGRpbmc9MTt0cmVlTW92aW5nPTE7Jyk7CmEudmVydGV4PSEwO3JldHVybiBzYi5jcmVhdGVWZXJ0ZXhUZW1wbGF0ZUZyb21DZWxscyhbYV0sYS5nZW9tZXRyeS53aWR0aCxhLmdlb21ldHJ5LmhlaWdodCxhLnZhbHVlKX0pLHRoaXMuYWRkRW50cnkoInRyZWUgbWluZG1hcCBtaW5kbWFwcyBicmFuY2giLGZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14Q2VsbCgiQnJhbmNoIixuZXcgbXhHZW9tZXRyeSgwLDAsODAsMjApLCd3aGl0ZVNwYWNlPXdyYXA7aHRtbD0xO3NoYXBlPXBhcnRpYWxSZWN0YW5nbGU7dG9wPTA7bGVmdD0wO2JvdHRvbT0xO3JpZ2h0PTA7cG9pbnRzPVtbMCwxXSxbMSwxXV07ZmlsbENvbG9yPW5vbmU7YWxpZ249Y2VudGVyO3ZlcnRpY2FsQWxpZ249Ym90dG9tO3JvdXRpbmdDZW50ZXJZPTAuNTtzbmFwVG9Qb2ludD0xO3JlY3Vyc2l2ZVJlc2l6ZT0wO2F1dG9zaXplPTE7dHJlZUZvbGRpbmc9MTt0cmVlTW92aW5nPTE7bmV3RWRnZVN0eWxlPXsiZWRnZVN0eWxlIjoiZW50aXR5UmVsYXRpb25FZGdlU3R5bGUiLCJzdGFydEFycm93Ijoibm9uZSIsImVuZEFycm93Ijoibm9uZSIsInNlZ21lbnQiOjEwLCJjdXJ2ZWQiOjF9OycpOwphLnZlcnRleD0hMDt2YXIgYz1uZXcgbXhDZWxsKCIiLG5ldyBteEdlb21ldHJ5KDAsMCwwLDApLCJlZGdlU3R5bGU9ZW50aXR5UmVsYXRpb25FZGdlU3R5bGU7c3RhcnRBcnJvdz1ub25lO2VuZEFycm93PW5vbmU7c2VnbWVudD0xMDtjdXJ2ZWQ9MTsiKTtjLmdlb21ldHJ5LnNldFRlcm1pbmFsUG9pbnQobmV3IG14UG9pbnQoLTQwLDQwKSwhMCk7Yy5nZW9tZXRyeS5yZWxhdGl2ZT0hMDtjLmVkZ2U9ITA7YS5pbnNlcnRFZGdlKGMsITEpO3JldHVybiBzYi5jcmVhdGVWZXJ0ZXhUZW1wbGF0ZUZyb21DZWxscyhbYSxjXSxhLmdlb21ldHJ5LndpZHRoLGEuZ2VvbWV0cnkuaGVpZ2h0LGEudmFsdWUpfSksdGhpcy5hZGRFbnRyeSgidHJlZSBtaW5kbWFwIG1pbmRtYXBzIHN1YiB0b3BpYyIsZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhDZWxsKCJTdWIgVG9waWMiLG5ldyBteEdlb21ldHJ5KDAsMCw3MiwyNiksJ3doaXRlU3BhY2U9d3JhcDtodG1sPTE7cm91bmRlZD0xO2FyY1NpemU9NTA7YWxpZ249Y2VudGVyO3ZlcnRpY2FsQWxpZ249bWlkZGxlO3N0cm9rZVdpZHRoPTE7YXV0b3NpemU9MTtzcGFjaW5nPTQ7dHJlZUZvbGRpbmc9MTt0cmVlTW92aW5nPTE7bmV3RWRnZVN0eWxlPXsiZWRnZVN0eWxlIjoiZW50aXR5UmVsYXRpb25FZGdlU3R5bGUiLCJzdGFydEFycm93Ijoibm9uZSIsImVuZEFycm93Ijoibm9uZSIsInNlZ21lbnQiOjEwLCJjdXJ2ZWQiOjF9OycpOwphLnZlcnRleD0hMDt2YXIgYz1uZXcgbXhDZWxsKCIiLG5ldyBteEdlb21ldHJ5KDAsMCwwLDApLCJlZGdlU3R5bGU9ZW50aXR5UmVsYXRpb25FZGdlU3R5bGU7c3RhcnRBcnJvdz1ub25lO2VuZEFycm93PW5vbmU7c2VnbWVudD0xMDtjdXJ2ZWQ9MTsiKTtjLmdlb21ldHJ5LnNldFRlcm1pbmFsUG9pbnQobmV3IG14UG9pbnQoLTQwLDQwKSwhMCk7Yy5nZW9tZXRyeS5yZWxhdGl2ZT0hMDtjLmVkZ2U9ITA7YS5pbnNlcnRFZGdlKGMsITEpO3JldHVybiBzYi5jcmVhdGVWZXJ0ZXhUZW1wbGF0ZUZyb21DZWxscyhbYSxjXSxhLmdlb21ldHJ5LndpZHRoLGEuZ2VvbWV0cnkuaGVpZ2h0LGEudmFsdWUpfSksdGhpcy5hZGRFbnRyeSgidHJlZSBvcmdjaGFydCBvcmdhbml6YXRpb24gZGl2aXNpb24iLGZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14Q2VsbCgiT3JnY2hhcnQiLG5ldyBteEdlb21ldHJ5KDAsMCwyODAsMjIwKSwnc3dpbWxhbmU7aHRtbD0xO3N0YXJ0U2l6ZT0yMDtob3Jpem9udGFsPTE7Y29udGFpbmVyVHlwZT10cmVlO25ld0VkZ2VTdHlsZT17ImVkZ2VTdHlsZSI6ImVsYm93RWRnZVN0eWxlIiwic3RhcnRBcnJvdyI6Im5vbmUiLCJlbmRBcnJvdyI6Im5vbmUifTsnKTsKYS52ZXJ0ZXg9ITA7dmFyIGQ9bmV3IG14Q2VsbCgiT3JnYW5pemF0aW9uIixuZXcgbXhHZW9tZXRyeSg4MCw0MCwxMjAsNjApLCd3aGl0ZVNwYWNlPXdyYXA7aHRtbD0xO2FsaWduPWNlbnRlcjt0cmVlRm9sZGluZz0xO3RyZWVNb3Zpbmc9MTtuZXdFZGdlU3R5bGU9eyJlZGdlU3R5bGUiOiJlbGJvd0VkZ2VTdHlsZSIsInN0YXJ0QXJyb3ciOiJub25lIiwiZW5kQXJyb3ciOiJub25lIn07Jyk7Yy5zZXRBdHRyaWJ1dGVGb3JDZWxsKGQsInRyZWVSb290IiwiMSIpO2QudmVydGV4PSEwO3ZhciBiPW5ldyBteENlbGwoIkRpdmlzaW9uIixuZXcgbXhHZW9tZXRyeSgyMCwxNDAsMTAwLDYwKSwnd2hpdGVTcGFjZT13cmFwO2h0bWw9MTthbGlnbj1jZW50ZXI7dmVydGljYWxBbGlnbj1taWRkbGU7dHJlZUZvbGRpbmc9MTt0cmVlTW92aW5nPTE7bmV3RWRnZVN0eWxlPXsiZWRnZVN0eWxlIjoiZWxib3dFZGdlU3R5bGUiLCJzdGFydEFycm93Ijoibm9uZSIsImVuZEFycm93Ijoibm9uZSJ9OycpOwpiLnZlcnRleD0hMDt2YXIgZT1uZXcgbXhDZWxsKCIiLG5ldyBteEdlb21ldHJ5KDAsMCwwLDApLCJlZGdlU3R5bGU9ZWxib3dFZGdlU3R5bGU7ZWxib3c9dmVydGljYWw7c3RhcnRBcnJvdz1ub25lO2VuZEFycm93PW5vbmU7cm91bmRlZD0wOyIpO2UuZ2VvbWV0cnkucmVsYXRpdmU9ITA7ZS5lZGdlPSEwO2QuaW5zZXJ0RWRnZShlLCEwKTtiLmluc2VydEVkZ2UoZSwhMSk7dmFyIGY9bmV3IG14Q2VsbCgiRGl2aXNpb24iLG5ldyBteEdlb21ldHJ5KDE2MCwxNDAsMTAwLDYwKSwnd2hpdGVTcGFjZT13cmFwO2h0bWw9MTthbGlnbj1jZW50ZXI7dmVydGljYWxBbGlnbj1taWRkbGU7dHJlZUZvbGRpbmc9MTt0cmVlTW92aW5nPTE7bmV3RWRnZVN0eWxlPXsiZWRnZVN0eWxlIjoiZWxib3dFZGdlU3R5bGUiLCJzdGFydEFycm93Ijoibm9uZSIsImVuZEFycm93Ijoibm9uZSJ9OycpO2YudmVydGV4PSEwO3ZhciBtPW5ldyBteENlbGwoIiIsbmV3IG14R2VvbWV0cnkoMCwwLDAsMCksImVkZ2VTdHlsZT1lbGJvd0VkZ2VTdHlsZTtlbGJvdz12ZXJ0aWNhbDtzdGFydEFycm93PW5vbmU7ZW5kQXJyb3c9bm9uZTtyb3VuZGVkPTA7Iik7Cm0uZ2VvbWV0cnkucmVsYXRpdmU9ITA7bS5lZGdlPSEwO2QuaW5zZXJ0RWRnZShtLCEwKTtmLmluc2VydEVkZ2UobSwhMSk7YS5pbnNlcnQoZSk7YS5pbnNlcnQobSk7YS5pbnNlcnQoZCk7YS5pbnNlcnQoYik7YS5pbnNlcnQoZik7cmV0dXJuIHNiLmNyZWF0ZVZlcnRleFRlbXBsYXRlRnJvbUNlbGxzKFthXSxhLmdlb21ldHJ5LndpZHRoLGEuZ2VvbWV0cnkuaGVpZ2h0LGEudmFsdWUpfSksdGhpcy5hZGRFbnRyeSgidHJlZSByb290IixmdW5jdGlvbigpe3ZhciBhPW5ldyBteENlbGwoIk9yZ2FuaXphdGlvbiIsbmV3IG14R2VvbWV0cnkoMCwwLDEyMCw2MCksJ3doaXRlU3BhY2U9d3JhcDtodG1sPTE7YWxpZ249Y2VudGVyO3RyZWVGb2xkaW5nPTE7dHJlZU1vdmluZz0xO25ld0VkZ2VTdHlsZT17ImVkZ2VTdHlsZSI6ImVsYm93RWRnZVN0eWxlIiwic3RhcnRBcnJvdyI6Im5vbmUiLCJlbmRBcnJvdyI6Im5vbmUifTsnKTtjLnNldEF0dHJpYnV0ZUZvckNlbGwoYSwidHJlZVJvb3QiLAoiMSIpO2EudmVydGV4PSEwO3JldHVybiBzYi5jcmVhdGVWZXJ0ZXhUZW1wbGF0ZUZyb21DZWxscyhbYV0sYS5nZW9tZXRyeS53aWR0aCxhLmdlb21ldHJ5LmhlaWdodCxhLnZhbHVlKX0pLHRoaXMuYWRkRW50cnkoInRyZWUgZGl2aXNpb24iLGZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14Q2VsbCgiRGl2aXNpb24iLG5ldyBteEdlb21ldHJ5KDIwLDQwLDEwMCw2MCksJ3doaXRlU3BhY2U9d3JhcDtodG1sPTE7YWxpZ249Y2VudGVyO3ZlcnRpY2FsQWxpZ249bWlkZGxlO3RyZWVGb2xkaW5nPTE7dHJlZU1vdmluZz0xO25ld0VkZ2VTdHlsZT17ImVkZ2VTdHlsZSI6ImVsYm93RWRnZVN0eWxlIiwic3RhcnRBcnJvdyI6Im5vbmUiLCJlbmRBcnJvdyI6Im5vbmUifTsnKTthLnZlcnRleD0hMDt2YXIgYz1uZXcgbXhDZWxsKCIiLG5ldyBteEdlb21ldHJ5KDAsMCwwLDApLCJlZGdlU3R5bGU9ZWxib3dFZGdlU3R5bGU7ZWxib3c9dmVydGljYWw7c3RhcnRBcnJvdz1ub25lO2VuZEFycm93PW5vbmU7cm91bmRlZD0wOyIpOwpjLmdlb21ldHJ5LnNldFRlcm1pbmFsUG9pbnQobmV3IG14UG9pbnQoMCwwKSwhMCk7Yy5nZW9tZXRyeS5yZWxhdGl2ZT0hMDtjLmVkZ2U9ITA7YS5pbnNlcnRFZGdlKGMsITEpO3JldHVybiBzYi5jcmVhdGVWZXJ0ZXhUZW1wbGF0ZUZyb21DZWxscyhbYSxjXSxhLmdlb21ldHJ5LndpZHRoLGEuZ2VvbWV0cnkuaGVpZ2h0LGEudmFsdWUpfSksdGhpcy5hZGRFbnRyeSgidHJlZSBzdWIgc2VjdGlvbnMiLGZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14Q2VsbCgiU3ViIFNlY3Rpb24iLG5ldyBteEdlb21ldHJ5KDAsMCwxMDAsNjApLCJ3aGl0ZVNwYWNlPXdyYXA7aHRtbD0xO2FsaWduPWNlbnRlcjt2ZXJ0aWNhbEFsaWduPW1pZGRsZTt0cmVlRm9sZGluZz0xO3RyZWVNb3Zpbmc9MTsiKTthLnZlcnRleD0hMDt2YXIgYz1uZXcgbXhDZWxsKCIiLG5ldyBteEdlb21ldHJ5KDAsMCwwLDApLCJlZGdlU3R5bGU9b3J0aG9nb25hbEVkZ2VTdHlsZTtzdGFydEFycm93PW5vbmU7ZW5kQXJyb3c9bm9uZTtyb3VuZGVkPTA7dGFyZ2V0UG9ydENvbnN0cmFpbnQ9ZWFzdHdlc3Q7c291cmNlUG9ydENvbnN0cmFpbnQ9bm9ydGhzb3V0aDsiKTsKYy5nZW9tZXRyeS5zZXRUZXJtaW5hbFBvaW50KG5ldyBteFBvaW50KDExMCwtNDApLCEwKTtjLmdlb21ldHJ5LnJlbGF0aXZlPSEwO2MuZWRnZT0hMDthLmluc2VydEVkZ2UoYywhMSk7dmFyIGI9bmV3IG14Q2VsbCgiU3ViIFNlY3Rpb24iLG5ldyBteEdlb21ldHJ5KDEyMCwwLDEwMCw2MCksIndoaXRlU3BhY2U9d3JhcDtodG1sPTE7YWxpZ249Y2VudGVyO3ZlcnRpY2FsQWxpZ249bWlkZGxlO3RyZWVGb2xkaW5nPTE7dHJlZU1vdmluZz0xOyIpO2IudmVydGV4PSEwO3ZhciBkPW5ldyBteENlbGwoIiIsbmV3IG14R2VvbWV0cnkoMCwwLDAsMCksImVkZ2VTdHlsZT1vcnRob2dvbmFsRWRnZVN0eWxlO3N0YXJ0QXJyb3c9bm9uZTtlbmRBcnJvdz1ub25lO3JvdW5kZWQ9MDt0YXJnZXRQb3J0Q29uc3RyYWludD1lYXN0d2VzdDtzb3VyY2VQb3J0Q29uc3RyYWludD1ub3J0aHNvdXRoOyIpO2QuZ2VvbWV0cnkuc2V0VGVybWluYWxQb2ludChuZXcgbXhQb2ludCgxMTAsLTQwKSwhMCk7ZC5nZW9tZXRyeS5yZWxhdGl2ZT0KITA7ZC5lZGdlPSEwO2IuaW5zZXJ0RWRnZShkLCExKTtyZXR1cm4gc2IuY3JlYXRlVmVydGV4VGVtcGxhdGVGcm9tQ2VsbHMoW2MsZCxhLGJdLDIyMCw2MCwiU3ViIFNlY3Rpb25zIil9KV0pfX19KSgpO0VkaXRvclVpLmluaXRNaW5pbWFsVGhlbWU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEsYil7dmFyIGM9YS5lZGl0b3IuZ3JhcGg7Yy5wb3B1cE1lbnVIYW5kbGVyLmhpZGVNZW51KCk7bnVsbD09YS5mb3JtYXRXaW5kb3c/KGEuZm9ybWF0V2luZG93PW5ldyBtKGEsbXhSZXNvdXJjZXMuZ2V0KCJmb3JtYXQiKSxNYXRoLm1heCgyMCxhLmRpYWdyYW1Db250YWluZXIuY2xpZW50V2lkdGgtMjQwLTEyKSw1NiwyNDAsTWF0aC5taW4oNTY2LGMuY29udGFpbmVyLmNsaWVudEhlaWdodC0xMCksZnVuY3Rpb24oYil7Yj1hLmNyZWF0ZUZvcm1hdChiKTtiLmluaXQoKTtyZXR1cm4gYn0pLGEuZm9ybWF0V2luZG93LndpbmRvdy5taW5pbXVtU2l6ZT1uZXcgbXhSZWN0YW5nbGUoMCwwLDI0MCw4MCksYS5mb3JtYXRXaW5kb3cud2luZG93LnNldFZpc2libGUoITApKTphLmZvcm1hdFdpbmRvdy53aW5kb3cuc2V0VmlzaWJsZShudWxsIT1iP2I6IWEuZm9ybWF0V2luZG93LndpbmRvdy5pc1Zpc2libGUoKSk7CmEuZm9ybWF0V2luZG93LndpbmRvdy5pc1Zpc2libGUoKSYmYS5mb3JtYXRXaW5kb3cud2luZG93LmZpdCgpfWZ1bmN0aW9uIGMoYSxiKXt2YXIgYz1hLmVkaXRvci5ncmFwaDtjLnBvcHVwTWVudUhhbmRsZXIuaGlkZU1lbnUoKTtuZXcgbXhSZWN0YW5nbGU7aWYobnVsbD09YS5zaWRlYmFyV2luZG93KXt2YXIgZD1NYXRoLm1pbihjLmNvbnRhaW5lci5jbGllbnRXaWR0aC0xMCwyMTgpO2Euc2lkZWJhcldpbmRvdz1uZXcgbShhLG14UmVzb3VyY2VzLmdldCgic2hhcGVzIiksMTAsNTYsZC02LE1hdGgubWluKDY1MCxjLmNvbnRhaW5lci5jbGllbnRIZWlnaHQtMzApLGZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyxkKXt2YXIgZj1hLm1lbnVzLmdldChjKSxnPWUuYWRkTWVudShkLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7Zi5mdW5jdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KSk7Zy5zdHlsZS5jc3NUZXh0PSJwb3NpdGlvbjphYnNvbHV0ZTtib3JkZXItdG9wOjFweCBzb2xpZCBsaWdodGdyYXk7d2lkdGg6NTAlO2hlaWdodDoyNHB4O2JvdHRvbTowcHg7dGV4dC1hbGlnbjpjZW50ZXI7Y3Vyc29yOnBvaW50ZXI7cGFkZGluZzo2cHggMCAwIDA7Y3Vzb3I6cG9pbnRlcjsiOwpnLmNsYXNzTmFtZT0iZ2VUaXRsZSI7Yi5hcHBlbmRDaGlsZChnKTtyZXR1cm4gZ312YXIgZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtkLnN0eWxlLmNzc1RleHQ9InBvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDtyaWdodDowO2JvcmRlci10b3A6MXB4IHNvbGlkIGxpZ2h0Z3JheTtoZWlnaHQ6MjRweDtib3R0b206MzFweDt0ZXh0LWFsaWduOmNlbnRlcjtjdXJzb3I6cG9pbnRlcjtwYWRkaW5nOjZweCAwIDAgMDsiO2QuY2xhc3NOYW1lPSJnZVRpdGxlIjtkLmlubmVySFRNTD0nPHNwYW4gc3R5bGU9ImZvbnQtc2l6ZToxOHB4O21hcmdpbi1yaWdodDo1cHg7Ij4rPC9zcGFuPic7bXhVdGlscy53cml0ZShkLG14UmVzb3VyY2VzLmdldCgibW9yZVNoYXBlcyIpKTtiLmFwcGVuZENoaWxkKGQpO214RXZlbnQuYWRkTGlzdGVuZXIoZCwiY2xpY2siLGZ1bmN0aW9uKCl7YS5hY3Rpb25zLmdldCgic2hhcGVzIikuZnVuY3QoKX0pO3ZhciBlPW5ldyBNZW51YmFyKGEsYik7aWYoIUVkaXRvci5lbmFibGVDdXN0b21MaWJyYXJpZXN8fAoiMSI9PXVybFBhcmFtcy5lbWJlZCYmIjEiIT11cmxQYXJhbXMubGlicmFyaWVzKWQuc3R5bGUuYm90dG9tPSIwIjtlbHNlIGlmKG51bGwhPWEuYWN0aW9ucy5nZXQoIm5ld0xpYnJhcnkiKSl7ZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtkLnN0eWxlLmNzc1RleHQ9InBvc2l0aW9uOmFic29sdXRlO2xlZnQ6MHB4O3dpZHRoOjUwJTtib3JkZXItdG9wOjFweCBzb2xpZCBsaWdodGdyYXk7aGVpZ2h0OjMwcHg7Ym90dG9tOjBweDt0ZXh0LWFsaWduOmNlbnRlcjtjdXJzb3I6cG9pbnRlcjtwYWRkaW5nOjBweDsiO2QuY2xhc3NOYW1lPSJnZVRpdGxlIjt2YXIgZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIik7Zi5zdHlsZS5jc3NUZXh0PSJwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6NnB4OyI7bXhVdGlscy53cml0ZShmLG14UmVzb3VyY2VzLmdldCgibmV3TGlicmFyeSIpKTtkLmFwcGVuZENoaWxkKGYpO2IuYXBwZW5kQ2hpbGQoZCk7bXhFdmVudC5hZGRMaXN0ZW5lcihkLAoiY2xpY2siLGEuYWN0aW9ucy5nZXQoIm5ld0xpYnJhcnkiKS5mdW5jdCk7ZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtkLnN0eWxlLmNzc1RleHQ9InBvc2l0aW9uOmFic29sdXRlO2xlZnQ6NTAlO3dpZHRoOjUwJTtib3JkZXItdG9wOjFweCBzb2xpZCBsaWdodGdyYXk7aGVpZ2h0OjMwcHg7Ym90dG9tOjBweDt0ZXh0LWFsaWduOmNlbnRlcjtjdXJzb3I6cG9pbnRlcjtwYWRkaW5nOjBweDtib3JkZXItbGVmdDogMXB4IHNvbGlkIGxpZ2h0Z3JheTsiO2QuY2xhc3NOYW1lPSJnZVRpdGxlIjtmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNwYW4iKTtmLnN0eWxlLmNzc1RleHQ9InBvc2l0aW9uOnJlbGF0aXZlO3RvcDo2cHg7IjtteFV0aWxzLndyaXRlKGYsbXhSZXNvdXJjZXMuZ2V0KCJvcGVuTGlicmFyeSIpKTtkLmFwcGVuZENoaWxkKGYpO2IuYXBwZW5kQ2hpbGQoZCk7bXhFdmVudC5hZGRMaXN0ZW5lcihkLCJjbGljayIsYS5hY3Rpb25zLmdldCgib3BlbkxpYnJhcnkiKS5mdW5jdCl9ZWxzZSBkPQpjKCJuZXdMaWJyYXJ5IixteFJlc291cmNlcy5nZXQoIm5ld0xpYnJhcnkiKSksZC5zdHlsZS5ib3hTaXppbmc9ImJvcmRlci1ib3giLGQuc3R5bGUucGFkZGluZ1JpZ2h0PSI2cHgiLGQuc3R5bGUucGFkZGluZ0xlZnQ9IjZweCIsZC5zdHlsZS5oZWlnaHQ9IjMycHgiLGQuc3R5bGUubGVmdD0iMCIsZD1jKCJvcGVuTGlicmFyeUZyb20iLG14UmVzb3VyY2VzLmdldCgib3BlbkxpYnJhcnlGcm9tIikpLGQuc3R5bGUuYm9yZGVyTGVmdD0iMXB4IHNvbGlkIGxpZ2h0Z3JheSIsZC5zdHlsZS5ib3hTaXppbmc9ImJvcmRlci1ib3giLGQuc3R5bGUucGFkZGluZ1JpZ2h0PSI2cHgiLGQuc3R5bGUucGFkZGluZ0xlZnQ9IjZweCIsZC5zdHlsZS5oZWlnaHQ9IjMycHgiLGQuc3R5bGUubGVmdD0iNTAlIjtiLmFwcGVuZENoaWxkKGEuc2lkZWJhci5jb250YWluZXIpO2Iuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiI7cmV0dXJuIGJ9KTthLnNpZGViYXJXaW5kb3cud2luZG93Lm1pbmltdW1TaXplPW5ldyBteFJlY3RhbmdsZSgwLAowLDkwLDkwKTthLnNpZGViYXJXaW5kb3cud2luZG93LnNldFZpc2libGUoITApO2EuZ2V0TG9jYWxEYXRhKCJzaWRlYmFyIixmdW5jdGlvbihiKXthLnNpZGViYXIuc2hvd0VudHJpZXMoYixudWxsLCEwKX0pO2EucmVzdG9yZUxpYnJhcmllcygpfWVsc2UgYS5zaWRlYmFyV2luZG93LndpbmRvdy5zZXRWaXNpYmxlKG51bGwhPWI/YjohYS5zaWRlYmFyV2luZG93LndpbmRvdy5pc1Zpc2libGUoKSk7YS5zaWRlYmFyV2luZG93LndpbmRvdy5pc1Zpc2libGUoKSYmYS5zaWRlYmFyV2luZG93LndpbmRvdy5maXQoKX1pZigiMSI9PXVybFBhcmFtcy5saWdodGJveHx8IjAiPT11cmxQYXJhbXMuY2hyb21lfHwidW5kZWZpbmVkIj09PXR5cGVvZiB3aW5kb3cuRm9ybWF0fHwidW5kZWZpbmVkIj09PXR5cGVvZiB3aW5kb3cuTWVudXMpd2luZG93LnVpVGhlbWU9bnVsbDtlbHNle3ZhciBmPXdpbmRvdy5pbm5lcldpZHRofHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGh8fGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGg7CnRyeXt2YXIgZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzdHlsZSIpO2QudHlwZT0idGV4dC9jc3MiO2QuaW5uZXJIVE1MPSIqIHsgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7IH1odG1sIGJvZHkgLm14V2luZG93IGJ1dHRvbi5nZUJ0biB7IGZvbnQtc2l6ZToxMnB4ICFpbXBvcnRhbnQ7IG1hcmdpbi1sZWZ0OiAwOyB9aHRtbCBib2R5IHRhYmxlLm14V2luZG93IHRkLm14V2luZG93UGFuZSBkaXYubXhXaW5kb3dQYW5lICo6bm90KHN2ZyAqKSB7IGZvbnQtc2l6ZTo5cHQ7IH10YWJsZS5teFdpbmRvdyAqIDpub3Qoc3ZnICopIHsgZm9udC1zaXplOjEzcHg7IH1odG1sIGJvZHkgZGl2LmRpYWdyYW1Db250YWluZXIgYnV0dG9uLCBodG1sIGJvZHkgYnV0dG9uLmdlQnRuIHsgZm9udC1zaXplOjE0cHg7IGZvbnQtd2VpZ2h0OjcwMDtib3JkZXItcmFkaXVzOiA1cHg7IH1odG1sIGJvZHkgYnV0dG9uLmdlQnRuOmFjdGl2ZSB7IG9wYWNpdHk6IDAuNjsgfWh0bWwgYm9keSBhLmdlTWVudUl0ZW0geyBvcGFjaXR5OiAwLjc1OyBjdXJzb3I6IHBvaW50ZXI7IHVzZXItc2VsZWN0Om5vbmU7IH1odG1sIGJvZHkgYS5nZU1lbnVJdGVtW2Rpc2FibGVkXSB7IG9wYWNpdHk6IDAuMjsgfWh0bWwgYm9keSBhLmdlTWVudUl0ZW1bZGlzYWJsZWRdOmFjdGl2ZSB7IG9wYWNpdHk6IDAuMjsgfWh0bWwgYm9keSBkaXYuZ2VBY3RpdmVQYWdlIHsgb3BhY2l0eTogMC43OyB9aHRtbCBib2R5IGEuZ2VNZW51SXRlbTphY3RpdmUgeyBvcGFjaXR5OiAwLjI7IH1odG1sIGJvZHkgLmdlVG9vbGJhckJ1dHRvbiB7IG9wYWNpdHk6IDAuMzsgfWh0bWwgYm9keSAuZ2VUb29sYmFyQnV0dG9uOmFjdGl2ZSB7IG9wYWNpdHk6IDAuMTU7IH1odG1sIGJvZHkgLmdlU3RhdHVzOmFjdGl2ZSB7IG9wYWNpdHk6IDAuNTsgfWh0bWwgdGFibGUubXhQb3B1cE1lbnUgdHIubXhQb3B1cE1lbnVJdGVtSG92ZXI6YWN0aXZlIHsgb3BhY2l0eTowLjc7IH1odG1sIGJvZHkgLmdlRGlhbG9nIGlucHV0LCBodG1sIGJvZHkgLmdlVG9vbGJhckNvbnRhaW5lciBpbnB1dCwgaHRtbCBib2R5IC5teFdpbmRvdyBpbnB1dCB7cGFkZGluZzoycHg7ZGlzcGxheTppbmxpbmUtYmxvY2s7IH1kaXYuZ2VEaWFsb2cgeyBib3JkZXItcmFkaXVzOiA1cHg7IH1odG1sIGJvZHkgZGl2LmdlRGlhbG9nIGJ1dHRvbi5nZUJpZ0J1dHRvbiB7IGNvbG9yOiAjZmZmICFpbXBvcnRhbnQ7IGJvcmRlcjogbm9uZSAhaW1wb3J0YW50OyB9Lm14V2luZG93IGJ1dHRvbiwgLmdlRGlhbG9nIHNlbGVjdCwgLm14V2luZG93IHNlbGVjdCB7IGRpc3BsYXk6aW5saW5lLWJsb2NrOyB9aHRtbCBib2R5IC5teFdpbmRvdyAuZ2VDb2xvckJ0biwgaHRtbCBib2R5IC5nZURpYWxvZyAuZ2VDb2xvckJ0biB7IGJhY2tncm91bmQ6IG5vbmU7IH1odG1sIGJvZHkgZGl2LmRpYWdyYW1Db250YWluZXIgYnV0dG9uLCBodG1sIGJvZHkgLm14V2luZG93IGJ1dHRvbiwgaHRtbCBib2R5IC5nZURpYWxvZyBidXR0b24geyBtaW4td2lkdGg6IDBweDsgYm9yZGVyLXJhZGl1czogNXB4OyBjb2xvcjogIzM1MzUzNSAhaW1wb3J0YW50OyBib3JkZXItc3R5bGU6IHNvbGlkOyBib3JkZXItd2lkdGg6IDFweDsgYm9yZGVyLWNvbG9yOiByZ2IoMjE2LCAyMTYsIDIxNik7IH1odG1sIGJvZHkgZGl2LmRpYWdyYW1Db250YWluZXIgYnV0dG9uOmhvdmVyLCBodG1sIGJvZHkgLm14V2luZG93IGJ1dHRvbjpob3ZlciwgaHRtbCBib2R5IC5nZURpYWxvZyBidXR0b246aG92ZXIgeyBib3JkZXItY29sb3I6IHJnYigxNzcsIDE3NywgMTc3KTsgfWh0bWwgYm9keSBkaXYuZGlhZ3JhbUNvbnRhaW5lciBidXR0b246YWN0aXZlLCBodG1sIGJvZHkgLm14V2luZG93IGJ1dHRvbjphY3RpdmUsIGh0bWwgYm9keSAuZ2VEaWFsb2cgYnV0dG9uOmFjdGl2ZSB7IG9wYWNpdHk6IDAuNjsgfWRpdi5kaWFncmFtQ29udGFpbmVyIGJ1dHRvbi5nZUJ0biwgLm14V2luZG93IGJ1dHRvbi5nZUJ0biwgLmdlRGlhbG9nIGJ1dHRvbi5nZUJ0biB7IG1pbi13aWR0aDo3MnB4OyBmb250LXdlaWdodDogNjAwOyBiYWNrZ3JvdW5kOiBub25lOyB9ZGl2LmRpYWdyYW1Db250YWluZXIgYnV0dG9uLmdlUHJpbWFyeUJ0biwgLm14V2luZG93IGJ1dHRvbi5nZVByaW1hcnlCdG4sIC5nZURpYWxvZyBidXR0b24uZ2VQcmltYXJ5QnRuLCBodG1sIGJvZHkgLmdlUHJpbWFyeUJ0biB7IGJhY2tncm91bmQ6ICMyOWI2ZjI7IGNvbG9yOiAjZmZmICFpbXBvcnRhbnQ7IGJvcmRlcjogbm9uZTsgYm94LXNoYWRvdzogbm9uZTsgfWh0bWwgYm9keSAuZ2VQcmltYXJ5QnRuOmhvdmVyIHsgYmFja2dyb3VuZDogIzI5YjZmMjsgYm9yZGVyOiBub25lOyBib3gtc2hhZG93OiBpbmhlcml0OyB9aHRtbCBib2R5IGJ1dHRvbi5nZVByaW1hcnlCdG46aG92ZXIgeyBiYWNrZ3JvdW5kOiAjMjliNmYyOyBib3JkZXI6IG5vbmU7IH0uZ2VCdG4gYnV0dG9uIHsgbWluLXdpZHRoOjcycHggIWltcG9ydGFudDsgfWRpdi5nZVRvb2xiYXJDb250YWluZXIgYS5nZUJ1dHRvbiB7IG1hcmdpbjowcHg7IHBhZGRpbmc6IDAgMnB4IDRweCAycHg7IH0gLmdlRGlhbG9nLCAubXhXaW5kb3cgdGQubXhXaW5kb3dQYW5lICosIGRpdi5nZVNwcml0ZSwgdGQubXhXaW5kb3dUaXRsZSwgLmdlRGlhZ3JhbUNvbnRhaW5lciB7IGJveC1zaXppbmc6Y29udGVudC1ib3g7IH0ubXhXaW5kb3cgZGl2IGJ1dHRvbi5nZVN0eWxlQnV0dG9uIHsgYm94LXNpemluZzogYm9yZGVyLWJveDsgfXRhYmxlLm14V2luZG93IHRkLm14V2luZG93UGFuZSBidXR0b24uZ2VDb2xvckJ0biB7IHBhZGRpbmc6MHB4OyBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9dGQubXhXaW5kb3dQYW5lIC5nZVNpZGViYXJDb250YWluZXIgYnV0dG9uIHsgcGFkZGluZzoycHg7IGJveC1zaXppbmc6IGJvcmRlci1ib3g7IH1odG1sIGJvZHkgLmdlTWVudUl0ZW0geyBmb250LXNpemU6MTRweDsgdGV4dC1kZWNvcmF0aW9uOiBub25lOyBmb250LXdlaWdodDogbm9ybWFsOyBwYWRkaW5nOiA2cHggMTBweCA2cHggMTBweDsgYm9yZGVyOiBub25lOyBib3JkZXItcmFkaXVzOiA1cHg7IGNvbG9yOiAjMzUzNTM1OyBib3gtc2hhZG93OiBpbnNldCAwIDAgMCAxcHggcmdiYSgwLDAsMCwuMTEpLCBpbnNldCAwIC0xcHggMCAwIHJnYmEoMCwwLDAsLjA4KSwgMCAxcHggMnB4IDAgcmdiYSgwLDAsMCwuMDQpOyB9LmdlVG9vbGJhckNvbnRhaW5lciB7IGJhY2tncm91bmQ6I2ZmZiAhaW1wb3J0YW50OyB9ZGl2LmdlU2lkZWJhckNvbnRhaW5lciB7IGJhY2tncm91bmQtY29sb3I6ICNmZmZmZmY7IH1kaXYuZ2VTaWRlYmFyQ29udGFpbmVyIC5nZVRpdGxlIHsgYmFja2dyb3VuZC1jb2xvcjojZmRmZGZkOyB9ZGl2Lm14V2luZG93IHRkLm14V2luZG93UGFuZSBidXR0b24geyBiYWNrZ3JvdW5kLWltYWdlOiBub25lOyBmbG9hdDogbm9uZTsgfXRkLm14V2luZG93VGl0bGUgeyBoZWlnaHQ6IDIycHggIWltcG9ydGFudDsgYmFja2dyb3VuZDogbm9uZSAhaW1wb3J0YW50OyBmb250LXNpemU6IDEzcHggIWltcG9ydGFudDsgdGV4dC1hbGlnbjpjZW50ZXIgIWltcG9ydGFudDsgYm9yZGVyLWJvdHRvbToxcHggc29saWQgbGlnaHRncmF5OyB9ZGl2Lm14V2luZG93LCBkaXYubXhXaW5kb3dUaXRsZSB7IGJhY2tncm91bmQtaW1hZ2U6IG5vbmUgIWltcG9ydGFudDsgYmFja2dyb3VuZC1jb2xvcjojZmZmICFpbXBvcnRhbnQ7IH1kaXYubXhXaW5kb3cgeyBib3JkZXItcmFkaXVzOjVweDsgYm94LXNoYWRvdzogMHB4IDBweCAycHggI0MwQzBDMCAhaW1wb3J0YW50O31kaXYubXhXaW5kb3cgKiB7IGZvbnQtZmFtaWx5OiBpbmhlcml0ICFpbXBvcnRhbnQ7IH1odG1sIGRpdi5nZVZlcnRpY2FsSGFuZGxlIHsgcG9zaXRpb246YWJzb2x1dGU7Ym90dG9tOjBweDtsZWZ0OjUwJTtjdXJzb3I6cm93LXJlc2l6ZTt3aWR0aDoxMXB4O2hlaWdodDoxMXB4O2JhY2tncm91bmQ6d2hpdGU7bWFyZ2luLWJvdHRvbTotNnB4OyBtYXJnaW4tbGVmdDotNnB4OyBib3JkZXI6IG5vbmU7IGJvcmRlci1yYWRpdXM6IDZweDsgYm94LXNoYWRvdzogaW5zZXQgMCAwIDAgMXB4IHJnYmEoMCwwLDAsLjExKSwgaW5zZXQgMCAtMXB4IDAgMCByZ2JhKDAsMCwwLC4wOCksIDAgMXB4IDJweCAwIHJnYmEoMCwwLDAsLjA0KTsgfWh0bWwgZGl2LmdlSW5hY3RpdmVQYWdlIHsgYmFja2dyb3VuZDogcmdiKDI0OSwgMjQ5LCAyNDkpICFpbXBvcnRhbnQ7IGNvbG9yOiAjQTBBMEEwICFpbXBvcnRhbnQ7IH0gaHRtbCBkaXYuZ2VBY3RpdmVQYWdlIHsgYmFja2dyb3VuZDogd2hpdGUgIWltcG9ydGFudDtjb2xvcjogIzM1MzUzNSAhaW1wb3J0YW50OyB9IGh0bWwgZGl2Lm14UnViYmVyYmFuZCB7IGJvcmRlcjoxcHggc29saWQ7IGJvcmRlci1jb2xvcjogIzI5YjZmMiAhaW1wb3J0YW50OyBiYWNrZ3JvdW5kOnJnYmEoNDEsMTgyLDI0MiwwLjQpICFpbXBvcnRhbnQ7IH0gaHRtbCBib2R5IGRpdi5teFBvcHVwTWVudSB7IGJvcmRlci1yYWRpdXM6NXB4OyBib3JkZXI6MXB4IHNvbGlkICNjMGMwYzA7IHBhZGRpbmc6NXB4IDAgNXB4IDA7IGJveC1zaGFkb3c6IDBweCA0cHggMTdweCAtNHB4IHJnYmEoOTYsOTYsOTYsMSk7IH0gaHRtbCB0YWJsZS5teFBvcHVwTWVudSB0ZC5teFBvcHVwTWVudUl0ZW0geyBjb2xvcjogIzM1MzUzNTsgZm9udC1zaXplOiAxNHB4OyBwYWRkaW5nLXRvcDogNHB4OyBwYWRkaW5nLWJvdHRvbTogNHB4OyB9aHRtbCB0YWJsZS5teFBvcHVwTWVudSB0ci5teFBvcHVwTWVudUl0ZW1Ib3ZlciB7IGJhY2tncm91bmQtY29sb3I6ICMyOWI2ZjI7IH1odG1sIHRyLm14UG9wdXBNZW51SXRlbUhvdmVyIHRkLm14UG9wdXBNZW51SXRlbSwgaHRtbCB0ci5teFBvcHVwTWVudUl0ZW1Ib3ZlciB0ZC5teFBvcHVwTWVudUl0ZW0gc3BhbiB7IGNvbG9yOiAjZmZmICFpbXBvcnRhbnQ7IH1odG1sIHRyLm14UG9wdXBNZW51SXRlbSwgaHRtbCB0ZC5teFBvcHVwTWVudUl0ZW0geyB0cmFuc2l0aW9uLXByb3BlcnR5OiBub25lICFpbXBvcnRhbnQ7IH1odG1sIHRhYmxlLm14UG9wdXBNZW51IGhyIHsgaGVpZ2h0OiAycHg7IGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwwLDAsLjA3KTsgbWFyZ2luOiA1cHggMDsgfSIrCihteENsaWVudC5JU19JT1M/Imh0bWwgaW5wdXRbdHlwZT1jaGVja2JveF0sIGh0bWwgaW5wdXRbdHlwZT1yYWRpb10geyBoZWlnaHQ6MTJweDsgfSI6IiIpO2RvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJoZWFkIilbMF0uYXBwZW5kQ2hpbGQoZCl9Y2F0Y2goeSl7fXZhciBtPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcpe3ZhciBrPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2suY2xhc3NOYW1lPSJnZVNpZGViYXJDb250YWluZXIiO2suc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtrLnN0eWxlLndpZHRoPSIxMDAlIjtrLnN0eWxlLmhlaWdodD0iMTAwJSI7ay5zdHlsZS5ib3JkZXI9IjFweCBzb2xpZCB3aGl0ZVNtb2tlIjtrLnN0eWxlLm92ZXJmbG93WD0iaGlkZGVuIjtrLnN0eWxlLm92ZXJmbG93WT0iYXV0byI7ZyhrKTt0aGlzLndpbmRvdz1uZXcgbXhXaW5kb3coYixrLGMsZCxlLGYsITAsITApO3RoaXMud2luZG93LmRlc3Ryb3lPbkNsb3NlPSExO3RoaXMud2luZG93LnNldE1heGltaXphYmxlKCExKTsKdGhpcy53aW5kb3cuc2V0UmVzaXphYmxlKCEwKTt0aGlzLndpbmRvdy5zZXRDbG9zYWJsZSghMCk7dGhpcy53aW5kb3cuc2V0VmlzaWJsZSghMCk7dGhpcy53aW5kb3cuc2V0TG9jYXRpb249ZnVuY3Rpb24oYSxiKXt2YXIgYz13aW5kb3cuaW5uZXJIZWlnaHR8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHR8fGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0O2E9TWF0aC5tYXgoMCxNYXRoLm1pbihhLCh3aW5kb3cuaW5uZXJXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRofHxkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoKS10aGlzLnRhYmxlLmNsaWVudFdpZHRoKSk7Yj1NYXRoLm1heCgwLE1hdGgubWluKGIsYy10aGlzLnRhYmxlLmNsaWVudEhlaWdodC00OCkpO3RoaXMuZ2V0WCgpPT1hJiZ0aGlzLmdldFkoKT09Ynx8bXhXaW5kb3cucHJvdG90eXBlLnNldExvY2F0aW9uLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07bXhDbGllbnQuSVNfU0YmJgoodGhpcy53aW5kb3cuZGl2Lm9uc2VsZWN0c3RhcnQ9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7bnVsbD09YiYmKGI9d2luZG93LmV2ZW50KTtyZXR1cm4gbnVsbCE9YiYmYS5pc1NlbGVjdGlvbkFsbG93ZWQoYil9KSl9O0VkaXRvci5jaGVja21hcmtJbWFnZT1HcmFwaC5jcmVhdGVTdmdJbWFnZSgyMiwxOCwnPHBhdGggdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNCAwKSIgZD0iTTcuMTgxLDE1LjAwN2ExLDEsMCwwLDEtLjc5My0wLjM5MUwzLjIyMiwxMC41QTEsMSwwLDEsMSw0LjgwOCw5LjI3NEw3LjEzMiwxMi4zbDYuMDQ0LTguODZBMSwxLDAsMSwxLDE0LjgzLDQuNTY5bC02LjgyMywxMGExLDEsMCwwLDEtLjguNDM3SDcuMTgxWiIgZmlsbD0iIzI5YjZmMiIvPicpLnNyYztteFdpbmRvdy5wcm90b3R5cGUuY2xvc2VJbWFnZT1HcmFwaC5jcmVhdGVTdmdJbWFnZSgxOCwxMCwnPHBhdGggZD0iTSA1IDEgTCAxMyA5IE0gMTMgMSBMIDUgOSIgc3Ryb2tlPSIjQzBDMEMwIiBzdHJva2Utd2lkdGg9IjIiLz4nKS5zcmM7Cm14V2luZG93LnByb3RvdHlwZS5taW5pbWl6ZUltYWdlPUdyYXBoLmNyZWF0ZVN2Z0ltYWdlKDE0LDEwLCc8cGF0aCBkPSJNIDMgNyBMIDcgMyBMIDExIDciIHN0cm9rZT0iI0MwQzBDMCIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSIjZmZmZmZmIi8+Jykuc3JjO214V2luZG93LnByb3RvdHlwZS5ub3JtYWxpemVJbWFnZT1HcmFwaC5jcmVhdGVTdmdJbWFnZSgxNCwxMCwnPHBhdGggZD0iTSAzIDMgTCA3IDcgTCAxMSAzIiBzdHJva2U9IiNDMEMwQzAiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0iI2ZmZmZmZiIvPicpLnNyYztteENvbnN0cmFpbnRIYW5kbGVyLnByb3RvdHlwZS5wb2ludEltYWdlPUdyYXBoLmNyZWF0ZVN2Z0ltYWdlKDUsNSwnPHBhdGggZD0ibSAwIDAgTCA1IDUgTSAwIDUgTCA1IDAiIHN0cm9rZT0iIzI5YjZmMiIvPicpO214T3V0bGluZS5wcm90b3R5cGUuc2l6ZXJJbWFnZT1udWxsO214Q29uc3RhbnRzLlZFUlRFWF9TRUxFQ1RJT05fQ09MT1I9IiNDMEMwQzAiO214Q29uc3RhbnRzLkVER0VfU0VMRUNUSU9OX0NPTE9SPQoiI0MwQzBDMCI7bXhDb25zdGFudHMuQ09OTkVDVF9IQU5ETEVfRklMTENPTE9SPSIjY2VlN2ZmIjtteENvbnN0YW50cy5ERUZBVUxUX1ZBTElEX0NPTE9SPSIjMjliNmYyIjtteENvbnN0YW50cy5HVUlERV9DT0xPUj0iI0MwQzBDMCI7bXhDb25zdGFudHMuSElHSExJR0hUX1NUUk9LRVdJRFRIPTU7bXhDb25zdGFudHMuSElHSExJR0hUX09QQUNJVFk9MzU7bXhDb25zdGFudHMuT1VUTElORV9DT0xPUj0iIzI5YjZmMiI7bXhDb25zdGFudHMuT1VUTElORV9IQU5ETEVfRklMTENPTE9SPSIjMjliNmYyIjtteENvbnN0YW50cy5PVVRMSU5FX0hBTkRMRV9TVFJPS0VDT0xPUj0iI2ZmZiI7R3JhcGgucHJvdG90eXBlLnN2Z1NoYWRvd0NvbG9yPSIjM0Q0NTc0IjtHcmFwaC5wcm90b3R5cGUuc3ZnU2hhZG93T3BhY2l0eT0iMC40IjtHcmFwaC5wcm90b3R5cGUuc3ZnU2hhZG93U2l6ZT0iMC42IjtHcmFwaC5wcm90b3R5cGUuc3ZnU2hhZG93Qmx1cj0iMS4yIjtGb3JtYXQucHJvdG90eXBlLmluYWN0aXZlVGFiQmFja2dyb3VuZENvbG9yPQoiI2YwZjBmMCI7bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnByZXZpZXdDb2xvcj0iI0MwQzBDMCI7bXhSdWJiZXJiYW5kLnByb3RvdHlwZS5kZWZhdWx0T3BhY2l0eT01MDtIb3Zlckljb25zLnByb3RvdHlwZS5pbmFjdGl2ZU9wYWNpdHk9MjU7Rm9ybWF0LnByb3RvdHlwZS5zaG93Q2xvc2VCdXR0b249ITE7RWRpdG9yVWkucHJvdG90eXBlLmNsb3NhYmxlU2NyYXRjaHBhZD0hMTtFZGl0b3JVaS5wcm90b3R5cGUudG9vbGJhckhlaWdodD00NjtFZGl0b3JVaS5wcm90b3R5cGUuZm9vdGVySGVpZ2h0PTA7R3JhcGgucHJvdG90eXBlLmVkaXRBZnRlckluc2VydD0hbXhDbGllbnQuSVNfSU9TJiYhbXhDbGllbnQuSVNfQU5EUk9JRDtFZGl0b3IucHJvdG90eXBlLmlzQ2hyb21lbGVzc1ZpZXc9ZnVuY3Rpb24oKXtyZXR1cm4hMX07R3JhcGgucHJvdG90eXBlLmlzTGlnaHRib3hWaWV3PWZ1bmN0aW9uKCl7cmV0dXJuITF9O3ZhciBrPUVkaXRvclVpLnByb3RvdHlwZS51cGRhdGVUYWJDb250YWluZXI7CkVkaXRvclVpLnByb3RvdHlwZS51cGRhdGVUYWJDb250YWluZXI9ZnVuY3Rpb24oKXtudWxsIT10aGlzLnRhYkNvbnRhaW5lciYmKHRoaXMudGFiQ29udGFpbmVyLnN0eWxlLnJpZ2h0PSI3MHB4Iix0aGlzLmRpYWdyYW1Db250YWluZXIuc3R5bGUuYm90dG9tPXRoaXMudGFiQ29udGFpbmVySGVpZ2h0KyJweCIpO2suYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgcT1FZGl0b3JVaS5wcm90b3R5cGUudXBkYXRlQWN0aW9uU3RhdGVzO0VkaXRvclVpLnByb3RvdHlwZS51cGRhdGVBY3Rpb25TdGF0ZXM9ZnVuY3Rpb24oKXtxLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLm1lbnVzLmdldCgic2F2ZSIpLnNldEVuYWJsZWQobnVsbCE9dGhpcy5nZXRDdXJyZW50RmlsZSgpfHwiMSI9PXVybFBhcmFtcy5lbWJlZCl9O3ZhciBiPU1lbnVzLnByb3RvdHlwZS5hZGRTaG9ydGN1dDtNZW51cy5wcm90b3R5cGUuYWRkU2hvcnRjdXQ9ZnVuY3Rpb24oYSxjKXtudWxsIT1jLnNob3J0Y3V0JiY5MDA+CmYmJiFteENsaWVudC5JU19JT1M/YS5maXJzdENoaWxkLm5leHRTaWJsaW5nLnNldEF0dHJpYnV0ZSgidGl0bGUiLGMuc2hvcnRjdXQpOmIuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgZT1BcHAucHJvdG90eXBlLnVwZGF0ZVVzZXJFbGVtZW50O0FwcC5wcm90b3R5cGUudXBkYXRlVXNlckVsZW1lbnQ9ZnVuY3Rpb24oKXtlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZihudWxsIT10aGlzLnVzZXJFbGVtZW50KXt2YXIgYT10aGlzLnVzZXJFbGVtZW50O2Euc3R5bGUuY3NzVGV4dD0icG9zaXRpb246cmVsYXRpdmU7bWFyZ2luLXJpZ2h0OjRweDtjdXJzb3I6cG9pbnRlcjtkaXNwbGF5OiIrYS5zdHlsZS5kaXNwbGF5O2EuY2xhc3NOYW1lPSJnZVRvb2xiYXJCdXR0b24iO2EuaW5uZXJIVE1MPSIiO2Euc3R5bGUuYmFja2dyb3VuZEltYWdlPSJ1cmwoIitFZGl0b3IudXNlckltYWdlKyIpIjthLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbj0iY2VudGVyIGNlbnRlciI7YS5zdHlsZS5iYWNrZ3JvdW5kUmVwZWF0PQoibm8tcmVwZWF0IjthLnN0eWxlLmJhY2tncm91bmRTaXplPSIyNHB4IDI0cHgiO2Euc3R5bGUuaGVpZ2h0PSIyNHB4IjthLnN0eWxlLndpZHRoPSIyNHB4IjthLnN0eWxlLmNzc0Zsb2F0PSJyaWdodCI7YS5zZXRBdHRyaWJ1dGUoInRpdGxlIixteFJlc291cmNlcy5nZXQoImNoYW5nZVVzZXIiKSk7Im5vbmUiIT1hLnN0eWxlLmRpc3BsYXkmJihhLnN0eWxlLmRpc3BsYXk9ImlubGluZS1ibG9jayIpfX07dmFyIGc9QXBwLnByb3RvdHlwZS51cGRhdGVCdXR0b25Db250YWluZXI7QXBwLnByb3RvdHlwZS51cGRhdGVCdXR0b25Db250YWluZXI9ZnVuY3Rpb24oKXtnLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZihudWxsIT10aGlzLnNoYXJlQnV0dG9uKXt2YXIgYT10aGlzLnNoYXJlQnV0dG9uO2Euc3R5bGUuY3NzVGV4dD0iZGlzcGxheTppbmxpbmUtYmxvY2s7cG9zaXRpb246cmVsYXRpdmU7Ym94LXNpemluZzpib3JkZXItYm94O21hcmdpbi1yaWdodDo0cHg7Y3Vyc29yOnBvaW50ZXI7IjsKYS5jbGFzc05hbWU9ImdlVG9vbGJhckJ1dHRvbiI7YS5pbm5lckhUTUw9IiI7YS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2U9InVybCgiK0VkaXRvci5zaGFyZUltYWdlKyIpIjthLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbj0iY2VudGVyIGNlbnRlciI7YS5zdHlsZS5iYWNrZ3JvdW5kUmVwZWF0PSJuby1yZXBlYXQiO2Euc3R5bGUuYmFja2dyb3VuZFNpemU9IjI0cHggMjRweCI7YS5zdHlsZS5oZWlnaHQ9IjI0cHgiO2Euc3R5bGUud2lkdGg9IjI0cHgifX07RWRpdG9yVWkucHJvdG90eXBlLmFkZEVtYmVkQnV0dG9ucz1mdW5jdGlvbigpe2lmKG51bGwhPXRoaXMuYnV0dG9uQ29udGFpbmVyKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTthLnN0eWxlLmRpc3BsYXk9ImlubGluZS1ibG9jayI7YS5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiO2Euc3R5bGUubWFyZ2luVG9wPSI4cHgiO2Euc3R5bGUubWFyZ2luUmlnaHQ9IjRweCI7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYSIpOwpiLmNsYXNzTmFtZT0iZ2VNZW51SXRlbSBnZVByaW1hcnlCdG4iO2Iuc3R5bGUubWFyZ2luTGVmdD0iOHB4IjtiLnN0eWxlLnBhZGRpbmc9IjZweCI7IjEiPT11cmxQYXJhbXMubm9TYXZlQnRuPyhteFV0aWxzLndyaXRlKGIsbXhSZXNvdXJjZXMuZ2V0KCJzYXZlQW5kRXhpdCIpKSxiLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgic2F2ZUFuZEV4aXQiKSksbXhFdmVudC5hZGRMaXN0ZW5lcihiLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmFjdGlvbnMuZ2V0KCJzYXZlQW5kRXhpdCIpLmZ1bmN0KCl9KSksYS5hcHBlbmRDaGlsZChiKSk6KG14VXRpbHMud3JpdGUoYixteFJlc291cmNlcy5nZXQoInNhdmUiKSksYi5zZXRBdHRyaWJ1dGUoInRpdGxlIixteFJlc291cmNlcy5nZXQoInNhdmUiKSsiICgiK0VkaXRvci5jdHJsS2V5KyIrUykiKSxteEV2ZW50LmFkZExpc3RlbmVyKGIsImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuYWN0aW9ucy5nZXQoInNhdmUiKS5mdW5jdCgpfSkpLAphLmFwcGVuZENoaWxkKGIpLCIxIj09dXJsUGFyYW1zLnNhdmVBbmRFeGl0JiYoYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJhIiksbXhVdGlscy53cml0ZShiLG14UmVzb3VyY2VzLmdldCgic2F2ZUFuZEV4aXQiKSksYi5zZXRBdHRyaWJ1dGUoInRpdGxlIixteFJlc291cmNlcy5nZXQoInNhdmVBbmRFeGl0IikpLGIuY2xhc3NOYW1lPSJnZU1lbnVJdGVtIixiLnN0eWxlLm1hcmdpbkxlZnQ9IjZweCIsYi5zdHlsZS5wYWRkaW5nPSI2cHgiLG14RXZlbnQuYWRkTGlzdGVuZXIoYiwiY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5hY3Rpb25zLmdldCgic2F2ZUFuZEV4aXQiKS5mdW5jdCgpfSkpLGEuYXBwZW5kQ2hpbGQoYikpKTtiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImEiKTtteFV0aWxzLndyaXRlKGIsbXhSZXNvdXJjZXMuZ2V0KCJleGl0IikpO2Iuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJleGl0IikpO2IuY2xhc3NOYW1lPQoiZ2VNZW51SXRlbSI7Yi5zdHlsZS5tYXJnaW5MZWZ0PSI2cHgiO2Iuc3R5bGUucGFkZGluZz0iNnB4IjtteEV2ZW50LmFkZExpc3RlbmVyKGIsImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuYWN0aW9ucy5nZXQoImV4aXQiKS5mdW5jdCgpfSkpO2EuYXBwZW5kQ2hpbGQoYik7dGhpcy5idXR0b25Db250YWluZXIuYXBwZW5kQ2hpbGQoYSk7dGhpcy5idXR0b25Db250YWluZXIuc3R5bGUudG9wPSI2cHgifX07U2lkZWJhci5wcm90b3R5cGUuZ2V0VG9vbHRpcE9mZnNldD1mdW5jdGlvbigpe3ZhciBhPW14VXRpbHMuZ2V0T2Zmc2V0KHRoaXMuZWRpdG9yVWkuc2lkZWJhcldpbmRvdy53aW5kb3cuZGl2KTthLnkrPTQwO3JldHVybiBhfTt2YXIgcD1NZW51cy5wcm90b3R5cGUuY3JlYXRlUG9wdXBNZW51O01lbnVzLnByb3RvdHlwZS5jcmVhdGVQb3B1cE1lbnU9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuZWRpdG9yVWkuZWRpdG9yLmdyYXBoO2Euc21hcnRTZXBhcmF0b3JzPQohMDtwLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBGaWxlbmFtZURpYWxvZyh0aGlzLmVkaXRvclVpLGEsbXhSZXNvdXJjZXMuZ2V0KCJhcHBseSIpLGZ1bmN0aW9uKGEpe2IocGFyc2VGbG9hdChhKSl9LG14UmVzb3VyY2VzLmdldCgic3BhY2luZyIpKTt0aGlzLmVkaXRvclVpLnNob3dEaWFsb2coYy5jb250YWluZXIsMzAwLDgwLCEwLCEwKTtjLmluaXQoKX0pOzE9PWQuZ2V0U2VsZWN0aW9uQ291bnQoKT8odGhpcy5hZGRNZW51SXRlbXMoYSxbImVkaXRUb29sdGlwIiwiLSIsImVkaXRTdHlsZSIsImVkaXRHZW9tZXRyeSIsIi0iXSxudWxsLGMpLGQuaXNDZWxsRm9sZGFibGUoZC5nZXRTZWxlY3Rpb25DZWxsKCkpJiZ0aGlzLmFkZE1lbnVJdGVtcyhhLGQuaXNDZWxsQ29sbGFwc2VkKGIpP1siZXhwYW5kIl06WyJjb2xsYXBzZSJdLG51bGwsYyksdGhpcy5hZGRNZW51SXRlbXMoYSxbImNvbGxhcHNpYmxlIiwiLSIsCiJsb2NrVW5sb2NrIiwiZW50ZXJHcm91cCJdLG51bGwsYyksYS5hZGRTZXBhcmF0b3IoKSx0aGlzLmFkZFN1Ym1lbnUoImxheW91dCIsYSkpOmQuaXNTZWxlY3Rpb25FbXB0eSgpJiZkLmlzRW5hYmxlZCgpPyhhLmFkZFNlcGFyYXRvcigpLHRoaXMuYWRkTWVudUl0ZW1zKGEsWyJlZGl0RGF0YSJdLG51bGwsYyksYS5hZGRTZXBhcmF0b3IoKSx0aGlzLmFkZFN1Ym1lbnUoImxheW91dCIsYSksdGhpcy5hZGRTdWJtZW51KCJ2aWV3IixhLG51bGwsbXhSZXNvdXJjZXMuZ2V0KCJvcHRpb25zIikpLGEuYWRkU2VwYXJhdG9yKCksdGhpcy5hZGRTdWJtZW51KCJpbnNlcnQiLGEpLHRoaXMuYWRkTWVudUl0ZW1zKGEsWyItIiwiZXhpdEdyb3VwIl0sbnVsbCxjKSk6ZC5pc0VuYWJsZWQoKSYmdGhpcy5hZGRNZW51SXRlbXMoYSxbIi0iLCJsb2NrVW5sb2NrIl0sbnVsbCxjKX07RWRpdG9yVWkucHJvdG90eXBlLnRvZ2dsZUZvcm1hdFBhbmVsPWZ1bmN0aW9uKGIpe251bGwhPXRoaXMuZm9ybWF0V2luZG93Pwp0aGlzLmZvcm1hdFdpbmRvdy53aW5kb3cuc2V0VmlzaWJsZShudWxsIT1iP2I6IXRoaXMuZm9ybWF0V2luZG93LndpbmRvdy5pc1Zpc2libGUoKSk6YSh0aGlzKX07RGlhZ3JhbUZvcm1hdFBhbmVsLnByb3RvdHlwZS5pc01hdGhPcHRpb25WaXNpYmxlPWZ1bmN0aW9uKCl7cmV0dXJuITB9O3ZhciBsPUVkaXRvclVpLnByb3RvdHlwZS5kZXN0cm95O0VkaXRvclVpLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5zaWRlYmFyV2luZG93JiYodGhpcy5zaWRlYmFyV2luZG93LndpbmRvdy5zZXRWaXNpYmxlKCExKSx0aGlzLnNpZGViYXJXaW5kb3cud2luZG93LmRlc3Ryb3koKSx0aGlzLnNpZGViYXJXaW5kb3c9bnVsbCk7bnVsbCE9dGhpcy5mb3JtYXRXaW5kb3cmJih0aGlzLmZvcm1hdFdpbmRvdy53aW5kb3cuc2V0VmlzaWJsZSghMSksdGhpcy5mb3JtYXRXaW5kb3cud2luZG93LmRlc3Ryb3koKSx0aGlzLmZvcm1hdFdpbmRvdz1udWxsKTtudWxsIT10aGlzLmFjdGlvbnMub3V0bGluZVdpbmRvdyYmCih0aGlzLmFjdGlvbnMub3V0bGluZVdpbmRvdy53aW5kb3cuc2V0VmlzaWJsZSghMSksdGhpcy5hY3Rpb25zLm91dGxpbmVXaW5kb3cud2luZG93LmRlc3Ryb3koKSx0aGlzLmFjdGlvbnMub3V0bGluZVdpbmRvdz1udWxsKTtudWxsIT10aGlzLmFjdGlvbnMubGF5ZXJzV2luZG93JiYodGhpcy5hY3Rpb25zLmxheWVyc1dpbmRvdy53aW5kb3cuc2V0VmlzaWJsZSghMSksdGhpcy5hY3Rpb25zLmxheWVyc1dpbmRvdy53aW5kb3cuZGVzdHJveSgpLHRoaXMuYWN0aW9ucy5sYXllcnNXaW5kb3c9bnVsbCk7bnVsbCE9dGhpcy5tZW51cy50YWdzV2luZG93JiYodGhpcy5tZW51cy50YWdzV2luZG93LndpbmRvdy5zZXRWaXNpYmxlKCExKSx0aGlzLm1lbnVzLnRhZ3NXaW5kb3cud2luZG93LmRlc3Ryb3koKSx0aGlzLm1lbnVzLnRhZ3NXaW5kb3c9bnVsbCk7bnVsbCE9dGhpcy5tZW51cy5maW5kV2luZG93JiYodGhpcy5tZW51cy5maW5kV2luZG93LndpbmRvdy5zZXRWaXNpYmxlKCExKSx0aGlzLm1lbnVzLmZpbmRXaW5kb3cud2luZG93LmRlc3Ryb3koKSwKdGhpcy5tZW51cy5maW5kV2luZG93PW51bGwpO2wuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgbj1FZGl0b3JVaS5wcm90b3R5cGUuc2V0R3JhcGhFbmFibGVkO0VkaXRvclVpLnByb3RvdHlwZS5zZXRHcmFwaEVuYWJsZWQ9ZnVuY3Rpb24oYSl7bi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YT8xRTM8PSh3aW5kb3cuaW5uZXJXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRofHxkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoKSYmKG51bGwhPXRoaXMuc2lkZWJhcldpbmRvdyYmdGhpcy5zaWRlYmFyV2luZG93LndpbmRvdy5zZXRWaXNpYmxlKCEwKSxudWxsIT10aGlzLmZvcm1hdFdpbmRvdyYmdGhpcy5mb3JtYXRXaW5kb3cud2luZG93LnNldFZpc2libGUoITApKToobnVsbCE9dGhpcy5zaWRlYmFyV2luZG93JiZ0aGlzLnNpZGViYXJXaW5kb3cud2luZG93LnNldFZpc2libGUoITEpLG51bGwhPXRoaXMuZm9ybWF0V2luZG93JiZ0aGlzLmZvcm1hdFdpbmRvdy53aW5kb3cuc2V0VmlzaWJsZSghMSkpfTsKRWRpdG9yVWkucHJvdG90eXBlLmNocm9tZWxlc3NXaW5kb3dSZXNpemU9ZnVuY3Rpb24oKXt9O3ZhciB2PU1lbnVzLnByb3RvdHlwZS5pbml0O01lbnVzLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7di5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGI9dGhpcy5lZGl0b3JVaSxkPWIuZWRpdG9yLmdyYXBoO2IuYWN0aW9ucy5nZXQoImVkaXREaWFncmFtIikubGFiZWw9bXhSZXNvdXJjZXMuZ2V0KCJmb3JtYXRYbWwiKSsiLi4uIjtiLmFjdGlvbnMuZ2V0KCJjcmVhdGVTaGFwZSIpLmxhYmVsPW14UmVzb3VyY2VzLmdldCgic2hhcGUiKSsiLi4uIjtiLmFjdGlvbnMuZ2V0KCJvdXRsaW5lIikubGFiZWw9bXhSZXNvdXJjZXMuZ2V0KCJvdXRsaW5lIikrIi4uLiI7Yi5hY3Rpb25zLmdldCgibGF5ZXJzIikubGFiZWw9bXhSZXNvdXJjZXMuZ2V0KCJsYXllcnMiKSsiLi4uIjtiLmFjdGlvbnMucHV0KCJpbXBvcnRDc3YiLG5ldyBBY3Rpb24obXhSZXNvdXJjZXMuZ2V0KCJjc3YiKSsiLi4uIiwKZnVuY3Rpb24oKXtkLnBvcHVwTWVudUhhbmRsZXIuaGlkZU1lbnUoKTtiLnNob3dJbXBvcnRDc3ZEaWFsb2coKX0pKTtiLmFjdGlvbnMucHV0KCJpbXBvcnRUZXh0IixuZXcgQWN0aW9uKG14UmVzb3VyY2VzLmdldCgidGV4dCIpKyIuLi4iLGZ1bmN0aW9uKCl7dmFyIGE9bmV3IFBhcnNlRGlhbG9nKGIsIkluc2VydCBmcm9tIFRleHQiKTtiLnNob3dEaWFsb2coYS5jb250YWluZXIsNjIwLDQyMCwhMCwhMSk7YS5pbml0KCl9KSk7Yi5hY3Rpb25zLnB1dCgiZm9ybWF0U3FsIixuZXcgQWN0aW9uKG14UmVzb3VyY2VzLmdldCgiZm9ybWF0U3FsIikrIi4uLiIsZnVuY3Rpb24oKXt2YXIgYT1uZXcgUGFyc2VEaWFsb2coYiwiSW5zZXJ0IGZyb20gVGV4dCIsImZvcm1hdFNxbCIpO2Iuc2hvd0RpYWxvZyhhLmNvbnRhaW5lciw2MjAsNDIwLCEwLCExKTthLmluaXQoKX0pKTtiLmFjdGlvbnMucHV0KCJ0b2dnbGVTaGFwZXMiLG5ldyBBY3Rpb24obXhSZXNvdXJjZXMuZ2V0KCJzaGFwZXMiKSsiLi4uIiwKZnVuY3Rpb24oKXtjKGIpfSkpO2IuYWN0aW9ucy5wdXQoInRvZ2dsZUZvcm1hdCIsbmV3IEFjdGlvbihteFJlc291cmNlcy5nZXQoImZvcm1hdCIpKyIuLi4iLGZ1bmN0aW9uKCl7YShiKX0pKTtFZGl0b3JVaS5lbmFibGVQbGFudFVtbCYmIWIuaXNPZmZsaW5lKCkmJmIuYWN0aW9ucy5wdXQoInBsYW50VW1sIixuZXcgQWN0aW9uKG14UmVzb3VyY2VzLmdldCgicGxhbnRVbWwiKSsiLi4uIixmdW5jdGlvbigpe3ZhciBhPW5ldyBQYXJzZURpYWxvZyhiLG14UmVzb3VyY2VzLmdldCgicGxhbnRVbWwiKSsiLi4uIiwicGxhbnRVbWwiKTtiLnNob3dEaWFsb2coYS5jb250YWluZXIsNjIwLDQyMCwhMCwhMSk7YS5pbml0KCl9KSk7Yi5hY3Rpb25zLnB1dCgibWVybWFpZCIsbmV3IEFjdGlvbihteFJlc291cmNlcy5nZXQoIm1lcm1haWQiKSsiLi4uIixmdW5jdGlvbigpe3ZhciBhPW5ldyBQYXJzZURpYWxvZyhiLG14UmVzb3VyY2VzLmdldCgibWVybWFpZCIpKyIuLi4iLCJtZXJtYWlkIik7CmIuc2hvd0RpYWxvZyhhLmNvbnRhaW5lciw2MjAsNDIwLCEwLCExKTthLmluaXQoKX0pKTt0aGlzLnB1dCgiZGlhZ3JhbSIsbmV3IE1lbnUobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXt2YXIgZD1iLmdldEN1cnJlbnRGaWxlKCk7Yi5tZW51cy5hZGRTdWJtZW51KCJleHRyYXMiLGEsYyxteFJlc291cmNlcy5nZXQoInByZWZlcmVuY2VzIikpO2EuYWRkU2VwYXJhdG9yKGMpO214Q2xpZW50LklTX0NIUk9NRUFQUHx8RWRpdG9yVWkuaXNFbGVjdHJvbkFwcD8oYi5tZW51cy5hZGRNZW51SXRlbXMoYSxbIm5ldyIsIm9wZW4iLCItIl0sYyksRWRpdG9yVWkuaXNFbGVjdHJvbkFwcCYmYi5tZW51cy5hZGRNZW51SXRlbXMoYSxbInN5bmNocm9uaXplIiwiLSJdLGMpLGIubWVudXMuYWRkTWVudUl0ZW1zKGEsWyJzYXZlIiwic2F2ZUFzIiwiLSJdLGMpKToiMSI9PXVybFBhcmFtcy5lbWJlZD8oYi5tZW51cy5hZGRNZW51SXRlbXMoYSxbIi0iLCJzYXZlIl0sYyksIjEiPT11cmxQYXJhbXMuc2F2ZUFuZEV4aXQmJgpiLm1lbnVzLmFkZE1lbnVJdGVtcyhhLFsic2F2ZUFuZEV4aXQiXSxjKSxhLmFkZFNlcGFyYXRvcihjKSk6KGIubWVudXMuYWRkTWVudUl0ZW1zKGEsWyJuZXciXSxjKSxiLm1lbnVzLmFkZFN1Ym1lbnUoIm9wZW5Gcm9tIixhLGMpLGlzTG9jYWxTdG9yYWdlJiZ0aGlzLmFkZFN1Ym1lbnUoIm9wZW5SZWNlbnQiLGEsYyksYS5hZGRTZXBhcmF0b3IoYyksbnVsbCE9ZCYmZC5jb25zdHJ1Y3Rvcj09RHJpdmVGaWxlJiZiLm1lbnVzLmFkZE1lbnVJdGVtcyhhLFsic2hhcmUiXSxjKSxteENsaWVudC5JU19DSFJPTUVBUFB8fEVkaXRvclVpLmlzRWxlY3Ryb25BcHB8fG51bGw9PWR8fGQuY29uc3RydWN0b3I9PUxvY2FsRmlsZXx8Yi5tZW51cy5hZGRNZW51SXRlbXMoYSxbInN5bmNocm9uaXplIl0sYyksYS5hZGRTZXBhcmF0b3IoYyksYi5tZW51cy5hZGRTdWJtZW51KCJzYXZlIixhLGMpKTtiLm1lbnVzLmFkZFN1Ym1lbnUoImV4cG9ydEFzIixhLGMpO214Q2xpZW50LklTX0NIUk9NRUFQUHx8CkVkaXRvclVpLmlzRWxlY3Ryb25BcHA/Yi5tZW51cy5hZGRNZW51SXRlbXMoYSxbImltcG9ydCJdLGMpOmIubWVudXMuYWRkU3VibWVudSgiaW1wb3J0RnJvbSIsYSxjKTtiLm1lbnVzLmFkZE1lbnVJdGVtcyhhLFsiLSIsIm91dGxpbmUiLCJsYXllcnMiXSxjKTtiLmNvbW1lbnRzU3VwcG9ydGVkKCkmJmIubWVudXMuYWRkTWVudUl0ZW1zKGEsWyJjb21tZW50cyJdLGMpO2IubWVudXMuYWRkTWVudUl0ZW1zKGEsWyItIiwiZmluZCIsInRhZ3MiXSxjKTtudWxsIT1kJiZudWxsIT1iLmZpbGVOb2RlJiYoZD1udWxsIT1kLmdldFRpdGxlKCk/ZC5nZXRUaXRsZSgpOmIuZGVmYXVsdEZpbGVuYW1lLC8oXC5odG1sKSQvaS50ZXN0KGQpfHwvKFwuc3ZnKSQvaS50ZXN0KGQpfHx0aGlzLmFkZE1lbnVJdGVtcyhhLFsiLSIsInByb3BlcnRpZXMiXSkpO214Q2xpZW50LklTX0lPUyYmbmF2aWdhdG9yLnN0YW5kYWxvbmV8fGIubWVudXMuYWRkTWVudUl0ZW1zKGEsWyItIiwicHJpbnQiLCItIl0sYyk7CmIubWVudXMuYWRkU3VibWVudSgiaGVscCIsYSxjKTsiMSI9PXVybFBhcmFtcy5lbWJlZD9iLm1lbnVzLmFkZE1lbnVJdGVtcyhhLFsiLSIsImV4aXQiXSxjKTpiLm1lbnVzLmFkZE1lbnVJdGVtcyhhLFsiLSIsImNsb3NlIl0pfSkpKTt0aGlzLnB1dCgic2F2ZSIsbmV3IE1lbnUobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXt2YXIgZD1iLmdldEN1cnJlbnRGaWxlKCk7bnVsbCE9ZCYmZC5jb25zdHJ1Y3Rvcj09RHJpdmVGaWxlP2IubWVudXMuYWRkTWVudUl0ZW1zKGEsWyJzYXZlIiwibWFrZUNvcHkiLCItIiwicmVuYW1lIiwibW92ZVRvRm9sZGVyIl0sYyk6KGIubWVudXMuYWRkTWVudUl0ZW1zKGEsWyJzYXZlIiwic2F2ZUFzIiwiLSIsInJlbmFtZSJdLGMpLGIuaXNPZmZsaW5lQXBwKCk/bmF2aWdhdG9yLm9uTGluZSYmIjEiIT11cmxQYXJhbXMuc3RlYWx0aCYmdGhpcy5hZGRNZW51SXRlbXMoYSxbInVwbG9hZCJdLGMpOmIubWVudXMuYWRkTWVudUl0ZW1zKGEsWyJtYWtlQ29weSJdLApjKSk7Yi5tZW51cy5hZGRNZW51SXRlbXMoYSxbIi0iLCJhdXRvc2F2ZSJdLGMpO251bGwhPWQmJmQuaXNSZXZpc2lvbkhpc3RvcnlTdXBwb3J0ZWQoKSYmYi5tZW51cy5hZGRNZW51SXRlbXMoYSxbIi0iLCJyZXZpc2lvbkhpc3RvcnkiXSxjKX0pKSk7dmFyIGU9dGhpcy5nZXQoImV4cG9ydEFzIik7dGhpcy5wdXQoImV4cG9ydEFzIixuZXcgTWVudShteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGMpe2UuZnVuY3QoYSxjKTtteENsaWVudC5JU19DSFJPTUVBUFB8fEVkaXRvclVpLmlzRWxlY3Ryb25BcHB8fGIubWVudXMuYWRkTWVudUl0ZW1zKGEsWyJwdWJsaXNoTGluayJdLGMpO2EuYWRkU2VwYXJhdG9yKGMpO2IubWVudXMuYWRkU3VibWVudSgiZW1iZWQiLGEsYyl9KSkpO3ZhciBmPXRoaXMuZ2V0KCJsYW5ndWFnZSIpO3RoaXMucHV0KCJ0YWJsZSIsbmV3IE1lbnUobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXtiLm1lbnVzLmFkZEluc2VydFRhYmxlQ2VsbEl0ZW0oYSwKYyl9KSkpO3RoaXMucHV0KCJleHRyYXMiLG5ldyBNZW51KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7IjEiIT11cmxQYXJhbXMuZW1iZWQmJmIubWVudXMuYWRkU3VibWVudSgidGhlbWUiLGEsYyk7bnVsbCE9ZiYmYi5tZW51cy5hZGRTdWJtZW51KCJsYW5ndWFnZSIsYSxjKTtiLm1lbnVzLmFkZFN1Ym1lbnUoInVuaXRzIixhLGMpO2EuYWRkU2VwYXJhdG9yKGMpO2IubWVudXMuYWRkTWVudUl0ZW1zKGEsWyJzY3JvbGxiYXJzIiwidG9vbHRpcHMiLCJydWxlciJdLGMpOyIxIiE9dXJsUGFyYW1zLmVtYmVkJiYoaXNMb2NhbFN0b3JhZ2V8fG14Q2xpZW50LklTX0NIUk9NRUFQUCkmJmIubWVudXMuYWRkTWVudUl0ZW1zKGEsWyItIiwic2VhcmNoIiwic2NyYXRjaHBhZCIsIi0iLCJzaG93U3RhcnRTY3JlZW4iXSxjKTshYi5pc09mZmxpbmVBcHAoKSYmaXNMb2NhbFN0b3JhZ2UmJmIubWVudXMuYWRkTWVudUl0ZW0oYSwicGx1Z2lucyIsYyk7YS5hZGRTZXBhcmF0b3IoYyk7CmIubWVudXMuYWRkTWVudUl0ZW0oYSwiZHJhd0NvbmZpZyIsYyk7YS5hZGRTZXBhcmF0b3IoYyl9KSkpO3RoaXMucHV0KCJpbnNlcnRBZHZhbmNlZCIsbmV3IE1lbnUobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXtiLm1lbnVzLmFkZE1lbnVJdGVtcyhhLCJpbXBvcnRUZXh0IHBsYW50VW1sIG1lcm1haWQgLSBmb3JtYXRTcWwgaW1wb3J0Q3N2IC0gY3JlYXRlU2hhcGUgZWRpdERpYWdyYW0iLnNwbGl0KCIgIiksYyl9KSkpO214VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXQoImluc2VydCIpLGM9YS5mdW5jdDthLmZ1bmN0PWZ1bmN0aW9uKGEsZCl7Yy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7Yi5tZW51cy5hZGRTdWJtZW51KCJ0YWJsZSIsYSxkKTthLmFkZFNlcGFyYXRvcihkKTtiLm1lbnVzLmFkZE1lbnVJdGVtcyhhLFsiLSIsInRvZ2dsZVNoYXBlcyJdLGQpfX0pKCk7dmFyIGc9Imhvcml6b250YWxGbG93IHZlcnRpY2FsRmxvdyAtIGhvcml6b250YWxUcmVlIHZlcnRpY2FsVHJlZSByYWRpYWxUcmVlIC0gb3JnYW5pYyBjaXJjbGUiLnNwbGl0KCIgIiksCms9ZnVuY3Rpb24oYSxjLGQsZSl7YS5hZGRJdGVtKGQsbnVsbCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3ZhciBhPW5ldyBDcmVhdGVHcmFwaERpYWxvZyhiLGQsZSk7Yi5zaG93RGlhbG9nKGEuY29udGFpbmVyLDYyMCw0MjAsITAsITEpO2EuaW5pdCgpfSksYyl9O3RoaXMucHV0KCJpbnNlcnRMYXlvdXQiLG5ldyBNZW51KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTA7YzxnLmxlbmd0aDtjKyspIi0iPT1nW2NdP2EuYWRkU2VwYXJhdG9yKGIpOmsoYSxiLG14UmVzb3VyY2VzLmdldChnW2NdKSsiLi4uIixnW2NdKX0pKSk7dGhpcy5wdXQoInZpZXciLG5ldyBNZW51KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7Yi5tZW51cy5hZGRNZW51SXRlbXMoYSwiZ3JpZCBndWlkZXMgcnVsZXIgLSBjb25uZWN0aW9uQXJyb3dzIGNvbm5lY3Rpb25Qb2ludHMgLSIuc3BsaXQoIiAiKSxjKTtpZigidW5kZWZpbmVkIiE9PXR5cGVvZiBNYXRoSmF4KXt2YXIgZD0KYi5tZW51cy5hZGRNZW51SXRlbShhLCJtYXRoZW1hdGljYWxUeXBlc2V0dGluZyIsYyk7Yi5tZW51cy5hZGRMaW5rVG9JdGVtKGQsImh0dHBzOi8vZGVzay5kcmF3LmlvL3N1cHBvcnQvc29sdXRpb25zL2FydGljbGVzLzE2MDAwMDMyODc1Iil9Yi5tZW51cy5hZGRNZW51SXRlbXMoYSxbImNvcHlDb25uZWN0IiwiY29sbGFwc2VFeHBhbmQiLCItIiwicGFnZVNjYWxlIl0sYyl9KSkpfTt2YXIgdD1FZGl0b3JVaS5wcm90b3R5cGUuaW5pdDtFZGl0b3JVaS5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYSxiLGMpe3ZhciBkPWwubWVudXMuZ2V0KGEpLGU9cS5hZGRNZW51KG14UmVzb3VyY2VzLmdldChhKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2QuZnVuY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfSkscCk7ZS5jbGFzc05hbWU9ImdlTWVudUl0ZW0iO2Uuc3R5bGUuZGlzcGxheT0iaW5saW5lLWJsb2NrIjtlLnN0eWxlLmJveFNpemluZz0iYm9yZGVyLWJveCI7CmUuc3R5bGUudG9wPSI2cHgiO2Uuc3R5bGUubWFyZ2luUmlnaHQ9IjZweCI7ZS5zdHlsZS5oZWlnaHQ9IjMwcHgiO2Uuc3R5bGUucGFkZGluZ1RvcD0iNnB4IjtlLnN0eWxlLnBhZGRpbmdCb3R0b209IjZweCI7ZS5zdHlsZS5jdXJzb3I9InBvaW50ZXIiO2Uuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KGEpKTtsLm1lbnVzLm1lbnVDcmVhdGVkKGQsZSwiZ2VNZW51SXRlbSIpO251bGwhPWM/KGUuc3R5bGUuYmFja2dyb3VuZEltYWdlPSJ1cmwoIitjKyIpIixlLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbj0iY2VudGVyIGNlbnRlciIsZS5zdHlsZS5iYWNrZ3JvdW5kUmVwZWF0PSJuby1yZXBlYXQiLGUuc3R5bGUuYmFja2dyb3VuZFNpemU9IjI0cHggMjRweCIsZS5zdHlsZS53aWR0aD0iMzRweCIsZS5pbm5lckhUTUw9IiIpOmJ8fChlLnN0eWxlLmJhY2tncm91bmRJbWFnZT0idXJsKCIrbXhXaW5kb3cucHJvdG90eXBlLm5vcm1hbGl6ZUltYWdlKyIpIixlLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbj0KInJpZ2h0IDZweCBjZW50ZXIiLGUuc3R5bGUuYmFja2dyb3VuZFJlcGVhdD0ibm8tcmVwZWF0IixlLnN0eWxlLnBhZGRpbmdSaWdodD0iMjJweCIpO3JldHVybiBlfWZ1bmN0aW9uIGQoYSxiLGMsZCxlLGYpe3ZhciBnPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImEiKTtnLmNsYXNzTmFtZT0iZ2VNZW51SXRlbSI7Zy5zdHlsZS5kaXNwbGF5PSJpbmxpbmUtYmxvY2siO2cuc3R5bGUuYm94U2l6aW5nPSJib3JkZXItYm94IjtnLnN0eWxlLmhlaWdodD0iMzBweCI7Zy5zdHlsZS5wYWRkaW5nPSI2cHgiO2cuc3R5bGUucG9zaXRpb249InJlbGF0aXZlIjtnLnN0eWxlLnZlcnRpY2FsQWxpZ249InRvcCI7Zy5zdHlsZS50b3A9IjBweCI7bnVsbCE9bC5zdGF0dXNDb250YWluZXI/bi5pbnNlcnRCZWZvcmUoZyxsLnN0YXR1c0NvbnRhaW5lcik6bi5hcHBlbmRDaGlsZChnKTtudWxsIT1mPyhnLnN0eWxlLmJhY2tncm91bmRJbWFnZT0idXJsKCIrZisiKSIsZy5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb249CiJjZW50ZXIgY2VudGVyIixnLnN0eWxlLmJhY2tncm91bmRSZXBlYXQ9Im5vLXJlcGVhdCIsZy5zdHlsZS5iYWNrZ3JvdW5kU2l6ZT0iMjRweCAyNHB4IixnLnN0eWxlLndpZHRoPSIzNHB4Iik6bXhVdGlscy53cml0ZShnLGEpO214RXZlbnQuYWRkTGlzdGVuZXIoZyxteENsaWVudC5JU19QT0lOVEVSPyJwb2ludGVyZG93biI6Im1vdXNlZG93biIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7YS5wcmV2ZW50RGVmYXVsdCgpfSkpO214RXZlbnQuYWRkTGlzdGVuZXIoZywiY2xpY2siLGZ1bmN0aW9uKGEpeyJkaXNhYmxlZCIhPWcuZ2V0QXR0cmlidXRlKCJkaXNhYmxlZCIpJiZiKGEpO214RXZlbnQuY29uc3VtZShhKX0pO251bGw9PWMmJihnLnN0eWxlLm1hcmdpblJpZ2h0PSI0cHgiKTtudWxsIT1kJiZnLnNldEF0dHJpYnV0ZSgidGl0bGUiLGQpO251bGwhPWUmJihhPWZ1bmN0aW9uKCl7ZS5pc0VuYWJsZWQoKT8oZy5yZW1vdmVBdHRyaWJ1dGUoImRpc2FibGVkIiksZy5zdHlsZS5jdXJzb3I9CiJwb2ludGVyIik6KGcuc2V0QXR0cmlidXRlKCJkaXNhYmxlZCIsImRpc2FibGVkIiksZy5zdHlsZS5jdXJzb3I9ImRlZmF1bHQiKX0sZS5hZGRMaXN0ZW5lcigic3RhdGVDaGFuZ2VkIixhKSxhKCkpO3JldHVybiBnfWZ1bmN0aW9uIGUoYSxiKXt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtjLmNsYXNzTmFtZT0iZ2VNZW51SXRlbSI7Yy5zdHlsZS5kaXNwbGF5PSJpbmxpbmUtYmxvY2siO2Muc3R5bGUudmVydGljYWxBbGlnbj0idG9wIjtjLnN0eWxlLm1hcmdpblJpZ2h0PSI2cHgiO2Muc3R5bGUucGFkZGluZz0iMCA0cHggMCA0cHgiO2Muc3R5bGUuaGVpZ2h0PSIzMHB4IjtjLnN0eWxlLnBvc2l0aW9uPSJyZWxhdGl2ZSI7Yy5zdHlsZS50b3A9IjBweCI7Zm9yKHZhciBkPTA7ZDxhLmxlbmd0aDtkKyspbnVsbCE9YVtkXSYmKGFbZF0uc3R5bGUubWFyZ2luPSIwcHgiLGFbZF0uc3R5bGUuYm94U2hhZG93PSJub25lIixjLmFwcGVuZENoaWxkKGFbZF0pKTtudWxsIT0KYiYmbXhVdGlscy5zZXRPcGFjaXR5KGMsYik7bnVsbCE9bC5zdGF0dXNDb250YWluZXI/bi5pbnNlcnRCZWZvcmUoYyxsLnN0YXR1c0NvbnRhaW5lcik6bi5hcHBlbmRDaGlsZChjKTtyZXR1cm4gY31mdW5jdGlvbiBnKCl7Zm9yKHZhciBhPW4uZmlyc3RDaGlsZDtudWxsIT1hOyl7dmFyIGM9YS5uZXh0U2libGluZzsiZ2VNZW51SXRlbSIhPWEuY2xhc3NOYW1lJiYiZ2VJdGVtIiE9YS5jbGFzc05hbWV8fGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKTthPWN9cD1uLmZpcnN0Q2hpbGQ7Zj13aW5kb3cuaW5uZXJXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRofHxkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoOyhhPTFFMz5mKXx8YigiZGlhZ3JhbSIpO2UoW2E/YigiZGlhZ3JhbSIsbnVsbCxJTUFHRV9QQVRIKyIvZHJhd2xvZ28uc3ZnIik6bnVsbCxkKG14UmVzb3VyY2VzLmdldCgic2hhcGVzIiksbC5hY3Rpb25zLmdldCgidG9nZ2xlU2hhcGVzIikuZnVuY3QsCm51bGwsbXhSZXNvdXJjZXMuZ2V0KCJzaGFwZXMiKSxsLmFjdGlvbnMuZ2V0KCJpbWFnZSIpLGE/ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWo0OGNHRjBhQ0JrUFNKTk1UTWdNVE4yT0dnNGRpMDRhQzA0ZWsweklESXhhRGgyTFRoSU0zWTRlazB6SUROMk9HZzRWak5JTTNwdE1UTXVOall0TVM0ek1Vd3hNU0EzTGpNMElERTJMalkySURFemJEVXVOall0TlM0Mk5pMDFMalkyTFRVdU5qVjZJaTgrUEM5emRtYysiOm51bGwpLGQobXhSZXNvdXJjZXMuZ2V0KCJmb3JtYXQiKSxsLmFjdGlvbnMuZ2V0KCJ0b2dnbGVGb3JtYXQiKS5mdW5jdCxudWxsLG14UmVzb3VyY2VzLmdldCgiZm9ybWF0IikrIiAoIitsLmFjdGlvbnMuZ2V0KCJmb3JtYXRQYW5lbCIpLnNob3J0Y3V0KyIpIixsLmFjdGlvbnMuZ2V0KCJpbWFnZSIpLAphPyJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlOQ0lnYUdWcFoyaDBQU0l5TkNJZ2RtbGxkMEp2ZUQwaU1DQXdJREkwSURJMElqNDhjR0YwYUNCa1BTSk5NVElnTTJNdE5DNDVOeUF3TFRrZ05DNHdNeTA1SURsek5DNHdNeUE1SURrZ09XTXVPRE1nTUNBeExqVXRMalkzSURFdU5TMHhMalVnTUMwdU16a3RMakUxTFM0M05DMHVNemt0TVM0d01TMHVNak10TGpJMkxTNHpPQzB1TmpFdExqTTRMUzQ1T1NBd0xTNDRNeTQyTnkweExqVWdNUzQxTFRFdU5VZ3hObU15TGpjMklEQWdOUzB5TGpJMElEVXROU0F3TFRRdU5ESXROQzR3TXkwNExUa3RPSHB0TFRVdU5TQTVZeTB1T0RNZ01DMHhMalV0TGpZM0xURXVOUzB4TGpWVE5TNDJOeUE1SURZdU5TQTVJRGdnT1M0Mk55QTRJREV3TGpVZ055NHpNeUF4TWlBMkxqVWdNVEo2YlRNdE5FTTRMalkzSURnZ09DQTNMak16SURnZ05pNDFVemd1TmpjZ05TQTVMalVnTlhNeExqVXVOamNnTVM0MUlERXVOVk14TUM0ek15QTRJRGt1TlNBNGVtMDFJREJqTFM0NE15QXdMVEV1TlMwdU5qY3RNUzQxTFRFdU5WTXhNeTQyTnlBMUlERTBMalVnTlhNeExqVXVOamNnTVM0MUlERXVOVk14TlM0ek15QTRJREUwTGpVZ09IcHRNeUEwWXkwdU9ETWdNQzB4TGpVdExqWTNMVEV1TlMweExqVlRNVFl1TmpjZ09TQXhOeTQxSURsek1TNDFMalkzSURFdU5TQXhMalV0TGpZM0lERXVOUzB4TGpVZ01TNDFlaUl2UGp3dmMzWm5QZz09IjoKbnVsbCldLGE/NjA6bnVsbCk7Yz1iKCJpbnNlcnQiLCEwLGE/ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWo0OGNHRjBhQ0JrUFNKTk1Ua2dNVE5vTFRaMk5tZ3RNbll0TmtnMWRpMHlhRFpXTldneWRqWm9Obll5ZWlJdlBqd3ZjM1puUGc9PSI6bnVsbCk7ZShbYyxkKG14UmVzb3VyY2VzLmdldCgiZGVsZXRlIiksbC5hY3Rpb25zLmdldCgiZGVsZXRlIikuZnVuY3QsbnVsbCxteFJlc291cmNlcy5nZXQoImRlbGV0ZSIpLGwuYWN0aW9ucy5nZXQoImRlbGV0ZSIpLGE/ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWo0OGNHRjBhQ0JrUFNKTk5pQXhPV013SURFdU1TNDVJRElnTWlBeWFEaGpNUzR4SURBZ01pMHVPU0F5TFRKV04wZzJkakV5ZWsweE9TQTBhQzB6TGpWc0xURXRNV2d0Tld3dE1TQXhTRFYyTW1neE5GWTBlaUl2UGp3dmMzWm5QZz09IjoKbnVsbCldLGE/NjA6bnVsbCk7aWYoNDExPD1mJiYoYz1sLmFjdGlvbnMuZ2V0KCJ1bmRvIiksYT1sLmFjdGlvbnMuZ2V0KCJyZWRvIiksYz1kKCIiLGMuZnVuY3QsbnVsbCxteFJlc291cmNlcy5nZXQoInVuZG8iKSsiICgiK2Muc2hvcnRjdXQrIikiLGMsImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWo0OGNHRjBhQ0JrUFNKTk1USXVOU0E0WXkweUxqWTFJREF0TlM0d05TNDVPUzAyTGprZ01pNDJURElnTjNZNWFEbHNMVE11TmpJdE15NDJNbU14TGpNNUxURXVNVFlnTXk0eE5pMHhMamc0SURVdU1USXRNUzQ0T0NBekxqVTBJREFnTmk0MU5TQXlMak14SURjdU5pQTFMalZzTWk0ek55MHVOemhETWpFdU1EZ2dNVEV1TURNZ01UY3VNVFVnT0NBeE1pNDFJRGg2SWk4K1BDOXpkbWMrIiksYT1kKCIiLAphLmZ1bmN0LG51bGwsbXhSZXNvdXJjZXMuZ2V0KCJyZWRvIikrIiAoIithLnNob3J0Y3V0KyIpIixhLCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlOQ0lnYUdWcFoyaDBQU0l5TkNJZ2RtbGxkMEp2ZUQwaU1DQXdJREkwSURJMElqNDhjR0YwYUNCa1BTSk5NVGd1TkNBeE1DNDJRekUyTGpVMUlEZ3VPVGtnTVRRdU1UVWdPQ0F4TVM0MUlEaGpMVFF1TmpVZ01DMDRMalU0SURNdU1ETXRPUzQ1TmlBM0xqSXlURE11T1NBeE5tTXhMakExTFRNdU1Ua2dOQzR3TlMwMUxqVWdOeTQyTFRVdU5TQXhMamsxSURBZ015NDNNeTQzTWlBMUxqRXlJREV1T0RoTU1UTWdNVFpvT1ZZM2JDMHpMallnTXk0MmVpSXZQand2YzNablBnPT0iKSxlKFtjLGFdLDYwKSw0ODA8PWYpKXt2YXIgYT1sLmFjdGlvbnMuZ2V0KCJ6b29tSW4iKSxjPWwuYWN0aW9ucy5nZXQoInpvb21PdXQiKSxnPWwuYWN0aW9ucy5nZXQoInJlc2V0VmlldyIpOwplKFtkKCIiLGZ1bmN0aW9uKCl7bS5wb3B1cE1lbnVIYW5kbGVyLmhpZGVNZW51KCk7dmFyIGE9bS52aWV3LnNjYWxlLGI9bS52aWV3LnRyYW5zbGF0ZS54LGM9bS52aWV3LnRyYW5zbGF0ZS55O2wuYWN0aW9ucy5nZXQoInJlc2V0VmlldyIpLmZ1bmN0KCk7MUUtNT5NYXRoLmFicyhhLW0udmlldy5zY2FsZSkmJmI9PW0udmlldy50cmFuc2xhdGUueCYmYz09bS52aWV3LnRyYW5zbGF0ZS55JiZsLmFjdGlvbnMuZ2V0KG0ucGFnZVZpc2libGU/ImZpdFBhZ2UiOiJmaXRXaW5kb3ciKS5mdW5jdCgpfSwhMCxteFJlc291cmNlcy5nZXQoImZpdCIpKyIgKCIrRWRpdG9yLmN0cmxLZXkrIitIKSIsZywiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJajQ4Y0dGMGFDQmtQU0pOTXlBMWRqUm9NbFkxYURSV00wZzFZeTB4TGpFZ01DMHlJQzQ1TFRJZ01ucHRNaUF4TUVnemRqUmpNQ0F4TGpFdU9TQXlJRElnTW1nMGRpMHlTRFYyTFRSNmJURTBJRFJvTFRSMk1tZzBZekV1TVNBd0lESXRMamtnTWkweWRpMDBhQzB5ZGpSNmJUQXRNVFpvTFRSMk1tZzBkalJvTWxZMVl6QXRNUzR4TFM0NUxUSXRNaTB5ZWlJdlBqd3ZjM1puUGc9PSIpLAo2NDA8PWY/ZCgiIixhLmZ1bmN0LCEwLG14UmVzb3VyY2VzLmdldCgiem9vbUluIikrIiAoIitFZGl0b3IuY3RybEtleSsiICspIixhLCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlOQ0lnYUdWcFoyaDBQU0l5TkNJZ2RtbGxkMEp2ZUQwaU1DQXdJREkwSURJMElqNDhjR0YwYUNCa1BTSk5NVFV1TlNBeE5HZ3RMamM1YkMwdU1qZ3RMakkzUXpFMUxqUXhJREV5TGpVNUlERTJJREV4TGpFeElERTJJRGt1TlNBeE5pQTFMamt4SURFekxqQTVJRE1nT1M0MUlETlRNeUExTGpreElETWdPUzQxSURVdU9URWdNVFlnT1M0MUlERTJZekV1TmpFZ01DQXpMakE1TFM0MU9TQTBMakl6TFRFdU5UZHNMakkzTGpJNGRpNDNPV3cxSURRdU9UbE1NakF1TkRrZ01UbHNMVFF1T1RrdE5YcHRMVFlnTUVNM0xqQXhJREUwSURVZ01URXVPVGtnTlNBNUxqVlROeTR3TVNBMUlEa3VOU0ExSURFMElEY3VNREVnTVRRZ09TNDFJREV4TGprNUlERTBJRGt1TlNBeE5IcHRNaTQxTFRSb0xUSjJNa2c1ZGkweVNEZFdPV2d5Vmpkb01YWXlhREoyTVhvaUx6NDhMM04yWno0PSIpOgpudWxsLDY0MDw9Zj9kKCIiLGMuZnVuY3QsITAsbXhSZXNvdXJjZXMuZ2V0KCJ6b29tT3V0IikrIiAoIitFZGl0b3IuY3RybEtleSsiIC0pIixjLCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlOQ0lnYUdWcFoyaDBQU0l5TkNJZ2RtbGxkMEp2ZUQwaU1DQXdJREkwSURJMElqNDhjR0YwYUNCa1BTSk5NVFV1TlNBeE5HZ3RMamM1YkMwdU1qZ3RMakkzUXpFMUxqUXhJREV5TGpVNUlERTJJREV4TGpFeElERTJJRGt1TlNBeE5pQTFMamt4SURFekxqQTVJRE1nT1M0MUlETlRNeUExTGpreElETWdPUzQxSURVdU9URWdNVFlnT1M0MUlERTJZekV1TmpFZ01DQXpMakE1TFM0MU9TQTBMakl6TFRFdU5UZHNMakkzTGpJNGRpNDNPV3cxSURRdU9UbE1NakF1TkRrZ01UbHNMVFF1T1RrdE5YcHRMVFlnTUVNM0xqQXhJREUwSURVZ01URXVPVGtnTlNBNUxqVlROeTR3TVNBMUlEa3VOU0ExSURFMElEY3VNREVnTVRRZ09TNDFJREV4TGprNUlERTBJRGt1TlNBeE5IcE5OeUE1YURWMk1VZzNlaUl2UGp3dmMzWm5QZz09Iik6Cm51bGxdLDYwKX1hPWwubWVudXMuZ2V0KCJsYW5ndWFnZSIpO251bGwhPWEmJiFteENsaWVudC5JU19DSFJPTUVBUFAmJiFFZGl0b3JVaS5pc0VsZWN0cm9uQXBwJiY2MDA8PWY/KG51bGw9PVAmJihjPXEuYWRkTWVudSgiIixhLmZ1bmN0KSxjLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgibGFuZ3VhZ2UiKSksYy5jbGFzc05hbWU9ImdlVG9vbGJhckJ1dHRvbiIsYy5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2U9InVybCgiK0VkaXRvci5nbG9iZUltYWdlKyIpIixjLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbj0iY2VudGVyIGNlbnRlciIsYy5zdHlsZS5iYWNrZ3JvdW5kUmVwZWF0PSJuby1yZXBlYXQiLGMuc3R5bGUuYmFja2dyb3VuZFNpemU9IjI0cHggMjRweCIsYy5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiLGMuc3R5bGUuaGVpZ2h0PSIyNHB4IixjLnN0eWxlLndpZHRoPSIyNHB4IixjLnN0eWxlLnpJbmRleD0iMSIsYy5zdHlsZS5yaWdodD0iOHB4IixjLnN0eWxlLmN1cnNvcj0KInBvaW50ZXIiLGMuc3R5bGUudG9wPSIxIj09dXJsUGFyYW1zLmVtYmVkPyIxMnB4IjoiMTFweCIsbi5hcHBlbmRDaGlsZChjKSxQPWMpLGwuYnV0dG9uQ29udGFpbmVyLnN0eWxlLnBhZGRpbmdSaWdodD0iMzRweCIpOihsLmJ1dHRvbkNvbnRhaW5lci5zdHlsZS5wYWRkaW5nUmlnaHQ9IjRweCIsbnVsbCE9UCYmKFAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChQKSxQPW51bGwpKX10LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgaz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtrLnN0eWxlLmNzc1RleHQ9InBvc2l0aW9uOmFic29sdXRlO2xlZnQ6MHB4O3JpZ2h0OjBweDt0b3A6MHB4O292ZXJmbG93LXk6YXV0bztvdmVyZmxvdy14OmhpZGRlbjsiO2suc3R5bGUuYm90dG9tPSIxIiE9dXJsUGFyYW1zLmVtYmVkfHwiMSI9PXVybFBhcmFtcy5saWJyYXJpZXM/IjYzcHgiOiIzMnB4Ijt0aGlzLnNpZGViYXI9dGhpcy5jcmVhdGVTaWRlYmFyKGspOygxRTM8PWZ8fG51bGwhPXVybFBhcmFtcy5jbGlic3x8Cm51bGwhPXVybFBhcmFtcy5saWJzKSYmYyh0aGlzLCEwKTsxRTM8PWYmJmEodGhpcywhMCk7dmFyIGw9dGhpcyxtPWwuZWRpdG9yLmdyYXBoO2wudG9vbGJhcj10aGlzLmNyZWF0ZVRvb2xiYXIobC5jcmVhdGVEaXYoImdlVG9vbGJhciIpKTtsLmRlZmF1bHRMaWJyYXJ5TmFtZT1teFJlc291cmNlcy5nZXQoInVudGl0bGVkTGlicmFyeSIpO3ZhciBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO24uc3R5bGUuY3NzVGV4dD0icG9zaXRpb246YWJzb2x1dGU7bGVmdDowcHg7cmlnaHQ6MHB4O3RvcDowcHg7aGVpZ2h0OjMwcHg7cGFkZGluZzo4cHg7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgbGlnaHRncmF5O2JhY2tncm91bmQtY29sb3I6I2ZmZmZmZjt0ZXh0LWFsaWduOmxlZnQ7d2hpdGUtc3BhY2U6bm93cmFwOyI7dmFyIHA9bnVsbCxxPW5ldyBNZW51YmFyKGwsbik7bC5zdGF0dXNDb250YWluZXI9bC5jcmVhdGVTdGF0dXNDb250YWluZXIoKTtsLnN0YXR1c0NvbnRhaW5lci5zdHlsZS5wb3NpdGlvbj0KInJlbGF0aXZlIjtsLnN0YXR1c0NvbnRhaW5lci5zdHlsZS5tYXhXaWR0aD0iIjtsLnN0YXR1c0NvbnRhaW5lci5zdHlsZS5tYXJnaW5Ub3A9IjdweCI7bC5zdGF0dXNDb250YWluZXIuc3R5bGUubWFyZ2luTGVmdD0iNnB4IjtsLnN0YXR1c0NvbnRhaW5lci5zdHlsZS5jb2xvcj0iZ3JheSI7bC5zdGF0dXNDb250YWluZXIuc3R5bGUuY3Vyc29yPSJkZWZhdWx0IjtsLmVkaXRvci5hZGRMaXN0ZW5lcigic3RhdHVzQ2hhbmdlZCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtsLnNldFN0YXR1c1RleHQobC5lZGl0b3IuZ2V0U3RhdHVzKCkpfSkpO3ZhciB2PWwuZGVzY3JpcHRvckNoYW5nZWQ7bC5kZXNjcmlwdG9yQ2hhbmdlZD1mdW5jdGlvbigpe3YuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciBhPWwuZ2V0Q3VycmVudEZpbGUoKTtpZihudWxsIT1hJiZudWxsIT1hLmdldFRpdGxlKCkpe3ZhciBiPWEuZ2V0TW9kZSgpOyJnb29nbGUiPT1iP2I9Imdvb2dsZURyaXZlIjoiZ2l0aHViIj09CmI/Yj0iZ2l0SHViIjoiZ2l0bGFiIj09Yj9iPSJnaXRMYWIiOiJvbmVkcml2ZSI9PWImJihiPSJvbmVEcml2ZSIpO2I9bXhSZXNvdXJjZXMuZ2V0KGIpO24uc2V0QXR0cmlidXRlKCJ0aXRsZSIsYS5nZXRUaXRsZSgpKyhudWxsIT1iPyIgKCIrYisiKSI6IiIpKX1lbHNlIG4ucmVtb3ZlQXR0cmlidXRlKCJ0aXRsZSIpfTtsLnNldFN0YXR1c1RleHQobC5lZGl0b3IuZ2V0U3RhdHVzKCkpO24uYXBwZW5kQ2hpbGQobC5zdGF0dXNDb250YWluZXIpO2wuYnV0dG9uQ29udGFpbmVyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2wuYnV0dG9uQ29udGFpbmVyLnN0eWxlLmNzc1RleHQ9InBvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjBweDtwYWRkaW5nLXJpZ2h0OjM0cHg7dG9wOjEwcHg7d2hpdGUtc3BhY2U6bm93cmFwO3BhZGRpbmctdG9wOjJweDtiYWNrZ3JvdW5kLWNvbG9yOmluaGVyaXQ7IjtuLmFwcGVuZENoaWxkKGwuYnV0dG9uQ29udGFpbmVyKTtsLm1lbnViYXJDb250YWluZXI9CmwuYnV0dG9uQ29udGFpbmVyO2wudGFiQ29udGFpbmVyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2wudGFiQ29udGFpbmVyLnN0eWxlLmNzc1RleHQ9InBvc2l0aW9uOmFic29sdXRlO2xlZnQ6MHB4O3JpZ2h0OjBweDtib3R0b206MHB4O2hlaWdodDozMHB4O3doaXRlLXNwYWNlOm5vd3JhcDtib3JkZXItYm90dG9tOjFweCBzb2xpZCBsaWdodGdyYXk7YmFja2dyb3VuZC1jb2xvcjojZmZmZmZmO2JvcmRlci10b3A6MXB4IHNvbGlkIGxpZ2h0Z3JheTttYXJnaW4tYm90dG9tOi0ycHg7dmlzaWJpbGl0eTpoaWRkZW47Ijt2YXIgaz1sLmRpYWdyYW1Db250YWluZXIucGFyZW50Tm9kZSx1PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO3Uuc3R5bGUuY3NzVGV4dD0icG9zaXRpb246YWJzb2x1dGU7dG9wOjBweDtsZWZ0OjBweDtyaWdodDowcHg7Ym90dG9tOjBweDtvdmVyZmxvdzpoaWRkZW47IjtsLmRpYWdyYW1Db250YWluZXIuc3R5bGUudG9wPSI0N3B4Ijt2YXIgSz0KbC5tZW51cy5nZXQoInZpZXdab29tIik7aWYobnVsbCE9Syl7dGhpcy50YWJDb250YWluZXIuc3R5bGUucmlnaHQ9IjcwcHgiO3ZhciBCPXEuYWRkTWVudSgiMTAwJSIsSy5mdW5jdCk7Qi5zZXRBdHRyaWJ1dGUoInRpdGxlIixteFJlc291cmNlcy5nZXQoInpvb20iKSsiIChBbHQrTW91c2V3aGVlbCkiKTtCLnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCI7Qi5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2U9InVybCgiK214V2luZG93LnByb3RvdHlwZS5taW5pbWl6ZUltYWdlKyIpIjtCLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbj0icmlnaHQgNnB4IGNlbnRlciI7Qi5zdHlsZS5iYWNrZ3JvdW5kUmVwZWF0PSJuby1yZXBlYXQiO0Iuc3R5bGUuYmFja2dyb3VuZENvbG9yPSIjZmZmZmZmIjtCLnN0eWxlLnBhZGRpbmdSaWdodD0iMTBweCI7Qi5zdHlsZS5kaXNwbGF5PSJibG9jayI7Qi5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO0Iuc3R5bGUudGV4dERlY29yYXRpb249Im5vbmUiO0Iuc3R5bGUudGV4dERlY29yYXRpb249CiJub25lIjtCLnN0eWxlLnJpZ2h0PSIwcHgiO0Iuc3R5bGUuYm90dG9tPSIwcHgiO0Iuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiI7Qi5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4iO0Iuc3R5bGUudGV4dEFsaWduPSJjZW50ZXIiO0Iuc3R5bGUuY29sb3I9IiMwMDAiO0Iuc3R5bGUuZm9udFNpemU9IjEycHgiO0Iuc3R5bGUuY29sb3I9IiM3MDcwNzAiO0Iuc3R5bGUud2lkdGg9IjU5cHgiO0Iuc3R5bGUuY3Vyc29yPSJwb2ludGVyIjtCLnN0eWxlLmJvcmRlclRvcD0iMXB4IHNvbGlkIGxpZ2h0Z3JheSI7Qi5zdHlsZS5ib3JkZXJMZWZ0PSIxcHggc29saWQgbGlnaHRncmF5IjtCLnN0eWxlLmhlaWdodD1wYXJzZUludChsLnRhYkNvbnRhaW5lckhlaWdodCktMSsicHgiO0Iuc3R5bGUubGluZUhlaWdodD1wYXJzZUludChsLnRhYkNvbnRhaW5lckhlaWdodCkrMSsicHgiO3UuYXBwZW5kQ2hpbGQoQik7Sz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe0IuaW5uZXJIVE1MPU1hdGgucm91bmQoMTAwKgpsLmVkaXRvci5ncmFwaC52aWV3LnNjYWxlKSsiJSJ9KTtsLmVkaXRvci5ncmFwaC52aWV3LmFkZExpc3RlbmVyKG14RXZlbnQuRVZFTlRfU0NBTEUsSyk7bC5lZGl0b3IuYWRkTGlzdGVuZXIoInJlc2V0R3JhcGhWaWV3IixLKTtsLmVkaXRvci5hZGRMaXN0ZW5lcigicGFnZVNlbGVjdGVkIixLKTt2YXIgTT1sLnNldEdyYXBoRW5hYmxlZDtsLnNldEdyYXBoRW5hYmxlZD1mdW5jdGlvbigpe00uYXBwbHkodGhpcyxhcmd1bWVudHMpO251bGwhPXRoaXMudGFiQ29udGFpbmVyJiYoQi5zdHlsZS52aXNpYmlsaXR5PXRoaXMudGFiQ29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHksdGhpcy5kaWFncmFtQ29udGFpbmVyLnN0eWxlLmJvdHRvbT0iaGlkZGVuIiE9dGhpcy50YWJDb250YWluZXIuc3R5bGUudmlzaWJpbGl0eT90aGlzLnRhYkNvbnRhaW5lckhlaWdodCsicHgiOiIwcHgiKX19dS5hcHBlbmRDaGlsZChsLnRhYkNvbnRhaW5lcik7dS5hcHBlbmRDaGlsZChuKTt1LmFwcGVuZENoaWxkKGwuZGlhZ3JhbUNvbnRhaW5lcik7CmsuYXBwZW5kQ2hpbGQodSk7bC51cGRhdGVUYWJDb250YWluZXIoKTt2YXIgUD1udWxsO2coKTtteEV2ZW50LmFkZExpc3RlbmVyKHdpbmRvdywicmVzaXplIixmdW5jdGlvbigpe2coKTtudWxsIT1sLnNpZGViYXJXaW5kb3cmJmwuc2lkZWJhcldpbmRvdy53aW5kb3cuZml0KCk7bnVsbCE9bC5mb3JtYXRXaW5kb3cmJmwuZm9ybWF0V2luZG93LndpbmRvdy5maXQoKTtudWxsIT1sLmFjdGlvbnMub3V0bGluZVdpbmRvdyYmbC5hY3Rpb25zLm91dGxpbmVXaW5kb3cud2luZG93LmZpdCgpO251bGwhPWwuYWN0aW9ucy5sYXllcnNXaW5kb3cmJmwuYWN0aW9ucy5sYXllcnNXaW5kb3cud2luZG93LmZpdCgpO251bGwhPWwubWVudXMudGFnc1dpbmRvdyYmbC5tZW51cy50YWdzV2luZG93LndpbmRvdy5maXQoKTtudWxsIT1sLm1lbnVzLmZpbmRXaW5kb3cmJmwubWVudXMuZmluZFdpbmRvdy53aW5kb3cuZml0KCl9KX19fTsKKGZ1bmN0aW9uKCl7dmFyIGE9ITE7Im1pbiIhPXVpVGhlbWV8fGF8fG14Q2xpZW50LklTX0NIUk9NRUFQUHx8KEVkaXRvclVpLmluaXRNaW5pbWFsVGhlbWUoKSxhPSEwKTt2YXIgYz1FZGl0b3JVaS5pbml0VGhlbWU7RWRpdG9yVWkuaW5pdFRoZW1lPWZ1bmN0aW9uKCl7Yy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7Im1pbiIhPXVpVGhlbWV8fGF8fCh0aGlzLmluaXRNaW5pbWFsVGhlbWUoKSxhPSEwKX19KSgpO0RyYXdpb0NvbW1lbnQ9ZnVuY3Rpb24oYSxjLGYsZCxtLGsscSl7dGhpcy5maWxlPWE7dGhpcy5pZD1jO3RoaXMuY29udGVudD1mO3RoaXMubW9kaWZpZWREYXRlPWQ7dGhpcy5jcmVhdGVkRGF0ZT1tO3RoaXMuaXNSZXNvbHZlZD1rO3RoaXMudXNlcj1xO3RoaXMucmVwbGllcz1bXX07RHJhd2lvQ29tbWVudC5wcm90b3R5cGUuYWRkUmVwbHlEaXJlY3Q9ZnVuY3Rpb24oYSl7bnVsbCE9YSYmdGhpcy5yZXBsaWVzLnB1c2goYSl9O0RyYXdpb0NvbW1lbnQucHJvdG90eXBlLmFkZFJlcGx5PWZ1bmN0aW9uKGEsYyxmLGQsbSl7YygpfTtEcmF3aW9Db21tZW50LnByb3RvdHlwZS5lZGl0Q29tbWVudD1mdW5jdGlvbihhLGMsZil7YygpfTtEcmF3aW9Db21tZW50LnByb3RvdHlwZS5kZWxldGVDb21tZW50PWZ1bmN0aW9uKGEsYyl7YSgpfTtEcmF3aW9Vc2VyPWZ1bmN0aW9uKGEsYyxmLGQsbSl7dGhpcy5pZD1hO3RoaXMuZW1haWw9Yzt0aGlzLmRpc3BsYXlOYW1lPWY7dGhpcy5waWN0dXJlVXJsPWQ7dGhpcy5sb2NhbGU9bX07bXhSZXNvdXJjZXMucGFyc2UoJyMgKkRPIE5PVCBESVJFQ1RMWSBFRElUIFRISVMgRklMRSwgSVQgSVMgQVVUT01BVElDQUxMWSBHRU5FUkFURUQgQU5EIElUIElTIEJBU0VEIE9OOipcbiMgaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXQvY2NjP2tleT0wQW1RRU8zNmxpTDRGZERKTFdWTk1hVlYyVW1SS1NucFhVMDlNWWtkR2JFRVxuYWJvdXQ9QWJvdXQgXG5hYm91dERyYXdpbz1BYm91dCBkcmF3LmlvXG5hY2Nlc3NEZW5pZWQ9QWNjZXNzIERlbmllZFxuYWN0aW9uPUFjdGlvblxuYWN0dWFsU2l6ZT1BY3R1YWwgU2l6ZVxuYWRkPUFkZFxuYWRkQWNjb3VudD1BZGQgYWNjb3VudFxuYWRkZWRGaWxlPUFkZGVkIHsxfVxuYWRkSW1hZ2VzPUFkZCBJbWFnZXNcbmFkZEltYWdlVXJsPUFkZCBJbWFnZSBVUkxcbmFkZExheWVyPUFkZCBMYXllclxuYWRkUHJvcGVydHk9QWRkIFByb3BlcnR5XG5hZGRyZXNzPUFkZHJlc3NcbmFkZFRvRXhpc3RpbmdEcmF3aW5nPUFkZCB0byBFeGlzdGluZyBEcmF3aW5nXG5hZGRXYXlwb2ludD1BZGQgV2F5cG9pbnRcbmFkanVzdFRvPUFkanVzdCB0b1xuYWR2YW5jZWQ9QWR2YW5jZWRcbmFsaWduPUFsaWduXG5hbGlnbm1lbnQ9QWxpZ25tZW50XG5hbGxDaGFuZ2VzTG9zdD1BbGwgY2hhbmdlcyB3aWxsIGJlIGxvc3QhXG5hbGxQYWdlcz1BbGwgUGFnZXNcbmFsbFByb2plY3RzPUFsbCBQcm9qZWN0c1xuYWxsU3BhY2VzPUFsbCBTcGFjZXNcbmFsbFRhZ3M9QWxsIFRhZ3NcbmFuY2hvcj1BbmNob3JcbmFuZHJvaWQ9QW5kcm9pZFxuYW5nbGU9QW5nbGVcbmFyYz1BcmNcbmFyZVlvdVN1cmU9QXJlIHlvdSBzdXJlP1xuZW5zdXJlRGF0YVNhdmVkPVBsZWFzZSBlbnN1cmUgeW91ciBkYXRhIGlzIHNhdmVkIGJlZm9yZSBjbG9zaW5nLlxuYWxsQ2hhbmdlc1NhdmVkPUFsbCBjaGFuZ2VzIHNhdmVkXG5hbGxDaGFuZ2VzU2F2ZWRJbkRyaXZlPUFsbCBjaGFuZ2VzIHNhdmVkIGluIERyaXZlXG5hbGxvd1BvcHVwcz1BbGxvdyBwb3AtdXBzIHRvIGF2b2lkIHRoaXMgZGlhbG9nLlxuYWxsb3dSZWxhdGl2ZVVybD1BbGxvdyByZWxhdGl2ZSBVUkxcbmFscmVhZHlDb25uZWN0ZWQ9Tm9kZXMgYWxyZWFkeSBjb25uZWN0ZWRcbmFwcGx5PUFwcGx5XG5hcmNoaU1hdGUyMT1BcmNoaU1hdGUgMi4xXG5hcnJhbmdlPUFycmFuZ2VcbmFycm93PUFycm93XG5hcnJvd3M9QXJyb3dzXG5hc05ldz1BcyBOZXdcbmF0bGFzPUF0bGFzXG5hdXRob3I9QXV0aG9yXG5hdXRob3JpemF0aW9uUmVxdWlyZWQ9QXV0aG9yaXphdGlvbiByZXF1aXJlZFxuYXV0aG9yaXplVGhpc0FwcEluPUF1dGhvcml6ZSB0aGlzIGFwcCBpbiB7MX06XG5hdXRob3JpemU9QXV0aG9yaXplXG5hdXRob3JpemluZz1BdXRob3JpemluZ1xuYXV0b21hdGljPUF1dG9tYXRpY1xuYXV0b3NhdmU9QXV0b3NhdmVcbmF1dG9zaXplPUF1dG9zaXplXG5hdHRhY2htZW50cz1BdHRhY2htZW50c1xuYXdzPUFXU1xuYXdzM2Q9QVdTIDNEXG5henVyZT1BenVyZVxuYmFjaz1CYWNrXG5iYWNrZ3JvdW5kPUJhY2tncm91bmRcbmJhY2tncm91bmRDb2xvcj1CYWNrZ3JvdW5kIENvbG9yXG5iYWNrZ3JvdW5kSW1hZ2U9QmFja2dyb3VuZCBJbWFnZVxuYmFzaWM9QmFzaWNcbmJsYW5rRHJhd2luZz1CbGFuayBEcmF3aW5nXG5ibGFua0RpYWdyYW09QmxhbmsgRGlhZ3JhbVxuYmxvY2s9QmxvY2tcbmJsb2NrcXVvdGU9QmxvY2txdW90ZVxuYmxvZz1CbG9nXG5ib2xkPUJvbGRcbmJvb3RzdHJhcD1Cb290c3RyYXBcbmJvcmRlcj1Cb3JkZXJcbmJvcmRlckNvbG9yPUJvcmRlciBDb2xvclxuYm9yZGVyV2lkdGg9Qm9yZGVyIFdpZHRoXG5ib3R0b209Qm90dG9tXG5ib3R0b21BbGlnbj1Cb3R0b20gQWxpZ25cbmJvdHRvbUxlZnQ9Qm90dG9tIExlZnRcbmJvdHRvbVJpZ2h0PUJvdHRvbSBSaWdodFxuYnBtbj1CUE1OXG5icm93c2VyPUJyb3dzZXJcbmJ1bGxldGVkTGlzdD1CdWxsZXRlZCBMaXN0XG5idXNpbmVzcz1CdXNpbmVzc1xuYnVzeT1PcGVyYXRpb24gaW4gcHJvZ3Jlc3NcbmNhYmluZXRzPUNhYmluZXRzXG5jYW5jZWw9Q2FuY2VsXG5jZW50ZXI9Q2VudGVyXG5jYW5ub3RMb2FkPUxvYWQgYXR0ZW1wdHMgZmFpbGVkLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLlxuY2Fubm90TG9naW49TG9nIGluIGF0dGVtcHRzIGZhaWxlZC4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci5cbmNhbm5vdE9wZW5GaWxlPUNhbm5vdCBvcGVuIGZpbGVcbmNoYW5nZT1DaGFuZ2VcbmNoYW5nZU9yaWVudGF0aW9uPUNoYW5nZSBPcmllbnRhdGlvblxuY2hhbmdlVXNlcj1DaGFuZ2UgdXNlclxuY2hhbmdlU3RvcmFnZT1DaGFuZ2Ugc3RvcmFnZVxuY2hhbmdlc05vdFNhdmVkPUNoYW5nZXMgaGF2ZSBub3QgYmVlbiBzYXZlZFxuY2xhc3NEaWFncmFtPUNsYXNzIERpYWdyYW1cbnVzZXJKb2luZWQ9ezF9IGhhcyBqb2luZWRcbnVzZXJMZWZ0PXsxfSBoYXMgbGVmdFxuY2hhdFdpbmRvd1RpdGxlPUNoYXRcbmNob29zZUFuT3B0aW9uPUNob29zZSBhbiBvcHRpb25cbmNocm9tZUFwcD1DaHJvbWUgQXBwXG5jb2xsYWJvcmF0aXZlRWRpdGluZ05vdGljZT1JbXBvcnRhbnQgTm90aWNlIGZvciBDb2xsYWJvcmF0aXZlIEVkaXRpbmdcbmNvbXByZXNzZWQ9Q29tcHJlc3NlZFxuY29tbWl0TWVzc2FnZT1Db21taXQgTWVzc2FnZVxuY29uZmlnTGlua1dhcm49VGhpcyBsaW5rIGNvbmZpZ3VyZXMgZHJhdy5pby4gT25seSBjbGljayBPSyBpZiB5b3UgdHJ1c3Qgd2hvZXZlciBnYXZlIHlvdSBpdCFcbmNvbmZpZ0xpbmtDb25maXJtPUNsaWNrIE9LIHRvIGNvbmZpZ3VyZSBhbmQgcmVzdGFydCBkcmF3LmlvLlxuY3N2PUNTVlxuZGFyaz1EYXJrXG5kaWFncmFtWG1sRGVzYz1YTUwgRmlsZVxuZGlhZ3JhbUh0bWxEZXNjPUhUTUwgRmlsZVxuZGlhZ3JhbVBuZ0Rlc2M9RWRpdGFibGUgQml0bWFwIEltYWdlXG5kaWFncmFtU3ZnRGVzYz1FZGl0YWJsZSBWZWN0b3IgSW1hZ2VcbmRpZFlvdU1lYW5Ub0V4cG9ydFRvUGRmPURpZCB5b3UgbWVhbiB0byBleHBvcnQgdG8gUERGP1xuZHJhZnRGb3VuZD1BIGRyYWZ0IGZvciBcJ3sxfVwnIGhhcyBiZWVuIGZvdW5kLiBMb2FkIGl0IGludG8gdGhlIGVkaXRvciBvciBkaXNjYXJkIGl0IHRvIGNvbnRpbnVlLlxuc2VsZWN0RHJhZnQ9U2VsZWN0IGEgZHJhZnQgdG8gY29udGludWUgZWRpdGluZzpcbmRyYWdBbmREcm9wTm90U3VwcG9ydGVkPURyYWcgYW5kIGRyb3Agbm90IHN1cHBvcnRlZCBmb3IgaW1hZ2VzLiBXb3VsZCB5b3UgbGlrZSB0byBpbXBvcnQgaW5zdGVhZD9cbmRyb3Bib3hDaGFyc05vdEFsbG93ZWQ9VGhlIGZvbGxvd2luZyBjaGFyYWN0ZXJzIGFyZSBub3QgYWxsb3dlZDogIC8gOiA/ICogIiB8XG5jaGVjaz1DaGVja1xuY2hlY2tzdW09Q2hlY2tzdW1cbmNpcmNsZT1DaXJjbGVcbmNpc2NvPUNpc2NvXG5jbGFzc2ljPUNsYXNzaWNcbmNsZWFyRGVmYXVsdFN0eWxlPUNsZWFyIERlZmF1bHQgU3R5bGVcbmNsZWFyV2F5cG9pbnRzPUNsZWFyIFdheXBvaW50c1xuY2xpcGFydD1DbGlwYXJ0XG5jbG9zZT1DbG9zZVxuY2xvc2luZ0ZpbGU9Q2xvc2luZyBmaWxlXG5jb2xsYWJvcmF0b3I9Q29sbGFib3JhdG9yXG5jb2xsYWJvcmF0b3JzPUNvbGxhYm9yYXRvcnNcbmNvbGxhcHNlPUNvbGxhcHNlXG5jb2xsYXBzZUV4cGFuZD1Db2xsYXBzZS9FeHBhbmRcbmNvbGxhcHNlLWV4cGFuZD1DbGljayB0byBjb2xsYXBzZS9leHBhbmRcblNoaWZ0LWNsaWNrIHRvIG1vdmUgbmVpZ2hib3JzIFxuQWx0LWNsaWNrIHRvIHByb3RlY3QgZ3JvdXAgc2l6ZVxuY29sbGFwc2libGU9Q29sbGFwc2libGVcbmNvbWljPUNvbWljXG5jb21tZW50PUNvbW1lbnRcbmNvbW1lbnRzTm90ZXM9Q29tbWVudHMvTm90ZXNcbmNvbXByZXNzPUNvbXByZXNzXG5jb25maWd1cmF0aW9uPUNvbmZpZ3VyYXRpb25cbmNvbm5lY3Q9Q29ubmVjdFxuY29ubmVjdGluZz1Db25uZWN0aW5nXG5jb25uZWN0V2l0aERyaXZlPUNvbm5lY3Qgd2l0aCBHb29nbGUgRHJpdmVcbmNvbm5lY3Rpb249Q29ubmVjdGlvblxuY29ubmVjdGlvbkFycm93cz1Db25uZWN0aW9uIEFycm93c1xuY29ubmVjdGlvblBvaW50cz1Db25uZWN0aW9uIFBvaW50c1xuY29uc3RyYWluUHJvcG9ydGlvbnM9Q29uc3RyYWluIFByb3BvcnRpb25zXG5jb250YWluc1ZhbGlkYXRpb25FcnJvcnM9Q29udGFpbnMgdmFsaWRhdGlvbiBlcnJvcnNcbmNvcGllZFRvQ2xpcGJvYXJkPUNvcGllZCB0byBjbGlwYm9hcmRcbmNvcHk9Q29weVxuY29weUNvbm5lY3Q9Q29weSBvbiBjb25uZWN0XG5jb3B5Q3JlYXRlZD1BIGNvcHkgb2YgdGhlIGZpbGUgd2FzIGNyZWF0ZWQuXG5jb3B5T2Y9Q29weSBvZiB7MX1cbmNvcHlPZkRyYXdpbmc9Q29weSBvZiBEcmF3aW5nXG5jb3B5U2l6ZT1Db3B5IFNpemVcbmNvcHlTdHlsZT1Db3B5IFN0eWxlXG5jcmVhdGU9Q3JlYXRlXG5jcmVhdGVOZXdEaWFncmFtPUNyZWF0ZSBOZXcgRGlhZ3JhbVxuY3JlYXRlUmV2aXNpb249Q3JlYXRlIFJldmlzaW9uXG5jcmVhdGVTaGFwZT1DcmVhdGUgU2hhcGVcbmNyb3A9Q3JvcFxuY3VydmVkPUN1cnZlZFxuY3VzdG9tPUN1c3RvbVxuY3VycmVudD1DdXJyZW50XG5jdXJyZW50UGFnZT1DdXJyZW50IHBhZ2VcbmN1dD1DdXRcbmRhc2hlZD1EYXNoZWRcbmRlY2lkZUxhdGVyPURlY2lkZSBsYXRlclxuZGVmYXVsdD1EZWZhdWx0XG5kZWxldGU9RGVsZXRlXG5kZWxldGVDb2x1bW49RGVsZXRlIENvbHVtblxuZGVsZXRlTGlicmFyeTQwMT1JbnN1ZmZpY2llbnQgcGVybWlzc2lvbnMgdG8gZGVsZXRlIHRoaXMgbGlicmFyeVxuZGVsZXRlTGlicmFyeTQwND1TZWxlY3RlZCBsaWJyYXJ5IGNvdWxkIG5vdCBiZSBmb3VuZFxuZGVsZXRlTGlicmFyeTUwMD1FcnJvciBkZWxldGluZyBsaWJyYXJ5XG5kZWxldGVMaWJyYXJ5Q29uZmlybT1Zb3UgYXJlIGFib3V0IHRvIHBlcm1hbmVudGx5IGRlbGV0ZSB0aGlzIGxpYnJhcnkuIEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkbyB0aGlzP1xuZGVsZXRlUm93PURlbGV0ZSBSb3dcbmRlc2NyaXB0aW9uPURlc2NyaXB0aW9uXG5kZXZpY2U9RGV2aWNlXG5kaWFncmFtPURpYWdyYW1cbmRpYWdyYW1Db250ZW50PURpYWdyYW0gQ29udGVudFxuZGlhZ3JhbUxvY2tlZD1EaWFncmFtIGhhcyBiZWVuIGxvY2tlZCB0byBwcmV2ZW50IGZ1cnRoZXIgZGF0YSBsb3NzLlxuZGlhZ3JhbUxvY2tlZEJ5U2luY2U9VGhlIGRpYWdyYW0gaXMgbG9ja2VkIGJ5IHsxfSBzaW5jZSB7Mn0gYWdvXG5kaWFncmFtTmFtZT1EaWFncmFtIE5hbWVcbmRpYWdyYW1Jc1B1YmxpYz1EaWFncmFtIGlzIHB1YmxpY1xuZGlhZ3JhbUlzTm90UHVibGljPURpYWdyYW0gaXMgbm90IHB1YmxpY1xuZGlhbW9uZD1EaWFtb25kXG5kaWFtb25kVGhpbj1EaWFtb25kICh0aGluKVxuZGlkWW91S25vdz1EaWQgeW91IGtub3cuLi5cbmRpcmVjdGlvbj1EaXJlY3Rpb25cbmRpc2NhcmQ9RGlzY2FyZFxuZGlzY2FyZENoYW5nZXNBbmRSZWNvbm5lY3Q9RGlzY2FyZCBDaGFuZ2VzIGFuZCBSZWNvbm5lY3Rcbmdvb2dsZURyaXZlTWlzc2luZ0NsaWNrSGVyZT1Hb29nbGUgRHJpdmUgbWlzc2luZz8gQ2xpY2sgaGVyZSFcbmRpc2NhcmRDaGFuZ2VzPURpc2NhcmQgQ2hhbmdlc1xuZGlzY29ubmVjdGVkPURpc2Nvbm5lY3RlZFxuZGlzdHJpYnV0ZT1EaXN0cmlidXRlXG5kb25lPURvbmVcbmRvTm90U2hvd0FnYWluPURvIG5vdCBzaG93IGFnYWluXG5kb3R0ZWQ9RG90dGVkXG5kb3VibGVDbGlja09yaWVudGF0aW9uPURvdWJsZWNsaWNrIHRvIGNoYW5nZSBvcmllbnRhdGlvblxuZG91YmxlQ2xpY2tUb29sdGlwPURvdWJsZWNsaWNrIHRvIGluc2VydCB0ZXh0XG5kb3VibGVDbGlja0NoYW5nZVByb3BlcnR5PURvdWJsZWNsaWNrIHRvIGNoYW5nZSBwcm9wZXJ0eSBuYW1lXG5kb3dubG9hZD1Eb3dubG9hZFxuZG93bmxvYWREZXNrdG9wPUdldCBEZXNrdG9wXG5kb3dubG9hZEFzPURvd25sb2FkIGFzXG5jbGlja0hlcmVUb1NhdmU9Q2xpY2sgaGVyZSB0byBzYXZlLlxuZHBpPURQSVxuZHJhZnREaXNjYXJkZWQ9RHJhZnQgZGlzY2FyZGVkXG5kcmFmdFNhdmVkPURyYWZ0IHNhdmVkXG5kcmFnRWxlbWVudHNIZXJlPURyYWcgZWxlbWVudHMgaGVyZVxuZHJhZ0ltYWdlc0hlcmU9RHJhZyBpbWFnZXMgb3IgVVJMcyBoZXJlXG5kcmFnVXJsc0hlcmU9RHJhZyBVUkxzIGhlcmVcbmRyYXcuaW89ZHJhdy5pb1xuZHJhd2luZz1EcmF3aW5nezF9XG5kcmF3aW5nRW1wdHk9RHJhd2luZyBpcyBlbXB0eVxuZHJhd2luZ1Rvb0xhcmdlPURyYXdpbmcgaXMgdG9vIGxhcmdlXG5kcmF3aW9Gb3JXb3JrPURyYXcuaW8gZm9yIEdTdWl0ZVxuZHJvcGJveD1Ecm9wYm94XG5kdXBsaWNhdGU9RHVwbGljYXRlXG5kdXBsaWNhdGVJdD1EdXBsaWNhdGUgezF9XG5kaXZpZGVyPURpdmlkZXJcbmR4PUR4XG5keT1EeVxuZWFzdD1FYXN0XG5lZGl0PUVkaXRcbmVkaXREYXRhPUVkaXQgRGF0YVxuZWRpdERpYWdyYW09RWRpdCBEaWFncmFtXG5lZGl0R2VvbWV0cnk9RWRpdCBHZW9tZXRyeVxuZWRpdEltYWdlPUVkaXQgSW1hZ2VcbmVkaXRJbWFnZVVybD1FZGl0IEltYWdlIFVSTFxuZWRpdExpbms9RWRpdCBMaW5rXG5lZGl0U2hhcGU9RWRpdCBTaGFwZVxuZWRpdFN0eWxlPUVkaXQgU3R5bGVcbmVkaXRUZXh0PUVkaXQgVGV4dFxuZWRpdFRvb2x0aXA9RWRpdCBUb29sdGlwXG5nbGFzcz1HbGFzc1xuZ29vZ2xlSW1hZ2VzPUdvb2dsZSBJbWFnZXNcbmltYWdlU2VhcmNoPUltYWdlIFNlYXJjaFxuZWlwPUVJUFxuZW1iZWQ9RW1iZWRcbmVtYmVkSW1hZ2VzPUVtYmVkIEltYWdlc1xubWFpbkVtYmVkTm90aWNlPVBhc3RlIHRoaXMgaW50byB0aGUgcGFnZVxuZWxlY3RyaWNhbD1FbGVjdHJpY2FsXG5lbGxpcHNlPUVsbGlwc2VcbmVtYmVkTm90aWNlPVBhc3RlIHRoaXMgb25jZSBhdCB0aGUgZW5kIG9mIHRoZSBwYWdlXG5lbnRlckdyb3VwPUVudGVyIEdyb3VwXG5lbnRlck5hbWU9RW50ZXIgTmFtZVxuZW50ZXJQcm9wZXJ0eU5hbWU9RW50ZXIgUHJvcGVydHkgTmFtZVxuZW50ZXJWYWx1ZT1FbnRlciBWYWx1ZVxuZW50aXR5UmVsYXRpb249RW50aXR5IFJlbGF0aW9uXG5lbnRpdHlSZWxhdGlvbnNoaXBEaWFncmFtPUVudGl0eSBSZWxhdGlvbnNoaXAgRGlhZ3JhbVxuZXJyb3I9RXJyb3JcbmVycm9yRGVsZXRpbmdGaWxlPUVycm9yIGRlbGV0aW5nIGZpbGVcbmVycm9yTG9hZGluZ0ZpbGU9RXJyb3IgbG9hZGluZyBmaWxlXG5lcnJvclJlbmFtaW5nRmlsZT1FcnJvciByZW5hbWluZyBmaWxlXG5lcnJvclJlbmFtaW5nRmlsZU5vdEZvdW5kPUVycm9yIHJlbmFtaW5nIGZpbGUuIEZpbGUgd2FzIG5vdCBmb3VuZC5cbmVycm9yUmVuYW1pbmdGaWxlRm9yYmlkZGVuPUVycm9yIHJlbmFtaW5nIGZpbGUuIEluc3VmZmljaWVudCBhY2Nlc3MgcmlnaHRzLlxuZXJyb3JTYXZpbmdEcmFmdD1FcnJvciBzYXZpbmcgZHJhZnRcbmVycm9yU2F2aW5nRmlsZT1FcnJvciBzYXZpbmcgZmlsZVxuZXJyb3JTYXZpbmdGaWxlVW5rbm93bj1FcnJvciBhdXRob3JpemluZyB3aXRoIEdvb2dsZVwncyBzZXJ2ZXJzLiBQbGVhc2UgcmVmcmVzaCB0aGUgcGFnZSB0byByZS1hdHRlbXB0LlxuZXJyb3JTYXZpbmdGaWxlRm9yYmlkZGVuPUVycm9yIHNhdmluZyBmaWxlLiBJbnN1ZmZpY2llbnQgYWNjZXNzIHJpZ2h0cy5cbmVycm9yU2F2aW5nRmlsZU5hbWVDb25mbGljdD1Db3VsZCBub3Qgc2F2ZSBkaWFncmFtLiBDdXJyZW50IHBhZ2UgYWxyZWFkeSBjb250YWlucyBmaWxlIG5hbWVkIFwnezF9XCcuXG5lcnJvclNhdmluZ0ZpbGVOb3RGb3VuZD1FcnJvciBzYXZpbmcgZmlsZS4gRmlsZSB3YXMgbm90IGZvdW5kLlxuZXJyb3JTYXZpbmdGaWxlUmVhZE9ubHlNb2RlPUNvdWxkIG5vdCBzYXZlIGRpYWdyYW0gd2hpbGUgcmVhZC1vbmx5IG1vZGUgaXMgYWN0aXZlLlxuZXJyb3JTYXZpbmdGaWxlU2Vzc2lvblRpbWVvdXQ9WW91ciBzZXNzaW9uIGhhcyBlbmRlZC4gUGxlYXNlIDxhIHRhcmdldD1cJ19ibGFua1wnIGhyZWY9XCd7MX1cJz57Mn08L2E+IGFuZCByZXR1cm4gdG8gdGhpcyB0YWIgdG8gdHJ5IHRvIHNhdmUgYWdhaW4uXG5lcnJvclNlbmRpbmdGZWVkYmFjaz1FcnJvciBzZW5kaW5nIGZlZWRiYWNrLlxuZXJyb3JVcGRhdGluZ1ByZXZpZXc9RXJyb3IgdXBkYXRpbmcgcHJldmlldy5cbmV4aXQ9RXhpdFxuZXhpdEdyb3VwPUV4aXQgR3JvdXBcbmV4cGFuZD1FeHBhbmRcbmV4cG9ydD1FeHBvcnRcbmV4cG9ydGluZz1FeHBvcnRpbmdcbmV4cG9ydEFzPUV4cG9ydCBhc1xuZXhwb3J0T3B0aW9uc0Rpc2FibGVkPUV4cG9ydCBvcHRpb25zIGRpc2FibGVkXG5leHBvcnRPcHRpb25zRGlzYWJsZWREZXRhaWxzPVRoZSBvd25lciBoYXMgZGlzYWJsZWQgb3B0aW9ucyB0byBkb3dubG9hZCwgcHJpbnQgb3IgY29weSBmb3IgY29tbWVudGVycyBhbmQgdmlld2VycyBvbiB0aGlzIGZpbGUuXG5leHRlcm5hbENoYW5nZXM9RXh0ZXJuYWwgQ2hhbmdlc1xuZXh0cmFzPUV4dHJhc1xuZmFjZWJvb2s9RmFjZWJvb2tcbmZhaWxlZFRvU2F2ZVRyeVJlY29ubmVjdD1GYWlsZWQgdG8gc2F2ZSwgdHJ5aW5nIHRvIHJlY29ubmVjdFxuZmVhdHVyZVJlcXVlc3Q9RmVhdHVyZSBSZXF1ZXN0XG5mZWVkYmFjaz1GZWVkYmFja1xuZmVlZGJhY2tTZW50PUZlZWRiYWNrIHN1Y2Nlc3NmdWxseSBzZW50LlxuZmxvb3JwbGFucz1GbG9vcnBsYW5zXG5maWxlPUZpbGVcbmZpbGVDaGFuZ2VkT3ZlcndyaXRlRGlhbG9nPVRoZSBmaWxlIGhhcyBiZWVuIG1vZGlmaWVkLiBEbyB5b3Ugd2FudCB0byBzYXZlIHRoZSBmaWxlIGFuZCBvdmVyd3JpdGUgdGhvc2UgY2hhbmdlcz9cbmZpbGVDaGFuZ2VkU3luY0RpYWxvZz1UaGUgZmlsZSBoYXMgYmVlbiBtb2RpZmllZC4gRG8geW91IHdhbnQgdG8gc3luY2hyb25pemUgdGhvc2UgY2hhbmdlcz9cbmZpbGVDaGFuZ2VkU3luYz1UaGUgZmlsZSBoYXMgYmVlbiBtb2RpZmllZC4gQ2xpY2sgaGVyZSB0byBzeW5jaHJvbml6ZS5cbm92ZXJ3cml0ZT1PdmVyd3JpdGVcbnN5bmNocm9uaXplPVN5bmNocm9uaXplXG5maWxlbmFtZT1GaWxlbmFtZVxuZmlsZUV4aXN0cz1GaWxlIGFscmVhZHkgZXhpc3RzXG5maWxlTW92ZWRUb1RyYXNoPUZpbGUgd2FzIG1vdmVkIHRvIHRyYXNoXG5maWxlTmVhcmx5RnVsbFNlZUZhcT1GaWxlIG5lYXJseSBmdWxsLCBwbGVhc2Ugc2VlIEZBUVxuZmlsZU5vdEZvdW5kPUZpbGUgbm90IGZvdW5kXG5yZXBvc2l0b3J5Tm90Rm91bmQ9UmVwb3NpdG9yeSBub3QgZm91bmRcbmZpbGVOb3RGb3VuZE9yRGVuaWVkPVRoZSBmaWxlIHdhcyBub3QgZm91bmQuIEl0IGRvZXMgbm90IGV4aXN0IG9yIHlvdSBkbyBub3QgaGF2ZSBhY2Nlc3MuXG5maWxlTm90TG9hZGVkPUZpbGUgbm90IGxvYWRlZFxuZmlsZU5vdFNhdmVkPUZpbGUgbm90IHNhdmVkXG5maWxlT3BlbkxvY2F0aW9uPUhvdyB3b3VsZCB5b3UgbGlrZSB0byBvcGVuIHRoZXNlIGZpbGUocyk/XG5maWxldHlwZUh0bWw9Lmh0bWwgY2F1c2VzIGZpbGUgdG8gc2F2ZSBhcyBIVE1MIHdpdGggcmVkaXJlY3QgdG8gY2xvdWQgVVJMXG5maWxldHlwZVBuZz0ucG5nIGNhdXNlcyBmaWxlIHRvIHNhdmUgYXMgUE5HIHdpdGggZW1iZWRkZWQgZGF0YVxuZmlsZXR5cGVTdmc9LnN2ZyBjYXVzZXMgZmlsZSB0byBzYXZlIGFzIFNWRyB3aXRoIGVtYmVkZGVkIGRhdGFcbmZpbGVXaWxsQmVTYXZlZEluQXBwRm9sZGVyPXsxfSB3aWxsIGJlIHNhdmVkIGluIHRoZSBhcHAgZm9sZGVyLlxuZmlsbD1GaWxsXG5maWxsQ29sb3I9RmlsbCBDb2xvclxuZmlsdGVyQ2FyZHM9RmlsdGVyIENhcmRzXG5maW5kPUZpbmRcbmZpdD1GaXRcbmZpdENvbnRhaW5lcj1SZXNpemUgQ29udGFpbmVyXG5maXRJbnRvQ29udGFpbmVyPUZpdCBpbnRvIENvbnRhaW5lclxuZml0UGFnZT1GaXQgUGFnZVxuZml0UGFnZVdpZHRoPUZpdCBQYWdlIFdpZHRoXG5maXRUbz1GaXQgdG9cbmZpdFRvU2hlZXRzQWNyb3NzPXNoZWV0KHMpIGFjcm9zc1xuZml0VG9CeT1ieVxuZml0VG9TaGVldHNEb3duPXNoZWV0KHMpIGRvd25cbmZpdFR3b1BhZ2VzPVR3byBQYWdlc1xuZml0V2luZG93PUZpdCBXaW5kb3dcbmZsaXA9RmxpcFxuZmxpcEg9RmxpcCBIb3Jpem9udGFsXG5mbGlwVj1GbGlwIFZlcnRpY2FsXG5mbG93Y2hhcnQ9Rmxvd2NoYXJ0XG5mb2xkZXI9Rm9sZGVyXG5mb250PUZvbnRcbmZvbnRDb2xvcj1Gb250IENvbG9yXG5mb250RmFtaWx5PUZvbnQgRmFtaWx5XG5mb250U2l6ZT1Gb250IFNpemVcbmZvcmJpZGRlbj1Zb3UgYXJlIG5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIGZpbGVcbmZvcm1hdD1Gb3JtYXRcbmZvcm1hdFBhbmVsPUZvcm1hdCBQYW5lbFxuZm9ybWF0dGVkPUZvcm1hdHRlZFxuZm9ybWF0dGVkVGV4dD1Gb3JtYXR0ZWQgVGV4dFxuZm9ybWF0UG5nPVBOR1xuZm9ybWF0R2lmPUdJRlxuZm9ybWF0SnBnPUpQRUdcbmZvcm1hdFBkZj1QREZcbmZvcm1hdFNxbD1TUUxcbmZvcm1hdFN2Zz1TVkdcbmZvcm1hdEh0bWxFbWJlZGRlZD1IVE1MXG5mb3JtYXRTdmdFbWJlZGRlZD1TVkcgKHdpdGggWE1MKVxuZm9ybWF0VnNkeD1WU0RYXG5mb3JtYXRWc3N4PVZTU1hcbmZvcm1hdFhtbFBsYWluPVhNTCAoUGxhaW4pXG5mb3JtYXRYbWw9WE1MXG5mb3J1bT1EaXNjdXNzaW9uL0hlbHAgRm9ydW1zXG5mcmVlaGFuZD1GcmVlaGFuZFxuZnJvbVRlbXBsYXRlPUZyb20gVGVtcGxhdGVcbmZyb21UZW1wbGF0ZVVybD1Gcm9tIFRlbXBsYXRlIFVSTFxuZnJvbVRleHQ9RnJvbSBUZXh0XG5mcm9tVXJsPUZyb20gVVJMXG5mcm9tVGhpc1BhZ2U9RnJvbSB0aGlzIHBhZ2VcbmZ1bGxzY3JlZW49RnVsbHNjcmVlblxuZ2FwPUdhcFxuZ2NwPUdDUFxuZ2VuZXJhbD1HZW5lcmFsXG5naXRodWI9R2l0SHViXG5naXRsYWI9R2l0TGFiXG5nbGlmZnk9R2xpZmZ5XG5nbG9iYWw9R2xvYmFsXG5nb29nbGVEb2NzPUdvb2dsZSBEb2NzXG5nb29nbGVEcml2ZT1Hb29nbGUgRHJpdmVcbmdvb2dsZUdhZGdldD1Hb29nbGUgR2FkZ2V0XG5nb29nbGVQbHVzPUdvb2dsZStcbmdvb2dsZVNoYXJpbmdOb3RBdmFpbGFibGU9U2hhcmluZyBpcyBvbmx5IGF2YWlsYWJsZSB2aWEgR29vZ2xlIERyaXZlLiBQbGVhc2UgY2xpY2sgT3BlbiBiZWxvdyBhbmQgc2hhcmUgZnJvbSB0aGUgbW9yZSBhY3Rpb25zIG1lbnU6XG5nb29nbGVTbGlkZXM9R29vZ2xlIFNsaWRlc1xuZ29vZ2xlU2l0ZXM9R29vZ2xlIFNpdGVzXG5nb29nbGVTaGVldHM9R29vZ2xlIFNoZWV0c1xuZ3JhZGllbnQ9R3JhZGllbnRcbmdyYWRpZW50Q29sb3I9Q29sb3JcbmdyaWQ9R3JpZFxuZ3JpZENvbG9yPUdyaWQgQ29sb3JcbmdyaWRTaXplPUdyaWQgU2l6ZVxuZ3JvdXA9R3JvdXBcbmd1aWRlcz1HdWlkZXNcbmhhdGVBcHA9SSBoYXRlIGRyYXcuaW9cbmhlYWRpbmc9SGVhZGluZ1xuaGVpZ2h0PUhlaWdodFxuaGVscD1IZWxwXG5oZWxwVHJhbnNsYXRlPUhlbHAgdXMgdHJhbnNsYXRlIHRoaXMgYXBwbGljYXRpb25cbmhpZGU9SGlkZVxuaGlkZUl0PUhpZGUgezF9XG5oaWRkZW49SGlkZGVuXG5ob21lPUhvbWVcbmhvcml6b250YWw9SG9yaXpvbnRhbFxuaG9yaXpvbnRhbEZsb3c9SG9yaXpvbnRhbCBGbG93XG5ob3Jpem9udGFsVHJlZT1Ib3Jpem9udGFsIFRyZWVcbmhvd1RyYW5zbGF0ZT1Ib3cgZ29vZCBpcyB0aGUgdHJhbnNsYXRpb24gaW4geW91ciBsYW5ndWFnZT9cbmh0bWw9SFRNTFxuaHRtbFRleHQ9SFRNTCBUZXh0XG5pZD1JRFxuaWZyYW1lPUlGcmFtZVxuaWdub3JlPUlnbm9yZVxuaW1hZ2U9SW1hZ2VcbmltYWdlVXJsPUltYWdlIFVSTFxuaW1hZ2VzPUltYWdlc1xuaW1hZ2VQcmV2aWV3RXJyb3I9VGhpcyBpbWFnZSBjb3VsZG5cJ3QgYmUgbG9hZGVkIGZvciBwcmV2aWV3LiBQbGVhc2UgY2hlY2sgdGhlIFVSTC5cbmltYWdlVG9vQmlnPUltYWdlIHRvbyBiaWdcbmltZ3VyPUltZ3VyXG5pbXBvcnQ9SW1wb3J0XG5pbXBvcnRGcm9tPUltcG9ydCBmcm9tXG5pbmNsdWRlQ29weU9mTXlEaWFncmFtPUluY2x1ZGUgYSBjb3B5IG9mIG15IGRpYWdyYW1cbmluY3JlYXNlSW5kZW50PUluY3JlYXNlIEluZGVudFxuZGVjcmVhc2VJbmRlbnQ9RGVjcmVhc2UgSW5kZW50XG5pbnNlcnQ9SW5zZXJ0XG5pbnNlcnRDb2x1bW5CZWZvcmU9SW5zZXJ0IENvbHVtbiBMZWZ0XG5pbnNlcnRDb2x1bW5BZnRlcj1JbnNlcnQgQ29sdW1uIFJpZ2h0XG5pbnNlcnRFbGxpcHNlPUluc2VydCBFbGxpcHNlXG5pbnNlcnRJbWFnZT1JbnNlcnQgSW1hZ2Vcbmluc2VydEhvcml6b250YWxSdWxlPUluc2VydCBIb3Jpem9udGFsIFJ1bGVcbmluc2VydExpbms9SW5zZXJ0IExpbmtcbmluc2VydFBhZ2U9SW5zZXJ0IFBhZ2Vcbmluc2VydFJlY3RhbmdsZT1JbnNlcnQgUmVjdGFuZ2xlXG5pbnNlcnRSaG9tYnVzPUluc2VydCBSaG9tYnVzXG5pbnNlcnRSb3dCZWZvcmU9SW5zZXJ0IFJvdyBBYm92ZVxuaW5zZXJ0Um93QWZ0ZXI9SW5zZXJ0IFJvdyBBZnRlclxuaW5zZXJ0VGV4dD1JbnNlcnQgVGV4dFxuaW5zZXJ0aW5nPUluc2VydGluZ1xuaW5zdGFsbEFwcD1JbnN0YWxsIEFwcFxuaW52YWxpZEZpbGVuYW1lPURpYWdyYW0gbmFtZXMgbXVzdCBub3QgY29udGFpbiB0aGUgZm9sbG93aW5nIGNoYXJhY3RlcnM6ICAvIHwgOiA7IHsgfSA8ID4gJiArID8gPSAiXG5pbnZhbGlkTGljZW5zZVNlZVRoaXNQYWdlPVlvdXIgbGljZW5zZSBpcyBpbnZhbGlkLCBwbGVhc2Ugc2VlIHRoaXMgPGEgdGFyZ2V0PSJfYmxhbmsiIGhyZWY9Imh0dHBzOi8vc3VwcG9ydC5kcmF3LmlvL2Rpc3BsYXkvREZDUy9MaWNlbnNpbmcreW91citkcmF3LmlvK3BsdWdpbiI+cGFnZTwvYT4uXG5pbnZhbGlkSW5wdXQ9SW52YWxpZCBpbnB1dFxuaW52YWxpZE5hbWU9SW52YWxpZCBuYW1lXG5pbnZhbGlkT3JNaXNzaW5nRmlsZT1JbnZhbGlkIG9yIG1pc3NpbmcgZmlsZVxuaW52YWxpZFB1YmxpY1VybD1JbnZhbGlkIHB1YmxpYyBVUkxcbmlzb21ldHJpYz1Jc29tZXRyaWNcbmlvcz1pT1Ncbml0YWxpYz1JdGFsaWNcbmtlbm5lZHk9S2VubmVkeVxua2V5Ym9hcmRTaG9ydGN1dHM9S2V5Ym9hcmQgU2hvcnRjdXRzXG5sYXllcnM9TGF5ZXJzXG5sYW5kc2NhcGU9TGFuZHNjYXBlXG5sYW5ndWFnZT1MYW5ndWFnZVxubGVhbk1hcHBpbmc9TGVhbiBNYXBwaW5nXG5sYXN0Q2hhbmdlPUxhc3QgY2hhbmdlIHsxfSBhZ29cbmxlc3NUaGFuQU1pbnV0ZT1sZXNzIHRoYW4gYSBtaW51dGVcbmxpY2Vuc2luZ0Vycm9yPUxpY2Vuc2luZyBFcnJvclxubGljZW5zZUhhc0V4cGlyZWQ9VGhlIGxpY2Vuc2UgZm9yIHsxfSBoYXMgZXhwaXJlZCBvbiB7Mn0uIENsaWNrIGhlcmUuXG5saWNlbnNlV2lsbEV4cGlyZT1UaGUgbGljZW5zZSBmb3IgezF9IHdpbGwgZXhwaXJlIG9uIHsyfS4gQ2xpY2sgaGVyZS5cbmxpbmVKdW1wcz1MaW5lIGp1bXBzXG5saW5rQWNjb3VudFJlcXVpcmVkPUlmIHRoZSBkaWFncmFtIGlzIG5vdCBwdWJsaWMgYSBHb29nbGUgYWNjb3VudCBpcyByZXF1aXJlZCB0byB2aWV3IHRoZSBsaW5rLlxubGlua1RleHQ9TGluayBUZXh0XG5saXN0PUxpc3Rcbm1pbnV0ZT1taW51dGVcbm1pbnV0ZXM9bWludXRlc1xuaG91cnM9aG91cnNcbmRheXM9ZGF5c1xubW9udGhzPW1vbnRoc1xueWVhcnM9eWVhcnNcbnJlc3RhcnRGb3JDaGFuZ2VSZXF1aXJlZD1DaGFuZ2VzIHdpbGwgdGFrZSBlZmZlY3QgYWZ0ZXIgYSByZXN0YXJ0IG9mIHRoZSBhcHBsaWNhdGlvbi5cbmxhbmVDb2xvcj1MYW5lY29sb3Jcbmxhc3RNb2RpZmllZD1MYXN0IG1vZGlmaWVkXG5sYXlvdXQ9TGF5b3V0XG5sZWZ0PUxlZnRcbmxlZnRBbGlnbj1MZWZ0IEFsaWduXG5sZWZ0VG9SaWdodD1MZWZ0IHRvIHJpZ2h0XG5saWJyYXJ5VG9vbHRpcD1EcmFnIGFuZCBkcm9wIHNoYXBlcyBoZXJlIG9yIGNsaWNrICsgdG8gaW5zZXJ0LiBEb3VibGUgY2xpY2sgdG8gZWRpdC5cbmxpZ2h0Ym94PUxpZ2h0Ym94XG5saW5lPUxpbmVcbmxpbmVlbmQ9TGluZSBlbmRcbmxpbmVoZWlnaHQ9TGluZSBIZWlnaHRcbmxpbmVzdGFydD1MaW5lIHN0YXJ0XG5saW5ld2lkdGg9TGluZXdpZHRoXG5saW5rPUxpbmtcbmxpbmtzPUxpbmtzXG5sb2FkaW5nPUxvYWRpbmdcbmxvY2tVbmxvY2s9TG9jay9VbmxvY2tcbmxvZ2dlZE91dD1Mb2dnZWQgT3V0XG5sb2dJbj1sb2cgaW5cbmxvdmVJdD1JIGxvdmUgezF9XG5sdWNpZGNoYXJ0PUx1Y2lkY2hhcnRcbm1hcHM9TWFwc1xubWF0aGVtYXRpY2FsVHlwZXNldHRpbmc9TWF0aGVtYXRpY2FsIFR5cGVzZXR0aW5nXG5tYWtlQ29weT1NYWtlIGEgQ29weVxubWFudWFsPU1hbnVhbFxubWVybWFpZD1NZXJtYWlkXG5taWNyb3NvZnRPZmZpY2U9TWljcm9zb2Z0IE9mZmljZVxubWljcm9zb2Z0RXhjZWw9TWljcm9zb2Z0IEV4Y2VsXG5taWNyb3NvZnRQb3dlclBvaW50PU1pY3Jvc29mdCBQb3dlclBvaW50XG5taWNyb3NvZnRXb3JkPU1pY3Jvc29mdCBXb3JkXG5taWRkbGU9TWlkZGxlXG5taW5pbWFsPU1pbmltYWxcbm1pc2M9TWlzY1xubW9ja3Vwcz1Nb2NrdXBzXG5tb2RpZmljYXRpb25EYXRlPU1vZGlmaWNhdGlvbiBkYXRlXG5tb2RpZmllZEJ5PU1vZGlmaWVkIGJ5XG5tb3JlPU1vcmVcbm1vcmVSZXN1bHRzPU1vcmUgUmVzdWx0c1xubW9yZVNoYXBlcz1Nb3JlIFNoYXBlc1xubW92ZT1Nb3ZlXG5tb3ZlVG9Gb2xkZXI9TW92ZSB0byBGb2xkZXJcbm1vdmluZz1Nb3Zpbmdcbm1vdmVTZWxlY3Rpb25Ubz1Nb3ZlIHNlbGVjdGlvbiB0byB7MX1cbm5hbWU9TmFtZVxubmF2aWdhdGlvbj1OYXZpZ2F0aW9uXG5uZXR3b3JrPU5ldHdvcmtcbm5ldHdvcmtpbmc9TmV0d29ya2luZ1xubmV3PU5ld1xubmV3TGlicmFyeT1OZXcgTGlicmFyeVxubmV4dFBhZ2U9TmV4dCBQYWdlXG5ubz1Ob1xubm9QaWNrRm9sZGVyPU5vLCBwaWNrIGZvbGRlclxubm9BdHRhY2htZW50cz1ObyBhdHRhY2htZW50cyBmb3VuZFxubm9Db2xvcj1ObyBDb2xvclxubm9GaWxlcz1ObyBGaWxlc1xubm9GaWxlU2VsZWN0ZWQ9Tm8gZmlsZSBzZWxlY3RlZFxubm9MaWJyYXJpZXM9Tm8gbGlicmFyaWVzIGZvdW5kXG5ub01vcmVSZXN1bHRzPU5vIG1vcmUgcmVzdWx0c1xubm9uZT1Ob25lXG5ub090aGVyVmlld2Vycz1ObyBvdGhlciB2aWV3ZXJzXG5ub1BsdWdpbnM9Tm8gcGx1Z2luc1xubm9QcmV2aWV3PU5vIHByZXZpZXdcbm5vUmVzcG9uc2U9Tm8gcmVzcG9uc2UgZnJvbSBzZXJ2ZXJcbm5vUmVzdWx0c0Zvcj1ObyByZXN1bHRzIGZvciBcJ3sxfVwnXG5ub1JldmlzaW9ucz1ObyByZXZpc2lvbnNcbm5vU2VhcmNoUmVzdWx0cz1ObyBzZWFyY2ggcmVzdWx0cyBmb3VuZFxubm9QYWdlQ29udGVudE9yTm90U2F2ZWQ9Tm8gYW5jaG9ycyBmb3VuZCBvbiB0aGlzIHBhZ2Ugb3IgaXQgaGFzblwndCBiZWVuIHNhdmVkIHlldFxubm9ybWFsPU5vcm1hbFxubm9ydGg9Tm9ydGhcbm5vdEFEaWFncmFtRmlsZT1Ob3QgYSBkaWFncmFtIGZpbGVcbm5vdEFMaWJyYXJ5RmlsZT1Ob3QgYSBsaWJyYXJ5IGZpbGVcbm5vdEF2YWlsYWJsZT1Ob3QgYXZhaWxhYmxlXG5ub3RBVXRmOEZpbGU9Tm90IGEgVVRGLTggZmlsZVxubm90Q29ubmVjdGVkPU5vdCBjb25uZWN0ZWRcbm5vdGU9Tm90ZVxubm90U2F0aXNmaWVkV2l0aEltcG9ydD1Ob3Qgc2F0aXNmaWVkIHdpdGggdGhlIGltcG9ydD9cbm5vdFVzaW5nU2VydmljZT1Ob3QgdXNpbmcgezF9P1xubnVtYmVyZWRMaXN0PU51bWJlcmVkIGxpc3Rcbm9mZmxpbmU9T2ZmbGluZVxub2s9T0tcbm9uZURyaXZlPU9uZURyaXZlXG5vbmxpbmU9T25saW5lXG5vcGFjaXR5PU9wYWNpdHlcbm9wZW49T3Blblxub3BlbkFycm93PU9wZW4gQXJyb3dcbm9wZW5FeGlzdGluZ0RpYWdyYW09T3BlbiBFeGlzdGluZyBEaWFncmFtXG5vcGVuRmlsZT1PcGVuIEZpbGVcbm9wZW5Gcm9tPU9wZW4gZnJvbVxub3BlbkxpYnJhcnk9T3BlbiBMaWJyYXJ5XG5vcGVuTGlicmFyeUZyb209T3BlbiBMaWJyYXJ5IGZyb21cbm9wZW5MaW5rPU9wZW4gTGlua1xub3BlbkluTmV3V2luZG93PU9wZW4gaW4gTmV3IFdpbmRvd1xub3BlbkluVGhpc1dpbmRvdz1PcGVuIGluIFRoaXMgV2luZG93XG5vcGVuSXQ9T3BlbiB7MX1cbm9wZW5SZWNlbnQ9T3BlbiBSZWNlbnRcbm9wZW5TdXBwb3J0ZWQ9U3VwcG9ydGVkIGZvcm1hdHMgYXJlIGZpbGVzIHNhdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSAoLnhtbCksIC52c2R4IGFuZCAuZ2xpZmZ5XG5vcHRpb25zPU9wdGlvbnNcbm9yZ2FuaWM9T3JnYW5pY1xub3JnQ2hhcnQ9T3JnIENoYXJ0XG5vcnRob2dvbmFsPU9ydGhvZ29uYWxcbm90aGVyVmlld2VyPW90aGVyIHZpZXdlclxub3RoZXJWaWV3ZXJzPW90aGVyIHZpZXdlcnNcbm91dGxpbmU9T3V0bGluZVxub3ZhbD1PdmFsXG5wYWdlPVBhZ2VcbnBhZ2VDb250ZW50PVBhZ2UgQ29udGVudFxucGFnZU5vdEZvdW5kPVBhZ2Ugbm90IGZvdW5kXG5wYWdlV2l0aE51bWJlcj1QYWdlLXsxfVxucGFnZXM9UGFnZXNcbnBhZ2VWaWV3PVBhZ2UgVmlld1xucGFnZVNldHVwPVBhZ2UgU2V0dXBcbnBhZ2VTY2FsZT1QYWdlIFNjYWxlXG5wYW49UGFuXG5wYW5Ub29sdGlwPVNwYWNlK0RyYWcgdG8gcGFuXG5wYXBlclNpemU9UGFwZXIgU2l6ZVxucGF0dGVybj1QYXR0ZXJuXG5wYXN0ZT1QYXN0ZVxucGFzdGVIZXJlPVBhc3RlIGhlcmVcbnBhc3RlU2l6ZT1QYXN0ZSBTaXplXG5wYXN0ZVN0eWxlPVBhc3RlIFN0eWxlXG5wZXJpbWV0ZXI9UGVyaW1ldGVyXG5wZXJtaXNzaW9uQW55b25lPUFueW9uZSBjYW4gZWRpdFxucGVybWlzc2lvbkF1dGhvcj1Pd25lciBhbmQgYWRtaW5zIGNhbiBlZGl0XG5waWNrRm9sZGVyPVBpY2sgYSBmb2xkZXJcbnBpY2tMaWJyYXJ5RGlhbG9nVGl0bGU9U2VsZWN0IExpYnJhcnlcbnB1YmxpY0RpYWdyYW1Vcmw9UHVibGljIFVSTCBvZiB0aGUgZGlhZ3JhbVxucGxhY2Vob2xkZXJzPVBsYWNlaG9sZGVyc1xucGxhbnRVbWw9UGxhbnRVTUxcbnBsdWdpbnM9UGx1Z2luc1xucGx1Z2luVXJsPVBsdWdpbiBVUkxcbnBsdWdpbldhcm5pbmc9VGhlIHBhZ2UgaGFzIHJlcXVlc3RlZCB0byBsb2FkIHRoZSBmb2xsb3dpbmcgcGx1Z2luKHMpOlxuIFxuIHsxfVxuIFxuIFdvdWxkIHlvdSBsaWtlIHRvIGxvYWQgdGhlc2UgcGx1Z2luKHMpIG5vdz9cbiBcbiBOT1RFIDogT25seSBhbGxvdyBwbHVnaW5zIHRvIHJ1biBpZiB5b3UgZnVsbHkgdW5kZXJzdGFuZCB0aGUgc2VjdXJpdHkgaW1wbGljYXRpb25zIG9mIGRvaW5nIHNvLlxuXG5wbHVzVG9vbHRpcD1DbGljayB0byBjb25uZWN0IGFuZCBjbG9uZSAoY3RybCtjbGljayB0byBjbG9uZSwgc2hpZnQrY2xpY2sgdG8gY29ubmVjdCkuIERyYWcgdG8gY29ubmVjdCAoY3RybCtkcmFnIHRvIGNsb25lKS5cbnBvcnRyYWl0PVBvcnRyYWl0XG5wb3NpdGlvbj1Qb3NpdGlvblxucG9zdGVyUHJpbnQ9UG9zdGVyIFByaW50XG5wcmVmZXJlbmNlcz1QcmVmZXJlbmNlc1xucHJldmlldz1QcmV2aWV3XG5wcmV2aW91c1BhZ2U9UHJldmlvdXMgUGFnZVxucHJpbnQ9UHJpbnRcbnByaW50QWxsUGFnZXM9UHJpbnQgQWxsIFBhZ2VzXG5wcm9jRW5nPVByb2MuIEVuZy5cbnByb2plY3Q9UHJvamVjdFxucHJpb3JpdHk9UHJpb3JpdHlcbnByb3BlcnRpZXM9UHJvcGVydGllc1xucHVibGlzaD1QdWJsaXNoXG5xdWlja1N0YXJ0PVF1aWNrIFN0YXJ0IFZpZGVvXG5yYWNrPVJhY2tcbnJhZGlhbFRyZWU9UmFkaWFsIFRyZWVcbnJlYWRPbmx5PVJlYWQtb25seVxucmVjb25uZWN0aW5nPVJlY29ubmVjdGluZ1xucmVjZW50bHlVcGRhdGVkPVJlY2VudGx5IFVwZGF0ZWRcbnJlY2VudGx5Vmlld2VkPVJlY2VudGx5IFZpZXdlZFxucmVjdGFuZ2xlPVJlY3RhbmdsZVxucmVkaXJlY3RUb05ld0FwcD1UaGlzIGZpbGUgd2FzIGNyZWF0ZWQgb3IgbW9kaWZpZWQgaW4gYSBuZXdlciB2ZXJzaW9uIG9mIHRoaXMgYXBwLiBZb3Ugd2lsbCBiZSByZWRpcmVjdGVkIG5vdy5cbnJlYWx0aW1lVGltZW91dD1JdCBsb29rcyBsaWtlIHlvdVwndmUgbWFkZSBhIGZldyBjaGFuZ2VzIHdoaWxlIG9mZmxpbmUuIFdlXCdyZSBzb3JyeSwgdGhlc2UgY2hhbmdlcyBjYW5ub3QgYmUgc2F2ZWQuXG5yZWRvPVJlZG9cbnJlZnJlc2g9UmVmcmVzaFxucmVndWxhckV4cHJlc3Npb249UmVndWxhciBFeHByZXNzaW9uXG5yZWxhdGl2ZT1SZWxhdGl2ZVxucmVsYXRpdmVVcmxOb3RBbGxvd2VkPVJlbGF0aXZlIFVSTCBub3QgYWxsb3dlZFxucmVtZW1iZXJNZT1SZW1lbWJlciBtZVxucmVtZW1iZXJUaGlzU2V0dGluZz1SZW1lbWJlciB0aGlzIHNldHRpbmdcbnJlbW92ZUZvcm1hdD1DbGVhciBGb3JtYXR0aW5nXG5yZW1vdmVGcm9tR3JvdXA9UmVtb3ZlIGZyb20gR3JvdXBcbnJlbW92ZUl0PVJlbW92ZSB7MX1cbnJlbW92ZVdheXBvaW50PVJlbW92ZSBXYXlwb2ludFxucmVuYW1lPVJlbmFtZVxucmVuYW1lZD1SZW5hbWVkXG5yZW5hbWVJdD1SZW5hbWUgezF9XG5yZW5hbWluZz1SZW5hbWluZ1xucmVwbGFjZT1SZXBsYWNlXG5yZXBsYWNlSXQ9ezF9IGFscmVhZHkgZXhpc3RzLiBEbyB5b3Ugd2FudCB0byByZXBsYWNlIGl0P1xucmVwbGFjZUV4aXN0aW5nRHJhd2luZz1SZXBsYWNlIGV4aXN0aW5nIGRyYXdpbmdcbnJlcXVpcmVkPXJlcXVpcmVkXG5yZXNldD1SZXNldFxucmVzZXRWaWV3PVJlc2V0IFZpZXdcbnJlc2l6ZT1SZXNpemVcbnJlc2l6ZUxhcmdlSW1hZ2VzPURvIHlvdSB3YW50IHRvIHJlc2l6ZSBsYXJnZSBpbWFnZXMgdG8gbWFrZSB0aGUgYXBwbGljYXRpb24gcnVuIGZhc3Rlcj9cbnJldGluYT1SZXRpbmFcbnJlc3BvbnNpdmU9UmVzcG9uc2l2ZVxucmVzdG9yZT1SZXN0b3JlXG5yZXN0b3Jpbmc9UmVzdG9yaW5nXG5yZXRyeWluZ0luPVJldHJ5aW5nIGluIHsxfSBzZWNvbmQocylcbnJldHJ5aW5nTG9hZD1Mb2FkIGZhaWxlZC4gUmV0cnlpbmcuLi5cbnJldHJ5aW5nTG9naW49TG9naW4gdGltZSBvdXQuIFJldHJ5aW5nLi4uXG5yZXZlcnNlPVJldmVyc2VcbnJldmlzaW9uPVJldmlzaW9uXG5yZXZpc2lvbkhpc3Rvcnk9UmV2aXNpb24gSGlzdG9yeVxucmhvbWJ1cz1SaG9tYnVzXG5yaWdodD1SaWdodFxucmlnaHRBbGlnbj1SaWdodCBBbGlnblxucmlnaHRUb0xlZnQ9UmlnaHQgdG8gbGVmdFxucm90YXRlPVJvdGF0ZVxucm90YXRlVG9vbHRpcD1DbGljayBhbmQgZHJhZyB0byByb3RhdGUsIGNsaWNrIHRvIHR1cm4gc2hhcGUgb25seSBieSA5MCBkZWdyZWVzXG5yb3RhdGlvbj1Sb3RhdGlvblxucm91bmRlZD1Sb3VuZGVkXG5zYXZlPVNhdmVcbnNhdmVBbmRFeGl0PVNhdmUgJiBFeGl0XG5zYXZlQXM9U2F2ZSBhc1xuc2F2ZUFzWG1sRmlsZT1TYXZlIGFzIFhNTCBmaWxlP1xuc2F2ZWQ9U2F2ZWRcbnNhdmVEaWFncmFtRmlyc3Q9UGxlYXNlIHNhdmUgdGhlIGRpYWdyYW0gZmlyc3RcbnNhdmVEaWFncmFtc1RvPVNhdmUgZGlhZ3JhbXMgdG9cbnNhdmVMaWJyYXJ5NDAzPUluc3VmZmljaWVudCBwZXJtaXNzaW9ucyB0byBlZGl0IHRoaXMgbGlicmFyeVxuc2F2ZUxpYnJhcnk1MDA9VGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIHNhdmluZyB0aGUgbGlicmFyeVxuc2F2ZUxpYnJhcnlSZWFkT25seT1Db3VsZCBub3Qgc2F2ZSBsaWJyYXJ5IHdoaWxlIHJlYWQtb25seSBtb2RlIGlzIGFjdGl2ZVxuc2F2aW5nPVNhdmluZ1xuc2NyYXRjaHBhZD1TY3JhdGNocGFkXG5zY3JvbGxiYXJzPVNjcm9sbGJhcnNcbnNlYXJjaD1TZWFyY2hcbnNlYXJjaFNoYXBlcz1TZWFyY2ggU2hhcGVzXG5zZWxlY3RBbGw9U2VsZWN0IEFsbFxuc2VsZWN0aW9uT25seT1TZWxlY3Rpb24gT25seVxuc2VsZWN0Q2FyZD1TZWxlY3QgQ2FyZFxuc2VsZWN0RWRnZXM9U2VsZWN0IEVkZ2VzXG5zZWxlY3RGaWxlPVNlbGVjdCBGaWxlXG5zZWxlY3RGb2xkZXI9U2VsZWN0IEZvbGRlclxuc2VsZWN0Rm9udD1TZWxlY3QgRm9udFxuc2VsZWN0Tm9uZT1TZWxlY3QgTm9uZVxuc2VsZWN0VGVtcGxhdGU9U2VsZWN0IFRlbXBsYXRlXG5zZWxlY3RWZXJ0aWNlcz1TZWxlY3QgVmVydGljZXNcbnNlbmRNZXNzYWdlPVNlbmRcbnNlbmRZb3VyRmVlZGJhY2s9U2VuZCB5b3VyIGZlZWRiYWNrXG5zZXJ2aWNlVW5hdmFpbGFibGVPckJsb2NrZWQ9U2VydmljZSB1bmF2YWlsYWJsZSBvciBibG9ja2VkXG5zZXNzaW9uRXhwaXJlZD1Zb3VyIHNlc3Npb24gaGFzIGV4cGlyZWQuIFBsZWFzZSByZWZyZXNoIHRoZSBicm93c2VyIHdpbmRvdy5cbnNlc3Npb25UaW1lb3V0T25TYXZlPVlvdXIgc2Vzc2lvbiBoYXMgdGltZWQgb3V0IGFuZCB5b3UgaGF2ZSBiZWVuIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBHb29nbGUgRHJpdmUuIFByZXNzIE9LIHRvIGxvZ2luIGFuZCBzYXZlLiBcbnNldEFzRGVmYXVsdFN0eWxlPVNldCBhcyBEZWZhdWx0IFN0eWxlXG5zaGFkb3c9U2hhZG93XG5zaGFwZT1TaGFwZVxuc2hhcGVzPVNoYXBlc1xuc2hhcmU9U2hhcmVcbnNoYXJlTGluaz1MaW5rIGZvciBzaGFyZWQgZWRpdGluZ1xuc2hhcnA9U2hhcnBcbnNob3c9U2hvd1xuc2hvd1N0YXJ0U2NyZWVuPVNob3cgU3RhcnQgU2NyZWVuXG5zaWRlYmFyVG9vbHRpcD1DbGljayB0byBleHBhbmQuIERyYWcgYW5kIGRyb3Agc2hhcGVzIGludG8gdGhlIGRpYWdyYW0uIFNoaWZ0K2NsaWNrIHRvIGNoYW5nZSBzZWxlY3Rpb24uIEFsdCtjbGljayB0byBpbnNlcnQgYW5kIGNvbm5lY3QuXG5zaWducz1TaWduc1xuc2lnbk91dD1TaWduIG91dFxuc2ltcGxlPVNpbXBsZVxuc2ltcGxlQXJyb3c9U2ltcGxlIEFycm93XG5zaW1wbGVWaWV3ZXI9U2ltcGxlIFZpZXdlclxuc2l6ZT1TaXplXG5zb2xpZD1Tb2xpZFxuc291cmNlU3BhY2luZz1Tb3VyY2UgU3BhY2luZ1xuc291dGg9U291dGhcbnNvZnR3YXJlPVNvZnR3YXJlXG5zcGFjZT1TcGFjZVxuc3BhY2luZz1TcGFjaW5nXG5zcGVjaWFsTGluaz1TcGVjaWFsIExpbmtcbnN0YW5kYXJkPVN0YW5kYXJkXG5zdGFydERyYXdpbmc9U3RhcnQgZHJhd2luZ1xuc3RvcERyYXdpbmc9U3RvcCBkcmF3aW5nXG5zdGFydGluZz1TdGFydGluZ1xuc3RyYWlnaHQ9U3RyYWlnaHRcbnN0cmlrZXRocm91Z2g9U3RyaWtldGhyb3VnaFxuc3Ryb2tlQ29sb3I9TGluZSBDb2xvclxuc3R5bGU9U3R5bGVcbnN1YnNjcmlwdD1TdWJzY3JpcHRcbnN1bW1hcnk9U3VtbWFyeVxuc3VwZXJzY3JpcHQ9U3VwZXJzY3JpcHRcbnN1cHBvcnQ9U3VwcG9ydFxuc3dpbWxhbmVEaWFncmFtPVN3aW1sYW5lIERpYWdyYW1cbnN5c21sPVN5c01MXG50YWdzPVRhZ3NcbnRhYmxlPVRhYmxlXG50YWJsZXM9VGFibGVzXG50YWtlT3Zlcj1UYWtlIE92ZXJcbnRhcmdldFNwYWNpbmc9VGFyZ2V0IFNwYWNpbmdcbnRlbXBsYXRlPVRlbXBsYXRlXG50ZW1wbGF0ZXM9VGVtcGxhdGVzXG50ZXh0PVRleHRcbnRleHRBbGlnbm1lbnQ9VGV4dCBBbGlnbm1lbnRcbnRleHRPcGFjaXR5PVRleHQgT3BhY2l0eVxudGhlbWU9VGhlbWVcbnRpbWVvdXQ9VGltZW91dFxudGl0bGU9VGl0bGVcbnRvPXRvXG50b0JhY2s9VG8gQmFja1xudG9Gcm9udD1UbyBGcm9udFxudG9vbGJhcj1Ub29sYmFyXG50b29sdGlwcz1Ub29sdGlwc1xudG9wPVRvcFxudG9wQWxpZ249VG9wIEFsaWduXG50b3BMZWZ0PVRvcCBMZWZ0XG50b3BSaWdodD1Ub3AgUmlnaHRcbnRyYW5zcGFyZW50PVRyYW5zcGFyZW50XG50cmFuc3BhcmVudEJhY2tncm91bmQ9VHJhbnNwYXJlbnQgQmFja2dyb3VuZFxudHJlbGxvPVRyZWxsb1xudHJ5QWdhaW49VHJ5IGFnYWluXG50cnlPcGVuaW5nVmlhVGhpc1BhZ2U9VHJ5IG9wZW5pbmcgdmlhIHRoaXMgcGFnZVxudHVybj1Sb3RhdGUgc2hhcGUgb25seSBieSA5MMKwXG50eXBlPVR5cGVcbnR3aXR0ZXI9VHdpdHRlclxudW1sPVVNTFxudW5kZXJsaW5lPVVuZGVybGluZVxudW5kbz1VbmRvXG51bmdyb3VwPVVuZ3JvdXBcbnVuc2F2ZWRDaGFuZ2VzPVVuc2F2ZWQgY2hhbmdlc1xudW5zYXZlZENoYW5nZXNDbGlja0hlcmVUb1NhdmU9VW5zYXZlZCBjaGFuZ2VzLiBDbGljayBoZXJlIHRvIHNhdmUuXG51bnRpdGxlZD1VbnRpdGxlZFxudW50aXRsZWREaWFncmFtPVVudGl0bGVkIERpYWdyYW1cbnVudGl0bGVkTGF5ZXI9VW50aXRsZWQgTGF5ZXJcbnVudGl0bGVkTGlicmFyeT1VbnRpdGxlZCBMaWJyYXJ5XG51bmtub3duRXJyb3I9VW5rbm93biBlcnJvclxudXBkYXRlRmlsZT1VcGRhdGUgezF9XG51cGRhdGluZ0RvY3VtZW50PVVwZGF0aW5nIERvY3VtZW50LiBQbGVhc2Ugd2FpdC4uLlxudXBkYXRpbmdQcmV2aWV3PVVwZGF0aW5nIFByZXZpZXcuIFBsZWFzZSB3YWl0Li4uXG51cGRhdGluZ1NlbGVjdGlvbj1VcGRhdGluZyBTZWxlY3Rpb24uIFBsZWFzZSB3YWl0Li4uXG51cGxvYWQ9VXBsb2FkXG51cmw9VVJMXG51c2VPZmZsaW5lPVVzZSBPZmZsaW5lXG51c2VSb290Rm9sZGVyPVVzZSByb290IGZvbGRlcj9cbnVzZXJNYW51YWw9VXNlciBNYW51YWxcbnZlcnRpY2FsPVZlcnRpY2FsXG52ZXJ0aWNhbEZsb3c9VmVydGljYWwgRmxvd1xudmVydGljYWxUcmVlPVZlcnRpY2FsIFRyZWVcbnZpZXc9Vmlld1xudmlld2VyU2V0dGluZ3M9Vmlld2VyIFNldHRpbmdzXG52aWV3VXJsPUxpbmsgdG8gdmlldzogezF9XG52b2ljZUFzc2lzdGFudD1Wb2ljZSBBc3Npc3RhbnQgKGJldGEpXG53YXJuaW5nPVdhcm5pbmdcbndheXBvaW50cz1XYXlwb2ludHNcbndlc3Q9V2VzdFxud2lkdGg9V2lkdGhcbndpa2k9V2lraVxud29yZFdyYXA9V29yZCBXcmFwXG53cml0aW5nRGlyZWN0aW9uPVdyaXRpbmcgRGlyZWN0aW9uXG55ZXM9WWVzXG55b3VyRW1haWxBZGRyZXNzPVlvdXIgZW1haWwgYWRkcmVzc1xuem9vbT1ab29tXG56b29tSW49Wm9vbSBJblxuem9vbU91dD1ab29tIE91dFxuYmFzaWM9QmFzaWNcbmJ1c2luZXNzcHJvY2Vzcz1CdXNpbmVzcyBQcm9jZXNzZXNcbmNoYXJ0cz1DaGFydHNcbmVuZ2luZWVyaW5nPUVuZ2luZWVyaW5nXG5mbG93Y2hhcnRzPUZsb3djaGFydHNcbmdtZGw9TWF0ZXJpYWwgRGVzaWduXG5taW5kbWFwcz1NaW5kbWFwc1xubW9ja3Vwcz1Nb2NrdXBzXG5uZXR3b3JrZGlhZ3JhbXM9TmV0d29yayBEaWFncmFtc1xubm90aGluZ0lzU2VsZWN0ZWQ9Tm90aGluZyBpcyBzZWxlY3RlZFxub3RoZXI9T3RoZXJcbnNvZnR3YXJlZGVzaWduPVNvZnR3YXJlIERlc2lnblxudmVubmRpYWdyYW1zPVZlbm4gRGlhZ3JhbXNcbndlYkVtYWlsT3JPdGhlcj1XZWIsIGVtYWlsIG9yIGFueSBvdGhlciBpbnRlcm5ldCBhZGRyZXNzXG53ZWJMaW5rPVdlYiBMaW5rXG53aXJlZnJhbWVzPVdpcmVmcmFtZXNcbnByb3BlcnR5PVByb3BlcnR5XG52YWx1ZT1WYWx1ZVxuc2hvd01vcmU9U2hvdyBNb3JlXG5zaG93TGVzcz1TaG93IExlc3Ncbm15RGlhZ3JhbXM9TXkgRGlhZ3JhbXNcbmFsbERpYWdyYW1zPUFsbCBEaWFncmFtc1xucmVjZW50bHlVc2VkPVJlY2VudGx5IHVzZWRcbmxpc3RWaWV3PUxpc3Qgdmlld1xuZ3JpZFZpZXc9R3JpZCB2aWV3XG5yZXN1bHRzRm9yPVJlc3VsdHMgZm9yIFwnezF9XCdcbm9uZURyaXZlQ2hhcnNOb3RBbGxvd2VkPVRoZSBmb2xsb3dpbmcgY2hhcmFjdGVycyBhcmUgbm90IGFsbG93ZWQ6IH4gIiAjICUgICogOiA8ID4gPyAvICB7IHwgfVxub25lRHJpdmVJbnZhbGlkRGV2aWNlTmFtZT1UaGUgc3BlY2lmaWVkIGRldmljZSBuYW1lIGlzIGludmFsaWRcbm9mZmljZU5vdExvZ2dlZE9EPVlvdSBhcmUgbm90IGxvZ2dlZCBpbiB0byBPbmVEcml2ZS4gUGxlYXNlIG9wZW4gZHJhdy5pbyB0YXNrIHBhbmUgYW5kIGxvZ2luIGZpcnN0Llxub2ZmaWNlU2VsZWN0U2luZ2xlRGlhZz1QbGVhc2Ugc2VsZWN0IGEgc2luZ2xlIGRyYXcuaW8gZGlhZ3JhbSBvbmx5IHdpdGhvdXQgb3RoZXIgY29udGVudHMuXG5vZmZpY2VTZWxlY3REaWFnPVBsZWFzZSBzZWxlY3QgYSBkcmF3LmlvIGRpYWdyYW0uXG5vZmZpY2VDYW5ub3RGaW5kRGlhZ3JhbT1DYW5ub3QgZmluZCBhIGRyYXcuaW8gZGlhZ3JhbSBpbiB0aGUgc2VsZWN0aW9uXG5ub0RpYWdyYW1zPU5vIGRpYWdyYW1zIGZvdW5kXG5hdXRoRmFpbGVkPUF1dGhlbnRpY2F0aW9uIGZhaWxlZFxub2ZmaWNlRmFpbGVkQXV0aE1zZz1VbmFibGUgdG8gc3VjY2Vzc2Z1bGx5IGF1dGhlbnRpY2F0ZSB1c2VyIG9yIGF1dGhvcml6ZSBhcHBsaWNhdGlvbi5cbmNvbnZlcnRpbmdEaWFncmFtRmFpbGVkPUNvbnZlcnRpbmcgZGlhZ3JhbSBmYWlsZWRcbm9mZmljZUNvcHlJbWdFcnJNc2c9RHVlIHRvIHNvbWUgbGltaXRhdGlvbnMgaW4gdGhlIGhvc3QgYXBwbGljYXRpb24sIHRoZSBpbWFnZSBjb3VsZCBub3QgYmUgaW5zZXJ0ZWQuIFBsZWFzZSBtYW51YWxseSBjb3B5IHRoZSBpbWFnZSB0aGVuIHBhc3RlIGl0IHRvIHRoZSBkb2N1bWVudC5cbmluc2VydGluZ0ltYWdlRmFpbGVkPUluc2VydGluZyBpbWFnZSBmYWlsZWRcbm9mZmljZUNvcHlJbWdJbnN0PUluc3RydWN0aW9uczogUmlnaHQtY2xpY2sgdGhlIGltYWdlIGJlbG93LiBTZWxlY3QgIkNvcHkgaW1hZ2UiIGZyb20gdGhlIGNvbnRleHQgbWVudS4gVGhlbiwgaW4gdGhlIGRvY3VtZW50LCByaWdodC1jbGljayBhbmQgc2VsZWN0ICJQYXN0ZSIgZnJvbSB0aGUgY29udGV4dCBtZW51LlxuZm9sZGVyRW1wdHk9Rm9sZGVyIGlzIGVtcHR5XG5yZWNlbnQ9UmVjZW50XG5zaGFyZWRXaXRoTWU9U2hhcmVkIFdpdGggTWVcbnNoYXJlcG9pbnRTaXRlcz1TaGFyZXBvaW50IFNpdGVzXG5lcnJvckZldGNoaW5nRm9sZGVyPUVycm9yIGZldGNoaW5nIGZvbGRlciBpdGVtc1xuZXJyb3JBdXRoT0Q9RXJyb3IgYXV0aGVudGljYXRpbmcgdG8gT25lRHJpdmVcbm9mZmljZU1haW5IZWFkZXI9QWRkcyBkcmF3LmlvIGRpYWdyYW1zIHRvIHlvdXIgZG9jdW1lbnQuXG5vZmZpY2VTdGVwc0hlYWRlcj1UaGlzIGFkZC1pbiBwZXJmb3JtcyB0aGUgZm9sbG93aW5nIHN0ZXBzOlxub2ZmaWNlU3RlcDE9Q29ubmVjdHMgdG8gTWljcm9zb2Z0IE9uZURyaXZlLCBHb29nbGUgRHJpdmUgb3IgeW91ciBkZXZpY2UuXG5vZmZpY2VTdGVwMj1TZWxlY3QgYSBkcmF3LmlvIGRpYWdyYW0uXG5vZmZpY2VTdGVwMz1JbnNlcnQgdGhlIGRpYWdyYW0gaW50byB0aGUgZG9jdW1lbnQuXG5vZmZpY2VBdXRoUG9wdXBJbmZvPVBsZWFzZSBjb21wbGV0ZSB0aGUgYXV0aGVudGljYXRpb24gaW4gdGhlIHBvcC11cCB3aW5kb3cuXG5vZmZpY2VTZWxEaWFnPVNlbGVjdCBkcmF3LmlvIERpYWdyYW06XG5maWxlcz1GaWxlc1xuc2hhcmVkPVNoYXJlZFxuc2hhcmVwb2ludD1TaGFyZXBvaW50XG5vZmZpY2VNYW51YWxVcGRhdGVJbnN0PUluc3RydWN0aW9uczogQ29weSBkcmF3LmlvIGRpYWdyYW0gZnJvbSB0aGUgZG9jdW1lbnQuIFRoZW4sIGluIHRoZSBib3ggYmVsb3csIHJpZ2h0LWNsaWNrIGFuZCBzZWxlY3QgIlBhc3RlIiBmcm9tIHRoZSBjb250ZXh0IG1lbnUuXG5vZmZpY2VDbGlja1RvRWRpdD1DbGljayBpY29uIHRvIHN0YXJ0IGVkaXRpbmc6XG5wYXN0ZURpYWdyYW09UGFzdGUgZHJhdy5pbyBkaWFncmFtIGhlcmVcbmNvbm5lY3RPRD1Db25uZWN0IHRvIE9uZURyaXZlXG5zZWxlY3RDaGlsZHJlbj1TZWxlY3QgQ2hpbGRyZW5cbnNlbGVjdFNpYmxpbmdzPVNlbGVjdCBTaWJsaW5nc1xuc2VsZWN0UGFyZW50PVNlbGVjdCBQYXJlbnRcbnNlbGVjdERlc2NlbmRhbnRzPVNlbGVjdCBEZXNjZW5kYW50c1xubGFzdFNhdmVkPUxhc3Qgc2F2ZWQgezF9IGFnb1xucmVzb2x2ZT1SZXNvbHZlXG5yZW9wZW49UmUtb3Blblxuc2hvd1Jlc29sdmVkPVNob3cgUmVzb2x2ZWRcbnJlcGx5PVJlcGx5XG5vYmplY3ROb3RGb3VuZD1PYmplY3Qgbm90IGZvdW5kXG5yZU9wZW5lZD1SZS1vcGVuZWRcbm1hcmtlZEFzUmVzb2x2ZWQ9TWFya2VkIGFzIHJlc29sdmVkXG5ub0NvbW1lbnRzRm91bmQ9Tm8gY29tbWVudHMgZm91bmRcbmNvbW1lbnRzPUNvbW1lbnRzXG50aW1lQWdvPXsxfSBhZ29cbmNvbmZsdWVuY2VDbG91ZD1Db25mbHVlbmNlIENsb3VkXG5saWJyYXJpZXM9TGlicmFyaWVzXG5jb25mQW5jaG9yPUNvbmZsdWVuY2UgUGFnZSBBbmNob3JcbmNvbmZUaW1lb3V0PVRoZSBjb25uZWN0aW9uIGhhcyB0aW1lZCBvdXRcbmNvbmZTcnZUYWtlVG9vTG9uZz1UaGUgc2VydmVyIGF0IHsxfSBpcyB0YWtpbmcgdG9vIGxvbmcgdG8gcmVzcG9uZC5cbmNvbmZDYW5ub3RJbnNlcnROZXc9Q2Fubm90IGluc2VydCBkcmF3LmlvIGRpYWdyYW0gdG8gYSBuZXcgQ29uZmx1ZW5jZSBwYWdlXG5jb25mU2F2ZVRyeT1QbGVhc2Ugc2F2ZSB0aGUgcGFnZSBhbmQgdHJ5IGFnYWluLlxuY29uZkNhbm5vdEdldElEPVVuYWJsZSB0byBkZXRlcm1pbmUgcGFnZSBJRFxuY29uZkNvbnRhY3RBZG1pbj1QbGVhc2UgY29udGFjdCB5b3VyIENvbmZsdWVuY2UgYWRtaW5pc3RyYXRvci5cbnJlYWRFcnI9UmVhZCBFcnJvclxuZWRpdGluZ0Vycj1FZGl0aW5nIEVycm9yXG5jb25mRXh0RWRpdE5vdFBvc3NpYmxlPVRoaXMgZGlhZ3JhbSBjYW5ub3QgYmUgZWRpdGVkIGV4dGVybmFsbHkuIFBsZWFzZSB0cnkgZWRpdGluZyBpdCB3aGlsZSBlZGl0aW5nIHRoZSBwYWdlXG5jb25mRWRpdGVkRXh0PURpYWdyYW0vUGFnZSBlZGl0ZWQgZXh0ZXJuYWxseVxuZGlhZ05vdEZvdW5kPURpYWdyYW0gTm90IEZvdW5kXG5jb25mRWRpdGVkRXh0UmVmcmVzaD1EaWFncmFtL1BhZ2UgaXMgZWRpdGVkIGV4dGVybmFsbHkuIFBsZWFzZSByZWZyZXNoIHRoZSBwYWdlLlxuY29uZkNhbm5vdEVkaXREcmFmdERlbE9yRXh0PUNhbm5vdCBlZGl0IGRpYWdyYW1zIGluIGEgZHJhZnQgcGFnZSwgZGlhZ3JhbSBpcyBkZWxldGVkIGZyb20gdGhlIHBhZ2UsIG9yIGRpYWdyYW0gaXMgZWRpdGVkIGV4dGVybmFsbHkuIFBsZWFzZSBjaGVjayB0aGUgcGFnZS5cbnJldEJhY2s9UmV0dXJuIGJhY2tcbmNvbmZEaWFnTm90UHVibGlzaGVkPVRoZSBkaWFncmFtIGRvZXMgbm90IGJlbG9uZyB0byBhIHB1Ymxpc2hlZCBwYWdlXG5jcmVhdGVkQnlEcmF3PUNyZWF0ZWQgYnkgZHJhdy5pb1xuZmlsZW5hbWVTaG9ydD1GaWxlbmFtZSB0b28gc2hvcnRcbmludmFsaWRDaGFycz1JbnZhbGlkIGNoYXJhY3RlcnNcbmFscmVhZHlFeHN0PXsxfSBhbHJlYWR5IGV4aXN0c1xuZHJhZnRSZWFkRXJyPURyYWZ0IFJlYWQgRXJyb3JcbmRpYWdDYW50TG9hZD1EaWFncmFtIGNhbm5vdCBiZSBsb2FkZWRcbmRyYWZ0V3JpdGVFcnI9RHJhZnQgV3JpdGUgRXJyb3JcbmRyYWZ0Q2FudENyZWF0ZT1EcmFmdCBjb3VsZCBub3QgYmUgY3JlYXRlZFxuY29uZkR1cGxOYW1lPUR1cGxpY2F0ZSBkaWFncmFtIG5hbWUgZGV0ZWN0ZWQuIFBsZWFzZSBwaWNrIGFub3RoZXIgbmFtZS5cbmNvbmZTZXNzaW9uRXhwaXJlZD1Mb29rcyBsaWtlIHlvdXIgc2Vzc2lvbiBleHBpcmVkLiBMb2cgaW4gYWdhaW4gdG8ga2VlcCB3b3JraW5nLlxubG9naW49TG9naW5cbmRyYXdQcmV2PWRyYXcuaW8gcHJldmlld1xuZHJhd0RpYWc9ZHJhdy5pbyBkaWFncmFtXG5pbnZhbGlkQ2FsbEZuTm90Rm91bmQ9SW52YWxpZCBDYWxsOiB7MX0gbm90IGZvdW5kXG5pbnZhbGlkQ2FsbEVyck9jY3VyZWQ9SW52YWxpZCBDYWxsOiBBbiBlcnJvciBvY2N1cnJlZCwgezF9XG5hbm9ueW1vdXM9QW5vbnltb3VzXG5jb25mR290b1BhZ2U9R28gdG8gY29udGFpbmluZyBwYWdlXG5zaG93Q29tbWVudHM9U2hvdyBDb21tZW50c1xuY29uZkVycm9yPUVycm9yOiB7MX1cbmdsaWZmeUltcG9ydD1HbGlmZnkgSW1wb3J0XG5nbGlmZnlJbXBvcnRJbnN0MT1DbGljayB0aGUgIlN0YXJ0IEltcG9ydCIgYnV0dG9uIHRvIGltcG9ydCBhbGwgR2xpZmZ5IGRpYWdyYW1zIHRvIGRyYXcuaW8uXG5nbGlmZnlJbXBvcnRJbnN0Mj1QbGVhc2Ugbm90ZSB0aGF0IHRoZSBpbXBvcnQgcHJvY2VkdXJlIHdpbGwgdGFrZSBzb21lIHRpbWUgYW5kIHRoZSBicm93c2VyIHdpbmRvdyBtdXN0IHJlbWFpbiBvcGVuIHVudGlsIHRoZSBpbXBvcnQgaXMgY29tcGxldGVkLlxuc3RhcnRJbXBvcnQ9U3RhcnQgSW1wb3J0XG5kcmF3Q29uZmlnPWRyYXcuaW8gQ29uZmlndXJhdGlvblxuY3VzdG9tTGliPUN1c3RvbSBMaWJyYXJpZXNcbmN1c3RvbVRlbXA9Q3VzdG9tIFRlbXBsYXRlc1xucGFnZUlkc0V4cD1QYWdlIElEcyBFeHBvcnRcbmRyYXdSZWluZGV4PWRyYXcuaW8gcmUtaW5kZXhpbmcgKGJldGEpXG53b3JraW5nPVdvcmtpbmdcbmRyYXdDb25maWdOb3RGb3VuZEluc3Q9ZHJhdy5pbyBDb25maWd1cmF0aW9uIFNwYWNlIChEUkFXSU9DT05GSUcpIGRvZXMgbm90IGV4aXN0LiBUaGlzIHNwYWNlIGlzIG5lZWRlZCB0byBzdG9yZSBkcmF3LmlvIGNvbmZpZ3VyYXRpb24gZmlsZXMgYW5kIGN1c3RvbSBsaWJyYXJpZXMvdGVtcGxhdGVzLlxuY3JlYXRlQ29uZlNwPUNyZWF0ZSBDb25maWcgU3BhY2VcbnVuZXhwRXJyUmVmcmVzaD1VbmV4cGVjdGVkIGVycm9yLCBwbGVhc2UgcmVmcmVzaCB0aGUgcGFnZSBhbmQgdHJ5IGFnYWluLlxuY29uZmlnSlNPTkluc3Q9V3JpdGUgZHJhdy5pbyBKU09OIGNvbmZpZ3VyYXRpb24gaW4gdGhlIGVkaXRvciBiZWxvdyB0aGVuIGNsaWNrIHNhdmUuIElmIHlvdSBuZWVkIGhlbHAsIHBsZWFzZSByZWZlciB0b1xudGhpc1BhZ2U9dGhpcyBwYWdlXG5jdXJDdXN0TGliPUN1cnJlbnQgQ3VzdG9tIExpYnJhcmllc1xubGliTmFtZT1MaWJyYXJ5IE5hbWVcbmFjdGlvbj1BY3Rpb25cbmRyYXdDb25mSUQ9ZHJhdy5pbyBDb25maWcgSURcbmFkZExpYkluc3Q9Q2xpY2sgdGhlICJBZGQgTGlicmFyeSIgYnV0dG9uIHRvIHVwbG9hZCBhIG5ldyBsaWJyYXJ5LlxuYWRkTGliPUFkZCBMaWJyYXJ5XG5jdXN0b21UZW1wSW5zdDE9Q3VzdG9tIHRlbXBsYXRlcyBhcmUgZHJhdy5pbyBkaWFncmFtcyBzYXZlZCBpbiBjaGlsZHJlbiBwYWdlcyBvZlxuY3VzdG9tVGVtcEluc3QyPUZvciBtb3JlIGRldGFpbHMsIHBsZWFzZSByZWZlciB0b1xudGVtcHNQYWdlPVRlbXBsYXRlcyBwYWdlXG5wYWdlSWRzRXhwSW5zdDE9U2VsZWN0IGV4cG9ydCB0YXJnZXQsIHRoZW4gY2xpY2sgdGhlICJTdGFydCBFeHBvcnQiIGJ1dHRvbiB0byBleHBvcnQgYWxsIHBhZ2VzIElEcy5cbnBhZ2VJZHNFeHBJbnN0Mj1QbGVhc2Ugbm90ZSB0aGF0IHRoZSBleHBvcnQgcHJvY2VkdXJlIHdpbGwgdGFrZSBzb21lIHRpbWUgYW5kIHRoZSBicm93c2VyIHdpbmRvdyBtdXN0IHJlbWFpbiBvcGVuIHVudGlsIHRoZSBleHBvcnQgaXMgY29tcGxldGVkLlxuc3RhcnRFeHA9U3RhcnQgRXhwb3J0XG5yZWZyZXNoRHJhd0luZGV4PVJlZnJlc2ggZHJhdy5pbyBEaWFncmFtcyBJbmRleFxucmVpbmRleEluc3QxPUNsaWNrIHRoZSAiU3RhcnQgSW5kZXhpbmciIGJ1dHRvbiB0byByZWZyZXNoIGRyYXcuaW8gZGlhZ3JhbXMgaW5kZXguXG5yZWluZGV4SW5zdDI9UGxlYXNlIG5vdGUgdGhhdCB0aGUgaW5kZXhpbmcgcHJvY2VkdXJlIHdpbGwgdGFrZSBzb21lIHRpbWUgYW5kIHRoZSBicm93c2VyIHdpbmRvdyBtdXN0IHJlbWFpbiBvcGVuIHVudGlsIHRoZSBpbmRleGluZyBpcyBjb21wbGV0ZWQuXG5zdGFydEluZGV4aW5nPVN0YXJ0IEluZGV4aW5nXG5jb25mQVBhZ2VGb3VuZEZldGNoPVBhZ2UgInsxfSIgZm91bmQuIEZldGNoaW5nXG5jb25mQUFsbERpYWdEb25lPUFsbCB7MX0gZGlhZ3JhbXMgcHJvY2Vzc2VkLiBQcm9jZXNzIGZpbmlzaGVkLlxuY29uZkFTdGFydGVkUHJvY2Vzc2luZz1TdGFydGVkIHByb2Nlc3NpbmcgcGFnZSAiezF9IlxuY29uZkFBbGxEaWFnSW5QYWdlRG9uZT1BbGwgezF9IGRpYWdyYW1zIGluIHBhZ2UgInsyfSIgcHJvY2Vzc2VkIHN1Y2Nlc3NmdWxseS5cbmNvbmZBUGFydGlhbERpYWdEb25lPXsxfSBvdXQgb2YgezJ9IHszfSBkaWFncmFtcyBpbiBwYWdlICJ7NH0iIHByb2Nlc3NlZCBzdWNjZXNzZnVsbHkuXG5jb25mQVVwZGF0ZVBhZ2VGYWlsZWQ9VXBkYXRpbmcgcGFnZSAiezF9IiBmYWlsZWQuXG5jb25mQU5vRGlhZ0ZvdW5kSW5QYWdlPU5vIHsxfSBkaWFncmFtcyBmb3VuZCBpbiBwYWdlICJ7Mn0iLlxuY29uZkFGZXRjaFBhZ2VGYWlsZWQ9RmV0Y2hpbmcgdGhlIHBhZ2UgZmFpbGVkLlxuY29uZkFOb0RpYWdGb3VuZD1ObyB7MX0gZGlhZ3JhbXMgZm91bmQuIFByb2Nlc3MgZmluaXNoZWQuXG5jb25mQVNlYXJjaEZhaWxlZD1TZWFyY2hpbmcgZm9yIHsxfSBkaWFncmFtcyBmYWlsZWQuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuXG5jb25mQUdsaWZmeURpYWdGb3VuZD17Mn0gZGlhZ3JhbSAiezF9IiBmb3VuZC4gSW1wb3J0aW5nXG5jb25mQUdsaWZmeURpYWdJbXBvcnRlZD17Mn0gZGlhZ3JhbSAiezF9IiBpbXBvcnRlZCBzdWNjZXNzZnVsbHkuXG5jb25mQVNhdmluZ0ltcEdsaWZmeUZhaWxlZD1TYXZpbmcgaW1wb3J0ZWQgezJ9IGRpYWdyYW0gInsxfSIgZmFpbGVkLlxuY29uZkFJbXBvcnRlZEZyb21CeURyYXc9SW1wb3J0ZWQgZnJvbSAiezF9IiBieSBkcmF3LmlvXG5jb25mQUltcG9ydEdsaWZmeUZhaWxlZD1JbXBvcnRpbmcgezJ9IGRpYWdyYW0gInsxfSIgZmFpbGVkLlxuY29uZkFGZXRjaEdsaWZmeUZhaWxlZD1GZXRjaGluZyB7Mn0gZGlhZ3JhbSAiezF9IiBmYWlsZWQuXG5jb25mQUNoZWNrQnJva2VuRGlhZ0xuaz1DaGVja2luZyBmb3IgYnJva2VuIGRpYWdyYW1zIGxpbmtzLlxuY29uZkFEZWxEaWFnTGlua09mPURlbGV0aW5nIGRpYWdyYW0gbGluayBvZiAiezF9IlxuY29uZkFEdXBMbms9KGR1cGxpY2F0ZSBsaW5rKVxuY29uZkFEZWxEaWFnTG5rRmFpbGVkPURlbGV0aW5nIGRpYWdyYW0gbGluayBvZiAiezF9IiBmYWlsZWQuXG5jb25mQVVuZXhwRXJyUHJvY2Vzc1BhZ2U9VW5leHBlY3RlZCBlcnJvciBkdXJpbmcgcHJvY2Vzc2luZyB0aGUgcGFnZSB3aXRoIGlkOiB7MX1cbmNvbmZBRGlhZ0ZvdW5kSW5kZXg9RGlhZ3JhbSAiezF9IiBmb3VuZC4gSW5kZXhpbmdcbmNvbmZBRGlhZ0luZGV4U3VjYz1EaWFncmFtICJ7MX0iIGluZGV4ZWQgc3VjY2Vzc2Z1bGx5LlxuY29uZkFJbmRleERpYWdGYWlsZWQ9SW5kZXhpbmcgZGlhZ3JhbSAiezF9IiBmYWlsZWQuXG5jb25mQVNraXBEaWFnT3RoZXJQYWdlPVNraXBwZWQgInsxfSIgYXMgaXQgYmVsb25ncyB0byBhbm90aGVyIHBhZ2UhXG5jb25mQURpYWdVcHRvRGF0ZT1EaWFncmFtICJ7MX0iIGlzIHVwIHRvIGRhdGUuXG5jb25mQUNoZWNrUGFnZXNXRHJhdz1DaGVja2luZyBwYWdlcyBoYXZpbmcgZHJhdy5pbyBkaWFncmFtcy5cbmNvbmZBRXJyT2NjdXJlZD1BbiBlcnJvciBvY2N1cnJlZCFcbnNhdmVkU3VjYz1TYXZlZCBzdWNjZXNzZnVsbHlcbmNvbmZBU2F2ZUZhaWxlZEVycj1TYXZpbmcgRmFpbGVkIChVbmV4cGVjdGVkIEVycm9yKVxuY2hhcmFjdGVyPUNoYXJhY3RlclxuY29uZkFDb25mUGFnZURlc2M9VGhpcyBwYWdlIGNvbnRhaW5zIGRyYXcuaW8gY29uZmlndXJhdGlvbiBmaWxlIChjb25maWd1cmF0aW9uLmpzb24pIGFzIGF0dGFjaG1lbnRcbmNvbmZBTGliUGFnZURlc2M9VGhpcyBwYWdlIGNvbnRhaW5zIGRyYXcuaW8gY3VzdG9tIGxpYnJhcmllcyBhcyBhdHRhY2htZW50c1xuY29uZkFUZW1wUGFnZURlc2M9VGhpcyBwYWdlIGNvbnRhaW5zIGRyYXcuaW8gY3VzdG9tIHRlbXBsYXRlcyBhcyBhdHRhY2htZW50c1xud29ya2luZz1Xb3JraW5nXG5jb25mQUNvbmZTcGFjZURlc2M9VGhpcyBzcGFjZSBpcyB1c2VkIHRvIHN0b3JlIGRyYXcuaW8gY29uZmlndXJhdGlvbiBmaWxlcyBhbmQgY3VzdG9tIGxpYnJhcmllcy90ZW1wbGF0ZXNcbmNvbmZBTm9DdXN0TGliPU5vIEN1c3RvbSBMaWJyYXJpZXNcbmRlbEZhaWxlZD1EZWxldGUgZmFpbGVkIVxuc2hvd0lEPVNob3cgSURcbmNvbmZBSW5jb3JyZWN0TGliRmlsZVR5cGU9SW5jb3JyZWN0IGZpbGUgdHlwZS4gTGlicmFyaWVzIHNob3VsZCBiZSBYTUwgZmlsZXMuXG51cGxvYWRpbmc9VXBsb2FkaW5nXG5jb25mQUxpYkV4aXN0PVRoaXMgbGlicmFyeSBhbHJlYWR5IGV4aXN0c1xuY29uZkFVcGxvYWRTdWNjPVVwbG9hZGVkIHN1Y2Nlc3NmdWxseVxuY29uZkFVcGxvYWRGYWlsRXJyPVVwbG9hZCBGYWlsZWQgKFVuZXhwZWN0ZWQgRXJyb3IpXG5oaVJlc1ByZXZpZXc9SGlnaCBSZXMgUHJldmlld1xub2ZmaWNlTm90TG9nZ2VkR0Q9WW91IGFyZSBub3QgbG9nZ2VkIGluIHRvIEdvb2dsZSBEcml2ZS4gUGxlYXNlIG9wZW4gZHJhdy5pbyB0YXNrIHBhbmUgYW5kIGxvZ2luIGZpcnN0Llxub2ZmaWNlUG9wdXBJbmZvPVBsZWFzZSBjb21wbGV0ZSB0aGUgcHJvY2VzcyBpbiB0aGUgcG9wLXVwIHdpbmRvdy5cbnBpY2tPREZpbGU9UGljayBPbmVEcml2ZSBGaWxlXG5waWNrR0RyaXZlRmlsZT1QaWNrIEdvb2dsZSBEcml2ZSBGaWxlXG5waWNrRGV2aWNlRmlsZT1QaWNrIERldmljZSBGaWxlXG52c2ROb0NvbmZpZz0idnNkdXJsIiBpcyBub3QgY29uZmlndXJlZFxucnVsZXI9UnVsZXJcbnVuaXRzPVVuaXRzXG5wb2ludHM9UG9pbnRzXG5pbmNoZXM9SW5jaGVzXG5taWxsaW1ldGVycz1NaWxsaW1ldGVyc1xuY29uZkVkaXREcmFmdERlbE9yRXh0PVRoaXMgZGlhZ3JhbSBpcyBpbiBhIGRyYWZ0IHBhZ2UsIGlzIGRlbGV0ZWQgZnJvbSB0aGUgcGFnZSwgb3IgaXMgZWRpdGVkIGV4dGVybmFsbHkuIEl0IHdpbGwgYmUgc2F2ZWQgYXMgYSBuZXcgYXR0YWNobWVudCB2ZXJzaW9uIGFuZCBtYXkgbm90IGJlIHJlZmxlY3RlZCBpbiB0aGUgcGFnZS5cbmNvbmZEaWFnRWRpdGVkRXh0PURpYWdyYW0gaXMgZWRpdGVkIGluIGFub3RoZXIgc2Vzc2lvbi4gSXQgd2lsbCBiZSBzYXZlZCBhcyBhIG5ldyBhdHRhY2htZW50IHZlcnNpb24gYnV0IHRoZSBwYWdlIHdpbGwgc2hvdyBvdGhlciBzZXNzaW9uXCdzIG1vZGlmaWNhdGlvbnMuXG5tYWNyb05vdEZvdW5kPU1hY3JvIE5vdCBGb3VuZFxuY29uZkFJbnZhbGlkUGFnZUlkc0Zvcm1hdD1JbmNvcnJlY3QgUGFnZSBJRHMgZmlsZSBmb3JtYXRcbmNvbmZBQ29sbGVjdGluZ0N1clBhZ2VzPUNvbGxlY3RpbmcgY3VycmVudCBwYWdlc1xuY29uZkFCdWlsZGluZ1BhZ2VzTWFwPUJ1aWxkaW5nIHBhZ2VzIG1hcHBpbmdcbmNvbmZBUHJvY2Vzc0RyYXdEaWFnPVN0YXJ0ZWQgcHJvY2Vzc2luZyBpbXBvcnRlZCBkcmF3LmlvIGRpYWdyYW1zXG5jb25mQVByb2Nlc3NEcmF3RGlhZ0RvbmU9RmluaXNoZWQgcHJvY2Vzc2luZyBpbXBvcnRlZCBkcmF3LmlvIGRpYWdyYW1zXG5jb25mQVByb2Nlc3NJbXBQYWdlcz1TdGFydGVkIHByb2Nlc3NpbmcgaW1wb3J0ZWQgcGFnZXNcbmNvbmZBRXJyUHJjc0RpYWdJblBhZ2U9RXJyb3IgcHJvY2Vzc2luZyBkcmF3LmlvIGRpYWdyYW1zIGluIHBhZ2UgInsxfSJcbmNvbmZBUHJjc0RpYWdJblBhZ2U9UHJvY2Vzc2luZyBkcmF3LmlvIGRpYWdyYW1zIGluIHBhZ2UgInsxfSJcbmNvbmZBSW1wRGlhZ3JhbT1JbXBvcnRpbmcgZGlhZ3JhbSAiezF9IlxuY29uZkFJbXBEaWFncmFtRmFpbGVkPUltcG9ydGluZyBkaWFncmFtICJ7MX0iIGZhaWxlZC4gQ2Fubm90IGZpbmQgaXRzIG5ldyBwYWdlIElELiBNYXliZSBpdCBwb2ludHMgdG8gYSBwYWdlIHRoYXQgaXMgbm90IGltcG9ydGVkLiBcbmNvbmZBSW1wRGlhZ3JhbUVycm9yPUVycm9yIGltcG9ydGluZyBkaWFncmFtICJ7MX0iLiBDYW5ub3QgZmV0Y2ggb3Igc2F2ZSB0aGUgZGlhZ3JhbS4gQ2Fubm90IGZpeCB0aGlzIGRpYWdyYW0gbGlua3MuXG5jb25mQVVwZGF0ZURncm1DQ0ZhaWxlZD1VcGRhdGluZyBsaW5rIHRvIGRpYWdyYW0gInsxfSIgZmFpbGVkLlxuY29uZkltcERpYWdyYW1TdWNjZXNzPVVwZGF0aW5nIGRpYWdyYW0gInsxfSIgZG9uZSBzdWNjZXNzZnVsbHkuXG5jb25mQU5vTG5rc0luRHJnbT1ObyBsaW5rcyB0byB1cGRhdGUgaW46IHsxfVxuY29uZkFVcGRhdGVMbmtUb1BnPVVwZGF0ZWQgbGluayB0byBwYWdlOiAiezF9IiBpbiBkaWFncmFtOiAiezJ9IlxuY29uZkFVcGRhdGVMQkxua1RvUGc9VXBkYXRlZCBsaWdodGJveCBsaW5rIHRvIHBhZ2U6ICJ7MX0iIGluIGRpYWdyYW06ICJ7Mn0iXG5jb25mQVVwZGF0ZUxua0Jhc2U9VXBkYXRlZCBiYXNlIFVSTCBmcm9tOiAiezF9IiB0bzogInsyfSIgaW4gZGlhZ3JhbTogInszfSJcbmNvbmZBUGFnZUlkc0ltcERvbmU9UGFnZSBJRHMgSW1wb3J0IGZpbmlzaGVkLlxuY29uZkFQcmNzTWFjcm9zSW5QYWdlPVByb2Nlc3NpbmcgZHJhdy5pbyBtYWNyb3MgaW4gcGFnZSAiezF9IlxuY29uZkFFcnJGZXRjaFBhZ2U9RXJyb3IgZmV0Y2hpbmcgcGFnZSAiezF9IlxuY29uZkFGaXhpbmdNYWNybz1GaXhpbmcgbWFjcm8gb2YgZGlhZ3JhbSAiezF9IlxuY29uZkFFcnJSZWFkaW5nRXhwRmlsZT1FcnJvciByZWFkaW5nIGV4cG9ydCBmaWxlXG5jb25mQVByY3NEaWFnSW5QYWdlRG9uZT1Qcm9jZXNzaW5nIGRyYXcuaW8gZGlhZ3JhbXMgaW4gcGFnZSAiezF9IiBmaW5pc2hlZFxuY29uZkFGaXhpbmdNYWNyb1NraXBwZWQ9Rml4aW5nIG1hY3JvIG9mIGRpYWdyYW0gInsxfSIgZmFpbGVkLiBDYW5ub3QgZmluZCBpdHMgbmV3IHBhZ2UgSUQuIE1heWJlIGl0IHBvaW50cyB0byBhIHBhZ2UgdGhhdCBpcyBub3QgaW1wb3J0ZWQuIFxucGFnZUlkc0V4cFRyZz1FeHBvcnQgdGFyZ2V0XG5jb25mQUx1Y2lkRGlhZ0ltZ0ltcG9ydGVkPXsyfSBkaWFncmFtICJ7MX0iIGltYWdlIGV4dHJhY3RlZCBzdWNjZXNzZnVsbHkuXG5jb25mQVNhdmluZ0x1Y2lkRGlhZ0ltZ0ZhaWxlZD1FeHRyYWN0aW5nIHsyfSBkaWFncmFtICJ7MX0iIGltYWdlIGZhaWxlZC5cbmNvbmZHZXRJbmZvRmFpbGVkPUZldGNoaW5nIGZpbGUgaW5mbyBmcm9tIHsxfSBmYWlsZWQuXG5jb25mQ2hlY2tDYWNoZUZhaWxlZD1DYW5ub3QgZ2V0IGNhY2hlZCBmaWxlIGluZm8uXG5jb25mUmVhZEZpbGVFcnI9Q2Fubm90IHJlYWQgInsxfSIgZmlsZSBmcm9tIHsyfS5cbmNvbmZTYXZlQ2FjaGVGYWlsZWQ9VW5leHBlY3RlZCBlcnJvci4gQ2Fubm90IHNhdmUgY2FjaGVkIGZpbGVcbm9yZ0NoYXJ0VHlwZT1PcmcgQ2hhcnQgVHlwZVxubGluZWFyPUxpbmVhclxuaGFuZ2VyMj1IYW5nZXIgMlxuaGFuZ2VyND1IYW5nZXIgNFxuZmlzaGJvbmUxPUZpc2hib25lIDFcbmZpc2hib25lMj1GaXNoYm9uZSAyXG4xQ29sdW1uTGVmdD1TaW5nbGUgQ29sdW1uIExlZnRcbjFDb2x1bW5SaWdodD1TaW5nbGUgQ29sdW1uIFJpZ2h0XG5zbWFydD1TbWFydFxucGFyZW50Q2hpbGRTcGFjaW5nPVBhcmVudCBDaGlsZCBTcGFjaW5nXG5zaWJsaW5nU3BhY2luZz1TaWJsaW5nIFNwYWNpbmdcbmNvbmZOb1Blcm1FcnI9U29ycnksIHlvdSBkb25cJ3QgaGF2ZSBlbm91Z2ggcGVybWlzc2lvbnMgdG8gdmlldyB0aGlzIGVtYmVkZGVkIGRpYWdyYW0gZnJvbSBwYWdlIHsxfVxuY29weUFzSW1hZ2U9Q29weSBhcyBJbWFnZVxubHVjaWRJbXBvcnQ9THVjaWRjaGFydCBJbXBvcnRcbmx1Y2lkSW1wb3J0SW5zdDE9Q2xpY2sgdGhlICJTdGFydCBJbXBvcnQiIGJ1dHRvbiB0byBpbXBvcnQgYWxsIEx1Y2lkY2hhcnQgZGlhZ3JhbXMuXG5pbnN0YWxsRmlyc3Q9UGxlYXNlIGluc3RhbGwgezF9IGZpcnN0LlxuZHJhd2lvQ2hyb21lRXh0PWRyYXcuaW8gQ2hyb21lIEV4dGVuc2lvblxubG9naW5GaXJzdFRoZW49UGxlYXNlIGxvZ2luIHRvIHsxfSBmaXJzdCwgdGhlbiB7Mn1cbmVyckZldGNoRG9jTGlzdD1FcnJvcjogQ291bGRuXCd0IGZldGNoIGRvY3VtZW50cyBsaXN0LlxuYnVpbHRpblBsdWdpbnM9QnVpbHQtaW4gUGx1Z2luc1xuZXh0UGx1Z2lucz1FeHRlcm5hbCBQbHVnaW5zXG5iYWNrdXBGb3VuZD1CYWNrdXAgZmlsZSBmb3VuZFxuY2hyb21lT25seT1UaGlzIGZlYXR1cmUgb25seSB3b3JrcyBvbiBHb29nbGUgQ2hyb21lXG4nKTtHcmFwaC5wcm90b3R5cGUuZGVmYXVsdFRoZW1lc1siZGVmYXVsdC1zdHlsZTIiXT1teFV0aWxzLnBhcnNlWG1sKCc8bXhTdHlsZXNoZWV0PjxhZGQgYXM9ImRlZmF1bHRWZXJ0ZXgiPjxhZGQgYXM9InNoYXBlIiB2YWx1ZT0ibGFiZWwiLz48YWRkIGFzPSJwZXJpbWV0ZXIiIHZhbHVlPSJyZWN0YW5nbGVQZXJpbWV0ZXIiLz48YWRkIGFzPSJmb250U2l6ZSIgdmFsdWU9IjEyIi8+PGFkZCBhcz0iZm9udEZhbWlseSIgdmFsdWU9IkhlbHZldGljYSIvPjxhZGQgYXM9ImFsaWduIiB2YWx1ZT0iY2VudGVyIi8+PGFkZCBhcz0idmVydGljYWxBbGlnbiIgdmFsdWU9Im1pZGRsZSIvPjxhZGQgYXM9ImZpbGxDb2xvciIgdmFsdWU9IiNmZmZmZmYiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9IiMwMDAwMDAiLz48YWRkIGFzPSJmb250Q29sb3IiIHZhbHVlPSIjMDAwMDAwIi8+PC9hZGQ+PGFkZCBhcz0iZGVmYXVsdEVkZ2UiPjxhZGQgYXM9InNoYXBlIiB2YWx1ZT0iY29ubmVjdG9yIi8+PGFkZCBhcz0ibGFiZWxCYWNrZ3JvdW5kQ29sb3IiIHZhbHVlPSIjZmZmZmZmIi8+PGFkZCBhcz0iZW5kQXJyb3ciIHZhbHVlPSJjbGFzc2ljIi8+PGFkZCBhcz0iZm9udFNpemUiIHZhbHVlPSIxMSIvPjxhZGQgYXM9ImZvbnRGYW1pbHkiIHZhbHVlPSJIZWx2ZXRpY2EiLz48YWRkIGFzPSJhbGlnbiIgdmFsdWU9ImNlbnRlciIvPjxhZGQgYXM9InZlcnRpY2FsQWxpZ24iIHZhbHVlPSJtaWRkbGUiLz48YWRkIGFzPSJyb3VuZGVkIiB2YWx1ZT0iMSIvPjxhZGQgYXM9InN0cm9rZUNvbG9yIiB2YWx1ZT0iIzAwMDAwMCIvPjxhZGQgYXM9ImZvbnRDb2xvciIgdmFsdWU9IiMwMDAwMDAiLz48L2FkZD48YWRkIGFzPSJ0ZXh0Ij48YWRkIGFzPSJmaWxsQ29sb3IiIHZhbHVlPSJub25lIi8+PGFkZCBhcz0iZ3JhZGllbnRDb2xvciIgdmFsdWU9Im5vbmUiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9Im5vbmUiLz48YWRkIGFzPSJhbGlnbiIgdmFsdWU9ImxlZnQiLz48YWRkIGFzPSJ2ZXJ0aWNhbEFsaWduIiB2YWx1ZT0idG9wIi8+PC9hZGQ+PGFkZCBhcz0iZWRnZUxhYmVsIiBleHRlbmQ9InRleHQiPjxhZGQgYXM9ImxhYmVsQmFja2dyb3VuZENvbG9yIiB2YWx1ZT0iI2ZmZmZmZiIvPjxhZGQgYXM9ImZvbnRTaXplIiB2YWx1ZT0iMTEiLz48L2FkZD48YWRkIGFzPSJsYWJlbCI+PGFkZCBhcz0iZm9udFN0eWxlIiB2YWx1ZT0iMSIvPjxhZGQgYXM9ImFsaWduIiB2YWx1ZT0ibGVmdCIvPjxhZGQgYXM9InZlcnRpY2FsQWxpZ24iIHZhbHVlPSJtaWRkbGUiLz48YWRkIGFzPSJzcGFjaW5nIiB2YWx1ZT0iMiIvPjxhZGQgYXM9InNwYWNpbmdMZWZ0IiB2YWx1ZT0iNTIiLz48YWRkIGFzPSJpbWFnZVdpZHRoIiB2YWx1ZT0iNDIiLz48YWRkIGFzPSJpbWFnZUhlaWdodCIgdmFsdWU9IjQyIi8+PGFkZCBhcz0icm91bmRlZCIgdmFsdWU9IjEiLz48L2FkZD48YWRkIGFzPSJpY29uIiBleHRlbmQ9ImxhYmVsIj48YWRkIGFzPSJhbGlnbiIgdmFsdWU9ImNlbnRlciIvPjxhZGQgYXM9ImltYWdlQWxpZ24iIHZhbHVlPSJjZW50ZXIiLz48YWRkIGFzPSJ2ZXJ0aWNhbExhYmVsUG9zaXRpb24iIHZhbHVlPSJib3R0b20iLz48YWRkIGFzPSJ2ZXJ0aWNhbEFsaWduIiB2YWx1ZT0idG9wIi8+PGFkZCBhcz0ic3BhY2luZ1RvcCIgdmFsdWU9IjQiLz48YWRkIGFzPSJsYWJlbEJhY2tncm91bmRDb2xvciIgdmFsdWU9IiNmZmZmZmYiLz48YWRkIGFzPSJzcGFjaW5nIiB2YWx1ZT0iMCIvPjxhZGQgYXM9InNwYWNpbmdMZWZ0IiB2YWx1ZT0iMCIvPjxhZGQgYXM9InNwYWNpbmdUb3AiIHZhbHVlPSI2Ii8+PGFkZCBhcz0iZm9udFN0eWxlIiB2YWx1ZT0iMCIvPjxhZGQgYXM9ImltYWdlV2lkdGgiIHZhbHVlPSI0OCIvPjxhZGQgYXM9ImltYWdlSGVpZ2h0IiB2YWx1ZT0iNDgiLz48L2FkZD48YWRkIGFzPSJzd2ltbGFuZSI+PGFkZCBhcz0ic2hhcGUiIHZhbHVlPSJzd2ltbGFuZSIvPjxhZGQgYXM9ImZvbnRTaXplIiB2YWx1ZT0iMTIiLz48YWRkIGFzPSJmb250U3R5bGUiIHZhbHVlPSIxIi8+PGFkZCBhcz0ic3RhcnRTaXplIiB2YWx1ZT0iMjMiLz48L2FkZD48YWRkIGFzPSJncm91cCI+PGFkZCBhcz0idmVydGljYWxBbGlnbiIgdmFsdWU9InRvcCIvPjxhZGQgYXM9ImZpbGxDb2xvciIgdmFsdWU9Im5vbmUiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9Im5vbmUiLz48YWRkIGFzPSJncmFkaWVudENvbG9yIiB2YWx1ZT0ibm9uZSIvPjxhZGQgYXM9InBvaW50ZXJFdmVudHMiIHZhbHVlPSIwIi8+PC9hZGQ+PGFkZCBhcz0iZWxsaXBzZSI+PGFkZCBhcz0ic2hhcGUiIHZhbHVlPSJlbGxpcHNlIi8+PGFkZCBhcz0icGVyaW1ldGVyIiB2YWx1ZT0iZWxsaXBzZVBlcmltZXRlciIvPjwvYWRkPjxhZGQgYXM9InJob21idXMiPjxhZGQgYXM9InNoYXBlIiB2YWx1ZT0icmhvbWJ1cyIvPjxhZGQgYXM9InBlcmltZXRlciIgdmFsdWU9InJob21idXNQZXJpbWV0ZXIiLz48L2FkZD48YWRkIGFzPSJ0cmlhbmdsZSI+PGFkZCBhcz0ic2hhcGUiIHZhbHVlPSJ0cmlhbmdsZSIvPjxhZGQgYXM9InBlcmltZXRlciIgdmFsdWU9InRyaWFuZ2xlUGVyaW1ldGVyIi8+PC9hZGQ+PGFkZCBhcz0ibGluZSI+PGFkZCBhcz0ic2hhcGUiIHZhbHVlPSJsaW5lIi8+PGFkZCBhcz0ic3Ryb2tlV2lkdGgiIHZhbHVlPSI0Ii8+PGFkZCBhcz0ibGFiZWxCYWNrZ3JvdW5kQ29sb3IiIHZhbHVlPSIjZmZmZmZmIi8+PGFkZCBhcz0idmVydGljYWxBbGlnbiIgdmFsdWU9InRvcCIvPjxhZGQgYXM9InNwYWNpbmdUb3AiIHZhbHVlPSI4Ii8+PC9hZGQ+PGFkZCBhcz0iaW1hZ2UiPjxhZGQgYXM9InNoYXBlIiB2YWx1ZT0iaW1hZ2UiLz48YWRkIGFzPSJsYWJlbEJhY2tncm91bmRDb2xvciIgdmFsdWU9IndoaXRlIi8+PGFkZCBhcz0idmVydGljYWxBbGlnbiIgdmFsdWU9InRvcCIvPjxhZGQgYXM9InZlcnRpY2FsTGFiZWxQb3NpdGlvbiIgdmFsdWU9ImJvdHRvbSIvPjwvYWRkPjxhZGQgYXM9InJvdW5kSW1hZ2UiIGV4dGVuZD0iaW1hZ2UiPjxhZGQgYXM9InBlcmltZXRlciIgdmFsdWU9ImVsbGlwc2VQZXJpbWV0ZXIiLz48L2FkZD48YWRkIGFzPSJyaG9tYnVzSW1hZ2UiIGV4dGVuZD0iaW1hZ2UiPjxhZGQgYXM9InBlcmltZXRlciIgdmFsdWU9InJob21idXNQZXJpbWV0ZXIiLz48L2FkZD48YWRkIGFzPSJhcnJvdyI+PGFkZCBhcz0ic2hhcGUiIHZhbHVlPSJhcnJvdyIvPjxhZGQgYXM9ImVkZ2VTdHlsZSIgdmFsdWU9Im5vbmUiLz48YWRkIGFzPSJmaWxsQ29sb3IiIHZhbHVlPSIjZmZmZmZmIi8+PC9hZGQ+PGFkZCBhcz0iZmFuY3kiPjxhZGQgYXM9InNoYWRvdyIgdmFsdWU9IjEiLz48YWRkIGFzPSJnbGFzcyIgdmFsdWU9IjEiLz48L2FkZD48YWRkIGFzPSJncmF5IiBleHRlbmQ9ImZhbmN5Ij48YWRkIGFzPSJncmFkaWVudENvbG9yIiB2YWx1ZT0iI0IzQjNCMyIvPjxhZGQgYXM9ImZpbGxDb2xvciIgdmFsdWU9IiNGNUY1RjUiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9IiM2NjY2NjYiLz48L2FkZD48YWRkIGFzPSJibHVlIiBleHRlbmQ9ImZhbmN5Ij48YWRkIGFzPSJncmFkaWVudENvbG9yIiB2YWx1ZT0iIzdFQTZFMCIvPjxhZGQgYXM9ImZpbGxDb2xvciIgdmFsdWU9IiNEQUU4RkMiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9IiM2QzhFQkYiLz48L2FkZD48YWRkIGFzPSJncmVlbiIgZXh0ZW5kPSJmYW5jeSI+PGFkZCBhcz0iZ3JhZGllbnRDb2xvciIgdmFsdWU9IiM5N0QwNzciLz48YWRkIGFzPSJmaWxsQ29sb3IiIHZhbHVlPSIjRDVFOEQ0Ii8+PGFkZCBhcz0ic3Ryb2tlQ29sb3IiIHZhbHVlPSIjODJCMzY2Ii8+PC9hZGQ+PGFkZCBhcz0idHVycXVvaXNlIiBleHRlbmQ9ImZhbmN5Ij48YWRkIGFzPSJncmFkaWVudENvbG9yIiB2YWx1ZT0iIzY3QUI5RiIvPjxhZGQgYXM9ImZpbGxDb2xvciIgdmFsdWU9IiNENUU4RDQiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9IiM2QTkxNTMiLz48L2FkZD48YWRkIGFzPSJ5ZWxsb3ciIGV4dGVuZD0iZmFuY3kiPjxhZGQgYXM9ImdyYWRpZW50Q29sb3IiIHZhbHVlPSIjRkZEOTY2Ii8+PGFkZCBhcz0iZmlsbENvbG9yIiB2YWx1ZT0iI0ZGRjJDQyIvPjxhZGQgYXM9InN0cm9rZUNvbG9yIiB2YWx1ZT0iI0Q2QjY1NiIvPjwvYWRkPjxhZGQgYXM9Im9yYW5nZSIgZXh0ZW5kPSJmYW5jeSI+PGFkZCBhcz0iZ3JhZGllbnRDb2xvciIgdmFsdWU9IiNGRkE1MDAiLz48YWRkIGFzPSJmaWxsQ29sb3IiIHZhbHVlPSIjRkZDRDI4Ii8+PGFkZCBhcz0ic3Ryb2tlQ29sb3IiIHZhbHVlPSIjRDc5QjAwIi8+PC9hZGQ+PGFkZCBhcz0icmVkIiBleHRlbmQ9ImZhbmN5Ij48YWRkIGFzPSJncmFkaWVudENvbG9yIiB2YWx1ZT0iI0VBNkI2NiIvPjxhZGQgYXM9ImZpbGxDb2xvciIgdmFsdWU9IiNGOENFQ0MiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9IiNCODU0NTAiLz48L2FkZD48YWRkIGFzPSJwaW5rIiBleHRlbmQ9ImZhbmN5Ij48YWRkIGFzPSJncmFkaWVudENvbG9yIiB2YWx1ZT0iI0I1NzM5RCIvPjxhZGQgYXM9ImZpbGxDb2xvciIgdmFsdWU9IiNFNkQwREUiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9IiM5OTYxODUiLz48L2FkZD48YWRkIGFzPSJwdXJwbGUiIGV4dGVuZD0iZmFuY3kiPjxhZGQgYXM9ImdyYWRpZW50Q29sb3IiIHZhbHVlPSIjOEM2QzlDIi8+PGFkZCBhcz0iZmlsbENvbG9yIiB2YWx1ZT0iI0UxRDVFNyIvPjxhZGQgYXM9InN0cm9rZUNvbG9yIiB2YWx1ZT0iIzk2NzNBNiIvPjwvYWRkPjxhZGQgYXM9InBsYWluLWdyYXkiPjxhZGQgYXM9ImdyYWRpZW50Q29sb3IiIHZhbHVlPSIjQjNCM0IzIi8+PGFkZCBhcz0iZmlsbENvbG9yIiB2YWx1ZT0iI0Y1RjVGNSIvPjxhZGQgYXM9InN0cm9rZUNvbG9yIiB2YWx1ZT0iIzY2NjY2NiIvPjwvYWRkPjxhZGQgYXM9InBsYWluLWJsdWUiPjxhZGQgYXM9ImdyYWRpZW50Q29sb3IiIHZhbHVlPSIjN0VBNkUwIi8+PGFkZCBhcz0iZmlsbENvbG9yIiB2YWx1ZT0iI0RBRThGQyIvPjxhZGQgYXM9InN0cm9rZUNvbG9yIiB2YWx1ZT0iIzZDOEVCRiIvPjwvYWRkPjxhZGQgYXM9InBsYWluLWdyZWVuIj48YWRkIGFzPSJncmFkaWVudENvbG9yIiB2YWx1ZT0iIzk3RDA3NyIvPjxhZGQgYXM9ImZpbGxDb2xvciIgdmFsdWU9IiNENUU4RDQiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9IiM4MkIzNjYiLz48L2FkZD48YWRkIGFzPSJwbGFpbi10dXJxdW9pc2UiPjxhZGQgYXM9ImdyYWRpZW50Q29sb3IiIHZhbHVlPSIjNjdBQjlGIi8+PGFkZCBhcz0iZmlsbENvbG9yIiB2YWx1ZT0iI0Q1RThENCIvPjxhZGQgYXM9InN0cm9rZUNvbG9yIiB2YWx1ZT0iIzZBOTE1MyIvPjwvYWRkPjxhZGQgYXM9InBsYWluLXllbGxvdyI+PGFkZCBhcz0iZ3JhZGllbnRDb2xvciIgdmFsdWU9IiNGRkQ5NjYiLz48YWRkIGFzPSJmaWxsQ29sb3IiIHZhbHVlPSIjRkZGMkNDIi8+PGFkZCBhcz0ic3Ryb2tlQ29sb3IiIHZhbHVlPSIjRDZCNjU2Ii8+PC9hZGQ+PGFkZCBhcz0icGxhaW4tb3JhbmdlIj48YWRkIGFzPSJncmFkaWVudENvbG9yIiB2YWx1ZT0iI0ZGQTUwMCIvPjxhZGQgYXM9ImZpbGxDb2xvciIgdmFsdWU9IiNGRkNEMjgiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9IiNENzlCMDAiLz48L2FkZD48YWRkIGFzPSJwbGFpbi1yZWQiPjxhZGQgYXM9ImdyYWRpZW50Q29sb3IiIHZhbHVlPSIjRUE2QjY2Ii8+PGFkZCBhcz0iZmlsbENvbG9yIiB2YWx1ZT0iI0Y4Q0VDQyIvPjxhZGQgYXM9InN0cm9rZUNvbG9yIiB2YWx1ZT0iI0I4NTQ1MCIvPjwvYWRkPjxhZGQgYXM9InBsYWluLXBpbmsiPjxhZGQgYXM9ImdyYWRpZW50Q29sb3IiIHZhbHVlPSIjQjU3MzlEIi8+PGFkZCBhcz0iZmlsbENvbG9yIiB2YWx1ZT0iI0U2RDBERSIvPjxhZGQgYXM9InN0cm9rZUNvbG9yIiB2YWx1ZT0iIzk5NjE4NSIvPjwvYWRkPjxhZGQgYXM9InBsYWluLXB1cnBsZSI+PGFkZCBhcz0iZ3JhZGllbnRDb2xvciIgdmFsdWU9IiM4QzZDOUMiLz48YWRkIGFzPSJmaWxsQ29sb3IiIHZhbHVlPSIjRTFENUU3Ii8+PGFkZCBhcz0ic3Ryb2tlQ29sb3IiIHZhbHVlPSIjOTY3M0E2Ii8+PC9hZGQ+PC9teFN0eWxlc2hlZXQ+JykuZG9jdW1lbnRFbGVtZW50OwpHcmFwaC5wcm90b3R5cGUuZGVmYXVsdFRoZW1lcy5kYXJrVGhlbWU9bXhVdGlscy5wYXJzZVhtbCgnPG14U3R5bGVzaGVldD48YWRkIGFzPSJkZWZhdWx0VmVydGV4Ij48YWRkIGFzPSJzaGFwZSIgdmFsdWU9ImxhYmVsIi8+PGFkZCBhcz0icGVyaW1ldGVyIiB2YWx1ZT0icmVjdGFuZ2xlUGVyaW1ldGVyIi8+PGFkZCBhcz0iZm9udFNpemUiIHZhbHVlPSIxMiIvPjxhZGQgYXM9ImZvbnRGYW1pbHkiIHZhbHVlPSJIZWx2ZXRpY2EiLz48YWRkIGFzPSJhbGlnbiIgdmFsdWU9ImNlbnRlciIvPjxhZGQgYXM9InZlcnRpY2FsQWxpZ24iIHZhbHVlPSJtaWRkbGUiLz48YWRkIGFzPSJmaWxsQ29sb3IiIHZhbHVlPSIjMmEyYTJhIi8+PGFkZCBhcz0ic3Ryb2tlQ29sb3IiIHZhbHVlPSIjZjBmMGYwIi8+PGFkZCBhcz0iZm9udENvbG9yIiB2YWx1ZT0iI2YwZjBmMCIvPjwvYWRkPjxhZGQgYXM9ImRlZmF1bHRFZGdlIj48YWRkIGFzPSJzaGFwZSIgdmFsdWU9ImNvbm5lY3RvciIvPjxhZGQgYXM9ImxhYmVsQmFja2dyb3VuZENvbG9yIiB2YWx1ZT0iIzJhMmEyYSIvPjxhZGQgYXM9ImVuZEFycm93IiB2YWx1ZT0iY2xhc3NpYyIvPjxhZGQgYXM9ImZvbnRTaXplIiB2YWx1ZT0iMTEiLz48YWRkIGFzPSJmb250RmFtaWx5IiB2YWx1ZT0iSGVsdmV0aWNhIi8+PGFkZCBhcz0iYWxpZ24iIHZhbHVlPSJjZW50ZXIiLz48YWRkIGFzPSJ2ZXJ0aWNhbEFsaWduIiB2YWx1ZT0ibWlkZGxlIi8+PGFkZCBhcz0icm91bmRlZCIgdmFsdWU9IjEiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9IiNmMGYwZjAiLz48YWRkIGFzPSJmb250Q29sb3IiIHZhbHVlPSIjZjBmMGYwIi8+PC9hZGQ+PGFkZCBhcz0idGV4dCI+PGFkZCBhcz0iZmlsbENvbG9yIiB2YWx1ZT0ibm9uZSIvPjxhZGQgYXM9ImdyYWRpZW50Q29sb3IiIHZhbHVlPSJub25lIi8+PGFkZCBhcz0ic3Ryb2tlQ29sb3IiIHZhbHVlPSJub25lIi8+PGFkZCBhcz0iYWxpZ24iIHZhbHVlPSJsZWZ0Ii8+PGFkZCBhcz0idmVydGljYWxBbGlnbiIgdmFsdWU9InRvcCIvPjwvYWRkPjxhZGQgYXM9ImVkZ2VMYWJlbCIgZXh0ZW5kPSJ0ZXh0Ij48YWRkIGFzPSJsYWJlbEJhY2tncm91bmRDb2xvciIgdmFsdWU9IiMyYTJhMmEiLz48YWRkIGFzPSJmb250U2l6ZSIgdmFsdWU9IjExIi8+PC9hZGQ+PGFkZCBhcz0ibGFiZWwiPjxhZGQgYXM9ImZvbnRTdHlsZSIgdmFsdWU9IjEiLz48YWRkIGFzPSJhbGlnbiIgdmFsdWU9ImxlZnQiLz48YWRkIGFzPSJ2ZXJ0aWNhbEFsaWduIiB2YWx1ZT0ibWlkZGxlIi8+PGFkZCBhcz0ic3BhY2luZyIgdmFsdWU9IjIiLz48YWRkIGFzPSJzcGFjaW5nTGVmdCIgdmFsdWU9IjUyIi8+PGFkZCBhcz0iaW1hZ2VXaWR0aCIgdmFsdWU9IjQyIi8+PGFkZCBhcz0iaW1hZ2VIZWlnaHQiIHZhbHVlPSI0MiIvPjxhZGQgYXM9InJvdW5kZWQiIHZhbHVlPSIxIi8+PC9hZGQ+PGFkZCBhcz0iaWNvbiIgZXh0ZW5kPSJsYWJlbCI+PGFkZCBhcz0iYWxpZ24iIHZhbHVlPSJjZW50ZXIiLz48YWRkIGFzPSJpbWFnZUFsaWduIiB2YWx1ZT0iY2VudGVyIi8+PGFkZCBhcz0idmVydGljYWxMYWJlbFBvc2l0aW9uIiB2YWx1ZT0iYm90dG9tIi8+PGFkZCBhcz0idmVydGljYWxBbGlnbiIgdmFsdWU9InRvcCIvPjxhZGQgYXM9InNwYWNpbmdUb3AiIHZhbHVlPSI0Ii8+PGFkZCBhcz0ibGFiZWxCYWNrZ3JvdW5kQ29sb3IiIHZhbHVlPSIjMmEyYTJhIi8+PGFkZCBhcz0ic3BhY2luZyIgdmFsdWU9IjAiLz48YWRkIGFzPSJzcGFjaW5nTGVmdCIgdmFsdWU9IjAiLz48YWRkIGFzPSJzcGFjaW5nVG9wIiB2YWx1ZT0iNiIvPjxhZGQgYXM9ImZvbnRTdHlsZSIgdmFsdWU9IjAiLz48YWRkIGFzPSJpbWFnZVdpZHRoIiB2YWx1ZT0iNDgiLz48YWRkIGFzPSJpbWFnZUhlaWdodCIgdmFsdWU9IjQ4Ii8+PC9hZGQ+PGFkZCBhcz0ic3dpbWxhbmUiPjxhZGQgYXM9InNoYXBlIiB2YWx1ZT0ic3dpbWxhbmUiLz48YWRkIGFzPSJmb250U2l6ZSIgdmFsdWU9IjEyIi8+PGFkZCBhcz0iZm9udFN0eWxlIiB2YWx1ZT0iMSIvPjxhZGQgYXM9InN0YXJ0U2l6ZSIgdmFsdWU9IjIzIi8+PC9hZGQ+PGFkZCBhcz0iZ3JvdXAiPjxhZGQgYXM9InZlcnRpY2FsQWxpZ24iIHZhbHVlPSJ0b3AiLz48YWRkIGFzPSJmaWxsQ29sb3IiIHZhbHVlPSJub25lIi8+PGFkZCBhcz0ic3Ryb2tlQ29sb3IiIHZhbHVlPSJub25lIi8+PGFkZCBhcz0iZ3JhZGllbnRDb2xvciIgdmFsdWU9Im5vbmUiLz48YWRkIGFzPSJwb2ludGVyRXZlbnRzIiB2YWx1ZT0iMCIvPjwvYWRkPjxhZGQgYXM9ImVsbGlwc2UiPjxhZGQgYXM9InNoYXBlIiB2YWx1ZT0iZWxsaXBzZSIvPjxhZGQgYXM9InBlcmltZXRlciIgdmFsdWU9ImVsbGlwc2VQZXJpbWV0ZXIiLz48L2FkZD48YWRkIGFzPSJyaG9tYnVzIj48YWRkIGFzPSJzaGFwZSIgdmFsdWU9InJob21idXMiLz48YWRkIGFzPSJwZXJpbWV0ZXIiIHZhbHVlPSJyaG9tYnVzUGVyaW1ldGVyIi8+PC9hZGQ+PGFkZCBhcz0idHJpYW5nbGUiPjxhZGQgYXM9InNoYXBlIiB2YWx1ZT0idHJpYW5nbGUiLz48YWRkIGFzPSJwZXJpbWV0ZXIiIHZhbHVlPSJ0cmlhbmdsZVBlcmltZXRlciIvPjwvYWRkPjxhZGQgYXM9ImxpbmUiPjxhZGQgYXM9InNoYXBlIiB2YWx1ZT0ibGluZSIvPjxhZGQgYXM9InN0cm9rZVdpZHRoIiB2YWx1ZT0iNCIvPjxhZGQgYXM9ImxhYmVsQmFja2dyb3VuZENvbG9yIiB2YWx1ZT0iIzJhMmEyYSIvPjxhZGQgYXM9InZlcnRpY2FsQWxpZ24iIHZhbHVlPSJ0b3AiLz48YWRkIGFzPSJzcGFjaW5nVG9wIiB2YWx1ZT0iOCIvPjwvYWRkPjxhZGQgYXM9ImltYWdlIj48YWRkIGFzPSJzaGFwZSIgdmFsdWU9ImltYWdlIi8+PGFkZCBhcz0ibGFiZWxCYWNrZ3JvdW5kQ29sb3IiIHZhbHVlPSIjMmEyYTJhIi8+PGFkZCBhcz0idmVydGljYWxBbGlnbiIgdmFsdWU9InRvcCIvPjxhZGQgYXM9InZlcnRpY2FsTGFiZWxQb3NpdGlvbiIgdmFsdWU9ImJvdHRvbSIvPjwvYWRkPjxhZGQgYXM9InJvdW5kSW1hZ2UiIGV4dGVuZD0iaW1hZ2UiPjxhZGQgYXM9InBlcmltZXRlciIgdmFsdWU9ImVsbGlwc2VQZXJpbWV0ZXIiLz48L2FkZD48YWRkIGFzPSJyaG9tYnVzSW1hZ2UiIGV4dGVuZD0iaW1hZ2UiPjxhZGQgYXM9InBlcmltZXRlciIgdmFsdWU9InJob21idXNQZXJpbWV0ZXIiLz48L2FkZD48YWRkIGFzPSJhcnJvdyI+PGFkZCBhcz0ic2hhcGUiIHZhbHVlPSJhcnJvdyIvPjxhZGQgYXM9ImVkZ2VTdHlsZSIgdmFsdWU9Im5vbmUiLz48YWRkIGFzPSJmaWxsQ29sb3IiIHZhbHVlPSIjMmEyYTJhIi8+PC9hZGQ+PC9teFN0eWxlc2hlZXQ+JykuZG9jdW1lbnRFbGVtZW50O0dyYXBoVmlld2VyPWZ1bmN0aW9uKGEsYyxmKXt0aGlzLmluaXQoYSxjLGYpfTtteFV0aWxzLmV4dGVuZChHcmFwaFZpZXdlcixteEV2ZW50U291cmNlKTtHcmFwaFZpZXdlci5wcm90b3R5cGUuZWRpdEJsYW5rVXJsPSJodHRwczovL2FwcC5kaWFncmFtcy5uZXQvIjtHcmFwaFZpZXdlci5wcm90b3R5cGUuaW1hZ2VCYXNlVXJsPSJodHRwczovL2FwcC5kaWFncmFtcy5uZXQvIjtHcmFwaFZpZXdlci5wcm90b3R5cGUudG9vbGJhckhlaWdodD0iQmFja0NvbXBhdCI9PWRvY3VtZW50LmNvbXBhdE1vZGU/Mjg6MzA7R3JhcGhWaWV3ZXIucHJvdG90eXBlLmxpZ2h0Ym94Q2hyb21lPSEwO0dyYXBoVmlld2VyLnByb3RvdHlwZS5saWdodGJveFpJbmRleD05OTk7R3JhcGhWaWV3ZXIucHJvdG90eXBlLnRvb2xiYXJaSW5kZXg9OTk5O0dyYXBoVmlld2VyLnByb3RvdHlwZS5hdXRvRml0PSEwO0dyYXBoVmlld2VyLnByb3RvdHlwZS5jZW50ZXI9ITE7CkdyYXBoVmlld2VyLnByb3RvdHlwZS5hbGxvd1pvb21Jbj0hMTtHcmFwaFZpZXdlci5wcm90b3R5cGUuc2hvd1RpdGxlQXNUb29sdGlwPSExO0dyYXBoVmlld2VyLnByb3RvdHlwZS5jaGVja1Zpc2libGVTdGF0ZT0hMDtHcmFwaFZpZXdlci5wcm90b3R5cGUubWluSGVpZ2h0PTI4O0dyYXBoVmlld2VyLnByb3RvdHlwZS5taW5XaWR0aD0xMDA7CkdyYXBoVmlld2VyLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKGEsYyxmKXt0aGlzLmdyYXBoQ29uZmlnPW51bGwhPWY/Zjp7fTt0aGlzLmF1dG9GaXQ9bnVsbCE9dGhpcy5ncmFwaENvbmZpZ1siYXV0by1maXQiXT90aGlzLmdyYXBoQ29uZmlnWyJhdXRvLWZpdCJdOnRoaXMuYXV0b0ZpdDt0aGlzLmFsbG93Wm9vbUluPW51bGwhPXRoaXMuZ3JhcGhDb25maWdbImFsbG93LXpvb20taW4iXT90aGlzLmdyYXBoQ29uZmlnWyJhbGxvdy16b29tLWluIl06dGhpcy5hbGxvd1pvb21Jbjt0aGlzLmNlbnRlcj1udWxsIT10aGlzLmdyYXBoQ29uZmlnLmNlbnRlcj90aGlzLmdyYXBoQ29uZmlnLmNlbnRlcjp0aGlzLmNlbnRlcjt0aGlzLmNoZWNrVmlzaWJsZVN0YXRlPW51bGwhPXRoaXMuZ3JhcGhDb25maWdbImNoZWNrLXZpc2libGUtc3RhdGUiXT90aGlzLmdyYXBoQ29uZmlnWyJjaGVjay12aXNpYmxlLXN0YXRlIl06dGhpcy5jaGVja1Zpc2libGVTdGF0ZTt0aGlzLnRvb2xiYXJJdGVtcz1udWxsIT0KdGhpcy5ncmFwaENvbmZpZy50b29sYmFyP3RoaXMuZ3JhcGhDb25maWcudG9vbGJhci5zcGxpdCgiICIpOltdO3RoaXMuem9vbUVuYWJsZWQ9MDw9bXhVdGlscy5pbmRleE9mKHRoaXMudG9vbGJhckl0ZW1zLCJ6b29tIik7dGhpcy5sYXllcnNFbmFibGVkPTA8PW14VXRpbHMuaW5kZXhPZih0aGlzLnRvb2xiYXJJdGVtcywibGF5ZXJzIik7dGhpcy5saWdodGJveEVuYWJsZWQ9MDw9bXhVdGlscy5pbmRleE9mKHRoaXMudG9vbGJhckl0ZW1zLCJsaWdodGJveCIpO3RoaXMubGlnaHRib3hDbGlja0VuYWJsZWQ9MCE9dGhpcy5ncmFwaENvbmZpZy5saWdodGJveDt0aGlzLmluaXRpYWxXaWR0aD1udWxsIT1hP2Euc3R5bGUud2lkdGg6bnVsbDt0aGlzLndpZHRoSXNFbXB0eT1udWxsIT10aGlzLmluaXRpYWxXaWR0aD8iIj09dGhpcy5pbml0aWFsV2lkdGg6ITA7dGhpcy5jdXJyZW50UGFnZT1wYXJzZUludCh0aGlzLmdyYXBoQ29uZmlnLnBhZ2UpfHwwO3RoaXMucGFnZUlkPXRoaXMuZ3JhcGhDb25maWcucGFnZUlkOwp0aGlzLmVkaXRvcj1udWxsOyJpbmxpbmUiPT10aGlzLmdyYXBoQ29uZmlnWyJ0b29sYmFyLXBvc2l0aW9uIl0mJih0aGlzLm1pbkhlaWdodCs9dGhpcy50b29sYmFySGVpZ2h0KTtpZihudWxsIT1jJiYodGhpcy54bWxEb2N1bWVudD1jLm93bmVyRG9jdW1lbnQsdGhpcy54bWxOb2RlPWMsdGhpcy54bWw9bXhVdGlscy5nZXRYbWwoYyksbnVsbCE9YSkpe3ZhciBkPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5ncmFwaD1uZXcgR3JhcGgoYSk7dGhpcy5ncmFwaC5kZWZhdWx0UGFnZUJhY2tncm91bmRDb2xvcj0idHJhbnNwYXJlbnQiO3RoaXMuZ3JhcGgudHJhbnNwYXJlbnRCYWNrZ3JvdW5kPSExO3RoaXMuZ3JhcGhDb25maWcubW92ZSYmKHRoaXMuZ3JhcGguaXNNb3ZlQ2VsbHNFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4hMH0pO3RoaXMubGlnaHRib3hDbGlja0VuYWJsZWQmJihhLnN0eWxlLmN1cnNvcj0icG9pbnRlciIpO3RoaXMuZWRpdG9yPW5ldyBFZGl0b3IoITAsCm51bGwsbnVsbCx0aGlzLmdyYXBoKTt0aGlzLmVkaXRvci5lZGl0QmxhbmtVcmw9dGhpcy5lZGl0QmxhbmtVcmw7dGhpcy5ncmFwaC5saWdodGJveD0hMDt0aGlzLmdyYXBoLmNlbnRlclpvb209ITE7dGhpcy5ncmFwaC5hdXRvRXh0ZW5kPSExO3RoaXMuZ3JhcGguYXV0b1Njcm9sbD0hMTt0aGlzLmdyYXBoLnNldEVuYWJsZWQoITEpOzE9PXRoaXMuZ3JhcGhDb25maWdbInRvb2xiYXItbm9oaWRlIl0mJih0aGlzLmVkaXRvci5kZWZhdWx0R3JhcGhPdmVyZmxvdz0idmlzaWJsZSIpO3RoaXMueG1sTm9kZT10aGlzLmVkaXRvci5leHRyYWN0R3JhcGhNb2RlbCh0aGlzLnhtbE5vZGUsITApO3RoaXMueG1sTm9kZSE9YyYmKHRoaXMueG1sPW14VXRpbHMuZ2V0WG1sKHRoaXMueG1sTm9kZSksdGhpcy54bWxEb2N1bWVudD10aGlzLnhtbE5vZGUub3duZXJEb2N1bWVudCk7dmFyIGQ9dGhpczt0aGlzLmdyYXBoLmdldEltYWdlRnJvbUJ1bmRsZXM9ZnVuY3Rpb24oYSl7cmV0dXJuIGQuZ2V0SW1hZ2VVcmwoYSl9OwpteENsaWVudC5JU19TVkcmJnRoaXMuZ3JhcGguYWRkU3ZnU2hhZG93KHRoaXMuZ3JhcGgudmlldy5jYW52YXMub3duZXJTVkdFbGVtZW50LG51bGwsITApO2lmKCJteGZpbGUiPT10aGlzLnhtbE5vZGUubm9kZU5hbWUpe3ZhciBiPXRoaXMueG1sTm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGlhZ3JhbSIpO2lmKDA8Yi5sZW5ndGgpe2lmKG51bGwhPXRoaXMucGFnZUlkKWZvcih2YXIgZT0wO2U8Yi5sZW5ndGg7ZSsrKWlmKHRoaXMucGFnZUlkPT1iW2VdLmdldEF0dHJpYnV0ZSgiaWQiKSl7dGhpcy5jdXJyZW50UGFnZT1lO2JyZWFrfXZhciBmPXRoaXMuZ3JhcGguZ2V0R2xvYmFsVmFyaWFibGUsZD10aGlzO3RoaXMuZ3JhcGguZ2V0R2xvYmFsVmFyaWFibGU9ZnVuY3Rpb24oYSl7dmFyIGM9YltkLmN1cnJlbnRQYWdlXTtyZXR1cm4icGFnZSI9PWE/Yy5nZXRBdHRyaWJ1dGUoIm5hbWUiKXx8IlBhZ2UtIisoZC5jdXJyZW50UGFnZSsxKToicGFnZW51bWJlciI9PWE/ZC5jdXJyZW50UGFnZSsKMToicGFnZWNvdW50Ij09YT9iLmxlbmd0aDpmLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19fXRoaXMuZGlhZ3JhbXM9W107dmFyIGs9bnVsbDt0aGlzLnNlbGVjdFBhZ2U9ZnVuY3Rpb24oYSl7dGhpcy5oYW5kbGluZ1Jlc2l6ZXx8KHRoaXMuY3VycmVudFBhZ2U9bXhVdGlscy5tb2QoYSx0aGlzLmRpYWdyYW1zLmxlbmd0aCksdGhpcy51cGRhdGVHcmFwaFhtbChFZGl0b3IucGFyc2VEaWFncmFtTm9kZSh0aGlzLmRpYWdyYW1zW3RoaXMuY3VycmVudFBhZ2VdKSkpfTt0aGlzLnNlbGVjdFBhZ2VCeUlkPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0hMSxjPTA7Yzx0aGlzLmRpYWdyYW1zLmxlbmd0aDtjKyspaWYodGhpcy5kaWFncmFtc1tjXS5nZXRBdHRyaWJ1dGUoImlkIik9PWEpe3RoaXMuc2VsZWN0UGFnZShjKTtiPSEwO2JyZWFrfXJldHVybiBifTtlPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7aWYobnVsbD09dGhpcy54bWxOb2RlfHwibXhmaWxlIiE9dGhpcy54bWxOb2RlLm5vZGVOYW1lKXRoaXMuZGlhZ3JhbXM9CltdO3RoaXMueG1sTm9kZSE9ayYmKHRoaXMuZGlhZ3JhbXM9dGhpcy54bWxOb2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaWFncmFtIiksaz10aGlzLnhtbE5vZGUpfSk7dGhpcy5hZGRMaXN0ZW5lcigieG1sTm9kZUNoYW5nZWQiLGUpO2UoKTt1cmxQYXJhbXMucGFnZT1kLmN1cnJlbnRQYWdlO3RoaXMuZ3JhcGguZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXt1cmxQYXJhbXMubmF2PTAhPXRoaXMuZ3JhcGhDb25maWcubmF2PyIxIjoiMCIsdGhpcy5lZGl0b3Iuc2V0R3JhcGhYbWwodGhpcy54bWxOb2RlKSx0aGlzLmdyYXBoLmJvcmRlcj1udWxsIT10aGlzLmdyYXBoQ29uZmlnLmJvcmRlcj90aGlzLmdyYXBoQ29uZmlnLmJvcmRlcjo4LHRoaXMuZ3JhcGgudmlldy5zY2FsZT10aGlzLmdyYXBoQ29uZmlnLnpvb218fDF9ZmluYWxseXt0aGlzLmdyYXBoLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9dGhpcy5ncmFwaC5wYW5uaW5nSGFuZGxlci51c2VMZWZ0QnV0dG9uRm9yUGFubmluZz0KITA7dGhpcy5ncmFwaC5wYW5uaW5nSGFuZGxlci5pc0ZvcmNlUGFubmluZ0V2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiFteEV2ZW50LmlzUG9wdXBUcmlnZ2VyKGEuZ2V0RXZlbnQoKSkmJiJhdXRvIj09dGhpcy5ncmFwaC5jb250YWluZXIuc3R5bGUub3ZlcmZsb3d9O3RoaXMuZ3JhcGgucGFubmluZ0hhbmRsZXIudXNlUG9wdXBUcmlnZ2VyPSExO3RoaXMuZ3JhcGgucGFubmluZ0hhbmRsZXIucGluY2hFbmFibGVkPSExO3RoaXMuZ3JhcGgucGFubmluZ0hhbmRsZXIuaWdub3JlQ2VsbD0hMDt0aGlzLmdyYXBoLnNldFBhbm5pbmcoITEpO251bGwhPXRoaXMuZ3JhcGhDb25maWcudG9vbGJhcj90aGlzLmFkZFRvb2xiYXIoKTpudWxsIT10aGlzLmdyYXBoQ29uZmlnLnRpdGxlJiZ0aGlzLnNob3dUaXRsZUFzVG9vbHRpcCYmYS5zZXRBdHRyaWJ1dGUoInRpdGxlIix0aGlzLmdyYXBoQ29uZmlnLnRpdGxlKTt0aGlzLmFkZFNpemVIYW5kbGVyKCk7dGhpcy5zaG93TGF5ZXJzKHRoaXMuZ3JhcGgpOwp0aGlzLmFkZENsaWNrSGFuZGxlcih0aGlzLmdyYXBoKTt0aGlzLmdyYXBoLnNldFRvb2x0aXBzKDAhPXRoaXMuZ3JhcGhDb25maWcudG9vbHRpcHMpO3RoaXMuZ3JhcGguaW5pdGlhbFZpZXdTdGF0ZT17dHJhbnNsYXRlOnRoaXMuZ3JhcGgudmlldy50cmFuc2xhdGUuY2xvbmUoKSxzY2FsZTp0aGlzLmdyYXBoLnZpZXcuc2NhbGV9O2Q9dGhpczt0aGlzLmdyYXBoLmN1c3RvbUxpbmtDbGlja2VkPWZ1bmN0aW9uKGEpe2lmKCJkYXRhOnBhZ2UvaWQsIj09YS5zdWJzdHJpbmcoMCwxMykpe3ZhciBiPWEuaW5kZXhPZigiLCIpO2Quc2VsZWN0UGFnZUJ5SWQoYS5zdWJzdHJpbmcoYisxKSl8fGFsZXJ0KG14UmVzb3VyY2VzLmdldCgicGFnZU5vdEZvdW5kIil8fCJQYWdlIG5vdCBmb3VuZCIpfWVsc2UgdGhpcy5oYW5kbGVDdXN0b21MaW5rKGEpO3JldHVybiEwfTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgicmVuZGVyIikpfSk7Zj13aW5kb3cuTXV0YXRpb25PYnNlcnZlcnx8CndpbmRvdy5XZWJLaXRNdXRhdGlvbk9ic2VydmVyfHx3aW5kb3cuTW96TXV0YXRpb25PYnNlcnZlcjtpZih0aGlzLmNoZWNrVmlzaWJsZVN0YXRlJiYwPT1hLm9mZnNldFdpZHRoJiYidW5kZWZpbmVkIiE9PXR5cGVvZiBmKXt2YXIgbT10aGlzLmdldE9ic2VydmFibGVQYXJlbnQoYSksaz1uZXcgZihteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihjKXswPGEub2Zmc2V0V2lkdGgmJihrLmRpc2Nvbm5lY3QoKSxkKCkpfSkpO2sub2JzZXJ2ZShtLHthdHRyaWJ1dGVzOiEwfSl9ZWxzZSBkKCl9fTtHcmFwaFZpZXdlci5wcm90b3R5cGUuZ2V0T2JzZXJ2YWJsZVBhcmVudD1mdW5jdGlvbihhKXtmb3IoYT1hLnBhcmVudE5vZGU7YSE9ZG9jdW1lbnQuYm9keSYmbnVsbCE9YS5wYXJlbnROb2RlJiYibm9uZSIhPT1teFV0aWxzLmdldEN1cnJlbnRTdHlsZShhKS5kaXNwbGF5OylhPWEucGFyZW50Tm9kZTtyZXR1cm4gYX07CkdyYXBoVmlld2VyLnByb3RvdHlwZS5nZXRJbWFnZVVybD1mdW5jdGlvbihhKXtudWxsIT1hJiYiaHR0cDovLyIhPWEuc3Vic3RyaW5nKDAsNykmJiJodHRwczovLyIhPWEuc3Vic3RyaW5nKDAsOCkmJiJkYXRhOmltYWdlIiE9YS5zdWJzdHJpbmcoMCwxMCkmJigiLyI9PWEuY2hhckF0KDApJiYoYT1hLnN1YnN0cmluZygxLGEubGVuZ3RoKSksYT10aGlzLmltYWdlQmFzZVVybCthKTtyZXR1cm4gYX07R3JhcGhWaWV3ZXIucHJvdG90eXBlLnNldFhtbE5vZGU9ZnVuY3Rpb24oYSl7YT10aGlzLmVkaXRvci5leHRyYWN0R3JhcGhNb2RlbChhLCEwKTt0aGlzLnhtbERvY3VtZW50PWEub3duZXJEb2N1bWVudDt0aGlzLnhtbD1teFV0aWxzLmdldFhtbChhKTt0aGlzLnhtbE5vZGU9YTt0aGlzLnVwZGF0ZUdyYXBoWG1sKGEpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJ4bWxOb2RlQ2hhbmdlZCIpKX07CkdyYXBoVmlld2VyLnByb3RvdHlwZS5zZXRGaWxlTm9kZT1mdW5jdGlvbihhKXtudWxsPT10aGlzLnhtbE5vZGUmJih0aGlzLnhtbERvY3VtZW50PWEub3duZXJEb2N1bWVudCx0aGlzLnhtbD1teFV0aWxzLmdldFhtbChhKSx0aGlzLnhtbE5vZGU9YSk7dGhpcy5zZXRHcmFwaFhtbChhKX07R3JhcGhWaWV3ZXIucHJvdG90eXBlLnVwZGF0ZUdyYXBoWG1sPWZ1bmN0aW9uKGEpe3RoaXMuc2V0R3JhcGhYbWwoYSk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImdyYXBoQ2hhbmdlZCIpKX07CkdyYXBoVmlld2VyLnByb3RvdHlwZS5zZXRHcmFwaFhtbD1mdW5jdGlvbihhKXtudWxsIT10aGlzLmdyYXBoJiYodGhpcy5ncmFwaC52aWV3LnRyYW5zbGF0ZT1uZXcgbXhQb2ludCx0aGlzLmdyYXBoLnZpZXcuc2NhbGU9MSx0aGlzLmdyYXBoLmdldE1vZGVsKCkuY2xlYXIoKSx0aGlzLmVkaXRvci5zZXRHcmFwaFhtbChhKSx0aGlzLndpZHRoSXNFbXB0eT8odGhpcy5ncmFwaC5jb250YWluZXIuc3R5bGUud2lkdGg9IiIsdGhpcy5ncmFwaC5jb250YWluZXIuc3R5bGUuaGVpZ2h0PSIiKTp0aGlzLmdyYXBoLmNvbnRhaW5lci5zdHlsZS53aWR0aD10aGlzLmluaXRpYWxXaWR0aCx0aGlzLnBvc2l0aW9uR3JhcGgoKSx0aGlzLmdyYXBoLmluaXRpYWxWaWV3U3RhdGU9e3RyYW5zbGF0ZTp0aGlzLmdyYXBoLnZpZXcudHJhbnNsYXRlLmNsb25lKCksc2NhbGU6dGhpcy5ncmFwaC52aWV3LnNjYWxlfSl9OwpHcmFwaFZpZXdlci5wcm90b3R5cGUuYWRkU2l6ZUhhbmRsZXI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoLmNvbnRhaW5lcixjPXRoaXMuZ3JhcGguZ2V0R3JhcGhCb3VuZHMoKSxmPSExO2Euc3R5bGUub3ZlcmZsb3c9MSE9dGhpcy5ncmFwaENvbmZpZ1sidG9vbGJhci1ub2hpZGUiXT8iaGlkZGVuIjoidmlzaWJsZSI7dmFyIGQ9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtpZighZil7Zj0hMDt2YXIgYj10aGlzLmdyYXBoLmdldEdyYXBoQm91bmRzKCk7YS5zdHlsZS5vdmVyZmxvdz0xIT10aGlzLmdyYXBoQ29uZmlnWyJ0b29sYmFyLW5vaGlkZSJdP2Iud2lkdGgrMip0aGlzLmdyYXBoLmJvcmRlcj5hLm9mZnNldFdpZHRoLTI/ImF1dG8iOiJoaWRkZW4iOiJ2aXNpYmxlIjtpZihudWxsIT10aGlzLnRvb2xiYXImJjEhPXRoaXMuZ3JhcGhDb25maWdbInRvb2xiYXItbm9oaWRlIl0pe3ZhciBiPWEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksYz1teFV0aWxzLmdldFNjcm9sbE9yaWdpbihkb2N1bWVudC5ib2R5KSwKYz0icmVsYXRpdmUiPT09ZG9jdW1lbnQuYm9keS5zdHlsZS5wb3NpdGlvbj9kb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOntsZWZ0Oi1jLngsdG9wOi1jLnl9LGI9e2xlZnQ6Yi5sZWZ0LWMubGVmdCx0b3A6Yi50b3AtYy50b3AsYm90dG9tOmIuYm90dG9tLWMudG9wLHJpZ2h0OmIucmlnaHQtYy5sZWZ0fTt0aGlzLnRvb2xiYXIuc3R5bGUubGVmdD1iLmxlZnQrInB4IjsiYm90dG9tIj09dGhpcy5ncmFwaENvbmZpZ1sidG9vbGJhci1wb3NpdGlvbiJdP3RoaXMudG9vbGJhci5zdHlsZS50b3A9Yi5ib3R0b20tMSsicHgiOiJpbmxpbmUiIT10aGlzLmdyYXBoQ29uZmlnWyJ0b29sYmFyLXBvc2l0aW9uIl0/KHRoaXMudG9vbGJhci5zdHlsZS53aWR0aD1NYXRoLm1heCh0aGlzLm1pblRvb2xiYXJXaWR0aCxhLm9mZnNldFdpZHRoKSsicHgiLHRoaXMudG9vbGJhci5zdHlsZS50b3A9Yi50b3ArMSsicHgiKTp0aGlzLnRvb2xiYXIuc3R5bGUudG9wPWIudG9wKyJweCJ9ZWxzZSBudWxsIT0KdGhpcy50b29sYmFyJiYodGhpcy50b29sYmFyLnN0eWxlLndpZHRoPU1hdGgubWF4KHRoaXMubWluVG9vbGJhcldpZHRoLGEub2Zmc2V0V2lkdGgpKyJweCIpO2Y9ITF9fSksbT1udWxsO3RoaXMuaGFuZGxpbmdSZXNpemU9ITE7dGhpcy5maXRHcmFwaD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXt2YXIgYz1hLm9mZnNldFdpZHRoO2M9PW18fHRoaXMuaGFuZGxpbmdSZXNpemV8fCh0aGlzLmhhbmRsaW5nUmVzaXplPSEwLCJhdXRvIj09YS5zdHlsZS5vdmVyZmxvdyYmKGEuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiIpLHRoaXMuZ3JhcGgubWF4Rml0U2NhbGU9bnVsbCE9Yj9iOnRoaXMuZ3JhcGhDb25maWcuem9vbXx8KHRoaXMuYWxsb3dab29tSW4/bnVsbDoxKSx0aGlzLmdyYXBoLmZpdChudWxsLG51bGwsbnVsbCxudWxsLG51bGwsITApLCh0aGlzLmNlbnRlcnx8MD09dGhpcy5ncmFwaENvbmZpZy5yZXNpemUmJiIiIT1hLnN0eWxlLmhlaWdodCkmJnRoaXMuZ3JhcGguY2VudGVyKCksCnRoaXMuZ3JhcGgubWF4Rml0U2NhbGU9bnVsbCwwPT10aGlzLmdyYXBoQ29uZmlnLnJlc2l6ZSYmIiIhPWEuc3R5bGUuaGVpZ2h0fHx0aGlzLnVwZGF0ZUNvbnRhaW5lckhlaWdodChhLE1hdGgubWF4KHRoaXMubWluSGVpZ2h0LHRoaXMuZ3JhcGguZ2V0R3JhcGhCb3VuZHMoKS5oZWlnaHQrMip0aGlzLmdyYXBoLmJvcmRlcisxKSksdGhpcy5ncmFwaC5pbml0aWFsVmlld1N0YXRlPXt0cmFuc2xhdGU6dGhpcy5ncmFwaC52aWV3LnRyYW5zbGF0ZS5jbG9uZSgpLHNjYWxlOnRoaXMuZ3JhcGgudmlldy5zY2FsZX0sbT1jLHdpbmRvdy5zZXRUaW1lb3V0KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5oYW5kbGluZ1Jlc2l6ZT0hMX0pLDApKX0pO0dyYXBoVmlld2VyLnVzZVJlc2l6ZVNlbnNvciYmKG14Q2xpZW50LklTX1FVSVJLU3x8OT49ZG9jdW1lbnQuZG9jdW1lbnRNb2RlPyhteEV2ZW50LmFkZExpc3RlbmVyKHdpbmRvdywicmVzaXplIixkKSx0aGlzLmdyYXBoLmFkZExpc3RlbmVyKCJzaXplIiwKZCkpOm5ldyBSZXNpemVTZW5zb3IodGhpcy5ncmFwaC5jb250YWluZXIsZCkpO2lmKHRoaXMuZ3JhcGhDb25maWcucmVzaXplfHwodGhpcy56b29tRW5hYmxlZHx8IXRoaXMuYXV0b0ZpdCkmJjAhPXRoaXMuZ3JhcGhDb25maWcucmVzaXplKXRoaXMuZ3JhcGgubWluaW11bUNvbnRhaW5lclNpemU9bmV3IG14UmVjdGFuZ2xlKDAsMCx0aGlzLm1pbldpZHRoLHRoaXMubWluSGVpZ2h0KSx0aGlzLmdyYXBoLnJlc2l6ZUNvbnRhaW5lcj0hMDtlbHNlIGlmKCF0aGlzLndpZHRoSXNFbXB0eXx8IiIhPWEuc3R5bGUuaGVpZ2h0JiZ0aGlzLmF1dG9GaXR8fHRoaXMudXBkYXRlQ29udGFpbmVyV2lkdGgoYSxjLndpZHRoKzIqdGhpcy5ncmFwaC5ib3JkZXIpLDA9PXRoaXMuZ3JhcGhDb25maWcucmVzaXplJiYiIiE9YS5zdHlsZS5oZWlnaHR8fHRoaXMudXBkYXRlQ29udGFpbmVySGVpZ2h0KGEsTWF0aC5tYXgodGhpcy5taW5IZWlnaHQsYy5oZWlnaHQrMip0aGlzLmdyYXBoLmJvcmRlcisxKSksCiF0aGlzLnpvb21FbmFibGVkJiZ0aGlzLmF1dG9GaXQpe3ZhciBrPW09bnVsbCxkPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7d2luZG93LmNsZWFyVGltZW91dChrKTt0aGlzLmhhbmRsaW5nUmVzaXplfHwoaz13aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyx0aGlzLmZpdEdyYXBoKSwxMDApKX0pO0dyYXBoVmlld2VyLnVzZVJlc2l6ZVNlbnNvciYmKG14Q2xpZW50LklTX1FVSVJLU3x8OT49ZG9jdW1lbnQuZG9jdW1lbnRNb2RlP214RXZlbnQuYWRkTGlzdGVuZXIod2luZG93LCJyZXNpemUiLGQpOm5ldyBSZXNpemVTZW5zb3IodGhpcy5ncmFwaC5jb250YWluZXIsZCkpfWVsc2UgbXhDbGllbnQuSVNfUVVJUktTfHw5Pj1kb2N1bWVudC5kb2N1bWVudE1vZGV8fHRoaXMuZ3JhcGguYWRkTGlzdGVuZXIoInNpemUiLGQpO3ZhciBxPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGI9YS5zdHlsZS5taW5XaWR0aDt0aGlzLndpZHRoSXNFbXB0eSYmKGEuc3R5bGUubWluV2lkdGg9CiIxMDAlIik7dmFyIGQ9bnVsbCE9dGhpcy5ncmFwaENvbmZpZ1sibWF4LWhlaWdodCJdP3RoaXMuZ3JhcGhDb25maWdbIm1heC1oZWlnaHQiXToiIiE9YS5zdHlsZS5oZWlnaHQmJnRoaXMuYXV0b0ZpdD9hLm9mZnNldEhlaWdodDp2b2lkIDA7aWYoMDxhLm9mZnNldFdpZHRoJiYodGhpcy5hbGxvd1pvb21Jbnx8Yy53aWR0aCsyKnRoaXMuZ3JhcGguYm9yZGVyPmEub2Zmc2V0V2lkdGh8fGMuaGVpZ2h0KzIqdGhpcy5ncmFwaC5ib3JkZXI+ZCkpe3ZhciBmPW51bGw7bnVsbCE9ZCYmYy5oZWlnaHQrMip0aGlzLmdyYXBoLmJvcmRlcj5kLTImJihmPShkLTIqdGhpcy5ncmFwaC5ib3JkZXItMikvYy5oZWlnaHQpO3RoaXMuZml0R3JhcGgoZil9ZWxzZSB0aGlzLndpZHRoSXNFbXB0eXx8MCE9dGhpcy5ncmFwaENvbmZpZy5yZXNpemV8fCIiPT1hLnN0eWxlLmhlaWdodD8odGhpcy5ncmFwaC52aWV3LnNldFRyYW5zbGF0ZShNYXRoLmZsb29yKHRoaXMuZ3JhcGguYm9yZGVyLWMueC90aGlzLmdyYXBoLnZpZXcuc2NhbGUpLApNYXRoLmZsb29yKHRoaXMuZ3JhcGguYm9yZGVyLWMueS90aGlzLmdyYXBoLnZpZXcuc2NhbGUpKSxtPWEub2Zmc2V0V2lkdGgpOnRoaXMuZ3JhcGguY2VudGVyKCghdGhpcy53aWR0aElzRW1wdHl8fGMud2lkdGg8dGhpcy5taW5XaWR0aCkmJjEhPXRoaXMuZ3JhcGhDb25maWcucmVzaXplKTthLnN0eWxlLm1pbldpZHRoPWJ9KTtteENsaWVudC5JU19RVUlSS1N8fDg9PWRvY3VtZW50LmRvY3VtZW50TW9kZT93aW5kb3cuc2V0VGltZW91dChxLDApOnEoKTt0aGlzLnBvc2l0aW9uR3JhcGg9ZnVuY3Rpb24oKXtjPXRoaXMuZ3JhcGguZ2V0R3JhcGhCb3VuZHMoKTttPW51bGw7cSgpfX07R3JhcGhWaWV3ZXIucHJvdG90eXBlLnVwZGF0ZUNvbnRhaW5lcldpZHRoPWZ1bmN0aW9uKGEsYyl7YS5zdHlsZS53aWR0aD1jKyJweCJ9OwpHcmFwaFZpZXdlci5wcm90b3R5cGUudXBkYXRlQ29udGFpbmVySGVpZ2h0PWZ1bmN0aW9uKGEsYyl7aWYodGhpcy56b29tRW5hYmxlZHx8IXRoaXMuYXV0b0ZpdHx8IkJhY2tDb21wYXQiPT1kb2N1bWVudC5jb21wYXRNb2RlfHxteENsaWVudC5JU19RVUlSS1N8fDg9PWRvY3VtZW50LmRvY3VtZW50TW9kZSlhLnN0eWxlLmhlaWdodD1jKyJweCJ9OwpHcmFwaFZpZXdlci5wcm90b3R5cGUuc2hvd0xheWVycz1mdW5jdGlvbihhLGMpe3ZhciBmPXRoaXMuZ3JhcGhDb25maWcubGF5ZXJzLGY9bnVsbCE9Zj9mLnNwbGl0KCIgIik6W10sZD10aGlzLmdyYXBoQ29uZmlnLmxheWVySWRzLG09bnVsbCE9ZCYmMDxkLmxlbmd0aDtpZigwPGYubGVuZ3RofHxtfHxudWxsIT1jKXt2YXIgaz1udWxsIT1jP2MuZ2V0TW9kZWwoKTpudWxsLHE9YS5nZXRNb2RlbCgpO3EuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBiPXEuZ2V0Q2hpbGRDb3VudChxLnJvb3QpLGU9MDtlPGI7ZSsrKXEuc2V0VmlzaWJsZShxLmdldENoaWxkQXQocS5yb290LGUpLG51bGwhPWM/ay5pc1Zpc2libGUoay5nZXRDaGlsZEF0KGsucm9vdCxlKSk6ITEpO2lmKG51bGw9PWspaWYobSlmb3IoZT0wO2U8ZC5sZW5ndGg7ZSsrKXEuc2V0VmlzaWJsZShxLmdldENlbGwoZFtlXSksITApO2Vsc2UgZm9yKGU9MDtlPGYubGVuZ3RoO2UrKylxLnNldFZpc2libGUocS5nZXRDaGlsZEF0KHEucm9vdCwKcGFyc2VJbnQoZltlXSkpLCEwKX1maW5hbGx5e3EuZW5kVXBkYXRlKCl9fX07CkdyYXBoVmlld2VyLnByb3RvdHlwZS5hZGRUb29sYmFyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGIsYyxkKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtlLnN0eWxlLmJvcmRlclJpZ2h0PSIxcHggc29saWQgI2QwZDBkMCI7ZS5zdHlsZS5wYWRkaW5nPSIzcHggNnB4IDNweCA2cHgiO214RXZlbnQuYWRkTGlzdGVuZXIoZSwiY2xpY2siLGEpO251bGwhPWMmJmUuc2V0QXR0cmlidXRlKCJ0aXRsZSIsYyk7ZS5zdHlsZS5kaXNwbGF5PW14Q2xpZW50LklTX1FVSVJLUz8iaW5saW5lIjoiaW5saW5lLWJsb2NrIjthPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImltZyIpO2Euc2V0QXR0cmlidXRlKCJib3JkZXIiLCIwIik7YS5zZXRBdHRyaWJ1dGUoInNyYyIsYik7bnVsbD09ZHx8ZD8obXhFdmVudC5hZGRMaXN0ZW5lcihlLCJtb3VzZWVudGVyIixmdW5jdGlvbigpe2Uuc3R5bGUuYmFja2dyb3VuZENvbG9yPSIjZGRkIn0pLG14RXZlbnQuYWRkTGlzdGVuZXIoZSwibW91c2VsZWF2ZSIsCmZ1bmN0aW9uKCl7ZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9IiNlZWUifSksbXhVdGlscy5zZXRPcGFjaXR5KGEsNjApLGUuc3R5bGUuY3Vyc29yPSJwb2ludGVyIik6bXhVdGlscy5zZXRPcGFjaXR5KGUsMzApO2UuYXBwZW5kQ2hpbGQoYSk7Zi5hcHBlbmRDaGlsZChlKTtwKys7cmV0dXJuIGV9dmFyIGM9dGhpcy5ncmFwaC5jb250YWluZXI7ImJvdHRvbSI9PXRoaXMuZ3JhcGhDb25maWdbInRvb2xiYXItcG9zaXRpb24iXT9jLnN0eWxlLm1hcmdpbkJvdHRvbT10aGlzLnRvb2xiYXJIZWlnaHQrInB4IjoiaW5saW5lIiE9dGhpcy5ncmFwaENvbmZpZ1sidG9vbGJhci1wb3NpdGlvbiJdJiYoYy5zdHlsZS5tYXJnaW5Ub3A9dGhpcy50b29sYmFySGVpZ2h0KyJweCIpO3ZhciBmPWMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtmLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7Zi5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjtmLnN0eWxlLmJveFNpemluZz0iYm9yZGVyLWJveCI7CmYuc3R5bGUud2hpdGVTcGFjZT0ibm93cmFwIjtmLnN0eWxlLnRleHRBbGlnbj0ibGVmdCI7Zi5zdHlsZS56SW5kZXg9dGhpcy50b29sYmFyWkluZGV4O2Yuc3R5bGUuYmFja2dyb3VuZENvbG9yPSIjZWVlIjtmLnN0eWxlLmhlaWdodD10aGlzLnRvb2xiYXJIZWlnaHQrInB4Ijt0aGlzLnRvb2xiYXI9ZjtpZigiaW5saW5lIj09dGhpcy5ncmFwaENvbmZpZ1sidG9vbGJhci1wb3NpdGlvbiJdKXtteFV0aWxzLnNldFByZWZpeGVkU3R5bGUoZi5zdHlsZSwidHJhbnNpdGlvbiIsIm9wYWNpdHkgMTAwbXMgZWFzZS1pbi1vdXQiKTtteFV0aWxzLnNldE9wYWNpdHkoZiwzMCk7dmFyIGQ9bnVsbCxtPW51bGwsaz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsIT1kJiYod2luZG93LmNsZWFyVGltZW91dChkKSxmYWRlVGhlYWQ9bnVsbCk7bnVsbCE9bSYmKHdpbmRvdy5jbGVhclRpbWVvdXQobSksZmFkZVRoZWFkMj1udWxsKTtkPXdpbmRvdy5zZXRUaW1lb3V0KG14VXRpbHMuYmluZCh0aGlzLApmdW5jdGlvbigpe214VXRpbHMuc2V0T3BhY2l0eShmLDApO2Q9bnVsbDttPXdpbmRvdy5zZXRUaW1lb3V0KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7Zi5zdHlsZS5kaXNwbGF5PSJub25lIjttPW51bGx9KSwxMDApfSksYXx8MjAwKX0pLHE9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bnVsbCE9ZCYmKHdpbmRvdy5jbGVhclRpbWVvdXQoZCksZmFkZVRoZWFkPW51bGwpO251bGwhPW0mJih3aW5kb3cuY2xlYXJUaW1lb3V0KG0pLGZhZGVUaGVhZDI9bnVsbCk7Zi5zdHlsZS5kaXNwbGF5PSIiO214VXRpbHMuc2V0T3BhY2l0eShmLGF8fDMwKX0pO214RXZlbnQuYWRkTGlzdGVuZXIodGhpcy5ncmFwaC5jb250YWluZXIsbXhDbGllbnQuSVNfUE9JTlRFUj8icG9pbnRlcm1vdmUiOiJtb3VzZW1vdmUiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe214RXZlbnQuaXNUb3VjaEV2ZW50KGEpfHwocSgzMCksaygpKX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKGYsbXhDbGllbnQuSVNfUE9JTlRFUj8KInBvaW50ZXJtb3ZlIjoibW91c2Vtb3ZlIixmdW5jdGlvbihhKXtteEV2ZW50LmNvbnN1bWUoYSl9KTtteEV2ZW50LmFkZExpc3RlbmVyKGYsIm1vdXNlZW50ZXIiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3EoMTAwKX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKGYsIm1vdXNlbW92ZSIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7cSgxMDApO214RXZlbnQuY29uc3VtZShhKX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKGYsIm1vdXNlbGVhdmUiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe214RXZlbnQuaXNUb3VjaEV2ZW50KGEpfHxxKDMwKX0pKTt2YXIgYj10aGlzLmdyYXBoLGU9Yi5nZXRUb2xlcmFuY2UoKTtiLmFkZE1vdXNlTGlzdGVuZXIoe3N0YXJ0WDowLHN0YXJ0WTowLHNjcm9sbExlZnQ6MCxzY3JvbGxUb3A6MCxtb3VzZURvd246ZnVuY3Rpb24oYSxjKXt0aGlzLnN0YXJ0WD1jLmdldEdyYXBoWCgpO3RoaXMuc3RhcnRZPWMuZ2V0R3JhcGhZKCk7CnRoaXMuc2Nyb2xsTGVmdD1iLmNvbnRhaW5lci5zY3JvbGxMZWZ0O3RoaXMuc2Nyb2xsVG9wPWIuY29udGFpbmVyLnNjcm9sbFRvcH0sbW91c2VNb3ZlOmZ1bmN0aW9uKGEsYil7fSxtb3VzZVVwOmZ1bmN0aW9uKGEsYyl7bXhFdmVudC5pc1RvdWNoRXZlbnQoYy5nZXRFdmVudCgpKSYmTWF0aC5hYnModGhpcy5zY3JvbGxMZWZ0LWIuY29udGFpbmVyLnNjcm9sbExlZnQpPGUmJk1hdGguYWJzKHRoaXMuc2Nyb2xsVG9wLWIuY29udGFpbmVyLnNjcm9sbFRvcCk8ZSYmTWF0aC5hYnModGhpcy5zdGFydFgtYy5nZXRHcmFwaFgoKSk8ZSYmTWF0aC5hYnModGhpcy5zdGFydFktYy5nZXRHcmFwaFkoKSk8ZSYmKDA8cGFyc2VGbG9hdChmLnN0eWxlLm9wYWNpdHl8fDApP2soKTpxKDMwKSl9fSl9Zm9yKHZhciBnPXRoaXMudG9vbGJhckl0ZW1zLHA9MCxsPW51bGwsbj1udWxsLHY9MDt2PGcubGVuZ3RoO3YrKyl7dmFyIHQ9Z1t2XTtpZigicGFnZXMiPT10KXtuPWMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTsKbi5zdHlsZS5jc3NUZXh0PSJkaXNwbGF5OmlubGluZS1ibG9jaztwb3NpdGlvbjpyZWxhdGl2ZTtwYWRkaW5nOjNweCA0cHggMCA0cHg7dmVydGljYWwtYWxpZ246dG9wO2ZvbnQtZmFtaWx5OkhlbHZldGljYSxBcmlhbDtmb250LXNpemU6MTJweDt0b3A6NHB4O2N1cnNvcjpkZWZhdWx0OyI7bXhVdGlscy5zZXRPcGFjaXR5KG4sNzApO3ZhciB5PWEobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnNlbGVjdFBhZ2UodGhpcy5jdXJyZW50UGFnZS0xKX0pLEVkaXRvci5wcmV2aW91c0ltYWdlLG14UmVzb3VyY2VzLmdldCgicHJldmlvdXNQYWdlIil8fCJQcmV2aW91cyBQYWdlIik7eS5zdHlsZS5ib3JkZXJSaWdodFN0eWxlPSJub25lIjt5LnN0eWxlLnBhZGRpbmdMZWZ0PSIwcHgiO3kuc3R5bGUucGFkZGluZ1JpZ2h0PSIwcHgiO2YuYXBwZW5kQ2hpbGQobik7dmFyIHg9YShteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuc2VsZWN0UGFnZSh0aGlzLmN1cnJlbnRQYWdlKwoxKX0pLEVkaXRvci5uZXh0SW1hZ2UsbXhSZXNvdXJjZXMuZ2V0KCJuZXh0UGFnZSIpfHwiTmV4dCBQYWdlIik7eC5zdHlsZS5wYWRkaW5nTGVmdD0iMHB4Ijt4LnN0eWxlLnBhZGRpbmdSaWdodD0iMHB4Ijt0PW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bi5pbm5lckhUTUw9IiI7bXhVdGlscy53cml0ZShuLHRoaXMuY3VycmVudFBhZ2UrMSsiIC8gIit0aGlzLmRpYWdyYW1zLmxlbmd0aCk7bi5zdHlsZS5kaXNwbGF5PTE8dGhpcy5kaWFncmFtcy5sZW5ndGg/ImlubGluZS1ibG9jayI6Im5vbmUiO3kuc3R5bGUuZGlzcGxheT1uLnN0eWxlLmRpc3BsYXk7eC5zdHlsZS5kaXNwbGF5PW4uc3R5bGUuZGlzcGxheX0pO3RoaXMuYWRkTGlzdGVuZXIoImdyYXBoQ2hhbmdlZCIsdCk7dCgpfWVsc2UgaWYoInpvb20iPT10KXRoaXMuem9vbUVuYWJsZWQmJihhKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5ncmFwaC56b29tT3V0KCl9KSxFZGl0b3Iuem9vbU91dEltYWdlLApteFJlc291cmNlcy5nZXQoInpvb21PdXQiKXx8Ilpvb20gT3V0IiksYShteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuZ3JhcGguem9vbUluKCl9KSxFZGl0b3Iuem9vbUluSW1hZ2UsbXhSZXNvdXJjZXMuZ2V0KCJ6b29tSW4iKXx8Ilpvb20gSW4iKSxhKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5ncmFwaC52aWV3LnNjYWxlQW5kVHJhbnNsYXRlKHRoaXMuZ3JhcGguaW5pdGlhbFZpZXdTdGF0ZS5zY2FsZSx0aGlzLmdyYXBoLmluaXRpYWxWaWV3U3RhdGUudHJhbnNsYXRlLngsdGhpcy5ncmFwaC5pbml0aWFsVmlld1N0YXRlLnRyYW5zbGF0ZS55KX0pLEVkaXRvci56b29tRml0SW1hZ2UsbXhSZXNvdXJjZXMuZ2V0KCJmaXQiKXx8IkZpdCIpKTtlbHNlIGlmKCJsYXllcnMiPT10KXtpZih0aGlzLmxheWVyc0VuYWJsZWQpe3ZhciBFPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxBPWEobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7aWYobnVsbCE9bClsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobCksCmw9bnVsbDtlbHNle2w9dGhpcy5ncmFwaC5jcmVhdGVMYXllcnNEaWFsb2coKTtteEV2ZW50LmFkZExpc3RlbmVyKGwsIm1vdXNlbGVhdmUiLGZ1bmN0aW9uKCl7bC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGwpO2w9bnVsbH0pO2E9QS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtsLnN0eWxlLndpZHRoPSIxNDBweCI7bC5zdHlsZS5wYWRkaW5nPSIycHggMHB4IDJweCAwcHgiO2wuc3R5bGUuYm9yZGVyPSIxcHggc29saWQgI2QwZDBkMCI7bC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9IiNlZWUiO2wuc3R5bGUuZm9udEZhbWlseT0iSGVsdmV0aWNhIE5ldWUsSGVsdmV0aWNhLEFyaWFsIFVuaWNvZGUgTVMsQXJpYWwiO2wuc3R5bGUuZm9udFNpemU9IjExcHgiO2wuc3R5bGUuekluZGV4PXRoaXMudG9vbGJhclpJbmRleCsxO214VXRpbHMuc2V0T3BhY2l0eShsLDgwKTt2YXIgYj1teFV0aWxzLmdldERvY3VtZW50U2Nyb2xsT3JpZ2luKGRvY3VtZW50KTtsLnN0eWxlLmxlZnQ9Yi54K2EubGVmdCsKInB4IjtsLnN0eWxlLnRvcD1iLnkrYS5ib3R0b20rInB4Ijtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGwpfX0pLEVkaXRvci5sYXllcnNJbWFnZSxteFJlc291cmNlcy5nZXQoImxheWVycyIpfHwiTGF5ZXJzIik7RS5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSxmdW5jdGlvbigpe0Euc3R5bGUuZGlzcGxheT0xPEUuZ2V0Q2hpbGRDb3VudChFLnJvb3QpPyJpbmxpbmUtYmxvY2siOiJub25lIn0pO0Euc3R5bGUuZGlzcGxheT0xPEUuZ2V0Q2hpbGRDb3VudChFLnJvb3QpPyJpbmxpbmUtYmxvY2siOiJub25lIn19ZWxzZSJsaWdodGJveCI9PXQ/dGhpcy5saWdodGJveEVuYWJsZWQmJmEobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnNob3dMaWdodGJveCgpfSksRWRpdG9yLm1heGltaXplSW1hZ2UsbXhSZXNvdXJjZXMuZ2V0KCJzaG93Iil8fCJTaG93Iik6bnVsbCE9dGhpcy5ncmFwaENvbmZpZ1sidG9vbGJhci1idXR0b25zIl0mJih0PXRoaXMuZ3JhcGhDb25maWdbInRvb2xiYXItYnV0dG9ucyJdW3RdLApudWxsIT10JiZhKG51bGw9PXQuZW5hYmxlZHx8dC5lbmFibGVkP3QuaGFuZGxlcjpmdW5jdGlvbigpe30sdC5pbWFnZSx0LnRpdGxlLHQuZW5hYmxlZCkpfW51bGwhPXRoaXMuZ3JhcGgubWluaW11bUNvbnRhaW5lclNpemUmJih0aGlzLmdyYXBoLm1pbmltdW1Db250YWluZXJTaXplLndpZHRoPTM0KnApO251bGwhPXRoaXMuZ3JhcGhDb25maWcudGl0bGUmJihnPWMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxnLnN0eWxlLmNzc1RleHQ9ImRpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO3BhZGRpbmc6M3B4IDZweCAwIDZweDt2ZXJ0aWNhbC1hbGlnbjp0b3A7Zm9udC1mYW1pbHk6SGVsdmV0aWNhLEFyaWFsO2ZvbnQtc2l6ZToxMnB4O3RvcDo0cHg7Y3Vyc29yOmRlZmF1bHQ7IixnLnNldEF0dHJpYnV0ZSgidGl0bGUiLHRoaXMuZ3JhcGhDb25maWcudGl0bGUpLG14VXRpbHMud3JpdGUoZyx0aGlzLmdyYXBoQ29uZmlnLnRpdGxlKSxteFV0aWxzLnNldE9wYWNpdHkoZywKNzApLGYuYXBwZW5kQ2hpbGQoZyksdGhpcy5maWxlbmFtZT1nKTt0aGlzLm1pblRvb2xiYXJXaWR0aD0zNCpwO3ZhciBDPWMuc3R5bGUuYm9yZGVyLGc9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtmLnN0eWxlLndpZHRoPSJpbmxpbmUiPT10aGlzLmdyYXBoQ29uZmlnWyJ0b29sYmFyLXBvc2l0aW9uIl0/ImF1dG8iOk1hdGgubWF4KHRoaXMubWluVG9vbGJhcldpZHRoLGMub2Zmc2V0V2lkdGgpKyJweCI7Zi5zdHlsZS5ib3JkZXI9IjFweCBzb2xpZCAjZDBkMGQwIjtpZigxIT10aGlzLmdyYXBoQ29uZmlnWyJ0b29sYmFyLW5vaGlkZSJdKXt2YXIgYT1jLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGI9bXhVdGlscy5nZXRTY3JvbGxPcmlnaW4oZG9jdW1lbnQuYm9keSksYj0icmVsYXRpdmUiPT09ZG9jdW1lbnQuYm9keS5zdHlsZS5wb3NpdGlvbj9kb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOntsZWZ0Oi1iLngsdG9wOi1iLnl9LGE9e2xlZnQ6YS5sZWZ0LQpiLmxlZnQsdG9wOmEudG9wLWIudG9wLGJvdHRvbTphLmJvdHRvbS1iLnRvcCxyaWdodDphLnJpZ2h0LWIubGVmdH07Zi5zdHlsZS5sZWZ0PWEubGVmdCsicHgiOyJib3R0b20iPT10aGlzLmdyYXBoQ29uZmlnWyJ0b29sYmFyLXBvc2l0aW9uIl0/Zi5zdHlsZS50b3A9YS5ib3R0b20tMSsicHgiOiJpbmxpbmUiIT10aGlzLmdyYXBoQ29uZmlnWyJ0b29sYmFyLXBvc2l0aW9uIl0/KGYuc3R5bGUubWFyZ2luVG9wPS10aGlzLnRvb2xiYXJIZWlnaHQrInB4IixmLnN0eWxlLnRvcD1hLnRvcCsxKyJweCIpOmYuc3R5bGUudG9wPWEudG9wKyJweCI7IjFweCBzb2xpZCB0cmFuc3BhcmVudCI9PUMmJihjLnN0eWxlLmJvcmRlcj0iMXB4IHNvbGlkICNkMGQwZDAiKTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGYpO3ZhciBkPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bnVsbCE9Zi5wYXJlbnROb2RlJiZmLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZik7bnVsbCE9bCYmKGwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsKSwKbD1udWxsKTtjLnN0eWxlLmJvcmRlcj1DfSk7bXhFdmVudC5hZGRMaXN0ZW5lcihkb2N1bWVudCwibW91c2Vtb3ZlIixmdW5jdGlvbihhKXtmb3IoYT1teEV2ZW50LmdldFNvdXJjZShhKTtudWxsIT1hOyl7aWYoYT09Y3x8YT09Znx8YT09bClyZXR1cm47YT1hLnBhcmVudE5vZGV9ZCgpfSk7bXhFdmVudC5hZGRMaXN0ZW5lcihkb2N1bWVudCwibW91c2VsZWF2ZSIsZnVuY3Rpb24oYSl7ZCgpfSl9ZWxzZSBmLnN0eWxlLnRvcD0tdGhpcy50b29sYmFySGVpZ2h0KyJweCIsYy5hcHBlbmRDaGlsZChmKX0pOzEhPXRoaXMuZ3JhcGhDb25maWdbInRvb2xiYXItbm9oaWRlIl0/bXhFdmVudC5hZGRMaXN0ZW5lcihjLCJtb3VzZWVudGVyIixnKTpnKCl9OwpHcmFwaFZpZXdlci5wcm90b3R5cGUuYWRkQ2xpY2tIYW5kbGVyPWZ1bmN0aW9uKGEsYyl7YS5saW5rUG9saWN5PXRoaXMuZ3JhcGhDb25maWcudGFyZ2V0fHxhLmxpbmtQb2xpY3k7YS5hZGRDbGlja0hhbmRsZXIodGhpcy5ncmFwaENvbmZpZy5oaWdobGlnaHQsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oZixkKXtpZihudWxsPT1kKXt2YXIgbT1teEV2ZW50LmdldFNvdXJjZShmKTsiYSI9PW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSYmKGQ9bS5nZXRBdHRyaWJ1dGUoImhyZWYiKSl9bnVsbCE9Yz9udWxsPT1kfHxhLmlzQ3VzdG9tTGluayhkKT9teEV2ZW50LmNvbnN1bWUoZik6YS5pc0V4dGVybmFsUHJvdG9jb2woZCl8fGEuaXNCbGFua0xpbmsoZCl8fHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yy5kZXN0cm95KCl9LDApOm51bGwhPWQmJm51bGw9PWMmJmEuaXNDdXN0b21MaW5rKGQpJiYobXhFdmVudC5pc1RvdWNoRXZlbnQoZil8fCFteEV2ZW50LmlzUG9wdXBUcmlnZ2VyKGYpKSYmCmEuY3VzdG9tTGlua0NsaWNrZWQoZCkmJm14RXZlbnQuY29uc3VtZShmKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe251bGwhPWN8fCF0aGlzLmxpZ2h0Ym94Q2xpY2tFbmFibGVkfHxteEV2ZW50LmlzVG91Y2hFdmVudChhKSYmMCE9dGhpcy50b29sYmFySXRlbXMubGVuZ3RofHx0aGlzLnNob3dMaWdodGJveCgpfSkpfTsKR3JhcGhWaWV3ZXIucHJvdG90eXBlLnNob3dMaWdodGJveD1mdW5jdGlvbihhLGMsZil7aWYoIm9wZW4iPT10aGlzLmdyYXBoQ29uZmlnLmxpZ2h0Ym94fHx3aW5kb3cuc2VsZiE9PXdpbmRvdy50b3ApaWYobnVsbD09dGhpcy5saWdodGJveFdpbmRvd3x8dGhpcy5saWdodGJveFdpbmRvdy5jbG9zZWQpe2E9bnVsbCE9YT9hOm51bGwhPXRoaXMuZ3JhcGhDb25maWcuZWRpdGFibGU/dGhpcy5ncmFwaENvbmZpZy5lZGl0YWJsZTohMDtmPXtjbGllbnQ6MSxsaWdodGJveDoxLHRhcmdldDpudWxsIT1mP2Y6ImJsYW5rIn07YSYmKGYuZWRpdD10aGlzLmdyYXBoQ29uZmlnLmVkaXR8fCJfYmxhbmsiKTtpZihudWxsIT1jP2M6MSlmLmNsb3NlPTE7dGhpcy5sYXllcnNFbmFibGVkJiYoZi5sYXllcnM9MSk7bnVsbCE9dGhpcy5ncmFwaENvbmZpZyYmMCE9dGhpcy5ncmFwaENvbmZpZy5uYXYmJihmLm5hdj0xKTtudWxsIT10aGlzLmdyYXBoQ29uZmlnJiZudWxsIT10aGlzLmdyYXBoQ29uZmlnLmhpZ2hsaWdodCYmCihmLmhpZ2hsaWdodD10aGlzLmdyYXBoQ29uZmlnLmhpZ2hsaWdodC5zdWJzdHJpbmcoMSkpO251bGwhPXRoaXMuY3VycmVudFBhZ2UmJjA8dGhpcy5jdXJyZW50UGFnZSYmKGYucGFnZT10aGlzLmN1cnJlbnRQYWdlKTsidW5kZWZpbmVkIiE9PXR5cGVvZiB3aW5kb3cucG9zdE1lc3NhZ2UmJihudWxsPT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fDEwPD1kb2N1bWVudC5kb2N1bWVudE1vZGUpP251bGw9PXRoaXMubGlnaHRib3hXaW5kb3cmJm14RXZlbnQuYWRkTGlzdGVuZXIod2luZG93LCJtZXNzYWdlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXsicmVhZHkiPT1hLmRhdGEmJmEuc291cmNlPT10aGlzLmxpZ2h0Ym94V2luZG93JiZ0aGlzLmxpZ2h0Ym94V2luZG93LnBvc3RNZXNzYWdlKHRoaXMueG1sLCIqIil9KSk6Zi5kYXRhPWVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnhtbCk7YT0iYXBwLmRpYWdyYW1zLm5ldCI7IjEiPT11cmxQYXJhbXMuZGV2JiYoZi5kZXY9IjEiLApmLmRyYXdkZXY9IjEiLGE9InRlc3QuZHJhdy5pbyIpO3RoaXMubGlnaHRib3hXaW5kb3c9d2luZG93Lm9wZW4oImh0dHBzOi8vIithKyIvI1AiK2VuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShmKSkpfWVsc2UgdGhpcy5saWdodGJveFdpbmRvdy5mb2N1cygpO2Vsc2UgdGhpcy5zaG93TG9jYWxMaWdodGJveCgpfTsKR3JhcGhWaWV3ZXIucHJvdG90eXBlLnNob3dMb2NhbExpZ2h0Ym94PWZ1bmN0aW9uKCl7dmFyIGE9bXhVdGlscy5nZXREb2N1bWVudFNjcm9sbE9yaWdpbihkb2N1bWVudCksYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtteENsaWVudC5JU19RVUlSS1M/KGMuc3R5bGUucG9zaXRpb249ImFic29sdXRlIixjLnN0eWxlLmxlZnQ9YS54KyJweCIsYy5zdHlsZS50b3A9YS55KyJweCIsYy5zdHlsZS53aWR0aD1kb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoKyJweCIsYy5zdHlsZS5oZWlnaHQ9ZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQrInB4Iik6Yy5zdHlsZS5jc3NUZXh0PSJwb3NpdGlvbjpmaXhlZDt0b3A6MDtsZWZ0OjA7Ym90dG9tOjA7cmlnaHQ6MDsiO2Muc3R5bGUuekluZGV4PXRoaXMubGlnaHRib3haSW5kZXg7Yy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9IiMwMDAwMDAiO214VXRpbHMuc2V0T3BhY2l0eShjLDcwKTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGMpOwp2YXIgZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTtmLnNldEF0dHJpYnV0ZSgiYm9yZGVyIiwiMCIpO2Yuc2V0QXR0cmlidXRlKCJzcmMiLEVkaXRvci5jbG9zZUltYWdlKTtteENsaWVudC5JU19RVUlSS1M/KGYuc3R5bGUucG9zaXRpb249ImFic29sdXRlIixmLnN0eWxlLnJpZ2h0PSIzMnB4IixmLnN0eWxlLnRvcD1hLnkrMzIrInB4Iik6Zi5zdHlsZS5jc3NUZXh0PSJwb3NpdGlvbjpmaXhlZDt0b3A6MzJweDtyaWdodDozMnB4OyI7Zi5zdHlsZS5jdXJzb3I9InBvaW50ZXIiO214RXZlbnQuYWRkTGlzdGVuZXIoZiwiY2xpY2siLGZ1bmN0aW9uKCl7bS5kZXN0cm95KCl9KTt1cmxQYXJhbXMucGFnZXM9IjEiO3VybFBhcmFtcy5wYWdlPXRoaXMuY3VycmVudFBhZ2U7dXJsUGFyYW1zWyJwYWdlLWlkIl09dGhpcy5ncmFwaENvbmZpZy5wYWdlSWQ7dXJsUGFyYW1zWyJsYXllci1pZHMiXT1udWxsIT10aGlzLmdyYXBoQ29uZmlnLmxheWVySWRzJiYwPHRoaXMuZ3JhcGhDb25maWcubGF5ZXJJZHMubGVuZ3RoPwp0aGlzLmdyYXBoQ29uZmlnLmxheWVySWRzLmpvaW4oIiAiKTpudWxsO3VybFBhcmFtcy5uYXY9MCE9dGhpcy5ncmFwaENvbmZpZy5uYXY/IjEiOiIwIjt1cmxQYXJhbXMubGF5ZXJzPXRoaXMubGF5ZXJzRW5hYmxlZD8iMSI6IjAiO2lmKG51bGw9PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8MTA8PWRvY3VtZW50LmRvY3VtZW50TW9kZSlFZGl0b3IucHJvdG90eXBlLmVkaXRCdXR0b25MaW5rPXRoaXMuZ3JhcGhDb25maWcuZWRpdCxFZGl0b3IucHJvdG90eXBlLmVkaXRCdXR0b25GdW5jPXRoaXMuZ3JhcGhDb25maWcuZWRpdEZ1bmM7RWRpdG9yVWkucHJvdG90eXBlLnVwZGF0ZUFjdGlvblN0YXRlcz1mdW5jdGlvbigpe307RWRpdG9yVWkucHJvdG90eXBlLmFkZEJlZm9yZVVubG9hZExpc3RlbmVyPWZ1bmN0aW9uKCl7fTtFZGl0b3JVaS5wcm90b3R5cGUuYWRkQ2hyb21lbGVzc0NsaWNrSGFuZGxlcj1mdW5jdGlvbigpe307dmFyIGQ9R3JhcGgucHJvdG90eXBlLnNoYWRvd0lkO0dyYXBoLnByb3RvdHlwZS5zaGFkb3dJZD0KImxpZ2h0Ym94RHJvcFNoYWRvdyI7dmFyIG09bmV3IEVkaXRvclVpKG5ldyBFZGl0b3IoITApLGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLCEwKTttLmVkaXRvci5lZGl0QmxhbmtVcmw9dGhpcy5lZGl0QmxhbmtVcmw7bS5lZGl0b3IuZ3JhcGguc2hhZG93SWQ9ImxpZ2h0Ym94RHJvcFNoYWRvdyI7R3JhcGgucHJvdG90eXBlLnNoYWRvd0lkPWQ7bS5yZWZyZXNoPWZ1bmN0aW9uKCl7fTt2YXIgaz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXsyNz09YS5rZXlDb2RlJiZtLmRlc3Ryb3koKX0pLHE9bS5kZXN0cm95O20uZGVzdHJveT1mdW5jdGlvbigpe214RXZlbnQucmVtb3ZlTGlzdGVuZXIoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCJrZXlkb3duIixrKTtkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGMpO2RvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZik7ZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdz0iYXV0byI7R3JhcGhWaWV3ZXIucmVzaXplU2Vuc29yRW5hYmxlZD0KITA7cS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBiPW0uZWRpdG9yLmdyYXBoLGU9Yi5jb250YWluZXI7ZS5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjt0aGlzLmxpZ2h0Ym94Q2hyb21lPyhlLnN0eWxlLmJvcmRlcj0iMXB4IHNvbGlkICNjMGMwYzAiLGUuc3R5bGUubWFyZ2luPSI0MHB4IixteEV2ZW50LmFkZExpc3RlbmVyKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwia2V5ZG93biIsaykpOihjLnN0eWxlLmRpc3BsYXk9Im5vbmUiLGYuc3R5bGUuZGlzcGxheT0ibm9uZSIpO3ZhciBnPXRoaXM7Yi5nZXRJbWFnZUZyb21CdW5kbGVzPWZ1bmN0aW9uKGEpe3JldHVybiBnLmdldEltYWdlVXJsKGEpfTt2YXIgcD1tLmNyZWF0ZVRlbXBvcmFyeUdyYXBoO20uY3JlYXRlVGVtcG9yYXJ5R3JhcGg9ZnVuY3Rpb24oKXt2YXIgYT1wLmFwcGx5KHRoaXMsYXJndW1lbnRzKTthLmdldEltYWdlRnJvbUJ1bmRsZXM9ZnVuY3Rpb24oYSl7cmV0dXJuIGcuZ2V0SW1hZ2VVcmwoYSl9O3JldHVybiBhfTsKdGhpcy5ncmFwaENvbmZpZy5tb3ZlJiYoYi5pc01vdmVDZWxsc0V2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiEwfSk7bXhDbGllbnQuSVNfUVVJUktTfHwobXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGUuc3R5bGUsImJvcmRlci1yYWRpdXMiLCI0cHgiKSxlLnN0eWxlLnBvc2l0aW9uPSJmaXhlZCIpO0dyYXBoVmlld2VyLnJlc2l6ZVNlbnNvckVuYWJsZWQ9ITE7ZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjtteENsaWVudC5JU19TRnx8bXhDbGllbnQuSVNfRURHRXx8KG14VXRpbHMuc2V0UHJlZml4ZWRTdHlsZShlLnN0eWxlLCJ0cmFuc2Zvcm0iLCJyb3RhdGVZKDkwZGVnKSIpLG14VXRpbHMuc2V0UHJlZml4ZWRTdHlsZShlLnN0eWxlLCJ0cmFuc2l0aW9uIiwiYWxsIC4yNXMgZWFzZS1pbi1vdXQiKSk7dGhpcy5hZGRDbGlja0hhbmRsZXIoYixtKTt3aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2Uuc3R5bGUub3V0bGluZT0ibm9uZSI7CmUuc3R5bGUuekluZGV4PXRoaXMubGlnaHRib3haSW5kZXg7Zi5zdHlsZS56SW5kZXg9dGhpcy5saWdodGJveFpJbmRleDtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGUpO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZik7bS5zZXRGaWxlRGF0YSh0aGlzLnhtbCk7bXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGUuc3R5bGUsInRyYW5zZm9ybSIsInJvdGF0ZVkoMGRlZykiKTttLmNocm9tZWxlc3NUb29sYmFyLnN0eWxlLmJvdHRvbT0iNjBweCI7bS5jaHJvbWVsZXNzVG9vbGJhci5zdHlsZS56SW5kZXg9dGhpcy5saWdodGJveFpJbmRleDtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG0uY2hyb21lbGVzc1Rvb2xiYXIpO20uZ2V0RWRpdEJsYW5rWG1sPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMueG1sfSk7bXhDbGllbnQuSVNfUVVJUktTJiYoZS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiLGUuc3R5bGUuZGlzcGxheT0iYmxvY2siLGUuc3R5bGUubGVmdD0KYS54KyJweCIsZS5zdHlsZS50b3A9YS55KyJweCIsZS5zdHlsZS53aWR0aD1kb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoLTgwKyJweCIsZS5zdHlsZS5oZWlnaHQ9ZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQtODArInB4IixlLnN0eWxlLmJhY2tncm91bmRDb2xvcj0id2hpdGUiLG0uY2hyb21lbGVzc1Rvb2xiYXIuc3R5bGUuZGlzcGxheT0iYmxvY2siLG0uY2hyb21lbGVzc1Rvb2xiYXIuc3R5bGUucG9zaXRpb249ImFic29sdXRlIixtLmNocm9tZWxlc3NUb29sYmFyLnN0eWxlLmJvdHRvbT0iIixtLmNocm9tZWxlc3NUb29sYmFyLnN0eWxlLnRvcD1hLnkrZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQtMTAwKyJweCIpO20ubGlnaHRib3hGaXQoKTttLmNocm9tZWxlc3NSZXNpemUoKTt0aGlzLnNob3dMYXllcnMoYix0aGlzLmdyYXBoKTtteEV2ZW50LmFkZExpc3RlbmVyKGMsImNsaWNrIixmdW5jdGlvbigpe20uZGVzdHJveSgpfSl9KSwwKTtyZXR1cm4gbX07CkdyYXBoVmlld2VyLnByb3RvdHlwZS51cGRhdGVUaXRsZT1mdW5jdGlvbihhKXthPWF8fCIiO3RoaXMuc2hvd1RpdGxlQXNUb29sdGlwJiZudWxsIT10aGlzLmdyYXBoJiZudWxsIT10aGlzLmdyYXBoLmNvbnRhaW5lciYmdGhpcy5ncmFwaC5jb250YWluZXIuc2V0QXR0cmlidXRlKCJ0aXRsZSIsYSk7bnVsbCE9dGhpcy5maWxlbmFtZSYmKHRoaXMuZmlsZW5hbWUuaW5uZXJIVE1MPSIiLG14VXRpbHMud3JpdGUodGhpcy5maWxlbmFtZSxhKSx0aGlzLmZpbGVuYW1lLnNldEF0dHJpYnV0ZSgidGl0bGUiLGEpKX07CkdyYXBoVmlld2VyLnByb2Nlc3NFbGVtZW50cz1mdW5jdGlvbihhKXtteFV0aWxzLmZvckVhY2goR3JhcGhWaWV3ZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShhfHwibXhncmFwaCIpLGZ1bmN0aW9uKGEpe3RyeXthLmlubmVySFRNTD0iIixHcmFwaFZpZXdlci5jcmVhdGVWaWV3ZXJGb3JFbGVtZW50KGEpfWNhdGNoKGYpe3Rocm93IGEuaW5uZXJIVE1MPWYubWVzc2FnZSxmO319KX07CkdyYXBoVmlld2VyLmdldEVsZW1lbnRzQnlDbGFzc05hbWU9ZnVuY3Rpb24oYSl7aWYoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSl7dmFyIGM9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShhKTthPVtdO2Zvcih2YXIgZj0wO2Y8Yy5sZW5ndGg7ZisrKWEucHVzaChjW2ZdKTtyZXR1cm4gYX1mb3IodmFyIGQ9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIioiKSxjPVtdLGY9MDtmPGQubGVuZ3RoO2YrKyl7dmFyIG09ZFtmXS5jbGFzc05hbWU7bnVsbCE9bSYmMDxtLmxlbmd0aCYmKG09bS5zcGxpdCgiICIpLDA8PW14VXRpbHMuaW5kZXhPZihtLGEpJiZjLnB1c2goZFtmXSkpfXJldHVybiBjfTsKR3JhcGhWaWV3ZXIuY3JlYXRlVmlld2VyRm9yRWxlbWVudD1mdW5jdGlvbihhLGMpe3ZhciBmPWEuZ2V0QXR0cmlidXRlKCJkYXRhLW14Z3JhcGgiKTtpZihudWxsIT1mKXt2YXIgZD1KU09OLnBhcnNlKGYpLG09ZnVuY3Rpb24oZil7Zj1teFV0aWxzLnBhcnNlWG1sKGYpO2Y9bmV3IEdyYXBoVmlld2VyKGEsZi5kb2N1bWVudEVsZW1lbnQsZCk7bnVsbCE9YyYmYyhmKX07bnVsbCE9ZC51cmw/R3JhcGhWaWV3ZXIuZ2V0VXJsKGQudXJsLGZ1bmN0aW9uKGEpe20oYSl9KTptKGQueG1sKX19OwpHcmFwaFZpZXdlci5pbml0Q3NzPWZ1bmN0aW9uKCl7dHJ5e3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInN0eWxlIik7YS50eXBlPSJ0ZXh0L2NzcyI7YS5pbm5lckhUTUw9ImRpdi5teFRvb2x0aXAge1xuLXdlYmtpdC1ib3gtc2hhZG93OiAzcHggM3B4IDEycHggI0MwQzBDMDtcbi1tb3otYm94LXNoYWRvdzogM3B4IDNweCAxMnB4ICNDMEMwQzA7XG5ib3gtc2hhZG93OiAzcHggM3B4IDEycHggI0MwQzBDMDtcbmJhY2tncm91bmQ6ICNGRkZGQ0M7XG5ib3JkZXItc3R5bGU6IHNvbGlkO1xuYm9yZGVyLXdpZHRoOiAxcHg7XG5ib3JkZXItY29sb3I6IGJsYWNrO1xuZm9udC1mYW1pbHk6IEFyaWFsO1xuZm9udC1zaXplOiA4cHQ7XG5wb3NpdGlvbjogYWJzb2x1dGU7XG5jdXJzb3I6IGRlZmF1bHQ7XG5wYWRkaW5nOiA0cHg7XG5jb2xvcjogYmxhY2s7fVxudGQubXhQb3B1cE1lbnVJY29uIGRpdiB7XG53aWR0aDoxNnB4O1xuaGVpZ2h0OjE2cHg7fVxuaHRtbCBkaXYubXhQb3B1cE1lbnUge1xuLXdlYmtpdC1ib3gtc2hhZG93OjJweCAycHggM3B4ICNkNWQ1ZDU7XG4tbW96LWJveC1zaGFkb3c6MnB4IDJweCAzcHggI2Q1ZDVkNTtcbmJveC1zaGFkb3c6MnB4IDJweCAzcHggI2Q1ZDVkNTtcbl9maWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkRyb3BTaGFkb3coT2ZmWD0yLCBPZmZZPTIsIENvbG9yPScjZDBkMGQwJyxQb3NpdGl2ZT0ndHJ1ZScpO1xuYmFja2dyb3VuZDp3aGl0ZTtcbnBvc2l0aW9uOmFic29sdXRlO1xuYm9yZGVyOjNweCBzb2xpZCAjZTdlN2U3O1xucGFkZGluZzozcHg7fVxuaHRtbCB0YWJsZS5teFBvcHVwTWVudSB7XG5ib3JkZXItY29sbGFwc2U6Y29sbGFwc2U7XG5tYXJnaW46MHB4O31cbmh0bWwgdGQubXhQb3B1cE1lbnVJdGVtIHtcbnBhZGRpbmc6N3B4IDMwcHggN3B4IDMwcHg7XG5mb250LWZhbWlseTpIZWx2ZXRpY2EgTmV1ZSxIZWx2ZXRpY2EsQXJpYWwgVW5pY29kZSBNUyxBcmlhbDtcbmZvbnQtc2l6ZToxMHB0O31cbmh0bWwgdGQubXhQb3B1cE1lbnVJY29uIHtcbmJhY2tncm91bmQtY29sb3I6d2hpdGU7XG5wYWRkaW5nOjBweDt9XG50ZC5teFBvcHVwTWVudUljb24gLmdlSWNvbiB7XG5wYWRkaW5nOjJweDtcbnBhZGRpbmctYm90dG9tOjRweDtcbm1hcmdpbjoycHg7XG5ib3JkZXI6MXB4IHNvbGlkIHRyYW5zcGFyZW50O1xub3BhY2l0eTowLjU7XG5fd2lkdGg6MjZweDtcbl9oZWlnaHQ6MjZweDt9XG50ZC5teFBvcHVwTWVudUljb24gLmdlSWNvbjpob3ZlciB7XG5ib3JkZXI6MXB4IHNvbGlkIGdyYXk7XG5ib3JkZXItcmFkaXVzOjJweDtcbm9wYWNpdHk6MTt9XG5odG1sIHRyLm14UG9wdXBNZW51SXRlbUhvdmVyIHtcbmJhY2tncm91bmQtY29sb3I6ICNlZWVlZWU7XG5jb2xvcjogYmxhY2s7fVxudGFibGUubXhQb3B1cE1lbnUgaHIge1xuY29sb3I6I2NjY2NjYztcbmJhY2tncm91bmQtY29sb3I6I2NjY2NjYztcbmJvcmRlcjpub25lO1xuaGVpZ2h0OjFweDt9XG50YWJsZS5teFBvcHVwTWVudSB0ciB7XHRmb250LXNpemU6NHB0O31cbi5nZURpYWxvZyB7IGZvbnQtZmFtaWx5OkhlbHZldGljYSBOZXVlLEhlbHZldGljYSxBcmlhbCBVbmljb2RlIE1TLEFyaWFsO1xuZm9udC1zaXplOjEwcHQ7XG5ib3JkZXI6bm9uZTtcbm1hcmdpbjowcHg7fVxuLmdlRGlhbG9nIHtcdHBvc2l0aW9uOmFic29sdXRlO1x0YmFja2dyb3VuZDp3aGl0ZTtcdG92ZXJmbG93OmhpZGRlbjtcdHBhZGRpbmc6MzBweDtcdGJvcmRlcjoxcHggc29saWQgI2FjYWNhYztcdC13ZWJraXQtYm94LXNoYWRvdzowcHggMHB4IDJweCAycHggI2Q1ZDVkNTtcdC1tb3otYm94LXNoYWRvdzowcHggMHB4IDJweCAycHggI2Q1ZDVkNTtcdGJveC1zaGFkb3c6MHB4IDBweCAycHggMnB4ICNkNWQ1ZDU7XHRfZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5Ecm9wU2hhZG93KE9mZlg9MiwgT2ZmWT0yLCBDb2xvcj0nI2Q1ZDVkNScsIFBvc2l0aXZlPSd0cnVlJyk7XHR6LWluZGV4OiAyO30uZ2VEaWFsb2dDbG9zZSB7XHRwb3NpdGlvbjphYnNvbHV0ZTtcdHdpZHRoOjlweDtcdGhlaWdodDo5cHg7XHRvcGFjaXR5OjAuNTtcdGN1cnNvcjpwb2ludGVyO1x0X2ZpbHRlcjphbHBoYShvcGFjaXR5PTUwKTt9LmdlRGlhbG9nQ2xvc2U6aG92ZXIge1x0b3BhY2l0eToxO30uZ2VEaWFsb2dUaXRsZSB7XHRib3gtc2l6aW5nOmJvcmRlci1ib3g7XHR3aGl0ZS1zcGFjZTpub3dyYXA7XHRiYWNrZ3JvdW5kOnJnYigyMjksIDIyOSwgMjI5KTtcdGJvcmRlci1ib3R0b206MXB4IHNvbGlkIHJnYigxOTIsIDE5MiwgMTkyKTtcdGZvbnQtc2l6ZToxNXB4O1x0Zm9udC13ZWlnaHQ6Ym9sZDtcdHRleHQtYWxpZ246Y2VudGVyO1x0Y29sb3I6cmdiKDM1LCA4NiwgMTQ5KTt9LmdlRGlhbG9nRm9vdGVyIHtcdGJhY2tncm91bmQ6d2hpdGVTbW9rZTtcdHdoaXRlLXNwYWNlOm5vd3JhcDtcdHRleHQtYWxpZ246cmlnaHQ7XHRib3gtc2l6aW5nOmJvcmRlci1ib3g7XHRib3JkZXItdG9wOjFweCBzb2xpZCAjZTVlNWU1O1x0Y29sb3I6ZGFya0dyYXk7fVxuLmdlQnRuIHtcdGJhY2tncm91bmQtY29sb3I6ICNmNWY1ZjU7XHRib3JkZXItcmFkaXVzOiAycHg7XHRib3JkZXI6IDFweCBzb2xpZCAjZDhkOGQ4O1x0Y29sb3I6ICMzMzM7XHRjdXJzb3I6IGRlZmF1bHQ7XHRmb250LXNpemU6IDExcHg7XHRmb250LXdlaWdodDogYm9sZDtcdGhlaWdodDogMjlweDtcdGxpbmUtaGVpZ2h0OiAyN3B4O1x0bWFyZ2luOiAwIDAgMCA4cHg7XHRtaW4td2lkdGg6IDcycHg7XHRvdXRsaW5lOiAwO1x0cGFkZGluZzogMCA4cHg7XHRjdXJzb3I6IHBvaW50ZXI7fS5nZUJ0bjpob3ZlciwgLmdlQnRuOmZvY3VzIHtcdC13ZWJraXQtYm94LXNoYWRvdzogMHB4IDFweCAxcHggcmdiYSgwLDAsMCwwLjEpO1x0LW1vei1ib3gtc2hhZG93OiAwcHggMXB4IDFweCByZ2JhKDAsMCwwLDAuMSk7XHRib3gtc2hhZG93OiAwcHggMXB4IDFweCByZ2JhKDAsMCwwLDAuMSk7XHRib3JkZXI6IDFweCBzb2xpZCAjYzZjNmM2O1x0YmFja2dyb3VuZC1jb2xvcjogI2Y4ZjhmODtcdGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudCgjZjhmOGY4IDBweCwjZjFmMWYxIDEwMCUpO1x0Y29sb3I6ICMxMTE7fS5nZUJ0bjpkaXNhYmxlZCB7XHRvcGFjaXR5OiAuNTt9LmdlUHJpbWFyeUJ0biB7XHRiYWNrZ3JvdW5kLWNvbG9yOiAjNGQ5MGZlO1x0YmFja2dyb3VuZC1pbWFnZTogbGluZWFyLWdyYWRpZW50KCM0ZDkwZmUgMHB4LCM0Nzg3ZWQgMTAwJSk7XHRib3JkZXI6IDFweCBzb2xpZCAjMzA3OWVkO1x0Y29sb3I6ICNmZmY7fS5nZVByaW1hcnlCdG46aG92ZXIsIC5nZVByaW1hcnlCdG46Zm9jdXMge1x0YmFja2dyb3VuZC1jb2xvcjogIzM1N2FlODtcdGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudCgjNGQ5MGZlIDBweCwjMzU3YWU4IDEwMCUpO1x0Ym9yZGVyOiAxcHggc29saWQgIzJmNWJiNztcdGNvbG9yOiAjZmZmO30uZ2VQcmltYXJ5QnRuOmRpc2FibGVkIHtcdG9wYWNpdHk6IC41O30iO2RvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJoZWFkIilbMF0uYXBwZW5kQ2hpbGQoYSl9Y2F0Y2goYyl7fX07CkdyYXBoVmlld2VyLmNhY2hlZFVybHM9e307R3JhcGhWaWV3ZXIuZ2V0VXJsPWZ1bmN0aW9uKGEsYyxmKXtpZihudWxsIT1HcmFwaFZpZXdlci5jYWNoZWRVcmxzW2FdKWMoR3JhcGhWaWV3ZXIuY2FjaGVkVXJsc1thXSk7ZWxzZXt2YXIgZD1udWxsIT1uYXZpZ2F0b3IudXNlckFnZW50JiYwPG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiTVNJRSA5Iik/bmV3IFhEb21haW5SZXF1ZXN0Om5ldyBYTUxIdHRwUmVxdWVzdDtkLm9wZW4oIkdFVCIsYSk7ZC5vbmxvYWQ9ZnVuY3Rpb24oKXtjKG51bGwhPWQuZ2V0VGV4dD9kLmdldFRleHQoKTpkLnJlc3BvbnNlVGV4dCl9O2Qub25lcnJvcj1mO2Quc2VuZCgpfX07R3JhcGhWaWV3ZXIucmVzaXplU2Vuc29yRW5hYmxlZD0hMDtHcmFwaFZpZXdlci51c2VSZXNpemVTZW5zb3I9ITA7CihmdW5jdGlvbigpe3ZhciBhPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fGZ1bmN0aW9uKGEpe3JldHVybiB3aW5kb3cuc2V0VGltZW91dChhLDIwKX0sYz1mdW5jdGlvbihmLGQpe2Z1bmN0aW9uIG0oKXt0aGlzLnE9W107dGhpcy5hZGQ9ZnVuY3Rpb24oYSl7dGhpcy5xLnB1c2goYSl9O3ZhciBhLGI7dGhpcy5jYWxsPWZ1bmN0aW9uKCl7YT0wO2ZvcihiPXRoaXMucS5sZW5ndGg7YTxiO2ErKyl0aGlzLnFbYV0uY2FsbCgpfX1mdW5jdGlvbiBrKGEsYil7cmV0dXJuIGEuY3VycmVudFN0eWxlP2EuY3VycmVudFN0eWxlW2JdOndpbmRvdy5nZXRDb21wdXRlZFN0eWxlP3dpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGEsbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShiKTphLnN0eWxlW2JdfWZ1bmN0aW9uIHEoYixjKXtpZighYi5yZXNpemVkQXR0YWNoZWQpYi5yZXNpemVkQXR0YWNoZWQ9Cm5ldyBtLGIucmVzaXplZEF0dGFjaGVkLmFkZChjKTtlbHNlIGlmKGIucmVzaXplZEF0dGFjaGVkKXtiLnJlc2l6ZWRBdHRhY2hlZC5hZGQoYyk7cmV0dXJufWIucmVzaXplU2Vuc29yPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2IucmVzaXplU2Vuc29yLmNsYXNzTmFtZT0icmVzaXplLXNlbnNvciI7Yi5yZXNpemVTZW5zb3Iuc3R5bGUuY3NzVGV4dD0icG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAwOyB0b3A6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IG92ZXJmbG93OiBoaWRkZW47IHotaW5kZXg6IC0xOyB2aXNpYmlsaXR5OiBoaWRkZW47IjtiLnJlc2l6ZVNlbnNvci5pbm5lckhUTUw9JzxkaXYgY2xhc3M9InJlc2l6ZS1zZW5zb3ItZXhwYW5kIiBzdHlsZT0icG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAwOyB0b3A6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IG92ZXJmbG93OiBoaWRkZW47IHotaW5kZXg6IC0xOyB2aXNpYmlsaXR5OiBoaWRkZW47Ij48ZGl2IHN0eWxlPSJwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDA7IHRvcDogMDsgdHJhbnNpdGlvbjogMHM7Ij48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPSJyZXNpemUtc2Vuc29yLXNocmluayIgc3R5bGU9InBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBvdmVyZmxvdzogaGlkZGVuOyB6LWluZGV4OiAtMTsgdmlzaWJpbGl0eTogaGlkZGVuOyI+PGRpdiBzdHlsZT0icG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAwOyB0b3A6IDA7IHRyYW5zaXRpb246IDBzOyB3aWR0aDogMjAwJTsgaGVpZ2h0OiAyMDAlIj48L2Rpdj48L2Rpdj4nOwpiLmFwcGVuZENoaWxkKGIucmVzaXplU2Vuc29yKTsic3RhdGljIj09ayhiLCJwb3NpdGlvbiIpJiYoYi5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiKTt2YXIgZD1iLnJlc2l6ZVNlbnNvci5jaGlsZE5vZGVzWzBdLGU9ZC5jaGlsZE5vZGVzWzBdLGY9Yi5yZXNpemVTZW5zb3IuY2hpbGROb2Rlc1sxXSxnPWZ1bmN0aW9uKCl7ZS5zdHlsZS53aWR0aD0iMTAwMDAwcHgiO2Uuc3R5bGUuaGVpZ2h0PSIxMDAwMDBweCI7ZC5zY3JvbGxMZWZ0PTFFNTtkLnNjcm9sbFRvcD0xRTU7Zi5zY3JvbGxMZWZ0PTFFNTtmLnNjcm9sbFRvcD0xRTV9O2coKTt2YXIgbD0hMSxuPWZ1bmN0aW9uKCl7Yi5yZXNpemVkQXR0YWNoZWQmJihsJiYoYi5yZXNpemVkQXR0YWNoZWQuY2FsbCgpLGw9ITEpLGEobikpfTthKG4pO3ZhciBwLHEsRCxHLEY9ZnVuY3Rpb24oKXtpZigoRD1iLm9mZnNldFdpZHRoKSE9cHx8KEc9Yi5vZmZzZXRIZWlnaHQpIT1xKWw9ITAscD1ELHE9RztnKCl9LEg9ZnVuY3Rpb24oYSxiLGMpe2EuYXR0YWNoRXZlbnQ/CmEuYXR0YWNoRXZlbnQoIm9uIitiLGMpOmEuYWRkRXZlbnRMaXN0ZW5lcihiLGMpfTtIKGQsInNjcm9sbCIsRik7SChmLCJzY3JvbGwiLEYpfXZhciBiPWZ1bmN0aW9uKCl7R3JhcGhWaWV3ZXIucmVzaXplU2Vuc29yRW5hYmxlZCYmZCgpfSxlPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChmKSxnPSJbb2JqZWN0IEFycmF5XSI9PT1lfHwiW29iamVjdCBOb2RlTGlzdF0iPT09ZXx8IltvYmplY3QgSFRNTENvbGxlY3Rpb25dIj09PWV8fCJ1bmRlZmluZWQiIT09dHlwZW9mIGpRdWVyeSYmZiBpbnN0YW5jZW9mIGpRdWVyeXx8InVuZGVmaW5lZCIhPT10eXBlb2YgRWxlbWVudHMmJmYgaW5zdGFuY2VvZiBFbGVtZW50cztpZihnKWZvcih2YXIgZT0wLHA9Zi5sZW5ndGg7ZTxwO2UrKylxKGZbZV0sYik7ZWxzZSBxKGYsYik7dGhpcy5kZXRhY2g9ZnVuY3Rpb24oKXtpZihnKWZvcih2YXIgYT0wLGI9Zi5sZW5ndGg7YTxiO2ErKyljLmRldGFjaChmW2FdKTtlbHNlIGMuZGV0YWNoKGYpfX07CmMuZGV0YWNoPWZ1bmN0aW9uKGEpe2EucmVzaXplU2Vuc29yJiYoYS5yZW1vdmVDaGlsZChhLnJlc2l6ZVNlbnNvciksZGVsZXRlIGEucmVzaXplU2Vuc29yLGRlbGV0ZSBhLnJlc2l6ZWRBdHRhY2hlZCl9O3dpbmRvdy5SZXNpemVTZW5zb3I9Y30pKCk7CihmdW5jdGlvbigpe0VkaXRvci5pbml0TWF0aCgpO0dyYXBoVmlld2VyLmluaXRDc3MoKTtpZihudWxsIT13aW5kb3cub25EcmF3aW9WaWV3ZXJMb2FkKXdpbmRvdy5vbkRyYXdpb1ZpZXdlckxvYWQoKTtlbHNlIEdyYXBoVmlld2VyLnByb2Nlc3NFbGVtZW50cygpfSkoKTsK';","//import moment from 'moment';\nimport grafana from 'grafana_func';\nimport { State } from './state_class';\nimport _ from 'lodash';\nimport { Metric } from 'metric_class';\nimport { $GF } from 'globals_class';\nimport chroma from 'chroma-js';\n\n/**\n * Rule definition\n *\n * @export\n * @class Rule\n */\nexport class Rule {\n  data: gf.TIRuleData;\n  shapeMaps: ShapeMap[] = [];\n  textMaps: TextMap[] = [];\n  linkMaps: LinkMap[] = [];\n  eventMaps: EventMap[] = [];\n  valueMaps: ValueMap[] = [];\n  rangeMaps: RangeMap[] = [];\n  id: string;\n  removeClick = 2;\n  states: Map<string, State>;\n  highestLevel: number = -1;\n  highestColor: string = '';\n  highestFormattedValue: string = '';\n  highestValue: any = undefined;\n  execTimes: number = 0;\n\n  /**\n   * Creates an instance of Rule.\n   * @param {string} pattern\n   * @param {TIRuleData} data\n   * @memberof Rule\n   */\n  constructor(pattern: string, data: gf.TIRuleData) {\n    this.data = data;\n    this.data.pattern = pattern;\n    this.id = $GF.utils.uniqueID();\n    this.states = new Map();\n  }\n\n  /**\n   * Get default data\n   *\n   * @static\n   * @returns {gf.TIRuleData}\n   * @memberof Rule\n   */\n  static getDefaultData(): gf.TIRuleData {\n    return {\n      order: 1,\n      pattern: '.*',\n      unit: 'short',\n      type: 'number',\n      metricType: 'serie',\n      alias: 'myRule',\n      refId: 'A',\n      column: 'Time',\n      hidden: false,\n      aggregation: 'current',\n      decimals: 2,\n      colors: ['rgba(245, 54, 54, 0.9)', 'rgba(237, 129, 40, 0.89)', 'rgba(50, 172, 45, 0.97)'],\n      reduce: true,\n      dateFormat: 'YYYY-MM-DD HH:mm:ss',\n      thresholds: [50, 80],\n      stringThresholds: ['/.*/', '/.*/'],\n      invert: false,\n      gradient: false,\n      overlayIcon: false,\n      tooltip: false,\n      tooltipLabel: '',\n      tooltipColors: false,\n      tooltipOn: 'a',\n      tpDirection: 'v',\n      tpGraph: false,\n      tpGraphSize: '100%',\n      tpGraphType: 'line',\n      tpGraphLow: null,\n      tpGraphHigh: null,\n      tpGraphScale: 'linear',\n      shapeProp: 'id',\n      shapeRegEx: true,\n      shapeData: [],\n      textProp: 'id',\n      textRegEx: true,\n      textData: [],\n      linkProp: 'id',\n      linkRegEx: true,\n      linkData: [],\n      eventProp: 'id',\n      eventRegEx: false,\n      eventData: [],\n      mappingType: 1,\n      valueData: [],\n      rangeData: [],\n      sanitize: false,\n    };\n  }\n\n  /**\n   * return data of rule\n   *\n   * @returns {data}\n   * @memberof Rule\n   */\n  getData(): gf.TIRuleData {\n    return this.data;\n  }\n\n  /**\n   * import data in rule\n   *\n   * @returns {this}\n   * @param {data} obj\n   * @memberof Rule\n   */\n  import(obj: any): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'import()');\n    if (!!obj.unit) {\n      this.data.unit = obj.unit;\n    }\n    if (!!obj.type) {\n      this.data.type = obj.type;\n    }\n    if (!!obj.metricType) {\n      this.data.metricType = obj.metricType;\n    }\n    if (!!obj.alias) {\n      this.data.alias = obj.alias;\n    }\n    if (!!obj.refId) {\n      this.data.refId = obj.refId;\n    }\n    if (!!obj.column) {\n      this.data.column = obj.column;\n    }\n    if (!!obj.aggregation) {\n      this.data.aggregation = obj.aggregation;\n    }\n    if (!!obj.decimals || obj.decimals === 0) {\n      this.data.decimals = obj.decimals;\n    }\n    if (!!obj.colors) {\n      this.data.colors = obj.colors.slice(0);\n    }\n    if (!!this.data.reduce) {\n      this.data.reduce = true;\n    }\n\n    // 0.7.0\n    let colorOn: gf.TColorOnKeys | undefined = undefined;\n    if (!!obj.colorOn) {\n      colorOn = obj.colorOn;\n    }\n\n    // 0.7.0\n    let style: gf.TStyleColorKeys | undefined = undefined;\n    if (!!obj.style) {\n      style = obj.style;\n    }\n\n    // 0.7.0\n    let link = false;\n    let linkUrl: string | undefined = undefined;\n    let linkParams: boolean | undefined = undefined;\n    if (!!obj.link) {\n      link = obj.link;\n    }\n    if (!!obj.linkUrl) {\n      linkUrl = obj.linkUrl;\n    }\n    if (!!obj.linkParams) {\n      linkParams = obj.linkParams;\n    }\n\n    // 0.7.0\n    let linkOn: gf.TLinkOnKeys | undefined = undefined;\n    if (!!obj.linkOn) {\n      linkOn = obj.linkOn;\n    }\n\n    // 0.7.0\n    let textOn: gf.TTextOnKeys | undefined = undefined;\n    if (!!obj.textOn) {\n      textOn = obj.textOn;\n    }\n\n    // 0.7.0\n    let textReplace: gf.TTextMethodKeys | undefined = undefined;\n    let textPattern: string | undefined = undefined;\n    if (!!obj.textReplace) {\n      textReplace = obj.textReplace;\n    }\n    if (!!obj.textPattern) {\n      textPattern = obj.textPattern;\n    }\n    if (!!obj.pattern) {\n      this.data.pattern = obj.pattern;\n    }\n    if (!!obj.dateFormat) {\n      this.data.dateFormat = obj.dateFormat;\n    }\n    if (!!obj.thresholds) {\n      this.data.thresholds = obj.thresholds.map((x: any) => {\n        let value = x;\n        if (typeof value === 'string') {\n          value = parseFloat(value);\n        }\n        return value;\n      });\n      // this.data.thresholds = obj.thresholds.slice(0);\n    }\n\n    if (!!obj.stringThresholds) {\n      this.data.stringThresholds = obj.stringThresholds.slice(0);\n    }\n\n    if (!!obj.stringWarning) {\n      //this.data.stringWarning = obj.stringWarning;\n      this.data.stringThresholds[1] = obj.stringWarning;\n    }\n    if (!!obj.stringCritical) {\n      //this.data.stringCritical = obj.stringCritical;\n      this.data.stringThresholds[0] = obj.stringCritical;\n    }\n\n    if (!!obj.invert || obj.invert === false) {\n      this.data.invert = obj.invert;\n    }\n\n    if (!!obj.gradient || obj.gradient === false) {\n      this.data.gradient = obj.gradient;\n    }\n\n    if (!!obj.overlayIcon || obj.overlayIcon === false) {\n      this.data.overlayIcon = obj.overlayIcon;\n    }\n    if (!!obj.tooltip || obj.tooltip === false) {\n      this.data.tooltip = obj.tooltip;\n    }\n    if (!!obj.tooltipLabel) {\n      this.data.tooltipLabel = obj.tooltipLabel;\n    }\n    if (!!obj.tooltipColors || obj.tooltipColors === false) {\n      this.data.tooltipColors = obj.tooltipColors;\n    }\n    if (!!obj.tooltipOn) {\n      this.data.tooltipOn = obj.tooltipOn;\n    }\n    if (!!obj.tpDirection) {\n      this.data.tpDirection = obj.tpDirection;\n    }\n    if (!!obj.tpGraph || this.data.tpGraph === false) {\n      this.data.tpGraph = obj.tpGraph;\n    }\n    if (!!obj.tpGraphSize) {\n      this.data.tpGraphSize = obj.tpGraphSize;\n    }\n    if (!!obj.tpGraphType) {\n      this.data.tpGraphType = obj.tpGraphType;\n    }\n    if (!!obj.tpGraphLow || obj.tpGraphLow === 0) {\n      this.data.tpGraphLow = obj.tpGraphLow;\n    }\n    if (!!obj.tpGraphHigh || obj.tpGraphHigh === 0) {\n      this.data.tpGraphHigh = obj.tpGraphHigh;\n    }\n    if (!!obj.tpGraphScale) {\n      this.data.tpGraphScale = obj.tpGraphScale;\n    }\n    let maps: any = [];\n\n    // SHAPES\n    if (!!obj.shapeProp) {\n      this.data.shapeProp = obj.shapeProp;\n    }\n    if (!!obj.shapeRegEx || obj.shapeRegEx === false) {\n      this.data.shapeRegEx = obj.shapeRegEx;\n    }\n\n    this.data.shapeData = [];\n\n    // For 0.2.0\n    maps = [];\n    if (obj.shapeMaps !== undefined && obj.shapeMaps !== null && obj.shapeMaps.length > 0) {\n      maps = obj.shapeMaps;\n    } else {\n      maps = obj.shapeData;\n    }\n\n    if (maps !== undefined && maps !== null && maps.length > 0) {\n      maps.forEach((shapeData: gf.TShapeMapData) => {\n        // 0.7.0\n        if (!!style) {\n          shapeData.style = style;\n        }\n\n        // 0.7.0\n        if (!!colorOn) {\n          shapeData.colorOn = colorOn;\n        }\n        this.addShapeMap('').import(shapeData);\n      });\n    }\n\n    // TEXT\n    this.data.textProp = obj.textProp || 'id';\n    if (!!obj.textRegEx || obj.textRegEx === false) {\n      this.data.textRegEx = obj.textRegEx;\n    }\n    this.data.textData = [];\n    // For 0.2.0\n    maps = [];\n    if (obj.shapeMaps !== undefined && obj.shapeMaps !== null && obj.shapeMaps.length > 0) {\n      maps = obj.textMaps;\n    } else {\n      maps = obj.textData;\n    }\n\n    if (maps !== undefined && maps != null && maps.length > 0) {\n      maps.forEach((textData: gf.TTextMapData) => {\n        // 0.7.0\n        if (!!textReplace) {\n          textData.textReplace = textReplace;\n        }\n        if (!!textPattern) {\n          textData.textPattern = textPattern;\n        }\n        if (!!textOn) {\n          textData.textOn = textOn;\n        }\n\n        this.addTextMap('').import(textData);\n      });\n    }\n\n    // LINK\n    this.data.linkProp = obj.linkProp || 'id';\n    if (!!obj.linkRegEx || obj.linkRegEx === false) {\n      this.data.linkRegEx = obj.linkRegEx;\n    }\n    this.data.linkData = [];\n    if (obj.linkData !== undefined && obj.linkData != null && obj.linkData.length > 0) {\n      obj.linkData.forEach((linkData: gf.TlinkMapData) => {\n        // 0.7.0\n        if (!!linkUrl && link) {\n          linkData.linkUrl = linkUrl;\n        }\n        if (!!linkParams && link) {\n          linkData.linkParams = linkParams;\n        }\n        if (!!linkOn) {\n          linkData.linkOn = linkOn;\n        }\n        this.addLinkMap('').import(linkData);\n      });\n    }\n\n    // EVENT\n    this.data.eventProp = obj.eventProp || 'id';\n    if (!!obj.eventRegEx || obj.eventRegEx === false) {\n      this.data.eventRegEx = obj.eventRegEx;\n    }\n    this.data.eventData = [];\n    if (obj.eventData !== undefined && obj.eventData != null && obj.eventData.length > 0) {\n      obj.eventData.forEach((eventData: gf.TEventMapData) => {\n        // 0.7.0\n        this.addEventMap('').import(eventData);\n      });\n    }\n\n    this.data.mappingType = obj.mappingType || 1;\n\n    // VALUES\n    this.data.valueData = [];\n    if (obj.valueData !== undefined && obj.valueData != null && obj.valueData.length > 0) {\n      obj.valueData.forEach((valueData: gf.TValueMapData) => {\n        this.addValueMap('value', 'text').import(valueData);\n      });\n    }\n\n    // RANGE\n    this.data.rangeData = [];\n    if (obj.rangeData !== undefined && obj.rangeData != null && obj.rangeData.length > 0) {\n      obj.rangeData.forEach(rangeData => {\n        this.addRangeMap('from', 'to', 'text').import(rangeData);\n      });\n    }\n    this.data.sanitize = obj.sanitize || false;\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Return uniq id of rule\n   *\n   * @returns\n   * @memberof Rule\n   */\n  getId(): string {\n    return this.id;\n  }\n\n  /**\n   * Highlight Cells in rule (mapping color text and link)\n   *\n   * @memberof Rule\n   */\n  highlightCells() {\n    if (this.states) {\n      this.states.forEach(state => {\n        state.highlightCell();\n      });\n    }\n  }\n\n  /**\n   * Highlight Cells in rule (mapping color text and link)\n   *\n   * @memberof Rule\n   */\n  unhighlightCells() {\n    if (this.states) {\n      this.states.forEach(state => {\n        state.unhighlightCell();\n      });\n    }\n  }\n\n  /**\n   * Return the order of this rule\n   * Grafana 6+ have a bug when reload dashboad, array are not in order\n   *\n   * @param {number} order\n   * @memberof Rule\n   */\n  setOrder(order: number) {\n    this.data.order = order;\n  }\n\n  /**\n   * Return order of rule\n   *\n   * @memberof Rule\n   */\n  getOrder(): number {\n    return this.data.order;\n  }\n\n  isHidden(): boolean {\n    return this.data.hidden;\n  }\n\n  hide(): this {\n    this.data.hidden = true;\n    return this;\n  }\n\n  show(): this {\n    this.data.hidden = false;\n    return this;\n  }\n\n  /**\n   * Invert color order\n   *\n   * @returns {this}\n   * @memberof Rule\n   */\n  invertColorOrder(): this {\n    // const ref = this.data.colors;\n    // const copy = ref[0];\n    // ref[0] = ref[2];\n    // ref[2] = copy;\n    this.data.colors.reverse();\n    // this.data.invert = !this.data.invert;\n    // if (this.data.invert) {\n    //   this.data.invert = false;\n    // } else {\n    //   this.data.invert = true;\n    // }\n    return this;\n  }\n\n  /**\n   * Invert threshold\n   *\n   * @returns {this}\n   * @memberof Rule\n   */\n  invertThesholds(): this {\n    this.invertColorOrder();\n    this.data.invert = !this.data.invert;\n    return this;\n  }\n\n  /**\n   *\n   *\n   * @param {number} index\n   * @returns {this}\n   * @memberof Rule\n   */\n  addColor(index: number): this {\n    const thresholds = this.data.thresholds;\n    const colors = this.data.colors;\n    const colorStart: string = colors[index];\n    let color: string;\n    let value: any;\n    if (index !== colors.length - 1) {\n      const ratio = 0.5;\n      let colorEnd = colors[index + 1];\n      try {\n        // color = $GF.utils.getRatioColor(ratio, colorStart, colorEnd);\n        let f = chroma.scale([colorStart, colorEnd]).mode('lrgb');\n        color = f(ratio).hex();\n      } catch (error) {\n        $GF.log.error(error);\n        color = colorStart;\n      }\n      if (this.data.type === 'number') {\n        let absoluteDistance = thresholds[index] - thresholds[index - 1];\n        value = absoluteDistance / 2 + thresholds[index - 1];\n      } else {\n        value = this.data.stringThresholds[index - 1];\n      }\n    } else {\n      color = colorStart;\n    }\n    this.data.colors.splice(index + 1, 0, color);\n    if (this.data.type === 'number') {\n      this.data.thresholds.splice(index, 0, value);\n    } else if (this.data.type === 'string') {\n      this.data.stringThresholds.splice(index, 0, value);\n    }\n    return this;\n  }\n\n  /**\n   *\n   *\n   * @param {number} index\n   * @returns {this}\n   * @memberof Rule\n   */\n  removeColor(index: number): this {\n    this.data.thresholds.splice(index - 1, 1);\n    this.data.stringThresholds.splice(index - 1, 1);\n    this.data.colors.splice(index, 1);\n    return this;\n  }\n\n  /**\n   * Return a color\n   *\n   * @param {number} index\n   * @returns {string} html color\n   * @memberof Rule\n   */\n  getColor(index: number): string {\n    return this.data.colors[index];\n  }\n\n  /**\n   * Return Array of html colors\n   *\n   * @returns {string[]}\n   * @memberof Rule\n   */\n  getColors(): string[] {\n    return this.data.colors;\n  }\n\n  /**\n   * Return number of colors\n   *\n   * @returns {number}\n   * @memberof Rule\n   */\n  getColorsCount(): number {\n    return this.data.colors.length;\n  }\n\n  //\n  // Conditions\n  //\n\n  /**\n   * Return true or false for condition to display icon warning\n   *\n   * @param {level} level\n   * @returns {boolean}\n   * @memberof Rule\n   */\n  toIconize(level: number): boolean {\n    if (this.data.overlayIcon === false) {\n      return false;\n    }\n    if (this.data.overlayIcon === true && level >= 1) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Return true or false for condition to display tooltip with values\n   *\n   * @param {number} level\n   * @returns\n   * @memberof Rule\n   */\n  toTooltipize(level: number): boolean {\n    if (this.data.tooltip === false) {\n      return false;\n    }\n    if (this.data.tooltipOn === 'a') {\n      return true;\n    }\n    if (this.data.tooltipOn === 'wc' && level >= 1) {\n      return true;\n    }\n    return false;\n  }\n\n  //\n  // Series|Tables\n  //\n  /**\n   * Return boolean if metrics is matched by rule\n   *\n   * @param {Metric} metric\n   * @returns {boolean}\n   * @memberof Rule\n   */\n  matchMetric(metric: Metric): boolean {\n    if (this.data.metricType === 'serie' && metric.type === 'serie') {\n      return $GF.utils.matchString(metric.getName(), this.data.pattern);\n    }\n    if (this.data.metricType === 'table' && metric.type === 'table') {\n      return metric.getName() === this.data.refId;\n    }\n    return false;\n  }\n\n  //\n  // SHAPE MAPS\n  //\n  /**\n   * Add new shape for rule\n   *\n   * @param {string} pattern\n   * @memberof Rule\n   */\n  addShapeMap(pattern: string): ShapeMap {\n    const data = ShapeMap.getDefaultData();\n    const m = new ShapeMap(pattern, data);\n    this.shapeMaps.push(m);\n    this.data.shapeData.push(data);\n    return m;\n  }\n\n  /**\n   * Remove shape for rule\n   *\n   * @returns {this}\n   * @param {number} index\n   * @memberof Rule\n   */\n  removeShapeMap(index: number): this {\n    this.data.shapeData.splice(index, 1);\n    this.shapeMaps.splice(index, 1);\n    return this;\n  }\n\n  /**\n   * Return shape objet in index position\n   *\n   * @param {number} index\n   * @returns {ShapeMap}\n   * @memberof Rule\n   */\n  getShapeMap(index: number): ShapeMap {\n    return this.shapeMaps[index];\n  }\n\n  /**\n   * Return all ShapeMaps\n   *\n   * @returns {Array<ShapeMap>}\n   * @memberof Rule\n   */\n  getShapeMaps(): ShapeMap[] {\n    return this.shapeMaps;\n  }\n\n  /**\n   * Return bool if shape name (value|id) is in rule\n   *\n   * @param {string} pattern\n   * @returns {boolean}\n   * @memberof Rule\n   */\n  matchShape(pattern: string | null): boolean {\n    let found = false;\n    this.shapeMaps.forEach(element => {\n      if (element.match(pattern, this.data.shapeRegEx)) {\n        found = true;\n      }\n    });\n    return found;\n  }\n\n  //\n  // TEXT MAPS\n  //\n  addTextMap(pattern: string): TextMap {\n    const data = TextMap.getDefaultData();\n    const m = new TextMap(pattern, data);\n    this.textMaps.push(m);\n    this.data.textData.push(data);\n    return m;\n  }\n\n  removeTextMap(index: number) {\n    this.data.textData.splice(index, 1);\n    this.textMaps.splice(index, 1);\n  }\n\n  getTextMap(index: number): TextMap {\n    return this.textMaps[index];\n  }\n\n  getTextMaps(): TextMap[] {\n    return this.textMaps;\n  }\n\n  matchText(pattern: string | null): boolean {\n    let found = false;\n    this.textMaps.forEach(element => {\n      if (element.match(pattern)) {\n        found = true;\n      }\n    });\n    return found;\n  }\n\n  //\n  // Event MAPS\n  //\n  addEventMap(pattern: string): EventMap {\n    const data = EventMap.getDefaultData();\n    const m = new EventMap(pattern, data);\n    this.eventMaps.push(m);\n    this.data.eventData.push(data);\n    return m;\n  }\n\n  removeEventMap(index: number) {\n    this.data.eventData.splice(index, 1);\n    this.eventMaps.splice(index, 1);\n  }\n\n  getEventMap(index: number): EventMap {\n    return this.eventMaps[index];\n  }\n\n  getEventMaps(): EventMap[] {\n    return this.eventMaps;\n  }\n\n  matchEvent(pattern: string | null): boolean {\n    let found = false;\n    this.eventMaps.forEach(element => {\n      if (element.match(pattern)) {\n        found = true;\n      }\n    });\n    return found;\n  }\n\n  //\n  // LINK MAPS\n  //\n  addLinkMap(pattern: string): LinkMap {\n    $GF.log.info('Rule.addLinkMap()');\n    const data = LinkMap.getDefaultData();\n    const m = new LinkMap(pattern, data);\n    m.import(data);\n    this.linkMaps.push(m);\n    this.data.linkData.push(data);\n    return m;\n  }\n\n  removeLinkMap(index: number) {\n    this.data.linkData.splice(index, 1);\n    this.linkMaps.splice(index, 1);\n  }\n\n  getLinkMap(index: number): LinkMap {\n    return this.linkMaps[index];\n  }\n\n  getLinkMaps(): LinkMap[] {\n    return this.linkMaps;\n  }\n\n  matchLink(pattern: string | null): boolean {\n    let found = false;\n    this.linkMaps.forEach(element => {\n      if (element.match(pattern)) {\n        found = true;\n      }\n    });\n    return found;\n  }\n\n  //\n  // STRING VALUE MAPS\n  //\n  addValueMap(value: any, text: string): ValueMap {\n    const data: gf.TValueMapData = ValueMap.getDefaultdata();\n    const m = new ValueMap(value, text, data);\n    this.valueMaps.push(m);\n    this.data.valueData.push(data);\n    return m;\n  }\n\n  removeValueMap(index) {\n    this.data.valueData.splice(index, 1);\n    this.valueMaps.splice(index, 1);\n  }\n\n  getValueMap(index): ValueMap {\n    return this.valueMaps[index];\n  }\n\n  getValueMaps(): ValueMap[] {\n    return this.valueMaps;\n  }\n\n  //\n  // STRING RANGE VALUE MAPS\n  //\n  addRangeMap(from, to, text): RangeMap {\n    const data = RangeMap.getDefaultData();\n    const m = new RangeMap(from, to, text, data);\n    this.rangeMaps.push(m);\n    this.data.rangeData.push(data);\n    return m;\n  }\n\n  removeRangeMap(index) {\n    this.data.rangeData.splice(index, 1);\n    this.rangeMaps.splice(index, 1);\n  }\n\n  getRangeMap(index): RangeMap {\n    return this.rangeMaps[index];\n  }\n\n  getRangeMaps(): RangeMap[] {\n    return this.rangeMaps;\n  }\n\n  hideRangeMap(index): this {\n    this.rangeMaps[index].hide();\n    return this;\n  }\n\n  showRangeMap(index): this {\n    this.rangeMaps[index].show();\n    return this;\n  }\n\n  getExectedTime(): string {\n    return typeof this.execTimes === 'number' ? `${this.execTimes.toFixed(2)} ms` : `${this.execTimes} ms`;\n  }\n\n  //\n  // Format value\n  //\n  /**\n   * Get color according to value\n   *\n   * @param {number} value\n   * @returns {string} html color\n   * @memberof Rule\n   */\n  getColorForValue(value: any): string {\n    if (!this.data.gradient || this.data.type !== 'number') {\n      let level = this.getThresholdLevel(value);\n      return this.getColorForLevel(level);\n    }\n    if (this.data.type === 'number') {\n      const thresholds = this.data.thresholds;\n      const colors = this.data.colors;\n      let l = thresholds.length;\n      // No Thresholds\n      if (thresholds === undefined || l === 0) {\n        return colors[0];\n      }\n\n      let cursor = 0;\n      for (let index = 0; index < l; index++) {\n        const t = thresholds[index];\n        if (value < t) {\n          break;\n        }\n        cursor = index;\n      }\n      // value Lower than min level\n      if (cursor === 0 && value <= thresholds[0]) {\n        return colors[0];\n      }\n      // value upper then max level\n      if (cursor === l - 1) {\n        return colors[cursor + 1];\n      }\n      // Or\n      let absoluteDistance = thresholds[cursor + 1] - thresholds[cursor];\n      let valueDistanceFromMin = value - thresholds[cursor];\n      let ratio = valueDistanceFromMin / absoluteDistance;\n      // let color = $GF.utils.getRatioColor(ratio, colors[cursor + 1], colors[cursor + 2]);\n      let color = colors[cursor + 1];\n      try {\n        color = chroma\n          .scale([colors[cursor + 1], colors[cursor + 2]])\n          .mode('lrgb')(ratio)\n          .hex();\n      } catch (error) {\n        color = colors[cursor + 1];\n      }\n      return color;\n    }\n    return '';\n  }\n\n  /**\n   * Get color according level (-1,0,1,2)\n   *\n   * @param {*} level\n   * @returns\n   * @memberof Rule\n   */\n  getColorForLevel(level: number): string {\n    const colors = this.data.colors;\n    if (level < 0) {\n      return colors[0];\n    }\n    let l = level;\n    if (!this.data.invert) {\n      l = this.data.colors.length - 1 - level;\n    }\n    if (colors[l] !== undefined) {\n      return colors[l];\n    }\n    return colors[0];\n  }\n\n  /**\n   * Return Level according to value and rule options\n   *\n   * @param {number} value\n   * @returns 0, 1 or 2\n   * @memberof Rule\n   */\n  getThresholdLevel(value: any): number {\n    // NUMBER\n    if (this.data.type === 'number') {\n      let thresholdLevel = 0;\n      let thresholds = this.data.thresholds;\n\n      if (thresholds === undefined || thresholds.length === 0) {\n        return 0;\n      }\n\n      let l = thresholds.length;\n      for (let index = 0; index < l; index++) {\n        const t = thresholds[index];\n        if (value < t) {\n          break;\n        }\n        thresholdLevel = index + 1;\n      }\n\n      if (!this.data.invert) {\n        thresholdLevel = this.data.colors.length - 1 - thresholdLevel;\n      }\n      return thresholdLevel;\n    }\n    // STRING\n    if (this.data.type === 'string') {\n      let thresholdLevel = 0;\n      const formatedValue = this.getFormattedValue(value);\n      let thresholds = this.data.stringThresholds;\n      if (thresholds === undefined || thresholds.length === 0) {\n        return 0;\n      }\n      let l = thresholds.length;\n      for (let index = 0; index < l; index++) {\n        const t = thresholds[index];\n        if ($GF.utils.matchString(value, t) || $GF.utils.matchString(formatedValue, t)) {\n          thresholdLevel = index + 1;\n          break;\n        }\n      }\n\n      if (!this.data.invert) {\n        thresholdLevel = this.data.colors.length - 1 - thresholdLevel;\n      }\n      return thresholdLevel;\n    }\n    return 0;\n  }\n\n  /**\n   * Get value for this metric\n   *\n   * @param {Metric} metric\n   * @returns {(string | number | null)}\n   * @memberof Rule\n   */\n  getValueForMetric(metric: Metric): string | number | null {\n    if (this.matchMetric(metric)) {\n      try {\n        const value = metric.getValue(this.data.aggregation, this.data.column);\n        return value;\n      } catch (error) {\n        $GF.log.error('datapoint for metric is null', error);\n        return null;\n      }\n    }\n    return '-';\n  }\n\n  /**\n   * Get formatting value according unit\n   *\n   * @param {Metric} metric\n   * @returns {string}\n   * @memberof Rule\n   */\n  getFormattedValueForMetric(metric: Metric): string {\n    const formattedValue = this.getValueForMetric(metric);\n    return this.getFormattedValue(formattedValue);\n  }\n\n  /**\n   * Format a one value according rule\n   *\n   * @param {*} value\n   * @returns\n   * @memberof Rule\n   */\n  getFormattedValue(value: any) {\n    // Number\n    if (this.data.type === 'number') {\n      if (!_.isFinite(value)) {\n        return 'null';\n      }\n      if (value === null || value === void 0) {\n        return '-';\n      }\n      let decimals = this.decimalPlaces(value);\n      decimals = typeof this.data.decimals === 'number' ? Math.min(this.data.decimals, decimals) : decimals;\n      return grafana.formatValue(value, this.data.unit, this.data.decimals);\n    }\n\n    if (this.data.type === 'string') {\n      if (value === null || value === void 0) {\n        value = 'null';\n      }\n\n      if (_.isArray(value)) {\n        value = value.join(', ');\n      }\n      const mappingType = this.data.mappingType || 0;\n      if (mappingType === 1 && this.valueMaps) {\n        for (let i = 0; i < this.valueMaps.length; i += 1) {\n          const map = this.valueMaps[i];\n          if (map.match(value)) {\n            return map.getFormattedText(value);\n          }\n        }\n        return value.toString();\n      }\n\n      if (mappingType === 2 && this.rangeMaps) {\n        for (let i = 0; i < this.rangeMaps.length; i += 1) {\n          const map = this.rangeMaps[i];\n          if (map.match(value)) {\n            return map.getFormattedText(value);\n          }\n        }\n        return value.toString();\n      }\n\n      if (value === null || value === void 0) {\n        return 'null';\n      }\n    }\n\n    if (this.data.type === 'date') {\n      if (value === undefined || value === null) {\n        return '-';\n      }\n\n      if (_.isArray(value)) {\n        value = value[0];\n      }\n\n      let d = grafana.getFormatedDate(value, this.data.dateFormat);\n      return d;\n    }\n    return value;\n  }\n\n  defaultValueFormatter(value: any) {\n    if (value === null || value === void 0 || value === undefined) {\n      return '';\n    }\n\n    if (_.isArray(value)) {\n      value = value.join(', ');\n    }\n\n    if (this.data.sanitize) {\n      return this.$sanitize(value);\n    }\n    return _.escape(value);\n  }\n  $sanitize(value: any) {\n    throw new Error('Method not implemented.');\n  }\n\n  decimalPlaces(num) {\n    const match = ('' + num).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n    if (!match) {\n      return 0;\n    }\n    return Math.max(\n      0,\n      // Number of digits right of decimal point.\n      (match[1] ? match[1].length : 0) -\n        // Adjust for scientific notation.\n        (match[2] ? +match[2] : 0)\n    );\n  }\n}\n\nexport class GFMap {\n  data: gf.TGFMapData;\n  id: string;\n  static methods: any[] = [];\n  constructor(pattern, data: gf.TGFMapData) {\n    this.data = data;\n    this.data.pattern = pattern;\n    this.id = $GF.utils.uniqueID();\n    // this.import(data);\n  }\n\n  /**\n   * Import data from panel\n   *\n   * @param {*} obj\n   * @returns {this}\n   * @memberof GFMap\n   */\n  import(obj: any): this {\n    if (!!obj.pattern) {\n      this.data.pattern = obj.pattern;\n    }\n    if (!!obj.hidden) {\n      this.data.hidden = obj.hidden;\n    }\n    return this;\n  }\n\n  static getDefaultMethods() {\n    return this.methods;\n  }\n\n  static getDefaultPlaceHolder(value: string): string | undefined {\n    const elt = this.methods.find(x => x.value === value);\n    if (elt !== undefined) {\n      return elt.placeholder;\n    }\n    return undefined;\n  }\n\n  static getDefaultValue(value: string): string | undefined {\n    const elt = this.methods.find(x => x.value === value);\n    if (elt !== undefined) {\n      return elt.default;\n    }\n    return undefined;\n  }\n\n  /**\n   * Return if text match pattern\n   *\n   * @param {(string | null)} text\n   * @returns {boolean}\n   * @memberof GFMap\n   */\n  match(text: string | null, regex = true): boolean {\n    if (text === undefined || text === null || text.length === 0) {\n      return false;\n    }\n    return $GF.utils.matchString(text, this.data.pattern, regex);\n  }\n\n  /**\n   * Return uniq ID\n   *\n   * @returns {string}\n   * @memberof GFMap\n   */\n  getId(): string {\n    return this.id;\n  }\n\n  /**\n   * Show/enable\n   *\n   * @returns {this}\n   * @memberof GFMap\n   */\n  show(): this {\n    this.data.hidden = false;\n    return this;\n  }\n\n  /**\n   * Hide/disable\n   *\n   * @returns {this}\n   * @memberof GFMap\n   */\n  hide(): this {\n    this.data.hidden = true;\n    return this;\n  }\n\n  /**\n   * Return if hidden\n   *\n   * @returns {boolean}\n   * @memberof GFMap\n   */\n  isHidden(): boolean {\n    if (this.data.hidden === undefined) {\n      return false;\n    }\n    return this.data.hidden;\n  }\n\n  /**\n   * Toggle Visible/Hide\n   *\n   * @returns {boolean}\n   * @memberof GFMap\n   */\n  toVisible(): boolean {\n    if (this.data.hidden) {\n      return false;\n    }\n    return true;\n  }\n\n  export(): gf.TGFMapData {\n    return {\n      pattern: this.data.pattern,\n      hidden: this.data.hidden,\n    };\n  }\n}\n\n/**\n * ShapeMap class for mapping\n * @class ShapeMap\n * @extends GFMap\n */\nexport class ShapeMap extends GFMap {\n  data: gf.TShapeMapData;\n\n  /**\n   * Creates an instance of ShapeMap.\n   * @param {string} pattern\n   * @param {gf.TShapeMapData} data\n   * @memberof ShapeMap\n   */\n  constructor(pattern: string, data: gf.TShapeMapData) {\n    super(pattern, data);\n    this.data = data;\n  }\n\n  /**\n   * Return default data\n   *\n   * @static\n   * @returns {gf.TShapeMapData}\n   * @memberof ShapeMap\n   */\n  static getDefaultData(): gf.TShapeMapData {\n    return {\n      pattern: '',\n      hidden: false,\n      style: 'fillColor',\n      colorOn: 'a',\n    };\n  }\n\n  /**\n   * Return true or false for condition to colorize\n   *\n   * @param {number} level\n   * @returns {boolean}\n   * @memberof ShapeMap\n   * 0.7.0 : Moved to shape\n   */\n  toColorize(level: number): boolean {\n    if (level === -1) {\n      return false;\n    }\n    if (this.data.colorOn === 'n') {\n      return false;\n    }\n    if (this.data.colorOn === 'a') {\n      return true;\n    }\n    if (this.data.colorOn === 'wc' && level >= 1) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Import data\n   *\n   * @param {*} obj\n   * @returns {this}\n   * @memberof ShapeMap\n   */\n  import(obj: any): this {\n    super.import(obj);\n    if (!!obj.style) {\n      this.data.style = obj.style;\n    }\n    if (!!obj.colorOn) {\n      this.data.colorOn = obj.colorOn;\n    }\n    return this;\n  }\n}\n\n/**\n * TextMap class for mapping\n * @class TextMap\n * @extends GFMap\n */\nexport class TextMap extends GFMap {\n  data: gf.TTextMapData;\n\n  constructor(pattern: string, data: gf.TTextMapData) {\n    super(pattern, data);\n    this.data = data;\n  }\n\n  /**\n   * Return default data\n   *\n   * @static\n   * @returns {gf.TTextMapData}\n   * @memberof TextMap\n   */\n  static getDefaultData(): gf.TTextMapData {\n    return {\n      pattern: '',\n      hidden: false,\n      textReplace: 'content',\n      textPattern: '/.*/',\n      textOn: 'wmd',\n    };\n  }\n\n  /**\n   * Return true or false for condition to change label\n   *\n   * @param {number} level\n   * @returns {boolean}\n   * @memberof TextMap\n   */\n  toLabelize(level: number): boolean {\n    // if (this.data.textOn === 'wmd' && level > 0) return true;\n    // if (this.data.textOn === 'wmd' && level === -1) return false;\n    if (this.data.textOn === 'wmd') {\n      return true;\n    }\n    if (this.data.textOn === 'n') {\n      return false;\n    }\n    if (this.data.textOn === 'wc' && level >= 1) {\n      return true;\n    }\n    if (this.data.textOn === 'co' && level >= 2) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Import data from current or old version\n   *\n   * @param {*} obj\n   * @returns {this}\n   * @memberof TextMap\n   */\n  import(obj: any): this {\n    super.import(obj);\n    if (!!obj.textReplace) {\n      this.data.textReplace = obj.textReplace;\n    }\n    if (!!obj.textPattern) {\n      this.data.textPattern = obj.textPattern;\n    }\n    if (!!obj.textOn) {\n      this.data.textOn = obj.textOn;\n    }\n\n    return this;\n  }\n\n  /**\n   * Replace text according text options\n   *\n   * @param {string} text\n   * @param {string} FormattedValue\n   * @returns\n   * @memberof Rule\n   */\n  getReplaceText(text: string, FormattedValue: string): string {\n    if (this.data.textReplace === 'content') {\n      return FormattedValue;\n    }\n    if (this.data.textReplace === 'pattern') {\n      const regexVal = $GF.utils.stringToJsRegex(this.data.textPattern);\n      if (text.toString().match(regexVal)) {\n        return text.toString().replace(regexVal, FormattedValue);\n      }\n      return text;\n    }\n    if (this.data.textReplace === 'as') {\n      return `${text} ${FormattedValue}`;\n    }\n    if (this.data.textReplace === 'anl') {\n      return `${text}\\n${FormattedValue}`;\n    }\n    return text;\n  }\n}\n\n/**\n * LinkMap class for mapping\n * @class LinkMap\n * @extends GFMap\n */\nexport class LinkMap extends GFMap {\n  data: gf.TlinkMapData;\n\n  constructor(pattern: string, data: gf.TlinkMapData) {\n    super(pattern, data);\n    this.data = data;\n  }\n\n  static getDefaultData(): gf.TlinkMapData {\n    return {\n      pattern: '',\n      hidden: false,\n      linkUrl: '',\n      linkParams: false,\n      linkOn: 'a',\n    };\n  }\n\n  /**\n   * Get defined link\n   *\n   * @returns\n   * @memberof Rule\n   */\n  getLink() {\n    if (this.data.linkParams) {\n      return this.data.linkUrl + window.location.search;\n    }\n    return this.data.linkUrl;\n  }\n\n  /**\n   * Import data to Link\n   *\n   * @param {*} obj\n   * @returns {this}\n   * @memberof LinkMap\n   */\n  import(obj: any): this {\n    super.import(obj);\n    if (!!obj.linkUrl) {\n      this.data.linkUrl = obj.linkUrl;\n    }\n    if (!!obj.linkParams) {\n      this.data.linkParams = obj.linkParams;\n    }\n    if (!!obj.linkOn) {\n      this.data.linkOn = obj.linkOn;\n    }\n    return this;\n  }\n\n  /**\n   * Return true or false for condition to add/replace link\n   *\n   * @param {number} level\n   * @returns {boolean}\n   * @memberof LinkMap\n   */\n  toLinkable(level: number): boolean {\n    if (this.data.linkOn === 'a') {\n      return true;\n    }\n    if (this.data.linkOn === 'wc' && level >= 1) {\n      return true;\n    }\n    return false;\n  }\n}\n\nexport class EventMap extends GFMap {\n  data: gf.TEventMapData;\n  static methods = $GF.CONSTANTS.EVENTMETHODS;\n  // static shapes: string[] = EventMap.getFormNames();\n  static shapes: string[] = [];\n\n  /**\n   * Creates an instance of EventMap.\n   * @param {string} pattern\n   * @param {gf.TEventMapData} data\n   * @memberof EventMap\n   */\n  constructor(pattern: string, data: gf.TEventMapData) {\n    super(pattern, data);\n    this.data = data;\n    // GFGlobal.loadFile(_GF.CONSTANTS.VAR_STG_SHAPES, _GF.CONSTANTS.CONF_FILE_SHAPES);\n  }\n\n  /**\n   * Return default data\n   *\n   * @static\n   * @returns {gf.TShapeMapData}\n   * @memberof ShapeMap\n   */\n  static getDefaultData(): gf.TEventMapData {\n    return {\n      pattern: '',\n      hidden: false,\n      style: 'shape',\n      eventOn: 0,\n      value: '',\n    };\n  }\n\n  getPlaceHolder(): string {\n    const ph = EventMap.getDefaultPlaceHolder(this.data.style);\n    return ph !== undefined ? ph : '';\n  }\n\n  getTypeahead(): string[] {\n    const self = this;\n    let result = $GF.getFullAvailableVarNames();\n    const elt: gf.TStyleEventElt | undefined = EventMap.methods.find(x => x.value === self.data.style);\n    if (elt !== undefined && elt.typeahead !== undefined) {\n      result = result.concat(elt.typeahead.split('|'));\n      return result;\n    }\n    if (this.data.style === 'shape') {\n      const shapes = EventMap.getFormNames();\n      Array.prototype.push.apply(result, shapes);\n    }\n    return result;\n  }\n\n  getValueByDefault(): string {\n    const vbd = EventMap.getDefaultValue(this.data.style);\n    return vbd !== undefined ? vbd : '';\n  }\n\n  static getFormNames(): string[] {\n    // if (EventMap.shapes === undefined) {\n    //   EventMap.shapes = [];\n    // }\n\n    if (EventMap.shapes.length > 0) {\n      return EventMap.shapes;\n    }\n    // _GF.loadLocalFile(_GF.CONSTANTS.VAR_STG_SHAPES, _GF.CONSTANTS.CONF_FILE_SHAPES);\n    // const shapesText: string = _GF.getVar(_GF.CONSTANTS.VAR_STG_SHAPES);\n    const shapesText = $GF.utils.loadFile(\n      $GF.getVar($GF.CONSTANTS.VAR_STG_CTXROOT) + $GF.CONSTANTS.CONF_FILE_SHAPESTXT\n    );\n    if (shapesText !== undefined) {\n      if (EventMap.shapes.length === 0) {\n        EventMap.shapes = EventMap.shapes.concat(shapesText.split(/\\n/));\n        // _GF.unsetVar(_GF.CONSTANTS.VAR_STG_SHAPES);\n        return EventMap.shapes;\n      }\n    }\n    return EventMap.shapes;\n  }\n\n  /**\n   * Return true or false for condition to colorize\n   *\n   * @param {number} level\n   * @returns {boolean}\n   * @memberof ShapeMap\n   * 0.7.0 : Moved to shape\n   */\n  toEventable(level: number): boolean {\n    return this.data.eventOn === -1 || level === this.data.eventOn;\n  }\n\n  /**\n   * Import data\n   *\n   * @param {*} obj\n   * @returns {this}\n   * @memberof ShapeMap\n   */\n  import(obj: any): this {\n    super.import(obj);\n    if (!!obj.style) {\n      this.data.style = obj.style;\n    }\n    if (!!obj.eventOn) {\n      this.data.eventOn = obj.eventOn;\n    }\n    if (!!obj.value) {\n      this.data.value = obj.value;\n    }\n    return this;\n  }\n}\n\n/**\n * TextMap class for Range Value\n * @class RangeMap\n */\nclass RangeMap {\n  data: gf.TRangeMapData;\n  constructor(from: string, to: string, text: string, data: gf.TRangeMapData) {\n    this.data = data;\n    this.data.from = from;\n    this.data.to = to;\n    this.data.text = text;\n    this.data.hidden = false;\n    // this.import(data);\n  }\n\n  /**\n   * import data from panel\n   *\n   * @param {*} obj\n   * @returns {this}\n   * @memberof RangeMap\n   */\n  import(obj: any): this {\n    this.data.from = !!obj.from ? obj.from : undefined;\n    this.data.to = !!obj.to ? obj.to : undefined;\n    this.data.text = !!obj.text ? obj.text : undefined;\n    this.data.hidden = !!obj.hidden || obj.hidden === false ? obj.hidden : false;\n    return this;\n  }\n\n  /**\n   * Get default data\n   *\n   * @static\n   * @returns {gf.TRangeMapData}\n   * @memberof RangeMap\n   */\n  static getDefaultData(): gf.TRangeMapData {\n    return {\n      from: undefined,\n      to: undefined,\n      text: undefined,\n      hidden: false,\n    };\n  }\n\n  /**\n   * Match value\n   *\n   * @param {*} value\n   * @returns {boolean}\n   * @memberof RangeMap\n   */\n  match(value: any): boolean {\n    if (\n      (value !== undefined && typeof value === 'string' && value.length > 0) ||\n      (value !== undefined && typeof value === 'number')\n    ) {\n      let v: number = Number(value);\n      if (\n        (this.data.from !== undefined && typeof value === 'string' && this.data.from.length > 0) ||\n        (this.data.from !== undefined && typeof value === 'number')\n      ) {\n        let from = Number(this.data.from);\n        if (v >= from) {\n          if (\n            (this.data.to !== undefined && typeof this.data.to === 'string' && this.data.to.length > 0) ||\n            (this.data.from !== undefined && typeof this.data.to === 'number')\n          ) {\n            let to = Number(this.data.to);\n            return v < to;\n          }\n          return true;\n        }\n        return false;\n      }\n      // from is empty here\n      if (\n        (this.data.to !== undefined && typeof this.data.to === 'string' && this.data.to.length > 0) ||\n        (this.data.to !== undefined && typeof this.data.to === 'number')\n      ) {\n        let to = Number(this.data.to);\n        return v < to;\n      }\n      // from and to is empty\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Return Formatted value\n   *\n   * @param {*} value\n   * @returns {(string | null)}\n   * @memberof RangeMap\n   */\n  getFormattedText(value: any): string | undefined {\n    if (this.match(value)) {\n      return this.data.text;\n    }\n    return value;\n  }\n\n  /**\n   * Show/enable range\n   *\n   * @memberof RangeMap\n   */\n  show() {\n    this.data.hidden = false;\n  }\n\n  /**\n   * Hide/disable range\n   *\n   * @memberof RangeMap\n   */\n  hide() {\n    this.data.hidden = true;\n  }\n\n  /**\n   * Is hidden\n   *\n   * @returns\n   * @memberof RangeMap\n   */\n  isHidden() {\n    return this.data.hidden;\n  }\n\n  /**\n   * is visible\n   *\n   * @returns\n   * @memberof RangeMap\n   */\n  toVisible() {\n    if (this.data.hidden) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Export current data\n   *\n   * @returns\n   * @memberof RangeMap\n   */\n  export() {\n    return {\n      from: this.data.from,\n      to: this.data.to,\n      text: this.data.text,\n      hidden: this.data.hidden,\n    };\n  }\n}\n\nclass ValueMap {\n  data: gf.TValueMapData;\n  constructor(value: string, text: string, data: gf.TValueMapData) {\n    this.data = data;\n    this.data.value = value;\n    this.data.text = text;\n    this.data.hidden = false;\n    this.import(data);\n  }\n\n  /**\n   * Get default data\n   *\n   * @static\n   * @returns\n   * @memberof ValueMap\n   */\n  static getDefaultdata() {\n    return {\n      value: undefined,\n      text: undefined,\n      hidden: false,\n    };\n  }\n\n  /**\n   * import data from panel\n   *\n   * @param {*} obj\n   * @returns {this}\n   * @memberof ValueMap\n   */\n  import(obj: any): this {\n    this.data.value = obj.value || this.data.value || undefined;\n    this.data.text = obj.text || this.data.text || undefined;\n    this.data.hidden = obj.hidden || this.data.hidden || false;\n    return this;\n  }\n\n  /**\n   * Match value with datas\n   *\n   * @param {any} value\n   * @returns {boolean}\n   * @memberof ValueMap\n   */\n  match(value: any): boolean {\n    if (value === null || value === undefined) {\n      if (this.data.value === 'null') {\n        return true;\n      }\n      return false;\n    }\n\n    if (!_.isString(value) && Number(this.data.value) === Number(value)) {\n      return true;\n    }\n    return $GF.utils.matchString(value.toString(), this.data.value);\n  }\n\n  /**\n   * Get formatted value\n   *\n   * @param {any} value\n   * @returns\n   * @memberof ValueMap\n   */\n  getFormattedText(value: any): string {\n    if (value === null || value === undefined) {\n      if (this.data.value === 'null' || this.data.value === 'undefined') {\n        return !!this.data.text ? this.data.text : '';\n      }\n    }\n    if (this.match(value)) {\n      return !!this.data.text ? this.data.text : '';\n    }\n    return `${value}`;\n  }\n\n  /**\n   * Show/enable valuemap\n   *\n   * @memberof ValueMap\n   */\n  show() {\n    this.data.hidden = false;\n  }\n\n  /**\n   * Hide/disable valuemap\n   *\n   * @memberof ValueMap\n   */\n  hide() {\n    this.data.hidden = true;\n  }\n\n  /**\n   * Is hidden/disable\n   *\n   * @returns\n   * @memberof ValueMap\n   */\n  isHidden() {\n    return this.data.hidden;\n  }\n\n  /**\n   * export data\n   *\n   * @returns\n   * @memberof ValueMap\n   */\n  export() {\n    return {\n      value: this.data.value,\n      text: this.data.text,\n      hidden: this.data.hidden,\n    };\n  }\n}\n","import { Rule } from 'rule_class';\nimport _ from 'lodash';\nimport { $GF } from 'globals_class';\n\n/**\n * Rules Handler\n *\n * @export\n * @class RulesHandler\n */\nexport class RulesHandler {\n  rules: Rule[];\n  data: gf.TIRulesHandlerData;\n  activeRuleIndex = 0;\n  /**\n   * Creates an instance of RulesHandler.\n   * @param {TIRulesHandlerData} data\n   * @memberof RulesHandler\n   */\n  constructor(data: gf.TIRulesHandlerData) {\n    $GF.log.info('RulesHandler.constructor()');\n    this.rules = [];\n    this.data = data;\n    // this.import(this.data);\n  }\n\n  /**\n   * import datas in rule from current or old version\n   *\n   * @return this\n   * @param {any} obj\n   * @memberof RulesHandler\n   */\n  import(obj: any): this {\n    $GF.log.info('RuleHandler.import()');\n    this.rules = [];\n    let index = 1;\n    if (obj !== undefined && obj !== null) {\n      // For version < 0.6.0\n      let tmpRules: gf.TIRuleData[];\n      if (Array.isArray(obj)) {\n        tmpRules = obj;\n      } else {\n        tmpRules = obj.rulesData;\n      }\n      // Fix bug of grafana 6+\n      if (tmpRules.length > 0 && tmpRules[0].order !== undefined) {\n        tmpRules = _.sortBy(_.sortBy(tmpRules, o => o.order));\n      }\n\n      tmpRules.forEach(ruleData => {\n        this.addRule('')\n          .import(ruleData)\n          .setOrder(index);\n        index += 1;\n      });\n    }\n    return this;\n  }\n\n  static getDefaultData(): gf.TIRulesHandlerData {\n    return {\n      rulesData: [],\n    };\n  }\n\n  /**\n   * Return array of rules\n   *\n   * @returns {Array} of Rules\n   * @memberof RulesHandler\n   */\n  getRules(): Rule[] {\n    return this.rules;\n  }\n\n  /**\n   * Get Rule at index\n   *\n   * @param {number} index\n   * @returns {Rule}\n   * @memberof RulesHandler\n   */\n  getRule(index: number): Rule {\n    return this.rules[index];\n  }\n\n  /**\n   * Add a new rule\n   *\n   * @param {string} pattern\n   * @returns {Rule} New rule\n   * @memberof RulesHandler\n   */\n  addRule(pattern: string): Rule {\n    const data = Rule.getDefaultData();\n    const newRule = new Rule(pattern, data);\n    this.rules.push(newRule);\n    this.data.rulesData.push(data);\n    newRule.setOrder(this.countRules());\n    return newRule;\n  }\n\n  /**\n   * count number of rules\n   *\n   * @returns {number}\n   * @memberof RulesHandler\n   */\n  countRules(): number {\n    if (this.rules !== undefined && Array.isArray(this.rules)) {\n      return this.rules.length;\n    }\n    return 0;\n  }\n\n  /**\n   * Redefine Order number of rules\n   *\n   * @memberof RulesHandler\n   */\n  setOrder(): this {\n    const lg = this.rules.length;\n    for (let index = 0; index < lg; index++) {\n      const rule = this.rules[index];\n      rule.setOrder(index + 1);\n    }\n    return this;\n  }\n\n  /**\n   * Remove rule at index\n   *\n   * @param {number} index\n   * @memberof RulesHandler\n   */\n  removeRule(rule: Rule) {\n    const index = rule.getOrder() - 1;\n    this.rules.splice(index, 1);\n    this.data.rulesData.splice(index, 1);\n    this.setOrder();\n  }\n\n  /**\n   * Clone rules at index in index - 1\n   *\n   * @param {number} index\n   * @returns {Rule}\n   * @memberof RulesHandler\n   */\n  cloneRule(rule: Rule): Rule {\n    const index = rule.getOrder() - 1;\n    const data = rule.getData();\n    const newData: gf.TIRuleData = Rule.getDefaultData();\n    this.reduce();\n    const newRule = new Rule(newData.pattern, newData);\n    newRule.import(data);\n    newData.alias = `Copy of ${newData.alias}`;\n    this.rules.splice(index, 0, newRule);\n    this.data.rulesData.splice(index, 0, newData);\n    newRule.data.reduce = false;\n    this.activeRuleIndex = index;\n    this.setOrder();\n    const elt = document.getElementById(newRule.getId());\n    //TODO: verify ScrollTo\n    if (elt) {\n      setTimeout(() => {\n        elt.focus();\n      }, 100);\n    }\n    return newRule;\n  }\n\n  /**\n   * Reduce all rules\n   *\n   * @memberof RulesHandler\n   */\n  reduce(): this {\n    this.getRules().forEach(rule => {\n      rule.data.reduce = true;\n    });\n    return this;\n  }\n\n  /**\n   * Move rule on index in index - 1\n   *\n   * @param {rule} rule\n   * @memberof RulesHandler\n   */\n  moveRuleToUp(rule: Rule) {\n    const index = rule.getOrder() - 1;\n    const first = 0;\n    const rules = this.rules;\n    const last = rules.length - 1;\n    if (index !== first && last !== first) {\n      const curr = rules[index];\n      curr.setOrder(index);\n      const before = rules[index - 1];\n      before.setOrder(index + 1);\n      rules[index - 1] = curr;\n      rules[index] = before;\n    }\n  }\n\n  /**\n   * Move rule on index in index + 1\n   *\n   * @param {Rule} rule\n   * @memberof RulesHandler\n   */\n  moveRuleToDown(rule: Rule) {\n    const index = rule.getOrder() - 1;\n    const first = 0;\n    const rules = this.rules;\n    const last = rules.length - 1;\n    if (index !== last && last !== first) {\n      const curr = rules[index];\n      curr.setOrder(index + 2);\n      const after = rules[index + 1];\n      after.setOrder(index + 1);\n      rules[index + 1] = curr;\n      rules[index] = after;\n    }\n  }\n}\n","import XGraph from './graph_class';\nimport { Rule, EventMap } from './rule_class';\nimport { Metric } from './metric_class';\nimport { TooltipHandler } from './tooltipHandler';\nimport { $GF, GFVariables } from 'globals_class';\n\n/**\n * Class for state of one cell\n *\n * @export\n * @class State\n */\nexport class State {\n  mxcell: mxCell; // mxCell State\n  cellId: string; // cell ID in mxcell\n  newcellId: string | undefined; // for inspect mode\n  previousId: string | undefined; // for inspect mode\n  edited: boolean | undefined; // if modified in inspector\n  edit: boolean | undefined; // if modified in inspector\n  xgraph: XGraph;\n  changed = false;\n  matched = false;\n  shapeState: ShapeState;\n  tooltipState: TooltipState;\n  iconState: IconState;\n  eventState: EventState;\n  textState: TextState;\n  linkState: LinkState;\n  variables: GFVariables;\n  status: Map<string, any>;\n  globalLevel = -1;\n  tooltipHandler: TooltipHandler | null = null;\n  originalText: string;\n\n  /**\n   * Creates an instance of State.\n   * @param {mxCell} mxcell\n   * @param {XGraph} xgraph\n   * @memberof State\n   */\n  constructor(mxcell: mxCell, xgraph: XGraph) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'constructor()');\n    this.mxcell = mxcell;\n    this.cellId = mxcell.id;\n    this.xgraph = xgraph;\n    this.shapeState = new ShapeState(xgraph, mxcell);\n    this.tooltipState = new TooltipState(xgraph, mxcell);\n    this.iconState = new IconState(xgraph, mxcell);\n    this.eventState = new EventState(xgraph, mxcell);\n    this.textState = new TextState(xgraph, mxcell);\n    this.linkState = new LinkState(xgraph, mxcell);\n    this.variables = $GF.createLocalVars();\n    this.status = new Map();\n    this.tooltipHandler = null;\n    this.mxcell.GF_tooltipHandler = null;\n    this.originalText = this.xgraph.getLabelCell(mxcell);\n    trc.after();\n  }\n\n  /**\n   * Call applyState() asynchronously\n   *\n   * @memberof State\n   */\n  async async_applyState() {\n    // new Promise (this.applyState.bind(this));\n    this.applyState();\n  }\n\n  /**\n   * Define state according to 1 rule and 1 serie without apply display\n   *\n   * @returns {this}\n   * @param {Rule} rule\n   * @param {Metric} metric\n   * @memberof State\n   */\n  setState(rule: Rule, metric: Metric): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'setState()');\n    if (!rule.isHidden() && rule.matchMetric(metric)) {\n      let beginPerf = Date.now();\n      const shapeMaps = rule.getShapeMaps();\n      const textMaps = rule.getTextMaps();\n      const linkMaps = rule.getLinkMaps();\n      const eventMaps = rule.getEventMaps();\n      const value = rule.getValueForMetric(metric);\n      const FormattedValue = rule.getFormattedValue(value);\n      const level = rule.getThresholdLevel(value);\n      const color =\n        rule.data.gradient && rule.data.type === 'number' ? rule.getColorForValue(value) : rule.getColorForLevel(level);\n      this.variables.set($GF.CONSTANTS.VAR_STR_RULENAME, rule.data.alias);\n      this.variables.set($GF.CONSTANTS.VAR_NUM_VALUE, value);\n      this.variables.set($GF.CONSTANTS.VAR_STR_FORMATED, FormattedValue);\n      this.variables.set($GF.CONSTANTS.VAR_NUM_LEVEL, level);\n      this.variables.set($GF.CONSTANTS.VAR_STR_COLOR, color);\n\n      // SHAPE\n      let cellProp = this.getCellProp(rule.data.shapeProp);\n      shapeMaps.forEach(shape => {\n        let k = shape.data.style;\n        if (!shape.isHidden() && shape.match(cellProp, rule.data.shapeRegEx)) {\n          let v: any = color;\n          this.matched = true;\n          this.globalLevel = level > this.globalLevel ? level : this.globalLevel;\n          if (shape.toColorize(level)) {\n            this.shapeState.set(k, v, level) && this.status.set(k, v);\n          }\n          // TOOLTIP\n          if (rule.toTooltipize(level)) {\n            k = 'tooltip';\n            v = true;\n            this.tooltipState.set('tooltip', true, level) && this.status.set(k, v);\n            this.tooltipState.setTooltip(rule, metric, color, FormattedValue);\n          }\n          // ICONS\n          if (rule.toIconize(level)) {\n            k = 'icon';\n            v = true;\n            this.iconState.set('icon', true, level) && this.status.set(k, v);\n          }\n        }\n      });\n\n      // TEXT\n      cellProp = this.getCellProp(rule.data.textProp);\n      textMaps.forEach(text => {\n        const k = 'label';\n        if (!text.isHidden() && text.match(cellProp, rule.data.textRegEx) && text.toLabelize(level)) {\n          if (text.toLabelize(level)) {\n            this.matched = true;\n            this.globalLevel = level > this.globalLevel ? level : this.globalLevel;\n            const textScoped = this.variables.replaceText(FormattedValue);\n            const v = text.getReplaceText(this.textState.getMatchValue(k), textScoped);\n            this.textState.set(k, v, level) && this.status.set(k, v);\n          }\n        }\n      });\n\n      // EVENTS\n      cellProp = this.getCellProp(rule.data.eventProp);\n      eventMaps.forEach(event => {\n        const k = event.data.style;\n        if (!event.isHidden() && event.match(cellProp, rule.data.eventRegEx) && event.toEventable(level)) {\n          if (event.toEventable(level)) {\n            this.matched = true;\n            this.globalLevel = level > this.globalLevel ? level : this.globalLevel;\n            const v = this.variables.eval(event.data.value);\n            this.eventState.set(k, v, level) && this.status.set(k, v);\n          }\n        }\n      });\n\n      // LINK\n      cellProp = this.getCellProp(rule.data.linkProp);\n      linkMaps.forEach(link => {\n        const k = 'link';\n        if (!link.isHidden() && link.match(cellProp, rule.data.linkRegEx)) {\n          if (link.toLinkable(level)) {\n            this.matched = true;\n            this.globalLevel = level > this.globalLevel ? level : this.globalLevel;\n            const v = this.variables.replaceText(link.getLink());\n            this.linkState.set(k, v, level) && this.status.set(k, v);\n          }\n        }\n      });\n\n      if (level >= rule.highestLevel && this.matched) {\n        rule.highestLevel = level;\n        rule.highestValue = value;\n        rule.highestFormattedValue = FormattedValue;\n        rule.highestColor = color;\n      }\n      let endPerf = Date.now();\n      rule.execTimes += endPerf - beginPerf;\n    }\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Restore initial status of state without apply display.\n   * Use applyState() to apply on graph (color, level and text)\n   *\n   * @returns {this}\n   * @memberof State\n   */\n  unsetState(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'unsetState()');\n    this.eventState.unset();\n    this.textState.unset();\n    this.linkState.unset();\n    this.tooltipState.unset();\n    this.iconState.unset();\n    this.matched = false;\n    trc.after();\n    return this;\n  }\n\n  /**\n   *\n   *\n   * @param {string} prop - id|value\n   * @returns {string|null} return original value of id or label of cell\n   * @memberof State\n   */\n  getCellProp(prop: gf.TPropertieKey): string | null {\n    if (prop === 'id') {\n      return this.cellId;\n    }\n    if (prop === 'value') {\n      return this.originalText;\n    }\n    return null;\n  }\n\n  /**\n   * Get the highest/global level\n   *\n   * @returns {number}\n   * @memberof State\n   */\n  getLevel(): number {\n    return this.globalLevel;\n  }\n\n  /**\n   * Get Level in text\n   *\n   * @returns {number}\n   * @memberof State\n   */\n  getTextLevel(): string {\n    return this.globalLevel === -1 ? '' : this.globalLevel.toString();\n  }\n\n  getStatus(key: string): string {\n    let style: string | null | undefined = this.status.get(key);\n    if (style !== undefined && style !== null) {\n      return style;\n    }\n    style = this.xgraph.getStyleCell(this.mxcell, key);\n    if (style === null) {\n      style = '';\n    }\n    this.status.set(key, style);\n    return style;\n  }\n\n  haveStatus(key: string): boolean {\n    return this.status.has(key);\n  }\n\n  /**\n   * Return true if is a shape/vertex\n   *\n   * @returns\n   * @memberof State\n   */\n  isShape(): boolean {\n    return this.mxcell.isVertex();\n  }\n\n  /**\n   * Return true if is a arrow/connector\n   *\n   * @returns\n   * @memberof State\n   */\n  isConnector(): boolean {\n    return this.mxcell.isEdge();\n  }\n\n  /**\n   * Apply new state\n   *\n   * @returns {this}\n   * @memberof State\n   */\n  applyState(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'applyState()');\n    if (this.matched || this.changed) {\n      this.changed = true;\n      this.shapeState.apply();\n      this.tooltipState.apply();\n      this.iconState.apply();\n      this.textState.apply();\n      this.eventState.apply();\n      this.linkState.apply();\n    }\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Reset and restore state\n   *\n   * @returns {this}\n   * @memberof State\n   */\n  reset(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'reset()');\n    this.shapeState.reset();\n    this.tooltipState.reset();\n    this.iconState.reset();\n    this.textState.reset();\n    this.eventState.reset();\n    this.linkState.reset();\n    this.variables.clear();\n    this.status.clear();\n    this.globalLevel = -1;\n    this.changed = false;\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Prepare state for a new rule and serie\n   *\n   * @returns {this}\n   * @memberof State\n   */\n  prepare(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'prepare()');\n    if (this.changed) {\n      this.shapeState.prepare();\n      this.tooltipState.prepare();\n      this.iconState.prepare();\n      this.textState.prepare();\n      this.eventState.prepare();\n      this.linkState.prepare();\n      this.variables.clear();\n      this.status.clear();\n      this.globalLevel = -1;\n      this.matched = false;\n    }\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Highlight mxcell\n   *\n   * @returns {this}\n   * @memberof State\n   */\n  highlightCell(): this {\n    this.xgraph.highlightCell(this.mxcell);\n    return this;\n  }\n\n  /**\n   * Unhighlight mxcell\n   *\n   * @returns {this}\n   * @memberof State\n   */\n  unhighlightCell(): this {\n    this.xgraph.unhighlightCell(this.mxcell);\n    return this;\n  }\n}\n\n/**\n * Mother of sub states\n *\n * @class GFState\n */\nexport class GFState {\n  xgraph: XGraph;\n  mxcell: mxCell;\n  keys: string[] = [];\n  matchedKey: Map<string, boolean> = new Map();\n  changedKey: Map<string, boolean> = new Map();\n  originalValue: Map<string, any> = new Map();\n  matchValue: Map<string, any> = new Map();\n  static DEFAULTLEVEL: number = -1;\n  // lastValue: Map<string, any> = new Map(); To not apply the same value\n  matchLevel: Map<string, number> = new Map();\n\n  constructor(xgraph: XGraph, mxcell: mxCell) {\n    this.xgraph = xgraph;\n    this.mxcell = mxcell;\n    this.init_core();\n  }\n\n  init_core() {}\n\n  addValue(key: string, value: any) {\n    if (!this.hasKey(key)) {\n      // _GF.log.warn('GFState.addValue()', key, 'not found');\n      this.keys.push(key);\n    }\n    this.originalValue.set(key, value);\n    this.matchValue.set(key, value);\n    // this.lastValue.set(key, value); To not apply the same value\n    this.matchLevel.set(key, GFState.DEFAULTLEVEL);\n    this.matchedKey.set(key, false);\n    this.changedKey.set(key, false);\n  }\n\n  hasKey(key: string): boolean {\n    return this.keys.includes(key);\n  }\n\n  getOriginalValue(key: string): any | undefined {\n    if (!this.hasKey(key)) {\n      this.originalValue.set(key, this.default_core(key));\n    }\n    return this.originalValue.get(key);\n  }\n\n  getMatchValue(key: string): any | undefined {\n    if (!this.hasKey(key)) {\n      this.matchValue.set(key, this.getOriginalValue(key));\n    }\n    return this.matchValue.get(key);\n  }\n\n  /**\n   * Insert key and value if >= level\n   *\n   * @param {string} key\n   * @param {*} value\n   * @param {number} level\n   * @returns {boolean} true if applied\n   * @memberof GFState\n   */\n  set(key: string, value: any, level: number): boolean {\n    let matchLevel = this.matchLevel.get(key);\n    if (matchLevel === undefined) {\n      const defaultValue = this.default_core(key);\n      this.addValue(key, defaultValue);\n      return this.set(key, value, level);\n    }\n    if (matchLevel <= level) {\n      this.matchLevel.set(key, level);\n      this.matchedKey.set(key, true);\n      this.matchValue.set(key, value);\n      return true;\n    }\n    return false;\n  }\n\n  apply(key?: string): this {\n    if (key !== undefined) {\n      if (this.isMatched(key)) {\n        let value = this.getMatchValue(key);\n        try {\n          this.apply_core(key, value);\n        } catch (error) {\n          $GF.log.error('Error on reset for key ' + key, error);\n        }\n        this.changedKey.set(key, true);\n        this.matchedKey.set(key, false);\n      } else if (this.isChanged(key)) {\n        this.reset(key);\n      }\n    } else {\n      this.keys.forEach(key => {\n        this.apply(key);\n      });\n    }\n    return this;\n  }\n\n  default_core(key: any): any {\n    return null;\n  }\n\n  apply_core(key: any, value: any) {}\n\n  isMatched(key?: string): boolean {\n    if (key !== undefined) {\n      return this.matchedKey.get(key) === true;\n    }\n    let matched = false;\n    this.keys.forEach(key => {\n      matched = this.isMatched(key) || matched;\n    });\n    return matched;\n  }\n\n  isChanged(key?: string): boolean {\n    if (key !== undefined) {\n      return this.changedKey.get(key) === true;\n    }\n    let changed = false;\n    this.keys.forEach(key => {\n      changed = this.isChanged(key) ? true : changed;\n    });\n    return changed;\n  }\n\n  getLevel(key?: string): number {\n    if (key !== undefined) {\n      let level = this.matchLevel.get(key);\n      return level !== undefined ? level : GFState.DEFAULTLEVEL;\n    }\n    let level = GFState.DEFAULTLEVEL;\n    this.keys.forEach(key => (level = Math.max(this.getLevel(key))));\n    return level;\n  }\n\n  unset(key?: string): this {\n    if (key !== undefined) {\n      this.matchValue.set(key, this.originalValue.get(key));\n      this.matchedKey.set(key, false);\n      this.matchLevel.set(key, -1);\n    } else {\n      this.keys.forEach(key => {\n        this.unset(key);\n      });\n    }\n    return this;\n  }\n\n  reset(key?: string): this {\n    if (key !== undefined) {\n      this.unset(key);\n      let value = this.getOriginalValue(key);\n      try {\n        this.reset_core(key, value);\n      } catch (error) {\n        $GF.log.error('Error on reset for key ' + key, error);\n      }\n      this.changedKey.set(key, false);\n      this.matchedKey.set(key, false);\n    } else {\n      this.keys.forEach(key => {\n        this.reset(key);\n      });\n    }\n    return this;\n  }\n\n  reset_core(key: any, value: any) {}\n\n  prepare(): this {\n    if (this.isChanged()) {\n      this.unset();\n    }\n    return this;\n  }\n}\n\n/**\n * Event SubState\n *\n * @class EventState\n * @extends {GFState}\n */\nclass EventState extends GFState {\n  keys: gf.TStyleEventKeys[] = [];\n  geo:\n    | {\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n      }\n    | undefined = undefined;\n  constructor(xgraph: XGraph, mxcell: mxCell) {\n    super(xgraph, mxcell);\n    this.init_core();\n  }\n\n  init_core() {\n    // this.keys = $GF.CONSTANTS.EVENTMETHODS.map(x => x.value);\n    this.geo = this.xgraph.getSizeCell(this.mxcell);\n    // this.keys.forEach(key => {\n    //   const value = this._get(key);\n    //   this.addValue(key, value);\n    // });\n  }\n\n  default_core(key: gf.TStyleEventKeys): any {\n    return this._get(key);\n  }\n\n  async apply_core(key: gf.TStyleEventKeys, value: any) {\n    if (value === undefined) {\n      value = null;\n    }\n    this._set(key, value);\n  }\n\n  async reset_core(key: gf.TStyleEventKeys, value: any) {\n    if (value === undefined) {\n      value = null;\n    }\n    this._set(key, value);\n  }\n\n  _set(key: gf.TStyleEventKeys, value: any) {\n    if (value === undefined) {\n      value = null;\n    }\n    let beginValue: any = undefined;\n    const toUnset: boolean = this.isChanged(key) && !this.isMatched(key);\n    let className = '';\n    let newkey: gf.TStyleEventKeys | 'class' = key;\n    if (key.startsWith('class_')) {\n      newkey = 'class';\n      className = key.substring(6);\n    }\n    switch (newkey) {\n      case 'class':\n        if (toUnset) {\n          this.xgraph.unsetClassCell(this.mxcell, className);\n        } else {\n          this.xgraph.setClassCell(this.mxcell, className);\n        }\n        break;\n      case 'text':\n        value = String(value);\n        this.xgraph.setLabelCell(this.mxcell, value);\n        break;\n\n      case 'visibility':\n        value = String(value);\n        if (value === '0') {\n          this.xgraph.hideCell(this.mxcell);\n        } else if (value === '1') {\n          this.xgraph.showCell(this.mxcell);\n        }\n        break;\n\n      case 'fold':\n        value = String(value);\n        if (value === '0') {\n          this.xgraph.collapseCell(this.mxcell);\n        } else if (value === '1') {\n          this.xgraph.expandCell(this.mxcell);\n        }\n        break;\n\n      case 'height':\n        if (this.geo !== undefined) {\n          let height = Number(value);\n          if (this.isMatched('height')) {\n            let width = this.isMatched('width') ? Number(this.getMatchValue('width')) : undefined;\n            this.xgraph.changeSizeCell(this.mxcell, width, height, this.geo);\n            this.unset('width');\n          } else {\n            if (!this.isMatched('width')) {\n              this.xgraph.resetSizeCell(this.mxcell, this.geo);\n              this.unset('width');\n            }\n          }\n        }\n        break;\n\n      case 'width':\n        if (this.geo !== undefined) {\n          let width = Number(value);\n          if (this.isMatched('width')) {\n            let height = this.isMatched('height') ? Number(this.getMatchValue('height')) : undefined;\n            this.xgraph.changeSizeCell(this.mxcell, width, height, this.geo);\n            this.unset('width');\n          } else {\n            if (!this.isMatched('height')) {\n              this.xgraph.resetSizeCell(this.mxcell, this.geo);\n              this.unset('height');\n            }\n          }\n        }\n        break;\n\n      case 'size':\n        if (this.geo !== undefined) {\n          let percent = Number(value);\n          this.xgraph.resizeCell(this.mxcell, percent, this.geo);\n        }\n        break;\n\n      case 'barPos':\n      case 'fontSize':\n      case 'opacity':\n      case 'textOpacity':\n      case 'rotation':\n        beginValue = this._get(key);\n        beginValue = beginValue === undefined ? EventMap.getDefaultValue(key) : beginValue;\n        this.xgraph.setStyleAnimCell(this.mxcell, key, value, beginValue);\n        break;\n\n      case 'blink':\n        if (!!value) {\n          this.xgraph.blinkCell(this.mxcell, value);\n        } else {\n          this.xgraph.unblinkCell(this.mxcell);\n        }\n        break;\n\n      default:\n        this.xgraph.setStyleCell(this.mxcell, key, value);\n        break;\n    }\n  }\n\n  _get(key: gf.TStyleEventKeys): any {\n    switch (key) {\n      case 'text':\n        return this.xgraph.getLabelCell(this.mxcell);\n        break;\n\n      case 'visibility':\n        return this.xgraph.isVisibleCell(this.mxcell) === false ? '0' : '1';\n        break;\n\n      case 'height':\n        return this.geo !== undefined ? this.geo.height : undefined;\n        break;\n\n      case 'width':\n        return this.geo !== undefined ? this.geo.width : undefined;\n        break;\n\n      case 'size':\n        return 100;\n        break;\n\n      case 'fold':\n        return this.xgraph.isCollapsedCell(this.mxcell) === true ? '0' : '1';\n        break;\n\n      case 'blink':\n        return this.xgraph.geBlinkMxCell(this.mxcell);\n        break;\n\n      default:\n        return this.xgraph.getStyleCell(this.mxcell, key);\n        break;\n    }\n  }\n}\n\nclass TextState extends GFState {\n  // keys: string[] = ['label'];\n  keys: string[] = [];\n  constructor(xgraph: XGraph, mxcell: mxCell) {\n    super(xgraph, mxcell);\n    this.init_core();\n  }\n\n  init_core() {\n    // const value = this.xgraph.getLabelCell(this.mxcell);\n    // this.addValue('label', value);\n  }\n\n  default_core(key: any): string | null {\n    return this.xgraph.getLabelCell(this.mxcell);\n  }\n\n  async apply_core(key: string, value: any) {\n    this.xgraph.setLabelCell(this.mxcell, value);\n  }\n\n  async reset_core(key: string, value: any) {\n    this.xgraph.setLabelCell(this.mxcell, value);\n  }\n}\n\nclass LinkState extends GFState {\n  // keys: string[] = ['link'];\n  keys: string[] = [];\n  constructor(xgraph: XGraph, mxcell: mxCell) {\n    super(xgraph, mxcell);\n    this.init_core();\n  }\n\n  init_core() {\n    // const value = this.xgraph.getLink(this.mxcell);\n    // this.addValue('link', value);\n  }\n\n  default_core(key: any): string | null {\n    return this.xgraph.getLink(this.mxcell);\n  }\n\n  async apply_core(key: string, value: any) {\n    this.xgraph.addLink(this.mxcell, value);\n  }\n\n  async reset_core(key: string, value: any) {\n    if (value === undefined || value === null || value.length === 0) {\n      this.xgraph.removeLink(this.mxcell);\n    } else {\n      this.xgraph.addLink(this.mxcell, value);\n    }\n  }\n}\n\n/**\n * State for shape color\n *\n * @class ShapeState\n * @extends {GFState}\n */\nclass ShapeState extends GFState {\n  keys: gf.TStyleColorKeys[] = [];\n  fullStylesString: string | undefined;\n  constructor(xgraph: XGraph, mxcell: mxCell) {\n    super(xgraph, mxcell);\n    this.init_core();\n  }\n\n  init_core() {\n    // this.keys = $GF.CONSTANTS.COLORMETHODS.map(x => x.value);\n    // this.fullStylesString = this.mxcell.getStyle();\n    // this.keys.forEach(key => {\n    //   const value = this.xgraph.getStyleCell(this.mxcell, key);\n    //   this.addValue(key, value);\n    //   $GF.log.debug('ShapeState [' + this.mxcell.id + '] Add value : ' + key, value);\n    // });\n    this.mxcell.GF_tooltipHandler = null;\n  }\n\n  default_core(key: any): string | null {\n    return this.xgraph.getStyleCell(this.mxcell, key);\n  }\n\n  async apply_core(key: gf.TStyleColorKeys, value: any) {\n    if (value === undefined) {\n      value = null;\n    }\n    this.xgraph.setColorAnimCell(this.mxcell, key, value);\n  }\n\n  async reset_core(key: gf.TStyleColorKeys, value: any) {\n    if (value === undefined) {\n      value = null;\n    }\n    this.xgraph.setColorAnimCell(this.mxcell, key, value);\n  }\n}\n\nclass TooltipState extends GFState {\n  keys: string[] = ['tooltip'];\n  tooltipHandler: TooltipHandler | undefined;\n  constructor(xgraph: XGraph, mxcell: mxCell) {\n    super(xgraph, mxcell);\n    this.init_core();\n  }\n\n  init_core() {\n    this.addValue('tooltip', false);\n    this.tooltipHandler = undefined;\n    this.mxcell.GF_tooltipHandler = null;\n  }\n\n  async setTooltip(rule: Rule, metric: Metric, color: string, value: string) {\n    let tpColor: string | null = null;\n    let label: string = rule.data.tooltipLabel;\n    if (this.tooltipHandler === null || this.tooltipHandler === undefined) {\n      this.tooltipHandler = new TooltipHandler(this.mxcell);\n    }\n    if (label === null || label.length === 0) {\n      if (rule.data.metricType === 'serie') {\n        label = metric.getName();\n      }\n      if (rule.data.metricType === 'table') {\n        label = rule.data.column;\n      }\n    }\n    if (rule.data.tooltipColors) {\n      tpColor = color;\n    }\n    // METRIC\n    const metricToolip = this.tooltipHandler\n      .addMetric()\n      .setLabel(label)\n      .setValue(value)\n      .setColor(tpColor)\n      .setDirection(rule.data.tpDirection);\n    // GRAPH\n    if (rule.data.tpGraph) {\n      const graph = metricToolip.addGraph(rule.data.tpGraphType);\n      graph\n        .setColor(tpColor)\n        .setColumn(rule.data.column)\n        .setMetric(metric)\n        .setSize(rule.data.tpGraphSize)\n        .setScaling(rule.data.tpGraphLow, rule.data.tpGraphHigh)\n        .setScale(rule.data.tpGraphScale);\n    }\n    // Date\n    this.tooltipHandler.updateDate();\n  }\n\n  apply(key?: string): this {\n    if (key !== undefined && key === 'tooltip') {\n      if (this.isMatched(key) && this.getMatchValue(key) === true) {\n        if (this.tooltipHandler != null && this.tooltipHandler.isChecked()) {\n          this.mxcell.GF_tooltipHandler = this.tooltipHandler;\n        }\n        super.apply(key);\n      }\n    } else {\n      this.keys.forEach(key => {\n        this.apply(key);\n      });\n    }\n    return this;\n  }\n\n  prepare(): this {\n    super.prepare();\n    this.reset();\n    return this;\n  }\n\n  reset(key?: string): this {\n    if (key !== undefined && key === 'tooltip') {\n      this.mxcell.GF_tooltipHandler = null;\n      if (this.tooltipHandler) {\n        this.tooltipHandler.destroy();\n      }\n      this.tooltipHandler = undefined;\n      super.reset(key);\n    } else {\n      this.keys.forEach(key => {\n        this.reset(key);\n      });\n    }\n    return this;\n  }\n}\n\nclass IconState extends GFState {\n  // keys: string[] = ['icon'];\n  keys: string[] = [];\n  constructor(xgraph: XGraph, mxcell: mxCell) {\n    super(xgraph, mxcell);\n    this.init();\n  }\n\n  init() {\n    // this.addValue('icon', false);\n  }\n\n  default_core(key: string): any {\n    return false;\n  }\n\n  apply_core(key?: string): this {\n    if (key !== undefined && key === 'icon') {\n      if (this.isMatched(key) && this.getMatchValue(key) === true) {\n        if (!this.isChanged(key)) {\n          this.xgraph.addOverlay(`WARNING/ERROR`, this.mxcell);\n        }\n        // super.apply(key);\n      } else if (this.isChanged(key)) {\n        this.reset_core(key);\n      }\n    } else {\n      this.keys.forEach(key => {\n        this.apply_core(key);\n      });\n    }\n    return this;\n  }\n\n  reset_core(key?: string): this {\n    if (key !== undefined && key === 'icon') {\n      this.xgraph.removeOverlay(this.mxcell);\n      // super.reset(key);\n    } else {\n      this.keys.forEach(key => {\n        this.reset_core(key);\n      });\n    }\n    return this;\n  }\n}\n","import { State } from './state_class';\nimport { Rule } from './rule_class';\nimport _ from 'lodash';\nimport { Metric } from './metric_class';\nimport XGraph from 'graph_class';\nimport { $GF } from 'globals_class';\n\n/**\n * States Handler class\n *\n * @export\n * @class StateHandler\n */\nexport class StateHandler {\n  states: Map<string, State>;\n  xgraph: XGraph;\n  edited = false;\n  /**\n   * Creates an instance of StateHandler.\n   * @param {XGraph} xgraph\n   * @memberof StateHandler\n   */\n  constructor(xgraph: XGraph) {\n    this.states = new Map();\n    this.xgraph = xgraph;\n    this.initStates(this.xgraph);\n  }\n\n  /**\n   * Initialisation of states\n   *\n   * @returns {this}\n   * @param {XGraph} xgraph\n   * @memberof StateHandler\n   */\n  initStates(xgraph: XGraph): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'initStates()');\n    this.xgraph = xgraph;\n    this.states.clear();\n    const mxcells = xgraph.getMxCells();\n    _.each(mxcells, mxcell => {\n      this.addState(mxcell);\n    });\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Return states array for a rule\n   *\n   * @param {Rule} rule - rule mapping\n   * @returns {Array<State>}\n   * @memberof StateHandler\n   */\n  getStatesForRule(rule: Rule) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'getStatesForRule()');\n    const result = new Map();\n    let name: string | null;\n    const xgraph = this.xgraph;\n    this.states.forEach(state => {\n      const mxcell: mxCell = state.mxcell;\n      const id: string = mxcell.id;\n      let found = false;\n\n      // SHAPES\n      name = xgraph.getValuePropOfMxCell(rule.data.shapeProp, mxcell);\n      if (name !== null && rule.matchShape(name)) {\n        result.set(id, state);\n        found = true;\n      }\n\n      // TEXTS\n      if (!found) {\n        name = xgraph.getValuePropOfMxCell(rule.data.textProp, mxcell);\n        if (rule.matchText(name)) {\n          result.set(id, state);\n          found = true;\n        }\n      }\n\n      // LINKS\n      if (!found) {\n        name = xgraph.getValuePropOfMxCell(rule.data.linkProp, mxcell);\n        if (rule.matchLink(name)) {\n          result.set(id, state);\n          found = true;\n        }\n      }\n\n      // EVENTS\n      if (!found) {\n        name = xgraph.getValuePropOfMxCell(rule.data.eventProp, mxcell);\n        if (rule.matchEvent(name)) {\n          result.set(id, state);\n          found = true;\n        }\n      }\n    });\n    trc.after();\n    return result;\n  }\n\n  /**\n   * Update States : Add or remove state in states when rules changed\n   *\n   * @param {XGraph} xgraph\n   * @param {Array<Rule>} rules\n   * @memberof StateHandler\n   */\n  updateStates(rules: Rule[]) {\n    $GF.log.info('StateHandler.updateStates()');\n    rules.forEach(rule => {\n      rule.states = this.getStatesForRule(rule);\n    });\n  }\n\n  /**\n   * Return array of state\n   *\n   * @returns Map<States>\n   * @memberof StateHandler\n   */\n  getStates() {\n    return this.states;\n  }\n\n  /**\n   * get array states\n   *\n   * @returns {State[]}\n   * @memberof StateHandler\n   */\n  getStatesForInspect(): State[] {\n    const states: State[] = [];\n    this.states.forEach(state => {\n      states.push(state);\n    });\n    return states;\n  }\n\n  /**\n   * Find state by Id\n   * @param  {string} cellId - Id of cell\n   * @returns {state}\n   */\n  getState(cellId: string): State | undefined {\n    return this.states.get(cellId);\n  }\n\n  /**\n   * Add a state\n   *\n   * @param {mxCell} mxcell\n   * @returns {State} created state\n   * @memberof StateHandler\n   */\n  addState(mxcell: mxCell): State {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'addState()');\n    const state = new State(mxcell, this.xgraph);\n    this.states.set(mxcell.id, state);\n    if ($GF.DEBUG) {\n      $GF.setVar(`STATE_${state.cellId}`, state);\n    }\n    trc.after();\n    return state;\n  }\n\n  /**\n   * Count number of state\n   *\n   * @returns {Number}\n   * @memberof StateHandler\n   */\n  countStates(): number {\n    return this.states.size;\n  }\n\n  /**\n   * Restore initial status and prepare states object\n   */\n  prepare(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'prepare()');\n    this.states.forEach(state => {\n      state.prepare();\n    });\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Change states according to rules and datas from grafana\n   * @param  {Array<Rule>} rules - Array of Rule object\n   * @param  {Array<Metric>} metrics - Array of serie object\n   */\n  setStates(rules: Rule[], metrics: Metric[]): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'setStates()');\n    this.prepare();\n    rules.forEach(rule => {\n      rule.highestLevel = -1;\n      rule.highestFormattedValue = '';\n      rule.highestColor = '';\n      rule.highestValue = '';\n      rule.execTimes = 0;\n      if (rule.states === undefined || rule.states.size === 0) {\n        rule.states = this.getStatesForRule(rule);\n      }\n      rule.states.forEach(state => {\n        metrics.forEach(metric => {\n          state.setState(rule, metric);\n        });\n      });\n    });\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Apply color and text\n   */\n  applyStates(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'applyStates()');\n    this.states.forEach(state => {\n      state.async_applyState();\n    });\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Call applyStates asynchronously\n   *\n   * @memberof StateHandler\n   */\n  async async_applyStates() {\n    this.applyStates();\n  }\n}\n","import Chartist from 'chartist';\n// import ctAreaGradient from 'chartist-plugin-gradient';\nimport { Metric } from './metric_class';\nimport { $GF } from 'globals_class';\n\n/**\n *\n *\n * @export\n * @class TooltipHandler\n */\nexport class TooltipHandler {\n  timeFormat = 'YYYY-MM-DD HH:mm:ss';\n  mxcell: mxCell;\n  checked = false;\n  metrics: Set<MetricTooltip>;\n  lastChange: string | undefined;\n  div: HTMLHeadingElement | null = null;\n  constructor(mxcell: any) {\n    this.mxcell = mxcell;\n    this.checked = false;\n    this.metrics = new Set();\n  }\n\n  /**\n   * Return if tooltip is available\n   *\n   * @returns {boolean}\n   * @memberof TooltipHandler\n   */\n  isChecked(): boolean {\n    return this.checked;\n  }\n\n  /**\n   * Add a metric (one value) for tooltip\n   * @returns {MetricTooltip}\n   * @memberof TooltipHandler\n   */\n  addMetric(): MetricTooltip {\n    this.checked = true;\n    const metric = new MetricTooltip();\n    this.metrics.add(metric);\n    return metric;\n  }\n\n  /**\n   * Update date in tooltip\n   *\n   * @memberof TooltipHandler\n   */\n  updateDate() {\n    const currentDateTime = new Date();\n    this.lastChange =\n      currentDateTime.getFullYear() +\n      '-' +\n      (currentDateTime.getMonth() + 1).toLocaleString('en-US', {\n        minimumIntegerDigits: 2,\n        useGrouping: false,\n      }) +\n      '-' +\n      currentDateTime.getDate().toLocaleString('en-US', {\n        minimumIntegerDigits: 2,\n        useGrouping: false,\n      }) +\n      ' ' +\n      currentDateTime.getHours().toLocaleString('en-US', {\n        minimumIntegerDigits: 2,\n        useGrouping: false,\n      }) +\n      ':' +\n      currentDateTime.getMinutes().toLocaleString('en-US', {\n        minimumIntegerDigits: 2,\n        useGrouping: false,\n      }) +\n      ':' +\n      currentDateTime.getSeconds().toLocaleString('en-US', {\n        minimumIntegerDigits: 2,\n        useGrouping: false,\n      });\n  }\n\n  destroy() {\n    this.metrics.clear();\n    if (this.mxcell.GF_tooltipHandler) {\n      delete this.mxcell.GF_tooltipHandler;\n    }\n  }\n\n  getDiv(parentDiv: HTMLDivElement): HTMLDivElement | null {\n    if (this.div !== null && this.div !== undefined) {\n      if (parentDiv && this.div) {\n        parentDiv.appendChild(this.div);\n      }\n      return this.div;\n    }\n    if (!this.checked) {\n      return null;\n    }\n    const div = document.createElement('div');\n    if (parentDiv !== undefined) {\n      parentDiv.appendChild(div);\n    }\n    if (this.metrics.size > 0) {\n      this.getDateDiv(div);\n      this.metrics.forEach((metric: MetricTooltip) => {\n        metric.getDiv(div);\n      });\n    }\n    this.div = div;\n    return div;\n  }\n\n  getDateDiv(parentDiv: HTMLDivElement) {\n    const div = document.createElement('div');\n    div.id = this.mxcell.mxObjectId + '_DATE';\n    if (parentDiv !== undefined) {\n      parentDiv.appendChild(div);\n    }\n    div.className = 'graph-tooltip-time tooltip-date';\n    div.innerHTML = `${this.lastChange}`;\n    return div;\n  }\n}\n\n/**\n * Create a metric for tooltip\n *\n * @class MetricTooltip\n */\nexport class MetricTooltip {\n  color: string;\n  graphs: Set<GraphTooltip>;\n  label: string;\n  value: string;\n  direction: gf.TDirectionKeys = 'v';\n  div: HTMLDivElement | undefined;\n  constructor() {\n    this.color = '#8c8980';\n    this.graphs = new Set();\n    this.label = '';\n    this.value = '';\n  }\n\n  setLabel(label: string): this {\n    this.label = label;\n    return this;\n  }\n\n  setValue(value: string): this {\n    this.value = value;\n    return this;\n  }\n\n  setColor(color: string | null): this {\n    if (color !== null) {\n      this.color = color;\n    }\n    return this;\n  }\n\n  setDirection(direction: gf.TDirectionKeys): this {\n    this.direction = direction;\n    return this;\n  }\n\n  getDiv(parentDiv: HTMLDivElement): HTMLDivElement {\n    const div = document.createElement('div');\n    div.className = 'tooltip-metric';\n    if (this.direction === 'h') {\n      div.style.display = 'inline-block';\n    }\n    if (parentDiv !== undefined) {\n      parentDiv.appendChild(div);\n    }\n    this.div = div;\n    this.getTextDiv(div);\n    this.getGraphsDiv(div);\n    return div;\n  }\n\n  getTextDiv(parentDiv: HTMLDivElement): HTMLDivElement {\n    const div = document.createElement('div');\n    div.className = 'tooltip-text';\n    let str = '';\n    if (parentDiv !== undefined) {\n      parentDiv.appendChild(div);\n    }\n    if (this.label !== undefined) {\n      str += `${this.label} : `;\n      str += `<span style=\"color:${this.color}\"><b>${this.value}</b></span>`;\n    }\n    div.innerHTML = str;\n    return div;\n  }\n\n  getGraphsDiv(parentDiv: HTMLDivElement): HTMLDivElement {\n    const div = document.createElement('div');\n    if (parentDiv !== undefined) {\n      parentDiv.appendChild(div);\n    }\n    if (this.graphs.size > 0) {\n      this.graphs.forEach(graph => {\n        graph.getDiv(div);\n      });\n    }\n    return div;\n  }\n\n  addGraph(type: gf.TGraphTypeKeys): GraphTooltip {\n    let graph: GraphTooltip;\n    switch (type) {\n      case 'line':\n        graph = new LineGraphTooltip();\n        break;\n      case 'bar':\n        graph = new BarGraphTooltip();\n        break;\n      default:\n        $GF.log.error('Graph type unknow', type);\n        graph = new BarGraphTooltip();\n        break;\n    }\n    this.graphs.add(graph);\n    return graph;\n  }\n}\n\n/**\n * Create a graph for tooltip\n *\n * @class GraphTooltip\n */\nexport class GraphTooltip {\n  color = '#8c8980';\n\n  type: gf.TGraphTypeKeys = 'line';\n  data: Chartist.IChartistData = {\n    series: [\n      {\n        data: [{ x: 0, y: 0 }],\n      },\n    ],\n  };\n  name: string | undefined;\n  column: string | undefined;\n  size: gf.TGraphSizeKeys = '100%';\n  metric: Metric | undefined;\n  low: number | null = null;\n  high: number | null = null;\n  scaleType: gf.TGraphScaleKeys = 'linear';\n  div: HTMLDivElement | undefined;\n  chart: any;\n  parentDiv: HTMLDivElement | undefined;\n  constructor() {}\n\n  getDiv(div: HTMLDivElement): HTMLDivElement | undefined {\n    return this.div;\n  }\n\n  setName(name: string): this {\n    this.name = name;\n    return this;\n  }\n\n  setColumn(column: string): this {\n    this.column = column;\n    return this;\n  }\n\n  setType(type: gf.TGraphTypeKeys): this {\n    this.type = type;\n    return this;\n  }\n\n  setSize(size: gf.TGraphSizeKeys): this {\n    this.size = size;\n    return this;\n  }\n\n  setMetric(metric: any): this {\n    this.metric = metric;\n    return this;\n  }\n\n  setScaling(low: number | null, high: number | null): this {\n    this.low = low;\n    this.high = high;\n    return this;\n  }\n\n  setScale(type: gf.TGraphScaleKeys) {\n    this.scaleType = type;\n  }\n\n  setColor(color: string | null): this {\n    if (color !== null) {\n      this.color = color;\n    }\n    return this;\n  }\n\n  setParentDiv(div: HTMLDivElement): this {\n    this.parentDiv = div;\n    return this;\n  }\n\n  getChart() {\n    return this.chart;\n  }\n}\n\n/**\n * tooltip for line graph\n *\n * @class LineGraphTooltip\n * @extends {GraphTooltip}\n */\nclass LineGraphTooltip extends GraphTooltip {\n  chartistOptions: Chartist.ILineChartOptions;\n  div: HTMLDivElement | undefined;\n  // data: { series: Array<{ x: any; y: any }>[] } | undefined;\n  chart: Chartist.IChartistLineChart | undefined;\n  /**\n   * Creates an instance of LineGraphTooltip.\n   * @memberof LineGraphTooltip\n   */\n  constructor() {\n    super();\n    this.type = 'line';\n    this.chartistOptions = {\n      showPoint: false,\n      showLine: true,\n      showArea: true,\n      fullWidth: true,\n      axisX: {\n        showGrid: false,\n        showLabel: false,\n        offset: 0,\n      },\n      axisY: {\n        showGrid: false,\n        showLabel: false,\n        offset: 0,\n      },\n      chartPadding: { top: 0, left: 0, right: 0, bottom: 0 },\n    };\n  }\n\n  /**\n   * get current Div\n   *\n   * @param {HTMLDivElement} parentDiv\n   * @returns {HTMLDivElement}\n   * @memberof LineGraphTooltip\n   */\n  getDiv(parentDiv: HTMLDivElement): HTMLDivElement {\n    if (this.metric) {\n      let log = this.scaleType === 'log' ? true : false;\n      this.data.series[0]['data'] = this.metric.getData(this.column, log);\n    }\n    const div = document.createElement('div');\n    const color = this.color;\n    // const svg = '<svg style=\"width:0;height:0;position:absolute;\" aria-hidden=\"true\" focusable=\"false\">  <linearGradient id=\"my-cool-gradient\" x2=\"1\" y2=\"1\">    <stop offset=\"0%\" stop-color=\"#447799\" />    <stop offset=\"50%\" stop-color=\"#224488\" />    <stop offset=\"100%\" stop-color=\"#112266\" />  </linearGradient></svg>';\n    this.div = div;\n    if (parentDiv !== undefined) {\n      parentDiv.appendChild(div);\n    }\n    div.className = 'ct-chart ct-golden-section';\n    if (this.size !== null) {\n      div.style.width = this.size;\n    }\n    if (this.low !== null) {\n      this.chartistOptions.low = this.low;\n    }\n    if (this.high !== null) {\n      this.chartistOptions.high = this.high;\n    }\n\n    this.chart = new Chartist.Line(div, this.data, this.chartistOptions);\n    this.chart.on('draw', (data: any) => {\n      if (data.type === 'line' || data.type === 'area') {\n        if (data.type === 'line') {\n          data.element.attr({\n            style: `stroke: ${color}`,\n          });\n        }\n        if (data.type === 'area') {\n          data.element.attr({\n            style: `fill: ${color}`,\n          });\n        }\n        data.element.animate({\n          d: {\n            begin: 1000 * data.index,\n            dur: 1000,\n            from: data.path\n              .clone()\n              .scale(1, 0)\n              .translate(0, data.chartRect.height())\n              .stringify(),\n            to: data.path.clone().stringify(),\n            easing: Chartist.Svg.Easing.easeOutQuint,\n          },\n        });\n      }\n    });\n    return div;\n  }\n}\n\n/**\n * Tooltip for Histogram\n *\n * @class BarGraphTooltip\n * @extends {GraphTooltip}\n */\nclass BarGraphTooltip extends GraphTooltip {\n  chartistOptions: Chartist.IBarChartOptions;\n  chart: Chartist.IChartistBarChart | undefined;\n  /**\n   * Creates an instance of BarGraphTooltip.\n   * @memberof BarGraphTooltip\n   */\n  constructor() {\n    super();\n    this.type = 'bar';\n    this.chartistOptions = {\n      axisX: {\n        showGrid: false,\n        showLabel: false,\n        offset: 0,\n      },\n      axisY: {\n        showGrid: false,\n        showLabel: false,\n        offset: 0,\n      },\n      chartPadding: { top: 0, left: 0, right: 0, bottom: 0 },\n    };\n  }\n\n  /**\n   * Get current div\n   *\n   * @param {HTMLDivElement} parentDiv\n   * @returns {HTMLDivElement}\n   * @memberof BarGraphTooltip\n   */\n  getDiv(parentDiv: HTMLDivElement): HTMLDivElement {\n    if (this.metric) {\n      let log = this.scaleType === 'log' ? true : false;\n      this.data.series[0]['data'] = this.metric.getData(this.column, log);\n    }\n    const div = document.createElement('div');\n    const color = this.color;\n    this.div = div;\n    if (parentDiv !== undefined) {\n      parentDiv.appendChild(div);\n    }\n    div.className = 'ct-chart ct-golden-section';\n    if (this.size !== null) {\n      div.style.width = this.size;\n    }\n    if (this.low !== null) {\n      this.chartistOptions.low = this.low;\n    }\n    if (this.high !== null) {\n      this.chartistOptions.high = this.high;\n    }\n\n    this.chart = new Chartist.Bar(div, this.data, this.chartistOptions);\n    let seq = 0;\n    const length = this.data.series[0]['data'].length;\n    const delays = Math.round(50 / (length / 10));\n    const durations = Math.round(250 / (length / 10));\n    this.chart.on('draw', (data: any) => {\n      if (data.type === 'bar') {\n        data.element.attr({\n          style: `stroke: ${color}`,\n        });\n        seq++;\n        data.element.animate({\n          opacity: {\n            begin: seq * delays,\n            dur: durations,\n            from: 0,\n            to: 1,\n            easing: 'ease',\n          },\n        });\n      }\n    });\n    return div;\n  }\n}\n","const pako = require('pako');\nconst vkbeautify = require('vkbeautify');\nconst safeEval = require('safe-eval');\n\n// sources :\n// https://jgraph.github.io/drawio-tools/tools/convert.html\n\nmodule.exports = {\n  stringToBytes(str) {\n    const arr = new Array(str.length);\n\n    for (let i = 0; i < str.length; i += 1) {\n      arr[i] = str.charCodeAt(i);\n    }\n\n    return arr;\n  },\n  bytesToString(arr) {\n    let str = '';\n\n    for (let i = 0; i < arr.length; i += 1) {\n      str += String.fromCharCode(arr[i]);\n    }\n    return str;\n  },\n  encode(data, encode, deflate, base64) {\n    let result = data;\n    if (encode) {\n      try {\n        result = encodeURIComponent(result);\n      } catch (e) {\n        console.error(e);\n        return;\n      }\n    }\n\n    if (deflate && result.length > 0) {\n      try {\n        result = this.bytesToString(pako.deflateRaw(result));\n      } catch (e) {\n        console.error(e);\n        return;\n      }\n    }\n\n    if (base64) {\n      try {\n        result = btoa(result);\n      } catch (e) {\n        console.error(e);\n        return;\n      }\n    }\n    return result;\n  },\n\n  removeLinebreaks(data) {\n    return data.replace(/(\\r\\n|\\n|\\r)/gm, '');\n  },\n\n  isencoded(data) {\n    try {\n      const node = this.parseXml(data).documentElement;\n      if (node != null && node.nodeName === 'mxfile') {\n        const diagrams = node.getElementsByTagName('diagram');\n        if (diagrams.length > 0) {\n          return true;\n        }\n      } else {\n        return data.indexOf('mxGraphModel') === -1;\n      }\n    } catch (error) {\n      return true;\n    }\n    return false;\n  },\n\n  decode(data, encode, deflate, base64) {\n    try {\n      const node = this.parseXml(data).documentElement;\n\n      if (node != null && node.nodeName === 'mxfile') {\n        const diagrams = node.getElementsByTagName('diagram');\n\n        if (diagrams.length > 0) {\n          data = this.getTextContent(diagrams[0]);\n        }\n      }\n    } catch (e) {\n      // ignore\n    }\n\n    if (base64) {\n      data = atob(data);\n    }\n\n    if (deflate && data.length > 0) {\n      data = this.bytesToString(pako.inflateRaw(data));\n    }\n\n    if (encode) {\n      data = decodeURIComponent(data);\n    }\n\n    return data;\n  },\n\n  parseXml(xml) {\n    if (window.DOMParser) {\n      const parser = new DOMParser();\n\n      return parser.parseFromString(xml, 'text/xml');\n    }\n    const result = this.createXmlDocument();\n    result.async = 'false';\n    result.loadXML(xml);\n    return result;\n  },\n\n  createXmlDocument() {\n    let doc = null;\n\n    if (document.implementation && document.implementation.createDocument) {\n      doc = document.implementation.createDocument('', '', null);\n    } else if (window.ActiveXObject) {\n      doc = new ActiveXObject('Microsoft.XMLDOM');\n    }\n\n    return doc;\n  },\n\n  decodeFromUri(data) {\n    try {\n      data = decodeURIComponent(data);\n    } catch (e) {\n      console.error(e);\n      return;\n    }\n    return data;\n  },\n\n  getTextContent(node) {\n    return node != null ? node[node.textContent === undefined ? 'text' : 'textContent'] : '';\n  },\n\n  normalizeXml(data) {\n    try {\n      let str = data;\n      str = str.replace(/>\\s*/g, '>'); // Replace \"> \" with \">\"\n      str = str.replace(/\\s*</g, '<'); // Replace \"< \" with \"<\"\n      return data;\n    } catch (e) {\n      return;\n    }\n  },\n\n  async sleep(ms, mess) {\n    function delay(ms) {\n      return new Promise(resolve => setTimeout(resolve, ms));\n    }\n    await delay(ms);\n    if (mess) {\n      console.log(mess);\n    }\n  },\n\n  uniqueID() {\n    function chr4() {\n      return Math.random()\n        .toString(16)\n        .slice(-4);\n    }\n    return `${chr4() + chr4()}-${chr4()}-${chr4()}-${chr4()}-${chr4()}${chr4()}${chr4()}`;\n  },\n\n  stringToJsRegex(str) {\n    if (str[0] !== '/') {\n      return new RegExp(`^${str}$`);\n    }\n    const match = str.match(new RegExp('^/(.*?)/(g?i?m?y?)$'));\n    return new RegExp(match[1], match[2]);\n  },\n\n  matchString(str, pattern, regex = true) {\n    if (str === null || str === undefined || pattern === null || pattern === undefined || str.length === 0 || pattern.length === 0) {\n      return false;\n    }\n    if (str === pattern) {\n      return true;\n    }\n    if (regex) {\n      const regex = this.stringToJsRegex(pattern);\n      return str.toString().match(regex);\n    }\n    return false;\n  },\n\n  minify(text) {\n    try {\n      return vkbeautify.xmlmin(text, false);\n    } catch (error) {\n      this.log(3, 'Error in minify', error);\n      return text;\n    }\n  },\n\n  prettify(text) {\n    try {\n      return vkbeautify.xml(text);\n    } catch (error) {\n      this.log(3, 'Error in prettify', error);\n      return text;\n    }\n  },\n  prettifyJSON(text) {\n    try {\n      return vkbeautify.json(text);\n    } catch (error) {\n      this.log(3, 'Error in prettify', error);\n      return text;\n    }\n  },\n\n  addScript(src) {\n    var s = document.createElement('script');\n    s.setAttribute('type', 'text/javascript');\n    s.setAttribute('src', src);\n    var r = false;\n    var t = document.getElementsByTagName('script')[0];\n\n    if (t != null) {\n      t.parentNode.insertBefore(s, t);\n    }\n  },\n\n  loadJS(fname) {\n    try {\n      var code = this.loadFile(fname)\n      if (code) {\n        this.evalRaw(code);\n        // console.info('LoadJS called succesfully', fname);\n      }\n    } catch (e) {\n      if (window.console != null) {\n        console.error('LoadJS failed:', fname, e);\n      }\n    }\n  },\n\n  loadFile(fname) {\n    try {\n      var req = mxUtils.load(fname);\n      if (req != null && req.getStatus() >= 200 && req.getStatus() <= 299) {\n        // console.info('loadFile called succesfully', fname);\n        return req.getText();\n      }\n    } catch (e) {\n      if (window.console != null) {\n        console.error('Error loadFile:', fname, e);\n      }\n    }\n  },\n\n  $loadFile(fname) {\n    let result;\n    $.ajax({\n      type: 'GET',\n      url: fname,\n      async: false,\n      success: data => {\n        result = data;\n      },\n      error: error => {\n        console.log('Error when download ' + fname), error;\n      },\n    });\n    return result;\n  },\n\n  $evalFile(fname) {\n    let result;\n    $.ajax({\n      type: 'GET',\n      url: fname,\n      async: false,\n      success: data => {\n        eval.call(window, data);\n      },\n      error: error => {\n        console.log('Error when download/eval ' + fname), error;\n      },\n    });\n  },\n\n  evalRaw(code) {\n    try {\n      eval.call(window, code);\n      // console.info('eval.call succesfully');\n    } catch (e) {\n      if (window.console != null) {\n        console.error('Error eval.call : ', e);\n      }\n    }\n  },\n\n  evalIt(code) {\n    let result = code;\n    try {\n      result = safeEval(code);\n    } catch (error) {\n      result = code;\n    }\n    return result;\n  },\n\n  getfileContent(url) {\n    let result;\n    const request = async () => {\n      const response = await fetch(url);\n      const result = await response.text();\n      console.log(getfileContent, url, result);\n    };\n    request();\n    return result;\n  },\n};\n","module.exports = __WEBPACK_EXTERNAL_MODULE__grafana_data__;","module.exports = __WEBPACK_EXTERNAL_MODULE_grafana_app_core_app_events__;","module.exports = __WEBPACK_EXTERNAL_MODULE_grafana_app_core_time_series2__;","module.exports = __WEBPACK_EXTERNAL_MODULE_grafana_app_core_utils_kbn__;","module.exports = __WEBPACK_EXTERNAL_MODULE_grafana_app_plugins_sdk__;","module.exports = __WEBPACK_EXTERNAL_MODULE_lodash__;"],"sourceRoot":""}